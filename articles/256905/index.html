<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Writing Your Spliterator</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Many of you have already tasted the Stream API - Java 8 streams. Certainly, some have a desire not only to use ready streams from collections, arrays,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Writing Your Spliterator</h1><div class="post__text post__text-html js-mediator-article">  Many of you have already tasted the Stream API - Java 8 streams. Certainly, some have a desire not only to use ready streams from collections, arrays, random numbers, but also to create some kind of fundamentally new stream.  To do this you need to write your splitter.  <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Spliterator.html">Spliterator</a> is the filling of the stream, the public part of its internal logic.  In this article I will tell you how and why I wrote the splitter. <br><a name="habracut"></a><br><h3>  What is the splitter </h3><br>  A splitter is an interface that contains 8 methods, four of which already have a default implementation.  The remaining methods are <code>tryAdvance</code> , <code>trySplit</code> , <code>estimateSize</code> and <code>characteristics</code> .  There are also special modifications of the splitter for the primitive types <code>int</code> , <code>long</code> and <code>double</code> : they add a few additional methods to avoid boxing.  A splitter is like an ordinary iterator.  The main difference - the ability to split (split) into two parts - underlies the parallel operation of threads.  Also, in order to optimize, the splitter has a number of characteristic flags and can report exactly or approximately its size.  Finally, the splitter never modifies a data source: it does not have a <code>remove</code> method like an iterator.  Consider the methods in more detail: <br><br><ul><li>  <b>tryAdvance (Consumer)</b> - combining the <code>hasNext()</code> and <code>next()</code> iterator methods.  If the splitter has the following element, it must call the passed function with this element and return <code>true</code> , otherwise the function will not be called and return <code>false</code> . </li><li>  <b>trySplit ()</b> - try to share in two.  The method returns a new splitter that will run through the first half of the original data set, while the current splitter itself jumps to the second half.  It is best when the halves are approximately equal, but this is not necessary.  Splitorators with an infinite set of data are particularly unevenly divided: after dividing one of the splitters will process a finite volume, and the second remains infinite.  The <code>trySplit()</code> method has the legal right not to share and return <code>null</code> (try not there by chance).  This is usually done when there is little data left in the current splitter (say, only one element). </li><li>  <b>characteristics ()</b> - returns the bit mask of the characteristics of the splitter.  There are eight of them at the moment: <br><ol><li>  ORDERED - if the order of the data matters.  For example, the splitter from <code>HashSet</code> does not have this characteristic, because the order of the data in <code>HashSet</code> depends on the implementation.  The absence of this characteristic will automatically transfer the parallel stream to an unordered mode, so that it can work faster.  Since there was no order in the data source, then you can not follow it further. </li><li>  DISTINCT - if the elements are known to be unique.  Any <code>Set</code> or stream after the <code>distinct()</code> operation <code>distinct()</code> creates a splitter with this characteristic.  For example, the operation <code>distinct()</code> on the stream from <code>Set</code> will not be performed at all and, therefore, it will not take too much time. </li><li>  SORTED - if items are sorted.  In this case, be sure to return both ORDERED and override the <code>getComparator()</code> method, returning a sorting comparator or null for " <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Comparable.html">natural order</a> ".  Sorted collections (for example, a <code>TreeSet</code> ) create a splitter with this characteristic, and with it the streaming operation <code>sorted()</code> can be skipped. </li><li>  SIZED - if the exact number of splitter elements is known.  This characteristic is returned by splitters of all collections.  After some streaming operations (for example, <code>map()</code> or <code>sorted()</code> ) it is saved, and after others (say, <code>filter()</code> or <code>distinct()</code> ) it is lost.  It is useful for sorting or, say, the operation <code>toArray()</code> : you can pre-allocate an array of the desired size, rather than guess how many elements you need. </li><li>  SUBSIZED - if it is known that all child splitters will also know their size.  This characteristic is returned by the splitter from the <code>ArrayList</code> , because when dividing it simply breaks the range of values ‚Äã‚Äãinto two ranges of known length.  But <code>HashSet</code> will not return it, because it breaks the hash table, for which it is not known how many elements are contained in each half.  Accordingly, child splitters will no longer return SIZED. </li><li>  NONNULL - if it is known that among the elements there is no <code>null</code> .  This characteristic is returned, for example, by the splitter created by <code>ConcurrentSkipListSet</code> : you cannot put <code>null</code> in this data structure.  It is also returned by all splitters created on primitive types. </li><li>  IMMUTABLE - if it is known that the source of the data during the crawling process cannot be changed.  Splitors from ordinary collections do not return such a characteristic, but it is issued, for example, by the splitter from <code>Collections.singletonList()</code> , because this list cannot be changed. </li><li>  CONCURRENT - if it is known that the splitter remains working after any source changes.  This characteristic is reported by the splitter collections from <code>java.util.concurrent</code> .  If the splitter does not have the characteristics of IMMUTABLE and CONCURRENT, then it would be good to make it work in fail-fast mode so that it throws a <code>ConcurrentModificationException</code> if it notes that the source has changed. </li></ol>  As far as I know, the last three characteristics are now not used by threads in any way (including in Java 9 code). </li><li>  <b>The estimateSize ()</b> method should return the number of remaining elements for SIZED-splitters and estimate as closely as possible in other cases.  For example, if we create a splitter from <code>HashSet</code> and divide it with <code>trySplit()</code> , <code>estimateSize()</code> will return half of the original size of the collection, although the actual number of elements in half of the hash table may be different.  If there are an infinite number of items, or count them too <code>Long.MAX_VALUE</code> , you can return <code>Long.MAX_VALUE</code> . </li></ul><br>  Creating a stream over an existing splitter is very easy - you need to call <a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/StreamSupport.html">StreamSupport.stream ()</a> . <br><br><h3>  When it is not necessary to write a splitrator </h3><br>  The main thing is to understand that by itself you do not need a splitter, you need a stream.  If you can create a stream using existing functionality, then you should do just that.  For example, you want to make friends with XML DOM threads and create a stream using a <code>NodeList</code> .  There is no standard such method, but it is easy to write it without additional splitters: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">XmlStream</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Stream&lt;Node&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">of</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(NodeList list)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> IntStream.range(<span class="hljs-number"><span class="hljs-number">0</span></span>, list.getLength()).mapToObj(list::item); } }</code> </pre> <br>  Similarly, you can add threads to any non-standard collection (another example - <code>org.json.JSONArray</code> ), which can quickly return the length and the element by its ordinal number. <br><br>  If you find it difficult or too lazy to write <code>trySplit</code> , you'd better not write the splitter at all.  Here is one friend <a href="https://github.com/poetix/protonpack/tree/master/src/main/java/com/codepoetics/protonpack">writing</a> the protonpack library, completely ignoring the existence of parallel threads.  He wrote a lot of splitters that don‚Äôt know how to share at all.  A splitter that does not share at all is a bad, worthless splitter.  Do not do this.  In this case, it is better to write an ordinary iterator and create a splitter on it using the <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Spliterators.html">Spliterators.spliterator</a> methods or, if you do not know the size of the collection, then <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Spliterators.html">Spliterators.spliteratorUnknownSize</a> .  These methods have at least some sort of heuristics for division: they bypass a part of the iterator by reading it into an array and creating a new splitter for this array.  If the stream continues with a lengthy operation, then parallelization will still speed up the work. <br><br>  If you implement the standard <code>Iterable</code> interface or <code>Collection</code> , then you get a free <code>default</code> <code>spliterator()</code> .  It is worth, of course, to see if it can be improved.  One way or another, you rarely need to write your splitters.  This can be useful if you are developing your data structure (for example, a collection on primitives, as <a href="https://habrahabr.ru/users/leventov/" class="user_link">leventov</a> does). <br><br><h3>  And still write </h3><br>  We will write a new splitter to solve this problem: for a given stream, create a stream of pairs from neighboring values ‚Äã‚Äãof the original stream.  Since there is no generally accepted type for representing a pair of values ‚Äã‚Äãin Java and there are too many options (use an array of two values, a list of two values, <code>Map.Entry</code> with the same key and value type, etc.), we will give it to the user : let him decide how to combine the two values.  That is, we want to create a method with the following signature: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;T, R&gt; <span class="hljs-function"><span class="hljs-function">Stream&lt;R&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pairMap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Stream&lt;T&gt; stream, BiFunction&lt;T, T, R&gt; mapper)</span></span></span><span class="hljs-function"> </span></span>{...}</code> </pre> <br>  With it, you can use any type to represent a pair.  For example, if we want <code>Map.Entry</code> : <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;T&gt; Stream&lt;Map.Entry&lt;T, T&gt;&gt; pairs(Stream&lt;T&gt; stream) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> pairMap(stream, AbstractMap.SimpleImmutableEntry&lt;T, T&gt;::<span class="hljs-keyword"><span class="hljs-keyword">new</span></span>); }</code> </pre> <br>  In general, you can immediately calculate something interesting without folding the pair into an intermediate container: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Stream&lt;Integer&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">diff</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Stream&lt;Integer&gt; stream)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> pairMap(stream, (a, b) -&gt; b - a); }</code> </pre> <br>  This method on a stream of integers will return a stream of differences of neighboring elements.  As you might guess, in the final stream there will be one element less than in the initial one. <br><br>  We want our <code>pairMap</code> look like a normal intermediate ( <a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html">intermediate</a> ) operation, that is, in fact, no calculations should be performed until it reaches the terminal operation.  To do this, you need to take the <code>spliterator</code> at the input stream, but do nothing with it until we are asked.  Another small, but important thing: when you close a new stream through <code>close()</code> you must close the original stream.  As a result, our method may look like this: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;T, R&gt; <span class="hljs-function"><span class="hljs-function">Stream&lt;R&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pairMap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Stream&lt;T&gt; stream, BiFunction&lt;T, T, R&gt; mapper)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> StreamSupport.stream(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PairSpliterator&lt;&gt;(mapper, stream.spliterator()), stream.isParallel()).onClose(stream::close); }</code> </pre> <br>  The initial stream after calling the <code>spliterator()</code> method becomes ‚Äúused‚Äù, you cannot cook any more porridge with it.  But this is normal: this is the case with all intermediate threads when you add a new operation.  The <a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html">Stream.concat ()</a> method, which <a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html">merges</a> two streams, looks about the same.  It remains to write myself <code>PairSpliterator</code> . <br><br><h3>  Getting to the point </h3><br>  The simplest thing is to write the <code>characteristics()</code> method.  Some of the characteristics are inherited from the original splitter, but it is necessary to reset NONNULL, DISTINCT and SORTED: we cannot guarantee these characteristics after applying an arbitrary mapper function: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">characteristics</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> source.characteristics() &amp; (SIZED | SUBSIZED | CONCURRENT | IMMUTABLE | ORDERED); }</code> </pre> <br>  The implementation of the <code>tryAdvance</code> method should be fairly simple.  It is only necessary to read the data from the source splitter, memorizing the previous element in the intermediate buffer, and call the <code>mapper</code> for the last pair.  One has only to remember whether we are at the beginning of the stream or not.  For this, the boolean <code>hasPrev</code> variable is <code>hasPrev</code> , indicating whether we have a previous value. <br><br>  The <code>trySplit</code> method <code>trySplit</code> best implemented by calling <code>trySplit</code> on the source splitter.  The main difficulty here is to process a pair at the junction of two separated pieces of the original stream.  This pair should be processed by a splitter that bypasses the first half.  Accordingly, he must keep the first value from the second half and, when he gets to the end, work again, submitting it to the <code>mapper</code> along with his last value. <br><br>  Having dealt with this, we will write the constructors: <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PairSpliterator</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">R</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Spliterator</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">R</span></span></span><span class="hljs-class">&gt; </span></span>{ Spliterator&lt;T&gt; source; <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> hasLast, hasPrev; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> T cur; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> T last; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> BiFunction&lt;T, T, R&gt; mapper; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PairSpliterator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(BiFunction&lt;T, T, R&gt; mapper, Spliterator&lt;T&gt; source)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>(mapper, source, <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PairSpliterator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(BiFunction&lt;T, T, R&gt; mapper, Spliterator&lt;T&gt; source, T prev, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hasPrev, T last, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hasLast)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.source = source; <span class="hljs-comment"><span class="hljs-comment">//   this.hasLast = hasLast; //       (   ) this.hasPrev = hasPrev; //     this.cur = prev; //   this.last = last; //     this.mapper = mapper; } // ... }</span></span></code> </pre> <br>  The <code>tryAdvance</code> method (instead of lambda for transmission to the original <code>tryAdvance</code> use the reference to the setter): <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setCur</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T t)</span></span></span><span class="hljs-function"> </span></span>{ cur = t; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tryAdvance</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Consumer&lt;? </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">super</span></span></span></span><span class="hljs-function"><span class="hljs-params"> R&gt; action)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!hasPrev) { <span class="hljs-comment"><span class="hljs-comment">//    :      if (!source.tryAdvance(this::setCur)) { return false; //    ‚Äî  } hasPrev = true; } T prev = cur; //    if (!source.tryAdvance(this::setCur)) { //     if (!hasLast) return false; //    ‚Äî  hasLast = false; //       cur = last; } action.accept(mapper.apply(prev, cur)); //   action  mapper' return true; }</span></span></code> </pre> <br>  Here is the <code>trySplit()</code> method: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Spliterator&lt;R&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">trySplit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Spliterator&lt;T&gt; prefixSource = source.trySplit(); <span class="hljs-comment"><span class="hljs-comment">//    if (prefixSource == null) return null; //   ‚Äî       T prev = cur; //       ,     if (!source.tryAdvance(this::setCur)) { //      source = prefixSource; //      ‚Äî    return null; } boolean oldHasPrev = hasPrev; hasPrev = true; //      ,      return new PairSpliterator&lt;&gt;(mapper, prefixSource, prev, oldHasPrev, cur, true); }</span></span></code> </pre> <br>  It is easy to write <code>estimateSize()</code> : if the source splitter is able to estimate its size, you just need to check the flags and tweak it one way or the other: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">estimateSize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> size = source.estimateSize(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (size == Long.MAX_VALUE) <span class="hljs-comment"><span class="hljs-comment">//       ‚Äî     return size; if (hasLast) //          size++; if (!hasPrev &amp;&amp; size &gt; 0) //        size--; return size; }</span></span></code> </pre> <br>  In this form, this splitter and <a href="">got</a> into my library StreamEx.  The only difference is that it took to make versions for primitive types, and <code>pairMap</code> is not a static method. <br><br><h3>  All this, probably, strongly brakes? </h3><br>  With speed it's not so bad.  Take for example the following <a href="http://stackoverflow.com/q/30089761/4856258">problem</a> with StackOverflow: from the given set of <code>Integer</code> numbers, leave only those that are smaller than the number following them, and save the result to a new list.  The task itself is very simple, so a significant portion of the time will go to the overhead.  You can offer two naive implementations: through an iterator (will work with any collection) and through access by item number (will work only with a list with quick random access).  Here is an option with an iterator (naiveIterator): <br><br><pre> <code class="java hljs">List&lt;Integer&gt; result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(); Integer last = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Integer cur : input) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (last != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; last &lt; cur) result.add(last); last = cur; }</code> </pre> <br>  But with random access (naiveGet): <br><br><pre> <code class="java hljs">List&lt;Integer&gt; result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; input.size() - <span class="hljs-number"><span class="hljs-number">1</span></span>; i++) { Integer cur = input.get(i), next = input.get(i + <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cur &lt; next) result.add(cur); }</code> </pre> <br>  The solution using the StreamEx library is very compact and works with any data source (streamEx): <br><br><pre> <code class="java hljs">List&lt;Integer&gt; result = StreamEx.of(input).pairMap((a, b) -&gt; a &lt; b ? a : <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>).nonNull().toList();</code> </pre> <br>  Commentators suggested three more working solutions.  The largest number of votes gained more or less traditional, which at the entrance requires a list with random access (let's call this solution stream): <br><br><pre> <code class="java hljs">List&lt;Integer&gt; result = IntStream.range(<span class="hljs-number"><span class="hljs-number">0</span></span>, input.size() - <span class="hljs-number"><span class="hljs-number">1</span></span>).filter(i -&gt; input.get(i) &lt; input.get(i + <span class="hljs-number"><span class="hljs-number">1</span></span>)).mapToObj(input::get) .collect(Collectors.toList());</code> </pre> <br>  The following is reduce with a side effect that does not parallel (reduce): <br><br><pre> <code class="java hljs">List&lt;Integer&gt; result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(); input.stream().reduce((a, b) -&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a &lt; b) result.add(a); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> b; });</code> </pre> <br>  And the last thing is its own collector, which also does not parallel (collector): <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Collector&lt;Integer, ?, List&lt;Integer&gt;&gt; collectPrecedingValues() { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] holder = { Integer.MAX_VALUE }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Collector.of(ArrayList::<span class="hljs-keyword"><span class="hljs-keyword">new</span></span>, (l, elem) -&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (holder[<span class="hljs-number"><span class="hljs-number">0</span></span>] &lt; elem) l.add(holder[<span class="hljs-number"><span class="hljs-number">0</span></span>]); holder[<span class="hljs-number"><span class="hljs-number">0</span></span>] = elem; }, (l1, l2) -&gt; { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> UnsupportedOperationException(<span class="hljs-string"><span class="hljs-string">"Don't run in parallel"</span></span>); }); } List&lt;Integer&gt; result = input.stream().collect(collectPrecedingValues());</code> </pre> <br>  Parallel versions of stream and streamEx are also compared.  We will conduct the experiment on arrays of random integers of length n = 10 000, 100 000 and 1 000 000 elements (about half of the result will be in the result)  The complete JMH benchmark code is <a href="https://gist.github.com/amaembo/f683235194a59ae4f10c">here</a> .  It is checked that all algorithms produce the same result array. <br><br>  The measurements were carried out on a quad-core Core-i5.  The results look like this (all times in microseconds per operation, less is better): <br><table><tbody><tr><th>  Algorithm </th><th>  n = 10,000 </th><th>  n = 100,000 </th><th>  n = 1,000,000 </th></tr><tr><th>  naiveIterator </th><td>  97.7 </td><td>  904.0 </td><td>  10592.7 </td></tr><tr><th>  naiveGet </th><td>  99.8 </td><td>  1084.4 </td><td>  11424.2 </td></tr><tr><th>  collector </th><td>  112.5 </td><td>  1404.9 </td><td>  14387.2 </td></tr><tr><th>  reduce </th><td>  112.1 </td><td>  1139.5 </td><td>  12001.5 </td></tr><tr><th>  stream </th><td>  146.4 </td><td>  1624.1 </td><td>  16600.9 </td></tr><tr><th>  streamEx </th><td>  115.2 </td><td>  1247.1 </td><td>  12967.0 </td></tr><tr><th>  streamParallel </th><td>  56.9 </td><td>  582.3 </td><td>  6120.5 </td></tr><tr><th>  streamExParallel </th><td>  53.4 </td><td>  516.7 </td><td>  5353.4 </td></tr></tbody></table>  It can be seen that the version with pairMap (streamEx) overtakes both the traditional streaming version (stream) and the version with a collector, second only to the wrong reduce.  At the same time, the parallel version of streamEx is also faster than the parallel version of stream and significantly overtakes all sequential versions even for a small data set.  This is consistent with the rule of thumb from the <a href="http://gee.cs.oswego.edu/dl/html/StreamParallelGuidance.html">Stream Parallel Guidance</a> : it makes sense to parallel the task if it is executed for at least 100 microseconds. <br><br>  If you want to create your own streams, remember that it depends on a good splitter how your task will be paralleled.  If you do not want to bother with division, do not write the splitter at all, but use utility methods.  Also, do not write a new splitter if it is possible to create a stream using the existing JDK functionality.  If you have a good splitter, even a not very difficult task can be accelerated with parallel processing. </div><p>Source: <a href="https://habr.com/ru/post/256905/">https://habr.com/ru/post/256905/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../256889/index.html">The first acquaintance with the architecture of the collectible card game "Last Argument"</a></li>
<li><a href="../256893/index.html">Work with date and time in Perl6</a></li>
<li><a href="../256895/index.html">How to recover data from faulty SSD</a></li>
<li><a href="../256899/index.html">Announcement of the fourth meeting of the Java User Group EKB</a></li>
<li><a href="../256901/index.html">55 questions to ask when designing a logo</a></li>
<li><a href="../256907/index.html">How to fasten a tracing from the browser to any project</a></li>
<li><a href="../256909/index.html">NGINX 1.8 and 1.9 release</a></li>
<li><a href="../256911/index.html">PLC Ace: small controller for smart home</a></li>
<li><a href="../256915/index.html">Preparatory stage of software development</a></li>
<li><a href="../256917/index.html">Overview of the new Microsoft Azure Management Portal - Azure Preview</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>