<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Performance of simple and complex constructs in javascript</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Periodically, I ran into articles on JS code optimization ( one of the most popular ones ), and I caught myself thinking that there was too little inf...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Performance of simple and complex constructs in javascript</h1><div class="post__text post__text-html js-mediator-article">  Periodically, I ran into articles on JS code optimization ( <a href="http://blogs.msdn.com/ie/archive/2006/08/28/728654.aspx">one of the most popular ones</a> ), and I caught myself thinking that there was too little information in them.  Listed 2-3 designs, 1-2 browsers and everything on it. <br><br>  As they say, if you want to do something well, do it yourself. <br>  I decided to test, first of all for myself, the speed of work of various language constructs (starting with the most basic ones) in the main modern browsers and on the basis of this to draw conclusions about what and how to use in scripts that are demanding of performance. <br><br>  Well, since the results are obtained, why not put them for general use? 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>Upd:</b> added graphs of the results provided by <a href="http://habrahabr.ru/users/deerua/" class="user_link">deerua</a> (for those who perceive the visual presentation of information better than the table) <br><a name="habracut"></a><br><h1>  Introduction </h1><br>  So, the testing machine is P4 3GHz (dual core), 1.5RAM, Vista 32-bit. <br>  Browser set - FF3, Opera 9.62, Chrom 1.0, IE7, IE8b2 <br><br>  I have to say that IE8 is not original, but launched through the <a href="http://www.google.ru/search%3Fq%3DIETester%26ie%3Dutf-8%26oe%3Dutf-8%26aq%3Dt%26rls%3Dorg.mozilla:ru:official%26client%3Dfirefox-a">IETester</a> program. <br>  I do not know how much it corresponds to the original one, but at least the results differ quite strongly from IE7, and in different directions. <br><br>  If someone wants to test IE6 or any other browser (actually, welcome) <br><br><h1>  Testing Methodology </h1><br>  All of the language constructs described below were tested by repeating 1 million times in a loop.  This action was repeated several times in each browser in order to reveal a certain average result (it usually ranges from + -2-5% depending on the current system load).  The average result (in milliseconds) was recorded in the table. <br><br>  Everywhere (where nothing else is clearly indicated), the inverted for loop was used (var i = 1000000; i--;) as the fastest. <br><br><h1>  Getting down to business </h1><br><h2>  Cycles </h2><br><table width="974"><tbody><tr><td>  <b>Tests / Browsers</b> </td><td>  FF3 </td><td>  Opera </td><td>  Chrome </td><td>  IE7 </td><td>  IE8b2 </td></tr><tr><td>  <b>Cycles</b> </td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>  Classic cycle </td><td>  71 </td><td>  100 </td><td>  sixteen </td><td>  238 </td><td>  218 </td></tr><tr><td>  Inverted cycle </td><td>  34 </td><td>  34 </td><td>  7 </td><td>  70 </td><td>  118 </td></tr><tr><td>  while loop </td><td>  thirty </td><td>  33 </td><td>  7 </td><td>  70 </td><td>  118 </td></tr></tbody></table><br><img src="https://habrastorage.org/getpro/habr/post_images/7db/5f8/10b/7db5f810b6d637e69b22b9b0becc7aed.gif"><br>  So, for starters, I decided to test the cycles themselves (just empty loops with no executable code inside).  Because  say the basis of our testing) <br>  About cycles has already been written quite a lot, so that the results are quite predictable. <br>  As you can see, the inverted for loop (var i = 1000000; i--;) is at least twice as fast as the classical for (var i = 0; i &lt;1000000; i ++), so it was used in further testing. <br>  It can also be noted that while the cycle practically does not differ in speed from the inverted for, apparently because it is actually the same construction (according to the logic of operation). <br><br><h2>  Work with arrays and objects </h2><br><table width="974"><tbody><tr><td>  <b>Tests / Browsers</b> </td><td>  FF3 </td><td>  Opera </td><td>  Chrome </td><td>  IE7 </td><td>  IE8b2 </td></tr><tr><td>  <b>Search arrays and objects</b> </td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>  Getting the values ‚Äã‚Äãof a large array (1M) by index (full search in the reverse order) </td><td>  430 </td><td>  170 </td><td>  18 </td><td>  790 </td><td>  1020 </td></tr><tr><td>  Getting the value of a small array (100) by index </td><td>  124 </td><td>  146 </td><td>  18 </td><td>  428 </td><td>  515 </td></tr><tr><td>  For-in object loop (1M) </td><td>  2020 </td><td>  2160 </td><td>  385 </td><td>  39400 </td><td>  35400 </td></tr><tr><td>  Brute force (1M) through inverted loop </td><td>  390 </td><td>  170 </td><td>  18 </td><td>  745 </td><td>  746 </td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>  <b>Filling arrays and objects</b> </td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>  Filling (1M) array through array.length </td><td>  190 </td><td>  485 </td><td>  82 </td><td>  2640 </td><td>  865 </td></tr><tr><td>  Filling (1M) an array in direct order through the cycle step value (classic cycle) </td><td>  200 </td><td>  432 </td><td>  75 </td><td>  2500 </td><td>  760 </td></tr><tr><td>  Filling (1M) an array in reverse order through the cycle step value (inverted cycle) </td><td>  1180 </td><td>  310 </td><td>  124 </td><td>  2270 </td><td>  2260 </td></tr><tr><td>  Filling (1M) array via push () </td><td>  176 </td><td>  1120 </td><td>  98 </td><td>  4450 </td><td>  1186 </td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>  Filling an object (1M) in direct order through the value of the cycle step (classic cycle) </td><td>  1080 </td><td>  368 </td><td>  74 </td><td>  2400 </td><td>  2205 </td></tr></tbody></table><br><br>  This part is dedicated to working with arrays and substitute objects.  Under the replacement object in this test is meant an object (of type Object), which is used exclusively as a replacement for an array (that is, it does not contain any properties except for elements like an array).  I was interested in the speed of such substitutes. <br><br>  Array (or object) 1M - meaning array (or its substitute) with the number of elements equal to 1,000,000, and of indices (keys), respectively, from zero to a million (more precisely, 999,999). <br><br>  In the first test, we completely iterate over such an array in the inverted cycle, i.e.  something like this: <br>  var a = 0; <br>  for (var i = 1000000; i--;) {a = big_array [i];} <br><br>  In the second test, we also do a million iterations of the loop, but at each step we get the same value from a small array (100 elements in size).  I did this test to check how much the size of the array affects the speed of getting values ‚Äã‚Äãfrom it. <br>  As the test showed, in all browsers except Chrome, the search time for a value in an array can increase significantly with an increase in the number of its elements. <br><br>  In the third test, a complete for-in loop is done on the array substitute object. <br>  It is clearly seen that the for-in loop is very slow in all browsers (compared to inverted for), and VERY slow in IE for large amounts of data.  Never use it to iterate through arrays or objects where you can get by with the for loop (i.e., numeric and ordered keys). <br><br>  The fourth test is a complete analog of the first test, except that big_array is not an array but an object. <br>  It is noticeable that the speed of iteration through the loop weakly depends on whether we have an array or a substitute object.  There is only a tangible difference in IE8, but this is still a beta, so things can change. <br><img src="https://habrastorage.org/getpro/habr/post_images/32e/add/d0b/32eaddd0bc914665e70d21a66134aa02.gif"><br><br>  It is also worth noting that if we are faced with the task of choosing a range of array elements, then using the array.slice () method in any browser is several times faster than simply iterating over the array in a loop with sampling the necessary elements according to the condition.  The difference is so obvious that I did not even include it in the test. <br><br>  In addition to sorting arrays, you often have to fill them in, so the next 5 tests are just about that. <br>  In principle, everything should be clear from the table: <br><ul><li>  Filling an array using the push method is significantly slower in all browsers except FF, compared to filling via array [array.length] = value.  (The developers of firestone apparently were the only ones who understood that this is a complete disgrace when a bulky construction is used instead of the native method.) </li><li>  In some browsers, it is important whether you fill the array in direct or reverse order. </li><li>  Filling a replacement object is much slower in FF and IE8, apparently because the operation of filling the array is specially optimized, but filling the object is not (which is understandable, because the object should not be used instead of an array to store large amounts of uniform data). </li></ul><br><br><img src="https://habrastorage.org/getpro/habr/post_images/657/24e/eb6/65724eeb62db1ceec99367b8b250e737.gif"><br><br><h2>  Functions, Objects, Variables </h2><br><table width="974"><tbody><tr><td>  <b>Functions, Objects, Variables</b> </td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>  <b>Tests / Browsers</b> </td><td>  FF3 </td><td>  Opera </td><td>  Chrome </td><td>  IE7 </td><td>  IE8b2 </td></tr><tr><td>  Calling an empty function with passing it the current loop value </td><td>  129 </td><td>  270 </td><td>  17 </td><td>  3100 </td><td>  860 </td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>  Creating an object (creating 2 methods and one property through a constructor) </td><td>  2460 </td><td>  1900 </td><td>  593 </td><td>  18600 </td><td>  11,700 </td></tr><tr><td>  Creating an object (creating 2 methods from the prototype and one property through the constructor) </td><td>  1260 </td><td>  636 </td><td>  64 </td><td>  7830 </td><td>  4210 </td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>  Getting the property of an object (own property) </td><td>  84 </td><td>  142 </td><td>  sixteen </td><td>  406 </td><td>  412 </td></tr><tr><td>  Getting object property (prototype property) </td><td>  90 </td><td>  147 </td><td>  29 </td><td>  474 </td><td>  474 </td></tr><tr><td>  Getting object properties (getter method of private var properties) </td><td>  260 </td><td>  354 </td><td>  33 </td><td>  3430 </td><td>  1160 </td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>  Calling an incremental method of an object (increases its own property through this) </td><td>  326 </td><td>  460 </td><td>  60 </td><td>  3810 </td><td>  1520 </td></tr><tr><td>  Calling an incremental method of an object (increases its own property by explicitly specifying an object) </td><td>  356 </td><td>  520 </td><td>  65 </td><td>  3985 </td><td>  1633 </td></tr><tr><td>  Calling an incremental method of an object (increases the private var property) </td><td>  412 </td><td>  370 </td><td>  38 </td><td>  3530 </td><td>  1320 </td></tr></tbody></table><br><img src="https://habrastorage.org/getpro/habr/post_images/33d/700/a35/33d700a35c73ec998faaabe69af40a53.gif"><br><br>  First of all, I tested calling an empty function in a loop. <br>  var f = function () {} <br>  for (var i = 1000000; i--;) {f ();} <br><br>  In most browsers, calling a function is a fairly cheap operation (there are only a few hundred milliseconds added per million calls, compared to a completely empty cycle). <br>  However, IE, as always, presents unpleasant surprises.  Fans of wrapping code in a lot of wrapper functions will have something to think about) <br><br>  I note that the slow function call itself has a negative effect on other tests related to function calls (for example, creating an object or calling a method), so the time to execute them in IE increases even more. <br><br>  The following 2 tests are devoted to the creation of a million objects, in one case all the methods are created through the constructor, in the other through the prototype. <br>  The difference, I think, is obvious. <br><br>  The following three tests call the property of an object: its own property (created through this.prop = value), the property of the prototype, and a private property (created through the closure from the constructor function).  Obviously, the last option is obtained through the getter. <br>  The result is, in general, predictable - the own property of the object can be obtained much faster. <br><br>  Then follow 3 tests that call the incremental method of the object (i.e., the method that, by each call, increases the property of the object by one).  Actually, the difference here again is how exactly this property was created (i.e., the access speed to the object properties from its methods is tested). <br>  It is clearly seen that in this case the rate of change of the private property is higher everywhere except for Firefox, however, it must be remembered that this property is common to all objects of the same type and has the worst reading time outside (via a getter). <br><br><h2>  Branches </h2><br><table width="974"><tbody><tr><td>  <b>Branches</b> </td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>  <b>Tests / Browsers</b> </td><td>  FF3 </td><td>  Opera </td><td>  Chrome </td><td>  IE7 </td><td>  IE8b2 </td></tr><tr><td>  Select a branch of 8 possible through if </td><td>  800 </td><td>  500 </td><td>  60 </td><td>  1500 </td><td>  1460 </td></tr><tr><td>  The choice of a branch from 8 possible through switch </td><td>  315 </td><td>  334 </td><td>  54 </td><td>  868 </td><td>  1039 </td></tr><tr><td>  Selecting branches from 8 possible through hash functions </td><td>  620 </td><td>  400 </td><td>  86 </td><td>  4520 </td><td>  1820 </td></tr><tr><td width="649"></td><td width="64"></td><td width="64"></td><td width="69"></td><td width="64"></td><td width="64"></td></tr></tbody></table><br><img src="https://habrastorage.org/getpro/habr/post_images/0a1/24a/ccc/0a124accccdcdd0048edd32ead84e9a6.gif"><br><br>  I think the first two tests in this table are not necessary to comment, we‚Äôll dwell on the third one in more detail. <br>  A hash of functions is an object that emulates switch behavior. <br>  For example, we have this piece of code: <br>  switch (a) { <br>  case 0: b = 6 + 2;  break; <br>  case 1: b = 8 * 3;  break; <br>  } <br>  Then the hash of functions will look like this: <br>  hash = { <br>  '0': function () {return 6 + 2;}, <br>  '1': function () {return 8 * 3;} <br>  } <br>  And used as b = hash [a] (); <br><br>  With such simple actions, the hash shows worse results than switch (due to the need to call a function).  However, if you're still going to call functions from switch, the hash will probably be faster. <br><br><h2>  General browser output </h2><br>  Again, everything is predictable.  Chrome confidently leads with a margin of several Parsecs, firelight and opera share the second and third place with each other (in different tests in different ways), the donkey sadly weaves at the end, but the beta donkey gives some hope that the patient is more alive than is dead <br><br><h2>  Conclusion </h2><br>  The first thing I would like to draw attention to is that all the above tests are synthetic, and the load is much higher than usual for web applications (not so often we have to deal with arrays of a million values, for example). <br>  Consequently, it is worth treating them exactly as synthetic tests with a specially increased load - i.e.  Be aware of what is important for this particular script, and what is not important. <br><br>  On the other hand, the method that is being called a hundred times today may be called ten thousand times tomorrow, so it‚Äôs not worth waving a hand on this thing.  And if something started to slow down somewhere, there would be at least an understanding of which way to ‚Äúdig‚Äù) </div><p>Source: <a href="https://habr.com/ru/post/49052/">https://habr.com/ru/post/49052/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../49044/index.html">Parajet skycar</a></li>
<li><a href="../49046/index.html">The speed of technical support for Yandex</a></li>
<li><a href="../49047/index.html">Your new skill. Remote training</a></li>
<li><a href="../49049/index.html">We are Fedora-aa!</a></li>
<li><a href="../49050/index.html">Google Sitemap Generator</a></li>
<li><a href="../49053/index.html">UPD. Demon video conversion to FLV.</a></li>
<li><a href="../49054/index.html">RichFaces release 3.3.0 GA</a></li>
<li><a href="../49058/index.html">Clockwork radio</a></li>
<li><a href="../49059/index.html">Optional SideStage Monitor</a></li>
<li><a href="../49061/index.html">Universal password for sites</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>