<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Databases in MIDP Part 1: The Concept of Record Management System</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="One of the key components of MIDP is the Record Management System (RMS). This is an API that provides the ability to store data locally in the device‚Äô...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Databases in MIDP Part 1: The Concept of Record Management System</h1><div class="post__text post__text-html js-mediator-article">  One of the key components of MIDP is the Record Management System (RMS).  This is an API that provides the ability to store data locally in the device‚Äôs memory.  For most MIDP-compatible phones, this is the only way to store data - only a small number of devices support access to a regular file system.  It is easy to guess that a full understanding of the RMS mechanism is necessary for writing any application that requires the storage of local data. <br><br>  This is the first article of the cycle, which will address the most common problems related to the use of RMS in applications, for example, interaction with external data sources, such as relational databases.  To begin, we learn what RMS can offer us, and write some simple debuggers. <a name="habracut"></a><br><br><h4>  Key Concepts </h4><br><h5>  Records </h5><br>  From the name it is clear that RMS is a system for managing records.  A <i>record</i> is a data item.  RMS does not impose any restrictions on the contents of the record; it can contain a number, a string, an array, an image ‚Äî anything that can be represented as a sequence of bytes.  If you can encode the available data into a binary format (and decode it back), then you can save it in the record, if, of course, they fit into the size limit imposed by the system. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Many newcomers to RMS are puzzled by the notion of writing.  They ask: ‚Äúwhere are the fields?‚Äù, Wondering how the system divides the individual records into separate data sequences.  The answer is simple: <i>the RMS record contains no fields.</i>  More precisely, the record contains one binary field of arbitrary length.  The function of interpreting the contents of the record rests entirely with the application.  RMS provides storage and a unique identifier, nothing more.  This creates difficulties for applications, but keeps the RMS simple and flexible, which is quite important for the MIDP subsystem. <br><br>  At the API level, entries are simply arrays of bytes. <br><br><h5>  Record Storage </h5><br>  A record store is an ordered collection of records.  Each entry belongs to the repository and is accessible only through it.  The storage guarantees atomic reading and writing of data, preventing their damage. <br><br>  When a record is created, the repository assigns it a unique integer identifier (record ID).  The first record gets id 1, the second one gets 2, and so on. This is not an index: when you delete a record, the remaining elements are not renumbered. <br><br>  The name is used to identify the repository inside the MIDlet.  The name can contain from 1 to 32 unicode characters and must be unique within the MIDlet that created the repository.  In MIDP 1.0, repositories cannot be used by more than one application.  MIDP 2.0 optionally allows this, in which case the storage is identified not only by the name, but also by the name and manufacturer of the application that created the storage. <br><br>  In addition, the repository contains information about the last modified date and version.  Applications can also bind to the repository a data change event handler in it. <br><br>  At the API level, storage is represented by an instance of the javax.microedition.rms.RecordStore class.  All classes and interfaces of RMS are defined in the javax.microedition.rms package. <br><br><h4>  RMS aspects </h4><br><h5>  Data Size Limits </h5><br>  The amount of memory available for storing records differs across devices.  The MIDP specification requires a backup of at least 8 KB of memory for permanent data storage.  At the same time the size of one record is not limited.  RMS provides methods for determining the size of the record size, the total storage size and the size of free memory.  Remember that permanent memory is common for all applications, use it sparingly. <br><br>  Any MIDlet using RMS must specify the minimum storage size in bytes necessary for its operation.  For this, the MIDlet-Data-Size attribute must be set in the jar-file manifest and in the jad-file.  Do not specify there too much value - some devices may prohibit the installation of the application if there is not enough free space.  In practice, most devices allow applications to go beyond the starting data size. <br><br>  Please note that some MIDP implementations require you to specify additional attributes related to the required memory size.  This should be stated in the device documentation. <br><br><h5>  Work speed </h5><br>  Operations with permanent memory are usually performed more slowly than with operational.  In particular, on some platforms, data recording can take a long time.  To improve performance, use caching of frequently used data in RAM.  In order not to slow down the response of the user interface, do not perform RMS operations in the flow of event processing of the MIDlet. <br><br><h5>  Thread safety </h5><br>  RMS operations are thread-safe.  However, flows need to be coordinated among themselves, as when working with any shared resource.  This also applies to simultaneously running midlets using the same storage. <br><br><h5>  Exceptions </h5><br>  In general, the RMS API methods throw a few exceptions (in addition to standard exceptions like java.lang.IllegalArgumentException).  These exceptions are defined in the javax.microedition.rms package: <br><ul><li>  InvalidRecordIDException - the operation could not be performed because an invalid record id was passed. </li><li>  RecordStoreFullException - Out of available memory. </li><li>  RecordStoreNotFoundException - the specified store does not exist. </li><li>  RecordStoreNotOpenException - the application is trying to use a repository that has been closed. </li><li>  RecordStoreException - the superclass of previous exceptions, is also thrown when common errors are not covered by them. </li></ul><br>  Note that for brevity, we will ignore exception handling in some examples (because of its simplicity). <br><br><h4>  Using RMS </h4><br>  We will devote the rest of the article to the main operations with records through the RMS API.  Some of them are presented in the RMSAnalyzer class, intended for analyzing repositories.  You can use it as a debugging tool in your projects. <br><br><h5>  Storage search </h5><br>  The list of storages can be obtained using RecordStore.listRecordStores ().  This static method returns an array of strings, each of which is the name of the storage that belongs to the midlet.  If no storage is created, null is returned. <br><br>  The RMSAnalyzer.analyzeAll () method uses listRecordStores () to call analyze () for each repository: <br><pre><code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">analyzeAll</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { String[] names = RecordStore.listRecordStores(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; names != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; i &lt; names.length; ++i ) { analyze( names[i] ); } }</code> </pre> <br>  Please note that the array contains only the names of the repositories created by our midlet.  The MIDP specification does not contain any way to get a list of all the repositories of the other MIDlets.  MIDP 1.0 does not allow access to foreign repositories.  In MIDP 2.0, an application can mark a repository as shareable, but other midlets can use it only if they know its name. <br><br><h5>  Opening and closing the repository </h5><br>  RecordStore.openRecordStore () is used to open (and sometimes create) a repository.  This static method returns an instance of the RecordStore object, as seen from this version of RMSAnalyzer.analyze (): <br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">analyze</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> String rsName </span></span></span><span class="hljs-function">)</span></span> { RecordStore rs = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { rs = RecordStore.openRecordStore( rsName, <span class="hljs-literal"><span class="hljs-literal">false</span></span> ); analyze( rs ); <span class="hljs-comment"><span class="hljs-comment">//   } catch( RecordStoreException e ) { logger.exception( rsName, e ); } finally { try { rs.closeRecordStore(); } catch( RecordStoreException e ){ //    } } }</span></span></code> </pre><br>  The second parameter of the openRecordStore () method indicates whether the store will be created if it does not exist.  In MIDP 2.0, the following openRecordStore () form is used to open a repository created by another application: <br><pre> <code class="hljs vbscript">... <span class="hljs-built_in"><span class="hljs-built_in">String</span></span> name = <span class="hljs-string"><span class="hljs-string">"mySharedRS"</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">String</span></span> vendor = <span class="hljs-string"><span class="hljs-string">"EricGiguere.com"</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">String</span></span> suite = <span class="hljs-string"><span class="hljs-string">"TestSuite"</span></span>; RecordStore rs = RecordStore.openRecordStore( name, vendor, suite ); ...</code> </pre><br>  The manufacturer and name of the midlet must match the ones specified in the manifest. <br><br>  After the work is finished, close the repository by calling RecordStore.closeRecordStore (), as in the analyze () method above. <br><br>  The RecordStore instance is unique in the midlet: after it is opened, all subsequent openRecordStore () calls with the same arguments will return a reference to the same object.  This copy is common to all midlets in the collection. <br><br>  Each instance of RecordStore counts how many times a repository has been opened.  It will not close until closeRecordStore () has been called the same number of times.  After the storage is closed, an attempt to use it will result in a RecordStoreNotOpenException. <br><br><h5>  Creation of storage </h5><br>  To create a repository (not available to other midlets), you need to call openRecordStore (), setting the second parameter to true: <br><pre> <code class="hljs coffeescript">... <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   RecordStore rs = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { rs = RecordStore.openRecordStore( <span class="hljs-string"><span class="hljs-string">"myrs"</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span> ); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>( RecordStoreException e ){ <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>       } ...</code> </pre><br>  To perform the initial initialization of the repository, check the value of getNextRecordID () - if it is equal to 1, there are no records in the repository: <br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( rs.getNextRecordID() == <span class="hljs-number"><span class="hljs-number">1</span></span> ){ <span class="hljs-comment"><span class="hljs-comment">//   }</span></span></code> </pre><br>  An alternative way is to check the value returned by getNumRecords (): <br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( rs.getNumRecords() == <span class="hljs-number"><span class="hljs-number">0</span></span> ){ <span class="hljs-comment"><span class="hljs-comment">//  ,  }</span></span></code> </pre><br>  To create a shared storage (only in MIDP 2.0), use the following openRecordStore () call option with four parameters: <br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">boolean</span></span> writable = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">rs</span></span> = RecordStore.openRecordStore( <span class="hljs-string"><span class="hljs-string">"myrs"</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>, RecordStore.AUTHMODE_ANY, writable );</code> </pre><br>  If the second parameter is true and the storage does not exist, the last two parameters control its access mode and the ability to write.  Access mode determines whether other applications can use this storage.  Two options are possible: RecordStore.AUTHMODE_PRIVATE (only our application has access) or RecordStore.AUTHMODE_ANY (any application has access).  The writable flag determines whether another application will have write access ‚Äî if writable = false, it can only read data. <br><br>  The storage owner application can change these settings at any time using RecordStore.setMode (): <br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">rs</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.setMode</span></span>( <span class="hljs-selector-tag"><span class="hljs-selector-tag">RecordStore</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.AUTHMODE_ANY</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">false</span></span> );</code> </pre><br>  In fact, it is best to create a private repository, and open access only after its initialization. <br><br><h5>  Adding and modifying entries </h5><br>  Recall that records are arrays of bytes.  To add a new record to the public storage, use the RecordStore.addRecord () method: <br><pre> <code class="hljs cs">... <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] data = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[]{ <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> recordID; recordID = rs.addRecord( data, <span class="hljs-number"><span class="hljs-number">0</span></span>, data.length ); ...</code> </pre><br>  You can create an empty entry by passing null as the first parameter.  The second and third parameters specify the starting position of the reading and the number of bytes to be saved.  If successful, the record id is returned, otherwise an exception is thrown (for example, RecordStoreFullException). <br><br>  At any time, you can update the record using RecordStore.setRecord (): <br><pre> <code class="hljs haskell">... int recordID = ...; // <span class="hljs-type"><span class="hljs-type">ID</span></span>   byte[] <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> = new byte[] { 0, 10, 20, 30 }; rs.setRecord( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">recordID</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">data</span></span></span><span class="hljs-class">, 1, 2 ); //       10, 20 ...</span></span></code> </pre><br>  You can find out what id will be assigned to the next record being added, using the RecordStore.getNextRecordID () method.  All existing entries have id less than this. <br><br>  In the <a href="http://developers.sun.com/mobility/midp/articles/databasemap/">second part,</a> we will look at how to convert objects and other data into an array of bytes. <br><br><h5>  Reading records </h5><br>  To read entries, use RecordStore.getRecord () in one of two forms.  In the first variant, this method creates an array of the required length and writes data to it: <br><pre> <code class="hljs haskell">... int recordID = .... // <span class="hljs-type"><span class="hljs-type">ID</span></span>   byte[] <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> = rs.getRecord( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">recordID</span></span></span><span class="hljs-class"> ); ...</span></span></code> </pre><br>  In the second variant, the data is copied to the already created array, starting from the specified position, and the number of bytes written is returned: <br><pre> <code class="hljs perl">... <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> recordID = ...; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> ID  byte[] data = ...; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> offset = ...; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> numCopied = rs.getRecord( recordID, data, offset ); ...</code> </pre><br>  The array must be of sufficient length to contain the data, otherwise java.lang.ArrayIndexOutOfBoundsException will occur.  To determine the required size of the array is used RecordStore.getRecordSize ().  In fact, the first form of getRecord () is equivalent to the following: <br><pre> <code class="hljs haskell">... byte[] <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> = new byte[ rs.getRecordSize( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">recordID</span></span></span><span class="hljs-class"> ) ]; rs.getRecord( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">recordID</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">data</span></span></span><span class="hljs-class">, 0 ); ...</span></span></code> </pre><br>  The second form is useful if you loop through many records in a loop, as the number of memory requests is reduced.  For example, you can use it with getNextRecordID () and getRecordSize () to search through all the records in the repository: <br><pre> <code class="hljs objectivec">... <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> nextID = rs.getNextRecordID(); byte[] data = null; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> &lt; nextID; ++<span class="hljs-keyword"><span class="hljs-keyword">id</span></span> ) { try { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> size = rs.getRecordSize( <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( data == null || data.length &lt; size ) { data = new byte[ size ]; } rs.getRecord( <span class="hljs-keyword"><span class="hljs-keyword">id</span></span>, data, <span class="hljs-number"><span class="hljs-number">0</span></span> ); processRecord( rs, <span class="hljs-keyword"><span class="hljs-keyword">id</span></span>, data, size ); <span class="hljs-comment"><span class="hljs-comment">// -     } catch( InvalidRecordIDException e ){ //       } catch( RecordStoreException e ){ handleError( rs, id, e ); //   } } ...</span></span></code> </pre><br>  However, it is better to use RecordStore.enumerateRecords () for this.  We will consider this method in the <a href="http://developers.sun.com/mobility/midp/articles/databasemapextend/">third part of a</a> series of articles. <br><br><h5>  Deleting records and repositories </h5><br>  The function RecordStore.deleteRecord () is used to delete records: <br><pre> <code class="hljs objectivec">... <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> recordID = ...; rs.deleteRecord( recordID ); ...</code> </pre><br>  After deleting a record, any attempt to use it results in an InvalidRecordIDException. <br><br>  You can delete the entire repository using RecordStore.deleteRecordStore (): <br><pre> <code class="hljs erlang">... <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { RecordStore.deleteRecordStore( <span class="hljs-string"><span class="hljs-string">"myrs"</span></span> ); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>( RecordStoreNotFoundException e ){ //    } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>( RecordStoreException e ){ //   } ...</code> </pre><br>  Storage cannot be removed while it is open by any application.  Only the MIDlet that created it can delete the repository. <br><br><h5>  Other operation </h5><br>  There are only a few RMS operations left, all of which are methods of the RecordStore class: <br><ul><li>  getLastModified () returns the time of the last modification of the repository in the same format as System.currentTimeMillis (). </li><li>  getName () returns the name of the repository. </li><li>  getNumRecords () returns the number of records in the repository. </li><li>  getSize () returns the full size of the repository in bytes, including the length of the records and service fields necessary for the system to organize it. </li><li>  getSizeAvailable () returns the size of the free space in bytes.  The actual available size may be smaller due to the extra bytes used by the repository to store each record. </li><li>  getVersion () returns the version number of the repository.  This is a positive integer increasing by one each time the data changes. </li></ul><br>  A MIDlet can also monitor changes to the repository by registering a handler with addRecordListener (); removeRecordListener () is designed to remove it.  In the third part, these methods will be discussed in more detail. <br><br><h4>  RMSAnalyzer class </h4><br>  We end this article with the source code of the RMSAnalyzer class, our repository analyzer.  For the analysis you need to run the following code: <br><pre> <code class="hljs objectivec">... RecordStore rs = ...; <span class="hljs-comment"><span class="hljs-comment">//   RMSAnalyzer analyzer = new RMSAnalyzer(); analyzer.analyze( rs ); ...</span></span></code> </pre><br>  By default, the output is redirected to System.out and looks like this: <br><blockquote> <code>========================================= <br> Record store: recordstore2 <br> Number of records = 4 <br> Total size = 304 <br> Version = 4 <br> Last modified = 1070745507485 <br> Size available = 975950 <br> <br> Record #1 of length 56 bytes <br> 5f 62 06 75 2e 6b 1c 42 58 3f _b.ukBX? <br> 1e 2e 6a 24 74 29 7c 56 30 32 ..j$t)|V02 <br> 5f 67 5a 13 47 7a 77 68 7d 49 _gZ.Gzwh}I <br> 50 74 50 20 6b 14 78 60 58 4b PtP kx`XK <br> 1a 61 67 20 53 65 0a 2f 23 2b .ag Se./#+ <br> 16 42 10 4e 37 6f .B.N7o <br> Record #2 of length 35 bytes <br> 22 4b 19 22 15 7d 74 1f 65 26 "K.".}te&amp; <br> 4e 1e 50 62 50 6e 4f 47 6a 26 N.PbPnOGj&amp; <br> 31 11 74 36 7a 0a 33 51 61 0e 1.t6z.3Qa. <br> 04 75 6a 2a 2a .uj** <br> Record #3 of length 5 bytes <br> 47 04 43 22 1f GC". <br> Record #4 of length 57 bytes <br> 6b 6f 42 1d 5b 65 2f 72 0f 7a koB.[e/rz <br> 2a 6e 07 57 51 71 5f 68 4c 5c *n.WQq_hL\ <br> 1a 2a 44 7b 02 7d 19 73 4f 0b .*D{.}.sO. <br> 75 03 34 58 17 19 5e 6a 5e 80 u.4X..^j^? <br> 2a 39 28 5c 4a 4e 21 57 4d 75 *9(\JN!WMu <br> 80 68 06 26 3b 77 33 ?h.&amp;;w3 <br> <br> Actual size of records = 153 <br> ----------------------------------------- <br></code> </blockquote><br>  This format is useful when testing with the J2ME Wireless Toolkit.  When testing on a real device, you can send the analyzer output to a serial port or even over the network.  To do this, you need to create a new class with the RMSAnalyzer.Logger interface and pass it an instance to the RMSAnalyzer constructor. <br><br>  The article ends with a J2ME Wireless Toolkit project called RMSAnalyzerTest, demonstrating the use of the analyzer: <a href="http://pastebin.com/n36QLuAs">pastebin.com/n36QLuAs</a> <br><br>  <i>The rest of the article in English can be seen <a href="http://developers.sun.com/mobility/allarticles/">here</a> .</i>  <i>Does it make sense to continue their translation?</i> </div><p>Source: <a href="https://habr.com/ru/post/85856/">https://habr.com/ru/post/85856/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../85844/index.html">Starcraft 2 can be played with AI on several special cards and on different difficulty levels.</a></li>
<li><a href="../85849/index.html">Nvidia ION in the face of Acer Aspire Revolution</a></li>
<li><a href="../85851/index.html">Deploying the site to Django using FastCGI</a></li>
<li><a href="../85852/index.html">Singleton and Late static binding</a></li>
<li><a href="../85853/index.html">√úr√ºn - another look at online shopping</a></li>
<li><a href="../85858/index.html">Forms in the Zend Framework</a></li>
<li><a href="../85859/index.html">Transcend T.Sonic 330 (8Gb)</a></li>
<li><a href="../85860/index.html">Mysterious file copying bug during Opera 10.10</a></li>
<li><a href="../85861/index.html">Patch to the Drupal-module Date - show months in the genitive case</a></li>
<li><a href="../85865/index.html">Bookmark design for books. Progress and does not think to stop</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>