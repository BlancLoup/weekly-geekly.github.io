<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>And again about topological sorting ...</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Greetings to all readers of Habr! Having decided to write this article, I found a lot of materials on Habr√© on graphs and, in particular, on topologic...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>And again about topological sorting ...</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/storage/habraeffect/b3/d1/b3d112675c0e83b9d953699c3fe4674f.png" align="left"><br>  Greetings to all readers of Habr!  Having decided to write this article, I found a lot of materials on Habr√© on graphs and, in particular, on <a href="http://ru.wikipedia.org/wiki/%25D0%25A2%25D0%25BE%25D0%25BF%25D0%25BE%25D0%25BB%25D0%25BE%25D0%25B3%25D0%25B8%25D1%2587%25D0%25B5%25D1%2581%25D0%25BA%25D0%25B0%25D1%258F_%25D1%2581%25D0%25BE%25D1%2580%25D1%2582%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25BA%25D0%25B0">topological sorting</a> .  For example, the theoretical part is described in some detail and examples of basic algorithms are given.  Therefore, I will not repeat, but I will tell you about the practical scope of <b>Topological sorting</b> , or rather, I want to share my personal experience of using this method in the development of <a href="http://www.devexpress.com/">DevExpress</a> products.  From the article, the motives and reasons for using this algorithm will become clear.  At the end I will give our variant of the implementation of the algorithm for sorting dependent objects. <br><a name="habracut"></a><br><br><h2>  Scope of the sorting algorithm in DevExpress </h2><br><br>  In a <a href="http://habrahabr.ru/company/devexpress/blog/105260/">previous article,</a> we talked about the <a href="http://www.devexpress.com/xtrascheduler">XtraScheduler scheduler</a> and its print extension.  It includes a report designer working with visual elements.  When designing in the designer of the appearance of the printed form, it is necessary to establish links between the visual elements of the report on the principle of "master-slave".  These dependencies should determine how data is transferred between items.  For internal implementation, this implies the formation of the correct printing priority of these objects. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The elements were inherently oriented graph of objects, since  The options of these controls uniquely determined the direction of the dependency by specifying a reference to the main object. <br><br>  The topological sorting algorithm could not be better suited to build dependent objects in the correct order before printing, analyzing the connections between them.  In addition, the dependent controls for printing used the rendering data of the main controls.  Therefore, the algorithm was also applied to the organization of internal data caching objects containing the main data iterator object and its associated subordinate list. <br><br>  Where else did we apply the algorithm? <br><br>  A little later, in the <a href="http://www.devexpress.com/xtrarichedit">XtraRichEdit</a> project <a href="http://www.devexpress.com/xtrarichedit">,</a> when developing import and export styles for documents in RTF and DOC formats, it also became necessary to get the objects containing dependencies between them in the correct order.  The described algorithm was generalized and successfully applied in this case. <br><br><h2>  Algorithm-T </h2><br><br>  Let us turn to our implementation of the sorting algorithm.  It is based on the described Algorithm-T from the book <a href="http://ru.wikipedia.org/wiki/%25D0%2598%25D1%2581%25D0%25BA%25D1%2583%25D1%2581%25D1%2581%25D1%2582%25D0%25B2%25D0%25BE_%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B3%25D1%2580%25D0%25B0%25D0%25BC%25D0%25BC%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D1%258F">‚ÄúThe Art of Programming‚Äù by</a> Donald Knuth (Volume 1, Chapter 2.2.3).  Therefore, you can read about the details of the algorithm in the original; here I will only provide an algorithm for a general understanding of the idea. <br><br><img src="https://habrastorage.org/storage/habraeffect/dd/4e/dd4e72289fb8442a72cf3f415e754da4.png"><br><br>  Why did we choose this algorithm?  Just let me quote the author a little. <br><blockquote>  <i>‚ÄúThe analysis of the algorithm T can be easily performed using Kirchhoff‚Äôs law.</i>  <i>Using this law, the execution time can be estimated approximately using the formula c1 * m + c2 * n, where m is the number of relations introduced, n is the number of objects, and c1 and c2 are constants.</i>  <i>A faster algorithm for solving this problem is simply impossible to imagine! ‚Äù</i> <i><br></i> </blockquote><br><br>  The implemented algorithm is located in the <i>DevExpress.Data.dll</i> assembly in the <i>Algorithms</i> class, which along with the topological sorting contains a number of other useful algorithms. <br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">DevExpress.Utils</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Algorithms</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> IList&lt;T&gt; TopologicalSort&lt;T&gt;(IList&lt;T&gt; sourceObjects, IComparer&lt;T&gt; comparer) { TopologicalSorter&lt;T&gt; sorter = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TopologicalSorter&lt;T&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sorter.Sort(sourceObjects, comparer); } }</code> </pre> <br>  Using the algorithm is extremely simple.  It is enough to call the static class method, passing it the necessary parameters.  An example call is as follows: <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> IList&lt;XRControl&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SortControls</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">List&lt;XRControl&gt; sourceControls</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Algorithms.TopologicalSort&lt;XRControl&gt;(sourceControls, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ReportViewControlComparer()); }</code> </pre><br>  You can do without calling a static method by explicitly creating an instance of the sorter object. <br>  The source code of the sorter class that implements the algorithm will be given at the end of the article. <br><br>  As can be seen from the parameters, in addition to the list of objects, a specialized comparer is passed to the method.  If it is not specified, the default object will be used.  In practice, the comparator object is usually specified, since it determines the comparison logic, which can be based on the properties of the compared objects.  In addition, such an object can implement several IComparer interfaces simultaneously for several inherited types. <br>  As an example of such a class, I will give our ReportViewControlComparer, which is used in the <a href="">XtraScheduler.Reporting</a> library: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ReportViewControlComparer</span></span> : <span class="hljs-title"><span class="hljs-title">IComparer</span></span>&lt;<span class="hljs-title"><span class="hljs-title">XRControl</span></span>&gt;, <span class="hljs-title"><span class="hljs-title">IComparer</span></span>&lt;<span class="hljs-title"><span class="hljs-title">ReportViewControlBase</span></span>&gt; { <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">region</span></span></span><span class="hljs-meta"> IComparer&lt;XRControl&gt; Members public int Compare(XRControl x, XRControl y) { return CompareCore(x as ReportRelatedControlBase, y as ReportViewControlBase); } #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endregion</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">region</span></span></span><span class="hljs-meta"> IComparer&lt;ReportViewControlBase&gt; Members public int Compare(ReportViewControlBase x, ReportViewControlBase y) { return CompareCore(x as ReportRelatedControlBase, y); } #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endregion</span></span></span><span class="hljs-meta"> int CompareCore(ReportRelatedControlBase slave, ReportViewControlBase master) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (slave != null &amp;&amp; master != null) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (slave.LayoutOptionsHorizontal.MasterControl == master || slave.LayoutOptionsVertical.MasterControl == master) return 1; } return 0; } }</span></span></code> </pre><br><br><h2>  Application example </h2><br><br>  To demonstrate the operation of the algorithm, create a console application.  As an example of a graph, we take a simple graph of 5 nodes (see the figure at the beginning of the article). <br><br>  <b>G = ({a, b, c, d, e}, {(a, b), (a, c), (a, d), (a, e), (b, d), (c, d ), (c, e), (d, e)})</b> <br><br>  To represent the graph, a simple class will be used that defines a node with a list of other nodes associated with it. <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">GraphNode</span></span> { List&lt;GraphNode&gt; linkedNodes = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;GraphNode&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> id; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GraphNode</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> id</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.id = id; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> List&lt;GraphNode&gt; LinkedNodes { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> linkedNodes; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> Id { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> id; } } }</code> </pre><br><br>  The code for the application itself is shown below: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] args</span></span></span><span class="hljs-function">)</span></span> { DoDXTopologicalSort(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoDXTopologicalSort</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { GraphNode[] list = PrepareNodes(); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"DX Topological Sorter"</span></span>); Console.WriteLine(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>(<span class="hljs-string"><span class="hljs-string">'-'</span></span>, <span class="hljs-number"><span class="hljs-number">21</span></span>)); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"Nodes:"</span></span>); GraphNode[] list = PrepareNodes(); PrintNodes(list); IComparer&lt;GraphNode&gt; comparer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GraphNodeComparer(); IList&lt;GraphNode&gt; sortedNodes = DevExpress.Utils.Algorithms.TopologicalSort&lt;GraphNode&gt;(list, comparer); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"Sorted nodes:"</span></span>); PrintNodes(sortedNodes); Console.Read(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> GraphNode[] </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrepareNodes</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { GraphNode nodeA = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GraphNode(<span class="hljs-string"><span class="hljs-string">"A"</span></span>); GraphNode nodeB = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GraphNode(<span class="hljs-string"><span class="hljs-string">"B"</span></span>); GraphNode nodeC = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GraphNode(<span class="hljs-string"><span class="hljs-string">"C"</span></span>); GraphNode nodeD = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GraphNode(<span class="hljs-string"><span class="hljs-string">"D"</span></span>); GraphNode nodeE = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GraphNode(<span class="hljs-string"><span class="hljs-string">"E"</span></span>); nodeA.LinkedNodes.AddRange(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GraphNode[] { nodeB, nodeC, nodeE }); nodeB.LinkedNodes.Add(nodeD); nodeC.LinkedNodes.AddRange(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GraphNode[] { nodeD, nodeE }); nodeD.LinkedNodes.Add(nodeE); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GraphNode[] { nodeD, nodeA, nodeC, nodeE, nodeB }; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrintNodes</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IList&lt;GraphNode&gt; list</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; list.Count; i++) { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> s = <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.Empty; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) s = <span class="hljs-string"><span class="hljs-string">"-&gt;"</span></span>; s += list[i].Id.ToString(); Console.Write(s); } Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"\r\n"</span></span>); } }</code> </pre><br><br>  Directly connections of the graph are set in the <i>PrepareNodes</i> method.  In this case, dependencies are created arbitrarily. <br><br>  To compare the nodes, we also need the GraphNodeComparer class. <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">GraphNodeComparer</span></span> : <span class="hljs-title"><span class="hljs-title">IComparer</span></span>&lt;<span class="hljs-title"><span class="hljs-title">GraphNode</span></span>&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Compare</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GraphNode x, GraphNode y</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x.LinkedNodes.Contains(y)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (y.LinkedNodes.Contains(x)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } }</code> </pre><br>  After launching the application, we will get a sorted list of nodes and the console will display <br>  <b>A-&gt; B-&gt; C-&gt; D-&gt; E.</b> <br><br>  The result of the program is shown in the figure below: <br><img src="https://habrastorage.org/storage/habraeffect/75/b9/75b9df7d91ad8c178643c82c0cfdf9d5.png"><br><br><h2>  Sorter source code </h2><br><br>  As I promised above, I provide the code for the implementation of the topological sorting algorithm. <br><br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black"><font color="#0000ff">namespace</font> DevExpress.Utils.Implementation { <br> <br> <font color="#0000ff">#region</font> TopologicalSorter <br> <font color="#0000ff">public</font> <font color="#0000ff">class</font> TopologicalSorter&lt;T&gt; { <br> <font color="#0000ff">#region</font> Node <br> <font color="#0000ff">public</font> <font color="#0000ff">class</font> Node { <br> <font color="#0000ff">int</font> refCount; <br> Node next; <br> <font color="#0000ff">public</font> Node( <font color="#0000ff">int</font> refCount, Node next) { <br> <font color="#0000ff">this</font> .refCount = refCount; <br> <font color="#0000ff">this</font> .next = next; <br> } <br> <font color="#0000ff">public</font> <font color="#0000ff">int</font> RefCount { <font color="#0000ff">get</font> { <font color="#0000ff">return</font> refCount; } } <br> <font color="#0000ff">public</font> Node Next { <font color="#0000ff">get</font> { <font color="#0000ff">return</font> next; } } <br> } <br> <font color="#0000ff">#endregion</font> <br> <br> <font color="#0000ff">#region</font> Fields <br> <font color="#0000ff">int</font> [] qLink; <br> Node[] nodes; <br> IList&lt;T&gt; sourceObjects; <br> IComparer&lt;T&gt; comparer; <br> <font color="#0000ff">#endregion</font> <br> <br> <font color="#0000ff">#region</font> Properties <br> <font color="#0000ff">protected</font> <font color="#0000ff">internal</font> Node[] Nodes { <font color="#0000ff">get</font> { <font color="#0000ff">return</font> nodes; } } <br> <font color="#0000ff">protected</font> <font color="#0000ff">internal</font> <font color="#0000ff">int</font> [] QLink { <font color="#0000ff">get</font> { <font color="#0000ff">return</font> qLink; } } <br> <font color="#0000ff">protected</font> IComparer&lt;T&gt; Comparer { <font color="#0000ff">get</font> { <font color="#0000ff">return</font> comparer; } } <br> <font color="#0000ff">protected</font> <font color="#0000ff">internal</font> IList&lt;T&gt; SourceObjects { <font color="#0000ff">get</font> { <font color="#0000ff">return</font> sourceObjects; } } <br> <font color="#0000ff">#endregion</font> <br> <br> <font color="#0000ff">protected</font> IComparer&lt;T&gt; GetComparer() { <br> <font color="#0000ff">return</font> Comparer != <font color="#0000ff">null</font> ? Comparer : System.Collections. <font color="#2B91AF">Generic</font> .Comparer&lt;T&gt;.Default; <br> } <br> <font color="#0000ff">protected</font> <font color="#0000ff">bool</font> IsDependOn(T x, T y) { <br> <font color="#0000ff">return</font> GetComparer().Compare(x, y) &gt; 0; <br> } <br> <font color="#0000ff">public</font> IList&lt;T&gt; Sort(IList&lt;T&gt; sourceObjects, IComparer&lt;T&gt; comparer) { <br> <font color="#0000ff">this</font> .comparer = comparer; <br> <font color="#0000ff">return</font> Sort(sourceObjects); <br> } <br> <font color="#0000ff">public</font> IList&lt;T&gt; Sort(IList&lt;T&gt; sourceObjects) { <br> <font color="#0000ff">this</font> .sourceObjects = sourceObjects; <br> <br> <font color="#0000ff">int</font> n = sourceObjects.Count; <br> <font color="#0000ff">if</font> (n &lt; 2) <br> <font color="#0000ff">return</font> sourceObjects; <br> <br> Initialize(n); <br> CalculateRelations(sourceObjects); <br> <br> <font color="#0000ff">int</font> r = FindNonRelatedNodeIndex(); <br> IList&lt;T&gt; result = ProcessNodes(r); <br> <font color="#0000ff">return</font> result.Count &gt; 0 ? result : sourceObjects; <br> <br> } <br> <font color="#0000ff">protected</font> <font color="#0000ff">internal</font> <font color="#0000ff">void</font> Initialize( <font color="#0000ff">int</font> n) { <br> <font color="#0000ff">int</font> count = n + 1; <br> <font color="#0000ff">this</font> .qLink = <font color="#0000ff">new</font> <font color="#0000ff">int</font> [count]; <br> <font color="#0000ff">this</font> .nodes = <font color="#0000ff">new</font> Node[count]; <br> } <br> <font color="#0000ff">protected</font> <font color="#0000ff">internal</font> <font color="#0000ff">void</font> CalculateRelations(IList&lt;T&gt; sourceObjects) { <br> <font color="#0000ff">int</font> n = sourceObjects.Count; <br> <font color="#0000ff">for</font> ( <font color="#0000ff">int</font> y = 0; y &lt; n; y++) { <br> <font color="#0000ff">for</font> ( <font color="#0000ff">int</font> x = 0; x &lt; n; x++) { <br> <font color="#0000ff">if</font> (!IsDependOn(sourceObjects[y], sourceObjects[x])) <br> <font color="#0000ff">continue</font> ; <br> <font color="#0000ff">int</font> minIndex = x + 1; <br> <font color="#0000ff">int</font> maxIndex = y + 1; <br> QLink[maxIndex]++; <br> Nodes[minIndex] = <font color="#0000ff">new</font> Node(maxIndex, Nodes[minIndex]); <br> } <br> } <br> } <br> <font color="#0000ff">protected</font> <font color="#0000ff">internal</font> <font color="#0000ff">int</font> FindNonRelatedNodeIndex() { <br> <font color="#0000ff">int</font> r = 0; <br> <font color="#0000ff">int</font> n = SourceObjects.Count; <br> <font color="#0000ff">for</font> ( <font color="#0000ff">int</font> i = 0; i &lt;= n; i++) { <br> <font color="#0000ff">if</font> (QLink[i] == 0) { <br> QLink[r] = i; <br> r = i; <br> } <br> } <br> <font color="#0000ff">return</font> r; <br> } <br> <font color="#0000ff">protected</font> <font color="#0000ff">virtual</font> IList&lt;T&gt; ProcessNodes( <font color="#0000ff">int</font> r) { <br> <font color="#0000ff">int</font> n = sourceObjects.Count; <br> <font color="#0000ff">int</font> k = n; <br> <br> <font color="#0000ff">int</font> f = QLink[0]; <br> <font color="#2B91AF">List</font> &lt;T&gt; result = <font color="#0000ff">new</font> <font color="#2B91AF">List</font> &lt;T&gt;(n); <br> <font color="#0000ff">while</font> (f &gt; 0) { <br> result.Add(sourceObjects[f - 1]); <br> k--; <br> <br> Node node = Nodes[f]; <br> <font color="#0000ff">while</font> (node != <font color="#0000ff">null</font> ) { <br> node = RemoveRelation(node, <font color="#0000ff">ref</font> r); <br> } <br> f = QLink[f]; <br> } <br> <font color="#0000ff">return</font> result; <br> <br> } <br> Node RemoveRelation(Node node, <font color="#0000ff">ref</font> <font color="#0000ff">int</font> r) { <br> <font color="#0000ff">int</font> suc_p = node.RefCount; <br> QLink[suc_p]--; <br> <br> <font color="#0000ff">if</font> (QLink[suc_p] == 0) { <br> QLink[r] = suc_p; <br> r = suc_p; <br> } <br> <font color="#0000ff">return</font> node.Next; <br> } <br> } <br> <font color="#0000ff">#endregion</font> <br></font> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br><br><h2>  findings </h2><br><br>  If necessary, in a specific order of processing objects that are dependent on each other, they can be pre-ordered by applying the topological sorting algorithm.  As a result, the correct sequence of objects and the execution of actions on them are constructed. <br><br>  The proposed algorithm provides the following advantages: <br><ul><li>  the use of generalization (generic), i.e.  It can be used to sort objects of various types. </li><li>  the ability to set your class Comparer, that is, it allows you to implement different logic for comparing objects. </li><li>  linearity algorithm, non-recursive algorithm </li></ul><br>  An example with source text is available <a href="http://www.devexpress.com/example%3DE3121">here</a> . <br><br>  I hope this material will be useful to you in future projects. </div><p>Source: <a href="https://habr.com/ru/post/116812/">https://habr.com/ru/post/116812/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../116802/index.html">Where to look for experts?</a></li>
<li><a href="../116805/index.html">iNT PRO and iNETTRADER - an app to trade stocks using your iPhone and iPad</a></li>
<li><a href="../116807/index.html">Conference Railsclub'Moscow April 30, 2011</a></li>
<li><a href="../116809/index.html">Windows 8: Ribbon and Metro UI to the masses</a></li>
<li><a href="../116810/index.html">Should a startup investor participate in the technical process of web development?</a></li>
<li><a href="../116813/index.html">Sberbank Post</a></li>
<li><a href="../116814/index.html">Video Kit: Sony Ericsson Xperia ARC vs HTC Desire HD</a></li>
<li><a href="../116815/index.html">CSS Pivot: A Website Design Sharing Platform</a></li>
<li><a href="../116817/index.html">DOOM on PocketBook 360 Plus</a></li>
<li><a href="../116818/index.html">RIF 2011: Personal Data Protection</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>