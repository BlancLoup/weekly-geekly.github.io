<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Comparing Rust and C ++ with examples</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Foreword 
 Here is the promised comparison of languages. Examples, of course, are artificial, so use your imagination to appreciate the scale of the t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Comparing Rust and C ++ with examples</h1><div class="post__text post__text-html js-mediator-article"><h4>  Foreword </h4><br>  Here is the <a href="http://habrahabr.ru/post/224607/">promised</a> comparison of languages.  Examples, of course, are artificial, so use your imagination to appreciate the scale of the threat in the real world. <br><br>  All C ++ programs were compiled using gcc-4.7.2 in c ++ 11 mode using an <a href="http://www.compileonline.com/compile_cpp11_online.php">online compiler</a> .  Rust programs were compiled with the latest version of Rust (nightly, 0.11-pre) using the <a href="http://playtest.rust-lang.org/">rust playpen</a> . <br><br>  I know that C ++ 14 (and further) will patch up the weak points of the language, as well as add new features.  Reflections on how backward compatibility prevents C ++ from reaching the stars (and preventing it) are beyond the scope of this article, but I would be interested to read your expert opinion in the comments.  Any information on D. is also welcome. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <a name="habracut"></a><br><h4>  Check Template Types </h4><br>  Author C ++ has long been displeased with how templates are implemented in the language, calling them " <i>compile-time duck typing</i> " in a recent speech on Lang-NEXT.  The problem is that it is not always clear how to instantiate a template by looking at its declaration.  The situation is worsened by monstrous error messages.  Try building, for example, this program: <br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;vector&gt; #include &lt;algorithm&gt; int main() { int a; std::vector&lt; std::vector &lt;int&gt; &gt; v; std::vector&lt; std::vector &lt;int&gt; &gt;::const_iterator it = std::find( v.begin(), v.end(), a ); }</span></span></span></span></code> </pre> <br>  Imagine the joy of a person reading a <a href="http://codegolf.stackexchange.com/questions/1956/generate-the-longest-error-message-in-c">multipage error message</a> if he created such a situation by accident. <br><br>  Templates in Rust are checked for correctness prior to their instantiation, so there is a clear separation between errors in the template itself (which should not be if you use someone else's / library template) and in the place of instantiation, where all that is required of you is to meet the requirements for type described in the template: <br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Sortable</span></span></span></span> {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sort</span></span></span></span>&lt;T: Sortable&gt;(array: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> [T]) {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { sort(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>]); }</code> </pre><br>  This code is not compiled for an obvious reason: <br><blockquote>  demo: 5: 5: 5: 9 error: failed to find out <br>  demo: 5 sort (&amp; mut [1,2,3]); <br></blockquote><br><br><h4>  Access to remote memory </h4><br>  There is a whole class of problems with C ++, expressed in indefinite behavior and falls, which arise from the attempt to use memory that has already been deleted. <br>  Example: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *x = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> x; *x = <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br>  In Rust, this kind of problem is impossible, since there are no memory removal commands.  The memory on the stack lives while it is in scope, and Rust does not allow references to it to survive this area (see the example of a lost pointer).  If the memory is allocated in the heap - then a pointer to it ( <pre> <code class="hljs rust"><code><code><code class="cpp"><span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>)     ,       (     ).        (std::rc::Rc)    (std::gc::Gc),      (   ). <br> <br>      <br>  ++: <br> #include &lt;stdio.h&gt; int *bar(int *p) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p; } int* foo(int n) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bar(&amp;n); } int main() { int *p1 = foo(<span class="hljs-number"><span class="hljs-number">1</span></span>); int *p2 = foo(<span class="hljs-number"><span class="hljs-number">2</span></span>); printf(<span class="hljs-string"><span class="hljs-string">"%d, %d\n"</span></span>, *p1, *p2); } <br>  : <br> <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span> <br> <br>  Rust: <br> <code class="rust"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt;(p: &amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> int) -&gt; &amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> int { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>(n: int) -&gt; &amp;int { bar(&amp;n) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> p1 = foo(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> p2 = foo(<span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{}, {}"</span></span>, *p1, *p2); }</code> <br>  : <br> demo:<span class="hljs-number"><span class="hljs-number">5</span></span>:<span class="hljs-number"><span class="hljs-number">10</span></span>: <span class="hljs-number"><span class="hljs-number">5</span></span>:<span class="hljs-number"><span class="hljs-number">11</span></span> error: `n` does not live long enough <br> demo:<span class="hljs-number"><span class="hljs-number">5</span></span> bar(&amp;n) <br> ^ <br> demo:<span class="hljs-number"><span class="hljs-number">4</span></span>:<span class="hljs-number"><span class="hljs-number">24</span></span>: <span class="hljs-number"><span class="hljs-number">6</span></span>:<span class="hljs-number"><span class="hljs-number">2</span></span> note: reference must <span class="hljs-keyword"><span class="hljs-keyword">be</span></span> valid <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> the anonymous lifetime #<span class="hljs-number"><span class="hljs-number">1</span></span> defined on the block at <span class="hljs-number"><span class="hljs-number">4</span></span>:<span class="hljs-number"><span class="hljs-number">23</span></span>... <br> demo:<span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>(n: int) -&gt; &amp;int { <br> demo:<span class="hljs-number"><span class="hljs-number">5</span></span> bar(&amp;n) <br> demo:<span class="hljs-number"><span class="hljs-number">6</span></span> } <br> demo:<span class="hljs-number"><span class="hljs-number">4</span></span>:<span class="hljs-number"><span class="hljs-number">24</span></span>: <span class="hljs-number"><span class="hljs-number">6</span></span>:<span class="hljs-number"><span class="hljs-number">2</span></span> note: ...but borrowed value is only valid <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> the block at <span class="hljs-number"><span class="hljs-number">4</span></span>:<span class="hljs-number"><span class="hljs-number">23</span></span> <br> demo:<span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>(n: int) -&gt; &amp;int { <br> demo:<span class="hljs-number"><span class="hljs-number">5</span></span> bar(&amp;n) <br> demo:<span class="hljs-number"><span class="hljs-number">6</span></span> } <br> <br>   <br> <code class="cpp">#include &lt;stdio.h&gt; int minval(int *A, int n) { int currmin; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;n; i++) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (A[i] &lt; currmin) currmin = A[i]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> currmin; } int main() { int A[] = {<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>}; int min = minval(A,<span class="hljs-number"><span class="hljs-number">3</span></span>); printf(<span class="hljs-string"><span class="hljs-string">"%d\n"</span></span>, min); }</code> <br>   <span class="hljs-number"><span class="hljs-number">0</span></span>  ,     , ,  .       Rust ( - ): <br> <code class="rust"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">minval</span></span></span></span>(A: &amp;[int]) -&gt; int { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> currmin; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> a <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> A.iter() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> *a &lt; currmin { currmin = *a; } } currmin } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> A = [<span class="hljs-number"><span class="hljs-number">1</span></span>i,<span class="hljs-number"><span class="hljs-number">2</span></span>i,<span class="hljs-number"><span class="hljs-number">3</span></span>i]; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> min = minval(A.as_slice()); <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{}"</span></span>, min); }</code> <br>  , : <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> of possibly uninitialized variable: `currmin` <br>   ( )      : <br> <code class="rust"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">minval</span></span></span></span>(A: &amp;[int]) -&gt; int { A.iter().fold(A[<span class="hljs-number"><span class="hljs-number">0</span></span>], |u,&amp;a| { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> a&lt;u {a} <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {u} }) }</code> <br> <br>    <br> <code class="cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span></span>{ int *x; A(int v): x(new int(v)) {} ~A() {delete x;} }; int main() { A a(<span class="hljs-number"><span class="hljs-number">1</span></span>), b=a; }</code> <br> ,    : <br> *** glibc detected *** demo: double free or corruption (fasttop): <span class="hljs-number"><span class="hljs-number">0x0000000000601010</span></span> *** <br> <br>     Rust: <br> <code class="rust"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span></span>{ x: <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;int&gt; } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> A { <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">new</span></span></span></span>(v: int) -&gt; A { A{ x: <span class="hljs-keyword"><span class="hljs-keyword">box</span></span> v } } } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Drop</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> A { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drop</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) {} <span class="hljs-comment"><span class="hljs-comment">// ,     ++ } fn main() { let a = A::new(1); let _b = a; }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">     .   ,     </span></span><code><span class="hljs-comment"><span class="hljs-comment">trait Copy</span></span></code><span class="hljs-comment"><span class="hljs-comment"> . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> Rust       .    </span></span><code><span class="hljs-comment"><span class="hljs-comment">Eq</span></span></code><span class="hljs-comment"><span class="hljs-comment">  </span></span><code><span class="hljs-comment"><span class="hljs-comment">Clone</span></span></code><span class="hljs-comment"><span class="hljs-comment"> ?    </span></span><code><span class="hljs-comment"><span class="hljs-comment">deriving</span></span></code><span class="hljs-comment"><span class="hljs-comment">   : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="rust"><span class="hljs-comment"><span class="hljs-comment">#[deriving(Clone, Eq, Hash, PartialEq, PartialOrd, Ord, Show)] struct A{ x: Box&lt;int&gt; }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">    </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="cpp"><span class="hljs-comment"><span class="hljs-comment">#include &lt;stdio.h&gt; struct X { int a, b; }; void swap_from(X&amp; x, const X&amp; y) { xa = yb; xb = ya; } int main() { X x = {1,2}; swap_from(x,x); printf("%d,%d\n", xa, xb); }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> 2,2 </span></span><br><span class="hljs-comment"><span class="hljs-comment">    ,    cc      .   ,   ,  99  </span></span><a href="http://en.wikipedia.org/wiki/Restrict"><span class="hljs-comment"><span class="hljs-comment">restrict</span></span></a><span class="hljs-comment"><span class="hljs-comment"> ,            :        . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">       Rust: </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="rust"><span class="hljs-comment"><span class="hljs-comment">struct X { pub a: int, pub b: int } fn swap_from(x: &amp;mut X, y: &amp;X) { xa = yb; xb = ya; } fn main() { let mut x = X{a:1, b:2}; swap_from(&amp;mut x, &amp;x); }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">    : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7:24: 7:25 error: cannot borrow `x` as immutable because it is also borrowed as mutable </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7 swap_from(&amp;mut x, &amp;x); </span></span><br><span class="hljs-comment"><span class="hljs-comment"> ^ </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7:20: 7:21 note: previous borrow of `x` occurs here; the mutable borrow prevents subsequent moves, borrows, or modification of `x` until the borrow ends </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7 swap_from(&amp;mut x, &amp;x); </span></span><br><span class="hljs-comment"><span class="hljs-comment"> ^ </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7:26: 7:26 note: previous borrow ends here </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7 swap_from(&amp;mut x, &amp;x); </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  ,             " </span></span><code><span class="hljs-comment"><span class="hljs-comment">&amp;mut</span></span></code><span class="hljs-comment"><span class="hljs-comment"> "  " </span></span><code><span class="hljs-comment"><span class="hljs-comment">&amp;</span></span></code><span class="hljs-comment"><span class="hljs-comment"> " ,   ,          ,   </span></span><code><span class="hljs-comment"><span class="hljs-comment">&amp;mut</span></span></code><span class="hljs-comment"><span class="hljs-comment"> .            .  ,    ,      C99  </span></span><code><span class="hljs-comment"><span class="hljs-comment">restrict</span></span></code><span class="hljs-comment"><span class="hljs-comment">  (Rust  LLVM    ),    . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">   </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="cpp"><span class="hljs-comment"><span class="hljs-comment">#include &lt;vector&gt; int main() { std::vector&lt;int&gt; v; v.push_back(1); v.push_back(2); for(std::vector&lt;int&gt;::const_iterator it=v.begin(); it!=v.end(); ++it) { if (*it &lt; 5) v.push_back(5-*it); } }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">    ,    : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> Segmentation fault (core dumped) </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">    Rust: </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="rust"><span class="hljs-comment"><span class="hljs-comment">fn main() { let mut v: Vec&lt;int&gt; = Vec::new(); v.push(1); v.push(2); for x in v.iter() { if *x &lt; 5 { v.push(5-*x); } } }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">      ,  ,        : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7:13: 7:14 error: cannot borrow `v` as mutable because it is also borrowed as immutable </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7 v.push(5-*x); </span></span><br><span class="hljs-comment"><span class="hljs-comment"> ^ </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:5:14: 5:15 note: previous borrow of `v` occurs here; the immutable borrow prevents subsequent moves or mutable borrows of `v` until the borrow ends </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:5 for x in v.iter() { </span></span><br><span class="hljs-comment"><span class="hljs-comment"> ^ </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:10:2: 10:2 note: previous borrow ends here </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:5 for x in v.iter() { </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:6 if *x &lt; 5 { </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7 v.push(5-*x); </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:8 } </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:9 } </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:10 } </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  Switch </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="cpp"><span class="hljs-comment"><span class="hljs-comment">#include &lt;stdio.h&gt; enum {RED, BLUE, GRAY, UNKNOWN} color = GRAY; int main() { int x; switch(color) { case GRAY: x=1; case RED: case BLUE: x=2; } printf("%d", x); }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">   "2".  Rust          .  ,       ,    </span></span><code><span class="hljs-comment"><span class="hljs-comment">break</span></span></code><span class="hljs-comment"><span class="hljs-comment"> .    Rust   : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="rust"><span class="hljs-comment"><span class="hljs-comment">enum Color {RED, BLUE, GRAY, UNKNOWN} fn main() { let color = GRAY; let x = match color { GRAY =&gt; 1, RED | BLUE =&gt; 2, _ =&gt; 3, }; println!("{}", x); }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">     </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="cpp"><span class="hljs-comment"><span class="hljs-comment">int main() { int pixels = 1; for (int j=0; j&lt;5; j++); pixels++; }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  Rust          . , ,     . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="cpp"><span class="hljs-comment"><span class="hljs-comment">#include &lt;stdio.h&gt; #include &lt;pthread.h&gt; #include &lt;unistd.h&gt; class Resource { int *value; public: Resource(): value(NULL) {} ~Resource() {delete value;} int *acquire() { if (!value) { value = new int(0); } return value; } }; void* function(void *param) { int *value = ((Resource*)param)-&gt;acquire(); printf("resource: %p\n", (void*)value); return value; } int main() { Resource res; for (int i=0; i&lt;5; ++i) { pthread_t pt; pthread_create(&amp;pt, NULL, function, &amp;res); } //sleep(10); printf("done\n"); }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">     : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> done </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7f229c0008c0 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7f22840008c0 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7f228c0008c0 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7f22940008c0 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7f227c0008c0 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">     ,        .      Rust: </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="rust"><span class="hljs-comment"><span class="hljs-comment">struct Resource { value: Option&lt;int&gt;, } impl Resource { pub fn new() -&gt; Resource { Resource{ value: None } } pub fn acquire&lt;'a&gt;(&amp;'a mut self) -&gt; &amp;'a int { if self.value.is_none() { self.value = Some(1); } self.value.get_ref() } } fn main() { let mut res = Resource::new(); for _ in range(0,5) { spawn(proc() { let ptr = res.acquire(); println!("resource {}", ptr) }) } }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  ,            . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:20:23: 20:26 error: cannot borrow immutable captured outer variable in a proc `res` as mutable </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:20 let ptr = res.acquire(); </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">      ,   : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="rust"><span class="hljs-comment"><span class="hljs-comment">extern crate sync; use sync::{Arc, RWLock}; struct Resource { value: Option&lt;Box&lt;int&gt;&gt;, } impl Resource { pub fn new() -&gt; Resource { Resource{ value: None } } pub fn acquire(&amp;mut self) -&gt; *int { if self.value.is_none() { self.value = Some(box 1) } &amp;**self.value.get_ref() as *int } } fn main() { let arc_res = Arc::new(RWLock::new(Resource::new())); for _ in range(0,5) { let child_res = arc_res.clone(); spawn(proc() { let ptr = child_res.write().acquire(); println!("resource: {}", ptr) }) } }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">     </span></span><code><span class="hljs-comment"><span class="hljs-comment">Arc</span></span></code><span class="hljs-comment"><span class="hljs-comment"> ( </span></span><i><span class="hljs-comment"><span class="hljs-comment">Atomically Reference Counted</span></span></i><span class="hljs-comment"><span class="hljs-comment"> -        )  </span></span><code><span class="hljs-comment"><span class="hljs-comment">RWLock</span></span></code><span class="hljs-comment"><span class="hljs-comment"> (   ).   : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7ff4b0010378 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7ff4b0010378 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7ff4b0010378 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7ff4b0010378 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7ff4b0010378 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  ,   ++    .    . Rust        ,    .  ,   ,   .           ,       ( </span></span><a href="http://superwebdeveloper.com/2009/11/25/the-incredible-rate-of-diminishing-returns-of-fixing-software-bugs/"><span class="hljs-comment"><span class="hljs-comment">  </span></span></a><span class="hljs-comment"><span class="hljs-comment"> ). </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">     </span></span><br><span class="hljs-comment"><span class="hljs-comment"> Rust        ,     </span></span><code><span class="hljs-comment"><span class="hljs-comment">unsafe{}</span></span></code><span class="hljs-comment"><span class="hljs-comment"> .   ,     " </span></span><i><span class="hljs-comment"><span class="hljs-comment"> !  ,  .</span></span></i><span class="hljs-comment"><span class="hljs-comment"> ".  ,  ""  (    ,    )    .    ,           ( )  . , ,        </span></span><code><span class="hljs-comment"><span class="hljs-comment">Cell</span></span></code><span class="hljs-comment"><span class="hljs-comment">  </span></span><code><span class="hljs-comment"><span class="hljs-comment">Mutex</span></span></code><span class="hljs-comment"><span class="hljs-comment"> .             ,       (   </span></span><a href="http://en.wikipedia.org/wiki/Test-driven_development"><span class="hljs-comment"><span class="hljs-comment">TDD</span></span></a><span class="hljs-comment"><span class="hljs-comment"> !). </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="https://air.mozilla.org/guaranteeing-memory-safety-in-rust/"><span class="hljs-comment"><span class="hljs-comment">Guaranteeing Memory Safety in Rust (by Niko Matsakis)</span></span></a><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="http://www.techtalkshub.com/rust-safe-systems-programming-fun-fp/"><span class="hljs-comment"><span class="hljs-comment">Rust: Safe Systems Programming with the Fun of FP (by Felix Klock II)</span></span></a><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Keynote"><span class="hljs-comment"><span class="hljs-comment">Lang-NEXT: What ‚Äì if anything ‚Äì have we learned from C++? (by Bjarne Stroustrup)</span></span></a><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Panel-Systems-Programming-Languages-in-2014-and-Beyond"><span class="hljs-comment"><span class="hljs-comment">Lang-NEXT Panel: Systems Programming in 2014 and Beyond</span></span></a></code></code></code></code> <h4> <code class="hljs rust"><code><code><code class="cpp"><span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>)     ,       (     ).        (std::rc::Rc)    (std::gc::Gc),      (   ). <br> <br></code>      <br>  ++: <br> #include &lt;stdio.h&gt; int *bar(int *p) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p; } int* foo(int n) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bar(&amp;n); } int main() { int *p1 = foo(<span class="hljs-number"><span class="hljs-number">1</span></span>); int *p2 = foo(<span class="hljs-number"><span class="hljs-number">2</span></span>); printf(<span class="hljs-string"><span class="hljs-string">"%d, %d\n"</span></span>, *p1, *p2); } <br>  : <br> <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span> <br> <br>  Rust: <br> <code class="rust"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt;(p: &amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> int) -&gt; &amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> int { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>(n: int) -&gt; &amp;int { bar(&amp;n) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> p1 = foo(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> p2 = foo(<span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{}, {}"</span></span>, *p1, *p2); }</code> <br>  : <br> demo:<span class="hljs-number"><span class="hljs-number">5</span></span>:<span class="hljs-number"><span class="hljs-number">10</span></span>: <span class="hljs-number"><span class="hljs-number">5</span></span>:<span class="hljs-number"><span class="hljs-number">11</span></span> error: `n` does not live long enough <br> demo:<span class="hljs-number"><span class="hljs-number">5</span></span> bar(&amp;n) <br> ^ <br> demo:<span class="hljs-number"><span class="hljs-number">4</span></span>:<span class="hljs-number"><span class="hljs-number">24</span></span>: <span class="hljs-number"><span class="hljs-number">6</span></span>:<span class="hljs-number"><span class="hljs-number">2</span></span> note: reference must <span class="hljs-keyword"><span class="hljs-keyword">be</span></span> valid <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> the anonymous lifetime #<span class="hljs-number"><span class="hljs-number">1</span></span> defined on the block at <span class="hljs-number"><span class="hljs-number">4</span></span>:<span class="hljs-number"><span class="hljs-number">23</span></span>... <br> demo:<span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>(n: int) -&gt; &amp;int { <br> demo:<span class="hljs-number"><span class="hljs-number">5</span></span> bar(&amp;n) <br> demo:<span class="hljs-number"><span class="hljs-number">6</span></span> } <br> demo:<span class="hljs-number"><span class="hljs-number">4</span></span>:<span class="hljs-number"><span class="hljs-number">24</span></span>: <span class="hljs-number"><span class="hljs-number">6</span></span>:<span class="hljs-number"><span class="hljs-number">2</span></span> note: ...but borrowed value is only valid <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> the block at <span class="hljs-number"><span class="hljs-number">4</span></span>:<span class="hljs-number"><span class="hljs-number">23</span></span> <br> demo:<span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>(n: int) -&gt; &amp;int { <br> demo:<span class="hljs-number"><span class="hljs-number">5</span></span> bar(&amp;n) <br> demo:<span class="hljs-number"><span class="hljs-number">6</span></span> } <br> <br>   <br> <code class="cpp">#include &lt;stdio.h&gt; int minval(int *A, int n) { int currmin; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;n; i++) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (A[i] &lt; currmin) currmin = A[i]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> currmin; } int main() { int A[] = {<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>}; int min = minval(A,<span class="hljs-number"><span class="hljs-number">3</span></span>); printf(<span class="hljs-string"><span class="hljs-string">"%d\n"</span></span>, min); }</code> <br>   <span class="hljs-number"><span class="hljs-number">0</span></span>  ,     , ,  .       Rust ( - ): <br> <code class="rust"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">minval</span></span></span></span>(A: &amp;[int]) -&gt; int { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> currmin; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> a <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> A.iter() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> *a &lt; currmin { currmin = *a; } } currmin } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> A = [<span class="hljs-number"><span class="hljs-number">1</span></span>i,<span class="hljs-number"><span class="hljs-number">2</span></span>i,<span class="hljs-number"><span class="hljs-number">3</span></span>i]; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> min = minval(A.as_slice()); <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{}"</span></span>, min); }</code> <br>  , : <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> of possibly uninitialized variable: `currmin` <br>   ( )      : <br> <code class="rust"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">minval</span></span></span></span>(A: &amp;[int]) -&gt; int { A.iter().fold(A[<span class="hljs-number"><span class="hljs-number">0</span></span>], |u,&amp;a| { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> a&lt;u {a} <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {u} }) }</code> <br> <br>    <br> <code class="cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span></span>{ int *x; A(int v): x(new int(v)) {} ~A() {delete x;} }; int main() { A a(<span class="hljs-number"><span class="hljs-number">1</span></span>), b=a; }</code> <br> ,    : <br> *** glibc detected *** demo: double free or corruption (fasttop): <span class="hljs-number"><span class="hljs-number">0x0000000000601010</span></span> *** <br> <br>     Rust: <br> <code class="rust"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span></span>{ x: <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;int&gt; } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> A { <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">new</span></span></span></span>(v: int) -&gt; A { A{ x: <span class="hljs-keyword"><span class="hljs-keyword">box</span></span> v } } } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Drop</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> A { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drop</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) {} <span class="hljs-comment"><span class="hljs-comment">// ,     ++ } fn main() { let a = A::new(1); let _b = a; }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">     .   ,     </span></span><code><span class="hljs-comment"><span class="hljs-comment">trait Copy</span></span></code><span class="hljs-comment"><span class="hljs-comment"> . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> Rust       .    </span></span><code><span class="hljs-comment"><span class="hljs-comment">Eq</span></span></code><span class="hljs-comment"><span class="hljs-comment">  </span></span><code><span class="hljs-comment"><span class="hljs-comment">Clone</span></span></code><span class="hljs-comment"><span class="hljs-comment"> ?    </span></span><code><span class="hljs-comment"><span class="hljs-comment">deriving</span></span></code><span class="hljs-comment"><span class="hljs-comment">   : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="rust"><span class="hljs-comment"><span class="hljs-comment">#[deriving(Clone, Eq, Hash, PartialEq, PartialOrd, Ord, Show)] struct A{ x: Box&lt;int&gt; }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">    </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="cpp"><span class="hljs-comment"><span class="hljs-comment">#include &lt;stdio.h&gt; struct X { int a, b; }; void swap_from(X&amp; x, const X&amp; y) { xa = yb; xb = ya; } int main() { X x = {1,2}; swap_from(x,x); printf("%d,%d\n", xa, xb); }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> 2,2 </span></span><br><span class="hljs-comment"><span class="hljs-comment">    ,    cc      .   ,   ,  99  </span></span><a href="http://en.wikipedia.org/wiki/Restrict"><span class="hljs-comment"><span class="hljs-comment">restrict</span></span></a><span class="hljs-comment"><span class="hljs-comment"> ,            :        . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">       Rust: </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="rust"><span class="hljs-comment"><span class="hljs-comment">struct X { pub a: int, pub b: int } fn swap_from(x: &amp;mut X, y: &amp;X) { xa = yb; xb = ya; } fn main() { let mut x = X{a:1, b:2}; swap_from(&amp;mut x, &amp;x); }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">    : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7:24: 7:25 error: cannot borrow `x` as immutable because it is also borrowed as mutable </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7 swap_from(&amp;mut x, &amp;x); </span></span><br><span class="hljs-comment"><span class="hljs-comment"> ^ </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7:20: 7:21 note: previous borrow of `x` occurs here; the mutable borrow prevents subsequent moves, borrows, or modification of `x` until the borrow ends </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7 swap_from(&amp;mut x, &amp;x); </span></span><br><span class="hljs-comment"><span class="hljs-comment"> ^ </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7:26: 7:26 note: previous borrow ends here </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7 swap_from(&amp;mut x, &amp;x); </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  ,             " </span></span><code><span class="hljs-comment"><span class="hljs-comment">&amp;mut</span></span></code><span class="hljs-comment"><span class="hljs-comment"> "  " </span></span><code><span class="hljs-comment"><span class="hljs-comment">&amp;</span></span></code><span class="hljs-comment"><span class="hljs-comment"> " ,   ,          ,   </span></span><code><span class="hljs-comment"><span class="hljs-comment">&amp;mut</span></span></code><span class="hljs-comment"><span class="hljs-comment"> .            .  ,    ,      C99  </span></span><code><span class="hljs-comment"><span class="hljs-comment">restrict</span></span></code><span class="hljs-comment"><span class="hljs-comment">  (Rust  LLVM    ),    . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">   </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="cpp"><span class="hljs-comment"><span class="hljs-comment">#include &lt;vector&gt; int main() { std::vector&lt;int&gt; v; v.push_back(1); v.push_back(2); for(std::vector&lt;int&gt;::const_iterator it=v.begin(); it!=v.end(); ++it) { if (*it &lt; 5) v.push_back(5-*it); } }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">    ,    : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> Segmentation fault (core dumped) </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">    Rust: </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="rust"><span class="hljs-comment"><span class="hljs-comment">fn main() { let mut v: Vec&lt;int&gt; = Vec::new(); v.push(1); v.push(2); for x in v.iter() { if *x &lt; 5 { v.push(5-*x); } } }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">      ,  ,        : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7:13: 7:14 error: cannot borrow `v` as mutable because it is also borrowed as immutable </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7 v.push(5-*x); </span></span><br><span class="hljs-comment"><span class="hljs-comment"> ^ </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:5:14: 5:15 note: previous borrow of `v` occurs here; the immutable borrow prevents subsequent moves or mutable borrows of `v` until the borrow ends </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:5 for x in v.iter() { </span></span><br><span class="hljs-comment"><span class="hljs-comment"> ^ </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:10:2: 10:2 note: previous borrow ends here </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:5 for x in v.iter() { </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:6 if *x &lt; 5 { </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7 v.push(5-*x); </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:8 } </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:9 } </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:10 } </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  Switch </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="cpp"><span class="hljs-comment"><span class="hljs-comment">#include &lt;stdio.h&gt; enum {RED, BLUE, GRAY, UNKNOWN} color = GRAY; int main() { int x; switch(color) { case GRAY: x=1; case RED: case BLUE: x=2; } printf("%d", x); }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">   "2".  Rust          .  ,       ,    </span></span><code><span class="hljs-comment"><span class="hljs-comment">break</span></span></code><span class="hljs-comment"><span class="hljs-comment"> .    Rust   : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="rust"><span class="hljs-comment"><span class="hljs-comment">enum Color {RED, BLUE, GRAY, UNKNOWN} fn main() { let color = GRAY; let x = match color { GRAY =&gt; 1, RED | BLUE =&gt; 2, _ =&gt; 3, }; println!("{}", x); }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">     </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="cpp"><span class="hljs-comment"><span class="hljs-comment">int main() { int pixels = 1; for (int j=0; j&lt;5; j++); pixels++; }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  Rust          . , ,     . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="cpp"><span class="hljs-comment"><span class="hljs-comment">#include &lt;stdio.h&gt; #include &lt;pthread.h&gt; #include &lt;unistd.h&gt; class Resource { int *value; public: Resource(): value(NULL) {} ~Resource() {delete value;} int *acquire() { if (!value) { value = new int(0); } return value; } }; void* function(void *param) { int *value = ((Resource*)param)-&gt;acquire(); printf("resource: %p\n", (void*)value); return value; } int main() { Resource res; for (int i=0; i&lt;5; ++i) { pthread_t pt; pthread_create(&amp;pt, NULL, function, &amp;res); } //sleep(10); printf("done\n"); }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">     : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> done </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7f229c0008c0 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7f22840008c0 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7f228c0008c0 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7f22940008c0 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7f227c0008c0 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">     ,        .      Rust: </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="rust"><span class="hljs-comment"><span class="hljs-comment">struct Resource { value: Option&lt;int&gt;, } impl Resource { pub fn new() -&gt; Resource { Resource{ value: None } } pub fn acquire&lt;'a&gt;(&amp;'a mut self) -&gt; &amp;'a int { if self.value.is_none() { self.value = Some(1); } self.value.get_ref() } } fn main() { let mut res = Resource::new(); for _ in range(0,5) { spawn(proc() { let ptr = res.acquire(); println!("resource {}", ptr) }) } }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  ,            . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:20:23: 20:26 error: cannot borrow immutable captured outer variable in a proc `res` as mutable </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:20 let ptr = res.acquire(); </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">      ,   : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="rust"><span class="hljs-comment"><span class="hljs-comment">extern crate sync; use sync::{Arc, RWLock}; struct Resource { value: Option&lt;Box&lt;int&gt;&gt;, } impl Resource { pub fn new() -&gt; Resource { Resource{ value: None } } pub fn acquire(&amp;mut self) -&gt; *int { if self.value.is_none() { self.value = Some(box 1) } &amp;**self.value.get_ref() as *int } } fn main() { let arc_res = Arc::new(RWLock::new(Resource::new())); for _ in range(0,5) { let child_res = arc_res.clone(); spawn(proc() { let ptr = child_res.write().acquire(); println!("resource: {}", ptr) }) } }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">     </span></span><code><span class="hljs-comment"><span class="hljs-comment">Arc</span></span></code><span class="hljs-comment"><span class="hljs-comment"> ( </span></span><i><span class="hljs-comment"><span class="hljs-comment">Atomically Reference Counted</span></span></i><span class="hljs-comment"><span class="hljs-comment"> -        )  </span></span><code><span class="hljs-comment"><span class="hljs-comment">RWLock</span></span></code><span class="hljs-comment"><span class="hljs-comment"> (   ).   : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7ff4b0010378 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7ff4b0010378 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7ff4b0010378 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7ff4b0010378 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7ff4b0010378 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  ,   ++    .    . Rust        ,    .  ,   ,   .           ,       ( </span></span><a href="http://superwebdeveloper.com/2009/11/25/the-incredible-rate-of-diminishing-returns-of-fixing-software-bugs/"><span class="hljs-comment"><span class="hljs-comment">  </span></span></a><span class="hljs-comment"><span class="hljs-comment"> ). </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">     </span></span><br><span class="hljs-comment"><span class="hljs-comment"> Rust        ,     </span></span><code><span class="hljs-comment"><span class="hljs-comment">unsafe{}</span></span></code><span class="hljs-comment"><span class="hljs-comment"> .   ,     " </span></span><i><span class="hljs-comment"><span class="hljs-comment"> !  ,  .</span></span></i><span class="hljs-comment"><span class="hljs-comment"> ".  ,  ""  (    ,    )    .    ,           ( )  . , ,        </span></span><code><span class="hljs-comment"><span class="hljs-comment">Cell</span></span></code><span class="hljs-comment"><span class="hljs-comment">  </span></span><code><span class="hljs-comment"><span class="hljs-comment">Mutex</span></span></code><span class="hljs-comment"><span class="hljs-comment"> .             ,       (   </span></span><a href="http://en.wikipedia.org/wiki/Test-driven_development"><span class="hljs-comment"><span class="hljs-comment">TDD</span></span></a><span class="hljs-comment"><span class="hljs-comment"> !). </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="https://air.mozilla.org/guaranteeing-memory-safety-in-rust/"><span class="hljs-comment"><span class="hljs-comment">Guaranteeing Memory Safety in Rust (by Niko Matsakis)</span></span></a><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="http://www.techtalkshub.com/rust-safe-systems-programming-fun-fp/"><span class="hljs-comment"><span class="hljs-comment">Rust: Safe Systems Programming with the Fun of FP (by Felix Klock II)</span></span></a><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Keynote"><span class="hljs-comment"><span class="hljs-comment">Lang-NEXT: What ‚Äì if anything ‚Äì have we learned from C++? (by Bjarne Stroustrup)</span></span></a><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Panel-Systems-Programming-Languages-in-2014-and-Beyond"><span class="hljs-comment"><span class="hljs-comment">Lang-NEXT Panel: Systems Programming in 2014 and Beyond</span></span></a></code></code></code> </h4> <code class="hljs rust"><code><code><code class="cpp"><span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>)     ,       (     ).        (std::rc::Rc)    (std::gc::Gc),      (   ). <br> <br></code>      <br>  ++: <br> #include &lt;stdio.h&gt; int *bar(int *p) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p; } int* foo(int n) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bar(&amp;n); } int main() { int *p1 = foo(<span class="hljs-number"><span class="hljs-number">1</span></span>); int *p2 = foo(<span class="hljs-number"><span class="hljs-number">2</span></span>); printf(<span class="hljs-string"><span class="hljs-string">"%d, %d\n"</span></span>, *p1, *p2); }</code> <br>  : <br> <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span> <br> <br>  Rust: <br> <code class="rust"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt;(p: &amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> int) -&gt; &amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> int { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>(n: int) -&gt; &amp;int { bar(&amp;n) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> p1 = foo(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> p2 = foo(<span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{}, {}"</span></span>, *p1, *p2); }</code> <br>  : <br> demo:<span class="hljs-number"><span class="hljs-number">5</span></span>:<span class="hljs-number"><span class="hljs-number">10</span></span>: <span class="hljs-number"><span class="hljs-number">5</span></span>:<span class="hljs-number"><span class="hljs-number">11</span></span> error: `n` does not live long enough <br> demo:<span class="hljs-number"><span class="hljs-number">5</span></span> bar(&amp;n) <br> ^ <br> demo:<span class="hljs-number"><span class="hljs-number">4</span></span>:<span class="hljs-number"><span class="hljs-number">24</span></span>: <span class="hljs-number"><span class="hljs-number">6</span></span>:<span class="hljs-number"><span class="hljs-number">2</span></span> note: reference must <span class="hljs-keyword"><span class="hljs-keyword">be</span></span> valid <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> the anonymous lifetime #<span class="hljs-number"><span class="hljs-number">1</span></span> defined on the block at <span class="hljs-number"><span class="hljs-number">4</span></span>:<span class="hljs-number"><span class="hljs-number">23</span></span>... <br> demo:<span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>(n: int) -&gt; &amp;int { <br> demo:<span class="hljs-number"><span class="hljs-number">5</span></span> bar(&amp;n) <br> demo:<span class="hljs-number"><span class="hljs-number">6</span></span> } <br> demo:<span class="hljs-number"><span class="hljs-number">4</span></span>:<span class="hljs-number"><span class="hljs-number">24</span></span>: <span class="hljs-number"><span class="hljs-number">6</span></span>:<span class="hljs-number"><span class="hljs-number">2</span></span> note: ...but borrowed value is only valid <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> the block at <span class="hljs-number"><span class="hljs-number">4</span></span>:<span class="hljs-number"><span class="hljs-number">23</span></span> <br> demo:<span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>(n: int) -&gt; &amp;int { <br> demo:<span class="hljs-number"><span class="hljs-number">5</span></span> bar(&amp;n) <br> demo:<span class="hljs-number"><span class="hljs-number">6</span></span> } <br> <br>   <br> <code class="cpp">#include &lt;stdio.h&gt; int minval(int *A, int n) { int currmin; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;n; i++) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (A[i] &lt; currmin) currmin = A[i]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> currmin; } int main() { int A[] = {<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>}; int min = minval(A,<span class="hljs-number"><span class="hljs-number">3</span></span>); printf(<span class="hljs-string"><span class="hljs-string">"%d\n"</span></span>, min); }</code> <br>   <span class="hljs-number"><span class="hljs-number">0</span></span>  ,     , ,  .       Rust ( - ): <br> <code class="rust"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">minval</span></span></span></span>(A: &amp;[int]) -&gt; int { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> currmin; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> a <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> A.iter() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> *a &lt; currmin { currmin = *a; } } currmin } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> A = [<span class="hljs-number"><span class="hljs-number">1</span></span>i,<span class="hljs-number"><span class="hljs-number">2</span></span>i,<span class="hljs-number"><span class="hljs-number">3</span></span>i]; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> min = minval(A.as_slice()); <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{}"</span></span>, min); }</code> <br>  , : <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> of possibly uninitialized variable: `currmin` <br>   ( )      : <br> <code class="rust"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">minval</span></span></span></span>(A: &amp;[int]) -&gt; int { A.iter().fold(A[<span class="hljs-number"><span class="hljs-number">0</span></span>], |u,&amp;a| { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> a&lt;u {a} <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {u} }) }</code> <br> <br>    <br> <code class="cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span></span>{ int *x; A(int v): x(new int(v)) {} ~A() {delete x;} }; int main() { A a(<span class="hljs-number"><span class="hljs-number">1</span></span>), b=a; }</code> <br> ,    : <br> *** glibc detected *** demo: double free or corruption (fasttop): <span class="hljs-number"><span class="hljs-number">0x0000000000601010</span></span> *** <br> <br>     Rust: <br> <code class="rust"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span></span>{ x: <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;int&gt; } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> A { <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">new</span></span></span></span>(v: int) -&gt; A { A{ x: <span class="hljs-keyword"><span class="hljs-keyword">box</span></span> v } } } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Drop</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> A { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drop</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) {} <span class="hljs-comment"><span class="hljs-comment">// ,     ++ } fn main() { let a = A::new(1); let _b = a; }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">     .   ,     </span></span><code><span class="hljs-comment"><span class="hljs-comment">trait Copy</span></span></code><span class="hljs-comment"><span class="hljs-comment"> . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> Rust       .    </span></span><code><span class="hljs-comment"><span class="hljs-comment">Eq</span></span></code><span class="hljs-comment"><span class="hljs-comment">  </span></span><code><span class="hljs-comment"><span class="hljs-comment">Clone</span></span></code><span class="hljs-comment"><span class="hljs-comment"> ?    </span></span><code><span class="hljs-comment"><span class="hljs-comment">deriving</span></span></code><span class="hljs-comment"><span class="hljs-comment">   : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="rust"><span class="hljs-comment"><span class="hljs-comment">#[deriving(Clone, Eq, Hash, PartialEq, PartialOrd, Ord, Show)] struct A{ x: Box&lt;int&gt; }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">    </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="cpp"><span class="hljs-comment"><span class="hljs-comment">#include &lt;stdio.h&gt; struct X { int a, b; }; void swap_from(X&amp; x, const X&amp; y) { xa = yb; xb = ya; } int main() { X x = {1,2}; swap_from(x,x); printf("%d,%d\n", xa, xb); }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> 2,2 </span></span><br><span class="hljs-comment"><span class="hljs-comment">    ,    cc      .   ,   ,  99  </span></span><a href="http://en.wikipedia.org/wiki/Restrict"><span class="hljs-comment"><span class="hljs-comment">restrict</span></span></a><span class="hljs-comment"><span class="hljs-comment"> ,            :        . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">       Rust: </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="rust"><span class="hljs-comment"><span class="hljs-comment">struct X { pub a: int, pub b: int } fn swap_from(x: &amp;mut X, y: &amp;X) { xa = yb; xb = ya; } fn main() { let mut x = X{a:1, b:2}; swap_from(&amp;mut x, &amp;x); }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">    : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7:24: 7:25 error: cannot borrow `x` as immutable because it is also borrowed as mutable </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7 swap_from(&amp;mut x, &amp;x); </span></span><br><span class="hljs-comment"><span class="hljs-comment"> ^ </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7:20: 7:21 note: previous borrow of `x` occurs here; the mutable borrow prevents subsequent moves, borrows, or modification of `x` until the borrow ends </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7 swap_from(&amp;mut x, &amp;x); </span></span><br><span class="hljs-comment"><span class="hljs-comment"> ^ </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7:26: 7:26 note: previous borrow ends here </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7 swap_from(&amp;mut x, &amp;x); </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  ,             " </span></span><code><span class="hljs-comment"><span class="hljs-comment">&amp;mut</span></span></code><span class="hljs-comment"><span class="hljs-comment"> "  " </span></span><code><span class="hljs-comment"><span class="hljs-comment">&amp;</span></span></code><span class="hljs-comment"><span class="hljs-comment"> " ,   ,          ,   </span></span><code><span class="hljs-comment"><span class="hljs-comment">&amp;mut</span></span></code><span class="hljs-comment"><span class="hljs-comment"> .            .  ,    ,      C99  </span></span><code><span class="hljs-comment"><span class="hljs-comment">restrict</span></span></code><span class="hljs-comment"><span class="hljs-comment">  (Rust  LLVM    ),    . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">   </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="cpp"><span class="hljs-comment"><span class="hljs-comment">#include &lt;vector&gt; int main() { std::vector&lt;int&gt; v; v.push_back(1); v.push_back(2); for(std::vector&lt;int&gt;::const_iterator it=v.begin(); it!=v.end(); ++it) { if (*it &lt; 5) v.push_back(5-*it); } }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">    ,    : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> Segmentation fault (core dumped) </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">    Rust: </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="rust"><span class="hljs-comment"><span class="hljs-comment">fn main() { let mut v: Vec&lt;int&gt; = Vec::new(); v.push(1); v.push(2); for x in v.iter() { if *x &lt; 5 { v.push(5-*x); } } }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">      ,  ,        : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7:13: 7:14 error: cannot borrow `v` as mutable because it is also borrowed as immutable </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7 v.push(5-*x); </span></span><br><span class="hljs-comment"><span class="hljs-comment"> ^ </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:5:14: 5:15 note: previous borrow of `v` occurs here; the immutable borrow prevents subsequent moves or mutable borrows of `v` until the borrow ends </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:5 for x in v.iter() { </span></span><br><span class="hljs-comment"><span class="hljs-comment"> ^ </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:10:2: 10:2 note: previous borrow ends here </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:5 for x in v.iter() { </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:6 if *x &lt; 5 { </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7 v.push(5-*x); </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:8 } </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:9 } </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:10 } </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  Switch </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="cpp"><span class="hljs-comment"><span class="hljs-comment">#include &lt;stdio.h&gt; enum {RED, BLUE, GRAY, UNKNOWN} color = GRAY; int main() { int x; switch(color) { case GRAY: x=1; case RED: case BLUE: x=2; } printf("%d", x); }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">   "2".  Rust          .  ,       ,    </span></span><code><span class="hljs-comment"><span class="hljs-comment">break</span></span></code><span class="hljs-comment"><span class="hljs-comment"> .    Rust   : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="rust"><span class="hljs-comment"><span class="hljs-comment">enum Color {RED, BLUE, GRAY, UNKNOWN} fn main() { let color = GRAY; let x = match color { GRAY =&gt; 1, RED | BLUE =&gt; 2, _ =&gt; 3, }; println!("{}", x); }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">     </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="cpp"><span class="hljs-comment"><span class="hljs-comment">int main() { int pixels = 1; for (int j=0; j&lt;5; j++); pixels++; }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  Rust          . , ,     . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="cpp"><span class="hljs-comment"><span class="hljs-comment">#include &lt;stdio.h&gt; #include &lt;pthread.h&gt; #include &lt;unistd.h&gt; class Resource { int *value; public: Resource(): value(NULL) {} ~Resource() {delete value;} int *acquire() { if (!value) { value = new int(0); } return value; } }; void* function(void *param) { int *value = ((Resource*)param)-&gt;acquire(); printf("resource: %p\n", (void*)value); return value; } int main() { Resource res; for (int i=0; i&lt;5; ++i) { pthread_t pt; pthread_create(&amp;pt, NULL, function, &amp;res); } //sleep(10); printf("done\n"); }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">     : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> done </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7f229c0008c0 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7f22840008c0 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7f228c0008c0 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7f22940008c0 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7f227c0008c0 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">     ,        .      Rust: </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="rust"><span class="hljs-comment"><span class="hljs-comment">struct Resource { value: Option&lt;int&gt;, } impl Resource { pub fn new() -&gt; Resource { Resource{ value: None } } pub fn acquire&lt;'a&gt;(&amp;'a mut self) -&gt; &amp;'a int { if self.value.is_none() { self.value = Some(1); } self.value.get_ref() } } fn main() { let mut res = Resource::new(); for _ in range(0,5) { spawn(proc() { let ptr = res.acquire(); println!("resource {}", ptr) }) } }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  ,            . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:20:23: 20:26 error: cannot borrow immutable captured outer variable in a proc `res` as mutable </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:20 let ptr = res.acquire(); </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">      ,   : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="rust"><span class="hljs-comment"><span class="hljs-comment">extern crate sync; use sync::{Arc, RWLock}; struct Resource { value: Option&lt;Box&lt;int&gt;&gt;, } impl Resource { pub fn new() -&gt; Resource { Resource{ value: None } } pub fn acquire(&amp;mut self) -&gt; *int { if self.value.is_none() { self.value = Some(box 1) } &amp;**self.value.get_ref() as *int } } fn main() { let arc_res = Arc::new(RWLock::new(Resource::new())); for _ in range(0,5) { let child_res = arc_res.clone(); spawn(proc() { let ptr = child_res.write().acquire(); println!("resource: {}", ptr) }) } }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">     </span></span><code><span class="hljs-comment"><span class="hljs-comment">Arc</span></span></code><span class="hljs-comment"><span class="hljs-comment"> ( </span></span><i><span class="hljs-comment"><span class="hljs-comment">Atomically Reference Counted</span></span></i><span class="hljs-comment"><span class="hljs-comment"> -        )  </span></span><code><span class="hljs-comment"><span class="hljs-comment">RWLock</span></span></code><span class="hljs-comment"><span class="hljs-comment"> (   ).   : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7ff4b0010378 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7ff4b0010378 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7ff4b0010378 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7ff4b0010378 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7ff4b0010378 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  ,   ++    .    . Rust        ,    .  ,   ,   .           ,       ( </span></span><a href="http://superwebdeveloper.com/2009/11/25/the-incredible-rate-of-diminishing-returns-of-fixing-software-bugs/"><span class="hljs-comment"><span class="hljs-comment">  </span></span></a><span class="hljs-comment"><span class="hljs-comment"> ). </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">     </span></span><br><span class="hljs-comment"><span class="hljs-comment"> Rust        ,     </span></span><code><span class="hljs-comment"><span class="hljs-comment">unsafe{}</span></span></code><span class="hljs-comment"><span class="hljs-comment"> .   ,     " </span></span><i><span class="hljs-comment"><span class="hljs-comment"> !  ,  .</span></span></i><span class="hljs-comment"><span class="hljs-comment"> ".  ,  ""  (    ,    )    .    ,           ( )  . , ,        </span></span><code><span class="hljs-comment"><span class="hljs-comment">Cell</span></span></code><span class="hljs-comment"><span class="hljs-comment">  </span></span><code><span class="hljs-comment"><span class="hljs-comment">Mutex</span></span></code><span class="hljs-comment"><span class="hljs-comment"> .             ,       (   </span></span><a href="http://en.wikipedia.org/wiki/Test-driven_development"><span class="hljs-comment"><span class="hljs-comment">TDD</span></span></a><span class="hljs-comment"><span class="hljs-comment"> !). </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="https://air.mozilla.org/guaranteeing-memory-safety-in-rust/"><span class="hljs-comment"><span class="hljs-comment">Guaranteeing Memory Safety in Rust (by Niko Matsakis)</span></span></a><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="http://www.techtalkshub.com/rust-safe-systems-programming-fun-fp/"><span class="hljs-comment"><span class="hljs-comment">Rust: Safe Systems Programming with the Fun of FP (by Felix Klock II)</span></span></a><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Keynote"><span class="hljs-comment"><span class="hljs-comment">Lang-NEXT: What ‚Äì if anything ‚Äì have we learned from C++? (by Bjarne Stroustrup)</span></span></a><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Panel-Systems-Programming-Languages-in-2014-and-Beyond"><span class="hljs-comment"><span class="hljs-comment">Lang-NEXT Panel: Systems Programming in 2014 and Beyond</span></span></a></code></code> </pre> <code><code><code><code class="cpp">Box)     ,       (     ).        (std::rc::Rc)    (std::gc::Gc),      (   ). <br> <br></code>      <br>  ++: <br> #include &lt;stdio.h&gt; int *bar(int *p) { return p; } int* foo(int n) { return bar(&amp;n); } int main() { int *p1 = foo(1); int *p2 = foo(2); printf("%d, %d\n", *p1, *p2); }</code> <br>  : <br> 2, 2 <br> <br>  Rust: <br> <code class="rust">fn bar&lt;'a&gt;(p: &amp;'a int) -&gt; &amp;'a int { return p; } fn foo(n: int) -&gt; &amp;int { bar(&amp;n) } fn main() { let p1 = foo(1); let p2 = foo(2); println!("{}, {}", *p1, *p2); }</code> <br>  : <br> demo:5:10: 5:11 error: `n` does not live long enough <br> demo:5 bar(&amp;n) <br> ^ <br> demo:4:24: 6:2 note: reference must be valid for the anonymous lifetime #1 defined on the block at 4:23... <br> demo:4 fn foo(n: int) -&gt; &amp;int { <br> demo:5 bar(&amp;n) <br> demo:6 } <br> demo:4:24: 6:2 note: ...but borrowed value is only valid for the block at 4:23 <br> demo:4 fn foo(n: int) -&gt; &amp;int { <br> demo:5 bar(&amp;n) <br> demo:6 } <br> <br>   <br> <code class="cpp">#include &lt;stdio.h&gt; int minval(int *A, int n) { int currmin; for (int i=0; i&lt;n; i++) if (A[i] &lt; currmin) currmin = A[i]; return currmin; } int main() { int A[] = {1,2,3}; int min = minval(A,3); printf("%d\n", min); }</code> <br>   0  ,     , ,  .       Rust ( - ): <br> <code class="rust">fn minval(A: &amp;[int]) -&gt; int { let mut currmin; for a in A.iter() { if *a &lt; currmin { currmin = *a; } } currmin } fn main() { let A = [1i,2i,3i]; let min = minval(A.as_slice()); println!("{}", min); }</code> <br>  , : use of possibly uninitialized variable: `currmin` <br>   ( )      : <br> <code class="rust">fn minval(A: &amp;[int]) -&gt; int { A.iter().fold(A[0], |u,&amp;a| { if a&lt;u {a} else {u} }) }</code> <br> <br>    <br> <code class="cpp">struct A{ int *x; A(int v): x(new int(v)) {} ~A() {delete x;} }; int main() { A a(1), b=a; }</code> <br> ,    : <br> *** glibc detected *** demo: double free or corruption (fasttop): 0x0000000000601010 *** <br> <br>     Rust: <br> <code class="rust">struct A{ x: Box&lt;int&gt; } impl A { pub fn new(v: int) -&gt; A { A{ x: box v } } } impl Drop for A { fn drop(&amp;mut self) {} // ,     ++ } fn main() { let a = A::new(1); let _b = a; }</code> <br>     .   ,     <code>trait Copy</code> . <br> Rust       .    <code>Eq</code>  <code>Clone</code> ?    <code>deriving</code>   : <br> <code class="rust">#[deriving(Clone, Eq, Hash, PartialEq, PartialOrd, Ord, Show)] struct A{ x: Box&lt;int&gt; }</code> <br> <br>    <br> <code class="cpp">#include &lt;stdio.h&gt; struct X { int a, b; }; void swap_from(X&amp; x, const X&amp; y) { xa = yb; xb = ya; } int main() { X x = {1,2}; swap_from(x,x); printf("%d,%d\n", xa, xb); }</code> <br>  : <br> 2,2 <br>    ,    cc      .   ,   ,  99  <a href="http://en.wikipedia.org/wiki/Restrict">restrict</a> ,            :        . <br> <br>       Rust: <br> <code class="rust">struct X { pub a: int, pub b: int } fn swap_from(x: &amp;mut X, y: &amp;X) { xa = yb; xb = ya; } fn main() { let mut x = X{a:1, b:2}; swap_from(&amp;mut x, &amp;x); }</code> <br>    : <br> demo:7:24: 7:25 error: cannot borrow `x` as immutable because it is also borrowed as mutable <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> ^ <br> demo:7:20: 7:21 note: previous borrow of `x` occurs here; the mutable borrow prevents subsequent moves, borrows, or modification of `x` until the borrow ends <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> ^ <br> demo:7:26: 7:26 note: previous borrow ends here <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> <br>  ,             " <code>&amp;mut</code> "  " <code>&amp;</code> " ,   ,          ,   <code>&amp;mut</code> .            .  ,    ,      C99  <code>restrict</code>  (Rust  LLVM    ),    . <br> <br>   <br> <code class="cpp">#include &lt;vector&gt; int main() { std::vector&lt;int&gt; v; v.push_back(1); v.push_back(2); for(std::vector&lt;int&gt;::const_iterator it=v.begin(); it!=v.end(); ++it) { if (*it &lt; 5) v.push_back(5-*it); } }</code> <br>    ,    : <br> Segmentation fault (core dumped) <br> <br>    Rust: <br> <code class="rust">fn main() { let mut v: Vec&lt;int&gt; = Vec::new(); v.push(1); v.push(2); for x in v.iter() { if *x &lt; 5 { v.push(5-*x); } } }</code> <br>      ,  ,        : <br> demo:7:13: 7:14 error: cannot borrow `v` as mutable because it is also borrowed as immutable <br> demo:7 v.push(5-*x); <br> ^ <br> demo:5:14: 5:15 note: previous borrow of `v` occurs here; the immutable borrow prevents subsequent moves or mutable borrows of `v` until the borrow ends <br> demo:5 for x in v.iter() { <br> ^ <br> demo:10:2: 10:2 note: previous borrow ends here <br> demo:5 for x in v.iter() { <br> demo:6 if *x &lt; 5 { <br> demo:7 v.push(5-*x); <br> demo:8 } <br> demo:9 } <br> demo:10 } <br> <br> <br>  Switch <br> <code class="cpp">#include &lt;stdio.h&gt; enum {RED, BLUE, GRAY, UNKNOWN} color = GRAY; int main() { int x; switch(color) { case GRAY: x=1; case RED: case BLUE: x=2; } printf("%d", x); }</code> <br>   "2".  Rust          .  ,       ,    <code>break</code> .    Rust   : <br> <code class="rust">enum Color {RED, BLUE, GRAY, UNKNOWN} fn main() { let color = GRAY; let x = match color { GRAY =&gt; 1, RED | BLUE =&gt; 2, _ =&gt; 3, }; println!("{}", x); }</code> <br> <br>     <br> <code class="cpp">int main() { int pixels = 1; for (int j=0; j&lt;5; j++); pixels++; }</code> <br>  Rust          . , ,     . <br> <br>  <br> <code class="cpp">#include &lt;stdio.h&gt; #include &lt;pthread.h&gt; #include &lt;unistd.h&gt; class Resource { int *value; public: Resource(): value(NULL) {} ~Resource() {delete value;} int *acquire() { if (!value) { value = new int(0); } return value; } }; void* function(void *param) { int *value = ((Resource*)param)-&gt;acquire(); printf("resource: %p\n", (void*)value); return value; } int main() { Resource res; for (int i=0; i&lt;5; ++i) { pthread_t pt; pthread_create(&amp;pt, NULL, function, &amp;res); } //sleep(10); printf("done\n"); }</code> <br>     : <br> done <br> resource: 0x7f229c0008c0 <br> resource: 0x7f22840008c0 <br> resource: 0x7f228c0008c0 <br> resource: 0x7f22940008c0 <br> resource: 0x7f227c0008c0 <br> <br>     ,        .      Rust: <br> <code class="rust">struct Resource { value: Option&lt;int&gt;, } impl Resource { pub fn new() -&gt; Resource { Resource{ value: None } } pub fn acquire&lt;'a&gt;(&amp;'a mut self) -&gt; &amp;'a int { if self.value.is_none() { self.value = Some(1); } self.value.get_ref() } } fn main() { let mut res = Resource::new(); for _ in range(0,5) { spawn(proc() { let ptr = res.acquire(); println!("resource {}", ptr) }) } }</code> <br>  ,            . <br> demo:20:23: 20:26 error: cannot borrow immutable captured outer variable in a proc `res` as mutable <br> demo:20 let ptr = res.acquire(); <br> <br>      ,   : <br> <code class="rust">extern crate sync; use sync::{Arc, RWLock}; struct Resource { value: Option&lt;Box&lt;int&gt;&gt;, } impl Resource { pub fn new() -&gt; Resource { Resource{ value: None } } pub fn acquire(&amp;mut self) -&gt; *int { if self.value.is_none() { self.value = Some(box 1) } &amp;**self.value.get_ref() as *int } } fn main() { let arc_res = Arc::new(RWLock::new(Resource::new())); for _ in range(0,5) { let child_res = arc_res.clone(); spawn(proc() { let ptr = child_res.write().acquire(); println!("resource: {}", ptr) }) } }</code> <br>     <code>Arc</code> ( <i>Atomically Reference Counted</i> -        )  <code>RWLock</code> (   ).   : <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> <br>  ,   ++    .    . Rust        ,    .  ,   ,   .           ,       ( <a href="http://superwebdeveloper.com/2009/11/25/the-incredible-rate-of-diminishing-returns-of-fixing-software-bugs/">  </a> ). <br> <br>     <br> Rust        ,     <code>unsafe{}</code> .   ,     " <i> !  ,  .</i> ".  ,  ""  (    ,    )    .    ,           ( )  . , ,        <code>Cell</code>  <code>Mutex</code> .             ,       (   <a href="http://en.wikipedia.org/wiki/Test-driven_development">TDD</a> !). <br> <br>  <br> <a href="https://air.mozilla.org/guaranteeing-memory-safety-in-rust/">Guaranteeing Memory Safety in Rust (by Niko Matsakis)</a> <br> <a href="http://www.techtalkshub.com/rust-safe-systems-programming-fun-fp/">Rust: Safe Systems Programming with the Fun of FP (by Felix Klock II)</a> <br> <a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Keynote">Lang-NEXT: What ‚Äì if anything ‚Äì have we learned from C++? (by Bjarne Stroustrup)</a> <br> <a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Panel-Systems-Programming-Languages-in-2014-and-Beyond">Lang-NEXT Panel: Systems Programming in 2014 and Beyond</a></code></code> <blockquote> <code><code><code><code class="cpp">Box)     ,       (     ).        (std::rc::Rc)    (std::gc::Gc),      (   ). <br> <br></code>      <br>  ++: <br> #include &lt;stdio.h&gt; int *bar(int *p) { return p; } int* foo(int n) { return bar(&amp;n); } int main() { int *p1 = foo(1); int *p2 = foo(2); printf("%d, %d\n", *p1, *p2); }</code> <br>  : <br> 2, 2 <br> <br>  Rust: <br> <code class="rust">fn bar&lt;'a&gt;(p: &amp;'a int) -&gt; &amp;'a int { return p; } fn foo(n: int) -&gt; &amp;int { bar(&amp;n) } fn main() { let p1 = foo(1); let p2 = foo(2); println!("{}, {}", *p1, *p2); }</code> <br>  : <br> demo:5:10: 5:11 error: `n` does not live long enough <br> demo:5 bar(&amp;n) <br> ^ <br> demo:4:24: 6:2 note: reference must be valid for the anonymous lifetime #1 defined on the block at 4:23... <br> demo:4 fn foo(n: int) -&gt; &amp;int { <br> demo:5 bar(&amp;n) <br> demo:6 } <br> demo:4:24: 6:2 note: ...but borrowed value is only valid for the block at 4:23 <br> demo:4 fn foo(n: int) -&gt; &amp;int { <br> demo:5 bar(&amp;n) <br> demo:6 } <br> <br>   <br> <code class="cpp">#include &lt;stdio.h&gt; int minval(int *A, int n) { int currmin; for (int i=0; i&lt;n; i++) if (A[i] &lt; currmin) currmin = A[i]; return currmin; } int main() { int A[] = {1,2,3}; int min = minval(A,3); printf("%d\n", min); }</code> <br>   0  ,     , ,  .       Rust ( - ): <br> <code class="rust">fn minval(A: &amp;[int]) -&gt; int { let mut currmin; for a in A.iter() { if *a &lt; currmin { currmin = *a; } } currmin } fn main() { let A = [1i,2i,3i]; let min = minval(A.as_slice()); println!("{}", min); }</code> <br>  , : use of possibly uninitialized variable: `currmin` <br>   ( )      : <br> <code class="rust">fn minval(A: &amp;[int]) -&gt; int { A.iter().fold(A[0], |u,&amp;a| { if a&lt;u {a} else {u} }) }</code> <br> <br>    <br> <code class="cpp">struct A{ int *x; A(int v): x(new int(v)) {} ~A() {delete x;} }; int main() { A a(1), b=a; }</code> <br> ,    : <br> *** glibc detected *** demo: double free or corruption (fasttop): 0x0000000000601010 *** <br> <br>     Rust: <br> <code class="rust">struct A{ x: Box&lt;int&gt; } impl A { pub fn new(v: int) -&gt; A { A{ x: box v } } } impl Drop for A { fn drop(&amp;mut self) {} // ,     ++ } fn main() { let a = A::new(1); let _b = a; }</code> <br>     .   ,     <code>trait Copy</code> . <br> Rust       .    <code>Eq</code>  <code>Clone</code> ?    <code>deriving</code>   : <br> <code class="rust">#[deriving(Clone, Eq, Hash, PartialEq, PartialOrd, Ord, Show)] struct A{ x: Box&lt;int&gt; }</code> <br> <br>    <br> <code class="cpp">#include &lt;stdio.h&gt; struct X { int a, b; }; void swap_from(X&amp; x, const X&amp; y) { xa = yb; xb = ya; } int main() { X x = {1,2}; swap_from(x,x); printf("%d,%d\n", xa, xb); }</code> <br>  : <br> 2,2 <br>    ,    cc      .   ,   ,  99  <a href="http://en.wikipedia.org/wiki/Restrict">restrict</a> ,            :        . <br> <br>       Rust: <br> <code class="rust">struct X { pub a: int, pub b: int } fn swap_from(x: &amp;mut X, y: &amp;X) { xa = yb; xb = ya; } fn main() { let mut x = X{a:1, b:2}; swap_from(&amp;mut x, &amp;x); }</code> <br>    : <br> demo:7:24: 7:25 error: cannot borrow `x` as immutable because it is also borrowed as mutable <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> ^ <br> demo:7:20: 7:21 note: previous borrow of `x` occurs here; the mutable borrow prevents subsequent moves, borrows, or modification of `x` until the borrow ends <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> ^ <br> demo:7:26: 7:26 note: previous borrow ends here <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> <br>  ,             " <code>&amp;mut</code> "  " <code>&amp;</code> " ,   ,          ,   <code>&amp;mut</code> .            .  ,    ,      C99  <code>restrict</code>  (Rust  LLVM    ),    . <br> <br>   <br> <code class="cpp">#include &lt;vector&gt; int main() { std::vector&lt;int&gt; v; v.push_back(1); v.push_back(2); for(std::vector&lt;int&gt;::const_iterator it=v.begin(); it!=v.end(); ++it) { if (*it &lt; 5) v.push_back(5-*it); } }</code> <br>    ,    : <br> Segmentation fault (core dumped) <br> <br>    Rust: <br> <code class="rust">fn main() { let mut v: Vec&lt;int&gt; = Vec::new(); v.push(1); v.push(2); for x in v.iter() { if *x &lt; 5 { v.push(5-*x); } } }</code> <br>      ,  ,        : <br> demo:7:13: 7:14 error: cannot borrow `v` as mutable because it is also borrowed as immutable <br> demo:7 v.push(5-*x); <br> ^ <br> demo:5:14: 5:15 note: previous borrow of `v` occurs here; the immutable borrow prevents subsequent moves or mutable borrows of `v` until the borrow ends <br> demo:5 for x in v.iter() { <br> ^ <br> demo:10:2: 10:2 note: previous borrow ends here <br> demo:5 for x in v.iter() { <br> demo:6 if *x &lt; 5 { <br> demo:7 v.push(5-*x); <br> demo:8 } <br> demo:9 } <br> demo:10 } <br> <br> <br>  Switch <br> <code class="cpp">#include &lt;stdio.h&gt; enum {RED, BLUE, GRAY, UNKNOWN} color = GRAY; int main() { int x; switch(color) { case GRAY: x=1; case RED: case BLUE: x=2; } printf("%d", x); }</code> <br>   "2".  Rust          .  ,       ,    <code>break</code> .    Rust   : <br> <code class="rust">enum Color {RED, BLUE, GRAY, UNKNOWN} fn main() { let color = GRAY; let x = match color { GRAY =&gt; 1, RED | BLUE =&gt; 2, _ =&gt; 3, }; println!("{}", x); }</code> <br> <br>     <br> <code class="cpp">int main() { int pixels = 1; for (int j=0; j&lt;5; j++); pixels++; }</code> <br>  Rust          . , ,     . <br> <br>  <br> <code class="cpp">#include &lt;stdio.h&gt; #include &lt;pthread.h&gt; #include &lt;unistd.h&gt; class Resource { int *value; public: Resource(): value(NULL) {} ~Resource() {delete value;} int *acquire() { if (!value) { value = new int(0); } return value; } }; void* function(void *param) { int *value = ((Resource*)param)-&gt;acquire(); printf("resource: %p\n", (void*)value); return value; } int main() { Resource res; for (int i=0; i&lt;5; ++i) { pthread_t pt; pthread_create(&amp;pt, NULL, function, &amp;res); } //sleep(10); printf("done\n"); }</code> <br>     : <br> done <br> resource: 0x7f229c0008c0 <br> resource: 0x7f22840008c0 <br> resource: 0x7f228c0008c0 <br> resource: 0x7f22940008c0 <br> resource: 0x7f227c0008c0 <br> <br>     ,        .      Rust: <br> <code class="rust">struct Resource { value: Option&lt;int&gt;, } impl Resource { pub fn new() -&gt; Resource { Resource{ value: None } } pub fn acquire&lt;'a&gt;(&amp;'a mut self) -&gt; &amp;'a int { if self.value.is_none() { self.value = Some(1); } self.value.get_ref() } } fn main() { let mut res = Resource::new(); for _ in range(0,5) { spawn(proc() { let ptr = res.acquire(); println!("resource {}", ptr) }) } }</code> <br>  ,            . <br> demo:20:23: 20:26 error: cannot borrow immutable captured outer variable in a proc `res` as mutable <br> demo:20 let ptr = res.acquire(); <br> <br>      ,   : <br> <code class="rust">extern crate sync; use sync::{Arc, RWLock}; struct Resource { value: Option&lt;Box&lt;int&gt;&gt;, } impl Resource { pub fn new() -&gt; Resource { Resource{ value: None } } pub fn acquire(&amp;mut self) -&gt; *int { if self.value.is_none() { self.value = Some(box 1) } &amp;**self.value.get_ref() as *int } } fn main() { let arc_res = Arc::new(RWLock::new(Resource::new())); for _ in range(0,5) { let child_res = arc_res.clone(); spawn(proc() { let ptr = child_res.write().acquire(); println!("resource: {}", ptr) }) } }</code> <br>     <code>Arc</code> ( <i>Atomically Reference Counted</i> -        )  <code>RWLock</code> (   ).   : <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> <br>  ,   ++    .    . Rust        ,    .  ,   ,   .           ,       ( <a href="http://superwebdeveloper.com/2009/11/25/the-incredible-rate-of-diminishing-returns-of-fixing-software-bugs/">  </a> ). <br> <br>     <br> Rust        ,     <code>unsafe{}</code> .   ,     " <i> !  ,  .</i> ".  ,  ""  (    ,    )    .    ,           ( )  . , ,        <code>Cell</code>  <code>Mutex</code> .             ,       (   <a href="http://en.wikipedia.org/wiki/Test-driven_development">TDD</a> !). <br> <br>  <br> <a href="https://air.mozilla.org/guaranteeing-memory-safety-in-rust/">Guaranteeing Memory Safety in Rust (by Niko Matsakis)</a> <br> <a href="http://www.techtalkshub.com/rust-safe-systems-programming-fun-fp/">Rust: Safe Systems Programming with the Fun of FP (by Felix Klock II)</a> <br> <a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Keynote">Lang-NEXT: What ‚Äì if anything ‚Äì have we learned from C++? (by Bjarne Stroustrup)</a> <br> <a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Panel-Systems-Programming-Languages-in-2014-and-Beyond">Lang-NEXT Panel: Systems Programming in 2014 and Beyond</a></code></code> </blockquote> <code><code><code><code class="cpp">Box)     ,       (     ).        (std::rc::Rc)    (std::gc::Gc),      (   ). <br> <br></code>      <br>  ++: <br> #include &lt;stdio.h&gt; int *bar(int *p) { return p; } int* foo(int n) { return bar(&amp;n); } int main() { int *p1 = foo(1); int *p2 = foo(2); printf("%d, %d\n", *p1, *p2); }</code> <br>  : <br> 2, 2 <br> <br>  Rust: <br> <code class="rust">fn bar&lt;'a&gt;(p: &amp;'a int) -&gt; &amp;'a int { return p; } fn foo(n: int) -&gt; &amp;int { bar(&amp;n) } fn main() { let p1 = foo(1); let p2 = foo(2); println!("{}, {}", *p1, *p2); }</code> <br>  : <br> demo:5:10: 5:11 error: `n` does not live long enough <br> demo:5 bar(&amp;n) <br> ^ <br> demo:4:24: 6:2 note: reference must be valid for the anonymous lifetime #1 defined on the block at 4:23... <br> demo:4 fn foo(n: int) -&gt; &amp;int { <br> demo:5 bar(&amp;n) <br> demo:6 } <br> demo:4:24: 6:2 note: ...but borrowed value is only valid for the block at 4:23 <br> demo:4 fn foo(n: int) -&gt; &amp;int { <br> demo:5 bar(&amp;n) <br> demo:6 } <br> <br>   <br> <code class="cpp">#include &lt;stdio.h&gt; int minval(int *A, int n) { int currmin; for (int i=0; i&lt;n; i++) if (A[i] &lt; currmin) currmin = A[i]; return currmin; } int main() { int A[] = {1,2,3}; int min = minval(A,3); printf("%d\n", min); }</code> <br>   0  ,     , ,  .       Rust ( - ): <br> <code class="rust">fn minval(A: &amp;[int]) -&gt; int { let mut currmin; for a in A.iter() { if *a &lt; currmin { currmin = *a; } } currmin } fn main() { let A = [1i,2i,3i]; let min = minval(A.as_slice()); println!("{}", min); }</code> <br>  , : use of possibly uninitialized variable: `currmin` <br>   ( )      : <br> <code class="rust">fn minval(A: &amp;[int]) -&gt; int { A.iter().fold(A[0], |u,&amp;a| { if a&lt;u {a} else {u} }) }</code> <br> <br>    <br> <code class="cpp">struct A{ int *x; A(int v): x(new int(v)) {} ~A() {delete x;} }; int main() { A a(1), b=a; }</code> <br> ,    : <br> *** glibc detected *** demo: double free or corruption (fasttop): 0x0000000000601010 *** <br> <br>     Rust: <br> <code class="rust">struct A{ x: Box&lt;int&gt; } impl A { pub fn new(v: int) -&gt; A { A{ x: box v } } } impl Drop for A { fn drop(&amp;mut self) {} // ,     ++ } fn main() { let a = A::new(1); let _b = a; }</code> <br>     .   ,     <code>trait Copy</code> . <br> Rust       .    <code>Eq</code>  <code>Clone</code> ?    <code>deriving</code>   : <br> <code class="rust">#[deriving(Clone, Eq, Hash, PartialEq, PartialOrd, Ord, Show)] struct A{ x: Box&lt;int&gt; }</code> <br> <br>    <br> <code class="cpp">#include &lt;stdio.h&gt; struct X { int a, b; }; void swap_from(X&amp; x, const X&amp; y) { xa = yb; xb = ya; } int main() { X x = {1,2}; swap_from(x,x); printf("%d,%d\n", xa, xb); }</code> <br>  : <br> 2,2 <br>    ,    cc      .   ,   ,  99  <a href="http://en.wikipedia.org/wiki/Restrict">restrict</a> ,            :        . <br> <br>       Rust: <br> <code class="rust">struct X { pub a: int, pub b: int } fn swap_from(x: &amp;mut X, y: &amp;X) { xa = yb; xb = ya; } fn main() { let mut x = X{a:1, b:2}; swap_from(&amp;mut x, &amp;x); }</code> <br>    : <br> demo:7:24: 7:25 error: cannot borrow `x` as immutable because it is also borrowed as mutable <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> ^ <br> demo:7:20: 7:21 note: previous borrow of `x` occurs here; the mutable borrow prevents subsequent moves, borrows, or modification of `x` until the borrow ends <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> ^ <br> demo:7:26: 7:26 note: previous borrow ends here <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> <br>  ,             " <code>&amp;mut</code> "  " <code>&amp;</code> " ,   ,          ,   <code>&amp;mut</code> .            .  ,    ,      C99  <code>restrict</code>  (Rust  LLVM    ),    . <br> <br>   <br> <code class="cpp">#include &lt;vector&gt; int main() { std::vector&lt;int&gt; v; v.push_back(1); v.push_back(2); for(std::vector&lt;int&gt;::const_iterator it=v.begin(); it!=v.end(); ++it) { if (*it &lt; 5) v.push_back(5-*it); } }</code> <br>    ,    : <br> Segmentation fault (core dumped) <br> <br>    Rust: <br> <code class="rust">fn main() { let mut v: Vec&lt;int&gt; = Vec::new(); v.push(1); v.push(2); for x in v.iter() { if *x &lt; 5 { v.push(5-*x); } } }</code> <br>      ,  ,        : <br> demo:7:13: 7:14 error: cannot borrow `v` as mutable because it is also borrowed as immutable <br> demo:7 v.push(5-*x); <br> ^ <br> demo:5:14: 5:15 note: previous borrow of `v` occurs here; the immutable borrow prevents subsequent moves or mutable borrows of `v` until the borrow ends <br> demo:5 for x in v.iter() { <br> ^ <br> demo:10:2: 10:2 note: previous borrow ends here <br> demo:5 for x in v.iter() { <br> demo:6 if *x &lt; 5 { <br> demo:7 v.push(5-*x); <br> demo:8 } <br> demo:9 } <br> demo:10 } <br> <br> <br>  Switch <br> <code class="cpp">#include &lt;stdio.h&gt; enum {RED, BLUE, GRAY, UNKNOWN} color = GRAY; int main() { int x; switch(color) { case GRAY: x=1; case RED: case BLUE: x=2; } printf("%d", x); }</code> <br>   "2".  Rust          .  ,       ,    <code>break</code> .    Rust   : <br> <code class="rust">enum Color {RED, BLUE, GRAY, UNKNOWN} fn main() { let color = GRAY; let x = match color { GRAY =&gt; 1, RED | BLUE =&gt; 2, _ =&gt; 3, }; println!("{}", x); }</code> <br> <br>     <br> <code class="cpp">int main() { int pixels = 1; for (int j=0; j&lt;5; j++); pixels++; }</code> <br>  Rust          . , ,     . <br> <br>  <br> <code class="cpp">#include &lt;stdio.h&gt; #include &lt;pthread.h&gt; #include &lt;unistd.h&gt; class Resource { int *value; public: Resource(): value(NULL) {} ~Resource() {delete value;} int *acquire() { if (!value) { value = new int(0); } return value; } }; void* function(void *param) { int *value = ((Resource*)param)-&gt;acquire(); printf("resource: %p\n", (void*)value); return value; } int main() { Resource res; for (int i=0; i&lt;5; ++i) { pthread_t pt; pthread_create(&amp;pt, NULL, function, &amp;res); } //sleep(10); printf("done\n"); }</code> <br>     : <br> done <br> resource: 0x7f229c0008c0 <br> resource: 0x7f22840008c0 <br> resource: 0x7f228c0008c0 <br> resource: 0x7f22940008c0 <br> resource: 0x7f227c0008c0 <br> <br>     ,        .      Rust: <br> <code class="rust">struct Resource { value: Option&lt;int&gt;, } impl Resource { pub fn new() -&gt; Resource { Resource{ value: None } } pub fn acquire&lt;'a&gt;(&amp;'a mut self) -&gt; &amp;'a int { if self.value.is_none() { self.value = Some(1); } self.value.get_ref() } } fn main() { let mut res = Resource::new(); for _ in range(0,5) { spawn(proc() { let ptr = res.acquire(); println!("resource {}", ptr) }) } }</code> <br>  ,            . <br> demo:20:23: 20:26 error: cannot borrow immutable captured outer variable in a proc `res` as mutable <br> demo:20 let ptr = res.acquire(); <br> <br>      ,   : <br> <code class="rust">extern crate sync; use sync::{Arc, RWLock}; struct Resource { value: Option&lt;Box&lt;int&gt;&gt;, } impl Resource { pub fn new() -&gt; Resource { Resource{ value: None } } pub fn acquire(&amp;mut self) -&gt; *int { if self.value.is_none() { self.value = Some(box 1) } &amp;**self.value.get_ref() as *int } } fn main() { let arc_res = Arc::new(RWLock::new(Resource::new())); for _ in range(0,5) { let child_res = arc_res.clone(); spawn(proc() { let ptr = child_res.write().acquire(); println!("resource: {}", ptr) }) } }</code> <br>     <code>Arc</code> ( <i>Atomically Reference Counted</i> -        )  <code>RWLock</code> (   ).   : <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> <br>  ,   ++    .    . Rust        ,    .  ,   ,   .           ,       ( <a href="http://superwebdeveloper.com/2009/11/25/the-incredible-rate-of-diminishing-returns-of-fixing-software-bugs/">  </a> ). <br> <br>     <br> Rust        ,     <code>unsafe{}</code> .   ,     " <i> !  ,  .</i> ".  ,  ""  (    ,    )    .    ,           ( )  . , ,        <code>Cell</code>  <code>Mutex</code> .             ,       (   <a href="http://en.wikipedia.org/wiki/Test-driven_development">TDD</a> !). <br> <br>  <br> <a href="https://air.mozilla.org/guaranteeing-memory-safety-in-rust/">Guaranteeing Memory Safety in Rust (by Niko Matsakis)</a> <br> <a href="http://www.techtalkshub.com/rust-safe-systems-programming-fun-fp/">Rust: Safe Systems Programming with the Fun of FP (by Felix Klock II)</a> <br> <a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Keynote">Lang-NEXT: What ‚Äì if anything ‚Äì have we learned from C++? (by Bjarne Stroustrup)</a> <br> <a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Panel-Systems-Programming-Languages-in-2014-and-Beyond">Lang-NEXT Panel: Systems Programming in 2014 and Beyond</a></code></code> <pre> <code class="hljs rust"><code><code><code class="cpp"><span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>)     ,       (     ).        (std::rc::Rc)    (std::gc::Gc),      (   ). <br> <br></code>      <br>  ++: <br> #include &lt;stdio.h&gt; int *bar(int *p) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p; } int* foo(int n) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bar(&amp;n); } int main() { int *p1 = foo(<span class="hljs-number"><span class="hljs-number">1</span></span>); int *p2 = foo(<span class="hljs-number"><span class="hljs-number">2</span></span>); printf(<span class="hljs-string"><span class="hljs-string">"%d, %d\n"</span></span>, *p1, *p2); }</code> <br>  : <br> <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span> <br> <br>  Rust: <br> <code class="rust"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt;(p: &amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> int) -&gt; &amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> int { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>(n: int) -&gt; &amp;int { bar(&amp;n) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> p1 = foo(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> p2 = foo(<span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{}, {}"</span></span>, *p1, *p2); }</code> <br>  : <br> demo:<span class="hljs-number"><span class="hljs-number">5</span></span>:<span class="hljs-number"><span class="hljs-number">10</span></span>: <span class="hljs-number"><span class="hljs-number">5</span></span>:<span class="hljs-number"><span class="hljs-number">11</span></span> error: `n` does not live long enough <br> demo:<span class="hljs-number"><span class="hljs-number">5</span></span> bar(&amp;n) <br> ^ <br> demo:<span class="hljs-number"><span class="hljs-number">4</span></span>:<span class="hljs-number"><span class="hljs-number">24</span></span>: <span class="hljs-number"><span class="hljs-number">6</span></span>:<span class="hljs-number"><span class="hljs-number">2</span></span> note: reference must <span class="hljs-keyword"><span class="hljs-keyword">be</span></span> valid <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> the anonymous lifetime #<span class="hljs-number"><span class="hljs-number">1</span></span> defined on the block at <span class="hljs-number"><span class="hljs-number">4</span></span>:<span class="hljs-number"><span class="hljs-number">23</span></span>... <br> demo:<span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>(n: int) -&gt; &amp;int { <br> demo:<span class="hljs-number"><span class="hljs-number">5</span></span> bar(&amp;n) <br> demo:<span class="hljs-number"><span class="hljs-number">6</span></span> } <br> demo:<span class="hljs-number"><span class="hljs-number">4</span></span>:<span class="hljs-number"><span class="hljs-number">24</span></span>: <span class="hljs-number"><span class="hljs-number">6</span></span>:<span class="hljs-number"><span class="hljs-number">2</span></span> note: ...but borrowed value is only valid <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> the block at <span class="hljs-number"><span class="hljs-number">4</span></span>:<span class="hljs-number"><span class="hljs-number">23</span></span> <br> demo:<span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>(n: int) -&gt; &amp;int { <br> demo:<span class="hljs-number"><span class="hljs-number">5</span></span> bar(&amp;n) <br> demo:<span class="hljs-number"><span class="hljs-number">6</span></span> } <br> <br>   <br> <code class="cpp">#include &lt;stdio.h&gt; int minval(int *A, int n) { int currmin; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;n; i++) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (A[i] &lt; currmin) currmin = A[i]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> currmin; } int main() { int A[] = {<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>}; int min = minval(A,<span class="hljs-number"><span class="hljs-number">3</span></span>); printf(<span class="hljs-string"><span class="hljs-string">"%d\n"</span></span>, min); }</code> <br>   <span class="hljs-number"><span class="hljs-number">0</span></span>  ,     , ,  .       Rust ( - ): <br> <code class="rust"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">minval</span></span></span></span>(A: &amp;[int]) -&gt; int { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> currmin; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> a <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> A.iter() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> *a &lt; currmin { currmin = *a; } } currmin } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> A = [<span class="hljs-number"><span class="hljs-number">1</span></span>i,<span class="hljs-number"><span class="hljs-number">2</span></span>i,<span class="hljs-number"><span class="hljs-number">3</span></span>i]; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> min = minval(A.as_slice()); <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{}"</span></span>, min); }</code> <br>  , : <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> of possibly uninitialized variable: `currmin` <br>   ( )      : <br> <code class="rust"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">minval</span></span></span></span>(A: &amp;[int]) -&gt; int { A.iter().fold(A[<span class="hljs-number"><span class="hljs-number">0</span></span>], |u,&amp;a| { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> a&lt;u {a} <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {u} }) }</code> <br> <br>    <br> <code class="cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span></span>{ int *x; A(int v): x(new int(v)) {} ~A() {delete x;} }; int main() { A a(<span class="hljs-number"><span class="hljs-number">1</span></span>), b=a; }</code> <br> ,    : <br> *** glibc detected *** demo: double free or corruption (fasttop): <span class="hljs-number"><span class="hljs-number">0x0000000000601010</span></span> *** <br> <br>     Rust: <br> <code class="rust"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span></span>{ x: <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;int&gt; } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> A { <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">new</span></span></span></span>(v: int) -&gt; A { A{ x: <span class="hljs-keyword"><span class="hljs-keyword">box</span></span> v } } } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Drop</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> A { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drop</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) {} <span class="hljs-comment"><span class="hljs-comment">// ,     ++ } fn main() { let a = A::new(1); let _b = a; }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">     .   ,     </span></span><code><span class="hljs-comment"><span class="hljs-comment">trait Copy</span></span></code><span class="hljs-comment"><span class="hljs-comment"> . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> Rust       .    </span></span><code><span class="hljs-comment"><span class="hljs-comment">Eq</span></span></code><span class="hljs-comment"><span class="hljs-comment">  </span></span><code><span class="hljs-comment"><span class="hljs-comment">Clone</span></span></code><span class="hljs-comment"><span class="hljs-comment"> ?    </span></span><code><span class="hljs-comment"><span class="hljs-comment">deriving</span></span></code><span class="hljs-comment"><span class="hljs-comment">   : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="rust"><span class="hljs-comment"><span class="hljs-comment">#[deriving(Clone, Eq, Hash, PartialEq, PartialOrd, Ord, Show)] struct A{ x: Box&lt;int&gt; }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">    </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="cpp"><span class="hljs-comment"><span class="hljs-comment">#include &lt;stdio.h&gt; struct X { int a, b; }; void swap_from(X&amp; x, const X&amp; y) { xa = yb; xb = ya; } int main() { X x = {1,2}; swap_from(x,x); printf("%d,%d\n", xa, xb); }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> 2,2 </span></span><br><span class="hljs-comment"><span class="hljs-comment">    ,    cc      .   ,   ,  99  </span></span><a href="http://en.wikipedia.org/wiki/Restrict"><span class="hljs-comment"><span class="hljs-comment">restrict</span></span></a><span class="hljs-comment"><span class="hljs-comment"> ,            :        . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">       Rust: </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="rust"><span class="hljs-comment"><span class="hljs-comment">struct X { pub a: int, pub b: int } fn swap_from(x: &amp;mut X, y: &amp;X) { xa = yb; xb = ya; } fn main() { let mut x = X{a:1, b:2}; swap_from(&amp;mut x, &amp;x); }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">    : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7:24: 7:25 error: cannot borrow `x` as immutable because it is also borrowed as mutable </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7 swap_from(&amp;mut x, &amp;x); </span></span><br><span class="hljs-comment"><span class="hljs-comment"> ^ </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7:20: 7:21 note: previous borrow of `x` occurs here; the mutable borrow prevents subsequent moves, borrows, or modification of `x` until the borrow ends </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7 swap_from(&amp;mut x, &amp;x); </span></span><br><span class="hljs-comment"><span class="hljs-comment"> ^ </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7:26: 7:26 note: previous borrow ends here </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7 swap_from(&amp;mut x, &amp;x); </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  ,             " </span></span><code><span class="hljs-comment"><span class="hljs-comment">&amp;mut</span></span></code><span class="hljs-comment"><span class="hljs-comment"> "  " </span></span><code><span class="hljs-comment"><span class="hljs-comment">&amp;</span></span></code><span class="hljs-comment"><span class="hljs-comment"> " ,   ,          ,   </span></span><code><span class="hljs-comment"><span class="hljs-comment">&amp;mut</span></span></code><span class="hljs-comment"><span class="hljs-comment"> .            .  ,    ,      C99  </span></span><code><span class="hljs-comment"><span class="hljs-comment">restrict</span></span></code><span class="hljs-comment"><span class="hljs-comment">  (Rust  LLVM    ),    . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">   </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="cpp"><span class="hljs-comment"><span class="hljs-comment">#include &lt;vector&gt; int main() { std::vector&lt;int&gt; v; v.push_back(1); v.push_back(2); for(std::vector&lt;int&gt;::const_iterator it=v.begin(); it!=v.end(); ++it) { if (*it &lt; 5) v.push_back(5-*it); } }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">    ,    : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> Segmentation fault (core dumped) </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">    Rust: </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="rust"><span class="hljs-comment"><span class="hljs-comment">fn main() { let mut v: Vec&lt;int&gt; = Vec::new(); v.push(1); v.push(2); for x in v.iter() { if *x &lt; 5 { v.push(5-*x); } } }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">      ,  ,        : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7:13: 7:14 error: cannot borrow `v` as mutable because it is also borrowed as immutable </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7 v.push(5-*x); </span></span><br><span class="hljs-comment"><span class="hljs-comment"> ^ </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:5:14: 5:15 note: previous borrow of `v` occurs here; the immutable borrow prevents subsequent moves or mutable borrows of `v` until the borrow ends </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:5 for x in v.iter() { </span></span><br><span class="hljs-comment"><span class="hljs-comment"> ^ </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:10:2: 10:2 note: previous borrow ends here </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:5 for x in v.iter() { </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:6 if *x &lt; 5 { </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7 v.push(5-*x); </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:8 } </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:9 } </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:10 } </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  Switch </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="cpp"><span class="hljs-comment"><span class="hljs-comment">#include &lt;stdio.h&gt; enum {RED, BLUE, GRAY, UNKNOWN} color = GRAY; int main() { int x; switch(color) { case GRAY: x=1; case RED: case BLUE: x=2; } printf("%d", x); }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">   "2".  Rust          .  ,       ,    </span></span><code><span class="hljs-comment"><span class="hljs-comment">break</span></span></code><span class="hljs-comment"><span class="hljs-comment"> .    Rust   : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="rust"><span class="hljs-comment"><span class="hljs-comment">enum Color {RED, BLUE, GRAY, UNKNOWN} fn main() { let color = GRAY; let x = match color { GRAY =&gt; 1, RED | BLUE =&gt; 2, _ =&gt; 3, }; println!("{}", x); }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">     </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="cpp"><span class="hljs-comment"><span class="hljs-comment">int main() { int pixels = 1; for (int j=0; j&lt;5; j++); pixels++; }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  Rust          . , ,     . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="cpp"><span class="hljs-comment"><span class="hljs-comment">#include &lt;stdio.h&gt; #include &lt;pthread.h&gt; #include &lt;unistd.h&gt; class Resource { int *value; public: Resource(): value(NULL) {} ~Resource() {delete value;} int *acquire() { if (!value) { value = new int(0); } return value; } }; void* function(void *param) { int *value = ((Resource*)param)-&gt;acquire(); printf("resource: %p\n", (void*)value); return value; } int main() { Resource res; for (int i=0; i&lt;5; ++i) { pthread_t pt; pthread_create(&amp;pt, NULL, function, &amp;res); } //sleep(10); printf("done\n"); }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">     : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> done </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7f229c0008c0 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7f22840008c0 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7f228c0008c0 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7f22940008c0 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7f227c0008c0 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">     ,        .      Rust: </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="rust"><span class="hljs-comment"><span class="hljs-comment">struct Resource { value: Option&lt;int&gt;, } impl Resource { pub fn new() -&gt; Resource { Resource{ value: None } } pub fn acquire&lt;'a&gt;(&amp;'a mut self) -&gt; &amp;'a int { if self.value.is_none() { self.value = Some(1); } self.value.get_ref() } } fn main() { let mut res = Resource::new(); for _ in range(0,5) { spawn(proc() { let ptr = res.acquire(); println!("resource {}", ptr) }) } }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  ,            . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:20:23: 20:26 error: cannot borrow immutable captured outer variable in a proc `res` as mutable </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:20 let ptr = res.acquire(); </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">      ,   : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="rust"><span class="hljs-comment"><span class="hljs-comment">extern crate sync; use sync::{Arc, RWLock}; struct Resource { value: Option&lt;Box&lt;int&gt;&gt;, } impl Resource { pub fn new() -&gt; Resource { Resource{ value: None } } pub fn acquire(&amp;mut self) -&gt; *int { if self.value.is_none() { self.value = Some(box 1) } &amp;**self.value.get_ref() as *int } } fn main() { let arc_res = Arc::new(RWLock::new(Resource::new())); for _ in range(0,5) { let child_res = arc_res.clone(); spawn(proc() { let ptr = child_res.write().acquire(); println!("resource: {}", ptr) }) } }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">     </span></span><code><span class="hljs-comment"><span class="hljs-comment">Arc</span></span></code><span class="hljs-comment"><span class="hljs-comment"> ( </span></span><i><span class="hljs-comment"><span class="hljs-comment">Atomically Reference Counted</span></span></i><span class="hljs-comment"><span class="hljs-comment"> -        )  </span></span><code><span class="hljs-comment"><span class="hljs-comment">RWLock</span></span></code><span class="hljs-comment"><span class="hljs-comment"> (   ).   : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7ff4b0010378 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7ff4b0010378 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7ff4b0010378 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7ff4b0010378 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7ff4b0010378 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  ,   ++    .    . Rust        ,    .  ,   ,   .           ,       ( </span></span><a href="http://superwebdeveloper.com/2009/11/25/the-incredible-rate-of-diminishing-returns-of-fixing-software-bugs/"><span class="hljs-comment"><span class="hljs-comment">  </span></span></a><span class="hljs-comment"><span class="hljs-comment"> ). </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">     </span></span><br><span class="hljs-comment"><span class="hljs-comment"> Rust        ,     </span></span><code><span class="hljs-comment"><span class="hljs-comment">unsafe{}</span></span></code><span class="hljs-comment"><span class="hljs-comment"> .   ,     " </span></span><i><span class="hljs-comment"><span class="hljs-comment"> !  ,  .</span></span></i><span class="hljs-comment"><span class="hljs-comment"> ".  ,  ""  (    ,    )    .    ,           ( )  . , ,        </span></span><code><span class="hljs-comment"><span class="hljs-comment">Cell</span></span></code><span class="hljs-comment"><span class="hljs-comment">  </span></span><code><span class="hljs-comment"><span class="hljs-comment">Mutex</span></span></code><span class="hljs-comment"><span class="hljs-comment"> .             ,       (   </span></span><a href="http://en.wikipedia.org/wiki/Test-driven_development"><span class="hljs-comment"><span class="hljs-comment">TDD</span></span></a><span class="hljs-comment"><span class="hljs-comment"> !). </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="https://air.mozilla.org/guaranteeing-memory-safety-in-rust/"><span class="hljs-comment"><span class="hljs-comment">Guaranteeing Memory Safety in Rust (by Niko Matsakis)</span></span></a><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="http://www.techtalkshub.com/rust-safe-systems-programming-fun-fp/"><span class="hljs-comment"><span class="hljs-comment">Rust: Safe Systems Programming with the Fun of FP (by Felix Klock II)</span></span></a><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Keynote"><span class="hljs-comment"><span class="hljs-comment">Lang-NEXT: What ‚Äì if anything ‚Äì have we learned from C++? (by Bjarne Stroustrup)</span></span></a><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Panel-Systems-Programming-Languages-in-2014-and-Beyond"><span class="hljs-comment"><span class="hljs-comment">Lang-NEXT Panel: Systems Programming in 2014 and Beyond</span></span></a></code></code> </pre> <code><code><code><code class="cpp">Box)     ,       (     ).        (std::rc::Rc)    (std::gc::Gc),      (   ). <br> <br></code>      <br>  ++: <br> #include &lt;stdio.h&gt; int *bar(int *p) { return p; } int* foo(int n) { return bar(&amp;n); } int main() { int *p1 = foo(1); int *p2 = foo(2); printf("%d, %d\n", *p1, *p2); }</code> <br>  : <br> 2, 2 <br> <br>  Rust: <br> <code class="rust">fn bar&lt;'a&gt;(p: &amp;'a int) -&gt; &amp;'a int { return p; } fn foo(n: int) -&gt; &amp;int { bar(&amp;n) } fn main() { let p1 = foo(1); let p2 = foo(2); println!("{}, {}", *p1, *p2); }</code> <br>  : <br> demo:5:10: 5:11 error: `n` does not live long enough <br> demo:5 bar(&amp;n) <br> ^ <br> demo:4:24: 6:2 note: reference must be valid for the anonymous lifetime #1 defined on the block at 4:23... <br> demo:4 fn foo(n: int) -&gt; &amp;int { <br> demo:5 bar(&amp;n) <br> demo:6 } <br> demo:4:24: 6:2 note: ...but borrowed value is only valid for the block at 4:23 <br> demo:4 fn foo(n: int) -&gt; &amp;int { <br> demo:5 bar(&amp;n) <br> demo:6 } <br> <br>   <br> <code class="cpp">#include &lt;stdio.h&gt; int minval(int *A, int n) { int currmin; for (int i=0; i&lt;n; i++) if (A[i] &lt; currmin) currmin = A[i]; return currmin; } int main() { int A[] = {1,2,3}; int min = minval(A,3); printf("%d\n", min); }</code> <br>   0  ,     , ,  .       Rust ( - ): <br> <code class="rust">fn minval(A: &amp;[int]) -&gt; int { let mut currmin; for a in A.iter() { if *a &lt; currmin { currmin = *a; } } currmin } fn main() { let A = [1i,2i,3i]; let min = minval(A.as_slice()); println!("{}", min); }</code> <br>  , : use of possibly uninitialized variable: `currmin` <br>   ( )      : <br> <code class="rust">fn minval(A: &amp;[int]) -&gt; int { A.iter().fold(A[0], |u,&amp;a| { if a&lt;u {a} else {u} }) }</code> <br> <br>    <br> <code class="cpp">struct A{ int *x; A(int v): x(new int(v)) {} ~A() {delete x;} }; int main() { A a(1), b=a; }</code> <br> ,    : <br> *** glibc detected *** demo: double free or corruption (fasttop): 0x0000000000601010 *** <br> <br>     Rust: <br> <code class="rust">struct A{ x: Box&lt;int&gt; } impl A { pub fn new(v: int) -&gt; A { A{ x: box v } } } impl Drop for A { fn drop(&amp;mut self) {} // ,     ++ } fn main() { let a = A::new(1); let _b = a; }</code> <br>     .   ,     <code>trait Copy</code> . <br> Rust       .    <code>Eq</code>  <code>Clone</code> ?    <code>deriving</code>   : <br> <code class="rust">#[deriving(Clone, Eq, Hash, PartialEq, PartialOrd, Ord, Show)] struct A{ x: Box&lt;int&gt; }</code> <br> <br>    <br> <code class="cpp">#include &lt;stdio.h&gt; struct X { int a, b; }; void swap_from(X&amp; x, const X&amp; y) { xa = yb; xb = ya; } int main() { X x = {1,2}; swap_from(x,x); printf("%d,%d\n", xa, xb); }</code> <br>  : <br> 2,2 <br>    ,    cc      .   ,   ,  99  <a href="http://en.wikipedia.org/wiki/Restrict">restrict</a> ,            :        . <br> <br>       Rust: <br> <code class="rust">struct X { pub a: int, pub b: int } fn swap_from(x: &amp;mut X, y: &amp;X) { xa = yb; xb = ya; } fn main() { let mut x = X{a:1, b:2}; swap_from(&amp;mut x, &amp;x); }</code> <br>    : <br> demo:7:24: 7:25 error: cannot borrow `x` as immutable because it is also borrowed as mutable <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> ^ <br> demo:7:20: 7:21 note: previous borrow of `x` occurs here; the mutable borrow prevents subsequent moves, borrows, or modification of `x` until the borrow ends <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> ^ <br> demo:7:26: 7:26 note: previous borrow ends here <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> <br>  ,             " <code>&amp;mut</code> "  " <code>&amp;</code> " ,   ,          ,   <code>&amp;mut</code> .            .  ,    ,      C99  <code>restrict</code>  (Rust  LLVM    ),    . <br> <br>   <br> <code class="cpp">#include &lt;vector&gt; int main() { std::vector&lt;int&gt; v; v.push_back(1); v.push_back(2); for(std::vector&lt;int&gt;::const_iterator it=v.begin(); it!=v.end(); ++it) { if (*it &lt; 5) v.push_back(5-*it); } }</code> <br>    ,    : <br> Segmentation fault (core dumped) <br> <br>    Rust: <br> <code class="rust">fn main() { let mut v: Vec&lt;int&gt; = Vec::new(); v.push(1); v.push(2); for x in v.iter() { if *x &lt; 5 { v.push(5-*x); } } }</code> <br>      ,  ,        : <br> demo:7:13: 7:14 error: cannot borrow `v` as mutable because it is also borrowed as immutable <br> demo:7 v.push(5-*x); <br> ^ <br> demo:5:14: 5:15 note: previous borrow of `v` occurs here; the immutable borrow prevents subsequent moves or mutable borrows of `v` until the borrow ends <br> demo:5 for x in v.iter() { <br> ^ <br> demo:10:2: 10:2 note: previous borrow ends here <br> demo:5 for x in v.iter() { <br> demo:6 if *x &lt; 5 { <br> demo:7 v.push(5-*x); <br> demo:8 } <br> demo:9 } <br> demo:10 } <br> <br> <br>  Switch <br> <code class="cpp">#include &lt;stdio.h&gt; enum {RED, BLUE, GRAY, UNKNOWN} color = GRAY; int main() { int x; switch(color) { case GRAY: x=1; case RED: case BLUE: x=2; } printf("%d", x); }</code> <br>   "2".  Rust          .  ,       ,    <code>break</code> .    Rust   : <br> <code class="rust">enum Color {RED, BLUE, GRAY, UNKNOWN} fn main() { let color = GRAY; let x = match color { GRAY =&gt; 1, RED | BLUE =&gt; 2, _ =&gt; 3, }; println!("{}", x); }</code> <br> <br>     <br> <code class="cpp">int main() { int pixels = 1; for (int j=0; j&lt;5; j++); pixels++; }</code> <br>  Rust          . , ,     . <br> <br>  <br> <code class="cpp">#include &lt;stdio.h&gt; #include &lt;pthread.h&gt; #include &lt;unistd.h&gt; class Resource { int *value; public: Resource(): value(NULL) {} ~Resource() {delete value;} int *acquire() { if (!value) { value = new int(0); } return value; } }; void* function(void *param) { int *value = ((Resource*)param)-&gt;acquire(); printf("resource: %p\n", (void*)value); return value; } int main() { Resource res; for (int i=0; i&lt;5; ++i) { pthread_t pt; pthread_create(&amp;pt, NULL, function, &amp;res); } //sleep(10); printf("done\n"); }</code> <br>     : <br> done <br> resource: 0x7f229c0008c0 <br> resource: 0x7f22840008c0 <br> resource: 0x7f228c0008c0 <br> resource: 0x7f22940008c0 <br> resource: 0x7f227c0008c0 <br> <br>     ,        .      Rust: <br> <code class="rust">struct Resource { value: Option&lt;int&gt;, } impl Resource { pub fn new() -&gt; Resource { Resource{ value: None } } pub fn acquire&lt;'a&gt;(&amp;'a mut self) -&gt; &amp;'a int { if self.value.is_none() { self.value = Some(1); } self.value.get_ref() } } fn main() { let mut res = Resource::new(); for _ in range(0,5) { spawn(proc() { let ptr = res.acquire(); println!("resource {}", ptr) }) } }</code> <br>  ,            . <br> demo:20:23: 20:26 error: cannot borrow immutable captured outer variable in a proc `res` as mutable <br> demo:20 let ptr = res.acquire(); <br> <br>      ,   : <br> <code class="rust">extern crate sync; use sync::{Arc, RWLock}; struct Resource { value: Option&lt;Box&lt;int&gt;&gt;, } impl Resource { pub fn new() -&gt; Resource { Resource{ value: None } } pub fn acquire(&amp;mut self) -&gt; *int { if self.value.is_none() { self.value = Some(box 1) } &amp;**self.value.get_ref() as *int } } fn main() { let arc_res = Arc::new(RWLock::new(Resource::new())); for _ in range(0,5) { let child_res = arc_res.clone(); spawn(proc() { let ptr = child_res.write().acquire(); println!("resource: {}", ptr) }) } }</code> <br>     <code>Arc</code> ( <i>Atomically Reference Counted</i> -        )  <code>RWLock</code> (   ).   : <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> <br>  ,   ++    .    . Rust        ,    .  ,   ,   .           ,       ( <a href="http://superwebdeveloper.com/2009/11/25/the-incredible-rate-of-diminishing-returns-of-fixing-software-bugs/">  </a> ). <br> <br>     <br> Rust        ,     <code>unsafe{}</code> .   ,     " <i> !  ,  .</i> ".  ,  ""  (    ,    )    .    ,           ( )  . , ,        <code>Cell</code>  <code>Mutex</code> .             ,       (   <a href="http://en.wikipedia.org/wiki/Test-driven_development">TDD</a> !). <br> <br>  <br> <a href="https://air.mozilla.org/guaranteeing-memory-safety-in-rust/">Guaranteeing Memory Safety in Rust (by Niko Matsakis)</a> <br> <a href="http://www.techtalkshub.com/rust-safe-systems-programming-fun-fp/">Rust: Safe Systems Programming with the Fun of FP (by Felix Klock II)</a> <br> <a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Keynote">Lang-NEXT: What ‚Äì if anything ‚Äì have we learned from C++? (by Bjarne Stroustrup)</a> <br> <a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Panel-Systems-Programming-Languages-in-2014-and-Beyond">Lang-NEXT Panel: Systems Programming in 2014 and Beyond</a></code></code> <blockquote> <code><code><code><code class="cpp">Box)     ,       (     ).        (std::rc::Rc)    (std::gc::Gc),      (   ). <br> <br></code>      <br>  ++: <br> #include &lt;stdio.h&gt; int *bar(int *p) { return p; } int* foo(int n) { return bar(&amp;n); } int main() { int *p1 = foo(1); int *p2 = foo(2); printf("%d, %d\n", *p1, *p2); }</code> <br>  : <br> 2, 2 <br> <br>  Rust: <br> <code class="rust">fn bar&lt;'a&gt;(p: &amp;'a int) -&gt; &amp;'a int { return p; } fn foo(n: int) -&gt; &amp;int { bar(&amp;n) } fn main() { let p1 = foo(1); let p2 = foo(2); println!("{}, {}", *p1, *p2); }</code> <br>  : <br> demo:5:10: 5:11 error: `n` does not live long enough <br> demo:5 bar(&amp;n) <br> ^ <br> demo:4:24: 6:2 note: reference must be valid for the anonymous lifetime #1 defined on the block at 4:23... <br> demo:4 fn foo(n: int) -&gt; &amp;int { <br> demo:5 bar(&amp;n) <br> demo:6 } <br> demo:4:24: 6:2 note: ...but borrowed value is only valid for the block at 4:23 <br> demo:4 fn foo(n: int) -&gt; &amp;int { <br> demo:5 bar(&amp;n) <br> demo:6 } <br> <br>   <br> <code class="cpp">#include &lt;stdio.h&gt; int minval(int *A, int n) { int currmin; for (int i=0; i&lt;n; i++) if (A[i] &lt; currmin) currmin = A[i]; return currmin; } int main() { int A[] = {1,2,3}; int min = minval(A,3); printf("%d\n", min); }</code> <br>   0  ,     , ,  .       Rust ( - ): <br> <code class="rust">fn minval(A: &amp;[int]) -&gt; int { let mut currmin; for a in A.iter() { if *a &lt; currmin { currmin = *a; } } currmin } fn main() { let A = [1i,2i,3i]; let min = minval(A.as_slice()); println!("{}", min); }</code> <br>  , : use of possibly uninitialized variable: `currmin` <br>   ( )      : <br> <code class="rust">fn minval(A: &amp;[int]) -&gt; int { A.iter().fold(A[0], |u,&amp;a| { if a&lt;u {a} else {u} }) }</code> <br> <br>    <br> <code class="cpp">struct A{ int *x; A(int v): x(new int(v)) {} ~A() {delete x;} }; int main() { A a(1), b=a; }</code> <br> ,    : <br> *** glibc detected *** demo: double free or corruption (fasttop): 0x0000000000601010 *** <br> <br>     Rust: <br> <code class="rust">struct A{ x: Box&lt;int&gt; } impl A { pub fn new(v: int) -&gt; A { A{ x: box v } } } impl Drop for A { fn drop(&amp;mut self) {} // ,     ++ } fn main() { let a = A::new(1); let _b = a; }</code> <br>     .   ,     <code>trait Copy</code> . <br> Rust       .    <code>Eq</code>  <code>Clone</code> ?    <code>deriving</code>   : <br> <code class="rust">#[deriving(Clone, Eq, Hash, PartialEq, PartialOrd, Ord, Show)] struct A{ x: Box&lt;int&gt; }</code> <br> <br>    <br> <code class="cpp">#include &lt;stdio.h&gt; struct X { int a, b; }; void swap_from(X&amp; x, const X&amp; y) { xa = yb; xb = ya; } int main() { X x = {1,2}; swap_from(x,x); printf("%d,%d\n", xa, xb); }</code> <br>  : <br> 2,2 <br>    ,    cc      .   ,   ,  99  <a href="http://en.wikipedia.org/wiki/Restrict">restrict</a> ,            :        . <br> <br>       Rust: <br> <code class="rust">struct X { pub a: int, pub b: int } fn swap_from(x: &amp;mut X, y: &amp;X) { xa = yb; xb = ya; } fn main() { let mut x = X{a:1, b:2}; swap_from(&amp;mut x, &amp;x); }</code> <br>    : <br> demo:7:24: 7:25 error: cannot borrow `x` as immutable because it is also borrowed as mutable <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> ^ <br> demo:7:20: 7:21 note: previous borrow of `x` occurs here; the mutable borrow prevents subsequent moves, borrows, or modification of `x` until the borrow ends <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> ^ <br> demo:7:26: 7:26 note: previous borrow ends here <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> <br>  ,             " <code>&amp;mut</code> "  " <code>&amp;</code> " ,   ,          ,   <code>&amp;mut</code> .            .  ,    ,      C99  <code>restrict</code>  (Rust  LLVM    ),    . <br> <br>   <br> <code class="cpp">#include &lt;vector&gt; int main() { std::vector&lt;int&gt; v; v.push_back(1); v.push_back(2); for(std::vector&lt;int&gt;::const_iterator it=v.begin(); it!=v.end(); ++it) { if (*it &lt; 5) v.push_back(5-*it); } }</code> <br>    ,    : <br> Segmentation fault (core dumped) <br> <br>    Rust: <br> <code class="rust">fn main() { let mut v: Vec&lt;int&gt; = Vec::new(); v.push(1); v.push(2); for x in v.iter() { if *x &lt; 5 { v.push(5-*x); } } }</code> <br>      ,  ,        : <br> demo:7:13: 7:14 error: cannot borrow `v` as mutable because it is also borrowed as immutable <br> demo:7 v.push(5-*x); <br> ^ <br> demo:5:14: 5:15 note: previous borrow of `v` occurs here; the immutable borrow prevents subsequent moves or mutable borrows of `v` until the borrow ends <br> demo:5 for x in v.iter() { <br> ^ <br> demo:10:2: 10:2 note: previous borrow ends here <br> demo:5 for x in v.iter() { <br> demo:6 if *x &lt; 5 { <br> demo:7 v.push(5-*x); <br> demo:8 } <br> demo:9 } <br> demo:10 } <br> <br> <br>  Switch <br> <code class="cpp">#include &lt;stdio.h&gt; enum {RED, BLUE, GRAY, UNKNOWN} color = GRAY; int main() { int x; switch(color) { case GRAY: x=1; case RED: case BLUE: x=2; } printf("%d", x); }</code> <br>   "2".  Rust          .  ,       ,    <code>break</code> .    Rust   : <br> <code class="rust">enum Color {RED, BLUE, GRAY, UNKNOWN} fn main() { let color = GRAY; let x = match color { GRAY =&gt; 1, RED | BLUE =&gt; 2, _ =&gt; 3, }; println!("{}", x); }</code> <br> <br>     <br> <code class="cpp">int main() { int pixels = 1; for (int j=0; j&lt;5; j++); pixels++; }</code> <br>  Rust          . , ,     . <br> <br>  <br> <code class="cpp">#include &lt;stdio.h&gt; #include &lt;pthread.h&gt; #include &lt;unistd.h&gt; class Resource { int *value; public: Resource(): value(NULL) {} ~Resource() {delete value;} int *acquire() { if (!value) { value = new int(0); } return value; } }; void* function(void *param) { int *value = ((Resource*)param)-&gt;acquire(); printf("resource: %p\n", (void*)value); return value; } int main() { Resource res; for (int i=0; i&lt;5; ++i) { pthread_t pt; pthread_create(&amp;pt, NULL, function, &amp;res); } //sleep(10); printf("done\n"); }</code> <br>     : <br> done <br> resource: 0x7f229c0008c0 <br> resource: 0x7f22840008c0 <br> resource: 0x7f228c0008c0 <br> resource: 0x7f22940008c0 <br> resource: 0x7f227c0008c0 <br> <br>     ,        .      Rust: <br> <code class="rust">struct Resource { value: Option&lt;int&gt;, } impl Resource { pub fn new() -&gt; Resource { Resource{ value: None } } pub fn acquire&lt;'a&gt;(&amp;'a mut self) -&gt; &amp;'a int { if self.value.is_none() { self.value = Some(1); } self.value.get_ref() } } fn main() { let mut res = Resource::new(); for _ in range(0,5) { spawn(proc() { let ptr = res.acquire(); println!("resource {}", ptr) }) } }</code> <br>  ,            . <br> demo:20:23: 20:26 error: cannot borrow immutable captured outer variable in a proc `res` as mutable <br> demo:20 let ptr = res.acquire(); <br> <br>      ,   : <br> <code class="rust">extern crate sync; use sync::{Arc, RWLock}; struct Resource { value: Option&lt;Box&lt;int&gt;&gt;, } impl Resource { pub fn new() -&gt; Resource { Resource{ value: None } } pub fn acquire(&amp;mut self) -&gt; *int { if self.value.is_none() { self.value = Some(box 1) } &amp;**self.value.get_ref() as *int } } fn main() { let arc_res = Arc::new(RWLock::new(Resource::new())); for _ in range(0,5) { let child_res = arc_res.clone(); spawn(proc() { let ptr = child_res.write().acquire(); println!("resource: {}", ptr) }) } }</code> <br>     <code>Arc</code> ( <i>Atomically Reference Counted</i> -        )  <code>RWLock</code> (   ).   : <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> <br>  ,   ++    .    . Rust        ,    .  ,   ,   .           ,       ( <a href="http://superwebdeveloper.com/2009/11/25/the-incredible-rate-of-diminishing-returns-of-fixing-software-bugs/">  </a> ). <br> <br>     <br> Rust        ,     <code>unsafe{}</code> .   ,     " <i> !  ,  .</i> ".  ,  ""  (    ,    )    .    ,           ( )  . , ,        <code>Cell</code>  <code>Mutex</code> .             ,       (   <a href="http://en.wikipedia.org/wiki/Test-driven_development">TDD</a> !). <br> <br>  <br> <a href="https://air.mozilla.org/guaranteeing-memory-safety-in-rust/">Guaranteeing Memory Safety in Rust (by Niko Matsakis)</a> <br> <a href="http://www.techtalkshub.com/rust-safe-systems-programming-fun-fp/">Rust: Safe Systems Programming with the Fun of FP (by Felix Klock II)</a> <br> <a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Keynote">Lang-NEXT: What ‚Äì if anything ‚Äì have we learned from C++? (by Bjarne Stroustrup)</a> <br> <a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Panel-Systems-Programming-Languages-in-2014-and-Beyond">Lang-NEXT Panel: Systems Programming in 2014 and Beyond</a></code></code> </blockquote> <code><code><code><code class="cpp">Box)     ,       (     ).        (std::rc::Rc)    (std::gc::Gc),      (   ). <br> <br></code>      <br>  ++: <br> #include &lt;stdio.h&gt; int *bar(int *p) { return p; } int* foo(int n) { return bar(&amp;n); } int main() { int *p1 = foo(1); int *p2 = foo(2); printf("%d, %d\n", *p1, *p2); }</code> <br>  : <br> 2, 2 <br> <br>  Rust: <br> <code class="rust">fn bar&lt;'a&gt;(p: &amp;'a int) -&gt; &amp;'a int { return p; } fn foo(n: int) -&gt; &amp;int { bar(&amp;n) } fn main() { let p1 = foo(1); let p2 = foo(2); println!("{}, {}", *p1, *p2); }</code> <br>  : <br> demo:5:10: 5:11 error: `n` does not live long enough <br> demo:5 bar(&amp;n) <br> ^ <br> demo:4:24: 6:2 note: reference must be valid for the anonymous lifetime #1 defined on the block at 4:23... <br> demo:4 fn foo(n: int) -&gt; &amp;int { <br> demo:5 bar(&amp;n) <br> demo:6 } <br> demo:4:24: 6:2 note: ...but borrowed value is only valid for the block at 4:23 <br> demo:4 fn foo(n: int) -&gt; &amp;int { <br> demo:5 bar(&amp;n) <br> demo:6 } <br> <br>   <br> <code class="cpp">#include &lt;stdio.h&gt; int minval(int *A, int n) { int currmin; for (int i=0; i&lt;n; i++) if (A[i] &lt; currmin) currmin = A[i]; return currmin; } int main() { int A[] = {1,2,3}; int min = minval(A,3); printf("%d\n", min); }</code> <br>   0  ,     , ,  .       Rust ( - ): <br> <code class="rust">fn minval(A: &amp;[int]) -&gt; int { let mut currmin; for a in A.iter() { if *a &lt; currmin { currmin = *a; } } currmin } fn main() { let A = [1i,2i,3i]; let min = minval(A.as_slice()); println!("{}", min); }</code> <br>  , : use of possibly uninitialized variable: `currmin` <br>   ( )      : <br> <code class="rust">fn minval(A: &amp;[int]) -&gt; int { A.iter().fold(A[0], |u,&amp;a| { if a&lt;u {a} else {u} }) }</code> <br> <br>    <br> <code class="cpp">struct A{ int *x; A(int v): x(new int(v)) {} ~A() {delete x;} }; int main() { A a(1), b=a; }</code> <br> ,    : <br> *** glibc detected *** demo: double free or corruption (fasttop): 0x0000000000601010 *** <br> <br>     Rust: <br> <code class="rust">struct A{ x: Box&lt;int&gt; } impl A { pub fn new(v: int) -&gt; A { A{ x: box v } } } impl Drop for A { fn drop(&amp;mut self) {} // ,     ++ } fn main() { let a = A::new(1); let _b = a; }</code> <br>     .   ,     <code>trait Copy</code> . <br> Rust       .    <code>Eq</code>  <code>Clone</code> ?    <code>deriving</code>   : <br> <code class="rust">#[deriving(Clone, Eq, Hash, PartialEq, PartialOrd, Ord, Show)] struct A{ x: Box&lt;int&gt; }</code> <br> <br>    <br> <code class="cpp">#include &lt;stdio.h&gt; struct X { int a, b; }; void swap_from(X&amp; x, const X&amp; y) { xa = yb; xb = ya; } int main() { X x = {1,2}; swap_from(x,x); printf("%d,%d\n", xa, xb); }</code> <br>  : <br> 2,2 <br>    ,    cc      .   ,   ,  99  <a href="http://en.wikipedia.org/wiki/Restrict">restrict</a> ,            :        . <br> <br>       Rust: <br> <code class="rust">struct X { pub a: int, pub b: int } fn swap_from(x: &amp;mut X, y: &amp;X) { xa = yb; xb = ya; } fn main() { let mut x = X{a:1, b:2}; swap_from(&amp;mut x, &amp;x); }</code> <br>    : <br> demo:7:24: 7:25 error: cannot borrow `x` as immutable because it is also borrowed as mutable <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> ^ <br> demo:7:20: 7:21 note: previous borrow of `x` occurs here; the mutable borrow prevents subsequent moves, borrows, or modification of `x` until the borrow ends <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> ^ <br> demo:7:26: 7:26 note: previous borrow ends here <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> <br>  ,             " <code>&amp;mut</code> "  " <code>&amp;</code> " ,   ,          ,   <code>&amp;mut</code> .            .  ,    ,      C99  <code>restrict</code>  (Rust  LLVM    ),    . <br> <br>   <br> <code class="cpp">#include &lt;vector&gt; int main() { std::vector&lt;int&gt; v; v.push_back(1); v.push_back(2); for(std::vector&lt;int&gt;::const_iterator it=v.begin(); it!=v.end(); ++it) { if (*it &lt; 5) v.push_back(5-*it); } }</code> <br>    ,    : <br> Segmentation fault (core dumped) <br> <br>    Rust: <br> <code class="rust">fn main() { let mut v: Vec&lt;int&gt; = Vec::new(); v.push(1); v.push(2); for x in v.iter() { if *x &lt; 5 { v.push(5-*x); } } }</code> <br>      ,  ,        : <br> demo:7:13: 7:14 error: cannot borrow `v` as mutable because it is also borrowed as immutable <br> demo:7 v.push(5-*x); <br> ^ <br> demo:5:14: 5:15 note: previous borrow of `v` occurs here; the immutable borrow prevents subsequent moves or mutable borrows of `v` until the borrow ends <br> demo:5 for x in v.iter() { <br> ^ <br> demo:10:2: 10:2 note: previous borrow ends here <br> demo:5 for x in v.iter() { <br> demo:6 if *x &lt; 5 { <br> demo:7 v.push(5-*x); <br> demo:8 } <br> demo:9 } <br> demo:10 } <br> <br> <br>  Switch <br> <code class="cpp">#include &lt;stdio.h&gt; enum {RED, BLUE, GRAY, UNKNOWN} color = GRAY; int main() { int x; switch(color) { case GRAY: x=1; case RED: case BLUE: x=2; } printf("%d", x); }</code> <br>   "2".  Rust          .  ,       ,    <code>break</code> .    Rust   : <br> <code class="rust">enum Color {RED, BLUE, GRAY, UNKNOWN} fn main() { let color = GRAY; let x = match color { GRAY =&gt; 1, RED | BLUE =&gt; 2, _ =&gt; 3, }; println!("{}", x); }</code> <br> <br>     <br> <code class="cpp">int main() { int pixels = 1; for (int j=0; j&lt;5; j++); pixels++; }</code> <br>  Rust          . , ,     . <br> <br>  <br> <code class="cpp">#include &lt;stdio.h&gt; #include &lt;pthread.h&gt; #include &lt;unistd.h&gt; class Resource { int *value; public: Resource(): value(NULL) {} ~Resource() {delete value;} int *acquire() { if (!value) { value = new int(0); } return value; } }; void* function(void *param) { int *value = ((Resource*)param)-&gt;acquire(); printf("resource: %p\n", (void*)value); return value; } int main() { Resource res; for (int i=0; i&lt;5; ++i) { pthread_t pt; pthread_create(&amp;pt, NULL, function, &amp;res); } //sleep(10); printf("done\n"); }</code> <br>     : <br> done <br> resource: 0x7f229c0008c0 <br> resource: 0x7f22840008c0 <br> resource: 0x7f228c0008c0 <br> resource: 0x7f22940008c0 <br> resource: 0x7f227c0008c0 <br> <br>     ,        .      Rust: <br> <code class="rust">struct Resource { value: Option&lt;int&gt;, } impl Resource { pub fn new() -&gt; Resource { Resource{ value: None } } pub fn acquire&lt;'a&gt;(&amp;'a mut self) -&gt; &amp;'a int { if self.value.is_none() { self.value = Some(1); } self.value.get_ref() } } fn main() { let mut res = Resource::new(); for _ in range(0,5) { spawn(proc() { let ptr = res.acquire(); println!("resource {}", ptr) }) } }</code> <br>  ,            . <br> demo:20:23: 20:26 error: cannot borrow immutable captured outer variable in a proc `res` as mutable <br> demo:20 let ptr = res.acquire(); <br> <br>      ,   : <br> <code class="rust">extern crate sync; use sync::{Arc, RWLock}; struct Resource { value: Option&lt;Box&lt;int&gt;&gt;, } impl Resource { pub fn new() -&gt; Resource { Resource{ value: None } } pub fn acquire(&amp;mut self) -&gt; *int { if self.value.is_none() { self.value = Some(box 1) } &amp;**self.value.get_ref() as *int } } fn main() { let arc_res = Arc::new(RWLock::new(Resource::new())); for _ in range(0,5) { let child_res = arc_res.clone(); spawn(proc() { let ptr = child_res.write().acquire(); println!("resource: {}", ptr) }) } }</code> <br>     <code>Arc</code> ( <i>Atomically Reference Counted</i> -        )  <code>RWLock</code> (   ).   : <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> <br>  ,   ++    .    . Rust        ,    .  ,   ,   .           ,       ( <a href="http://superwebdeveloper.com/2009/11/25/the-incredible-rate-of-diminishing-returns-of-fixing-software-bugs/">  </a> ). <br> <br>     <br> Rust        ,     <code>unsafe{}</code> .   ,     " <i> !  ,  .</i> ".  ,  ""  (    ,    )    .    ,           ( )  . , ,        <code>Cell</code>  <code>Mutex</code> .             ,       (   <a href="http://en.wikipedia.org/wiki/Test-driven_development">TDD</a> !). <br> <br>  <br> <a href="https://air.mozilla.org/guaranteeing-memory-safety-in-rust/">Guaranteeing Memory Safety in Rust (by Niko Matsakis)</a> <br> <a href="http://www.techtalkshub.com/rust-safe-systems-programming-fun-fp/">Rust: Safe Systems Programming with the Fun of FP (by Felix Klock II)</a> <br> <a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Keynote">Lang-NEXT: What ‚Äì if anything ‚Äì have we learned from C++? (by Bjarne Stroustrup)</a> <br> <a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Panel-Systems-Programming-Languages-in-2014-and-Beyond">Lang-NEXT Panel: Systems Programming in 2014 and Beyond</a></code></code> <h4> <code><code><code><code class="cpp">Box)     ,       (     ).        (std::rc::Rc)    (std::gc::Gc),      (   ). <br> <br></code>      <br>  ++: <br> #include &lt;stdio.h&gt; int *bar(int *p) { return p; } int* foo(int n) { return bar(&amp;n); } int main() { int *p1 = foo(1); int *p2 = foo(2); printf("%d, %d\n", *p1, *p2); }</code> <br>  : <br> 2, 2 <br> <br>  Rust: <br> <code class="rust">fn bar&lt;'a&gt;(p: &amp;'a int) -&gt; &amp;'a int { return p; } fn foo(n: int) -&gt; &amp;int { bar(&amp;n) } fn main() { let p1 = foo(1); let p2 = foo(2); println!("{}, {}", *p1, *p2); }</code> <br>  : <br> demo:5:10: 5:11 error: `n` does not live long enough <br> demo:5 bar(&amp;n) <br> ^ <br> demo:4:24: 6:2 note: reference must be valid for the anonymous lifetime #1 defined on the block at 4:23... <br> demo:4 fn foo(n: int) -&gt; &amp;int { <br> demo:5 bar(&amp;n) <br> demo:6 } <br> demo:4:24: 6:2 note: ...but borrowed value is only valid for the block at 4:23 <br> demo:4 fn foo(n: int) -&gt; &amp;int { <br> demo:5 bar(&amp;n) <br> demo:6 } <br> <br>   <br> <code class="cpp">#include &lt;stdio.h&gt; int minval(int *A, int n) { int currmin; for (int i=0; i&lt;n; i++) if (A[i] &lt; currmin) currmin = A[i]; return currmin; } int main() { int A[] = {1,2,3}; int min = minval(A,3); printf("%d\n", min); }</code> <br>   0  ,     , ,  .       Rust ( - ): <br> <code class="rust">fn minval(A: &amp;[int]) -&gt; int { let mut currmin; for a in A.iter() { if *a &lt; currmin { currmin = *a; } } currmin } fn main() { let A = [1i,2i,3i]; let min = minval(A.as_slice()); println!("{}", min); }</code> <br>  , : use of possibly uninitialized variable: `currmin` <br>   ( )      : <br> <code class="rust">fn minval(A: &amp;[int]) -&gt; int { A.iter().fold(A[0], |u,&amp;a| { if a&lt;u {a} else {u} }) }</code> <br> <br>    <br> <code class="cpp">struct A{ int *x; A(int v): x(new int(v)) {} ~A() {delete x;} }; int main() { A a(1), b=a; }</code> <br> ,    : <br> *** glibc detected *** demo: double free or corruption (fasttop): 0x0000000000601010 *** <br> <br>     Rust: <br> <code class="rust">struct A{ x: Box&lt;int&gt; } impl A { pub fn new(v: int) -&gt; A { A{ x: box v } } } impl Drop for A { fn drop(&amp;mut self) {} // ,     ++ } fn main() { let a = A::new(1); let _b = a; }</code> <br>     .   ,     <code>trait Copy</code> . <br> Rust       .    <code>Eq</code>  <code>Clone</code> ?    <code>deriving</code>   : <br> <code class="rust">#[deriving(Clone, Eq, Hash, PartialEq, PartialOrd, Ord, Show)] struct A{ x: Box&lt;int&gt; }</code> <br> <br>    <br> <code class="cpp">#include &lt;stdio.h&gt; struct X { int a, b; }; void swap_from(X&amp; x, const X&amp; y) { xa = yb; xb = ya; } int main() { X x = {1,2}; swap_from(x,x); printf("%d,%d\n", xa, xb); }</code> <br>  : <br> 2,2 <br>    ,    cc      .   ,   ,  99  <a href="http://en.wikipedia.org/wiki/Restrict">restrict</a> ,            :        . <br> <br>       Rust: <br> <code class="rust">struct X { pub a: int, pub b: int } fn swap_from(x: &amp;mut X, y: &amp;X) { xa = yb; xb = ya; } fn main() { let mut x = X{a:1, b:2}; swap_from(&amp;mut x, &amp;x); }</code> <br>    : <br> demo:7:24: 7:25 error: cannot borrow `x` as immutable because it is also borrowed as mutable <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> ^ <br> demo:7:20: 7:21 note: previous borrow of `x` occurs here; the mutable borrow prevents subsequent moves, borrows, or modification of `x` until the borrow ends <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> ^ <br> demo:7:26: 7:26 note: previous borrow ends here <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> <br>  ,             " <code>&amp;mut</code> "  " <code>&amp;</code> " ,   ,          ,   <code>&amp;mut</code> .            .  ,    ,      C99  <code>restrict</code>  (Rust  LLVM    ),    . <br> <br>   <br> <code class="cpp">#include &lt;vector&gt; int main() { std::vector&lt;int&gt; v; v.push_back(1); v.push_back(2); for(std::vector&lt;int&gt;::const_iterator it=v.begin(); it!=v.end(); ++it) { if (*it &lt; 5) v.push_back(5-*it); } }</code> <br>    ,    : <br> Segmentation fault (core dumped) <br> <br>    Rust: <br> <code class="rust">fn main() { let mut v: Vec&lt;int&gt; = Vec::new(); v.push(1); v.push(2); for x in v.iter() { if *x &lt; 5 { v.push(5-*x); } } }</code> <br>      ,  ,        : <br> demo:7:13: 7:14 error: cannot borrow `v` as mutable because it is also borrowed as immutable <br> demo:7 v.push(5-*x); <br> ^ <br> demo:5:14: 5:15 note: previous borrow of `v` occurs here; the immutable borrow prevents subsequent moves or mutable borrows of `v` until the borrow ends <br> demo:5 for x in v.iter() { <br> ^ <br> demo:10:2: 10:2 note: previous borrow ends here <br> demo:5 for x in v.iter() { <br> demo:6 if *x &lt; 5 { <br> demo:7 v.push(5-*x); <br> demo:8 } <br> demo:9 } <br> demo:10 } <br> <br> <br>  Switch <br> <code class="cpp">#include &lt;stdio.h&gt; enum {RED, BLUE, GRAY, UNKNOWN} color = GRAY; int main() { int x; switch(color) { case GRAY: x=1; case RED: case BLUE: x=2; } printf("%d", x); }</code> <br>   "2".  Rust          .  ,       ,    <code>break</code> .    Rust   : <br> <code class="rust">enum Color {RED, BLUE, GRAY, UNKNOWN} fn main() { let color = GRAY; let x = match color { GRAY =&gt; 1, RED | BLUE =&gt; 2, _ =&gt; 3, }; println!("{}", x); }</code> <br> <br>     <br> <code class="cpp">int main() { int pixels = 1; for (int j=0; j&lt;5; j++); pixels++; }</code> <br>  Rust          . , ,     . <br> <br>  <br> <code class="cpp">#include &lt;stdio.h&gt; #include &lt;pthread.h&gt; #include &lt;unistd.h&gt; class Resource { int *value; public: Resource(): value(NULL) {} ~Resource() {delete value;} int *acquire() { if (!value) { value = new int(0); } return value; } }; void* function(void *param) { int *value = ((Resource*)param)-&gt;acquire(); printf("resource: %p\n", (void*)value); return value; } int main() { Resource res; for (int i=0; i&lt;5; ++i) { pthread_t pt; pthread_create(&amp;pt, NULL, function, &amp;res); } //sleep(10); printf("done\n"); }</code> <br>     : <br> done <br> resource: 0x7f229c0008c0 <br> resource: 0x7f22840008c0 <br> resource: 0x7f228c0008c0 <br> resource: 0x7f22940008c0 <br> resource: 0x7f227c0008c0 <br> <br>     ,        .      Rust: <br> <code class="rust">struct Resource { value: Option&lt;int&gt;, } impl Resource { pub fn new() -&gt; Resource { Resource{ value: None } } pub fn acquire&lt;'a&gt;(&amp;'a mut self) -&gt; &amp;'a int { if self.value.is_none() { self.value = Some(1); } self.value.get_ref() } } fn main() { let mut res = Resource::new(); for _ in range(0,5) { spawn(proc() { let ptr = res.acquire(); println!("resource {}", ptr) }) } }</code> <br>  ,            . <br> demo:20:23: 20:26 error: cannot borrow immutable captured outer variable in a proc `res` as mutable <br> demo:20 let ptr = res.acquire(); <br> <br>      ,   : <br> <code class="rust">extern crate sync; use sync::{Arc, RWLock}; struct Resource { value: Option&lt;Box&lt;int&gt;&gt;, } impl Resource { pub fn new() -&gt; Resource { Resource{ value: None } } pub fn acquire(&amp;mut self) -&gt; *int { if self.value.is_none() { self.value = Some(box 1) } &amp;**self.value.get_ref() as *int } } fn main() { let arc_res = Arc::new(RWLock::new(Resource::new())); for _ in range(0,5) { let child_res = arc_res.clone(); spawn(proc() { let ptr = child_res.write().acquire(); println!("resource: {}", ptr) }) } }</code> <br>     <code>Arc</code> ( <i>Atomically Reference Counted</i> -        )  <code>RWLock</code> (   ).   : <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> <br>  ,   ++    .    . Rust        ,    .  ,   ,   .           ,       ( <a href="http://superwebdeveloper.com/2009/11/25/the-incredible-rate-of-diminishing-returns-of-fixing-software-bugs/">  </a> ). <br> <br>     <br> Rust        ,     <code>unsafe{}</code> .   ,     " <i> !  ,  .</i> ".  ,  ""  (    ,    )    .    ,           ( )  . , ,        <code>Cell</code>  <code>Mutex</code> .             ,       (   <a href="http://en.wikipedia.org/wiki/Test-driven_development">TDD</a> !). <br> <br>  <br> <a href="https://air.mozilla.org/guaranteeing-memory-safety-in-rust/">Guaranteeing Memory Safety in Rust (by Niko Matsakis)</a> <br> <a href="http://www.techtalkshub.com/rust-safe-systems-programming-fun-fp/">Rust: Safe Systems Programming with the Fun of FP (by Felix Klock II)</a> <br> <a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Keynote">Lang-NEXT: What ‚Äì if anything ‚Äì have we learned from C++? (by Bjarne Stroustrup)</a> <br> <a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Panel-Systems-Programming-Languages-in-2014-and-Beyond">Lang-NEXT Panel: Systems Programming in 2014 and Beyond</a></code></code> </h4> <code><code><code><code class="cpp">Box)     ,       (     ).        (std::rc::Rc)    (std::gc::Gc),      (   ). <br> <br></code>      <br>  ++: <br> #include &lt;stdio.h&gt; int *bar(int *p) { return p; } int* foo(int n) { return bar(&amp;n); } int main() { int *p1 = foo(1); int *p2 = foo(2); printf("%d, %d\n", *p1, *p2); }</code> <br>  : <br> 2, 2 <br> <br>  Rust: <br> <code class="rust">fn bar&lt;'a&gt;(p: &amp;'a int) -&gt; &amp;'a int { return p; } fn foo(n: int) -&gt; &amp;int { bar(&amp;n) } fn main() { let p1 = foo(1); let p2 = foo(2); println!("{}, {}", *p1, *p2); }</code> <br>  : <br> demo:5:10: 5:11 error: `n` does not live long enough <br> demo:5 bar(&amp;n) <br> ^ <br> demo:4:24: 6:2 note: reference must be valid for the anonymous lifetime #1 defined on the block at 4:23... <br> demo:4 fn foo(n: int) -&gt; &amp;int { <br> demo:5 bar(&amp;n) <br> demo:6 } <br> demo:4:24: 6:2 note: ...but borrowed value is only valid for the block at 4:23 <br> demo:4 fn foo(n: int) -&gt; &amp;int { <br> demo:5 bar(&amp;n) <br> demo:6 } <br> <br>   <br> <code class="cpp">#include &lt;stdio.h&gt; int minval(int *A, int n) { int currmin; for (int i=0; i&lt;n; i++) if (A[i] &lt; currmin) currmin = A[i]; return currmin; } int main() { int A[] = {1,2,3}; int min = minval(A,3); printf("%d\n", min); }</code> <br>   0  ,     , ,  .       Rust ( - ): <br> <code class="rust">fn minval(A: &amp;[int]) -&gt; int { let mut currmin; for a in A.iter() { if *a &lt; currmin { currmin = *a; } } currmin } fn main() { let A = [1i,2i,3i]; let min = minval(A.as_slice()); println!("{}", min); }</code> <br>  , : use of possibly uninitialized variable: `currmin` <br>   ( )      : <br> <code class="rust">fn minval(A: &amp;[int]) -&gt; int { A.iter().fold(A[0], |u,&amp;a| { if a&lt;u {a} else {u} }) }</code> <br> <br>    <br> <code class="cpp">struct A{ int *x; A(int v): x(new int(v)) {} ~A() {delete x;} }; int main() { A a(1), b=a; }</code> <br> ,    : <br> *** glibc detected *** demo: double free or corruption (fasttop): 0x0000000000601010 *** <br> <br>     Rust: <br> <code class="rust">struct A{ x: Box&lt;int&gt; } impl A { pub fn new(v: int) -&gt; A { A{ x: box v } } } impl Drop for A { fn drop(&amp;mut self) {} // ,     ++ } fn main() { let a = A::new(1); let _b = a; }</code> <br>     .   ,     <code>trait Copy</code> . <br> Rust       .    <code>Eq</code>  <code>Clone</code> ?    <code>deriving</code>   : <br> <code class="rust">#[deriving(Clone, Eq, Hash, PartialEq, PartialOrd, Ord, Show)] struct A{ x: Box&lt;int&gt; }</code> <br> <br>    <br> <code class="cpp">#include &lt;stdio.h&gt; struct X { int a, b; }; void swap_from(X&amp; x, const X&amp; y) { xa = yb; xb = ya; } int main() { X x = {1,2}; swap_from(x,x); printf("%d,%d\n", xa, xb); }</code> <br>  : <br> 2,2 <br>    ,    cc      .   ,   ,  99  <a href="http://en.wikipedia.org/wiki/Restrict">restrict</a> ,            :        . <br> <br>       Rust: <br> <code class="rust">struct X { pub a: int, pub b: int } fn swap_from(x: &amp;mut X, y: &amp;X) { xa = yb; xb = ya; } fn main() { let mut x = X{a:1, b:2}; swap_from(&amp;mut x, &amp;x); }</code> <br>    : <br> demo:7:24: 7:25 error: cannot borrow `x` as immutable because it is also borrowed as mutable <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> ^ <br> demo:7:20: 7:21 note: previous borrow of `x` occurs here; the mutable borrow prevents subsequent moves, borrows, or modification of `x` until the borrow ends <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> ^ <br> demo:7:26: 7:26 note: previous borrow ends here <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> <br>  ,             " <code>&amp;mut</code> "  " <code>&amp;</code> " ,   ,          ,   <code>&amp;mut</code> .            .  ,    ,      C99  <code>restrict</code>  (Rust  LLVM    ),    . <br> <br>   <br> <code class="cpp">#include &lt;vector&gt; int main() { std::vector&lt;int&gt; v; v.push_back(1); v.push_back(2); for(std::vector&lt;int&gt;::const_iterator it=v.begin(); it!=v.end(); ++it) { if (*it &lt; 5) v.push_back(5-*it); } }</code> <br>    ,    : <br> Segmentation fault (core dumped) <br> <br>    Rust: <br> <code class="rust">fn main() { let mut v: Vec&lt;int&gt; = Vec::new(); v.push(1); v.push(2); for x in v.iter() { if *x &lt; 5 { v.push(5-*x); } } }</code> <br>      ,  ,        : <br> demo:7:13: 7:14 error: cannot borrow `v` as mutable because it is also borrowed as immutable <br> demo:7 v.push(5-*x); <br> ^ <br> demo:5:14: 5:15 note: previous borrow of `v` occurs here; the immutable borrow prevents subsequent moves or mutable borrows of `v` until the borrow ends <br> demo:5 for x in v.iter() { <br> ^ <br> demo:10:2: 10:2 note: previous borrow ends here <br> demo:5 for x in v.iter() { <br> demo:6 if *x &lt; 5 { <br> demo:7 v.push(5-*x); <br> demo:8 } <br> demo:9 } <br> demo:10 } <br> <br> <br>  Switch <br> <code class="cpp">#include &lt;stdio.h&gt; enum {RED, BLUE, GRAY, UNKNOWN} color = GRAY; int main() { int x; switch(color) { case GRAY: x=1; case RED: case BLUE: x=2; } printf("%d", x); }</code> <br>   "2".  Rust          .  ,       ,    <code>break</code> .    Rust   : <br> <code class="rust">enum Color {RED, BLUE, GRAY, UNKNOWN} fn main() { let color = GRAY; let x = match color { GRAY =&gt; 1, RED | BLUE =&gt; 2, _ =&gt; 3, }; println!("{}", x); }</code> <br> <br>     <br> <code class="cpp">int main() { int pixels = 1; for (int j=0; j&lt;5; j++); pixels++; }</code> <br>  Rust          . , ,     . <br> <br>  <br> <code class="cpp">#include &lt;stdio.h&gt; #include &lt;pthread.h&gt; #include &lt;unistd.h&gt; class Resource { int *value; public: Resource(): value(NULL) {} ~Resource() {delete value;} int *acquire() { if (!value) { value = new int(0); } return value; } }; void* function(void *param) { int *value = ((Resource*)param)-&gt;acquire(); printf("resource: %p\n", (void*)value); return value; } int main() { Resource res; for (int i=0; i&lt;5; ++i) { pthread_t pt; pthread_create(&amp;pt, NULL, function, &amp;res); } //sleep(10); printf("done\n"); }</code> <br>     : <br> done <br> resource: 0x7f229c0008c0 <br> resource: 0x7f22840008c0 <br> resource: 0x7f228c0008c0 <br> resource: 0x7f22940008c0 <br> resource: 0x7f227c0008c0 <br> <br>     ,        .      Rust: <br> <code class="rust">struct Resource { value: Option&lt;int&gt;, } impl Resource { pub fn new() -&gt; Resource { Resource{ value: None } } pub fn acquire&lt;'a&gt;(&amp;'a mut self) -&gt; &amp;'a int { if self.value.is_none() { self.value = Some(1); } self.value.get_ref() } } fn main() { let mut res = Resource::new(); for _ in range(0,5) { spawn(proc() { let ptr = res.acquire(); println!("resource {}", ptr) }) } }</code> <br>  ,            . <br> demo:20:23: 20:26 error: cannot borrow immutable captured outer variable in a proc `res` as mutable <br> demo:20 let ptr = res.acquire(); <br> <br>      ,   : <br> <code class="rust">extern crate sync; use sync::{Arc, RWLock}; struct Resource { value: Option&lt;Box&lt;int&gt;&gt;, } impl Resource { pub fn new() -&gt; Resource { Resource{ value: None } } pub fn acquire(&amp;mut self) -&gt; *int { if self.value.is_none() { self.value = Some(box 1) } &amp;**self.value.get_ref() as *int } } fn main() { let arc_res = Arc::new(RWLock::new(Resource::new())); for _ in range(0,5) { let child_res = arc_res.clone(); spawn(proc() { let ptr = child_res.write().acquire(); println!("resource: {}", ptr) }) } }</code> <br>     <code>Arc</code> ( <i>Atomically Reference Counted</i> -        )  <code>RWLock</code> (   ).   : <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> <br>  ,   ++    .    . Rust        ,    .  ,   ,   .           ,       ( <a href="http://superwebdeveloper.com/2009/11/25/the-incredible-rate-of-diminishing-returns-of-fixing-software-bugs/">  </a> ). <br> <br>     <br> Rust        ,     <code>unsafe{}</code> .   ,     " <i> !  ,  .</i> ".  ,  ""  (    ,    )    .    ,           ( )  . , ,        <code>Cell</code>  <code>Mutex</code> .             ,       (   <a href="http://en.wikipedia.org/wiki/Test-driven_development">TDD</a> !). <br> <br>  <br> <a href="https://air.mozilla.org/guaranteeing-memory-safety-in-rust/">Guaranteeing Memory Safety in Rust (by Niko Matsakis)</a> <br> <a href="http://www.techtalkshub.com/rust-safe-systems-programming-fun-fp/">Rust: Safe Systems Programming with the Fun of FP (by Felix Klock II)</a> <br> <a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Keynote">Lang-NEXT: What ‚Äì if anything ‚Äì have we learned from C++? (by Bjarne Stroustrup)</a> <br> <a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Panel-Systems-Programming-Languages-in-2014-and-Beyond">Lang-NEXT Panel: Systems Programming in 2014 and Beyond</a></code></code> <pre> <code class="hljs rust"><code><code><code class="cpp"><span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>)     ,       (     ).        (std::rc::Rc)    (std::gc::Gc),      (   ). <br> <br></code>      <br>  ++: <br> #include &lt;stdio.h&gt; int *bar(int *p) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p; } int* foo(int n) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bar(&amp;n); } int main() { int *p1 = foo(<span class="hljs-number"><span class="hljs-number">1</span></span>); int *p2 = foo(<span class="hljs-number"><span class="hljs-number">2</span></span>); printf(<span class="hljs-string"><span class="hljs-string">"%d, %d\n"</span></span>, *p1, *p2); }</code> <br>  : <br> <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span> <br> <br>  Rust: <br> <code class="rust"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt;(p: &amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> int) -&gt; &amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> int { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>(n: int) -&gt; &amp;int { bar(&amp;n) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> p1 = foo(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> p2 = foo(<span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{}, {}"</span></span>, *p1, *p2); }</code> <br>  : <br> demo:<span class="hljs-number"><span class="hljs-number">5</span></span>:<span class="hljs-number"><span class="hljs-number">10</span></span>: <span class="hljs-number"><span class="hljs-number">5</span></span>:<span class="hljs-number"><span class="hljs-number">11</span></span> error: `n` does not live long enough <br> demo:<span class="hljs-number"><span class="hljs-number">5</span></span> bar(&amp;n) <br> ^ <br> demo:<span class="hljs-number"><span class="hljs-number">4</span></span>:<span class="hljs-number"><span class="hljs-number">24</span></span>: <span class="hljs-number"><span class="hljs-number">6</span></span>:<span class="hljs-number"><span class="hljs-number">2</span></span> note: reference must <span class="hljs-keyword"><span class="hljs-keyword">be</span></span> valid <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> the anonymous lifetime #<span class="hljs-number"><span class="hljs-number">1</span></span> defined on the block at <span class="hljs-number"><span class="hljs-number">4</span></span>:<span class="hljs-number"><span class="hljs-number">23</span></span>... <br> demo:<span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>(n: int) -&gt; &amp;int { <br> demo:<span class="hljs-number"><span class="hljs-number">5</span></span> bar(&amp;n) <br> demo:<span class="hljs-number"><span class="hljs-number">6</span></span> } <br> demo:<span class="hljs-number"><span class="hljs-number">4</span></span>:<span class="hljs-number"><span class="hljs-number">24</span></span>: <span class="hljs-number"><span class="hljs-number">6</span></span>:<span class="hljs-number"><span class="hljs-number">2</span></span> note: ...but borrowed value is only valid <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> the block at <span class="hljs-number"><span class="hljs-number">4</span></span>:<span class="hljs-number"><span class="hljs-number">23</span></span> <br> demo:<span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>(n: int) -&gt; &amp;int { <br> demo:<span class="hljs-number"><span class="hljs-number">5</span></span> bar(&amp;n) <br> demo:<span class="hljs-number"><span class="hljs-number">6</span></span> } <br> <br>   <br> <code class="cpp">#include &lt;stdio.h&gt; int minval(int *A, int n) { int currmin; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;n; i++) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (A[i] &lt; currmin) currmin = A[i]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> currmin; } int main() { int A[] = {<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>}; int min = minval(A,<span class="hljs-number"><span class="hljs-number">3</span></span>); printf(<span class="hljs-string"><span class="hljs-string">"%d\n"</span></span>, min); }</code> <br>   <span class="hljs-number"><span class="hljs-number">0</span></span>  ,     , ,  .       Rust ( - ): <br> <code class="rust"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">minval</span></span></span></span>(A: &amp;[int]) -&gt; int { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> currmin; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> a <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> A.iter() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> *a &lt; currmin { currmin = *a; } } currmin } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> A = [<span class="hljs-number"><span class="hljs-number">1</span></span>i,<span class="hljs-number"><span class="hljs-number">2</span></span>i,<span class="hljs-number"><span class="hljs-number">3</span></span>i]; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> min = minval(A.as_slice()); <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{}"</span></span>, min); }</code> <br>  , : <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> of possibly uninitialized variable: `currmin` <br>   ( )      : <br> <code class="rust"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">minval</span></span></span></span>(A: &amp;[int]) -&gt; int { A.iter().fold(A[<span class="hljs-number"><span class="hljs-number">0</span></span>], |u,&amp;a| { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> a&lt;u {a} <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {u} }) }</code> <br> <br>    <br> <code class="cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span></span>{ int *x; A(int v): x(new int(v)) {} ~A() {delete x;} }; int main() { A a(<span class="hljs-number"><span class="hljs-number">1</span></span>), b=a; }</code> <br> ,    : <br> *** glibc detected *** demo: double free or corruption (fasttop): <span class="hljs-number"><span class="hljs-number">0x0000000000601010</span></span> *** <br> <br>     Rust: <br> <code class="rust"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span></span>{ x: <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;int&gt; } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> A { <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">new</span></span></span></span>(v: int) -&gt; A { A{ x: <span class="hljs-keyword"><span class="hljs-keyword">box</span></span> v } } } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Drop</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> A { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drop</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) {} <span class="hljs-comment"><span class="hljs-comment">// ,     ++ } fn main() { let a = A::new(1); let _b = a; }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">     .   ,     </span></span><code><span class="hljs-comment"><span class="hljs-comment">trait Copy</span></span></code><span class="hljs-comment"><span class="hljs-comment"> . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> Rust       .    </span></span><code><span class="hljs-comment"><span class="hljs-comment">Eq</span></span></code><span class="hljs-comment"><span class="hljs-comment">  </span></span><code><span class="hljs-comment"><span class="hljs-comment">Clone</span></span></code><span class="hljs-comment"><span class="hljs-comment"> ?    </span></span><code><span class="hljs-comment"><span class="hljs-comment">deriving</span></span></code><span class="hljs-comment"><span class="hljs-comment">   : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="rust"><span class="hljs-comment"><span class="hljs-comment">#[deriving(Clone, Eq, Hash, PartialEq, PartialOrd, Ord, Show)] struct A{ x: Box&lt;int&gt; }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">    </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="cpp"><span class="hljs-comment"><span class="hljs-comment">#include &lt;stdio.h&gt; struct X { int a, b; }; void swap_from(X&amp; x, const X&amp; y) { xa = yb; xb = ya; } int main() { X x = {1,2}; swap_from(x,x); printf("%d,%d\n", xa, xb); }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> 2,2 </span></span><br><span class="hljs-comment"><span class="hljs-comment">    ,    cc      .   ,   ,  99  </span></span><a href="http://en.wikipedia.org/wiki/Restrict"><span class="hljs-comment"><span class="hljs-comment">restrict</span></span></a><span class="hljs-comment"><span class="hljs-comment"> ,            :        . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">       Rust: </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="rust"><span class="hljs-comment"><span class="hljs-comment">struct X { pub a: int, pub b: int } fn swap_from(x: &amp;mut X, y: &amp;X) { xa = yb; xb = ya; } fn main() { let mut x = X{a:1, b:2}; swap_from(&amp;mut x, &amp;x); }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">    : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7:24: 7:25 error: cannot borrow `x` as immutable because it is also borrowed as mutable </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7 swap_from(&amp;mut x, &amp;x); </span></span><br><span class="hljs-comment"><span class="hljs-comment"> ^ </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7:20: 7:21 note: previous borrow of `x` occurs here; the mutable borrow prevents subsequent moves, borrows, or modification of `x` until the borrow ends </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7 swap_from(&amp;mut x, &amp;x); </span></span><br><span class="hljs-comment"><span class="hljs-comment"> ^ </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7:26: 7:26 note: previous borrow ends here </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7 swap_from(&amp;mut x, &amp;x); </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  ,             " </span></span><code><span class="hljs-comment"><span class="hljs-comment">&amp;mut</span></span></code><span class="hljs-comment"><span class="hljs-comment"> "  " </span></span><code><span class="hljs-comment"><span class="hljs-comment">&amp;</span></span></code><span class="hljs-comment"><span class="hljs-comment"> " ,   ,          ,   </span></span><code><span class="hljs-comment"><span class="hljs-comment">&amp;mut</span></span></code><span class="hljs-comment"><span class="hljs-comment"> .            .  ,    ,      C99  </span></span><code><span class="hljs-comment"><span class="hljs-comment">restrict</span></span></code><span class="hljs-comment"><span class="hljs-comment">  (Rust  LLVM    ),    . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">   </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="cpp"><span class="hljs-comment"><span class="hljs-comment">#include &lt;vector&gt; int main() { std::vector&lt;int&gt; v; v.push_back(1); v.push_back(2); for(std::vector&lt;int&gt;::const_iterator it=v.begin(); it!=v.end(); ++it) { if (*it &lt; 5) v.push_back(5-*it); } }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">    ,    : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> Segmentation fault (core dumped) </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">    Rust: </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="rust"><span class="hljs-comment"><span class="hljs-comment">fn main() { let mut v: Vec&lt;int&gt; = Vec::new(); v.push(1); v.push(2); for x in v.iter() { if *x &lt; 5 { v.push(5-*x); } } }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">      ,  ,        : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7:13: 7:14 error: cannot borrow `v` as mutable because it is also borrowed as immutable </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7 v.push(5-*x); </span></span><br><span class="hljs-comment"><span class="hljs-comment"> ^ </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:5:14: 5:15 note: previous borrow of `v` occurs here; the immutable borrow prevents subsequent moves or mutable borrows of `v` until the borrow ends </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:5 for x in v.iter() { </span></span><br><span class="hljs-comment"><span class="hljs-comment"> ^ </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:10:2: 10:2 note: previous borrow ends here </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:5 for x in v.iter() { </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:6 if *x &lt; 5 { </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7 v.push(5-*x); </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:8 } </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:9 } </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:10 } </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  Switch </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="cpp"><span class="hljs-comment"><span class="hljs-comment">#include &lt;stdio.h&gt; enum {RED, BLUE, GRAY, UNKNOWN} color = GRAY; int main() { int x; switch(color) { case GRAY: x=1; case RED: case BLUE: x=2; } printf("%d", x); }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">   "2".  Rust          .  ,       ,    </span></span><code><span class="hljs-comment"><span class="hljs-comment">break</span></span></code><span class="hljs-comment"><span class="hljs-comment"> .    Rust   : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="rust"><span class="hljs-comment"><span class="hljs-comment">enum Color {RED, BLUE, GRAY, UNKNOWN} fn main() { let color = GRAY; let x = match color { GRAY =&gt; 1, RED | BLUE =&gt; 2, _ =&gt; 3, }; println!("{}", x); }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">     </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="cpp"><span class="hljs-comment"><span class="hljs-comment">int main() { int pixels = 1; for (int j=0; j&lt;5; j++); pixels++; }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  Rust          . , ,     . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="cpp"><span class="hljs-comment"><span class="hljs-comment">#include &lt;stdio.h&gt; #include &lt;pthread.h&gt; #include &lt;unistd.h&gt; class Resource { int *value; public: Resource(): value(NULL) {} ~Resource() {delete value;} int *acquire() { if (!value) { value = new int(0); } return value; } }; void* function(void *param) { int *value = ((Resource*)param)-&gt;acquire(); printf("resource: %p\n", (void*)value); return value; } int main() { Resource res; for (int i=0; i&lt;5; ++i) { pthread_t pt; pthread_create(&amp;pt, NULL, function, &amp;res); } //sleep(10); printf("done\n"); }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">     : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> done </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7f229c0008c0 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7f22840008c0 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7f228c0008c0 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7f22940008c0 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7f227c0008c0 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">     ,        .      Rust: </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="rust"><span class="hljs-comment"><span class="hljs-comment">struct Resource { value: Option&lt;int&gt;, } impl Resource { pub fn new() -&gt; Resource { Resource{ value: None } } pub fn acquire&lt;'a&gt;(&amp;'a mut self) -&gt; &amp;'a int { if self.value.is_none() { self.value = Some(1); } self.value.get_ref() } } fn main() { let mut res = Resource::new(); for _ in range(0,5) { spawn(proc() { let ptr = res.acquire(); println!("resource {}", ptr) }) } }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  ,            . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:20:23: 20:26 error: cannot borrow immutable captured outer variable in a proc `res` as mutable </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:20 let ptr = res.acquire(); </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">      ,   : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="rust"><span class="hljs-comment"><span class="hljs-comment">extern crate sync; use sync::{Arc, RWLock}; struct Resource { value: Option&lt;Box&lt;int&gt;&gt;, } impl Resource { pub fn new() -&gt; Resource { Resource{ value: None } } pub fn acquire(&amp;mut self) -&gt; *int { if self.value.is_none() { self.value = Some(box 1) } &amp;**self.value.get_ref() as *int } } fn main() { let arc_res = Arc::new(RWLock::new(Resource::new())); for _ in range(0,5) { let child_res = arc_res.clone(); spawn(proc() { let ptr = child_res.write().acquire(); println!("resource: {}", ptr) }) } }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">     </span></span><code><span class="hljs-comment"><span class="hljs-comment">Arc</span></span></code><span class="hljs-comment"><span class="hljs-comment"> ( </span></span><i><span class="hljs-comment"><span class="hljs-comment">Atomically Reference Counted</span></span></i><span class="hljs-comment"><span class="hljs-comment"> -        )  </span></span><code><span class="hljs-comment"><span class="hljs-comment">RWLock</span></span></code><span class="hljs-comment"><span class="hljs-comment"> (   ).   : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7ff4b0010378 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7ff4b0010378 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7ff4b0010378 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7ff4b0010378 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7ff4b0010378 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  ,   ++    .    . Rust        ,    .  ,   ,   .           ,       ( </span></span><a href="http://superwebdeveloper.com/2009/11/25/the-incredible-rate-of-diminishing-returns-of-fixing-software-bugs/"><span class="hljs-comment"><span class="hljs-comment">  </span></span></a><span class="hljs-comment"><span class="hljs-comment"> ). </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">     </span></span><br><span class="hljs-comment"><span class="hljs-comment"> Rust        ,     </span></span><code><span class="hljs-comment"><span class="hljs-comment">unsafe{}</span></span></code><span class="hljs-comment"><span class="hljs-comment"> .   ,     " </span></span><i><span class="hljs-comment"><span class="hljs-comment"> !  ,  .</span></span></i><span class="hljs-comment"><span class="hljs-comment"> ".  ,  ""  (    ,    )    .    ,           ( )  . , ,        </span></span><code><span class="hljs-comment"><span class="hljs-comment">Cell</span></span></code><span class="hljs-comment"><span class="hljs-comment">  </span></span><code><span class="hljs-comment"><span class="hljs-comment">Mutex</span></span></code><span class="hljs-comment"><span class="hljs-comment"> .             ,       (   </span></span><a href="http://en.wikipedia.org/wiki/Test-driven_development"><span class="hljs-comment"><span class="hljs-comment">TDD</span></span></a><span class="hljs-comment"><span class="hljs-comment"> !). </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="https://air.mozilla.org/guaranteeing-memory-safety-in-rust/"><span class="hljs-comment"><span class="hljs-comment">Guaranteeing Memory Safety in Rust (by Niko Matsakis)</span></span></a><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="http://www.techtalkshub.com/rust-safe-systems-programming-fun-fp/"><span class="hljs-comment"><span class="hljs-comment">Rust: Safe Systems Programming with the Fun of FP (by Felix Klock II)</span></span></a><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Keynote"><span class="hljs-comment"><span class="hljs-comment">Lang-NEXT: What ‚Äì if anything ‚Äì have we learned from C++? (by Bjarne Stroustrup)</span></span></a><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Panel-Systems-Programming-Languages-in-2014-and-Beyond"><span class="hljs-comment"><span class="hljs-comment">Lang-NEXT Panel: Systems Programming in 2014 and Beyond</span></span></a></code></code> </pre> <code><code><code><code class="cpp">Box)     ,       (     ).        (std::rc::Rc)    (std::gc::Gc),      (   ). <br> <br></code>      <br>  ++: <br> #include &lt;stdio.h&gt; int *bar(int *p) { return p; } int* foo(int n) { return bar(&amp;n); } int main() { int *p1 = foo(1); int *p2 = foo(2); printf("%d, %d\n", *p1, *p2); }</code> <br>  : <br> 2, 2 <br> <br>  Rust: <br> <code class="rust">fn bar&lt;'a&gt;(p: &amp;'a int) -&gt; &amp;'a int { return p; } fn foo(n: int) -&gt; &amp;int { bar(&amp;n) } fn main() { let p1 = foo(1); let p2 = foo(2); println!("{}, {}", *p1, *p2); }</code> <br>  : <br> demo:5:10: 5:11 error: `n` does not live long enough <br> demo:5 bar(&amp;n) <br> ^ <br> demo:4:24: 6:2 note: reference must be valid for the anonymous lifetime #1 defined on the block at 4:23... <br> demo:4 fn foo(n: int) -&gt; &amp;int { <br> demo:5 bar(&amp;n) <br> demo:6 } <br> demo:4:24: 6:2 note: ...but borrowed value is only valid for the block at 4:23 <br> demo:4 fn foo(n: int) -&gt; &amp;int { <br> demo:5 bar(&amp;n) <br> demo:6 } <br> <br>   <br> <code class="cpp">#include &lt;stdio.h&gt; int minval(int *A, int n) { int currmin; for (int i=0; i&lt;n; i++) if (A[i] &lt; currmin) currmin = A[i]; return currmin; } int main() { int A[] = {1,2,3}; int min = minval(A,3); printf("%d\n", min); }</code> <br>   0  ,     , ,  .       Rust ( - ): <br> <code class="rust">fn minval(A: &amp;[int]) -&gt; int { let mut currmin; for a in A.iter() { if *a &lt; currmin { currmin = *a; } } currmin } fn main() { let A = [1i,2i,3i]; let min = minval(A.as_slice()); println!("{}", min); }</code> <br>  , : use of possibly uninitialized variable: `currmin` <br>   ( )      : <br> <code class="rust">fn minval(A: &amp;[int]) -&gt; int { A.iter().fold(A[0], |u,&amp;a| { if a&lt;u {a} else {u} }) }</code> <br> <br>    <br> <code class="cpp">struct A{ int *x; A(int v): x(new int(v)) {} ~A() {delete x;} }; int main() { A a(1), b=a; }</code> <br> ,    : <br> *** glibc detected *** demo: double free or corruption (fasttop): 0x0000000000601010 *** <br> <br>     Rust: <br> <code class="rust">struct A{ x: Box&lt;int&gt; } impl A { pub fn new(v: int) -&gt; A { A{ x: box v } } } impl Drop for A { fn drop(&amp;mut self) {} // ,     ++ } fn main() { let a = A::new(1); let _b = a; }</code> <br>     .   ,     <code>trait Copy</code> . <br> Rust       .    <code>Eq</code>  <code>Clone</code> ?    <code>deriving</code>   : <br> <code class="rust">#[deriving(Clone, Eq, Hash, PartialEq, PartialOrd, Ord, Show)] struct A{ x: Box&lt;int&gt; }</code> <br> <br>    <br> <code class="cpp">#include &lt;stdio.h&gt; struct X { int a, b; }; void swap_from(X&amp; x, const X&amp; y) { xa = yb; xb = ya; } int main() { X x = {1,2}; swap_from(x,x); printf("%d,%d\n", xa, xb); }</code> <br>  : <br> 2,2 <br>    ,    cc      .   ,   ,  99  <a href="http://en.wikipedia.org/wiki/Restrict">restrict</a> ,            :        . <br> <br>       Rust: <br> <code class="rust">struct X { pub a: int, pub b: int } fn swap_from(x: &amp;mut X, y: &amp;X) { xa = yb; xb = ya; } fn main() { let mut x = X{a:1, b:2}; swap_from(&amp;mut x, &amp;x); }</code> <br>    : <br> demo:7:24: 7:25 error: cannot borrow `x` as immutable because it is also borrowed as mutable <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> ^ <br> demo:7:20: 7:21 note: previous borrow of `x` occurs here; the mutable borrow prevents subsequent moves, borrows, or modification of `x` until the borrow ends <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> ^ <br> demo:7:26: 7:26 note: previous borrow ends here <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> <br>  ,             " <code>&amp;mut</code> "  " <code>&amp;</code> " ,   ,          ,   <code>&amp;mut</code> .            .  ,    ,      C99  <code>restrict</code>  (Rust  LLVM    ),    . <br> <br>   <br> <code class="cpp">#include &lt;vector&gt; int main() { std::vector&lt;int&gt; v; v.push_back(1); v.push_back(2); for(std::vector&lt;int&gt;::const_iterator it=v.begin(); it!=v.end(); ++it) { if (*it &lt; 5) v.push_back(5-*it); } }</code> <br>    ,    : <br> Segmentation fault (core dumped) <br> <br>    Rust: <br> <code class="rust">fn main() { let mut v: Vec&lt;int&gt; = Vec::new(); v.push(1); v.push(2); for x in v.iter() { if *x &lt; 5 { v.push(5-*x); } } }</code> <br>      ,  ,        : <br> demo:7:13: 7:14 error: cannot borrow `v` as mutable because it is also borrowed as immutable <br> demo:7 v.push(5-*x); <br> ^ <br> demo:5:14: 5:15 note: previous borrow of `v` occurs here; the immutable borrow prevents subsequent moves or mutable borrows of `v` until the borrow ends <br> demo:5 for x in v.iter() { <br> ^ <br> demo:10:2: 10:2 note: previous borrow ends here <br> demo:5 for x in v.iter() { <br> demo:6 if *x &lt; 5 { <br> demo:7 v.push(5-*x); <br> demo:8 } <br> demo:9 } <br> demo:10 } <br> <br> <br>  Switch <br> <code class="cpp">#include &lt;stdio.h&gt; enum {RED, BLUE, GRAY, UNKNOWN} color = GRAY; int main() { int x; switch(color) { case GRAY: x=1; case RED: case BLUE: x=2; } printf("%d", x); }</code> <br>   "2".  Rust          .  ,       ,    <code>break</code> .    Rust   : <br> <code class="rust">enum Color {RED, BLUE, GRAY, UNKNOWN} fn main() { let color = GRAY; let x = match color { GRAY =&gt; 1, RED | BLUE =&gt; 2, _ =&gt; 3, }; println!("{}", x); }</code> <br> <br>     <br> <code class="cpp">int main() { int pixels = 1; for (int j=0; j&lt;5; j++); pixels++; }</code> <br>  Rust          . , ,     . <br> <br>  <br> <code class="cpp">#include &lt;stdio.h&gt; #include &lt;pthread.h&gt; #include &lt;unistd.h&gt; class Resource { int *value; public: Resource(): value(NULL) {} ~Resource() {delete value;} int *acquire() { if (!value) { value = new int(0); } return value; } }; void* function(void *param) { int *value = ((Resource*)param)-&gt;acquire(); printf("resource: %p\n", (void*)value); return value; } int main() { Resource res; for (int i=0; i&lt;5; ++i) { pthread_t pt; pthread_create(&amp;pt, NULL, function, &amp;res); } //sleep(10); printf("done\n"); }</code> <br>     : <br> done <br> resource: 0x7f229c0008c0 <br> resource: 0x7f22840008c0 <br> resource: 0x7f228c0008c0 <br> resource: 0x7f22940008c0 <br> resource: 0x7f227c0008c0 <br> <br>     ,        .      Rust: <br> <code class="rust">struct Resource { value: Option&lt;int&gt;, } impl Resource { pub fn new() -&gt; Resource { Resource{ value: None } } pub fn acquire&lt;'a&gt;(&amp;'a mut self) -&gt; &amp;'a int { if self.value.is_none() { self.value = Some(1); } self.value.get_ref() } } fn main() { let mut res = Resource::new(); for _ in range(0,5) { spawn(proc() { let ptr = res.acquire(); println!("resource {}", ptr) }) } }</code> <br>  ,            . <br> demo:20:23: 20:26 error: cannot borrow immutable captured outer variable in a proc `res` as mutable <br> demo:20 let ptr = res.acquire(); <br> <br>      ,   : <br> <code class="rust">extern crate sync; use sync::{Arc, RWLock}; struct Resource { value: Option&lt;Box&lt;int&gt;&gt;, } impl Resource { pub fn new() -&gt; Resource { Resource{ value: None } } pub fn acquire(&amp;mut self) -&gt; *int { if self.value.is_none() { self.value = Some(box 1) } &amp;**self.value.get_ref() as *int } } fn main() { let arc_res = Arc::new(RWLock::new(Resource::new())); for _ in range(0,5) { let child_res = arc_res.clone(); spawn(proc() { let ptr = child_res.write().acquire(); println!("resource: {}", ptr) }) } }</code> <br>     <code>Arc</code> ( <i>Atomically Reference Counted</i> -        )  <code>RWLock</code> (   ).   : <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> <br>  ,   ++    .    . Rust        ,    .  ,   ,   .           ,       ( <a href="http://superwebdeveloper.com/2009/11/25/the-incredible-rate-of-diminishing-returns-of-fixing-software-bugs/">  </a> ). <br> <br>     <br> Rust        ,     <code>unsafe{}</code> .   ,     " <i> !  ,  .</i> ".  ,  ""  (    ,    )    .    ,           ( )  . , ,        <code>Cell</code>  <code>Mutex</code> .             ,       (   <a href="http://en.wikipedia.org/wiki/Test-driven_development">TDD</a> !). <br> <br>  <br> <a href="https://air.mozilla.org/guaranteeing-memory-safety-in-rust/">Guaranteeing Memory Safety in Rust (by Niko Matsakis)</a> <br> <a href="http://www.techtalkshub.com/rust-safe-systems-programming-fun-fp/">Rust: Safe Systems Programming with the Fun of FP (by Felix Klock II)</a> <br> <a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Keynote">Lang-NEXT: What ‚Äì if anything ‚Äì have we learned from C++? (by Bjarne Stroustrup)</a> <br> <a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Panel-Systems-Programming-Languages-in-2014-and-Beyond">Lang-NEXT Panel: Systems Programming in 2014 and Beyond</a></code></code> <pre> <code class="hljs rust"><code><code><code class="cpp"><span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>)     ,       (     ).        (std::rc::Rc)    (std::gc::Gc),      (   ). <br> <br></code>      <br>  ++: <br> #include &lt;stdio.h&gt; int *bar(int *p) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p; } int* foo(int n) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bar(&amp;n); } int main() { int *p1 = foo(<span class="hljs-number"><span class="hljs-number">1</span></span>); int *p2 = foo(<span class="hljs-number"><span class="hljs-number">2</span></span>); printf(<span class="hljs-string"><span class="hljs-string">"%d, %d\n"</span></span>, *p1, *p2); }</code> <br>  : <br> <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span> <br> <br>  Rust: <br> <code class="rust"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt;(p: &amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> int) -&gt; &amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> int { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>(n: int) -&gt; &amp;int { bar(&amp;n) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> p1 = foo(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> p2 = foo(<span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{}, {}"</span></span>, *p1, *p2); }</code> <br>  : <br> demo:<span class="hljs-number"><span class="hljs-number">5</span></span>:<span class="hljs-number"><span class="hljs-number">10</span></span>: <span class="hljs-number"><span class="hljs-number">5</span></span>:<span class="hljs-number"><span class="hljs-number">11</span></span> error: `n` does not live long enough <br> demo:<span class="hljs-number"><span class="hljs-number">5</span></span> bar(&amp;n) <br> ^ <br> demo:<span class="hljs-number"><span class="hljs-number">4</span></span>:<span class="hljs-number"><span class="hljs-number">24</span></span>: <span class="hljs-number"><span class="hljs-number">6</span></span>:<span class="hljs-number"><span class="hljs-number">2</span></span> note: reference must <span class="hljs-keyword"><span class="hljs-keyword">be</span></span> valid <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> the anonymous lifetime #<span class="hljs-number"><span class="hljs-number">1</span></span> defined on the block at <span class="hljs-number"><span class="hljs-number">4</span></span>:<span class="hljs-number"><span class="hljs-number">23</span></span>... <br> demo:<span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>(n: int) -&gt; &amp;int { <br> demo:<span class="hljs-number"><span class="hljs-number">5</span></span> bar(&amp;n) <br> demo:<span class="hljs-number"><span class="hljs-number">6</span></span> } <br> demo:<span class="hljs-number"><span class="hljs-number">4</span></span>:<span class="hljs-number"><span class="hljs-number">24</span></span>: <span class="hljs-number"><span class="hljs-number">6</span></span>:<span class="hljs-number"><span class="hljs-number">2</span></span> note: ...but borrowed value is only valid <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> the block at <span class="hljs-number"><span class="hljs-number">4</span></span>:<span class="hljs-number"><span class="hljs-number">23</span></span> <br> demo:<span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>(n: int) -&gt; &amp;int { <br> demo:<span class="hljs-number"><span class="hljs-number">5</span></span> bar(&amp;n) <br> demo:<span class="hljs-number"><span class="hljs-number">6</span></span> } <br> <br>   <br> <code class="cpp">#include &lt;stdio.h&gt; int minval(int *A, int n) { int currmin; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;n; i++) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (A[i] &lt; currmin) currmin = A[i]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> currmin; } int main() { int A[] = {<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>}; int min = minval(A,<span class="hljs-number"><span class="hljs-number">3</span></span>); printf(<span class="hljs-string"><span class="hljs-string">"%d\n"</span></span>, min); }</code> <br>   <span class="hljs-number"><span class="hljs-number">0</span></span>  ,     , ,  .       Rust ( - ): <br> <code class="rust"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">minval</span></span></span></span>(A: &amp;[int]) -&gt; int { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> currmin; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> a <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> A.iter() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> *a &lt; currmin { currmin = *a; } } currmin } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> A = [<span class="hljs-number"><span class="hljs-number">1</span></span>i,<span class="hljs-number"><span class="hljs-number">2</span></span>i,<span class="hljs-number"><span class="hljs-number">3</span></span>i]; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> min = minval(A.as_slice()); <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{}"</span></span>, min); }</code> <br>  , : <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> of possibly uninitialized variable: `currmin` <br>   ( )      : <br> <code class="rust"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">minval</span></span></span></span>(A: &amp;[int]) -&gt; int { A.iter().fold(A[<span class="hljs-number"><span class="hljs-number">0</span></span>], |u,&amp;a| { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> a&lt;u {a} <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {u} }) }</code> <br> <br>    <br> <code class="cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span></span>{ int *x; A(int v): x(new int(v)) {} ~A() {delete x;} }; int main() { A a(<span class="hljs-number"><span class="hljs-number">1</span></span>), b=a; }</code> <br> ,    : <br> *** glibc detected *** demo: double free or corruption (fasttop): <span class="hljs-number"><span class="hljs-number">0x0000000000601010</span></span> *** <br> <br>     Rust: <br> <code class="rust"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span></span>{ x: <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;int&gt; } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> A { <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">new</span></span></span></span>(v: int) -&gt; A { A{ x: <span class="hljs-keyword"><span class="hljs-keyword">box</span></span> v } } } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Drop</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> A { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drop</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) {} <span class="hljs-comment"><span class="hljs-comment">// ,     ++ } fn main() { let a = A::new(1); let _b = a; }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">     .   ,     </span></span><code><span class="hljs-comment"><span class="hljs-comment">trait Copy</span></span></code><span class="hljs-comment"><span class="hljs-comment"> . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> Rust       .    </span></span><code><span class="hljs-comment"><span class="hljs-comment">Eq</span></span></code><span class="hljs-comment"><span class="hljs-comment">  </span></span><code><span class="hljs-comment"><span class="hljs-comment">Clone</span></span></code><span class="hljs-comment"><span class="hljs-comment"> ?    </span></span><code><span class="hljs-comment"><span class="hljs-comment">deriving</span></span></code><span class="hljs-comment"><span class="hljs-comment">   : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="rust"><span class="hljs-comment"><span class="hljs-comment">#[deriving(Clone, Eq, Hash, PartialEq, PartialOrd, Ord, Show)] struct A{ x: Box&lt;int&gt; }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">    </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="cpp"><span class="hljs-comment"><span class="hljs-comment">#include &lt;stdio.h&gt; struct X { int a, b; }; void swap_from(X&amp; x, const X&amp; y) { xa = yb; xb = ya; } int main() { X x = {1,2}; swap_from(x,x); printf("%d,%d\n", xa, xb); }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> 2,2 </span></span><br><span class="hljs-comment"><span class="hljs-comment">    ,    cc      .   ,   ,  99  </span></span><a href="http://en.wikipedia.org/wiki/Restrict"><span class="hljs-comment"><span class="hljs-comment">restrict</span></span></a><span class="hljs-comment"><span class="hljs-comment"> ,            :        . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">       Rust: </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="rust"><span class="hljs-comment"><span class="hljs-comment">struct X { pub a: int, pub b: int } fn swap_from(x: &amp;mut X, y: &amp;X) { xa = yb; xb = ya; } fn main() { let mut x = X{a:1, b:2}; swap_from(&amp;mut x, &amp;x); }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">    : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7:24: 7:25 error: cannot borrow `x` as immutable because it is also borrowed as mutable </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7 swap_from(&amp;mut x, &amp;x); </span></span><br><span class="hljs-comment"><span class="hljs-comment"> ^ </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7:20: 7:21 note: previous borrow of `x` occurs here; the mutable borrow prevents subsequent moves, borrows, or modification of `x` until the borrow ends </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7 swap_from(&amp;mut x, &amp;x); </span></span><br><span class="hljs-comment"><span class="hljs-comment"> ^ </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7:26: 7:26 note: previous borrow ends here </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7 swap_from(&amp;mut x, &amp;x); </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  ,             " </span></span><code><span class="hljs-comment"><span class="hljs-comment">&amp;mut</span></span></code><span class="hljs-comment"><span class="hljs-comment"> "  " </span></span><code><span class="hljs-comment"><span class="hljs-comment">&amp;</span></span></code><span class="hljs-comment"><span class="hljs-comment"> " ,   ,          ,   </span></span><code><span class="hljs-comment"><span class="hljs-comment">&amp;mut</span></span></code><span class="hljs-comment"><span class="hljs-comment"> .            .  ,    ,      C99  </span></span><code><span class="hljs-comment"><span class="hljs-comment">restrict</span></span></code><span class="hljs-comment"><span class="hljs-comment">  (Rust  LLVM    ),    . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">   </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="cpp"><span class="hljs-comment"><span class="hljs-comment">#include &lt;vector&gt; int main() { std::vector&lt;int&gt; v; v.push_back(1); v.push_back(2); for(std::vector&lt;int&gt;::const_iterator it=v.begin(); it!=v.end(); ++it) { if (*it &lt; 5) v.push_back(5-*it); } }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">    ,    : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> Segmentation fault (core dumped) </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">    Rust: </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="rust"><span class="hljs-comment"><span class="hljs-comment">fn main() { let mut v: Vec&lt;int&gt; = Vec::new(); v.push(1); v.push(2); for x in v.iter() { if *x &lt; 5 { v.push(5-*x); } } }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">      ,  ,        : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7:13: 7:14 error: cannot borrow `v` as mutable because it is also borrowed as immutable </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7 v.push(5-*x); </span></span><br><span class="hljs-comment"><span class="hljs-comment"> ^ </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:5:14: 5:15 note: previous borrow of `v` occurs here; the immutable borrow prevents subsequent moves or mutable borrows of `v` until the borrow ends </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:5 for x in v.iter() { </span></span><br><span class="hljs-comment"><span class="hljs-comment"> ^ </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:10:2: 10:2 note: previous borrow ends here </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:5 for x in v.iter() { </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:6 if *x &lt; 5 { </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7 v.push(5-*x); </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:8 } </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:9 } </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:10 } </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  Switch </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="cpp"><span class="hljs-comment"><span class="hljs-comment">#include &lt;stdio.h&gt; enum {RED, BLUE, GRAY, UNKNOWN} color = GRAY; int main() { int x; switch(color) { case GRAY: x=1; case RED: case BLUE: x=2; } printf("%d", x); }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">   "2".  Rust          .  ,       ,    </span></span><code><span class="hljs-comment"><span class="hljs-comment">break</span></span></code><span class="hljs-comment"><span class="hljs-comment"> .    Rust   : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="rust"><span class="hljs-comment"><span class="hljs-comment">enum Color {RED, BLUE, GRAY, UNKNOWN} fn main() { let color = GRAY; let x = match color { GRAY =&gt; 1, RED | BLUE =&gt; 2, _ =&gt; 3, }; println!("{}", x); }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">     </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="cpp"><span class="hljs-comment"><span class="hljs-comment">int main() { int pixels = 1; for (int j=0; j&lt;5; j++); pixels++; }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  Rust          . , ,     . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="cpp"><span class="hljs-comment"><span class="hljs-comment">#include &lt;stdio.h&gt; #include &lt;pthread.h&gt; #include &lt;unistd.h&gt; class Resource { int *value; public: Resource(): value(NULL) {} ~Resource() {delete value;} int *acquire() { if (!value) { value = new int(0); } return value; } }; void* function(void *param) { int *value = ((Resource*)param)-&gt;acquire(); printf("resource: %p\n", (void*)value); return value; } int main() { Resource res; for (int i=0; i&lt;5; ++i) { pthread_t pt; pthread_create(&amp;pt, NULL, function, &amp;res); } //sleep(10); printf("done\n"); }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">     : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> done </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7f229c0008c0 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7f22840008c0 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7f228c0008c0 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7f22940008c0 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7f227c0008c0 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">     ,        .      Rust: </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="rust"><span class="hljs-comment"><span class="hljs-comment">struct Resource { value: Option&lt;int&gt;, } impl Resource { pub fn new() -&gt; Resource { Resource{ value: None } } pub fn acquire&lt;'a&gt;(&amp;'a mut self) -&gt; &amp;'a int { if self.value.is_none() { self.value = Some(1); } self.value.get_ref() } } fn main() { let mut res = Resource::new(); for _ in range(0,5) { spawn(proc() { let ptr = res.acquire(); println!("resource {}", ptr) }) } }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  ,            . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:20:23: 20:26 error: cannot borrow immutable captured outer variable in a proc `res` as mutable </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:20 let ptr = res.acquire(); </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">      ,   : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="rust"><span class="hljs-comment"><span class="hljs-comment">extern crate sync; use sync::{Arc, RWLock}; struct Resource { value: Option&lt;Box&lt;int&gt;&gt;, } impl Resource { pub fn new() -&gt; Resource { Resource{ value: None } } pub fn acquire(&amp;mut self) -&gt; *int { if self.value.is_none() { self.value = Some(box 1) } &amp;**self.value.get_ref() as *int } } fn main() { let arc_res = Arc::new(RWLock::new(Resource::new())); for _ in range(0,5) { let child_res = arc_res.clone(); spawn(proc() { let ptr = child_res.write().acquire(); println!("resource: {}", ptr) }) } }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">     </span></span><code><span class="hljs-comment"><span class="hljs-comment">Arc</span></span></code><span class="hljs-comment"><span class="hljs-comment"> ( </span></span><i><span class="hljs-comment"><span class="hljs-comment">Atomically Reference Counted</span></span></i><span class="hljs-comment"><span class="hljs-comment"> -        )  </span></span><code><span class="hljs-comment"><span class="hljs-comment">RWLock</span></span></code><span class="hljs-comment"><span class="hljs-comment"> (   ).   : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7ff4b0010378 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7ff4b0010378 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7ff4b0010378 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7ff4b0010378 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7ff4b0010378 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  ,   ++    .    . Rust        ,    .  ,   ,   .           ,       ( </span></span><a href="http://superwebdeveloper.com/2009/11/25/the-incredible-rate-of-diminishing-returns-of-fixing-software-bugs/"><span class="hljs-comment"><span class="hljs-comment">  </span></span></a><span class="hljs-comment"><span class="hljs-comment"> ). </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">     </span></span><br><span class="hljs-comment"><span class="hljs-comment"> Rust        ,     </span></span><code><span class="hljs-comment"><span class="hljs-comment">unsafe{}</span></span></code><span class="hljs-comment"><span class="hljs-comment"> .   ,     " </span></span><i><span class="hljs-comment"><span class="hljs-comment"> !  ,  .</span></span></i><span class="hljs-comment"><span class="hljs-comment"> ".  ,  ""  (    ,    )    .    ,           ( )  . , ,        </span></span><code><span class="hljs-comment"><span class="hljs-comment">Cell</span></span></code><span class="hljs-comment"><span class="hljs-comment">  </span></span><code><span class="hljs-comment"><span class="hljs-comment">Mutex</span></span></code><span class="hljs-comment"><span class="hljs-comment"> .             ,       (   </span></span><a href="http://en.wikipedia.org/wiki/Test-driven_development"><span class="hljs-comment"><span class="hljs-comment">TDD</span></span></a><span class="hljs-comment"><span class="hljs-comment"> !). </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="https://air.mozilla.org/guaranteeing-memory-safety-in-rust/"><span class="hljs-comment"><span class="hljs-comment">Guaranteeing Memory Safety in Rust (by Niko Matsakis)</span></span></a><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="http://www.techtalkshub.com/rust-safe-systems-programming-fun-fp/"><span class="hljs-comment"><span class="hljs-comment">Rust: Safe Systems Programming with the Fun of FP (by Felix Klock II)</span></span></a><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Keynote"><span class="hljs-comment"><span class="hljs-comment">Lang-NEXT: What ‚Äì if anything ‚Äì have we learned from C++? (by Bjarne Stroustrup)</span></span></a><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Panel-Systems-Programming-Languages-in-2014-and-Beyond"><span class="hljs-comment"><span class="hljs-comment">Lang-NEXT Panel: Systems Programming in 2014 and Beyond</span></span></a></code></code> </pre> <code><code><code><code class="cpp">Box)     ,       (     ).        (std::rc::Rc)    (std::gc::Gc),      (   ). <br> <br></code>      <br>  ++: <br> #include &lt;stdio.h&gt; int *bar(int *p) { return p; } int* foo(int n) { return bar(&amp;n); } int main() { int *p1 = foo(1); int *p2 = foo(2); printf("%d, %d\n", *p1, *p2); }</code> <br>  : <br> 2, 2 <br> <br>  Rust: <br> <code class="rust">fn bar&lt;'a&gt;(p: &amp;'a int) -&gt; &amp;'a int { return p; } fn foo(n: int) -&gt; &amp;int { bar(&amp;n) } fn main() { let p1 = foo(1); let p2 = foo(2); println!("{}, {}", *p1, *p2); }</code> <br>  : <br> demo:5:10: 5:11 error: `n` does not live long enough <br> demo:5 bar(&amp;n) <br> ^ <br> demo:4:24: 6:2 note: reference must be valid for the anonymous lifetime #1 defined on the block at 4:23... <br> demo:4 fn foo(n: int) -&gt; &amp;int { <br> demo:5 bar(&amp;n) <br> demo:6 } <br> demo:4:24: 6:2 note: ...but borrowed value is only valid for the block at 4:23 <br> demo:4 fn foo(n: int) -&gt; &amp;int { <br> demo:5 bar(&amp;n) <br> demo:6 } <br> <br>   <br> <code class="cpp">#include &lt;stdio.h&gt; int minval(int *A, int n) { int currmin; for (int i=0; i&lt;n; i++) if (A[i] &lt; currmin) currmin = A[i]; return currmin; } int main() { int A[] = {1,2,3}; int min = minval(A,3); printf("%d\n", min); }</code> <br>   0  ,     , ,  .       Rust ( - ): <br> <code class="rust">fn minval(A: &amp;[int]) -&gt; int { let mut currmin; for a in A.iter() { if *a &lt; currmin { currmin = *a; } } currmin } fn main() { let A = [1i,2i,3i]; let min = minval(A.as_slice()); println!("{}", min); }</code> <br>  , : use of possibly uninitialized variable: `currmin` <br>   ( )      : <br> <code class="rust">fn minval(A: &amp;[int]) -&gt; int { A.iter().fold(A[0], |u,&amp;a| { if a&lt;u {a} else {u} }) }</code> <br> <br>    <br> <code class="cpp">struct A{ int *x; A(int v): x(new int(v)) {} ~A() {delete x;} }; int main() { A a(1), b=a; }</code> <br> ,    : <br> *** glibc detected *** demo: double free or corruption (fasttop): 0x0000000000601010 *** <br> <br>     Rust: <br> <code class="rust">struct A{ x: Box&lt;int&gt; } impl A { pub fn new(v: int) -&gt; A { A{ x: box v } } } impl Drop for A { fn drop(&amp;mut self) {} // ,     ++ } fn main() { let a = A::new(1); let _b = a; }</code> <br>     .   ,     <code>trait Copy</code> . <br> Rust       .    <code>Eq</code>  <code>Clone</code> ?    <code>deriving</code>   : <br> <code class="rust">#[deriving(Clone, Eq, Hash, PartialEq, PartialOrd, Ord, Show)] struct A{ x: Box&lt;int&gt; }</code> <br> <br>    <br> <code class="cpp">#include &lt;stdio.h&gt; struct X { int a, b; }; void swap_from(X&amp; x, const X&amp; y) { xa = yb; xb = ya; } int main() { X x = {1,2}; swap_from(x,x); printf("%d,%d\n", xa, xb); }</code> <br>  : <br> 2,2 <br>    ,    cc      .   ,   ,  99  <a href="http://en.wikipedia.org/wiki/Restrict">restrict</a> ,            :        . <br> <br>       Rust: <br> <code class="rust">struct X { pub a: int, pub b: int } fn swap_from(x: &amp;mut X, y: &amp;X) { xa = yb; xb = ya; } fn main() { let mut x = X{a:1, b:2}; swap_from(&amp;mut x, &amp;x); }</code> <br>    : <br> demo:7:24: 7:25 error: cannot borrow `x` as immutable because it is also borrowed as mutable <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> ^ <br> demo:7:20: 7:21 note: previous borrow of `x` occurs here; the mutable borrow prevents subsequent moves, borrows, or modification of `x` until the borrow ends <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> ^ <br> demo:7:26: 7:26 note: previous borrow ends here <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> <br>  ,             " <code>&amp;mut</code> "  " <code>&amp;</code> " ,   ,          ,   <code>&amp;mut</code> .            .  ,    ,      C99  <code>restrict</code>  (Rust  LLVM    ),    . <br> <br>   <br> <code class="cpp">#include &lt;vector&gt; int main() { std::vector&lt;int&gt; v; v.push_back(1); v.push_back(2); for(std::vector&lt;int&gt;::const_iterator it=v.begin(); it!=v.end(); ++it) { if (*it &lt; 5) v.push_back(5-*it); } }</code> <br>    ,    : <br> Segmentation fault (core dumped) <br> <br>    Rust: <br> <code class="rust">fn main() { let mut v: Vec&lt;int&gt; = Vec::new(); v.push(1); v.push(2); for x in v.iter() { if *x &lt; 5 { v.push(5-*x); } } }</code> <br>      ,  ,        : <br> demo:7:13: 7:14 error: cannot borrow `v` as mutable because it is also borrowed as immutable <br> demo:7 v.push(5-*x); <br> ^ <br> demo:5:14: 5:15 note: previous borrow of `v` occurs here; the immutable borrow prevents subsequent moves or mutable borrows of `v` until the borrow ends <br> demo:5 for x in v.iter() { <br> ^ <br> demo:10:2: 10:2 note: previous borrow ends here <br> demo:5 for x in v.iter() { <br> demo:6 if *x &lt; 5 { <br> demo:7 v.push(5-*x); <br> demo:8 } <br> demo:9 } <br> demo:10 } <br> <br> <br>  Switch <br> <code class="cpp">#include &lt;stdio.h&gt; enum {RED, BLUE, GRAY, UNKNOWN} color = GRAY; int main() { int x; switch(color) { case GRAY: x=1; case RED: case BLUE: x=2; } printf("%d", x); }</code> <br>   "2".  Rust          .  ,       ,    <code>break</code> .    Rust   : <br> <code class="rust">enum Color {RED, BLUE, GRAY, UNKNOWN} fn main() { let color = GRAY; let x = match color { GRAY =&gt; 1, RED | BLUE =&gt; 2, _ =&gt; 3, }; println!("{}", x); }</code> <br> <br>     <br> <code class="cpp">int main() { int pixels = 1; for (int j=0; j&lt;5; j++); pixels++; }</code> <br>  Rust          . , ,     . <br> <br>  <br> <code class="cpp">#include &lt;stdio.h&gt; #include &lt;pthread.h&gt; #include &lt;unistd.h&gt; class Resource { int *value; public: Resource(): value(NULL) {} ~Resource() {delete value;} int *acquire() { if (!value) { value = new int(0); } return value; } }; void* function(void *param) { int *value = ((Resource*)param)-&gt;acquire(); printf("resource: %p\n", (void*)value); return value; } int main() { Resource res; for (int i=0; i&lt;5; ++i) { pthread_t pt; pthread_create(&amp;pt, NULL, function, &amp;res); } //sleep(10); printf("done\n"); }</code> <br>     : <br> done <br> resource: 0x7f229c0008c0 <br> resource: 0x7f22840008c0 <br> resource: 0x7f228c0008c0 <br> resource: 0x7f22940008c0 <br> resource: 0x7f227c0008c0 <br> <br>     ,        .      Rust: <br> <code class="rust">struct Resource { value: Option&lt;int&gt;, } impl Resource { pub fn new() -&gt; Resource { Resource{ value: None } } pub fn acquire&lt;'a&gt;(&amp;'a mut self) -&gt; &amp;'a int { if self.value.is_none() { self.value = Some(1); } self.value.get_ref() } } fn main() { let mut res = Resource::new(); for _ in range(0,5) { spawn(proc() { let ptr = res.acquire(); println!("resource {}", ptr) }) } }</code> <br>  ,            . <br> demo:20:23: 20:26 error: cannot borrow immutable captured outer variable in a proc `res` as mutable <br> demo:20 let ptr = res.acquire(); <br> <br>      ,   : <br> <code class="rust">extern crate sync; use sync::{Arc, RWLock}; struct Resource { value: Option&lt;Box&lt;int&gt;&gt;, } impl Resource { pub fn new() -&gt; Resource { Resource{ value: None } } pub fn acquire(&amp;mut self) -&gt; *int { if self.value.is_none() { self.value = Some(box 1) } &amp;**self.value.get_ref() as *int } } fn main() { let arc_res = Arc::new(RWLock::new(Resource::new())); for _ in range(0,5) { let child_res = arc_res.clone(); spawn(proc() { let ptr = child_res.write().acquire(); println!("resource: {}", ptr) }) } }</code> <br>     <code>Arc</code> ( <i>Atomically Reference Counted</i> -        )  <code>RWLock</code> (   ).   : <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> <br>  ,   ++    .    . Rust        ,    .  ,   ,   .           ,       ( <a href="http://superwebdeveloper.com/2009/11/25/the-incredible-rate-of-diminishing-returns-of-fixing-software-bugs/">  </a> ). <br> <br>     <br> Rust        ,     <code>unsafe{}</code> .   ,     " <i> !  ,  .</i> ".  ,  ""  (    ,    )    .    ,           ( )  . , ,        <code>Cell</code>  <code>Mutex</code> .             ,       (   <a href="http://en.wikipedia.org/wiki/Test-driven_development">TDD</a> !). <br> <br>  <br> <a href="https://air.mozilla.org/guaranteeing-memory-safety-in-rust/">Guaranteeing Memory Safety in Rust (by Niko Matsakis)</a> <br> <a href="http://www.techtalkshub.com/rust-safe-systems-programming-fun-fp/">Rust: Safe Systems Programming with the Fun of FP (by Felix Klock II)</a> <br> <a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Keynote">Lang-NEXT: What ‚Äì if anything ‚Äì have we learned from C++? (by Bjarne Stroustrup)</a> <br> <a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Panel-Systems-Programming-Languages-in-2014-and-Beyond">Lang-NEXT Panel: Systems Programming in 2014 and Beyond</a></code></code> <blockquote> <code><code><code><code class="cpp">Box)     ,       (     ).        (std::rc::Rc)    (std::gc::Gc),      (   ). <br> <br></code>      <br>  ++: <br> #include &lt;stdio.h&gt; int *bar(int *p) { return p; } int* foo(int n) { return bar(&amp;n); } int main() { int *p1 = foo(1); int *p2 = foo(2); printf("%d, %d\n", *p1, *p2); }</code> <br>  : <br> 2, 2 <br> <br>  Rust: <br> <code class="rust">fn bar&lt;'a&gt;(p: &amp;'a int) -&gt; &amp;'a int { return p; } fn foo(n: int) -&gt; &amp;int { bar(&amp;n) } fn main() { let p1 = foo(1); let p2 = foo(2); println!("{}, {}", *p1, *p2); }</code> <br>  : <br> demo:5:10: 5:11 error: `n` does not live long enough <br> demo:5 bar(&amp;n) <br> ^ <br> demo:4:24: 6:2 note: reference must be valid for the anonymous lifetime #1 defined on the block at 4:23... <br> demo:4 fn foo(n: int) -&gt; &amp;int { <br> demo:5 bar(&amp;n) <br> demo:6 } <br> demo:4:24: 6:2 note: ...but borrowed value is only valid for the block at 4:23 <br> demo:4 fn foo(n: int) -&gt; &amp;int { <br> demo:5 bar(&amp;n) <br> demo:6 } <br> <br>   <br> <code class="cpp">#include &lt;stdio.h&gt; int minval(int *A, int n) { int currmin; for (int i=0; i&lt;n; i++) if (A[i] &lt; currmin) currmin = A[i]; return currmin; } int main() { int A[] = {1,2,3}; int min = minval(A,3); printf("%d\n", min); }</code> <br>   0  ,     , ,  .       Rust ( - ): <br> <code class="rust">fn minval(A: &amp;[int]) -&gt; int { let mut currmin; for a in A.iter() { if *a &lt; currmin { currmin = *a; } } currmin } fn main() { let A = [1i,2i,3i]; let min = minval(A.as_slice()); println!("{}", min); }</code> <br>  , : use of possibly uninitialized variable: `currmin` <br>   ( )      : <br> <code class="rust">fn minval(A: &amp;[int]) -&gt; int { A.iter().fold(A[0], |u,&amp;a| { if a&lt;u {a} else {u} }) }</code> <br> <br>    <br> <code class="cpp">struct A{ int *x; A(int v): x(new int(v)) {} ~A() {delete x;} }; int main() { A a(1), b=a; }</code> <br> ,    : <br> *** glibc detected *** demo: double free or corruption (fasttop): 0x0000000000601010 *** <br> <br>     Rust: <br> <code class="rust">struct A{ x: Box&lt;int&gt; } impl A { pub fn new(v: int) -&gt; A { A{ x: box v } } } impl Drop for A { fn drop(&amp;mut self) {} // ,     ++ } fn main() { let a = A::new(1); let _b = a; }</code> <br>     .   ,     <code>trait Copy</code> . <br> Rust       .    <code>Eq</code>  <code>Clone</code> ?    <code>deriving</code>   : <br> <code class="rust">#[deriving(Clone, Eq, Hash, PartialEq, PartialOrd, Ord, Show)] struct A{ x: Box&lt;int&gt; }</code> <br> <br>    <br> <code class="cpp">#include &lt;stdio.h&gt; struct X { int a, b; }; void swap_from(X&amp; x, const X&amp; y) { xa = yb; xb = ya; } int main() { X x = {1,2}; swap_from(x,x); printf("%d,%d\n", xa, xb); }</code> <br>  : <br> 2,2 <br>    ,    cc      .   ,   ,  99  <a href="http://en.wikipedia.org/wiki/Restrict">restrict</a> ,            :        . <br> <br>       Rust: <br> <code class="rust">struct X { pub a: int, pub b: int } fn swap_from(x: &amp;mut X, y: &amp;X) { xa = yb; xb = ya; } fn main() { let mut x = X{a:1, b:2}; swap_from(&amp;mut x, &amp;x); }</code> <br>    : <br> demo:7:24: 7:25 error: cannot borrow `x` as immutable because it is also borrowed as mutable <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> ^ <br> demo:7:20: 7:21 note: previous borrow of `x` occurs here; the mutable borrow prevents subsequent moves, borrows, or modification of `x` until the borrow ends <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> ^ <br> demo:7:26: 7:26 note: previous borrow ends here <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> <br>  ,             " <code>&amp;mut</code> "  " <code>&amp;</code> " ,   ,          ,   <code>&amp;mut</code> .            .  ,    ,      C99  <code>restrict</code>  (Rust  LLVM    ),    . <br> <br>   <br> <code class="cpp">#include &lt;vector&gt; int main() { std::vector&lt;int&gt; v; v.push_back(1); v.push_back(2); for(std::vector&lt;int&gt;::const_iterator it=v.begin(); it!=v.end(); ++it) { if (*it &lt; 5) v.push_back(5-*it); } }</code> <br>    ,    : <br> Segmentation fault (core dumped) <br> <br>    Rust: <br> <code class="rust">fn main() { let mut v: Vec&lt;int&gt; = Vec::new(); v.push(1); v.push(2); for x in v.iter() { if *x &lt; 5 { v.push(5-*x); } } }</code> <br>      ,  ,        : <br> demo:7:13: 7:14 error: cannot borrow `v` as mutable because it is also borrowed as immutable <br> demo:7 v.push(5-*x); <br> ^ <br> demo:5:14: 5:15 note: previous borrow of `v` occurs here; the immutable borrow prevents subsequent moves or mutable borrows of `v` until the borrow ends <br> demo:5 for x in v.iter() { <br> ^ <br> demo:10:2: 10:2 note: previous borrow ends here <br> demo:5 for x in v.iter() { <br> demo:6 if *x &lt; 5 { <br> demo:7 v.push(5-*x); <br> demo:8 } <br> demo:9 } <br> demo:10 } <br> <br> <br>  Switch <br> <code class="cpp">#include &lt;stdio.h&gt; enum {RED, BLUE, GRAY, UNKNOWN} color = GRAY; int main() { int x; switch(color) { case GRAY: x=1; case RED: case BLUE: x=2; } printf("%d", x); }</code> <br>   "2".  Rust          .  ,       ,    <code>break</code> .    Rust   : <br> <code class="rust">enum Color {RED, BLUE, GRAY, UNKNOWN} fn main() { let color = GRAY; let x = match color { GRAY =&gt; 1, RED | BLUE =&gt; 2, _ =&gt; 3, }; println!("{}", x); }</code> <br> <br>     <br> <code class="cpp">int main() { int pixels = 1; for (int j=0; j&lt;5; j++); pixels++; }</code> <br>  Rust          . , ,     . <br> <br>  <br> <code class="cpp">#include &lt;stdio.h&gt; #include &lt;pthread.h&gt; #include &lt;unistd.h&gt; class Resource { int *value; public: Resource(): value(NULL) {} ~Resource() {delete value;} int *acquire() { if (!value) { value = new int(0); } return value; } }; void* function(void *param) { int *value = ((Resource*)param)-&gt;acquire(); printf("resource: %p\n", (void*)value); return value; } int main() { Resource res; for (int i=0; i&lt;5; ++i) { pthread_t pt; pthread_create(&amp;pt, NULL, function, &amp;res); } //sleep(10); printf("done\n"); }</code> <br>     : <br> done <br> resource: 0x7f229c0008c0 <br> resource: 0x7f22840008c0 <br> resource: 0x7f228c0008c0 <br> resource: 0x7f22940008c0 <br> resource: 0x7f227c0008c0 <br> <br>     ,        .      Rust: <br> <code class="rust">struct Resource { value: Option&lt;int&gt;, } impl Resource { pub fn new() -&gt; Resource { Resource{ value: None } } pub fn acquire&lt;'a&gt;(&amp;'a mut self) -&gt; &amp;'a int { if self.value.is_none() { self.value = Some(1); } self.value.get_ref() } } fn main() { let mut res = Resource::new(); for _ in range(0,5) { spawn(proc() { let ptr = res.acquire(); println!("resource {}", ptr) }) } }</code> <br>  ,            . <br> demo:20:23: 20:26 error: cannot borrow immutable captured outer variable in a proc `res` as mutable <br> demo:20 let ptr = res.acquire(); <br> <br>      ,   : <br> <code class="rust">extern crate sync; use sync::{Arc, RWLock}; struct Resource { value: Option&lt;Box&lt;int&gt;&gt;, } impl Resource { pub fn new() -&gt; Resource { Resource{ value: None } } pub fn acquire(&amp;mut self) -&gt; *int { if self.value.is_none() { self.value = Some(box 1) } &amp;**self.value.get_ref() as *int } } fn main() { let arc_res = Arc::new(RWLock::new(Resource::new())); for _ in range(0,5) { let child_res = arc_res.clone(); spawn(proc() { let ptr = child_res.write().acquire(); println!("resource: {}", ptr) }) } }</code> <br>     <code>Arc</code> ( <i>Atomically Reference Counted</i> -        )  <code>RWLock</code> (   ).   : <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> <br>  ,   ++    .    . Rust        ,    .  ,   ,   .           ,       ( <a href="http://superwebdeveloper.com/2009/11/25/the-incredible-rate-of-diminishing-returns-of-fixing-software-bugs/">  </a> ). <br> <br>     <br> Rust        ,     <code>unsafe{}</code> .   ,     " <i> !  ,  .</i> ".  ,  ""  (    ,    )    .    ,           ( )  . , ,        <code>Cell</code>  <code>Mutex</code> .             ,       (   <a href="http://en.wikipedia.org/wiki/Test-driven_development">TDD</a> !). <br> <br>  <br> <a href="https://air.mozilla.org/guaranteeing-memory-safety-in-rust/">Guaranteeing Memory Safety in Rust (by Niko Matsakis)</a> <br> <a href="http://www.techtalkshub.com/rust-safe-systems-programming-fun-fp/">Rust: Safe Systems Programming with the Fun of FP (by Felix Klock II)</a> <br> <a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Keynote">Lang-NEXT: What ‚Äì if anything ‚Äì have we learned from C++? (by Bjarne Stroustrup)</a> <br> <a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Panel-Systems-Programming-Languages-in-2014-and-Beyond">Lang-NEXT Panel: Systems Programming in 2014 and Beyond</a></code></code> </blockquote> <code><code><code><code class="cpp">Box)     ,       (     ).        (std::rc::Rc)    (std::gc::Gc),      (   ). <br> <br></code>      <br>  ++: <br> #include &lt;stdio.h&gt; int *bar(int *p) { return p; } int* foo(int n) { return bar(&amp;n); } int main() { int *p1 = foo(1); int *p2 = foo(2); printf("%d, %d\n", *p1, *p2); }</code> <br>  : <br> 2, 2 <br> <br>  Rust: <br> <code class="rust">fn bar&lt;'a&gt;(p: &amp;'a int) -&gt; &amp;'a int { return p; } fn foo(n: int) -&gt; &amp;int { bar(&amp;n) } fn main() { let p1 = foo(1); let p2 = foo(2); println!("{}, {}", *p1, *p2); }</code> <br>  : <br> demo:5:10: 5:11 error: `n` does not live long enough <br> demo:5 bar(&amp;n) <br> ^ <br> demo:4:24: 6:2 note: reference must be valid for the anonymous lifetime #1 defined on the block at 4:23... <br> demo:4 fn foo(n: int) -&gt; &amp;int { <br> demo:5 bar(&amp;n) <br> demo:6 } <br> demo:4:24: 6:2 note: ...but borrowed value is only valid for the block at 4:23 <br> demo:4 fn foo(n: int) -&gt; &amp;int { <br> demo:5 bar(&amp;n) <br> demo:6 } <br> <br>   <br> <code class="cpp">#include &lt;stdio.h&gt; int minval(int *A, int n) { int currmin; for (int i=0; i&lt;n; i++) if (A[i] &lt; currmin) currmin = A[i]; return currmin; } int main() { int A[] = {1,2,3}; int min = minval(A,3); printf("%d\n", min); }</code> <br>   0  ,     , ,  .       Rust ( - ): <br> <code class="rust">fn minval(A: &amp;[int]) -&gt; int { let mut currmin; for a in A.iter() { if *a &lt; currmin { currmin = *a; } } currmin } fn main() { let A = [1i,2i,3i]; let min = minval(A.as_slice()); println!("{}", min); }</code> <br>  , : use of possibly uninitialized variable: `currmin` <br>   ( )      : <br> <code class="rust">fn minval(A: &amp;[int]) -&gt; int { A.iter().fold(A[0], |u,&amp;a| { if a&lt;u {a} else {u} }) }</code> <br> <br>    <br> <code class="cpp">struct A{ int *x; A(int v): x(new int(v)) {} ~A() {delete x;} }; int main() { A a(1), b=a; }</code> <br> ,    : <br> *** glibc detected *** demo: double free or corruption (fasttop): 0x0000000000601010 *** <br> <br>     Rust: <br> <code class="rust">struct A{ x: Box&lt;int&gt; } impl A { pub fn new(v: int) -&gt; A { A{ x: box v } } } impl Drop for A { fn drop(&amp;mut self) {} // ,     ++ } fn main() { let a = A::new(1); let _b = a; }</code> <br>     .   ,     <code>trait Copy</code> . <br> Rust       .    <code>Eq</code>  <code>Clone</code> ?    <code>deriving</code>   : <br> <code class="rust">#[deriving(Clone, Eq, Hash, PartialEq, PartialOrd, Ord, Show)] struct A{ x: Box&lt;int&gt; }</code> <br> <br>    <br> <code class="cpp">#include &lt;stdio.h&gt; struct X { int a, b; }; void swap_from(X&amp; x, const X&amp; y) { xa = yb; xb = ya; } int main() { X x = {1,2}; swap_from(x,x); printf("%d,%d\n", xa, xb); }</code> <br>  : <br> 2,2 <br>    ,    cc      .   ,   ,  99  <a href="http://en.wikipedia.org/wiki/Restrict">restrict</a> ,            :        . <br> <br>       Rust: <br> <code class="rust">struct X { pub a: int, pub b: int } fn swap_from(x: &amp;mut X, y: &amp;X) { xa = yb; xb = ya; } fn main() { let mut x = X{a:1, b:2}; swap_from(&amp;mut x, &amp;x); }</code> <br>    : <br> demo:7:24: 7:25 error: cannot borrow `x` as immutable because it is also borrowed as mutable <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> ^ <br> demo:7:20: 7:21 note: previous borrow of `x` occurs here; the mutable borrow prevents subsequent moves, borrows, or modification of `x` until the borrow ends <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> ^ <br> demo:7:26: 7:26 note: previous borrow ends here <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> <br>  ,             " <code>&amp;mut</code> "  " <code>&amp;</code> " ,   ,          ,   <code>&amp;mut</code> .            .  ,    ,      C99  <code>restrict</code>  (Rust  LLVM    ),    . <br> <br>   <br> <code class="cpp">#include &lt;vector&gt; int main() { std::vector&lt;int&gt; v; v.push_back(1); v.push_back(2); for(std::vector&lt;int&gt;::const_iterator it=v.begin(); it!=v.end(); ++it) { if (*it &lt; 5) v.push_back(5-*it); } }</code> <br>    ,    : <br> Segmentation fault (core dumped) <br> <br>    Rust: <br> <code class="rust">fn main() { let mut v: Vec&lt;int&gt; = Vec::new(); v.push(1); v.push(2); for x in v.iter() { if *x &lt; 5 { v.push(5-*x); } } }</code> <br>      ,  ,        : <br> demo:7:13: 7:14 error: cannot borrow `v` as mutable because it is also borrowed as immutable <br> demo:7 v.push(5-*x); <br> ^ <br> demo:5:14: 5:15 note: previous borrow of `v` occurs here; the immutable borrow prevents subsequent moves or mutable borrows of `v` until the borrow ends <br> demo:5 for x in v.iter() { <br> ^ <br> demo:10:2: 10:2 note: previous borrow ends here <br> demo:5 for x in v.iter() { <br> demo:6 if *x &lt; 5 { <br> demo:7 v.push(5-*x); <br> demo:8 } <br> demo:9 } <br> demo:10 } <br> <br> <br>  Switch <br> <code class="cpp">#include &lt;stdio.h&gt; enum {RED, BLUE, GRAY, UNKNOWN} color = GRAY; int main() { int x; switch(color) { case GRAY: x=1; case RED: case BLUE: x=2; } printf("%d", x); }</code> <br>   "2".  Rust          .  ,       ,    <code>break</code> .    Rust   : <br> <code class="rust">enum Color {RED, BLUE, GRAY, UNKNOWN} fn main() { let color = GRAY; let x = match color { GRAY =&gt; 1, RED | BLUE =&gt; 2, _ =&gt; 3, }; println!("{}", x); }</code> <br> <br>     <br> <code class="cpp">int main() { int pixels = 1; for (int j=0; j&lt;5; j++); pixels++; }</code> <br>  Rust          . , ,     . <br> <br>  <br> <code class="cpp">#include &lt;stdio.h&gt; #include &lt;pthread.h&gt; #include &lt;unistd.h&gt; class Resource { int *value; public: Resource(): value(NULL) {} ~Resource() {delete value;} int *acquire() { if (!value) { value = new int(0); } return value; } }; void* function(void *param) { int *value = ((Resource*)param)-&gt;acquire(); printf("resource: %p\n", (void*)value); return value; } int main() { Resource res; for (int i=0; i&lt;5; ++i) { pthread_t pt; pthread_create(&amp;pt, NULL, function, &amp;res); } //sleep(10); printf("done\n"); }</code> <br>     : <br> done <br> resource: 0x7f229c0008c0 <br> resource: 0x7f22840008c0 <br> resource: 0x7f228c0008c0 <br> resource: 0x7f22940008c0 <br> resource: 0x7f227c0008c0 <br> <br>     ,        .      Rust: <br> <code class="rust">struct Resource { value: Option&lt;int&gt;, } impl Resource { pub fn new() -&gt; Resource { Resource{ value: None } } pub fn acquire&lt;'a&gt;(&amp;'a mut self) -&gt; &amp;'a int { if self.value.is_none() { self.value = Some(1); } self.value.get_ref() } } fn main() { let mut res = Resource::new(); for _ in range(0,5) { spawn(proc() { let ptr = res.acquire(); println!("resource {}", ptr) }) } }</code> <br>  ,            . <br> demo:20:23: 20:26 error: cannot borrow immutable captured outer variable in a proc `res` as mutable <br> demo:20 let ptr = res.acquire(); <br> <br>      ,   : <br> <code class="rust">extern crate sync; use sync::{Arc, RWLock}; struct Resource { value: Option&lt;Box&lt;int&gt;&gt;, } impl Resource { pub fn new() -&gt; Resource { Resource{ value: None } } pub fn acquire(&amp;mut self) -&gt; *int { if self.value.is_none() { self.value = Some(box 1) } &amp;**self.value.get_ref() as *int } } fn main() { let arc_res = Arc::new(RWLock::new(Resource::new())); for _ in range(0,5) { let child_res = arc_res.clone(); spawn(proc() { let ptr = child_res.write().acquire(); println!("resource: {}", ptr) }) } }</code> <br>     <code>Arc</code> ( <i>Atomically Reference Counted</i> -        )  <code>RWLock</code> (   ).   : <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> <br>  ,   ++    .    . Rust        ,    .  ,   ,   .           ,       ( <a href="http://superwebdeveloper.com/2009/11/25/the-incredible-rate-of-diminishing-returns-of-fixing-software-bugs/">  </a> ). <br> <br>     <br> Rust        ,     <code>unsafe{}</code> .   ,     " <i> !  ,  .</i> ".  ,  ""  (    ,    )    .    ,           ( )  . , ,        <code>Cell</code>  <code>Mutex</code> .             ,       (   <a href="http://en.wikipedia.org/wiki/Test-driven_development">TDD</a> !). <br> <br>  <br> <a href="https://air.mozilla.org/guaranteeing-memory-safety-in-rust/">Guaranteeing Memory Safety in Rust (by Niko Matsakis)</a> <br> <a href="http://www.techtalkshub.com/rust-safe-systems-programming-fun-fp/">Rust: Safe Systems Programming with the Fun of FP (by Felix Klock II)</a> <br> <a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Keynote">Lang-NEXT: What ‚Äì if anything ‚Äì have we learned from C++? (by Bjarne Stroustrup)</a> <br> <a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Panel-Systems-Programming-Languages-in-2014-and-Beyond">Lang-NEXT Panel: Systems Programming in 2014 and Beyond</a></code></code> <pre> <code class="hljs rust"><code><code><code class="cpp"><span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>)     ,       (     ).        (std::rc::Rc)    (std::gc::Gc),      (   ). <br> <br></code>      <br>  ++: <br> #include &lt;stdio.h&gt; int *bar(int *p) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p; } int* foo(int n) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bar(&amp;n); } int main() { int *p1 = foo(<span class="hljs-number"><span class="hljs-number">1</span></span>); int *p2 = foo(<span class="hljs-number"><span class="hljs-number">2</span></span>); printf(<span class="hljs-string"><span class="hljs-string">"%d, %d\n"</span></span>, *p1, *p2); }</code> <br>  : <br> <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span> <br> <br>  Rust: <br> <code class="rust"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt;(p: &amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> int) -&gt; &amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> int { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>(n: int) -&gt; &amp;int { bar(&amp;n) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> p1 = foo(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> p2 = foo(<span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{}, {}"</span></span>, *p1, *p2); }</code> <br>  : <br> demo:<span class="hljs-number"><span class="hljs-number">5</span></span>:<span class="hljs-number"><span class="hljs-number">10</span></span>: <span class="hljs-number"><span class="hljs-number">5</span></span>:<span class="hljs-number"><span class="hljs-number">11</span></span> error: `n` does not live long enough <br> demo:<span class="hljs-number"><span class="hljs-number">5</span></span> bar(&amp;n) <br> ^ <br> demo:<span class="hljs-number"><span class="hljs-number">4</span></span>:<span class="hljs-number"><span class="hljs-number">24</span></span>: <span class="hljs-number"><span class="hljs-number">6</span></span>:<span class="hljs-number"><span class="hljs-number">2</span></span> note: reference must <span class="hljs-keyword"><span class="hljs-keyword">be</span></span> valid <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> the anonymous lifetime #<span class="hljs-number"><span class="hljs-number">1</span></span> defined on the block at <span class="hljs-number"><span class="hljs-number">4</span></span>:<span class="hljs-number"><span class="hljs-number">23</span></span>... <br> demo:<span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>(n: int) -&gt; &amp;int { <br> demo:<span class="hljs-number"><span class="hljs-number">5</span></span> bar(&amp;n) <br> demo:<span class="hljs-number"><span class="hljs-number">6</span></span> } <br> demo:<span class="hljs-number"><span class="hljs-number">4</span></span>:<span class="hljs-number"><span class="hljs-number">24</span></span>: <span class="hljs-number"><span class="hljs-number">6</span></span>:<span class="hljs-number"><span class="hljs-number">2</span></span> note: ...but borrowed value is only valid <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> the block at <span class="hljs-number"><span class="hljs-number">4</span></span>:<span class="hljs-number"><span class="hljs-number">23</span></span> <br> demo:<span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>(n: int) -&gt; &amp;int { <br> demo:<span class="hljs-number"><span class="hljs-number">5</span></span> bar(&amp;n) <br> demo:<span class="hljs-number"><span class="hljs-number">6</span></span> } <br> <br>   <br> <code class="cpp">#include &lt;stdio.h&gt; int minval(int *A, int n) { int currmin; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;n; i++) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (A[i] &lt; currmin) currmin = A[i]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> currmin; } int main() { int A[] = {<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>}; int min = minval(A,<span class="hljs-number"><span class="hljs-number">3</span></span>); printf(<span class="hljs-string"><span class="hljs-string">"%d\n"</span></span>, min); }</code> <br>   <span class="hljs-number"><span class="hljs-number">0</span></span>  ,     , ,  .       Rust ( - ): <br> <code class="rust"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">minval</span></span></span></span>(A: &amp;[int]) -&gt; int { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> currmin; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> a <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> A.iter() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> *a &lt; currmin { currmin = *a; } } currmin } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> A = [<span class="hljs-number"><span class="hljs-number">1</span></span>i,<span class="hljs-number"><span class="hljs-number">2</span></span>i,<span class="hljs-number"><span class="hljs-number">3</span></span>i]; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> min = minval(A.as_slice()); <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{}"</span></span>, min); }</code> <br>  , : <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> of possibly uninitialized variable: `currmin` <br>   ( )      : <br> <code class="rust"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">minval</span></span></span></span>(A: &amp;[int]) -&gt; int { A.iter().fold(A[<span class="hljs-number"><span class="hljs-number">0</span></span>], |u,&amp;a| { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> a&lt;u {a} <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {u} }) }</code> <br> <br>    <br> <code class="cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span></span>{ int *x; A(int v): x(new int(v)) {} ~A() {delete x;} }; int main() { A a(<span class="hljs-number"><span class="hljs-number">1</span></span>), b=a; }</code> <br> ,    : <br> *** glibc detected *** demo: double free or corruption (fasttop): <span class="hljs-number"><span class="hljs-number">0x0000000000601010</span></span> *** <br> <br>     Rust: <br> <code class="rust"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span></span>{ x: <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;int&gt; } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> A { <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">new</span></span></span></span>(v: int) -&gt; A { A{ x: <span class="hljs-keyword"><span class="hljs-keyword">box</span></span> v } } } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Drop</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> A { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drop</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) {} <span class="hljs-comment"><span class="hljs-comment">// ,     ++ } fn main() { let a = A::new(1); let _b = a; }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">     .   ,     </span></span><code><span class="hljs-comment"><span class="hljs-comment">trait Copy</span></span></code><span class="hljs-comment"><span class="hljs-comment"> . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> Rust       .    </span></span><code><span class="hljs-comment"><span class="hljs-comment">Eq</span></span></code><span class="hljs-comment"><span class="hljs-comment">  </span></span><code><span class="hljs-comment"><span class="hljs-comment">Clone</span></span></code><span class="hljs-comment"><span class="hljs-comment"> ?    </span></span><code><span class="hljs-comment"><span class="hljs-comment">deriving</span></span></code><span class="hljs-comment"><span class="hljs-comment">   : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="rust"><span class="hljs-comment"><span class="hljs-comment">#[deriving(Clone, Eq, Hash, PartialEq, PartialOrd, Ord, Show)] struct A{ x: Box&lt;int&gt; }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">    </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="cpp"><span class="hljs-comment"><span class="hljs-comment">#include &lt;stdio.h&gt; struct X { int a, b; }; void swap_from(X&amp; x, const X&amp; y) { xa = yb; xb = ya; } int main() { X x = {1,2}; swap_from(x,x); printf("%d,%d\n", xa, xb); }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> 2,2 </span></span><br><span class="hljs-comment"><span class="hljs-comment">    ,    cc      .   ,   ,  99  </span></span><a href="http://en.wikipedia.org/wiki/Restrict"><span class="hljs-comment"><span class="hljs-comment">restrict</span></span></a><span class="hljs-comment"><span class="hljs-comment"> ,            :        . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">       Rust: </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="rust"><span class="hljs-comment"><span class="hljs-comment">struct X { pub a: int, pub b: int } fn swap_from(x: &amp;mut X, y: &amp;X) { xa = yb; xb = ya; } fn main() { let mut x = X{a:1, b:2}; swap_from(&amp;mut x, &amp;x); }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">    : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7:24: 7:25 error: cannot borrow `x` as immutable because it is also borrowed as mutable </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7 swap_from(&amp;mut x, &amp;x); </span></span><br><span class="hljs-comment"><span class="hljs-comment"> ^ </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7:20: 7:21 note: previous borrow of `x` occurs here; the mutable borrow prevents subsequent moves, borrows, or modification of `x` until the borrow ends </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7 swap_from(&amp;mut x, &amp;x); </span></span><br><span class="hljs-comment"><span class="hljs-comment"> ^ </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7:26: 7:26 note: previous borrow ends here </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7 swap_from(&amp;mut x, &amp;x); </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  ,             " </span></span><code><span class="hljs-comment"><span class="hljs-comment">&amp;mut</span></span></code><span class="hljs-comment"><span class="hljs-comment"> "  " </span></span><code><span class="hljs-comment"><span class="hljs-comment">&amp;</span></span></code><span class="hljs-comment"><span class="hljs-comment"> " ,   ,          ,   </span></span><code><span class="hljs-comment"><span class="hljs-comment">&amp;mut</span></span></code><span class="hljs-comment"><span class="hljs-comment"> .            .  ,    ,      C99  </span></span><code><span class="hljs-comment"><span class="hljs-comment">restrict</span></span></code><span class="hljs-comment"><span class="hljs-comment">  (Rust  LLVM    ),    . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">   </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="cpp"><span class="hljs-comment"><span class="hljs-comment">#include &lt;vector&gt; int main() { std::vector&lt;int&gt; v; v.push_back(1); v.push_back(2); for(std::vector&lt;int&gt;::const_iterator it=v.begin(); it!=v.end(); ++it) { if (*it &lt; 5) v.push_back(5-*it); } }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">    ,    : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> Segmentation fault (core dumped) </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">    Rust: </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="rust"><span class="hljs-comment"><span class="hljs-comment">fn main() { let mut v: Vec&lt;int&gt; = Vec::new(); v.push(1); v.push(2); for x in v.iter() { if *x &lt; 5 { v.push(5-*x); } } }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">      ,  ,        : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7:13: 7:14 error: cannot borrow `v` as mutable because it is also borrowed as immutable </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7 v.push(5-*x); </span></span><br><span class="hljs-comment"><span class="hljs-comment"> ^ </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:5:14: 5:15 note: previous borrow of `v` occurs here; the immutable borrow prevents subsequent moves or mutable borrows of `v` until the borrow ends </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:5 for x in v.iter() { </span></span><br><span class="hljs-comment"><span class="hljs-comment"> ^ </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:10:2: 10:2 note: previous borrow ends here </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:5 for x in v.iter() { </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:6 if *x &lt; 5 { </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7 v.push(5-*x); </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:8 } </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:9 } </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:10 } </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  Switch </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="cpp"><span class="hljs-comment"><span class="hljs-comment">#include &lt;stdio.h&gt; enum {RED, BLUE, GRAY, UNKNOWN} color = GRAY; int main() { int x; switch(color) { case GRAY: x=1; case RED: case BLUE: x=2; } printf("%d", x); }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">   "2".  Rust          .  ,       ,    </span></span><code><span class="hljs-comment"><span class="hljs-comment">break</span></span></code><span class="hljs-comment"><span class="hljs-comment"> .    Rust   : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="rust"><span class="hljs-comment"><span class="hljs-comment">enum Color {RED, BLUE, GRAY, UNKNOWN} fn main() { let color = GRAY; let x = match color { GRAY =&gt; 1, RED | BLUE =&gt; 2, _ =&gt; 3, }; println!("{}", x); }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">     </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="cpp"><span class="hljs-comment"><span class="hljs-comment">int main() { int pixels = 1; for (int j=0; j&lt;5; j++); pixels++; }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  Rust          . , ,     . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="cpp"><span class="hljs-comment"><span class="hljs-comment">#include &lt;stdio.h&gt; #include &lt;pthread.h&gt; #include &lt;unistd.h&gt; class Resource { int *value; public: Resource(): value(NULL) {} ~Resource() {delete value;} int *acquire() { if (!value) { value = new int(0); } return value; } }; void* function(void *param) { int *value = ((Resource*)param)-&gt;acquire(); printf("resource: %p\n", (void*)value); return value; } int main() { Resource res; for (int i=0; i&lt;5; ++i) { pthread_t pt; pthread_create(&amp;pt, NULL, function, &amp;res); } //sleep(10); printf("done\n"); }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">     : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> done </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7f229c0008c0 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7f22840008c0 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7f228c0008c0 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7f22940008c0 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7f227c0008c0 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">     ,        .      Rust: </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="rust"><span class="hljs-comment"><span class="hljs-comment">struct Resource { value: Option&lt;int&gt;, } impl Resource { pub fn new() -&gt; Resource { Resource{ value: None } } pub fn acquire&lt;'a&gt;(&amp;'a mut self) -&gt; &amp;'a int { if self.value.is_none() { self.value = Some(1); } self.value.get_ref() } } fn main() { let mut res = Resource::new(); for _ in range(0,5) { spawn(proc() { let ptr = res.acquire(); println!("resource {}", ptr) }) } }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  ,            . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:20:23: 20:26 error: cannot borrow immutable captured outer variable in a proc `res` as mutable </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:20 let ptr = res.acquire(); </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">      ,   : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="rust"><span class="hljs-comment"><span class="hljs-comment">extern crate sync; use sync::{Arc, RWLock}; struct Resource { value: Option&lt;Box&lt;int&gt;&gt;, } impl Resource { pub fn new() -&gt; Resource { Resource{ value: None } } pub fn acquire(&amp;mut self) -&gt; *int { if self.value.is_none() { self.value = Some(box 1) } &amp;**self.value.get_ref() as *int } } fn main() { let arc_res = Arc::new(RWLock::new(Resource::new())); for _ in range(0,5) { let child_res = arc_res.clone(); spawn(proc() { let ptr = child_res.write().acquire(); println!("resource: {}", ptr) }) } }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">     </span></span><code><span class="hljs-comment"><span class="hljs-comment">Arc</span></span></code><span class="hljs-comment"><span class="hljs-comment"> ( </span></span><i><span class="hljs-comment"><span class="hljs-comment">Atomically Reference Counted</span></span></i><span class="hljs-comment"><span class="hljs-comment"> -        )  </span></span><code><span class="hljs-comment"><span class="hljs-comment">RWLock</span></span></code><span class="hljs-comment"><span class="hljs-comment"> (   ).   : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7ff4b0010378 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7ff4b0010378 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7ff4b0010378 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7ff4b0010378 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7ff4b0010378 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  ,   ++    .    . Rust        ,    .  ,   ,   .           ,       ( </span></span><a href="http://superwebdeveloper.com/2009/11/25/the-incredible-rate-of-diminishing-returns-of-fixing-software-bugs/"><span class="hljs-comment"><span class="hljs-comment">  </span></span></a><span class="hljs-comment"><span class="hljs-comment"> ). </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">     </span></span><br><span class="hljs-comment"><span class="hljs-comment"> Rust        ,     </span></span><code><span class="hljs-comment"><span class="hljs-comment">unsafe{}</span></span></code><span class="hljs-comment"><span class="hljs-comment"> .   ,     " </span></span><i><span class="hljs-comment"><span class="hljs-comment"> !  ,  .</span></span></i><span class="hljs-comment"><span class="hljs-comment"> ".  ,  ""  (    ,    )    .    ,           ( )  . , ,        </span></span><code><span class="hljs-comment"><span class="hljs-comment">Cell</span></span></code><span class="hljs-comment"><span class="hljs-comment">  </span></span><code><span class="hljs-comment"><span class="hljs-comment">Mutex</span></span></code><span class="hljs-comment"><span class="hljs-comment"> .             ,       (   </span></span><a href="http://en.wikipedia.org/wiki/Test-driven_development"><span class="hljs-comment"><span class="hljs-comment">TDD</span></span></a><span class="hljs-comment"><span class="hljs-comment"> !). </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="https://air.mozilla.org/guaranteeing-memory-safety-in-rust/"><span class="hljs-comment"><span class="hljs-comment">Guaranteeing Memory Safety in Rust (by Niko Matsakis)</span></span></a><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="http://www.techtalkshub.com/rust-safe-systems-programming-fun-fp/"><span class="hljs-comment"><span class="hljs-comment">Rust: Safe Systems Programming with the Fun of FP (by Felix Klock II)</span></span></a><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Keynote"><span class="hljs-comment"><span class="hljs-comment">Lang-NEXT: What ‚Äì if anything ‚Äì have we learned from C++? (by Bjarne Stroustrup)</span></span></a><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Panel-Systems-Programming-Languages-in-2014-and-Beyond"><span class="hljs-comment"><span class="hljs-comment">Lang-NEXT Panel: Systems Programming in 2014 and Beyond</span></span></a></code></code> </pre> <code><code><code><code class="cpp">Box)     ,       (     ).        (std::rc::Rc)    (std::gc::Gc),      (   ). <br> <br></code>      <br>  ++: <br> #include &lt;stdio.h&gt; int *bar(int *p) { return p; } int* foo(int n) { return bar(&amp;n); } int main() { int *p1 = foo(1); int *p2 = foo(2); printf("%d, %d\n", *p1, *p2); }</code> <br>  : <br> 2, 2 <br> <br>  Rust: <br> <code class="rust">fn bar&lt;'a&gt;(p: &amp;'a int) -&gt; &amp;'a int { return p; } fn foo(n: int) -&gt; &amp;int { bar(&amp;n) } fn main() { let p1 = foo(1); let p2 = foo(2); println!("{}, {}", *p1, *p2); }</code> <br>  : <br> demo:5:10: 5:11 error: `n` does not live long enough <br> demo:5 bar(&amp;n) <br> ^ <br> demo:4:24: 6:2 note: reference must be valid for the anonymous lifetime #1 defined on the block at 4:23... <br> demo:4 fn foo(n: int) -&gt; &amp;int { <br> demo:5 bar(&amp;n) <br> demo:6 } <br> demo:4:24: 6:2 note: ...but borrowed value is only valid for the block at 4:23 <br> demo:4 fn foo(n: int) -&gt; &amp;int { <br> demo:5 bar(&amp;n) <br> demo:6 } <br> <br>   <br> <code class="cpp">#include &lt;stdio.h&gt; int minval(int *A, int n) { int currmin; for (int i=0; i&lt;n; i++) if (A[i] &lt; currmin) currmin = A[i]; return currmin; } int main() { int A[] = {1,2,3}; int min = minval(A,3); printf("%d\n", min); }</code> <br>   0  ,     , ,  .       Rust ( - ): <br> <code class="rust">fn minval(A: &amp;[int]) -&gt; int { let mut currmin; for a in A.iter() { if *a &lt; currmin { currmin = *a; } } currmin } fn main() { let A = [1i,2i,3i]; let min = minval(A.as_slice()); println!("{}", min); }</code> <br>  , : use of possibly uninitialized variable: `currmin` <br>   ( )      : <br> <code class="rust">fn minval(A: &amp;[int]) -&gt; int { A.iter().fold(A[0], |u,&amp;a| { if a&lt;u {a} else {u} }) }</code> <br> <br>    <br> <code class="cpp">struct A{ int *x; A(int v): x(new int(v)) {} ~A() {delete x;} }; int main() { A a(1), b=a; }</code> <br> ,    : <br> *** glibc detected *** demo: double free or corruption (fasttop): 0x0000000000601010 *** <br> <br>     Rust: <br> <code class="rust">struct A{ x: Box&lt;int&gt; } impl A { pub fn new(v: int) -&gt; A { A{ x: box v } } } impl Drop for A { fn drop(&amp;mut self) {} // ,     ++ } fn main() { let a = A::new(1); let _b = a; }</code> <br>     .   ,     <code>trait Copy</code> . <br> Rust       .    <code>Eq</code>  <code>Clone</code> ?    <code>deriving</code>   : <br> <code class="rust">#[deriving(Clone, Eq, Hash, PartialEq, PartialOrd, Ord, Show)] struct A{ x: Box&lt;int&gt; }</code> <br> <br>    <br> <code class="cpp">#include &lt;stdio.h&gt; struct X { int a, b; }; void swap_from(X&amp; x, const X&amp; y) { xa = yb; xb = ya; } int main() { X x = {1,2}; swap_from(x,x); printf("%d,%d\n", xa, xb); }</code> <br>  : <br> 2,2 <br>    ,    cc      .   ,   ,  99  <a href="http://en.wikipedia.org/wiki/Restrict">restrict</a> ,            :        . <br> <br>       Rust: <br> <code class="rust">struct X { pub a: int, pub b: int } fn swap_from(x: &amp;mut X, y: &amp;X) { xa = yb; xb = ya; } fn main() { let mut x = X{a:1, b:2}; swap_from(&amp;mut x, &amp;x); }</code> <br>    : <br> demo:7:24: 7:25 error: cannot borrow `x` as immutable because it is also borrowed as mutable <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> ^ <br> demo:7:20: 7:21 note: previous borrow of `x` occurs here; the mutable borrow prevents subsequent moves, borrows, or modification of `x` until the borrow ends <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> ^ <br> demo:7:26: 7:26 note: previous borrow ends here <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> <br>  ,             " <code>&amp;mut</code> "  " <code>&amp;</code> " ,   ,          ,   <code>&amp;mut</code> .            .  ,    ,      C99  <code>restrict</code>  (Rust  LLVM    ),    . <br> <br>   <br> <code class="cpp">#include &lt;vector&gt; int main() { std::vector&lt;int&gt; v; v.push_back(1); v.push_back(2); for(std::vector&lt;int&gt;::const_iterator it=v.begin(); it!=v.end(); ++it) { if (*it &lt; 5) v.push_back(5-*it); } }</code> <br>    ,    : <br> Segmentation fault (core dumped) <br> <br>    Rust: <br> <code class="rust">fn main() { let mut v: Vec&lt;int&gt; = Vec::new(); v.push(1); v.push(2); for x in v.iter() { if *x &lt; 5 { v.push(5-*x); } } }</code> <br>      ,  ,        : <br> demo:7:13: 7:14 error: cannot borrow `v` as mutable because it is also borrowed as immutable <br> demo:7 v.push(5-*x); <br> ^ <br> demo:5:14: 5:15 note: previous borrow of `v` occurs here; the immutable borrow prevents subsequent moves or mutable borrows of `v` until the borrow ends <br> demo:5 for x in v.iter() { <br> ^ <br> demo:10:2: 10:2 note: previous borrow ends here <br> demo:5 for x in v.iter() { <br> demo:6 if *x &lt; 5 { <br> demo:7 v.push(5-*x); <br> demo:8 } <br> demo:9 } <br> demo:10 } <br> <br> <br>  Switch <br> <code class="cpp">#include &lt;stdio.h&gt; enum {RED, BLUE, GRAY, UNKNOWN} color = GRAY; int main() { int x; switch(color) { case GRAY: x=1; case RED: case BLUE: x=2; } printf("%d", x); }</code> <br>   "2".  Rust          .  ,       ,    <code>break</code> .    Rust   : <br> <code class="rust">enum Color {RED, BLUE, GRAY, UNKNOWN} fn main() { let color = GRAY; let x = match color { GRAY =&gt; 1, RED | BLUE =&gt; 2, _ =&gt; 3, }; println!("{}", x); }</code> <br> <br>     <br> <code class="cpp">int main() { int pixels = 1; for (int j=0; j&lt;5; j++); pixels++; }</code> <br>  Rust          . , ,     . <br> <br>  <br> <code class="cpp">#include &lt;stdio.h&gt; #include &lt;pthread.h&gt; #include &lt;unistd.h&gt; class Resource { int *value; public: Resource(): value(NULL) {} ~Resource() {delete value;} int *acquire() { if (!value) { value = new int(0); } return value; } }; void* function(void *param) { int *value = ((Resource*)param)-&gt;acquire(); printf("resource: %p\n", (void*)value); return value; } int main() { Resource res; for (int i=0; i&lt;5; ++i) { pthread_t pt; pthread_create(&amp;pt, NULL, function, &amp;res); } //sleep(10); printf("done\n"); }</code> <br>     : <br> done <br> resource: 0x7f229c0008c0 <br> resource: 0x7f22840008c0 <br> resource: 0x7f228c0008c0 <br> resource: 0x7f22940008c0 <br> resource: 0x7f227c0008c0 <br> <br>     ,        .      Rust: <br> <code class="rust">struct Resource { value: Option&lt;int&gt;, } impl Resource { pub fn new() -&gt; Resource { Resource{ value: None } } pub fn acquire&lt;'a&gt;(&amp;'a mut self) -&gt; &amp;'a int { if self.value.is_none() { self.value = Some(1); } self.value.get_ref() } } fn main() { let mut res = Resource::new(); for _ in range(0,5) { spawn(proc() { let ptr = res.acquire(); println!("resource {}", ptr) }) } }</code> <br>  ,            . <br> demo:20:23: 20:26 error: cannot borrow immutable captured outer variable in a proc `res` as mutable <br> demo:20 let ptr = res.acquire(); <br> <br>      ,   : <br> <code class="rust">extern crate sync; use sync::{Arc, RWLock}; struct Resource { value: Option&lt;Box&lt;int&gt;&gt;, } impl Resource { pub fn new() -&gt; Resource { Resource{ value: None } } pub fn acquire(&amp;mut self) -&gt; *int { if self.value.is_none() { self.value = Some(box 1) } &amp;**self.value.get_ref() as *int } } fn main() { let arc_res = Arc::new(RWLock::new(Resource::new())); for _ in range(0,5) { let child_res = arc_res.clone(); spawn(proc() { let ptr = child_res.write().acquire(); println!("resource: {}", ptr) }) } }</code> <br>     <code>Arc</code> ( <i>Atomically Reference Counted</i> -        )  <code>RWLock</code> (   ).   : <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> <br>  ,   ++    .    . Rust        ,    .  ,   ,   .           ,       ( <a href="http://superwebdeveloper.com/2009/11/25/the-incredible-rate-of-diminishing-returns-of-fixing-software-bugs/">  </a> ). <br> <br>     <br> Rust        ,     <code>unsafe{}</code> .   ,     " <i> !  ,  .</i> ".  ,  ""  (    ,    )    .    ,           ( )  . , ,        <code>Cell</code>  <code>Mutex</code> .             ,       (   <a href="http://en.wikipedia.org/wiki/Test-driven_development">TDD</a> !). <br> <br>  <br> <a href="https://air.mozilla.org/guaranteeing-memory-safety-in-rust/">Guaranteeing Memory Safety in Rust (by Niko Matsakis)</a> <br> <a href="http://www.techtalkshub.com/rust-safe-systems-programming-fun-fp/">Rust: Safe Systems Programming with the Fun of FP (by Felix Klock II)</a> <br> <a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Keynote">Lang-NEXT: What ‚Äì if anything ‚Äì have we learned from C++? (by Bjarne Stroustrup)</a> <br> <a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Panel-Systems-Programming-Languages-in-2014-and-Beyond">Lang-NEXT Panel: Systems Programming in 2014 and Beyond</a></code></code> <h4> <code><code><code><code class="cpp">Box)     ,       (     ).        (std::rc::Rc)    (std::gc::Gc),      (   ). <br> <br></code>      <br>  ++: <br> #include &lt;stdio.h&gt; int *bar(int *p) { return p; } int* foo(int n) { return bar(&amp;n); } int main() { int *p1 = foo(1); int *p2 = foo(2); printf("%d, %d\n", *p1, *p2); }</code> <br>  : <br> 2, 2 <br> <br>  Rust: <br> <code class="rust">fn bar&lt;'a&gt;(p: &amp;'a int) -&gt; &amp;'a int { return p; } fn foo(n: int) -&gt; &amp;int { bar(&amp;n) } fn main() { let p1 = foo(1); let p2 = foo(2); println!("{}, {}", *p1, *p2); }</code> <br>  : <br> demo:5:10: 5:11 error: `n` does not live long enough <br> demo:5 bar(&amp;n) <br> ^ <br> demo:4:24: 6:2 note: reference must be valid for the anonymous lifetime #1 defined on the block at 4:23... <br> demo:4 fn foo(n: int) -&gt; &amp;int { <br> demo:5 bar(&amp;n) <br> demo:6 } <br> demo:4:24: 6:2 note: ...but borrowed value is only valid for the block at 4:23 <br> demo:4 fn foo(n: int) -&gt; &amp;int { <br> demo:5 bar(&amp;n) <br> demo:6 } <br> <br>   <br> <code class="cpp">#include &lt;stdio.h&gt; int minval(int *A, int n) { int currmin; for (int i=0; i&lt;n; i++) if (A[i] &lt; currmin) currmin = A[i]; return currmin; } int main() { int A[] = {1,2,3}; int min = minval(A,3); printf("%d\n", min); }</code> <br>   0  ,     , ,  .       Rust ( - ): <br> <code class="rust">fn minval(A: &amp;[int]) -&gt; int { let mut currmin; for a in A.iter() { if *a &lt; currmin { currmin = *a; } } currmin } fn main() { let A = [1i,2i,3i]; let min = minval(A.as_slice()); println!("{}", min); }</code> <br>  , : use of possibly uninitialized variable: `currmin` <br>   ( )      : <br> <code class="rust">fn minval(A: &amp;[int]) -&gt; int { A.iter().fold(A[0], |u,&amp;a| { if a&lt;u {a} else {u} }) }</code> <br> <br>    <br> <code class="cpp">struct A{ int *x; A(int v): x(new int(v)) {} ~A() {delete x;} }; int main() { A a(1), b=a; }</code> <br> ,    : <br> *** glibc detected *** demo: double free or corruption (fasttop): 0x0000000000601010 *** <br> <br>     Rust: <br> <code class="rust">struct A{ x: Box&lt;int&gt; } impl A { pub fn new(v: int) -&gt; A { A{ x: box v } } } impl Drop for A { fn drop(&amp;mut self) {} // ,     ++ } fn main() { let a = A::new(1); let _b = a; }</code> <br>     .   ,     <code>trait Copy</code> . <br> Rust       .    <code>Eq</code>  <code>Clone</code> ?    <code>deriving</code>   : <br> <code class="rust">#[deriving(Clone, Eq, Hash, PartialEq, PartialOrd, Ord, Show)] struct A{ x: Box&lt;int&gt; }</code> <br> <br>    <br> <code class="cpp">#include &lt;stdio.h&gt; struct X { int a, b; }; void swap_from(X&amp; x, const X&amp; y) { xa = yb; xb = ya; } int main() { X x = {1,2}; swap_from(x,x); printf("%d,%d\n", xa, xb); }</code> <br>  : <br> 2,2 <br>    ,    cc      .   ,   ,  99  <a href="http://en.wikipedia.org/wiki/Restrict">restrict</a> ,            :        . <br> <br>       Rust: <br> <code class="rust">struct X { pub a: int, pub b: int } fn swap_from(x: &amp;mut X, y: &amp;X) { xa = yb; xb = ya; } fn main() { let mut x = X{a:1, b:2}; swap_from(&amp;mut x, &amp;x); }</code> <br>    : <br> demo:7:24: 7:25 error: cannot borrow `x` as immutable because it is also borrowed as mutable <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> ^ <br> demo:7:20: 7:21 note: previous borrow of `x` occurs here; the mutable borrow prevents subsequent moves, borrows, or modification of `x` until the borrow ends <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> ^ <br> demo:7:26: 7:26 note: previous borrow ends here <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> <br>  ,             " <code>&amp;mut</code> "  " <code>&amp;</code> " ,   ,          ,   <code>&amp;mut</code> .            .  ,    ,      C99  <code>restrict</code>  (Rust  LLVM    ),    . <br> <br>   <br> <code class="cpp">#include &lt;vector&gt; int main() { std::vector&lt;int&gt; v; v.push_back(1); v.push_back(2); for(std::vector&lt;int&gt;::const_iterator it=v.begin(); it!=v.end(); ++it) { if (*it &lt; 5) v.push_back(5-*it); } }</code> <br>    ,    : <br> Segmentation fault (core dumped) <br> <br>    Rust: <br> <code class="rust">fn main() { let mut v: Vec&lt;int&gt; = Vec::new(); v.push(1); v.push(2); for x in v.iter() { if *x &lt; 5 { v.push(5-*x); } } }</code> <br>      ,  ,        : <br> demo:7:13: 7:14 error: cannot borrow `v` as mutable because it is also borrowed as immutable <br> demo:7 v.push(5-*x); <br> ^ <br> demo:5:14: 5:15 note: previous borrow of `v` occurs here; the immutable borrow prevents subsequent moves or mutable borrows of `v` until the borrow ends <br> demo:5 for x in v.iter() { <br> ^ <br> demo:10:2: 10:2 note: previous borrow ends here <br> demo:5 for x in v.iter() { <br> demo:6 if *x &lt; 5 { <br> demo:7 v.push(5-*x); <br> demo:8 } <br> demo:9 } <br> demo:10 } <br> <br> <br>  Switch <br> <code class="cpp">#include &lt;stdio.h&gt; enum {RED, BLUE, GRAY, UNKNOWN} color = GRAY; int main() { int x; switch(color) { case GRAY: x=1; case RED: case BLUE: x=2; } printf("%d", x); }</code> <br>   "2".  Rust          .  ,       ,    <code>break</code> .    Rust   : <br> <code class="rust">enum Color {RED, BLUE, GRAY, UNKNOWN} fn main() { let color = GRAY; let x = match color { GRAY =&gt; 1, RED | BLUE =&gt; 2, _ =&gt; 3, }; println!("{}", x); }</code> <br> <br>     <br> <code class="cpp">int main() { int pixels = 1; for (int j=0; j&lt;5; j++); pixels++; }</code> <br>  Rust          . , ,     . <br> <br>  <br> <code class="cpp">#include &lt;stdio.h&gt; #include &lt;pthread.h&gt; #include &lt;unistd.h&gt; class Resource { int *value; public: Resource(): value(NULL) {} ~Resource() {delete value;} int *acquire() { if (!value) { value = new int(0); } return value; } }; void* function(void *param) { int *value = ((Resource*)param)-&gt;acquire(); printf("resource: %p\n", (void*)value); return value; } int main() { Resource res; for (int i=0; i&lt;5; ++i) { pthread_t pt; pthread_create(&amp;pt, NULL, function, &amp;res); } //sleep(10); printf("done\n"); }</code> <br>     : <br> done <br> resource: 0x7f229c0008c0 <br> resource: 0x7f22840008c0 <br> resource: 0x7f228c0008c0 <br> resource: 0x7f22940008c0 <br> resource: 0x7f227c0008c0 <br> <br>     ,        .      Rust: <br> <code class="rust">struct Resource { value: Option&lt;int&gt;, } impl Resource { pub fn new() -&gt; Resource { Resource{ value: None } } pub fn acquire&lt;'a&gt;(&amp;'a mut self) -&gt; &amp;'a int { if self.value.is_none() { self.value = Some(1); } self.value.get_ref() } } fn main() { let mut res = Resource::new(); for _ in range(0,5) { spawn(proc() { let ptr = res.acquire(); println!("resource {}", ptr) }) } }</code> <br>  ,            . <br> demo:20:23: 20:26 error: cannot borrow immutable captured outer variable in a proc `res` as mutable <br> demo:20 let ptr = res.acquire(); <br> <br>      ,   : <br> <code class="rust">extern crate sync; use sync::{Arc, RWLock}; struct Resource { value: Option&lt;Box&lt;int&gt;&gt;, } impl Resource { pub fn new() -&gt; Resource { Resource{ value: None } } pub fn acquire(&amp;mut self) -&gt; *int { if self.value.is_none() { self.value = Some(box 1) } &amp;**self.value.get_ref() as *int } } fn main() { let arc_res = Arc::new(RWLock::new(Resource::new())); for _ in range(0,5) { let child_res = arc_res.clone(); spawn(proc() { let ptr = child_res.write().acquire(); println!("resource: {}", ptr) }) } }</code> <br>     <code>Arc</code> ( <i>Atomically Reference Counted</i> -        )  <code>RWLock</code> (   ).   : <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> <br>  ,   ++    .    . Rust        ,    .  ,   ,   .           ,       ( <a href="http://superwebdeveloper.com/2009/11/25/the-incredible-rate-of-diminishing-returns-of-fixing-software-bugs/">  </a> ). <br> <br>     <br> Rust        ,     <code>unsafe{}</code> .   ,     " <i> !  ,  .</i> ".  ,  ""  (    ,    )    .    ,           ( )  . , ,        <code>Cell</code>  <code>Mutex</code> .             ,       (   <a href="http://en.wikipedia.org/wiki/Test-driven_development">TDD</a> !). <br> <br>  <br> <a href="https://air.mozilla.org/guaranteeing-memory-safety-in-rust/">Guaranteeing Memory Safety in Rust (by Niko Matsakis)</a> <br> <a href="http://www.techtalkshub.com/rust-safe-systems-programming-fun-fp/">Rust: Safe Systems Programming with the Fun of FP (by Felix Klock II)</a> <br> <a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Keynote">Lang-NEXT: What ‚Äì if anything ‚Äì have we learned from C++? (by Bjarne Stroustrup)</a> <br> <a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Panel-Systems-Programming-Languages-in-2014-and-Beyond">Lang-NEXT Panel: Systems Programming in 2014 and Beyond</a></code></code> </h4> <code><code><code><code class="cpp">Box)     ,       (     ).        (std::rc::Rc)    (std::gc::Gc),      (   ). <br> <br></code>      <br>  ++: <br> #include &lt;stdio.h&gt; int *bar(int *p) { return p; } int* foo(int n) { return bar(&amp;n); } int main() { int *p1 = foo(1); int *p2 = foo(2); printf("%d, %d\n", *p1, *p2); }</code> <br>  : <br> 2, 2 <br> <br>  Rust: <br> <code class="rust">fn bar&lt;'a&gt;(p: &amp;'a int) -&gt; &amp;'a int { return p; } fn foo(n: int) -&gt; &amp;int { bar(&amp;n) } fn main() { let p1 = foo(1); let p2 = foo(2); println!("{}, {}", *p1, *p2); }</code> <br>  : <br> demo:5:10: 5:11 error: `n` does not live long enough <br> demo:5 bar(&amp;n) <br> ^ <br> demo:4:24: 6:2 note: reference must be valid for the anonymous lifetime #1 defined on the block at 4:23... <br> demo:4 fn foo(n: int) -&gt; &amp;int { <br> demo:5 bar(&amp;n) <br> demo:6 } <br> demo:4:24: 6:2 note: ...but borrowed value is only valid for the block at 4:23 <br> demo:4 fn foo(n: int) -&gt; &amp;int { <br> demo:5 bar(&amp;n) <br> demo:6 } <br> <br>   <br> <code class="cpp">#include &lt;stdio.h&gt; int minval(int *A, int n) { int currmin; for (int i=0; i&lt;n; i++) if (A[i] &lt; currmin) currmin = A[i]; return currmin; } int main() { int A[] = {1,2,3}; int min = minval(A,3); printf("%d\n", min); }</code> <br>   0  ,     , ,  .       Rust ( - ): <br> <code class="rust">fn minval(A: &amp;[int]) -&gt; int { let mut currmin; for a in A.iter() { if *a &lt; currmin { currmin = *a; } } currmin } fn main() { let A = [1i,2i,3i]; let min = minval(A.as_slice()); println!("{}", min); }</code> <br>  , : use of possibly uninitialized variable: `currmin` <br>   ( )      : <br> <code class="rust">fn minval(A: &amp;[int]) -&gt; int { A.iter().fold(A[0], |u,&amp;a| { if a&lt;u {a} else {u} }) }</code> <br> <br>    <br> <code class="cpp">struct A{ int *x; A(int v): x(new int(v)) {} ~A() {delete x;} }; int main() { A a(1), b=a; }</code> <br> ,    : <br> *** glibc detected *** demo: double free or corruption (fasttop): 0x0000000000601010 *** <br> <br>     Rust: <br> <code class="rust">struct A{ x: Box&lt;int&gt; } impl A { pub fn new(v: int) -&gt; A { A{ x: box v } } } impl Drop for A { fn drop(&amp;mut self) {} // ,     ++ } fn main() { let a = A::new(1); let _b = a; }</code> <br>     .   ,     <code>trait Copy</code> . <br> Rust       .    <code>Eq</code>  <code>Clone</code> ?    <code>deriving</code>   : <br> <code class="rust">#[deriving(Clone, Eq, Hash, PartialEq, PartialOrd, Ord, Show)] struct A{ x: Box&lt;int&gt; }</code> <br> <br>    <br> <code class="cpp">#include &lt;stdio.h&gt; struct X { int a, b; }; void swap_from(X&amp; x, const X&amp; y) { xa = yb; xb = ya; } int main() { X x = {1,2}; swap_from(x,x); printf("%d,%d\n", xa, xb); }</code> <br>  : <br> 2,2 <br>    ,    cc      .   ,   ,  99  <a href="http://en.wikipedia.org/wiki/Restrict">restrict</a> ,            :        . <br> <br>       Rust: <br> <code class="rust">struct X { pub a: int, pub b: int } fn swap_from(x: &amp;mut X, y: &amp;X) { xa = yb; xb = ya; } fn main() { let mut x = X{a:1, b:2}; swap_from(&amp;mut x, &amp;x); }</code> <br>    : <br> demo:7:24: 7:25 error: cannot borrow `x` as immutable because it is also borrowed as mutable <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> ^ <br> demo:7:20: 7:21 note: previous borrow of `x` occurs here; the mutable borrow prevents subsequent moves, borrows, or modification of `x` until the borrow ends <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> ^ <br> demo:7:26: 7:26 note: previous borrow ends here <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> <br>  ,             " <code>&amp;mut</code> "  " <code>&amp;</code> " ,   ,          ,   <code>&amp;mut</code> .            .  ,    ,      C99  <code>restrict</code>  (Rust  LLVM    ),    . <br> <br>   <br> <code class="cpp">#include &lt;vector&gt; int main() { std::vector&lt;int&gt; v; v.push_back(1); v.push_back(2); for(std::vector&lt;int&gt;::const_iterator it=v.begin(); it!=v.end(); ++it) { if (*it &lt; 5) v.push_back(5-*it); } }</code> <br>    ,    : <br> Segmentation fault (core dumped) <br> <br>    Rust: <br> <code class="rust">fn main() { let mut v: Vec&lt;int&gt; = Vec::new(); v.push(1); v.push(2); for x in v.iter() { if *x &lt; 5 { v.push(5-*x); } } }</code> <br>      ,  ,        : <br> demo:7:13: 7:14 error: cannot borrow `v` as mutable because it is also borrowed as immutable <br> demo:7 v.push(5-*x); <br> ^ <br> demo:5:14: 5:15 note: previous borrow of `v` occurs here; the immutable borrow prevents subsequent moves or mutable borrows of `v` until the borrow ends <br> demo:5 for x in v.iter() { <br> ^ <br> demo:10:2: 10:2 note: previous borrow ends here <br> demo:5 for x in v.iter() { <br> demo:6 if *x &lt; 5 { <br> demo:7 v.push(5-*x); <br> demo:8 } <br> demo:9 } <br> demo:10 } <br> <br> <br>  Switch <br> <code class="cpp">#include &lt;stdio.h&gt; enum {RED, BLUE, GRAY, UNKNOWN} color = GRAY; int main() { int x; switch(color) { case GRAY: x=1; case RED: case BLUE: x=2; } printf("%d", x); }</code> <br>   "2".  Rust          .  ,       ,    <code>break</code> .    Rust   : <br> <code class="rust">enum Color {RED, BLUE, GRAY, UNKNOWN} fn main() { let color = GRAY; let x = match color { GRAY =&gt; 1, RED | BLUE =&gt; 2, _ =&gt; 3, }; println!("{}", x); }</code> <br> <br>     <br> <code class="cpp">int main() { int pixels = 1; for (int j=0; j&lt;5; j++); pixels++; }</code> <br>  Rust          . , ,     . <br> <br>  <br> <code class="cpp">#include &lt;stdio.h&gt; #include &lt;pthread.h&gt; #include &lt;unistd.h&gt; class Resource { int *value; public: Resource(): value(NULL) {} ~Resource() {delete value;} int *acquire() { if (!value) { value = new int(0); } return value; } }; void* function(void *param) { int *value = ((Resource*)param)-&gt;acquire(); printf("resource: %p\n", (void*)value); return value; } int main() { Resource res; for (int i=0; i&lt;5; ++i) { pthread_t pt; pthread_create(&amp;pt, NULL, function, &amp;res); } //sleep(10); printf("done\n"); }</code> <br>     : <br> done <br> resource: 0x7f229c0008c0 <br> resource: 0x7f22840008c0 <br> resource: 0x7f228c0008c0 <br> resource: 0x7f22940008c0 <br> resource: 0x7f227c0008c0 <br> <br>     ,        .      Rust: <br> <code class="rust">struct Resource { value: Option&lt;int&gt;, } impl Resource { pub fn new() -&gt; Resource { Resource{ value: None } } pub fn acquire&lt;'a&gt;(&amp;'a mut self) -&gt; &amp;'a int { if self.value.is_none() { self.value = Some(1); } self.value.get_ref() } } fn main() { let mut res = Resource::new(); for _ in range(0,5) { spawn(proc() { let ptr = res.acquire(); println!("resource {}", ptr) }) } }</code> <br>  ,            . <br> demo:20:23: 20:26 error: cannot borrow immutable captured outer variable in a proc `res` as mutable <br> demo:20 let ptr = res.acquire(); <br> <br>      ,   : <br> <code class="rust">extern crate sync; use sync::{Arc, RWLock}; struct Resource { value: Option&lt;Box&lt;int&gt;&gt;, } impl Resource { pub fn new() -&gt; Resource { Resource{ value: None } } pub fn acquire(&amp;mut self) -&gt; *int { if self.value.is_none() { self.value = Some(box 1) } &amp;**self.value.get_ref() as *int } } fn main() { let arc_res = Arc::new(RWLock::new(Resource::new())); for _ in range(0,5) { let child_res = arc_res.clone(); spawn(proc() { let ptr = child_res.write().acquire(); println!("resource: {}", ptr) }) } }</code> <br>     <code>Arc</code> ( <i>Atomically Reference Counted</i> -        )  <code>RWLock</code> (   ).   : <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> <br>  ,   ++    .    . Rust        ,    .  ,   ,   .           ,       ( <a href="http://superwebdeveloper.com/2009/11/25/the-incredible-rate-of-diminishing-returns-of-fixing-software-bugs/">  </a> ). <br> <br>     <br> Rust        ,     <code>unsafe{}</code> .   ,     " <i> !  ,  .</i> ".  ,  ""  (    ,    )    .    ,           ( )  . , ,        <code>Cell</code>  <code>Mutex</code> .             ,       (   <a href="http://en.wikipedia.org/wiki/Test-driven_development">TDD</a> !). <br> <br>  <br> <a href="https://air.mozilla.org/guaranteeing-memory-safety-in-rust/">Guaranteeing Memory Safety in Rust (by Niko Matsakis)</a> <br> <a href="http://www.techtalkshub.com/rust-safe-systems-programming-fun-fp/">Rust: Safe Systems Programming with the Fun of FP (by Felix Klock II)</a> <br> <a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Keynote">Lang-NEXT: What ‚Äì if anything ‚Äì have we learned from C++? (by Bjarne Stroustrup)</a> <br> <a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Panel-Systems-Programming-Languages-in-2014-and-Beyond">Lang-NEXT Panel: Systems Programming in 2014 and Beyond</a></code></code> <pre> <code class="hljs rust"><code><code><code class="cpp"><span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>)     ,       (     ).        (std::rc::Rc)    (std::gc::Gc),      (   ). <br> <br></code>      <br>  ++: <br> #include &lt;stdio.h&gt; int *bar(int *p) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p; } int* foo(int n) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bar(&amp;n); } int main() { int *p1 = foo(<span class="hljs-number"><span class="hljs-number">1</span></span>); int *p2 = foo(<span class="hljs-number"><span class="hljs-number">2</span></span>); printf(<span class="hljs-string"><span class="hljs-string">"%d, %d\n"</span></span>, *p1, *p2); }</code> <br>  : <br> <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span> <br> <br>  Rust: <br> <code class="rust"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt;(p: &amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> int) -&gt; &amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> int { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>(n: int) -&gt; &amp;int { bar(&amp;n) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> p1 = foo(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> p2 = foo(<span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{}, {}"</span></span>, *p1, *p2); }</code> <br>  : <br> demo:<span class="hljs-number"><span class="hljs-number">5</span></span>:<span class="hljs-number"><span class="hljs-number">10</span></span>: <span class="hljs-number"><span class="hljs-number">5</span></span>:<span class="hljs-number"><span class="hljs-number">11</span></span> error: `n` does not live long enough <br> demo:<span class="hljs-number"><span class="hljs-number">5</span></span> bar(&amp;n) <br> ^ <br> demo:<span class="hljs-number"><span class="hljs-number">4</span></span>:<span class="hljs-number"><span class="hljs-number">24</span></span>: <span class="hljs-number"><span class="hljs-number">6</span></span>:<span class="hljs-number"><span class="hljs-number">2</span></span> note: reference must <span class="hljs-keyword"><span class="hljs-keyword">be</span></span> valid <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> the anonymous lifetime #<span class="hljs-number"><span class="hljs-number">1</span></span> defined on the block at <span class="hljs-number"><span class="hljs-number">4</span></span>:<span class="hljs-number"><span class="hljs-number">23</span></span>... <br> demo:<span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>(n: int) -&gt; &amp;int { <br> demo:<span class="hljs-number"><span class="hljs-number">5</span></span> bar(&amp;n) <br> demo:<span class="hljs-number"><span class="hljs-number">6</span></span> } <br> demo:<span class="hljs-number"><span class="hljs-number">4</span></span>:<span class="hljs-number"><span class="hljs-number">24</span></span>: <span class="hljs-number"><span class="hljs-number">6</span></span>:<span class="hljs-number"><span class="hljs-number">2</span></span> note: ...but borrowed value is only valid <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> the block at <span class="hljs-number"><span class="hljs-number">4</span></span>:<span class="hljs-number"><span class="hljs-number">23</span></span> <br> demo:<span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>(n: int) -&gt; &amp;int { <br> demo:<span class="hljs-number"><span class="hljs-number">5</span></span> bar(&amp;n) <br> demo:<span class="hljs-number"><span class="hljs-number">6</span></span> } <br> <br>   <br> <code class="cpp">#include &lt;stdio.h&gt; int minval(int *A, int n) { int currmin; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;n; i++) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (A[i] &lt; currmin) currmin = A[i]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> currmin; } int main() { int A[] = {<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>}; int min = minval(A,<span class="hljs-number"><span class="hljs-number">3</span></span>); printf(<span class="hljs-string"><span class="hljs-string">"%d\n"</span></span>, min); }</code> <br>   <span class="hljs-number"><span class="hljs-number">0</span></span>  ,     , ,  .       Rust ( - ): <br> <code class="rust"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">minval</span></span></span></span>(A: &amp;[int]) -&gt; int { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> currmin; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> a <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> A.iter() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> *a &lt; currmin { currmin = *a; } } currmin } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> A = [<span class="hljs-number"><span class="hljs-number">1</span></span>i,<span class="hljs-number"><span class="hljs-number">2</span></span>i,<span class="hljs-number"><span class="hljs-number">3</span></span>i]; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> min = minval(A.as_slice()); <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{}"</span></span>, min); }</code> <br>  , : <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> of possibly uninitialized variable: `currmin` <br>   ( )      : <br> <code class="rust"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">minval</span></span></span></span>(A: &amp;[int]) -&gt; int { A.iter().fold(A[<span class="hljs-number"><span class="hljs-number">0</span></span>], |u,&amp;a| { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> a&lt;u {a} <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {u} }) }</code> <br> <br>    <br> <code class="cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span></span>{ int *x; A(int v): x(new int(v)) {} ~A() {delete x;} }; int main() { A a(<span class="hljs-number"><span class="hljs-number">1</span></span>), b=a; }</code> <br> ,    : <br> *** glibc detected *** demo: double free or corruption (fasttop): <span class="hljs-number"><span class="hljs-number">0x0000000000601010</span></span> *** <br> <br>     Rust: <br> <code class="rust"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span></span>{ x: <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;int&gt; } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> A { <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">new</span></span></span></span>(v: int) -&gt; A { A{ x: <span class="hljs-keyword"><span class="hljs-keyword">box</span></span> v } } } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Drop</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> A { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drop</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) {} <span class="hljs-comment"><span class="hljs-comment">// ,     ++ } fn main() { let a = A::new(1); let _b = a; }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">     .   ,     </span></span><code><span class="hljs-comment"><span class="hljs-comment">trait Copy</span></span></code><span class="hljs-comment"><span class="hljs-comment"> . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> Rust       .    </span></span><code><span class="hljs-comment"><span class="hljs-comment">Eq</span></span></code><span class="hljs-comment"><span class="hljs-comment">  </span></span><code><span class="hljs-comment"><span class="hljs-comment">Clone</span></span></code><span class="hljs-comment"><span class="hljs-comment"> ?    </span></span><code><span class="hljs-comment"><span class="hljs-comment">deriving</span></span></code><span class="hljs-comment"><span class="hljs-comment">   : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="rust"><span class="hljs-comment"><span class="hljs-comment">#[deriving(Clone, Eq, Hash, PartialEq, PartialOrd, Ord, Show)] struct A{ x: Box&lt;int&gt; }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">    </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="cpp"><span class="hljs-comment"><span class="hljs-comment">#include &lt;stdio.h&gt; struct X { int a, b; }; void swap_from(X&amp; x, const X&amp; y) { xa = yb; xb = ya; } int main() { X x = {1,2}; swap_from(x,x); printf("%d,%d\n", xa, xb); }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> 2,2 </span></span><br><span class="hljs-comment"><span class="hljs-comment">    ,    cc      .   ,   ,  99  </span></span><a href="http://en.wikipedia.org/wiki/Restrict"><span class="hljs-comment"><span class="hljs-comment">restrict</span></span></a><span class="hljs-comment"><span class="hljs-comment"> ,            :        . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">       Rust: </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="rust"><span class="hljs-comment"><span class="hljs-comment">struct X { pub a: int, pub b: int } fn swap_from(x: &amp;mut X, y: &amp;X) { xa = yb; xb = ya; } fn main() { let mut x = X{a:1, b:2}; swap_from(&amp;mut x, &amp;x); }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">    : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7:24: 7:25 error: cannot borrow `x` as immutable because it is also borrowed as mutable </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7 swap_from(&amp;mut x, &amp;x); </span></span><br><span class="hljs-comment"><span class="hljs-comment"> ^ </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7:20: 7:21 note: previous borrow of `x` occurs here; the mutable borrow prevents subsequent moves, borrows, or modification of `x` until the borrow ends </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7 swap_from(&amp;mut x, &amp;x); </span></span><br><span class="hljs-comment"><span class="hljs-comment"> ^ </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7:26: 7:26 note: previous borrow ends here </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7 swap_from(&amp;mut x, &amp;x); </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  ,             " </span></span><code><span class="hljs-comment"><span class="hljs-comment">&amp;mut</span></span></code><span class="hljs-comment"><span class="hljs-comment"> "  " </span></span><code><span class="hljs-comment"><span class="hljs-comment">&amp;</span></span></code><span class="hljs-comment"><span class="hljs-comment"> " ,   ,          ,   </span></span><code><span class="hljs-comment"><span class="hljs-comment">&amp;mut</span></span></code><span class="hljs-comment"><span class="hljs-comment"> .            .  ,    ,      C99  </span></span><code><span class="hljs-comment"><span class="hljs-comment">restrict</span></span></code><span class="hljs-comment"><span class="hljs-comment">  (Rust  LLVM    ),    . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">   </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="cpp"><span class="hljs-comment"><span class="hljs-comment">#include &lt;vector&gt; int main() { std::vector&lt;int&gt; v; v.push_back(1); v.push_back(2); for(std::vector&lt;int&gt;::const_iterator it=v.begin(); it!=v.end(); ++it) { if (*it &lt; 5) v.push_back(5-*it); } }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">    ,    : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> Segmentation fault (core dumped) </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">    Rust: </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="rust"><span class="hljs-comment"><span class="hljs-comment">fn main() { let mut v: Vec&lt;int&gt; = Vec::new(); v.push(1); v.push(2); for x in v.iter() { if *x &lt; 5 { v.push(5-*x); } } }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">      ,  ,        : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7:13: 7:14 error: cannot borrow `v` as mutable because it is also borrowed as immutable </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7 v.push(5-*x); </span></span><br><span class="hljs-comment"><span class="hljs-comment"> ^ </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:5:14: 5:15 note: previous borrow of `v` occurs here; the immutable borrow prevents subsequent moves or mutable borrows of `v` until the borrow ends </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:5 for x in v.iter() { </span></span><br><span class="hljs-comment"><span class="hljs-comment"> ^ </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:10:2: 10:2 note: previous borrow ends here </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:5 for x in v.iter() { </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:6 if *x &lt; 5 { </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7 v.push(5-*x); </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:8 } </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:9 } </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:10 } </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  Switch </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="cpp"><span class="hljs-comment"><span class="hljs-comment">#include &lt;stdio.h&gt; enum {RED, BLUE, GRAY, UNKNOWN} color = GRAY; int main() { int x; switch(color) { case GRAY: x=1; case RED: case BLUE: x=2; } printf("%d", x); }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">   "2".  Rust          .  ,       ,    </span></span><code><span class="hljs-comment"><span class="hljs-comment">break</span></span></code><span class="hljs-comment"><span class="hljs-comment"> .    Rust   : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="rust"><span class="hljs-comment"><span class="hljs-comment">enum Color {RED, BLUE, GRAY, UNKNOWN} fn main() { let color = GRAY; let x = match color { GRAY =&gt; 1, RED | BLUE =&gt; 2, _ =&gt; 3, }; println!("{}", x); }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">     </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="cpp"><span class="hljs-comment"><span class="hljs-comment">int main() { int pixels = 1; for (int j=0; j&lt;5; j++); pixels++; }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  Rust          . , ,     . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="cpp"><span class="hljs-comment"><span class="hljs-comment">#include &lt;stdio.h&gt; #include &lt;pthread.h&gt; #include &lt;unistd.h&gt; class Resource { int *value; public: Resource(): value(NULL) {} ~Resource() {delete value;} int *acquire() { if (!value) { value = new int(0); } return value; } }; void* function(void *param) { int *value = ((Resource*)param)-&gt;acquire(); printf("resource: %p\n", (void*)value); return value; } int main() { Resource res; for (int i=0; i&lt;5; ++i) { pthread_t pt; pthread_create(&amp;pt, NULL, function, &amp;res); } //sleep(10); printf("done\n"); }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">     : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> done </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7f229c0008c0 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7f22840008c0 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7f228c0008c0 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7f22940008c0 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7f227c0008c0 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">     ,        .      Rust: </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="rust"><span class="hljs-comment"><span class="hljs-comment">struct Resource { value: Option&lt;int&gt;, } impl Resource { pub fn new() -&gt; Resource { Resource{ value: None } } pub fn acquire&lt;'a&gt;(&amp;'a mut self) -&gt; &amp;'a int { if self.value.is_none() { self.value = Some(1); } self.value.get_ref() } } fn main() { let mut res = Resource::new(); for _ in range(0,5) { spawn(proc() { let ptr = res.acquire(); println!("resource {}", ptr) }) } }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  ,            . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:20:23: 20:26 error: cannot borrow immutable captured outer variable in a proc `res` as mutable </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:20 let ptr = res.acquire(); </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">      ,   : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="rust"><span class="hljs-comment"><span class="hljs-comment">extern crate sync; use sync::{Arc, RWLock}; struct Resource { value: Option&lt;Box&lt;int&gt;&gt;, } impl Resource { pub fn new() -&gt; Resource { Resource{ value: None } } pub fn acquire(&amp;mut self) -&gt; *int { if self.value.is_none() { self.value = Some(box 1) } &amp;**self.value.get_ref() as *int } } fn main() { let arc_res = Arc::new(RWLock::new(Resource::new())); for _ in range(0,5) { let child_res = arc_res.clone(); spawn(proc() { let ptr = child_res.write().acquire(); println!("resource: {}", ptr) }) } }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">     </span></span><code><span class="hljs-comment"><span class="hljs-comment">Arc</span></span></code><span class="hljs-comment"><span class="hljs-comment"> ( </span></span><i><span class="hljs-comment"><span class="hljs-comment">Atomically Reference Counted</span></span></i><span class="hljs-comment"><span class="hljs-comment"> -        )  </span></span><code><span class="hljs-comment"><span class="hljs-comment">RWLock</span></span></code><span class="hljs-comment"><span class="hljs-comment"> (   ).   : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7ff4b0010378 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7ff4b0010378 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7ff4b0010378 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7ff4b0010378 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7ff4b0010378 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  ,   ++    .    . Rust        ,    .  ,   ,   .           ,       ( </span></span><a href="http://superwebdeveloper.com/2009/11/25/the-incredible-rate-of-diminishing-returns-of-fixing-software-bugs/"><span class="hljs-comment"><span class="hljs-comment">  </span></span></a><span class="hljs-comment"><span class="hljs-comment"> ). </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">     </span></span><br><span class="hljs-comment"><span class="hljs-comment"> Rust        ,     </span></span><code><span class="hljs-comment"><span class="hljs-comment">unsafe{}</span></span></code><span class="hljs-comment"><span class="hljs-comment"> .   ,     " </span></span><i><span class="hljs-comment"><span class="hljs-comment"> !  ,  .</span></span></i><span class="hljs-comment"><span class="hljs-comment"> ".  ,  ""  (    ,    )    .    ,           ( )  . , ,        </span></span><code><span class="hljs-comment"><span class="hljs-comment">Cell</span></span></code><span class="hljs-comment"><span class="hljs-comment">  </span></span><code><span class="hljs-comment"><span class="hljs-comment">Mutex</span></span></code><span class="hljs-comment"><span class="hljs-comment"> .             ,       (   </span></span><a href="http://en.wikipedia.org/wiki/Test-driven_development"><span class="hljs-comment"><span class="hljs-comment">TDD</span></span></a><span class="hljs-comment"><span class="hljs-comment"> !). </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="https://air.mozilla.org/guaranteeing-memory-safety-in-rust/"><span class="hljs-comment"><span class="hljs-comment">Guaranteeing Memory Safety in Rust (by Niko Matsakis)</span></span></a><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="http://www.techtalkshub.com/rust-safe-systems-programming-fun-fp/"><span class="hljs-comment"><span class="hljs-comment">Rust: Safe Systems Programming with the Fun of FP (by Felix Klock II)</span></span></a><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Keynote"><span class="hljs-comment"><span class="hljs-comment">Lang-NEXT: What ‚Äì if anything ‚Äì have we learned from C++? (by Bjarne Stroustrup)</span></span></a><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Panel-Systems-Programming-Languages-in-2014-and-Beyond"><span class="hljs-comment"><span class="hljs-comment">Lang-NEXT Panel: Systems Programming in 2014 and Beyond</span></span></a></code></code> </pre> <code><code><code><code class="cpp">Box)     ,       (     ).        (std::rc::Rc)    (std::gc::Gc),      (   ). <br> <br></code>      <br>  ++: <br> #include &lt;stdio.h&gt; int *bar(int *p) { return p; } int* foo(int n) { return bar(&amp;n); } int main() { int *p1 = foo(1); int *p2 = foo(2); printf("%d, %d\n", *p1, *p2); }</code> <br>  : <br> 2, 2 <br> <br>  Rust: <br> <code class="rust">fn bar&lt;'a&gt;(p: &amp;'a int) -&gt; &amp;'a int { return p; } fn foo(n: int) -&gt; &amp;int { bar(&amp;n) } fn main() { let p1 = foo(1); let p2 = foo(2); println!("{}, {}", *p1, *p2); }</code> <br>  : <br> demo:5:10: 5:11 error: `n` does not live long enough <br> demo:5 bar(&amp;n) <br> ^ <br> demo:4:24: 6:2 note: reference must be valid for the anonymous lifetime #1 defined on the block at 4:23... <br> demo:4 fn foo(n: int) -&gt; &amp;int { <br> demo:5 bar(&amp;n) <br> demo:6 } <br> demo:4:24: 6:2 note: ...but borrowed value is only valid for the block at 4:23 <br> demo:4 fn foo(n: int) -&gt; &amp;int { <br> demo:5 bar(&amp;n) <br> demo:6 } <br> <br>   <br> <code class="cpp">#include &lt;stdio.h&gt; int minval(int *A, int n) { int currmin; for (int i=0; i&lt;n; i++) if (A[i] &lt; currmin) currmin = A[i]; return currmin; } int main() { int A[] = {1,2,3}; int min = minval(A,3); printf("%d\n", min); }</code> <br>   0  ,     , ,  .       Rust ( - ): <br> <code class="rust">fn minval(A: &amp;[int]) -&gt; int { let mut currmin; for a in A.iter() { if *a &lt; currmin { currmin = *a; } } currmin } fn main() { let A = [1i,2i,3i]; let min = minval(A.as_slice()); println!("{}", min); }</code> <br>  , : use of possibly uninitialized variable: `currmin` <br>   ( )      : <br> <code class="rust">fn minval(A: &amp;[int]) -&gt; int { A.iter().fold(A[0], |u,&amp;a| { if a&lt;u {a} else {u} }) }</code> <br> <br>    <br> <code class="cpp">struct A{ int *x; A(int v): x(new int(v)) {} ~A() {delete x;} }; int main() { A a(1), b=a; }</code> <br> ,    : <br> *** glibc detected *** demo: double free or corruption (fasttop): 0x0000000000601010 *** <br> <br>     Rust: <br> <code class="rust">struct A{ x: Box&lt;int&gt; } impl A { pub fn new(v: int) -&gt; A { A{ x: box v } } } impl Drop for A { fn drop(&amp;mut self) {} // ,     ++ } fn main() { let a = A::new(1); let _b = a; }</code> <br>     .   ,     <code>trait Copy</code> . <br> Rust       .    <code>Eq</code>  <code>Clone</code> ?    <code>deriving</code>   : <br> <code class="rust">#[deriving(Clone, Eq, Hash, PartialEq, PartialOrd, Ord, Show)] struct A{ x: Box&lt;int&gt; }</code> <br> <br>    <br> <code class="cpp">#include &lt;stdio.h&gt; struct X { int a, b; }; void swap_from(X&amp; x, const X&amp; y) { xa = yb; xb = ya; } int main() { X x = {1,2}; swap_from(x,x); printf("%d,%d\n", xa, xb); }</code> <br>  : <br> 2,2 <br>    ,    cc      .   ,   ,  99  <a href="http://en.wikipedia.org/wiki/Restrict">restrict</a> ,            :        . <br> <br>       Rust: <br> <code class="rust">struct X { pub a: int, pub b: int } fn swap_from(x: &amp;mut X, y: &amp;X) { xa = yb; xb = ya; } fn main() { let mut x = X{a:1, b:2}; swap_from(&amp;mut x, &amp;x); }</code> <br>    : <br> demo:7:24: 7:25 error: cannot borrow `x` as immutable because it is also borrowed as mutable <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> ^ <br> demo:7:20: 7:21 note: previous borrow of `x` occurs here; the mutable borrow prevents subsequent moves, borrows, or modification of `x` until the borrow ends <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> ^ <br> demo:7:26: 7:26 note: previous borrow ends here <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> <br>  ,             " <code>&amp;mut</code> "  " <code>&amp;</code> " ,   ,          ,   <code>&amp;mut</code> .            .  ,    ,      C99  <code>restrict</code>  (Rust  LLVM    ),    . <br> <br>   <br> <code class="cpp">#include &lt;vector&gt; int main() { std::vector&lt;int&gt; v; v.push_back(1); v.push_back(2); for(std::vector&lt;int&gt;::const_iterator it=v.begin(); it!=v.end(); ++it) { if (*it &lt; 5) v.push_back(5-*it); } }</code> <br>    ,    : <br> Segmentation fault (core dumped) <br> <br>    Rust: <br> <code class="rust">fn main() { let mut v: Vec&lt;int&gt; = Vec::new(); v.push(1); v.push(2); for x in v.iter() { if *x &lt; 5 { v.push(5-*x); } } }</code> <br>      ,  ,        : <br> demo:7:13: 7:14 error: cannot borrow `v` as mutable because it is also borrowed as immutable <br> demo:7 v.push(5-*x); <br> ^ <br> demo:5:14: 5:15 note: previous borrow of `v` occurs here; the immutable borrow prevents subsequent moves or mutable borrows of `v` until the borrow ends <br> demo:5 for x in v.iter() { <br> ^ <br> demo:10:2: 10:2 note: previous borrow ends here <br> demo:5 for x in v.iter() { <br> demo:6 if *x &lt; 5 { <br> demo:7 v.push(5-*x); <br> demo:8 } <br> demo:9 } <br> demo:10 } <br> <br> <br>  Switch <br> <code class="cpp">#include &lt;stdio.h&gt; enum {RED, BLUE, GRAY, UNKNOWN} color = GRAY; int main() { int x; switch(color) { case GRAY: x=1; case RED: case BLUE: x=2; } printf("%d", x); }</code> <br>   "2".  Rust          .  ,       ,    <code>break</code> .    Rust   : <br> <code class="rust">enum Color {RED, BLUE, GRAY, UNKNOWN} fn main() { let color = GRAY; let x = match color { GRAY =&gt; 1, RED | BLUE =&gt; 2, _ =&gt; 3, }; println!("{}", x); }</code> <br> <br>     <br> <code class="cpp">int main() { int pixels = 1; for (int j=0; j&lt;5; j++); pixels++; }</code> <br>  Rust          . , ,     . <br> <br>  <br> <code class="cpp">#include &lt;stdio.h&gt; #include &lt;pthread.h&gt; #include &lt;unistd.h&gt; class Resource { int *value; public: Resource(): value(NULL) {} ~Resource() {delete value;} int *acquire() { if (!value) { value = new int(0); } return value; } }; void* function(void *param) { int *value = ((Resource*)param)-&gt;acquire(); printf("resource: %p\n", (void*)value); return value; } int main() { Resource res; for (int i=0; i&lt;5; ++i) { pthread_t pt; pthread_create(&amp;pt, NULL, function, &amp;res); } //sleep(10); printf("done\n"); }</code> <br>     : <br> done <br> resource: 0x7f229c0008c0 <br> resource: 0x7f22840008c0 <br> resource: 0x7f228c0008c0 <br> resource: 0x7f22940008c0 <br> resource: 0x7f227c0008c0 <br> <br>     ,        .      Rust: <br> <code class="rust">struct Resource { value: Option&lt;int&gt;, } impl Resource { pub fn new() -&gt; Resource { Resource{ value: None } } pub fn acquire&lt;'a&gt;(&amp;'a mut self) -&gt; &amp;'a int { if self.value.is_none() { self.value = Some(1); } self.value.get_ref() } } fn main() { let mut res = Resource::new(); for _ in range(0,5) { spawn(proc() { let ptr = res.acquire(); println!("resource {}", ptr) }) } }</code> <br>  ,            . <br> demo:20:23: 20:26 error: cannot borrow immutable captured outer variable in a proc `res` as mutable <br> demo:20 let ptr = res.acquire(); <br> <br>      ,   : <br> <code class="rust">extern crate sync; use sync::{Arc, RWLock}; struct Resource { value: Option&lt;Box&lt;int&gt;&gt;, } impl Resource { pub fn new() -&gt; Resource { Resource{ value: None } } pub fn acquire(&amp;mut self) -&gt; *int { if self.value.is_none() { self.value = Some(box 1) } &amp;**self.value.get_ref() as *int } } fn main() { let arc_res = Arc::new(RWLock::new(Resource::new())); for _ in range(0,5) { let child_res = arc_res.clone(); spawn(proc() { let ptr = child_res.write().acquire(); println!("resource: {}", ptr) }) } }</code> <br>     <code>Arc</code> ( <i>Atomically Reference Counted</i> -        )  <code>RWLock</code> (   ).   : <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> <br>  ,   ++    .    . Rust        ,    .  ,   ,   .           ,       ( <a href="http://superwebdeveloper.com/2009/11/25/the-incredible-rate-of-diminishing-returns-of-fixing-software-bugs/">  </a> ). <br> <br>     <br> Rust        ,     <code>unsafe{}</code> .   ,     " <i> !  ,  .</i> ".  ,  ""  (    ,    )    .    ,           ( )  . , ,        <code>Cell</code>  <code>Mutex</code> .             ,       (   <a href="http://en.wikipedia.org/wiki/Test-driven_development">TDD</a> !). <br> <br>  <br> <a href="https://air.mozilla.org/guaranteeing-memory-safety-in-rust/">Guaranteeing Memory Safety in Rust (by Niko Matsakis)</a> <br> <a href="http://www.techtalkshub.com/rust-safe-systems-programming-fun-fp/">Rust: Safe Systems Programming with the Fun of FP (by Felix Klock II)</a> <br> <a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Keynote">Lang-NEXT: What ‚Äì if anything ‚Äì have we learned from C++? (by Bjarne Stroustrup)</a> <br> <a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Panel-Systems-Programming-Languages-in-2014-and-Beyond">Lang-NEXT Panel: Systems Programming in 2014 and Beyond</a></code></code> <blockquote> <code><code><code><code class="cpp">Box)     ,       (     ).        (std::rc::Rc)    (std::gc::Gc),      (   ). <br> <br></code>      <br>  ++: <br> #include &lt;stdio.h&gt; int *bar(int *p) { return p; } int* foo(int n) { return bar(&amp;n); } int main() { int *p1 = foo(1); int *p2 = foo(2); printf("%d, %d\n", *p1, *p2); }</code> <br>  : <br> 2, 2 <br> <br>  Rust: <br> <code class="rust">fn bar&lt;'a&gt;(p: &amp;'a int) -&gt; &amp;'a int { return p; } fn foo(n: int) -&gt; &amp;int { bar(&amp;n) } fn main() { let p1 = foo(1); let p2 = foo(2); println!("{}, {}", *p1, *p2); }</code> <br>  : <br> demo:5:10: 5:11 error: `n` does not live long enough <br> demo:5 bar(&amp;n) <br> ^ <br> demo:4:24: 6:2 note: reference must be valid for the anonymous lifetime #1 defined on the block at 4:23... <br> demo:4 fn foo(n: int) -&gt; &amp;int { <br> demo:5 bar(&amp;n) <br> demo:6 } <br> demo:4:24: 6:2 note: ...but borrowed value is only valid for the block at 4:23 <br> demo:4 fn foo(n: int) -&gt; &amp;int { <br> demo:5 bar(&amp;n) <br> demo:6 } <br> <br>   <br> <code class="cpp">#include &lt;stdio.h&gt; int minval(int *A, int n) { int currmin; for (int i=0; i&lt;n; i++) if (A[i] &lt; currmin) currmin = A[i]; return currmin; } int main() { int A[] = {1,2,3}; int min = minval(A,3); printf("%d\n", min); }</code> <br>   0  ,     , ,  .       Rust ( - ): <br> <code class="rust">fn minval(A: &amp;[int]) -&gt; int { let mut currmin; for a in A.iter() { if *a &lt; currmin { currmin = *a; } } currmin } fn main() { let A = [1i,2i,3i]; let min = minval(A.as_slice()); println!("{}", min); }</code> <br>  , : use of possibly uninitialized variable: `currmin` <br>   ( )      : <br> <code class="rust">fn minval(A: &amp;[int]) -&gt; int { A.iter().fold(A[0], |u,&amp;a| { if a&lt;u {a} else {u} }) }</code> <br> <br>    <br> <code class="cpp">struct A{ int *x; A(int v): x(new int(v)) {} ~A() {delete x;} }; int main() { A a(1), b=a; }</code> <br> ,    : <br> *** glibc detected *** demo: double free or corruption (fasttop): 0x0000000000601010 *** <br> <br>     Rust: <br> <code class="rust">struct A{ x: Box&lt;int&gt; } impl A { pub fn new(v: int) -&gt; A { A{ x: box v } } } impl Drop for A { fn drop(&amp;mut self) {} // ,     ++ } fn main() { let a = A::new(1); let _b = a; }</code> <br>     .   ,     <code>trait Copy</code> . <br> Rust       .    <code>Eq</code>  <code>Clone</code> ?    <code>deriving</code>   : <br> <code class="rust">#[deriving(Clone, Eq, Hash, PartialEq, PartialOrd, Ord, Show)] struct A{ x: Box&lt;int&gt; }</code> <br> <br>    <br> <code class="cpp">#include &lt;stdio.h&gt; struct X { int a, b; }; void swap_from(X&amp; x, const X&amp; y) { xa = yb; xb = ya; } int main() { X x = {1,2}; swap_from(x,x); printf("%d,%d\n", xa, xb); }</code> <br>  : <br> 2,2 <br>    ,    cc      .   ,   ,  99  <a href="http://en.wikipedia.org/wiki/Restrict">restrict</a> ,            :        . <br> <br>       Rust: <br> <code class="rust">struct X { pub a: int, pub b: int } fn swap_from(x: &amp;mut X, y: &amp;X) { xa = yb; xb = ya; } fn main() { let mut x = X{a:1, b:2}; swap_from(&amp;mut x, &amp;x); }</code> <br>    : <br> demo:7:24: 7:25 error: cannot borrow `x` as immutable because it is also borrowed as mutable <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> ^ <br> demo:7:20: 7:21 note: previous borrow of `x` occurs here; the mutable borrow prevents subsequent moves, borrows, or modification of `x` until the borrow ends <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> ^ <br> demo:7:26: 7:26 note: previous borrow ends here <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> <br>  ,             " <code>&amp;mut</code> "  " <code>&amp;</code> " ,   ,          ,   <code>&amp;mut</code> .            .  ,    ,      C99  <code>restrict</code>  (Rust  LLVM    ),    . <br> <br>   <br> <code class="cpp">#include &lt;vector&gt; int main() { std::vector&lt;int&gt; v; v.push_back(1); v.push_back(2); for(std::vector&lt;int&gt;::const_iterator it=v.begin(); it!=v.end(); ++it) { if (*it &lt; 5) v.push_back(5-*it); } }</code> <br>    ,    : <br> Segmentation fault (core dumped) <br> <br>    Rust: <br> <code class="rust">fn main() { let mut v: Vec&lt;int&gt; = Vec::new(); v.push(1); v.push(2); for x in v.iter() { if *x &lt; 5 { v.push(5-*x); } } }</code> <br>      ,  ,        : <br> demo:7:13: 7:14 error: cannot borrow `v` as mutable because it is also borrowed as immutable <br> demo:7 v.push(5-*x); <br> ^ <br> demo:5:14: 5:15 note: previous borrow of `v` occurs here; the immutable borrow prevents subsequent moves or mutable borrows of `v` until the borrow ends <br> demo:5 for x in v.iter() { <br> ^ <br> demo:10:2: 10:2 note: previous borrow ends here <br> demo:5 for x in v.iter() { <br> demo:6 if *x &lt; 5 { <br> demo:7 v.push(5-*x); <br> demo:8 } <br> demo:9 } <br> demo:10 } <br> <br> <br>  Switch <br> <code class="cpp">#include &lt;stdio.h&gt; enum {RED, BLUE, GRAY, UNKNOWN} color = GRAY; int main() { int x; switch(color) { case GRAY: x=1; case RED: case BLUE: x=2; } printf("%d", x); }</code> <br>   "2".  Rust          .  ,       ,    <code>break</code> .    Rust   : <br> <code class="rust">enum Color {RED, BLUE, GRAY, UNKNOWN} fn main() { let color = GRAY; let x = match color { GRAY =&gt; 1, RED | BLUE =&gt; 2, _ =&gt; 3, }; println!("{}", x); }</code> <br> <br>     <br> <code class="cpp">int main() { int pixels = 1; for (int j=0; j&lt;5; j++); pixels++; }</code> <br>  Rust          . , ,     . <br> <br>  <br> <code class="cpp">#include &lt;stdio.h&gt; #include &lt;pthread.h&gt; #include &lt;unistd.h&gt; class Resource { int *value; public: Resource(): value(NULL) {} ~Resource() {delete value;} int *acquire() { if (!value) { value = new int(0); } return value; } }; void* function(void *param) { int *value = ((Resource*)param)-&gt;acquire(); printf("resource: %p\n", (void*)value); return value; } int main() { Resource res; for (int i=0; i&lt;5; ++i) { pthread_t pt; pthread_create(&amp;pt, NULL, function, &amp;res); } //sleep(10); printf("done\n"); }</code> <br>     : <br> done <br> resource: 0x7f229c0008c0 <br> resource: 0x7f22840008c0 <br> resource: 0x7f228c0008c0 <br> resource: 0x7f22940008c0 <br> resource: 0x7f227c0008c0 <br> <br>     ,        .      Rust: <br> <code class="rust">struct Resource { value: Option&lt;int&gt;, } impl Resource { pub fn new() -&gt; Resource { Resource{ value: None } } pub fn acquire&lt;'a&gt;(&amp;'a mut self) -&gt; &amp;'a int { if self.value.is_none() { self.value = Some(1); } self.value.get_ref() } } fn main() { let mut res = Resource::new(); for _ in range(0,5) { spawn(proc() { let ptr = res.acquire(); println!("resource {}", ptr) }) } }</code> <br>  ,            . <br> demo:20:23: 20:26 error: cannot borrow immutable captured outer variable in a proc `res` as mutable <br> demo:20 let ptr = res.acquire(); <br> <br>      ,   : <br> <code class="rust">extern crate sync; use sync::{Arc, RWLock}; struct Resource { value: Option&lt;Box&lt;int&gt;&gt;, } impl Resource { pub fn new() -&gt; Resource { Resource{ value: None } } pub fn acquire(&amp;mut self) -&gt; *int { if self.value.is_none() { self.value = Some(box 1) } &amp;**self.value.get_ref() as *int } } fn main() { let arc_res = Arc::new(RWLock::new(Resource::new())); for _ in range(0,5) { let child_res = arc_res.clone(); spawn(proc() { let ptr = child_res.write().acquire(); println!("resource: {}", ptr) }) } }</code> <br>     <code>Arc</code> ( <i>Atomically Reference Counted</i> -        )  <code>RWLock</code> (   ).   : <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> <br>  ,   ++    .    . Rust        ,    .  ,   ,   .           ,       ( <a href="http://superwebdeveloper.com/2009/11/25/the-incredible-rate-of-diminishing-returns-of-fixing-software-bugs/">  </a> ). <br> <br>     <br> Rust        ,     <code>unsafe{}</code> .   ,     " <i> !  ,  .</i> ".  ,  ""  (    ,    )    .    ,           ( )  . , ,        <code>Cell</code>  <code>Mutex</code> .             ,       (   <a href="http://en.wikipedia.org/wiki/Test-driven_development">TDD</a> !). <br> <br>  <br> <a href="https://air.mozilla.org/guaranteeing-memory-safety-in-rust/">Guaranteeing Memory Safety in Rust (by Niko Matsakis)</a> <br> <a href="http://www.techtalkshub.com/rust-safe-systems-programming-fun-fp/">Rust: Safe Systems Programming with the Fun of FP (by Felix Klock II)</a> <br> <a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Keynote">Lang-NEXT: What ‚Äì if anything ‚Äì have we learned from C++? (by Bjarne Stroustrup)</a> <br> <a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Panel-Systems-Programming-Languages-in-2014-and-Beyond">Lang-NEXT Panel: Systems Programming in 2014 and Beyond</a></code></code> </blockquote> <code><code><code><code class="cpp">Box)     ,       (     ).        (std::rc::Rc)    (std::gc::Gc),      (   ). <br> <br></code>      <br>  ++: <br> #include &lt;stdio.h&gt; int *bar(int *p) { return p; } int* foo(int n) { return bar(&amp;n); } int main() { int *p1 = foo(1); int *p2 = foo(2); printf("%d, %d\n", *p1, *p2); }</code> <br>  : <br> 2, 2 <br> <br>  Rust: <br> <code class="rust">fn bar&lt;'a&gt;(p: &amp;'a int) -&gt; &amp;'a int { return p; } fn foo(n: int) -&gt; &amp;int { bar(&amp;n) } fn main() { let p1 = foo(1); let p2 = foo(2); println!("{}, {}", *p1, *p2); }</code> <br>  : <br> demo:5:10: 5:11 error: `n` does not live long enough <br> demo:5 bar(&amp;n) <br> ^ <br> demo:4:24: 6:2 note: reference must be valid for the anonymous lifetime #1 defined on the block at 4:23... <br> demo:4 fn foo(n: int) -&gt; &amp;int { <br> demo:5 bar(&amp;n) <br> demo:6 } <br> demo:4:24: 6:2 note: ...but borrowed value is only valid for the block at 4:23 <br> demo:4 fn foo(n: int) -&gt; &amp;int { <br> demo:5 bar(&amp;n) <br> demo:6 } <br> <br>   <br> <code class="cpp">#include &lt;stdio.h&gt; int minval(int *A, int n) { int currmin; for (int i=0; i&lt;n; i++) if (A[i] &lt; currmin) currmin = A[i]; return currmin; } int main() { int A[] = {1,2,3}; int min = minval(A,3); printf("%d\n", min); }</code> <br>   0  ,     , ,  .       Rust ( - ): <br> <code class="rust">fn minval(A: &amp;[int]) -&gt; int { let mut currmin; for a in A.iter() { if *a &lt; currmin { currmin = *a; } } currmin } fn main() { let A = [1i,2i,3i]; let min = minval(A.as_slice()); println!("{}", min); }</code> <br>  , : use of possibly uninitialized variable: `currmin` <br>   ( )      : <br> <code class="rust">fn minval(A: &amp;[int]) -&gt; int { A.iter().fold(A[0], |u,&amp;a| { if a&lt;u {a} else {u} }) }</code> <br> <br>    <br> <code class="cpp">struct A{ int *x; A(int v): x(new int(v)) {} ~A() {delete x;} }; int main() { A a(1), b=a; }</code> <br> ,    : <br> *** glibc detected *** demo: double free or corruption (fasttop): 0x0000000000601010 *** <br> <br>     Rust: <br> <code class="rust">struct A{ x: Box&lt;int&gt; } impl A { pub fn new(v: int) -&gt; A { A{ x: box v } } } impl Drop for A { fn drop(&amp;mut self) {} // ,     ++ } fn main() { let a = A::new(1); let _b = a; }</code> <br>     .   ,     <code>trait Copy</code> . <br> Rust       .    <code>Eq</code>  <code>Clone</code> ?    <code>deriving</code>   : <br> <code class="rust">#[deriving(Clone, Eq, Hash, PartialEq, PartialOrd, Ord, Show)] struct A{ x: Box&lt;int&gt; }</code> <br> <br>    <br> <code class="cpp">#include &lt;stdio.h&gt; struct X { int a, b; }; void swap_from(X&amp; x, const X&amp; y) { xa = yb; xb = ya; } int main() { X x = {1,2}; swap_from(x,x); printf("%d,%d\n", xa, xb); }</code> <br>  : <br> 2,2 <br>    ,    cc      .   ,   ,  99  <a href="http://en.wikipedia.org/wiki/Restrict">restrict</a> ,            :        . <br> <br>       Rust: <br> <code class="rust">struct X { pub a: int, pub b: int } fn swap_from(x: &amp;mut X, y: &amp;X) { xa = yb; xb = ya; } fn main() { let mut x = X{a:1, b:2}; swap_from(&amp;mut x, &amp;x); }</code> <br>    : <br> demo:7:24: 7:25 error: cannot borrow `x` as immutable because it is also borrowed as mutable <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> ^ <br> demo:7:20: 7:21 note: previous borrow of `x` occurs here; the mutable borrow prevents subsequent moves, borrows, or modification of `x` until the borrow ends <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> ^ <br> demo:7:26: 7:26 note: previous borrow ends here <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> <br>  ,             " <code>&amp;mut</code> "  " <code>&amp;</code> " ,   ,          ,   <code>&amp;mut</code> .            .  ,    ,      C99  <code>restrict</code>  (Rust  LLVM    ),    . <br> <br>   <br> <code class="cpp">#include &lt;vector&gt; int main() { std::vector&lt;int&gt; v; v.push_back(1); v.push_back(2); for(std::vector&lt;int&gt;::const_iterator it=v.begin(); it!=v.end(); ++it) { if (*it &lt; 5) v.push_back(5-*it); } }</code> <br>    ,    : <br> Segmentation fault (core dumped) <br> <br>    Rust: <br> <code class="rust">fn main() { let mut v: Vec&lt;int&gt; = Vec::new(); v.push(1); v.push(2); for x in v.iter() { if *x &lt; 5 { v.push(5-*x); } } }</code> <br>      ,  ,        : <br> demo:7:13: 7:14 error: cannot borrow `v` as mutable because it is also borrowed as immutable <br> demo:7 v.push(5-*x); <br> ^ <br> demo:5:14: 5:15 note: previous borrow of `v` occurs here; the immutable borrow prevents subsequent moves or mutable borrows of `v` until the borrow ends <br> demo:5 for x in v.iter() { <br> ^ <br> demo:10:2: 10:2 note: previous borrow ends here <br> demo:5 for x in v.iter() { <br> demo:6 if *x &lt; 5 { <br> demo:7 v.push(5-*x); <br> demo:8 } <br> demo:9 } <br> demo:10 } <br> <br> <br>  Switch <br> <code class="cpp">#include &lt;stdio.h&gt; enum {RED, BLUE, GRAY, UNKNOWN} color = GRAY; int main() { int x; switch(color) { case GRAY: x=1; case RED: case BLUE: x=2; } printf("%d", x); }</code> <br>   "2".  Rust          .  ,       ,    <code>break</code> .    Rust   : <br> <code class="rust">enum Color {RED, BLUE, GRAY, UNKNOWN} fn main() { let color = GRAY; let x = match color { GRAY =&gt; 1, RED | BLUE =&gt; 2, _ =&gt; 3, }; println!("{}", x); }</code> <br> <br>     <br> <code class="cpp">int main() { int pixels = 1; for (int j=0; j&lt;5; j++); pixels++; }</code> <br>  Rust          . , ,     . <br> <br>  <br> <code class="cpp">#include &lt;stdio.h&gt; #include &lt;pthread.h&gt; #include &lt;unistd.h&gt; class Resource { int *value; public: Resource(): value(NULL) {} ~Resource() {delete value;} int *acquire() { if (!value) { value = new int(0); } return value; } }; void* function(void *param) { int *value = ((Resource*)param)-&gt;acquire(); printf("resource: %p\n", (void*)value); return value; } int main() { Resource res; for (int i=0; i&lt;5; ++i) { pthread_t pt; pthread_create(&amp;pt, NULL, function, &amp;res); } //sleep(10); printf("done\n"); }</code> <br>     : <br> done <br> resource: 0x7f229c0008c0 <br> resource: 0x7f22840008c0 <br> resource: 0x7f228c0008c0 <br> resource: 0x7f22940008c0 <br> resource: 0x7f227c0008c0 <br> <br>     ,        .      Rust: <br> <code class="rust">struct Resource { value: Option&lt;int&gt;, } impl Resource { pub fn new() -&gt; Resource { Resource{ value: None } } pub fn acquire&lt;'a&gt;(&amp;'a mut self) -&gt; &amp;'a int { if self.value.is_none() { self.value = Some(1); } self.value.get_ref() } } fn main() { let mut res = Resource::new(); for _ in range(0,5) { spawn(proc() { let ptr = res.acquire(); println!("resource {}", ptr) }) } }</code> <br>  ,            . <br> demo:20:23: 20:26 error: cannot borrow immutable captured outer variable in a proc `res` as mutable <br> demo:20 let ptr = res.acquire(); <br> <br>      ,   : <br> <code class="rust">extern crate sync; use sync::{Arc, RWLock}; struct Resource { value: Option&lt;Box&lt;int&gt;&gt;, } impl Resource { pub fn new() -&gt; Resource { Resource{ value: None } } pub fn acquire(&amp;mut self) -&gt; *int { if self.value.is_none() { self.value = Some(box 1) } &amp;**self.value.get_ref() as *int } } fn main() { let arc_res = Arc::new(RWLock::new(Resource::new())); for _ in range(0,5) { let child_res = arc_res.clone(); spawn(proc() { let ptr = child_res.write().acquire(); println!("resource: {}", ptr) }) } }</code> <br>     <code>Arc</code> ( <i>Atomically Reference Counted</i> -        )  <code>RWLock</code> (   ).   : <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> <br>  ,   ++    .    . Rust        ,    .  ,   ,   .           ,       ( <a href="http://superwebdeveloper.com/2009/11/25/the-incredible-rate-of-diminishing-returns-of-fixing-software-bugs/">  </a> ). <br> <br>     <br> Rust        ,     <code>unsafe{}</code> .   ,     " <i> !  ,  .</i> ".  ,  ""  (    ,    )    .    ,           ( )  . , ,        <code>Cell</code>  <code>Mutex</code> .             ,       (   <a href="http://en.wikipedia.org/wiki/Test-driven_development">TDD</a> !). <br> <br>  <br> <a href="https://air.mozilla.org/guaranteeing-memory-safety-in-rust/">Guaranteeing Memory Safety in Rust (by Niko Matsakis)</a> <br> <a href="http://www.techtalkshub.com/rust-safe-systems-programming-fun-fp/">Rust: Safe Systems Programming with the Fun of FP (by Felix Klock II)</a> <br> <a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Keynote">Lang-NEXT: What ‚Äì if anything ‚Äì have we learned from C++? (by Bjarne Stroustrup)</a> <br> <a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Panel-Systems-Programming-Languages-in-2014-and-Beyond">Lang-NEXT Panel: Systems Programming in 2014 and Beyond</a></code></code> <pre> <code class="hljs rust"><code><code><code class="cpp"><span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>)     ,       (     ).        (std::rc::Rc)    (std::gc::Gc),      (   ). <br> <br></code>      <br>  ++: <br> #include &lt;stdio.h&gt; int *bar(int *p) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p; } int* foo(int n) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bar(&amp;n); } int main() { int *p1 = foo(<span class="hljs-number"><span class="hljs-number">1</span></span>); int *p2 = foo(<span class="hljs-number"><span class="hljs-number">2</span></span>); printf(<span class="hljs-string"><span class="hljs-string">"%d, %d\n"</span></span>, *p1, *p2); }</code> <br>  : <br> <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span> <br> <br>  Rust: <br> <code class="rust"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt;(p: &amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> int) -&gt; &amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> int { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>(n: int) -&gt; &amp;int { bar(&amp;n) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> p1 = foo(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> p2 = foo(<span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{}, {}"</span></span>, *p1, *p2); }</code> <br>  : <br> demo:<span class="hljs-number"><span class="hljs-number">5</span></span>:<span class="hljs-number"><span class="hljs-number">10</span></span>: <span class="hljs-number"><span class="hljs-number">5</span></span>:<span class="hljs-number"><span class="hljs-number">11</span></span> error: `n` does not live long enough <br> demo:<span class="hljs-number"><span class="hljs-number">5</span></span> bar(&amp;n) <br> ^ <br> demo:<span class="hljs-number"><span class="hljs-number">4</span></span>:<span class="hljs-number"><span class="hljs-number">24</span></span>: <span class="hljs-number"><span class="hljs-number">6</span></span>:<span class="hljs-number"><span class="hljs-number">2</span></span> note: reference must <span class="hljs-keyword"><span class="hljs-keyword">be</span></span> valid <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> the anonymous lifetime #<span class="hljs-number"><span class="hljs-number">1</span></span> defined on the block at <span class="hljs-number"><span class="hljs-number">4</span></span>:<span class="hljs-number"><span class="hljs-number">23</span></span>... <br> demo:<span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>(n: int) -&gt; &amp;int { <br> demo:<span class="hljs-number"><span class="hljs-number">5</span></span> bar(&amp;n) <br> demo:<span class="hljs-number"><span class="hljs-number">6</span></span> } <br> demo:<span class="hljs-number"><span class="hljs-number">4</span></span>:<span class="hljs-number"><span class="hljs-number">24</span></span>: <span class="hljs-number"><span class="hljs-number">6</span></span>:<span class="hljs-number"><span class="hljs-number">2</span></span> note: ...but borrowed value is only valid <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> the block at <span class="hljs-number"><span class="hljs-number">4</span></span>:<span class="hljs-number"><span class="hljs-number">23</span></span> <br> demo:<span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>(n: int) -&gt; &amp;int { <br> demo:<span class="hljs-number"><span class="hljs-number">5</span></span> bar(&amp;n) <br> demo:<span class="hljs-number"><span class="hljs-number">6</span></span> } <br> <br>   <br> <code class="cpp">#include &lt;stdio.h&gt; int minval(int *A, int n) { int currmin; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;n; i++) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (A[i] &lt; currmin) currmin = A[i]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> currmin; } int main() { int A[] = {<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>}; int min = minval(A,<span class="hljs-number"><span class="hljs-number">3</span></span>); printf(<span class="hljs-string"><span class="hljs-string">"%d\n"</span></span>, min); }</code> <br>   <span class="hljs-number"><span class="hljs-number">0</span></span>  ,     , ,  .       Rust ( - ): <br> <code class="rust"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">minval</span></span></span></span>(A: &amp;[int]) -&gt; int { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> currmin; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> a <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> A.iter() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> *a &lt; currmin { currmin = *a; } } currmin } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> A = [<span class="hljs-number"><span class="hljs-number">1</span></span>i,<span class="hljs-number"><span class="hljs-number">2</span></span>i,<span class="hljs-number"><span class="hljs-number">3</span></span>i]; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> min = minval(A.as_slice()); <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{}"</span></span>, min); }</code> <br>  , : <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> of possibly uninitialized variable: `currmin` <br>   ( )      : <br> <code class="rust"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">minval</span></span></span></span>(A: &amp;[int]) -&gt; int { A.iter().fold(A[<span class="hljs-number"><span class="hljs-number">0</span></span>], |u,&amp;a| { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> a&lt;u {a} <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {u} }) }</code> <br> <br>    <br> <code class="cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span></span>{ int *x; A(int v): x(new int(v)) {} ~A() {delete x;} }; int main() { A a(<span class="hljs-number"><span class="hljs-number">1</span></span>), b=a; }</code> <br> ,    : <br> *** glibc detected *** demo: double free or corruption (fasttop): <span class="hljs-number"><span class="hljs-number">0x0000000000601010</span></span> *** <br> <br>     Rust: <br> <code class="rust"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span></span>{ x: <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;int&gt; } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> A { <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">new</span></span></span></span>(v: int) -&gt; A { A{ x: <span class="hljs-keyword"><span class="hljs-keyword">box</span></span> v } } } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Drop</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> A { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drop</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) {} <span class="hljs-comment"><span class="hljs-comment">// ,     ++ } fn main() { let a = A::new(1); let _b = a; }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">     .   ,     </span></span><code><span class="hljs-comment"><span class="hljs-comment">trait Copy</span></span></code><span class="hljs-comment"><span class="hljs-comment"> . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> Rust       .    </span></span><code><span class="hljs-comment"><span class="hljs-comment">Eq</span></span></code><span class="hljs-comment"><span class="hljs-comment">  </span></span><code><span class="hljs-comment"><span class="hljs-comment">Clone</span></span></code><span class="hljs-comment"><span class="hljs-comment"> ?    </span></span><code><span class="hljs-comment"><span class="hljs-comment">deriving</span></span></code><span class="hljs-comment"><span class="hljs-comment">   : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="rust"><span class="hljs-comment"><span class="hljs-comment">#[deriving(Clone, Eq, Hash, PartialEq, PartialOrd, Ord, Show)] struct A{ x: Box&lt;int&gt; }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">    </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="cpp"><span class="hljs-comment"><span class="hljs-comment">#include &lt;stdio.h&gt; struct X { int a, b; }; void swap_from(X&amp; x, const X&amp; y) { xa = yb; xb = ya; } int main() { X x = {1,2}; swap_from(x,x); printf("%d,%d\n", xa, xb); }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> 2,2 </span></span><br><span class="hljs-comment"><span class="hljs-comment">    ,    cc      .   ,   ,  99  </span></span><a href="http://en.wikipedia.org/wiki/Restrict"><span class="hljs-comment"><span class="hljs-comment">restrict</span></span></a><span class="hljs-comment"><span class="hljs-comment"> ,            :        . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">       Rust: </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="rust"><span class="hljs-comment"><span class="hljs-comment">struct X { pub a: int, pub b: int } fn swap_from(x: &amp;mut X, y: &amp;X) { xa = yb; xb = ya; } fn main() { let mut x = X{a:1, b:2}; swap_from(&amp;mut x, &amp;x); }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">    : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7:24: 7:25 error: cannot borrow `x` as immutable because it is also borrowed as mutable </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7 swap_from(&amp;mut x, &amp;x); </span></span><br><span class="hljs-comment"><span class="hljs-comment"> ^ </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7:20: 7:21 note: previous borrow of `x` occurs here; the mutable borrow prevents subsequent moves, borrows, or modification of `x` until the borrow ends </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7 swap_from(&amp;mut x, &amp;x); </span></span><br><span class="hljs-comment"><span class="hljs-comment"> ^ </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7:26: 7:26 note: previous borrow ends here </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7 swap_from(&amp;mut x, &amp;x); </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  ,             " </span></span><code><span class="hljs-comment"><span class="hljs-comment">&amp;mut</span></span></code><span class="hljs-comment"><span class="hljs-comment"> "  " </span></span><code><span class="hljs-comment"><span class="hljs-comment">&amp;</span></span></code><span class="hljs-comment"><span class="hljs-comment"> " ,   ,          ,   </span></span><code><span class="hljs-comment"><span class="hljs-comment">&amp;mut</span></span></code><span class="hljs-comment"><span class="hljs-comment"> .            .  ,    ,      C99  </span></span><code><span class="hljs-comment"><span class="hljs-comment">restrict</span></span></code><span class="hljs-comment"><span class="hljs-comment">  (Rust  LLVM    ),    . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">   </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="cpp"><span class="hljs-comment"><span class="hljs-comment">#include &lt;vector&gt; int main() { std::vector&lt;int&gt; v; v.push_back(1); v.push_back(2); for(std::vector&lt;int&gt;::const_iterator it=v.begin(); it!=v.end(); ++it) { if (*it &lt; 5) v.push_back(5-*it); } }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">    ,    : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> Segmentation fault (core dumped) </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">    Rust: </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="rust"><span class="hljs-comment"><span class="hljs-comment">fn main() { let mut v: Vec&lt;int&gt; = Vec::new(); v.push(1); v.push(2); for x in v.iter() { if *x &lt; 5 { v.push(5-*x); } } }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">      ,  ,        : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7:13: 7:14 error: cannot borrow `v` as mutable because it is also borrowed as immutable </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7 v.push(5-*x); </span></span><br><span class="hljs-comment"><span class="hljs-comment"> ^ </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:5:14: 5:15 note: previous borrow of `v` occurs here; the immutable borrow prevents subsequent moves or mutable borrows of `v` until the borrow ends </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:5 for x in v.iter() { </span></span><br><span class="hljs-comment"><span class="hljs-comment"> ^ </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:10:2: 10:2 note: previous borrow ends here </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:5 for x in v.iter() { </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:6 if *x &lt; 5 { </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7 v.push(5-*x); </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:8 } </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:9 } </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:10 } </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  Switch </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="cpp"><span class="hljs-comment"><span class="hljs-comment">#include &lt;stdio.h&gt; enum {RED, BLUE, GRAY, UNKNOWN} color = GRAY; int main() { int x; switch(color) { case GRAY: x=1; case RED: case BLUE: x=2; } printf("%d", x); }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">   "2".  Rust          .  ,       ,    </span></span><code><span class="hljs-comment"><span class="hljs-comment">break</span></span></code><span class="hljs-comment"><span class="hljs-comment"> .    Rust   : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="rust"><span class="hljs-comment"><span class="hljs-comment">enum Color {RED, BLUE, GRAY, UNKNOWN} fn main() { let color = GRAY; let x = match color { GRAY =&gt; 1, RED | BLUE =&gt; 2, _ =&gt; 3, }; println!("{}", x); }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">     </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="cpp"><span class="hljs-comment"><span class="hljs-comment">int main() { int pixels = 1; for (int j=0; j&lt;5; j++); pixels++; }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  Rust          . , ,     . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="cpp"><span class="hljs-comment"><span class="hljs-comment">#include &lt;stdio.h&gt; #include &lt;pthread.h&gt; #include &lt;unistd.h&gt; class Resource { int *value; public: Resource(): value(NULL) {} ~Resource() {delete value;} int *acquire() { if (!value) { value = new int(0); } return value; } }; void* function(void *param) { int *value = ((Resource*)param)-&gt;acquire(); printf("resource: %p\n", (void*)value); return value; } int main() { Resource res; for (int i=0; i&lt;5; ++i) { pthread_t pt; pthread_create(&amp;pt, NULL, function, &amp;res); } //sleep(10); printf("done\n"); }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">     : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> done </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7f229c0008c0 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7f22840008c0 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7f228c0008c0 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7f22940008c0 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7f227c0008c0 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">     ,        .      Rust: </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="rust"><span class="hljs-comment"><span class="hljs-comment">struct Resource { value: Option&lt;int&gt;, } impl Resource { pub fn new() -&gt; Resource { Resource{ value: None } } pub fn acquire&lt;'a&gt;(&amp;'a mut self) -&gt; &amp;'a int { if self.value.is_none() { self.value = Some(1); } self.value.get_ref() } } fn main() { let mut res = Resource::new(); for _ in range(0,5) { spawn(proc() { let ptr = res.acquire(); println!("resource {}", ptr) }) } }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  ,            . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:20:23: 20:26 error: cannot borrow immutable captured outer variable in a proc `res` as mutable </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:20 let ptr = res.acquire(); </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">      ,   : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="rust"><span class="hljs-comment"><span class="hljs-comment">extern crate sync; use sync::{Arc, RWLock}; struct Resource { value: Option&lt;Box&lt;int&gt;&gt;, } impl Resource { pub fn new() -&gt; Resource { Resource{ value: None } } pub fn acquire(&amp;mut self) -&gt; *int { if self.value.is_none() { self.value = Some(box 1) } &amp;**self.value.get_ref() as *int } } fn main() { let arc_res = Arc::new(RWLock::new(Resource::new())); for _ in range(0,5) { let child_res = arc_res.clone(); spawn(proc() { let ptr = child_res.write().acquire(); println!("resource: {}", ptr) }) } }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">     </span></span><code><span class="hljs-comment"><span class="hljs-comment">Arc</span></span></code><span class="hljs-comment"><span class="hljs-comment"> ( </span></span><i><span class="hljs-comment"><span class="hljs-comment">Atomically Reference Counted</span></span></i><span class="hljs-comment"><span class="hljs-comment"> -        )  </span></span><code><span class="hljs-comment"><span class="hljs-comment">RWLock</span></span></code><span class="hljs-comment"><span class="hljs-comment"> (   ).   : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7ff4b0010378 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7ff4b0010378 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7ff4b0010378 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7ff4b0010378 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7ff4b0010378 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  ,   ++    .    . Rust        ,    .  ,   ,   .           ,       ( </span></span><a href="http://superwebdeveloper.com/2009/11/25/the-incredible-rate-of-diminishing-returns-of-fixing-software-bugs/"><span class="hljs-comment"><span class="hljs-comment">  </span></span></a><span class="hljs-comment"><span class="hljs-comment"> ). </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">     </span></span><br><span class="hljs-comment"><span class="hljs-comment"> Rust        ,     </span></span><code><span class="hljs-comment"><span class="hljs-comment">unsafe{}</span></span></code><span class="hljs-comment"><span class="hljs-comment"> .   ,     " </span></span><i><span class="hljs-comment"><span class="hljs-comment"> !  ,  .</span></span></i><span class="hljs-comment"><span class="hljs-comment"> ".  ,  ""  (    ,    )    .    ,           ( )  . , ,        </span></span><code><span class="hljs-comment"><span class="hljs-comment">Cell</span></span></code><span class="hljs-comment"><span class="hljs-comment">  </span></span><code><span class="hljs-comment"><span class="hljs-comment">Mutex</span></span></code><span class="hljs-comment"><span class="hljs-comment"> .             ,       (   </span></span><a href="http://en.wikipedia.org/wiki/Test-driven_development"><span class="hljs-comment"><span class="hljs-comment">TDD</span></span></a><span class="hljs-comment"><span class="hljs-comment"> !). </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="https://air.mozilla.org/guaranteeing-memory-safety-in-rust/"><span class="hljs-comment"><span class="hljs-comment">Guaranteeing Memory Safety in Rust (by Niko Matsakis)</span></span></a><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="http://www.techtalkshub.com/rust-safe-systems-programming-fun-fp/"><span class="hljs-comment"><span class="hljs-comment">Rust: Safe Systems Programming with the Fun of FP (by Felix Klock II)</span></span></a><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Keynote"><span class="hljs-comment"><span class="hljs-comment">Lang-NEXT: What ‚Äì if anything ‚Äì have we learned from C++? (by Bjarne Stroustrup)</span></span></a><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Panel-Systems-Programming-Languages-in-2014-and-Beyond"><span class="hljs-comment"><span class="hljs-comment">Lang-NEXT Panel: Systems Programming in 2014 and Beyond</span></span></a></code></code> </pre> <code><code><code><code class="cpp">Box)     ,       (     ).        (std::rc::Rc)    (std::gc::Gc),      (   ). <br> <br></code>      <br>  ++: <br> #include &lt;stdio.h&gt; int *bar(int *p) { return p; } int* foo(int n) { return bar(&amp;n); } int main() { int *p1 = foo(1); int *p2 = foo(2); printf("%d, %d\n", *p1, *p2); }</code> <br>  : <br> 2, 2 <br> <br>  Rust: <br> <code class="rust">fn bar&lt;'a&gt;(p: &amp;'a int) -&gt; &amp;'a int { return p; } fn foo(n: int) -&gt; &amp;int { bar(&amp;n) } fn main() { let p1 = foo(1); let p2 = foo(2); println!("{}, {}", *p1, *p2); }</code> <br>  : <br> demo:5:10: 5:11 error: `n` does not live long enough <br> demo:5 bar(&amp;n) <br> ^ <br> demo:4:24: 6:2 note: reference must be valid for the anonymous lifetime #1 defined on the block at 4:23... <br> demo:4 fn foo(n: int) -&gt; &amp;int { <br> demo:5 bar(&amp;n) <br> demo:6 } <br> demo:4:24: 6:2 note: ...but borrowed value is only valid for the block at 4:23 <br> demo:4 fn foo(n: int) -&gt; &amp;int { <br> demo:5 bar(&amp;n) <br> demo:6 } <br> <br>   <br> <code class="cpp">#include &lt;stdio.h&gt; int minval(int *A, int n) { int currmin; for (int i=0; i&lt;n; i++) if (A[i] &lt; currmin) currmin = A[i]; return currmin; } int main() { int A[] = {1,2,3}; int min = minval(A,3); printf("%d\n", min); }</code> <br>   0  ,     , ,  .       Rust ( - ): <br> <code class="rust">fn minval(A: &amp;[int]) -&gt; int { let mut currmin; for a in A.iter() { if *a &lt; currmin { currmin = *a; } } currmin } fn main() { let A = [1i,2i,3i]; let min = minval(A.as_slice()); println!("{}", min); }</code> <br>  , : use of possibly uninitialized variable: `currmin` <br>   ( )      : <br> <code class="rust">fn minval(A: &amp;[int]) -&gt; int { A.iter().fold(A[0], |u,&amp;a| { if a&lt;u {a} else {u} }) }</code> <br> <br>    <br> <code class="cpp">struct A{ int *x; A(int v): x(new int(v)) {} ~A() {delete x;} }; int main() { A a(1), b=a; }</code> <br> ,    : <br> *** glibc detected *** demo: double free or corruption (fasttop): 0x0000000000601010 *** <br> <br>     Rust: <br> <code class="rust">struct A{ x: Box&lt;int&gt; } impl A { pub fn new(v: int) -&gt; A { A{ x: box v } } } impl Drop for A { fn drop(&amp;mut self) {} // ,     ++ } fn main() { let a = A::new(1); let _b = a; }</code> <br>     .   ,     <code>trait Copy</code> . <br> Rust       .    <code>Eq</code>  <code>Clone</code> ?    <code>deriving</code>   : <br> <code class="rust">#[deriving(Clone, Eq, Hash, PartialEq, PartialOrd, Ord, Show)] struct A{ x: Box&lt;int&gt; }</code> <br> <br>    <br> <code class="cpp">#include &lt;stdio.h&gt; struct X { int a, b; }; void swap_from(X&amp; x, const X&amp; y) { xa = yb; xb = ya; } int main() { X x = {1,2}; swap_from(x,x); printf("%d,%d\n", xa, xb); }</code> <br>  : <br> 2,2 <br>    ,    cc      .   ,   ,  99  <a href="http://en.wikipedia.org/wiki/Restrict">restrict</a> ,            :        . <br> <br>       Rust: <br> <code class="rust">struct X { pub a: int, pub b: int } fn swap_from(x: &amp;mut X, y: &amp;X) { xa = yb; xb = ya; } fn main() { let mut x = X{a:1, b:2}; swap_from(&amp;mut x, &amp;x); }</code> <br>    : <br> demo:7:24: 7:25 error: cannot borrow `x` as immutable because it is also borrowed as mutable <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> ^ <br> demo:7:20: 7:21 note: previous borrow of `x` occurs here; the mutable borrow prevents subsequent moves, borrows, or modification of `x` until the borrow ends <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> ^ <br> demo:7:26: 7:26 note: previous borrow ends here <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> <br>  ,             " <code>&amp;mut</code> "  " <code>&amp;</code> " ,   ,          ,   <code>&amp;mut</code> .            .  ,    ,      C99  <code>restrict</code>  (Rust  LLVM    ),    . <br> <br>   <br> <code class="cpp">#include &lt;vector&gt; int main() { std::vector&lt;int&gt; v; v.push_back(1); v.push_back(2); for(std::vector&lt;int&gt;::const_iterator it=v.begin(); it!=v.end(); ++it) { if (*it &lt; 5) v.push_back(5-*it); } }</code> <br>    ,    : <br> Segmentation fault (core dumped) <br> <br>    Rust: <br> <code class="rust">fn main() { let mut v: Vec&lt;int&gt; = Vec::new(); v.push(1); v.push(2); for x in v.iter() { if *x &lt; 5 { v.push(5-*x); } } }</code> <br>      ,  ,        : <br> demo:7:13: 7:14 error: cannot borrow `v` as mutable because it is also borrowed as immutable <br> demo:7 v.push(5-*x); <br> ^ <br> demo:5:14: 5:15 note: previous borrow of `v` occurs here; the immutable borrow prevents subsequent moves or mutable borrows of `v` until the borrow ends <br> demo:5 for x in v.iter() { <br> ^ <br> demo:10:2: 10:2 note: previous borrow ends here <br> demo:5 for x in v.iter() { <br> demo:6 if *x &lt; 5 { <br> demo:7 v.push(5-*x); <br> demo:8 } <br> demo:9 } <br> demo:10 } <br> <br> <br>  Switch <br> <code class="cpp">#include &lt;stdio.h&gt; enum {RED, BLUE, GRAY, UNKNOWN} color = GRAY; int main() { int x; switch(color) { case GRAY: x=1; case RED: case BLUE: x=2; } printf("%d", x); }</code> <br>   "2".  Rust          .  ,       ,    <code>break</code> .    Rust   : <br> <code class="rust">enum Color {RED, BLUE, GRAY, UNKNOWN} fn main() { let color = GRAY; let x = match color { GRAY =&gt; 1, RED | BLUE =&gt; 2, _ =&gt; 3, }; println!("{}", x); }</code> <br> <br>     <br> <code class="cpp">int main() { int pixels = 1; for (int j=0; j&lt;5; j++); pixels++; }</code> <br>  Rust          . , ,     . <br> <br>  <br> <code class="cpp">#include &lt;stdio.h&gt; #include &lt;pthread.h&gt; #include &lt;unistd.h&gt; class Resource { int *value; public: Resource(): value(NULL) {} ~Resource() {delete value;} int *acquire() { if (!value) { value = new int(0); } return value; } }; void* function(void *param) { int *value = ((Resource*)param)-&gt;acquire(); printf("resource: %p\n", (void*)value); return value; } int main() { Resource res; for (int i=0; i&lt;5; ++i) { pthread_t pt; pthread_create(&amp;pt, NULL, function, &amp;res); } //sleep(10); printf("done\n"); }</code> <br>     : <br> done <br> resource: 0x7f229c0008c0 <br> resource: 0x7f22840008c0 <br> resource: 0x7f228c0008c0 <br> resource: 0x7f22940008c0 <br> resource: 0x7f227c0008c0 <br> <br>     ,        .      Rust: <br> <code class="rust">struct Resource { value: Option&lt;int&gt;, } impl Resource { pub fn new() -&gt; Resource { Resource{ value: None } } pub fn acquire&lt;'a&gt;(&amp;'a mut self) -&gt; &amp;'a int { if self.value.is_none() { self.value = Some(1); } self.value.get_ref() } } fn main() { let mut res = Resource::new(); for _ in range(0,5) { spawn(proc() { let ptr = res.acquire(); println!("resource {}", ptr) }) } }</code> <br>  ,            . <br> demo:20:23: 20:26 error: cannot borrow immutable captured outer variable in a proc `res` as mutable <br> demo:20 let ptr = res.acquire(); <br> <br>      ,   : <br> <code class="rust">extern crate sync; use sync::{Arc, RWLock}; struct Resource { value: Option&lt;Box&lt;int&gt;&gt;, } impl Resource { pub fn new() -&gt; Resource { Resource{ value: None } } pub fn acquire(&amp;mut self) -&gt; *int { if self.value.is_none() { self.value = Some(box 1) } &amp;**self.value.get_ref() as *int } } fn main() { let arc_res = Arc::new(RWLock::new(Resource::new())); for _ in range(0,5) { let child_res = arc_res.clone(); spawn(proc() { let ptr = child_res.write().acquire(); println!("resource: {}", ptr) }) } }</code> <br>     <code>Arc</code> ( <i>Atomically Reference Counted</i> -        )  <code>RWLock</code> (   ).   : <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> <br>  ,   ++    .    . Rust        ,    .  ,   ,   .           ,       ( <a href="http://superwebdeveloper.com/2009/11/25/the-incredible-rate-of-diminishing-returns-of-fixing-software-bugs/">  </a> ). <br> <br>     <br> Rust        ,     <code>unsafe{}</code> .   ,     " <i> !  ,  .</i> ".  ,  ""  (    ,    )    .    ,           ( )  . , ,        <code>Cell</code>  <code>Mutex</code> .             ,       (   <a href="http://en.wikipedia.org/wiki/Test-driven_development">TDD</a> !). <br> <br>  <br> <a href="https://air.mozilla.org/guaranteeing-memory-safety-in-rust/">Guaranteeing Memory Safety in Rust (by Niko Matsakis)</a> <br> <a href="http://www.techtalkshub.com/rust-safe-systems-programming-fun-fp/">Rust: Safe Systems Programming with the Fun of FP (by Felix Klock II)</a> <br> <a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Keynote">Lang-NEXT: What ‚Äì if anything ‚Äì have we learned from C++? (by Bjarne Stroustrup)</a> <br> <a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Panel-Systems-Programming-Languages-in-2014-and-Beyond">Lang-NEXT Panel: Systems Programming in 2014 and Beyond</a></code></code> <pre> <code class="hljs rust"><code><code><code class="cpp"><span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>)     ,       (     ).        (std::rc::Rc)    (std::gc::Gc),      (   ). <br> <br></code>      <br>  ++: <br> #include &lt;stdio.h&gt; int *bar(int *p) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p; } int* foo(int n) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bar(&amp;n); } int main() { int *p1 = foo(<span class="hljs-number"><span class="hljs-number">1</span></span>); int *p2 = foo(<span class="hljs-number"><span class="hljs-number">2</span></span>); printf(<span class="hljs-string"><span class="hljs-string">"%d, %d\n"</span></span>, *p1, *p2); }</code> <br>  : <br> <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span> <br> <br>  Rust: <br> <code class="rust"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt;(p: &amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> int) -&gt; &amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> int { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>(n: int) -&gt; &amp;int { bar(&amp;n) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> p1 = foo(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> p2 = foo(<span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{}, {}"</span></span>, *p1, *p2); }</code> <br>  : <br> demo:<span class="hljs-number"><span class="hljs-number">5</span></span>:<span class="hljs-number"><span class="hljs-number">10</span></span>: <span class="hljs-number"><span class="hljs-number">5</span></span>:<span class="hljs-number"><span class="hljs-number">11</span></span> error: `n` does not live long enough <br> demo:<span class="hljs-number"><span class="hljs-number">5</span></span> bar(&amp;n) <br> ^ <br> demo:<span class="hljs-number"><span class="hljs-number">4</span></span>:<span class="hljs-number"><span class="hljs-number">24</span></span>: <span class="hljs-number"><span class="hljs-number">6</span></span>:<span class="hljs-number"><span class="hljs-number">2</span></span> note: reference must <span class="hljs-keyword"><span class="hljs-keyword">be</span></span> valid <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> the anonymous lifetime #<span class="hljs-number"><span class="hljs-number">1</span></span> defined on the block at <span class="hljs-number"><span class="hljs-number">4</span></span>:<span class="hljs-number"><span class="hljs-number">23</span></span>... <br> demo:<span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>(n: int) -&gt; &amp;int { <br> demo:<span class="hljs-number"><span class="hljs-number">5</span></span> bar(&amp;n) <br> demo:<span class="hljs-number"><span class="hljs-number">6</span></span> } <br> demo:<span class="hljs-number"><span class="hljs-number">4</span></span>:<span class="hljs-number"><span class="hljs-number">24</span></span>: <span class="hljs-number"><span class="hljs-number">6</span></span>:<span class="hljs-number"><span class="hljs-number">2</span></span> note: ...but borrowed value is only valid <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> the block at <span class="hljs-number"><span class="hljs-number">4</span></span>:<span class="hljs-number"><span class="hljs-number">23</span></span> <br> demo:<span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>(n: int) -&gt; &amp;int { <br> demo:<span class="hljs-number"><span class="hljs-number">5</span></span> bar(&amp;n) <br> demo:<span class="hljs-number"><span class="hljs-number">6</span></span> } <br> <br>   <br> <code class="cpp">#include &lt;stdio.h&gt; int minval(int *A, int n) { int currmin; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;n; i++) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (A[i] &lt; currmin) currmin = A[i]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> currmin; } int main() { int A[] = {<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>}; int min = minval(A,<span class="hljs-number"><span class="hljs-number">3</span></span>); printf(<span class="hljs-string"><span class="hljs-string">"%d\n"</span></span>, min); }</code> <br>   <span class="hljs-number"><span class="hljs-number">0</span></span>  ,     , ,  .       Rust ( - ): <br> <code class="rust"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">minval</span></span></span></span>(A: &amp;[int]) -&gt; int { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> currmin; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> a <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> A.iter() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> *a &lt; currmin { currmin = *a; } } currmin } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> A = [<span class="hljs-number"><span class="hljs-number">1</span></span>i,<span class="hljs-number"><span class="hljs-number">2</span></span>i,<span class="hljs-number"><span class="hljs-number">3</span></span>i]; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> min = minval(A.as_slice()); <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{}"</span></span>, min); }</code> <br>  , : <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> of possibly uninitialized variable: `currmin` <br>   ( )      : <br> <code class="rust"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">minval</span></span></span></span>(A: &amp;[int]) -&gt; int { A.iter().fold(A[<span class="hljs-number"><span class="hljs-number">0</span></span>], |u,&amp;a| { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> a&lt;u {a} <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {u} }) }</code> <br> <br>    <br> <code class="cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span></span>{ int *x; A(int v): x(new int(v)) {} ~A() {delete x;} }; int main() { A a(<span class="hljs-number"><span class="hljs-number">1</span></span>), b=a; }</code> <br> ,    : <br> *** glibc detected *** demo: double free or corruption (fasttop): <span class="hljs-number"><span class="hljs-number">0x0000000000601010</span></span> *** <br> <br>     Rust: <br> <code class="rust"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span></span>{ x: <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;int&gt; } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> A { <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">new</span></span></span></span>(v: int) -&gt; A { A{ x: <span class="hljs-keyword"><span class="hljs-keyword">box</span></span> v } } } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Drop</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> A { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drop</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) {} <span class="hljs-comment"><span class="hljs-comment">// ,     ++ } fn main() { let a = A::new(1); let _b = a; }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">     .   ,     </span></span><code><span class="hljs-comment"><span class="hljs-comment">trait Copy</span></span></code><span class="hljs-comment"><span class="hljs-comment"> . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> Rust       .    </span></span><code><span class="hljs-comment"><span class="hljs-comment">Eq</span></span></code><span class="hljs-comment"><span class="hljs-comment">  </span></span><code><span class="hljs-comment"><span class="hljs-comment">Clone</span></span></code><span class="hljs-comment"><span class="hljs-comment"> ?    </span></span><code><span class="hljs-comment"><span class="hljs-comment">deriving</span></span></code><span class="hljs-comment"><span class="hljs-comment">   : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="rust"><span class="hljs-comment"><span class="hljs-comment">#[deriving(Clone, Eq, Hash, PartialEq, PartialOrd, Ord, Show)] struct A{ x: Box&lt;int&gt; }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">    </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="cpp"><span class="hljs-comment"><span class="hljs-comment">#include &lt;stdio.h&gt; struct X { int a, b; }; void swap_from(X&amp; x, const X&amp; y) { xa = yb; xb = ya; } int main() { X x = {1,2}; swap_from(x,x); printf("%d,%d\n", xa, xb); }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> 2,2 </span></span><br><span class="hljs-comment"><span class="hljs-comment">    ,    cc      .   ,   ,  99  </span></span><a href="http://en.wikipedia.org/wiki/Restrict"><span class="hljs-comment"><span class="hljs-comment">restrict</span></span></a><span class="hljs-comment"><span class="hljs-comment"> ,            :        . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">       Rust: </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="rust"><span class="hljs-comment"><span class="hljs-comment">struct X { pub a: int, pub b: int } fn swap_from(x: &amp;mut X, y: &amp;X) { xa = yb; xb = ya; } fn main() { let mut x = X{a:1, b:2}; swap_from(&amp;mut x, &amp;x); }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">    : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7:24: 7:25 error: cannot borrow `x` as immutable because it is also borrowed as mutable </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7 swap_from(&amp;mut x, &amp;x); </span></span><br><span class="hljs-comment"><span class="hljs-comment"> ^ </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7:20: 7:21 note: previous borrow of `x` occurs here; the mutable borrow prevents subsequent moves, borrows, or modification of `x` until the borrow ends </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7 swap_from(&amp;mut x, &amp;x); </span></span><br><span class="hljs-comment"><span class="hljs-comment"> ^ </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7:26: 7:26 note: previous borrow ends here </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7 swap_from(&amp;mut x, &amp;x); </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  ,             " </span></span><code><span class="hljs-comment"><span class="hljs-comment">&amp;mut</span></span></code><span class="hljs-comment"><span class="hljs-comment"> "  " </span></span><code><span class="hljs-comment"><span class="hljs-comment">&amp;</span></span></code><span class="hljs-comment"><span class="hljs-comment"> " ,   ,          ,   </span></span><code><span class="hljs-comment"><span class="hljs-comment">&amp;mut</span></span></code><span class="hljs-comment"><span class="hljs-comment"> .            .  ,    ,      C99  </span></span><code><span class="hljs-comment"><span class="hljs-comment">restrict</span></span></code><span class="hljs-comment"><span class="hljs-comment">  (Rust  LLVM    ),    . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">   </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="cpp"><span class="hljs-comment"><span class="hljs-comment">#include &lt;vector&gt; int main() { std::vector&lt;int&gt; v; v.push_back(1); v.push_back(2); for(std::vector&lt;int&gt;::const_iterator it=v.begin(); it!=v.end(); ++it) { if (*it &lt; 5) v.push_back(5-*it); } }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">    ,    : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> Segmentation fault (core dumped) </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">    Rust: </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="rust"><span class="hljs-comment"><span class="hljs-comment">fn main() { let mut v: Vec&lt;int&gt; = Vec::new(); v.push(1); v.push(2); for x in v.iter() { if *x &lt; 5 { v.push(5-*x); } } }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">      ,  ,        : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7:13: 7:14 error: cannot borrow `v` as mutable because it is also borrowed as immutable </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7 v.push(5-*x); </span></span><br><span class="hljs-comment"><span class="hljs-comment"> ^ </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:5:14: 5:15 note: previous borrow of `v` occurs here; the immutable borrow prevents subsequent moves or mutable borrows of `v` until the borrow ends </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:5 for x in v.iter() { </span></span><br><span class="hljs-comment"><span class="hljs-comment"> ^ </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:10:2: 10:2 note: previous borrow ends here </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:5 for x in v.iter() { </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:6 if *x &lt; 5 { </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7 v.push(5-*x); </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:8 } </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:9 } </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:10 } </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  Switch </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="cpp"><span class="hljs-comment"><span class="hljs-comment">#include &lt;stdio.h&gt; enum {RED, BLUE, GRAY, UNKNOWN} color = GRAY; int main() { int x; switch(color) { case GRAY: x=1; case RED: case BLUE: x=2; } printf("%d", x); }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">   "2".  Rust          .  ,       ,    </span></span><code><span class="hljs-comment"><span class="hljs-comment">break</span></span></code><span class="hljs-comment"><span class="hljs-comment"> .    Rust   : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="rust"><span class="hljs-comment"><span class="hljs-comment">enum Color {RED, BLUE, GRAY, UNKNOWN} fn main() { let color = GRAY; let x = match color { GRAY =&gt; 1, RED | BLUE =&gt; 2, _ =&gt; 3, }; println!("{}", x); }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">     </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="cpp"><span class="hljs-comment"><span class="hljs-comment">int main() { int pixels = 1; for (int j=0; j&lt;5; j++); pixels++; }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  Rust          . , ,     . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="cpp"><span class="hljs-comment"><span class="hljs-comment">#include &lt;stdio.h&gt; #include &lt;pthread.h&gt; #include &lt;unistd.h&gt; class Resource { int *value; public: Resource(): value(NULL) {} ~Resource() {delete value;} int *acquire() { if (!value) { value = new int(0); } return value; } }; void* function(void *param) { int *value = ((Resource*)param)-&gt;acquire(); printf("resource: %p\n", (void*)value); return value; } int main() { Resource res; for (int i=0; i&lt;5; ++i) { pthread_t pt; pthread_create(&amp;pt, NULL, function, &amp;res); } //sleep(10); printf("done\n"); }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">     : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> done </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7f229c0008c0 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7f22840008c0 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7f228c0008c0 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7f22940008c0 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7f227c0008c0 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">     ,        .      Rust: </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="rust"><span class="hljs-comment"><span class="hljs-comment">struct Resource { value: Option&lt;int&gt;, } impl Resource { pub fn new() -&gt; Resource { Resource{ value: None } } pub fn acquire&lt;'a&gt;(&amp;'a mut self) -&gt; &amp;'a int { if self.value.is_none() { self.value = Some(1); } self.value.get_ref() } } fn main() { let mut res = Resource::new(); for _ in range(0,5) { spawn(proc() { let ptr = res.acquire(); println!("resource {}", ptr) }) } }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  ,            . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:20:23: 20:26 error: cannot borrow immutable captured outer variable in a proc `res` as mutable </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:20 let ptr = res.acquire(); </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">      ,   : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="rust"><span class="hljs-comment"><span class="hljs-comment">extern crate sync; use sync::{Arc, RWLock}; struct Resource { value: Option&lt;Box&lt;int&gt;&gt;, } impl Resource { pub fn new() -&gt; Resource { Resource{ value: None } } pub fn acquire(&amp;mut self) -&gt; *int { if self.value.is_none() { self.value = Some(box 1) } &amp;**self.value.get_ref() as *int } } fn main() { let arc_res = Arc::new(RWLock::new(Resource::new())); for _ in range(0,5) { let child_res = arc_res.clone(); spawn(proc() { let ptr = child_res.write().acquire(); println!("resource: {}", ptr) }) } }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">     </span></span><code><span class="hljs-comment"><span class="hljs-comment">Arc</span></span></code><span class="hljs-comment"><span class="hljs-comment"> ( </span></span><i><span class="hljs-comment"><span class="hljs-comment">Atomically Reference Counted</span></span></i><span class="hljs-comment"><span class="hljs-comment"> -        )  </span></span><code><span class="hljs-comment"><span class="hljs-comment">RWLock</span></span></code><span class="hljs-comment"><span class="hljs-comment"> (   ).   : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7ff4b0010378 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7ff4b0010378 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7ff4b0010378 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7ff4b0010378 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7ff4b0010378 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  ,   ++    .    . Rust        ,    .  ,   ,   .           ,       ( </span></span><a href="http://superwebdeveloper.com/2009/11/25/the-incredible-rate-of-diminishing-returns-of-fixing-software-bugs/"><span class="hljs-comment"><span class="hljs-comment">  </span></span></a><span class="hljs-comment"><span class="hljs-comment"> ). </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">     </span></span><br><span class="hljs-comment"><span class="hljs-comment"> Rust        ,     </span></span><code><span class="hljs-comment"><span class="hljs-comment">unsafe{}</span></span></code><span class="hljs-comment"><span class="hljs-comment"> .   ,     " </span></span><i><span class="hljs-comment"><span class="hljs-comment"> !  ,  .</span></span></i><span class="hljs-comment"><span class="hljs-comment"> ".  ,  ""  (    ,    )    .    ,           ( )  . , ,        </span></span><code><span class="hljs-comment"><span class="hljs-comment">Cell</span></span></code><span class="hljs-comment"><span class="hljs-comment">  </span></span><code><span class="hljs-comment"><span class="hljs-comment">Mutex</span></span></code><span class="hljs-comment"><span class="hljs-comment"> .             ,       (   </span></span><a href="http://en.wikipedia.org/wiki/Test-driven_development"><span class="hljs-comment"><span class="hljs-comment">TDD</span></span></a><span class="hljs-comment"><span class="hljs-comment"> !). </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="https://air.mozilla.org/guaranteeing-memory-safety-in-rust/"><span class="hljs-comment"><span class="hljs-comment">Guaranteeing Memory Safety in Rust (by Niko Matsakis)</span></span></a><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="http://www.techtalkshub.com/rust-safe-systems-programming-fun-fp/"><span class="hljs-comment"><span class="hljs-comment">Rust: Safe Systems Programming with the Fun of FP (by Felix Klock II)</span></span></a><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Keynote"><span class="hljs-comment"><span class="hljs-comment">Lang-NEXT: What ‚Äì if anything ‚Äì have we learned from C++? (by Bjarne Stroustrup)</span></span></a><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Panel-Systems-Programming-Languages-in-2014-and-Beyond"><span class="hljs-comment"><span class="hljs-comment">Lang-NEXT Panel: Systems Programming in 2014 and Beyond</span></span></a></code></code> </pre> <code><code><code><code class="cpp">Box)     ,       (     ).        (std::rc::Rc)    (std::gc::Gc),      (   ). <br> <br></code>      <br>  ++: <br> #include &lt;stdio.h&gt; int *bar(int *p) { return p; } int* foo(int n) { return bar(&amp;n); } int main() { int *p1 = foo(1); int *p2 = foo(2); printf("%d, %d\n", *p1, *p2); }</code> <br>  : <br> 2, 2 <br> <br>  Rust: <br> <code class="rust">fn bar&lt;'a&gt;(p: &amp;'a int) -&gt; &amp;'a int { return p; } fn foo(n: int) -&gt; &amp;int { bar(&amp;n) } fn main() { let p1 = foo(1); let p2 = foo(2); println!("{}, {}", *p1, *p2); }</code> <br>  : <br> demo:5:10: 5:11 error: `n` does not live long enough <br> demo:5 bar(&amp;n) <br> ^ <br> demo:4:24: 6:2 note: reference must be valid for the anonymous lifetime #1 defined on the block at 4:23... <br> demo:4 fn foo(n: int) -&gt; &amp;int { <br> demo:5 bar(&amp;n) <br> demo:6 } <br> demo:4:24: 6:2 note: ...but borrowed value is only valid for the block at 4:23 <br> demo:4 fn foo(n: int) -&gt; &amp;int { <br> demo:5 bar(&amp;n) <br> demo:6 } <br> <br>   <br> <code class="cpp">#include &lt;stdio.h&gt; int minval(int *A, int n) { int currmin; for (int i=0; i&lt;n; i++) if (A[i] &lt; currmin) currmin = A[i]; return currmin; } int main() { int A[] = {1,2,3}; int min = minval(A,3); printf("%d\n", min); }</code> <br>   0  ,     , ,  .       Rust ( - ): <br> <code class="rust">fn minval(A: &amp;[int]) -&gt; int { let mut currmin; for a in A.iter() { if *a &lt; currmin { currmin = *a; } } currmin } fn main() { let A = [1i,2i,3i]; let min = minval(A.as_slice()); println!("{}", min); }</code> <br>  , : use of possibly uninitialized variable: `currmin` <br>   ( )      : <br> <code class="rust">fn minval(A: &amp;[int]) -&gt; int { A.iter().fold(A[0], |u,&amp;a| { if a&lt;u {a} else {u} }) }</code> <br> <br>    <br> <code class="cpp">struct A{ int *x; A(int v): x(new int(v)) {} ~A() {delete x;} }; int main() { A a(1), b=a; }</code> <br> ,    : <br> *** glibc detected *** demo: double free or corruption (fasttop): 0x0000000000601010 *** <br> <br>     Rust: <br> <code class="rust">struct A{ x: Box&lt;int&gt; } impl A { pub fn new(v: int) -&gt; A { A{ x: box v } } } impl Drop for A { fn drop(&amp;mut self) {} // ,     ++ } fn main() { let a = A::new(1); let _b = a; }</code> <br>     .   ,     <code>trait Copy</code> . <br> Rust       .    <code>Eq</code>  <code>Clone</code> ?    <code>deriving</code>   : <br> <code class="rust">#[deriving(Clone, Eq, Hash, PartialEq, PartialOrd, Ord, Show)] struct A{ x: Box&lt;int&gt; }</code> <br> <br>    <br> <code class="cpp">#include &lt;stdio.h&gt; struct X { int a, b; }; void swap_from(X&amp; x, const X&amp; y) { xa = yb; xb = ya; } int main() { X x = {1,2}; swap_from(x,x); printf("%d,%d\n", xa, xb); }</code> <br>  : <br> 2,2 <br>    ,    cc      .   ,   ,  99  <a href="http://en.wikipedia.org/wiki/Restrict">restrict</a> ,            :        . <br> <br>       Rust: <br> <code class="rust">struct X { pub a: int, pub b: int } fn swap_from(x: &amp;mut X, y: &amp;X) { xa = yb; xb = ya; } fn main() { let mut x = X{a:1, b:2}; swap_from(&amp;mut x, &amp;x); }</code> <br>    : <br> demo:7:24: 7:25 error: cannot borrow `x` as immutable because it is also borrowed as mutable <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> ^ <br> demo:7:20: 7:21 note: previous borrow of `x` occurs here; the mutable borrow prevents subsequent moves, borrows, or modification of `x` until the borrow ends <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> ^ <br> demo:7:26: 7:26 note: previous borrow ends here <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> <br>  ,             " <code>&amp;mut</code> "  " <code>&amp;</code> " ,   ,          ,   <code>&amp;mut</code> .            .  ,    ,      C99  <code>restrict</code>  (Rust  LLVM    ),    . <br> <br>   <br> <code class="cpp">#include &lt;vector&gt; int main() { std::vector&lt;int&gt; v; v.push_back(1); v.push_back(2); for(std::vector&lt;int&gt;::const_iterator it=v.begin(); it!=v.end(); ++it) { if (*it &lt; 5) v.push_back(5-*it); } }</code> <br>    ,    : <br> Segmentation fault (core dumped) <br> <br>    Rust: <br> <code class="rust">fn main() { let mut v: Vec&lt;int&gt; = Vec::new(); v.push(1); v.push(2); for x in v.iter() { if *x &lt; 5 { v.push(5-*x); } } }</code> <br>      ,  ,        : <br> demo:7:13: 7:14 error: cannot borrow `v` as mutable because it is also borrowed as immutable <br> demo:7 v.push(5-*x); <br> ^ <br> demo:5:14: 5:15 note: previous borrow of `v` occurs here; the immutable borrow prevents subsequent moves or mutable borrows of `v` until the borrow ends <br> demo:5 for x in v.iter() { <br> ^ <br> demo:10:2: 10:2 note: previous borrow ends here <br> demo:5 for x in v.iter() { <br> demo:6 if *x &lt; 5 { <br> demo:7 v.push(5-*x); <br> demo:8 } <br> demo:9 } <br> demo:10 } <br> <br> <br>  Switch <br> <code class="cpp">#include &lt;stdio.h&gt; enum {RED, BLUE, GRAY, UNKNOWN} color = GRAY; int main() { int x; switch(color) { case GRAY: x=1; case RED: case BLUE: x=2; } printf("%d", x); }</code> <br>   "2".  Rust          .  ,       ,    <code>break</code> .    Rust   : <br> <code class="rust">enum Color {RED, BLUE, GRAY, UNKNOWN} fn main() { let color = GRAY; let x = match color { GRAY =&gt; 1, RED | BLUE =&gt; 2, _ =&gt; 3, }; println!("{}", x); }</code> <br> <br>     <br> <code class="cpp">int main() { int pixels = 1; for (int j=0; j&lt;5; j++); pixels++; }</code> <br>  Rust          . , ,     . <br> <br>  <br> <code class="cpp">#include &lt;stdio.h&gt; #include &lt;pthread.h&gt; #include &lt;unistd.h&gt; class Resource { int *value; public: Resource(): value(NULL) {} ~Resource() {delete value;} int *acquire() { if (!value) { value = new int(0); } return value; } }; void* function(void *param) { int *value = ((Resource*)param)-&gt;acquire(); printf("resource: %p\n", (void*)value); return value; } int main() { Resource res; for (int i=0; i&lt;5; ++i) { pthread_t pt; pthread_create(&amp;pt, NULL, function, &amp;res); } //sleep(10); printf("done\n"); }</code> <br>     : <br> done <br> resource: 0x7f229c0008c0 <br> resource: 0x7f22840008c0 <br> resource: 0x7f228c0008c0 <br> resource: 0x7f22940008c0 <br> resource: 0x7f227c0008c0 <br> <br>     ,        .      Rust: <br> <code class="rust">struct Resource { value: Option&lt;int&gt;, } impl Resource { pub fn new() -&gt; Resource { Resource{ value: None } } pub fn acquire&lt;'a&gt;(&amp;'a mut self) -&gt; &amp;'a int { if self.value.is_none() { self.value = Some(1); } self.value.get_ref() } } fn main() { let mut res = Resource::new(); for _ in range(0,5) { spawn(proc() { let ptr = res.acquire(); println!("resource {}", ptr) }) } }</code> <br>  ,            . <br> demo:20:23: 20:26 error: cannot borrow immutable captured outer variable in a proc `res` as mutable <br> demo:20 let ptr = res.acquire(); <br> <br>      ,   : <br> <code class="rust">extern crate sync; use sync::{Arc, RWLock}; struct Resource { value: Option&lt;Box&lt;int&gt;&gt;, } impl Resource { pub fn new() -&gt; Resource { Resource{ value: None } } pub fn acquire(&amp;mut self) -&gt; *int { if self.value.is_none() { self.value = Some(box 1) } &amp;**self.value.get_ref() as *int } } fn main() { let arc_res = Arc::new(RWLock::new(Resource::new())); for _ in range(0,5) { let child_res = arc_res.clone(); spawn(proc() { let ptr = child_res.write().acquire(); println!("resource: {}", ptr) }) } }</code> <br>     <code>Arc</code> ( <i>Atomically Reference Counted</i> -        )  <code>RWLock</code> (   ).   : <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> <br>  ,   ++    .    . Rust        ,    .  ,   ,   .           ,       ( <a href="http://superwebdeveloper.com/2009/11/25/the-incredible-rate-of-diminishing-returns-of-fixing-software-bugs/">  </a> ). <br> <br>     <br> Rust        ,     <code>unsafe{}</code> .   ,     " <i> !  ,  .</i> ".  ,  ""  (    ,    )    .    ,           ( )  . , ,        <code>Cell</code>  <code>Mutex</code> .             ,       (   <a href="http://en.wikipedia.org/wiki/Test-driven_development">TDD</a> !). <br> <br>  <br> <a href="https://air.mozilla.org/guaranteeing-memory-safety-in-rust/">Guaranteeing Memory Safety in Rust (by Niko Matsakis)</a> <br> <a href="http://www.techtalkshub.com/rust-safe-systems-programming-fun-fp/">Rust: Safe Systems Programming with the Fun of FP (by Felix Klock II)</a> <br> <a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Keynote">Lang-NEXT: What ‚Äì if anything ‚Äì have we learned from C++? (by Bjarne Stroustrup)</a> <br> <a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Panel-Systems-Programming-Languages-in-2014-and-Beyond">Lang-NEXT Panel: Systems Programming in 2014 and Beyond</a></code></code> <h4> <code><code><code><code class="cpp">Box)     ,       (     ).        (std::rc::Rc)    (std::gc::Gc),      (   ). <br> <br></code>      <br>  ++: <br> #include &lt;stdio.h&gt; int *bar(int *p) { return p; } int* foo(int n) { return bar(&amp;n); } int main() { int *p1 = foo(1); int *p2 = foo(2); printf("%d, %d\n", *p1, *p2); }</code> <br>  : <br> 2, 2 <br> <br>  Rust: <br> <code class="rust">fn bar&lt;'a&gt;(p: &amp;'a int) -&gt; &amp;'a int { return p; } fn foo(n: int) -&gt; &amp;int { bar(&amp;n) } fn main() { let p1 = foo(1); let p2 = foo(2); println!("{}, {}", *p1, *p2); }</code> <br>  : <br> demo:5:10: 5:11 error: `n` does not live long enough <br> demo:5 bar(&amp;n) <br> ^ <br> demo:4:24: 6:2 note: reference must be valid for the anonymous lifetime #1 defined on the block at 4:23... <br> demo:4 fn foo(n: int) -&gt; &amp;int { <br> demo:5 bar(&amp;n) <br> demo:6 } <br> demo:4:24: 6:2 note: ...but borrowed value is only valid for the block at 4:23 <br> demo:4 fn foo(n: int) -&gt; &amp;int { <br> demo:5 bar(&amp;n) <br> demo:6 } <br> <br>   <br> <code class="cpp">#include &lt;stdio.h&gt; int minval(int *A, int n) { int currmin; for (int i=0; i&lt;n; i++) if (A[i] &lt; currmin) currmin = A[i]; return currmin; } int main() { int A[] = {1,2,3}; int min = minval(A,3); printf("%d\n", min); }</code> <br>   0  ,     , ,  .       Rust ( - ): <br> <code class="rust">fn minval(A: &amp;[int]) -&gt; int { let mut currmin; for a in A.iter() { if *a &lt; currmin { currmin = *a; } } currmin } fn main() { let A = [1i,2i,3i]; let min = minval(A.as_slice()); println!("{}", min); }</code> <br>  , : use of possibly uninitialized variable: `currmin` <br>   ( )      : <br> <code class="rust">fn minval(A: &amp;[int]) -&gt; int { A.iter().fold(A[0], |u,&amp;a| { if a&lt;u {a} else {u} }) }</code> <br> <br>    <br> <code class="cpp">struct A{ int *x; A(int v): x(new int(v)) {} ~A() {delete x;} }; int main() { A a(1), b=a; }</code> <br> ,    : <br> *** glibc detected *** demo: double free or corruption (fasttop): 0x0000000000601010 *** <br> <br>     Rust: <br> <code class="rust">struct A{ x: Box&lt;int&gt; } impl A { pub fn new(v: int) -&gt; A { A{ x: box v } } } impl Drop for A { fn drop(&amp;mut self) {} // ,     ++ } fn main() { let a = A::new(1); let _b = a; }</code> <br>     .   ,     <code>trait Copy</code> . <br> Rust       .    <code>Eq</code>  <code>Clone</code> ?    <code>deriving</code>   : <br> <code class="rust">#[deriving(Clone, Eq, Hash, PartialEq, PartialOrd, Ord, Show)] struct A{ x: Box&lt;int&gt; }</code> <br> <br>    <br> <code class="cpp">#include &lt;stdio.h&gt; struct X { int a, b; }; void swap_from(X&amp; x, const X&amp; y) { xa = yb; xb = ya; } int main() { X x = {1,2}; swap_from(x,x); printf("%d,%d\n", xa, xb); }</code> <br>  : <br> 2,2 <br>    ,    cc      .   ,   ,  99  <a href="http://en.wikipedia.org/wiki/Restrict">restrict</a> ,            :        . <br> <br>       Rust: <br> <code class="rust">struct X { pub a: int, pub b: int } fn swap_from(x: &amp;mut X, y: &amp;X) { xa = yb; xb = ya; } fn main() { let mut x = X{a:1, b:2}; swap_from(&amp;mut x, &amp;x); }</code> <br>    : <br> demo:7:24: 7:25 error: cannot borrow `x` as immutable because it is also borrowed as mutable <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> ^ <br> demo:7:20: 7:21 note: previous borrow of `x` occurs here; the mutable borrow prevents subsequent moves, borrows, or modification of `x` until the borrow ends <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> ^ <br> demo:7:26: 7:26 note: previous borrow ends here <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> <br>  ,             " <code>&amp;mut</code> "  " <code>&amp;</code> " ,   ,          ,   <code>&amp;mut</code> .            .  ,    ,      C99  <code>restrict</code>  (Rust  LLVM    ),    . <br> <br>   <br> <code class="cpp">#include &lt;vector&gt; int main() { std::vector&lt;int&gt; v; v.push_back(1); v.push_back(2); for(std::vector&lt;int&gt;::const_iterator it=v.begin(); it!=v.end(); ++it) { if (*it &lt; 5) v.push_back(5-*it); } }</code> <br>    ,    : <br> Segmentation fault (core dumped) <br> <br>    Rust: <br> <code class="rust">fn main() { let mut v: Vec&lt;int&gt; = Vec::new(); v.push(1); v.push(2); for x in v.iter() { if *x &lt; 5 { v.push(5-*x); } } }</code> <br>      ,  ,        : <br> demo:7:13: 7:14 error: cannot borrow `v` as mutable because it is also borrowed as immutable <br> demo:7 v.push(5-*x); <br> ^ <br> demo:5:14: 5:15 note: previous borrow of `v` occurs here; the immutable borrow prevents subsequent moves or mutable borrows of `v` until the borrow ends <br> demo:5 for x in v.iter() { <br> ^ <br> demo:10:2: 10:2 note: previous borrow ends here <br> demo:5 for x in v.iter() { <br> demo:6 if *x &lt; 5 { <br> demo:7 v.push(5-*x); <br> demo:8 } <br> demo:9 } <br> demo:10 } <br> <br> <br>  Switch <br> <code class="cpp">#include &lt;stdio.h&gt; enum {RED, BLUE, GRAY, UNKNOWN} color = GRAY; int main() { int x; switch(color) { case GRAY: x=1; case RED: case BLUE: x=2; } printf("%d", x); }</code> <br>   "2".  Rust          .  ,       ,    <code>break</code> .    Rust   : <br> <code class="rust">enum Color {RED, BLUE, GRAY, UNKNOWN} fn main() { let color = GRAY; let x = match color { GRAY =&gt; 1, RED | BLUE =&gt; 2, _ =&gt; 3, }; println!("{}", x); }</code> <br> <br>     <br> <code class="cpp">int main() { int pixels = 1; for (int j=0; j&lt;5; j++); pixels++; }</code> <br>  Rust          . , ,     . <br> <br>  <br> <code class="cpp">#include &lt;stdio.h&gt; #include &lt;pthread.h&gt; #include &lt;unistd.h&gt; class Resource { int *value; public: Resource(): value(NULL) {} ~Resource() {delete value;} int *acquire() { if (!value) { value = new int(0); } return value; } }; void* function(void *param) { int *value = ((Resource*)param)-&gt;acquire(); printf("resource: %p\n", (void*)value); return value; } int main() { Resource res; for (int i=0; i&lt;5; ++i) { pthread_t pt; pthread_create(&amp;pt, NULL, function, &amp;res); } //sleep(10); printf("done\n"); }</code> <br>     : <br> done <br> resource: 0x7f229c0008c0 <br> resource: 0x7f22840008c0 <br> resource: 0x7f228c0008c0 <br> resource: 0x7f22940008c0 <br> resource: 0x7f227c0008c0 <br> <br>     ,        .      Rust: <br> <code class="rust">struct Resource { value: Option&lt;int&gt;, } impl Resource { pub fn new() -&gt; Resource { Resource{ value: None } } pub fn acquire&lt;'a&gt;(&amp;'a mut self) -&gt; &amp;'a int { if self.value.is_none() { self.value = Some(1); } self.value.get_ref() } } fn main() { let mut res = Resource::new(); for _ in range(0,5) { spawn(proc() { let ptr = res.acquire(); println!("resource {}", ptr) }) } }</code> <br>  ,            . <br> demo:20:23: 20:26 error: cannot borrow immutable captured outer variable in a proc `res` as mutable <br> demo:20 let ptr = res.acquire(); <br> <br>      ,   : <br> <code class="rust">extern crate sync; use sync::{Arc, RWLock}; struct Resource { value: Option&lt;Box&lt;int&gt;&gt;, } impl Resource { pub fn new() -&gt; Resource { Resource{ value: None } } pub fn acquire(&amp;mut self) -&gt; *int { if self.value.is_none() { self.value = Some(box 1) } &amp;**self.value.get_ref() as *int } } fn main() { let arc_res = Arc::new(RWLock::new(Resource::new())); for _ in range(0,5) { let child_res = arc_res.clone(); spawn(proc() { let ptr = child_res.write().acquire(); println!("resource: {}", ptr) }) } }</code> <br>     <code>Arc</code> ( <i>Atomically Reference Counted</i> -        )  <code>RWLock</code> (   ).   : <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> <br>  ,   ++    .    . Rust        ,    .  ,   ,   .           ,       ( <a href="http://superwebdeveloper.com/2009/11/25/the-incredible-rate-of-diminishing-returns-of-fixing-software-bugs/">  </a> ). <br> <br>     <br> Rust        ,     <code>unsafe{}</code> .   ,     " <i> !  ,  .</i> ".  ,  ""  (    ,    )    .    ,           ( )  . , ,        <code>Cell</code>  <code>Mutex</code> .             ,       (   <a href="http://en.wikipedia.org/wiki/Test-driven_development">TDD</a> !). <br> <br>  <br> <a href="https://air.mozilla.org/guaranteeing-memory-safety-in-rust/">Guaranteeing Memory Safety in Rust (by Niko Matsakis)</a> <br> <a href="http://www.techtalkshub.com/rust-safe-systems-programming-fun-fp/">Rust: Safe Systems Programming with the Fun of FP (by Felix Klock II)</a> <br> <a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Keynote">Lang-NEXT: What ‚Äì if anything ‚Äì have we learned from C++? (by Bjarne Stroustrup)</a> <br> <a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Panel-Systems-Programming-Languages-in-2014-and-Beyond">Lang-NEXT Panel: Systems Programming in 2014 and Beyond</a></code></code> </h4> <code><code><code><code class="cpp">Box)     ,       (     ).        (std::rc::Rc)    (std::gc::Gc),      (   ). <br> <br></code>      <br>  ++: <br> #include &lt;stdio.h&gt; int *bar(int *p) { return p; } int* foo(int n) { return bar(&amp;n); } int main() { int *p1 = foo(1); int *p2 = foo(2); printf("%d, %d\n", *p1, *p2); }</code> <br>  : <br> 2, 2 <br> <br>  Rust: <br> <code class="rust">fn bar&lt;'a&gt;(p: &amp;'a int) -&gt; &amp;'a int { return p; } fn foo(n: int) -&gt; &amp;int { bar(&amp;n) } fn main() { let p1 = foo(1); let p2 = foo(2); println!("{}, {}", *p1, *p2); }</code> <br>  : <br> demo:5:10: 5:11 error: `n` does not live long enough <br> demo:5 bar(&amp;n) <br> ^ <br> demo:4:24: 6:2 note: reference must be valid for the anonymous lifetime #1 defined on the block at 4:23... <br> demo:4 fn foo(n: int) -&gt; &amp;int { <br> demo:5 bar(&amp;n) <br> demo:6 } <br> demo:4:24: 6:2 note: ...but borrowed value is only valid for the block at 4:23 <br> demo:4 fn foo(n: int) -&gt; &amp;int { <br> demo:5 bar(&amp;n) <br> demo:6 } <br> <br>   <br> <code class="cpp">#include &lt;stdio.h&gt; int minval(int *A, int n) { int currmin; for (int i=0; i&lt;n; i++) if (A[i] &lt; currmin) currmin = A[i]; return currmin; } int main() { int A[] = {1,2,3}; int min = minval(A,3); printf("%d\n", min); }</code> <br>   0  ,     , ,  .       Rust ( - ): <br> <code class="rust">fn minval(A: &amp;[int]) -&gt; int { let mut currmin; for a in A.iter() { if *a &lt; currmin { currmin = *a; } } currmin } fn main() { let A = [1i,2i,3i]; let min = minval(A.as_slice()); println!("{}", min); }</code> <br>  , : use of possibly uninitialized variable: `currmin` <br>   ( )      : <br> <code class="rust">fn minval(A: &amp;[int]) -&gt; int { A.iter().fold(A[0], |u,&amp;a| { if a&lt;u {a} else {u} }) }</code> <br> <br>    <br> <code class="cpp">struct A{ int *x; A(int v): x(new int(v)) {} ~A() {delete x;} }; int main() { A a(1), b=a; }</code> <br> ,    : <br> *** glibc detected *** demo: double free or corruption (fasttop): 0x0000000000601010 *** <br> <br>     Rust: <br> <code class="rust">struct A{ x: Box&lt;int&gt; } impl A { pub fn new(v: int) -&gt; A { A{ x: box v } } } impl Drop for A { fn drop(&amp;mut self) {} // ,     ++ } fn main() { let a = A::new(1); let _b = a; }</code> <br>     .   ,     <code>trait Copy</code> . <br> Rust       .    <code>Eq</code>  <code>Clone</code> ?    <code>deriving</code>   : <br> <code class="rust">#[deriving(Clone, Eq, Hash, PartialEq, PartialOrd, Ord, Show)] struct A{ x: Box&lt;int&gt; }</code> <br> <br>    <br> <code class="cpp">#include &lt;stdio.h&gt; struct X { int a, b; }; void swap_from(X&amp; x, const X&amp; y) { xa = yb; xb = ya; } int main() { X x = {1,2}; swap_from(x,x); printf("%d,%d\n", xa, xb); }</code> <br>  : <br> 2,2 <br>    ,    cc      .   ,   ,  99  <a href="http://en.wikipedia.org/wiki/Restrict">restrict</a> ,            :        . <br> <br>       Rust: <br> <code class="rust">struct X { pub a: int, pub b: int } fn swap_from(x: &amp;mut X, y: &amp;X) { xa = yb; xb = ya; } fn main() { let mut x = X{a:1, b:2}; swap_from(&amp;mut x, &amp;x); }</code> <br>    : <br> demo:7:24: 7:25 error: cannot borrow `x` as immutable because it is also borrowed as mutable <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> ^ <br> demo:7:20: 7:21 note: previous borrow of `x` occurs here; the mutable borrow prevents subsequent moves, borrows, or modification of `x` until the borrow ends <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> ^ <br> demo:7:26: 7:26 note: previous borrow ends here <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> <br>  ,             " <code>&amp;mut</code> "  " <code>&amp;</code> " ,   ,          ,   <code>&amp;mut</code> .            .  ,    ,      C99  <code>restrict</code>  (Rust  LLVM    ),    . <br> <br>   <br> <code class="cpp">#include &lt;vector&gt; int main() { std::vector&lt;int&gt; v; v.push_back(1); v.push_back(2); for(std::vector&lt;int&gt;::const_iterator it=v.begin(); it!=v.end(); ++it) { if (*it &lt; 5) v.push_back(5-*it); } }</code> <br>    ,    : <br> Segmentation fault (core dumped) <br> <br>    Rust: <br> <code class="rust">fn main() { let mut v: Vec&lt;int&gt; = Vec::new(); v.push(1); v.push(2); for x in v.iter() { if *x &lt; 5 { v.push(5-*x); } } }</code> <br>      ,  ,        : <br> demo:7:13: 7:14 error: cannot borrow `v` as mutable because it is also borrowed as immutable <br> demo:7 v.push(5-*x); <br> ^ <br> demo:5:14: 5:15 note: previous borrow of `v` occurs here; the immutable borrow prevents subsequent moves or mutable borrows of `v` until the borrow ends <br> demo:5 for x in v.iter() { <br> ^ <br> demo:10:2: 10:2 note: previous borrow ends here <br> demo:5 for x in v.iter() { <br> demo:6 if *x &lt; 5 { <br> demo:7 v.push(5-*x); <br> demo:8 } <br> demo:9 } <br> demo:10 } <br> <br> <br>  Switch <br> <code class="cpp">#include &lt;stdio.h&gt; enum {RED, BLUE, GRAY, UNKNOWN} color = GRAY; int main() { int x; switch(color) { case GRAY: x=1; case RED: case BLUE: x=2; } printf("%d", x); }</code> <br>   "2".  Rust          .  ,       ,    <code>break</code> .    Rust   : <br> <code class="rust">enum Color {RED, BLUE, GRAY, UNKNOWN} fn main() { let color = GRAY; let x = match color { GRAY =&gt; 1, RED | BLUE =&gt; 2, _ =&gt; 3, }; println!("{}", x); }</code> <br> <br>     <br> <code class="cpp">int main() { int pixels = 1; for (int j=0; j&lt;5; j++); pixels++; }</code> <br>  Rust          . , ,     . <br> <br>  <br> <code class="cpp">#include &lt;stdio.h&gt; #include &lt;pthread.h&gt; #include &lt;unistd.h&gt; class Resource { int *value; public: Resource(): value(NULL) {} ~Resource() {delete value;} int *acquire() { if (!value) { value = new int(0); } return value; } }; void* function(void *param) { int *value = ((Resource*)param)-&gt;acquire(); printf("resource: %p\n", (void*)value); return value; } int main() { Resource res; for (int i=0; i&lt;5; ++i) { pthread_t pt; pthread_create(&amp;pt, NULL, function, &amp;res); } //sleep(10); printf("done\n"); }</code> <br>     : <br> done <br> resource: 0x7f229c0008c0 <br> resource: 0x7f22840008c0 <br> resource: 0x7f228c0008c0 <br> resource: 0x7f22940008c0 <br> resource: 0x7f227c0008c0 <br> <br>     ,        .      Rust: <br> <code class="rust">struct Resource { value: Option&lt;int&gt;, } impl Resource { pub fn new() -&gt; Resource { Resource{ value: None } } pub fn acquire&lt;'a&gt;(&amp;'a mut self) -&gt; &amp;'a int { if self.value.is_none() { self.value = Some(1); } self.value.get_ref() } } fn main() { let mut res = Resource::new(); for _ in range(0,5) { spawn(proc() { let ptr = res.acquire(); println!("resource {}", ptr) }) } }</code> <br>  ,            . <br> demo:20:23: 20:26 error: cannot borrow immutable captured outer variable in a proc `res` as mutable <br> demo:20 let ptr = res.acquire(); <br> <br>      ,   : <br> <code class="rust">extern crate sync; use sync::{Arc, RWLock}; struct Resource { value: Option&lt;Box&lt;int&gt;&gt;, } impl Resource { pub fn new() -&gt; Resource { Resource{ value: None } } pub fn acquire(&amp;mut self) -&gt; *int { if self.value.is_none() { self.value = Some(box 1) } &amp;**self.value.get_ref() as *int } } fn main() { let arc_res = Arc::new(RWLock::new(Resource::new())); for _ in range(0,5) { let child_res = arc_res.clone(); spawn(proc() { let ptr = child_res.write().acquire(); println!("resource: {}", ptr) }) } }</code> <br>     <code>Arc</code> ( <i>Atomically Reference Counted</i> -        )  <code>RWLock</code> (   ).   : <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> <br>  ,   ++    .    . Rust        ,    .  ,   ,   .           ,       ( <a href="http://superwebdeveloper.com/2009/11/25/the-incredible-rate-of-diminishing-returns-of-fixing-software-bugs/">  </a> ). <br> <br>     <br> Rust        ,     <code>unsafe{}</code> .   ,     " <i> !  ,  .</i> ".  ,  ""  (    ,    )    .    ,           ( )  . , ,        <code>Cell</code>  <code>Mutex</code> .             ,       (   <a href="http://en.wikipedia.org/wiki/Test-driven_development">TDD</a> !). <br> <br>  <br> <a href="https://air.mozilla.org/guaranteeing-memory-safety-in-rust/">Guaranteeing Memory Safety in Rust (by Niko Matsakis)</a> <br> <a href="http://www.techtalkshub.com/rust-safe-systems-programming-fun-fp/">Rust: Safe Systems Programming with the Fun of FP (by Felix Klock II)</a> <br> <a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Keynote">Lang-NEXT: What ‚Äì if anything ‚Äì have we learned from C++? (by Bjarne Stroustrup)</a> <br> <a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Panel-Systems-Programming-Languages-in-2014-and-Beyond">Lang-NEXT Panel: Systems Programming in 2014 and Beyond</a></code></code> <pre> <code class="hljs rust"><code><code><code class="cpp"><span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>)     ,       (     ).        (std::rc::Rc)    (std::gc::Gc),      (   ). <br> <br></code>      <br>  ++: <br> #include &lt;stdio.h&gt; int *bar(int *p) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p; } int* foo(int n) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bar(&amp;n); } int main() { int *p1 = foo(<span class="hljs-number"><span class="hljs-number">1</span></span>); int *p2 = foo(<span class="hljs-number"><span class="hljs-number">2</span></span>); printf(<span class="hljs-string"><span class="hljs-string">"%d, %d\n"</span></span>, *p1, *p2); }</code> <br>  : <br> <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span> <br> <br>  Rust: <br> <code class="rust"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt;(p: &amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> int) -&gt; &amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> int { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>(n: int) -&gt; &amp;int { bar(&amp;n) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> p1 = foo(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> p2 = foo(<span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{}, {}"</span></span>, *p1, *p2); }</code> <br>  : <br> demo:<span class="hljs-number"><span class="hljs-number">5</span></span>:<span class="hljs-number"><span class="hljs-number">10</span></span>: <span class="hljs-number"><span class="hljs-number">5</span></span>:<span class="hljs-number"><span class="hljs-number">11</span></span> error: `n` does not live long enough <br> demo:<span class="hljs-number"><span class="hljs-number">5</span></span> bar(&amp;n) <br> ^ <br> demo:<span class="hljs-number"><span class="hljs-number">4</span></span>:<span class="hljs-number"><span class="hljs-number">24</span></span>: <span class="hljs-number"><span class="hljs-number">6</span></span>:<span class="hljs-number"><span class="hljs-number">2</span></span> note: reference must <span class="hljs-keyword"><span class="hljs-keyword">be</span></span> valid <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> the anonymous lifetime #<span class="hljs-number"><span class="hljs-number">1</span></span> defined on the block at <span class="hljs-number"><span class="hljs-number">4</span></span>:<span class="hljs-number"><span class="hljs-number">23</span></span>... <br> demo:<span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>(n: int) -&gt; &amp;int { <br> demo:<span class="hljs-number"><span class="hljs-number">5</span></span> bar(&amp;n) <br> demo:<span class="hljs-number"><span class="hljs-number">6</span></span> } <br> demo:<span class="hljs-number"><span class="hljs-number">4</span></span>:<span class="hljs-number"><span class="hljs-number">24</span></span>: <span class="hljs-number"><span class="hljs-number">6</span></span>:<span class="hljs-number"><span class="hljs-number">2</span></span> note: ...but borrowed value is only valid <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> the block at <span class="hljs-number"><span class="hljs-number">4</span></span>:<span class="hljs-number"><span class="hljs-number">23</span></span> <br> demo:<span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>(n: int) -&gt; &amp;int { <br> demo:<span class="hljs-number"><span class="hljs-number">5</span></span> bar(&amp;n) <br> demo:<span class="hljs-number"><span class="hljs-number">6</span></span> } <br> <br>   <br> <code class="cpp">#include &lt;stdio.h&gt; int minval(int *A, int n) { int currmin; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;n; i++) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (A[i] &lt; currmin) currmin = A[i]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> currmin; } int main() { int A[] = {<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>}; int min = minval(A,<span class="hljs-number"><span class="hljs-number">3</span></span>); printf(<span class="hljs-string"><span class="hljs-string">"%d\n"</span></span>, min); }</code> <br>   <span class="hljs-number"><span class="hljs-number">0</span></span>  ,     , ,  .       Rust ( - ): <br> <code class="rust"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">minval</span></span></span></span>(A: &amp;[int]) -&gt; int { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> currmin; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> a <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> A.iter() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> *a &lt; currmin { currmin = *a; } } currmin } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> A = [<span class="hljs-number"><span class="hljs-number">1</span></span>i,<span class="hljs-number"><span class="hljs-number">2</span></span>i,<span class="hljs-number"><span class="hljs-number">3</span></span>i]; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> min = minval(A.as_slice()); <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{}"</span></span>, min); }</code> <br>  , : <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> of possibly uninitialized variable: `currmin` <br>   ( )      : <br> <code class="rust"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">minval</span></span></span></span>(A: &amp;[int]) -&gt; int { A.iter().fold(A[<span class="hljs-number"><span class="hljs-number">0</span></span>], |u,&amp;a| { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> a&lt;u {a} <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {u} }) }</code> <br> <br>    <br> <code class="cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span></span>{ int *x; A(int v): x(new int(v)) {} ~A() {delete x;} }; int main() { A a(<span class="hljs-number"><span class="hljs-number">1</span></span>), b=a; }</code> <br> ,    : <br> *** glibc detected *** demo: double free or corruption (fasttop): <span class="hljs-number"><span class="hljs-number">0x0000000000601010</span></span> *** <br> <br>     Rust: <br> <code class="rust"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span></span>{ x: <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;int&gt; } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> A { <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">new</span></span></span></span>(v: int) -&gt; A { A{ x: <span class="hljs-keyword"><span class="hljs-keyword">box</span></span> v } } } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Drop</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> A { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drop</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) {} <span class="hljs-comment"><span class="hljs-comment">// ,     ++ } fn main() { let a = A::new(1); let _b = a; }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">     .   ,     </span></span><code><span class="hljs-comment"><span class="hljs-comment">trait Copy</span></span></code><span class="hljs-comment"><span class="hljs-comment"> . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> Rust       .    </span></span><code><span class="hljs-comment"><span class="hljs-comment">Eq</span></span></code><span class="hljs-comment"><span class="hljs-comment">  </span></span><code><span class="hljs-comment"><span class="hljs-comment">Clone</span></span></code><span class="hljs-comment"><span class="hljs-comment"> ?    </span></span><code><span class="hljs-comment"><span class="hljs-comment">deriving</span></span></code><span class="hljs-comment"><span class="hljs-comment">   : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="rust"><span class="hljs-comment"><span class="hljs-comment">#[deriving(Clone, Eq, Hash, PartialEq, PartialOrd, Ord, Show)] struct A{ x: Box&lt;int&gt; }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">    </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="cpp"><span class="hljs-comment"><span class="hljs-comment">#include &lt;stdio.h&gt; struct X { int a, b; }; void swap_from(X&amp; x, const X&amp; y) { xa = yb; xb = ya; } int main() { X x = {1,2}; swap_from(x,x); printf("%d,%d\n", xa, xb); }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> 2,2 </span></span><br><span class="hljs-comment"><span class="hljs-comment">    ,    cc      .   ,   ,  99  </span></span><a href="http://en.wikipedia.org/wiki/Restrict"><span class="hljs-comment"><span class="hljs-comment">restrict</span></span></a><span class="hljs-comment"><span class="hljs-comment"> ,            :        . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">       Rust: </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="rust"><span class="hljs-comment"><span class="hljs-comment">struct X { pub a: int, pub b: int } fn swap_from(x: &amp;mut X, y: &amp;X) { xa = yb; xb = ya; } fn main() { let mut x = X{a:1, b:2}; swap_from(&amp;mut x, &amp;x); }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">    : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7:24: 7:25 error: cannot borrow `x` as immutable because it is also borrowed as mutable </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7 swap_from(&amp;mut x, &amp;x); </span></span><br><span class="hljs-comment"><span class="hljs-comment"> ^ </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7:20: 7:21 note: previous borrow of `x` occurs here; the mutable borrow prevents subsequent moves, borrows, or modification of `x` until the borrow ends </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7 swap_from(&amp;mut x, &amp;x); </span></span><br><span class="hljs-comment"><span class="hljs-comment"> ^ </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7:26: 7:26 note: previous borrow ends here </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7 swap_from(&amp;mut x, &amp;x); </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  ,             " </span></span><code><span class="hljs-comment"><span class="hljs-comment">&amp;mut</span></span></code><span class="hljs-comment"><span class="hljs-comment"> "  " </span></span><code><span class="hljs-comment"><span class="hljs-comment">&amp;</span></span></code><span class="hljs-comment"><span class="hljs-comment"> " ,   ,          ,   </span></span><code><span class="hljs-comment"><span class="hljs-comment">&amp;mut</span></span></code><span class="hljs-comment"><span class="hljs-comment"> .            .  ,    ,      C99  </span></span><code><span class="hljs-comment"><span class="hljs-comment">restrict</span></span></code><span class="hljs-comment"><span class="hljs-comment">  (Rust  LLVM    ),    . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">   </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="cpp"><span class="hljs-comment"><span class="hljs-comment">#include &lt;vector&gt; int main() { std::vector&lt;int&gt; v; v.push_back(1); v.push_back(2); for(std::vector&lt;int&gt;::const_iterator it=v.begin(); it!=v.end(); ++it) { if (*it &lt; 5) v.push_back(5-*it); } }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">    ,    : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> Segmentation fault (core dumped) </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">    Rust: </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="rust"><span class="hljs-comment"><span class="hljs-comment">fn main() { let mut v: Vec&lt;int&gt; = Vec::new(); v.push(1); v.push(2); for x in v.iter() { if *x &lt; 5 { v.push(5-*x); } } }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">      ,  ,        : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7:13: 7:14 error: cannot borrow `v` as mutable because it is also borrowed as immutable </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7 v.push(5-*x); </span></span><br><span class="hljs-comment"><span class="hljs-comment"> ^ </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:5:14: 5:15 note: previous borrow of `v` occurs here; the immutable borrow prevents subsequent moves or mutable borrows of `v` until the borrow ends </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:5 for x in v.iter() { </span></span><br><span class="hljs-comment"><span class="hljs-comment"> ^ </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:10:2: 10:2 note: previous borrow ends here </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:5 for x in v.iter() { </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:6 if *x &lt; 5 { </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7 v.push(5-*x); </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:8 } </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:9 } </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:10 } </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  Switch </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="cpp"><span class="hljs-comment"><span class="hljs-comment">#include &lt;stdio.h&gt; enum {RED, BLUE, GRAY, UNKNOWN} color = GRAY; int main() { int x; switch(color) { case GRAY: x=1; case RED: case BLUE: x=2; } printf("%d", x); }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">   "2".  Rust          .  ,       ,    </span></span><code><span class="hljs-comment"><span class="hljs-comment">break</span></span></code><span class="hljs-comment"><span class="hljs-comment"> .    Rust   : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="rust"><span class="hljs-comment"><span class="hljs-comment">enum Color {RED, BLUE, GRAY, UNKNOWN} fn main() { let color = GRAY; let x = match color { GRAY =&gt; 1, RED | BLUE =&gt; 2, _ =&gt; 3, }; println!("{}", x); }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">     </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="cpp"><span class="hljs-comment"><span class="hljs-comment">int main() { int pixels = 1; for (int j=0; j&lt;5; j++); pixels++; }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  Rust          . , ,     . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="cpp"><span class="hljs-comment"><span class="hljs-comment">#include &lt;stdio.h&gt; #include &lt;pthread.h&gt; #include &lt;unistd.h&gt; class Resource { int *value; public: Resource(): value(NULL) {} ~Resource() {delete value;} int *acquire() { if (!value) { value = new int(0); } return value; } }; void* function(void *param) { int *value = ((Resource*)param)-&gt;acquire(); printf("resource: %p\n", (void*)value); return value; } int main() { Resource res; for (int i=0; i&lt;5; ++i) { pthread_t pt; pthread_create(&amp;pt, NULL, function, &amp;res); } //sleep(10); printf("done\n"); }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">     : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> done </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7f229c0008c0 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7f22840008c0 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7f228c0008c0 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7f22940008c0 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7f227c0008c0 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">     ,        .      Rust: </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="rust"><span class="hljs-comment"><span class="hljs-comment">struct Resource { value: Option&lt;int&gt;, } impl Resource { pub fn new() -&gt; Resource { Resource{ value: None } } pub fn acquire&lt;'a&gt;(&amp;'a mut self) -&gt; &amp;'a int { if self.value.is_none() { self.value = Some(1); } self.value.get_ref() } } fn main() { let mut res = Resource::new(); for _ in range(0,5) { spawn(proc() { let ptr = res.acquire(); println!("resource {}", ptr) }) } }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  ,            . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:20:23: 20:26 error: cannot borrow immutable captured outer variable in a proc `res` as mutable </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:20 let ptr = res.acquire(); </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">      ,   : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="rust"><span class="hljs-comment"><span class="hljs-comment">extern crate sync; use sync::{Arc, RWLock}; struct Resource { value: Option&lt;Box&lt;int&gt;&gt;, } impl Resource { pub fn new() -&gt; Resource { Resource{ value: None } } pub fn acquire(&amp;mut self) -&gt; *int { if self.value.is_none() { self.value = Some(box 1) } &amp;**self.value.get_ref() as *int } } fn main() { let arc_res = Arc::new(RWLock::new(Resource::new())); for _ in range(0,5) { let child_res = arc_res.clone(); spawn(proc() { let ptr = child_res.write().acquire(); println!("resource: {}", ptr) }) } }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">     </span></span><code><span class="hljs-comment"><span class="hljs-comment">Arc</span></span></code><span class="hljs-comment"><span class="hljs-comment"> ( </span></span><i><span class="hljs-comment"><span class="hljs-comment">Atomically Reference Counted</span></span></i><span class="hljs-comment"><span class="hljs-comment"> -        )  </span></span><code><span class="hljs-comment"><span class="hljs-comment">RWLock</span></span></code><span class="hljs-comment"><span class="hljs-comment"> (   ).   : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7ff4b0010378 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7ff4b0010378 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7ff4b0010378 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7ff4b0010378 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7ff4b0010378 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  ,   ++    .    . Rust        ,    .  ,   ,   .           ,       ( </span></span><a href="http://superwebdeveloper.com/2009/11/25/the-incredible-rate-of-diminishing-returns-of-fixing-software-bugs/"><span class="hljs-comment"><span class="hljs-comment">  </span></span></a><span class="hljs-comment"><span class="hljs-comment"> ). </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">     </span></span><br><span class="hljs-comment"><span class="hljs-comment"> Rust        ,     </span></span><code><span class="hljs-comment"><span class="hljs-comment">unsafe{}</span></span></code><span class="hljs-comment"><span class="hljs-comment"> .   ,     " </span></span><i><span class="hljs-comment"><span class="hljs-comment"> !  ,  .</span></span></i><span class="hljs-comment"><span class="hljs-comment"> ".  ,  ""  (    ,    )    .    ,           ( )  . , ,        </span></span><code><span class="hljs-comment"><span class="hljs-comment">Cell</span></span></code><span class="hljs-comment"><span class="hljs-comment">  </span></span><code><span class="hljs-comment"><span class="hljs-comment">Mutex</span></span></code><span class="hljs-comment"><span class="hljs-comment"> .             ,       (   </span></span><a href="http://en.wikipedia.org/wiki/Test-driven_development"><span class="hljs-comment"><span class="hljs-comment">TDD</span></span></a><span class="hljs-comment"><span class="hljs-comment"> !). </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="https://air.mozilla.org/guaranteeing-memory-safety-in-rust/"><span class="hljs-comment"><span class="hljs-comment">Guaranteeing Memory Safety in Rust (by Niko Matsakis)</span></span></a><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="http://www.techtalkshub.com/rust-safe-systems-programming-fun-fp/"><span class="hljs-comment"><span class="hljs-comment">Rust: Safe Systems Programming with the Fun of FP (by Felix Klock II)</span></span></a><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Keynote"><span class="hljs-comment"><span class="hljs-comment">Lang-NEXT: What ‚Äì if anything ‚Äì have we learned from C++? (by Bjarne Stroustrup)</span></span></a><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Panel-Systems-Programming-Languages-in-2014-and-Beyond"><span class="hljs-comment"><span class="hljs-comment">Lang-NEXT Panel: Systems Programming in 2014 and Beyond</span></span></a></code></code> </pre> <code><code><code><code class="cpp">Box)     ,       (     ).        (std::rc::Rc)    (std::gc::Gc),      (   ). <br> <br></code>      <br>  ++: <br> #include &lt;stdio.h&gt; int *bar(int *p) { return p; } int* foo(int n) { return bar(&amp;n); } int main() { int *p1 = foo(1); int *p2 = foo(2); printf("%d, %d\n", *p1, *p2); }</code> <br>  : <br> 2, 2 <br> <br>  Rust: <br> <code class="rust">fn bar&lt;'a&gt;(p: &amp;'a int) -&gt; &amp;'a int { return p; } fn foo(n: int) -&gt; &amp;int { bar(&amp;n) } fn main() { let p1 = foo(1); let p2 = foo(2); println!("{}, {}", *p1, *p2); }</code> <br>  : <br> demo:5:10: 5:11 error: `n` does not live long enough <br> demo:5 bar(&amp;n) <br> ^ <br> demo:4:24: 6:2 note: reference must be valid for the anonymous lifetime #1 defined on the block at 4:23... <br> demo:4 fn foo(n: int) -&gt; &amp;int { <br> demo:5 bar(&amp;n) <br> demo:6 } <br> demo:4:24: 6:2 note: ...but borrowed value is only valid for the block at 4:23 <br> demo:4 fn foo(n: int) -&gt; &amp;int { <br> demo:5 bar(&amp;n) <br> demo:6 } <br> <br>   <br> <code class="cpp">#include &lt;stdio.h&gt; int minval(int *A, int n) { int currmin; for (int i=0; i&lt;n; i++) if (A[i] &lt; currmin) currmin = A[i]; return currmin; } int main() { int A[] = {1,2,3}; int min = minval(A,3); printf("%d\n", min); }</code> <br>   0  ,     , ,  .       Rust ( - ): <br> <code class="rust">fn minval(A: &amp;[int]) -&gt; int { let mut currmin; for a in A.iter() { if *a &lt; currmin { currmin = *a; } } currmin } fn main() { let A = [1i,2i,3i]; let min = minval(A.as_slice()); println!("{}", min); }</code> <br>  , : use of possibly uninitialized variable: `currmin` <br>   ( )      : <br> <code class="rust">fn minval(A: &amp;[int]) -&gt; int { A.iter().fold(A[0], |u,&amp;a| { if a&lt;u {a} else {u} }) }</code> <br> <br>    <br> <code class="cpp">struct A{ int *x; A(int v): x(new int(v)) {} ~A() {delete x;} }; int main() { A a(1), b=a; }</code> <br> ,    : <br> *** glibc detected *** demo: double free or corruption (fasttop): 0x0000000000601010 *** <br> <br>     Rust: <br> <code class="rust">struct A{ x: Box&lt;int&gt; } impl A { pub fn new(v: int) -&gt; A { A{ x: box v } } } impl Drop for A { fn drop(&amp;mut self) {} // ,     ++ } fn main() { let a = A::new(1); let _b = a; }</code> <br>     .   ,     <code>trait Copy</code> . <br> Rust       .    <code>Eq</code>  <code>Clone</code> ?    <code>deriving</code>   : <br> <code class="rust">#[deriving(Clone, Eq, Hash, PartialEq, PartialOrd, Ord, Show)] struct A{ x: Box&lt;int&gt; }</code> <br> <br>    <br> <code class="cpp">#include &lt;stdio.h&gt; struct X { int a, b; }; void swap_from(X&amp; x, const X&amp; y) { xa = yb; xb = ya; } int main() { X x = {1,2}; swap_from(x,x); printf("%d,%d\n", xa, xb); }</code> <br>  : <br> 2,2 <br>    ,    cc      .   ,   ,  99  <a href="http://en.wikipedia.org/wiki/Restrict">restrict</a> ,            :        . <br> <br>       Rust: <br> <code class="rust">struct X { pub a: int, pub b: int } fn swap_from(x: &amp;mut X, y: &amp;X) { xa = yb; xb = ya; } fn main() { let mut x = X{a:1, b:2}; swap_from(&amp;mut x, &amp;x); }</code> <br>    : <br> demo:7:24: 7:25 error: cannot borrow `x` as immutable because it is also borrowed as mutable <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> ^ <br> demo:7:20: 7:21 note: previous borrow of `x` occurs here; the mutable borrow prevents subsequent moves, borrows, or modification of `x` until the borrow ends <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> ^ <br> demo:7:26: 7:26 note: previous borrow ends here <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> <br>  ,             " <code>&amp;mut</code> "  " <code>&amp;</code> " ,   ,          ,   <code>&amp;mut</code> .            .  ,    ,      C99  <code>restrict</code>  (Rust  LLVM    ),    . <br> <br>   <br> <code class="cpp">#include &lt;vector&gt; int main() { std::vector&lt;int&gt; v; v.push_back(1); v.push_back(2); for(std::vector&lt;int&gt;::const_iterator it=v.begin(); it!=v.end(); ++it) { if (*it &lt; 5) v.push_back(5-*it); } }</code> <br>    ,    : <br> Segmentation fault (core dumped) <br> <br>    Rust: <br> <code class="rust">fn main() { let mut v: Vec&lt;int&gt; = Vec::new(); v.push(1); v.push(2); for x in v.iter() { if *x &lt; 5 { v.push(5-*x); } } }</code> <br>      ,  ,        : <br> demo:7:13: 7:14 error: cannot borrow `v` as mutable because it is also borrowed as immutable <br> demo:7 v.push(5-*x); <br> ^ <br> demo:5:14: 5:15 note: previous borrow of `v` occurs here; the immutable borrow prevents subsequent moves or mutable borrows of `v` until the borrow ends <br> demo:5 for x in v.iter() { <br> ^ <br> demo:10:2: 10:2 note: previous borrow ends here <br> demo:5 for x in v.iter() { <br> demo:6 if *x &lt; 5 { <br> demo:7 v.push(5-*x); <br> demo:8 } <br> demo:9 } <br> demo:10 } <br> <br> <br>  Switch <br> <code class="cpp">#include &lt;stdio.h&gt; enum {RED, BLUE, GRAY, UNKNOWN} color = GRAY; int main() { int x; switch(color) { case GRAY: x=1; case RED: case BLUE: x=2; } printf("%d", x); }</code> <br>   "2".  Rust          .  ,       ,    <code>break</code> .    Rust   : <br> <code class="rust">enum Color {RED, BLUE, GRAY, UNKNOWN} fn main() { let color = GRAY; let x = match color { GRAY =&gt; 1, RED | BLUE =&gt; 2, _ =&gt; 3, }; println!("{}", x); }</code> <br> <br>     <br> <code class="cpp">int main() { int pixels = 1; for (int j=0; j&lt;5; j++); pixels++; }</code> <br>  Rust          . , ,     . <br> <br>  <br> <code class="cpp">#include &lt;stdio.h&gt; #include &lt;pthread.h&gt; #include &lt;unistd.h&gt; class Resource { int *value; public: Resource(): value(NULL) {} ~Resource() {delete value;} int *acquire() { if (!value) { value = new int(0); } return value; } }; void* function(void *param) { int *value = ((Resource*)param)-&gt;acquire(); printf("resource: %p\n", (void*)value); return value; } int main() { Resource res; for (int i=0; i&lt;5; ++i) { pthread_t pt; pthread_create(&amp;pt, NULL, function, &amp;res); } //sleep(10); printf("done\n"); }</code> <br>     : <br> done <br> resource: 0x7f229c0008c0 <br> resource: 0x7f22840008c0 <br> resource: 0x7f228c0008c0 <br> resource: 0x7f22940008c0 <br> resource: 0x7f227c0008c0 <br> <br>     ,        .      Rust: <br> <code class="rust">struct Resource { value: Option&lt;int&gt;, } impl Resource { pub fn new() -&gt; Resource { Resource{ value: None } } pub fn acquire&lt;'a&gt;(&amp;'a mut self) -&gt; &amp;'a int { if self.value.is_none() { self.value = Some(1); } self.value.get_ref() } } fn main() { let mut res = Resource::new(); for _ in range(0,5) { spawn(proc() { let ptr = res.acquire(); println!("resource {}", ptr) }) } }</code> <br>  ,            . <br> demo:20:23: 20:26 error: cannot borrow immutable captured outer variable in a proc `res` as mutable <br> demo:20 let ptr = res.acquire(); <br> <br>      ,   : <br> <code class="rust">extern crate sync; use sync::{Arc, RWLock}; struct Resource { value: Option&lt;Box&lt;int&gt;&gt;, } impl Resource { pub fn new() -&gt; Resource { Resource{ value: None } } pub fn acquire(&amp;mut self) -&gt; *int { if self.value.is_none() { self.value = Some(box 1) } &amp;**self.value.get_ref() as *int } } fn main() { let arc_res = Arc::new(RWLock::new(Resource::new())); for _ in range(0,5) { let child_res = arc_res.clone(); spawn(proc() { let ptr = child_res.write().acquire(); println!("resource: {}", ptr) }) } }</code> <br>     <code>Arc</code> ( <i>Atomically Reference Counted</i> -        )  <code>RWLock</code> (   ).   : <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> <br>  ,   ++    .    . Rust        ,    .  ,   ,   .           ,       ( <a href="http://superwebdeveloper.com/2009/11/25/the-incredible-rate-of-diminishing-returns-of-fixing-software-bugs/">  </a> ). <br> <br>     <br> Rust        ,     <code>unsafe{}</code> .   ,     " <i> !  ,  .</i> ".  ,  ""  (    ,    )    .    ,           ( )  . , ,        <code>Cell</code>  <code>Mutex</code> .             ,       (   <a href="http://en.wikipedia.org/wiki/Test-driven_development">TDD</a> !). <br> <br>  <br> <a href="https://air.mozilla.org/guaranteeing-memory-safety-in-rust/">Guaranteeing Memory Safety in Rust (by Niko Matsakis)</a> <br> <a href="http://www.techtalkshub.com/rust-safe-systems-programming-fun-fp/">Rust: Safe Systems Programming with the Fun of FP (by Felix Klock II)</a> <br> <a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Keynote">Lang-NEXT: What ‚Äì if anything ‚Äì have we learned from C++? (by Bjarne Stroustrup)</a> <br> <a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Panel-Systems-Programming-Languages-in-2014-and-Beyond">Lang-NEXT Panel: Systems Programming in 2014 and Beyond</a></code></code> <blockquote> <code><code><code><code class="cpp">Box)     ,       (     ).        (std::rc::Rc)    (std::gc::Gc),      (   ). <br> <br></code>      <br>  ++: <br> #include &lt;stdio.h&gt; int *bar(int *p) { return p; } int* foo(int n) { return bar(&amp;n); } int main() { int *p1 = foo(1); int *p2 = foo(2); printf("%d, %d\n", *p1, *p2); }</code> <br>  : <br> 2, 2 <br> <br>  Rust: <br> <code class="rust">fn bar&lt;'a&gt;(p: &amp;'a int) -&gt; &amp;'a int { return p; } fn foo(n: int) -&gt; &amp;int { bar(&amp;n) } fn main() { let p1 = foo(1); let p2 = foo(2); println!("{}, {}", *p1, *p2); }</code> <br>  : <br> demo:5:10: 5:11 error: `n` does not live long enough <br> demo:5 bar(&amp;n) <br> ^ <br> demo:4:24: 6:2 note: reference must be valid for the anonymous lifetime #1 defined on the block at 4:23... <br> demo:4 fn foo(n: int) -&gt; &amp;int { <br> demo:5 bar(&amp;n) <br> demo:6 } <br> demo:4:24: 6:2 note: ...but borrowed value is only valid for the block at 4:23 <br> demo:4 fn foo(n: int) -&gt; &amp;int { <br> demo:5 bar(&amp;n) <br> demo:6 } <br> <br>   <br> <code class="cpp">#include &lt;stdio.h&gt; int minval(int *A, int n) { int currmin; for (int i=0; i&lt;n; i++) if (A[i] &lt; currmin) currmin = A[i]; return currmin; } int main() { int A[] = {1,2,3}; int min = minval(A,3); printf("%d\n", min); }</code> <br>   0  ,     , ,  .       Rust ( - ): <br> <code class="rust">fn minval(A: &amp;[int]) -&gt; int { let mut currmin; for a in A.iter() { if *a &lt; currmin { currmin = *a; } } currmin } fn main() { let A = [1i,2i,3i]; let min = minval(A.as_slice()); println!("{}", min); }</code> <br>  , : use of possibly uninitialized variable: `currmin` <br>   ( )      : <br> <code class="rust">fn minval(A: &amp;[int]) -&gt; int { A.iter().fold(A[0], |u,&amp;a| { if a&lt;u {a} else {u} }) }</code> <br> <br>    <br> <code class="cpp">struct A{ int *x; A(int v): x(new int(v)) {} ~A() {delete x;} }; int main() { A a(1), b=a; }</code> <br> ,    : <br> *** glibc detected *** demo: double free or corruption (fasttop): 0x0000000000601010 *** <br> <br>     Rust: <br> <code class="rust">struct A{ x: Box&lt;int&gt; } impl A { pub fn new(v: int) -&gt; A { A{ x: box v } } } impl Drop for A { fn drop(&amp;mut self) {} // ,     ++ } fn main() { let a = A::new(1); let _b = a; }</code> <br>     .   ,     <code>trait Copy</code> . <br> Rust       .    <code>Eq</code>  <code>Clone</code> ?    <code>deriving</code>   : <br> <code class="rust">#[deriving(Clone, Eq, Hash, PartialEq, PartialOrd, Ord, Show)] struct A{ x: Box&lt;int&gt; }</code> <br> <br>    <br> <code class="cpp">#include &lt;stdio.h&gt; struct X { int a, b; }; void swap_from(X&amp; x, const X&amp; y) { xa = yb; xb = ya; } int main() { X x = {1,2}; swap_from(x,x); printf("%d,%d\n", xa, xb); }</code> <br>  : <br> 2,2 <br>    ,    cc      .   ,   ,  99  <a href="http://en.wikipedia.org/wiki/Restrict">restrict</a> ,            :        . <br> <br>       Rust: <br> <code class="rust">struct X { pub a: int, pub b: int } fn swap_from(x: &amp;mut X, y: &amp;X) { xa = yb; xb = ya; } fn main() { let mut x = X{a:1, b:2}; swap_from(&amp;mut x, &amp;x); }</code> <br>    : <br> demo:7:24: 7:25 error: cannot borrow `x` as immutable because it is also borrowed as mutable <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> ^ <br> demo:7:20: 7:21 note: previous borrow of `x` occurs here; the mutable borrow prevents subsequent moves, borrows, or modification of `x` until the borrow ends <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> ^ <br> demo:7:26: 7:26 note: previous borrow ends here <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> <br>  ,             " <code>&amp;mut</code> "  " <code>&amp;</code> " ,   ,          ,   <code>&amp;mut</code> .            .  ,    ,      C99  <code>restrict</code>  (Rust  LLVM    ),    . <br> <br>   <br> <code class="cpp">#include &lt;vector&gt; int main() { std::vector&lt;int&gt; v; v.push_back(1); v.push_back(2); for(std::vector&lt;int&gt;::const_iterator it=v.begin(); it!=v.end(); ++it) { if (*it &lt; 5) v.push_back(5-*it); } }</code> <br>    ,    : <br> Segmentation fault (core dumped) <br> <br>    Rust: <br> <code class="rust">fn main() { let mut v: Vec&lt;int&gt; = Vec::new(); v.push(1); v.push(2); for x in v.iter() { if *x &lt; 5 { v.push(5-*x); } } }</code> <br>      ,  ,        : <br> demo:7:13: 7:14 error: cannot borrow `v` as mutable because it is also borrowed as immutable <br> demo:7 v.push(5-*x); <br> ^ <br> demo:5:14: 5:15 note: previous borrow of `v` occurs here; the immutable borrow prevents subsequent moves or mutable borrows of `v` until the borrow ends <br> demo:5 for x in v.iter() { <br> ^ <br> demo:10:2: 10:2 note: previous borrow ends here <br> demo:5 for x in v.iter() { <br> demo:6 if *x &lt; 5 { <br> demo:7 v.push(5-*x); <br> demo:8 } <br> demo:9 } <br> demo:10 } <br> <br> <br>  Switch <br> <code class="cpp">#include &lt;stdio.h&gt; enum {RED, BLUE, GRAY, UNKNOWN} color = GRAY; int main() { int x; switch(color) { case GRAY: x=1; case RED: case BLUE: x=2; } printf("%d", x); }</code> <br>   "2".  Rust          .  ,       ,    <code>break</code> .    Rust   : <br> <code class="rust">enum Color {RED, BLUE, GRAY, UNKNOWN} fn main() { let color = GRAY; let x = match color { GRAY =&gt; 1, RED | BLUE =&gt; 2, _ =&gt; 3, }; println!("{}", x); }</code> <br> <br>     <br> <code class="cpp">int main() { int pixels = 1; for (int j=0; j&lt;5; j++); pixels++; }</code> <br>  Rust          . , ,     . <br> <br>  <br> <code class="cpp">#include &lt;stdio.h&gt; #include &lt;pthread.h&gt; #include &lt;unistd.h&gt; class Resource { int *value; public: Resource(): value(NULL) {} ~Resource() {delete value;} int *acquire() { if (!value) { value = new int(0); } return value; } }; void* function(void *param) { int *value = ((Resource*)param)-&gt;acquire(); printf("resource: %p\n", (void*)value); return value; } int main() { Resource res; for (int i=0; i&lt;5; ++i) { pthread_t pt; pthread_create(&amp;pt, NULL, function, &amp;res); } //sleep(10); printf("done\n"); }</code> <br>     : <br> done <br> resource: 0x7f229c0008c0 <br> resource: 0x7f22840008c0 <br> resource: 0x7f228c0008c0 <br> resource: 0x7f22940008c0 <br> resource: 0x7f227c0008c0 <br> <br>     ,        .      Rust: <br> <code class="rust">struct Resource { value: Option&lt;int&gt;, } impl Resource { pub fn new() -&gt; Resource { Resource{ value: None } } pub fn acquire&lt;'a&gt;(&amp;'a mut self) -&gt; &amp;'a int { if self.value.is_none() { self.value = Some(1); } self.value.get_ref() } } fn main() { let mut res = Resource::new(); for _ in range(0,5) { spawn(proc() { let ptr = res.acquire(); println!("resource {}", ptr) }) } }</code> <br>  ,            . <br> demo:20:23: 20:26 error: cannot borrow immutable captured outer variable in a proc `res` as mutable <br> demo:20 let ptr = res.acquire(); <br> <br>      ,   : <br> <code class="rust">extern crate sync; use sync::{Arc, RWLock}; struct Resource { value: Option&lt;Box&lt;int&gt;&gt;, } impl Resource { pub fn new() -&gt; Resource { Resource{ value: None } } pub fn acquire(&amp;mut self) -&gt; *int { if self.value.is_none() { self.value = Some(box 1) } &amp;**self.value.get_ref() as *int } } fn main() { let arc_res = Arc::new(RWLock::new(Resource::new())); for _ in range(0,5) { let child_res = arc_res.clone(); spawn(proc() { let ptr = child_res.write().acquire(); println!("resource: {}", ptr) }) } }</code> <br>     <code>Arc</code> ( <i>Atomically Reference Counted</i> -        )  <code>RWLock</code> (   ).   : <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> <br>  ,   ++    .    . Rust        ,    .  ,   ,   .           ,       ( <a href="http://superwebdeveloper.com/2009/11/25/the-incredible-rate-of-diminishing-returns-of-fixing-software-bugs/">  </a> ). <br> <br>     <br> Rust        ,     <code>unsafe{}</code> .   ,     " <i> !  ,  .</i> ".  ,  ""  (    ,    )    .    ,           ( )  . , ,        <code>Cell</code>  <code>Mutex</code> .             ,       (   <a href="http://en.wikipedia.org/wiki/Test-driven_development">TDD</a> !). <br> <br>  <br> <a href="https://air.mozilla.org/guaranteeing-memory-safety-in-rust/">Guaranteeing Memory Safety in Rust (by Niko Matsakis)</a> <br> <a href="http://www.techtalkshub.com/rust-safe-systems-programming-fun-fp/">Rust: Safe Systems Programming with the Fun of FP (by Felix Klock II)</a> <br> <a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Keynote">Lang-NEXT: What ‚Äì if anything ‚Äì have we learned from C++? (by Bjarne Stroustrup)</a> <br> <a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Panel-Systems-Programming-Languages-in-2014-and-Beyond">Lang-NEXT Panel: Systems Programming in 2014 and Beyond</a></code></code> </blockquote> <code><code><code><code class="cpp">Box)     ,       (     ).        (std::rc::Rc)    (std::gc::Gc),      (   ). <br> <br></code>      <br>  ++: <br> #include &lt;stdio.h&gt; int *bar(int *p) { return p; } int* foo(int n) { return bar(&amp;n); } int main() { int *p1 = foo(1); int *p2 = foo(2); printf("%d, %d\n", *p1, *p2); }</code> <br>  : <br> 2, 2 <br> <br>  Rust: <br> <code class="rust">fn bar&lt;'a&gt;(p: &amp;'a int) -&gt; &amp;'a int { return p; } fn foo(n: int) -&gt; &amp;int { bar(&amp;n) } fn main() { let p1 = foo(1); let p2 = foo(2); println!("{}, {}", *p1, *p2); }</code> <br>  : <br> demo:5:10: 5:11 error: `n` does not live long enough <br> demo:5 bar(&amp;n) <br> ^ <br> demo:4:24: 6:2 note: reference must be valid for the anonymous lifetime #1 defined on the block at 4:23... <br> demo:4 fn foo(n: int) -&gt; &amp;int { <br> demo:5 bar(&amp;n) <br> demo:6 } <br> demo:4:24: 6:2 note: ...but borrowed value is only valid for the block at 4:23 <br> demo:4 fn foo(n: int) -&gt; &amp;int { <br> demo:5 bar(&amp;n) <br> demo:6 } <br> <br>   <br> <code class="cpp">#include &lt;stdio.h&gt; int minval(int *A, int n) { int currmin; for (int i=0; i&lt;n; i++) if (A[i] &lt; currmin) currmin = A[i]; return currmin; } int main() { int A[] = {1,2,3}; int min = minval(A,3); printf("%d\n", min); }</code> <br>   0  ,     , ,  .       Rust ( - ): <br> <code class="rust">fn minval(A: &amp;[int]) -&gt; int { let mut currmin; for a in A.iter() { if *a &lt; currmin { currmin = *a; } } currmin } fn main() { let A = [1i,2i,3i]; let min = minval(A.as_slice()); println!("{}", min); }</code> <br>  , : use of possibly uninitialized variable: `currmin` <br>   ( )      : <br> <code class="rust">fn minval(A: &amp;[int]) -&gt; int { A.iter().fold(A[0], |u,&amp;a| { if a&lt;u {a} else {u} }) }</code> <br> <br>    <br> <code class="cpp">struct A{ int *x; A(int v): x(new int(v)) {} ~A() {delete x;} }; int main() { A a(1), b=a; }</code> <br> ,    : <br> *** glibc detected *** demo: double free or corruption (fasttop): 0x0000000000601010 *** <br> <br>     Rust: <br> <code class="rust">struct A{ x: Box&lt;int&gt; } impl A { pub fn new(v: int) -&gt; A { A{ x: box v } } } impl Drop for A { fn drop(&amp;mut self) {} // ,     ++ } fn main() { let a = A::new(1); let _b = a; }</code> <br>     .   ,     <code>trait Copy</code> . <br> Rust       .    <code>Eq</code>  <code>Clone</code> ?    <code>deriving</code>   : <br> <code class="rust">#[deriving(Clone, Eq, Hash, PartialEq, PartialOrd, Ord, Show)] struct A{ x: Box&lt;int&gt; }</code> <br> <br>    <br> <code class="cpp">#include &lt;stdio.h&gt; struct X { int a, b; }; void swap_from(X&amp; x, const X&amp; y) { xa = yb; xb = ya; } int main() { X x = {1,2}; swap_from(x,x); printf("%d,%d\n", xa, xb); }</code> <br>  : <br> 2,2 <br>    ,    cc      .   ,   ,  99  <a href="http://en.wikipedia.org/wiki/Restrict">restrict</a> ,            :        . <br> <br>       Rust: <br> <code class="rust">struct X { pub a: int, pub b: int } fn swap_from(x: &amp;mut X, y: &amp;X) { xa = yb; xb = ya; } fn main() { let mut x = X{a:1, b:2}; swap_from(&amp;mut x, &amp;x); }</code> <br>    : <br> demo:7:24: 7:25 error: cannot borrow `x` as immutable because it is also borrowed as mutable <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> ^ <br> demo:7:20: 7:21 note: previous borrow of `x` occurs here; the mutable borrow prevents subsequent moves, borrows, or modification of `x` until the borrow ends <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> ^ <br> demo:7:26: 7:26 note: previous borrow ends here <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> <br>  ,             " <code>&amp;mut</code> "  " <code>&amp;</code> " ,   ,          ,   <code>&amp;mut</code> .            .  ,    ,      C99  <code>restrict</code>  (Rust  LLVM    ),    . <br> <br>   <br> <code class="cpp">#include &lt;vector&gt; int main() { std::vector&lt;int&gt; v; v.push_back(1); v.push_back(2); for(std::vector&lt;int&gt;::const_iterator it=v.begin(); it!=v.end(); ++it) { if (*it &lt; 5) v.push_back(5-*it); } }</code> <br>    ,    : <br> Segmentation fault (core dumped) <br> <br>    Rust: <br> <code class="rust">fn main() { let mut v: Vec&lt;int&gt; = Vec::new(); v.push(1); v.push(2); for x in v.iter() { if *x &lt; 5 { v.push(5-*x); } } }</code> <br>      ,  ,        : <br> demo:7:13: 7:14 error: cannot borrow `v` as mutable because it is also borrowed as immutable <br> demo:7 v.push(5-*x); <br> ^ <br> demo:5:14: 5:15 note: previous borrow of `v` occurs here; the immutable borrow prevents subsequent moves or mutable borrows of `v` until the borrow ends <br> demo:5 for x in v.iter() { <br> ^ <br> demo:10:2: 10:2 note: previous borrow ends here <br> demo:5 for x in v.iter() { <br> demo:6 if *x &lt; 5 { <br> demo:7 v.push(5-*x); <br> demo:8 } <br> demo:9 } <br> demo:10 } <br> <br> <br>  Switch <br> <code class="cpp">#include &lt;stdio.h&gt; enum {RED, BLUE, GRAY, UNKNOWN} color = GRAY; int main() { int x; switch(color) { case GRAY: x=1; case RED: case BLUE: x=2; } printf("%d", x); }</code> <br>   "2".  Rust          .  ,       ,    <code>break</code> .    Rust   : <br> <code class="rust">enum Color {RED, BLUE, GRAY, UNKNOWN} fn main() { let color = GRAY; let x = match color { GRAY =&gt; 1, RED | BLUE =&gt; 2, _ =&gt; 3, }; println!("{}", x); }</code> <br> <br>     <br> <code class="cpp">int main() { int pixels = 1; for (int j=0; j&lt;5; j++); pixels++; }</code> <br>  Rust          . , ,     . <br> <br>  <br> <code class="cpp">#include &lt;stdio.h&gt; #include &lt;pthread.h&gt; #include &lt;unistd.h&gt; class Resource { int *value; public: Resource(): value(NULL) {} ~Resource() {delete value;} int *acquire() { if (!value) { value = new int(0); } return value; } }; void* function(void *param) { int *value = ((Resource*)param)-&gt;acquire(); printf("resource: %p\n", (void*)value); return value; } int main() { Resource res; for (int i=0; i&lt;5; ++i) { pthread_t pt; pthread_create(&amp;pt, NULL, function, &amp;res); } //sleep(10); printf("done\n"); }</code> <br>     : <br> done <br> resource: 0x7f229c0008c0 <br> resource: 0x7f22840008c0 <br> resource: 0x7f228c0008c0 <br> resource: 0x7f22940008c0 <br> resource: 0x7f227c0008c0 <br> <br>     ,        .      Rust: <br> <code class="rust">struct Resource { value: Option&lt;int&gt;, } impl Resource { pub fn new() -&gt; Resource { Resource{ value: None } } pub fn acquire&lt;'a&gt;(&amp;'a mut self) -&gt; &amp;'a int { if self.value.is_none() { self.value = Some(1); } self.value.get_ref() } } fn main() { let mut res = Resource::new(); for _ in range(0,5) { spawn(proc() { let ptr = res.acquire(); println!("resource {}", ptr) }) } }</code> <br>  ,            . <br> demo:20:23: 20:26 error: cannot borrow immutable captured outer variable in a proc `res` as mutable <br> demo:20 let ptr = res.acquire(); <br> <br>      ,   : <br> <code class="rust">extern crate sync; use sync::{Arc, RWLock}; struct Resource { value: Option&lt;Box&lt;int&gt;&gt;, } impl Resource { pub fn new() -&gt; Resource { Resource{ value: None } } pub fn acquire(&amp;mut self) -&gt; *int { if self.value.is_none() { self.value = Some(box 1) } &amp;**self.value.get_ref() as *int } } fn main() { let arc_res = Arc::new(RWLock::new(Resource::new())); for _ in range(0,5) { let child_res = arc_res.clone(); spawn(proc() { let ptr = child_res.write().acquire(); println!("resource: {}", ptr) }) } }</code> <br>     <code>Arc</code> ( <i>Atomically Reference Counted</i> -        )  <code>RWLock</code> (   ).   : <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> <br>  ,   ++    .    . Rust        ,    .  ,   ,   .           ,       ( <a href="http://superwebdeveloper.com/2009/11/25/the-incredible-rate-of-diminishing-returns-of-fixing-software-bugs/">  </a> ). <br> <br>     <br> Rust        ,     <code>unsafe{}</code> .   ,     " <i> !  ,  .</i> ".  ,  ""  (    ,    )    .    ,           ( )  . , ,        <code>Cell</code>  <code>Mutex</code> .             ,       (   <a href="http://en.wikipedia.org/wiki/Test-driven_development">TDD</a> !). <br> <br>  <br> <a href="https://air.mozilla.org/guaranteeing-memory-safety-in-rust/">Guaranteeing Memory Safety in Rust (by Niko Matsakis)</a> <br> <a href="http://www.techtalkshub.com/rust-safe-systems-programming-fun-fp/">Rust: Safe Systems Programming with the Fun of FP (by Felix Klock II)</a> <br> <a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Keynote">Lang-NEXT: What ‚Äì if anything ‚Äì have we learned from C++? (by Bjarne Stroustrup)</a> <br> <a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Panel-Systems-Programming-Languages-in-2014-and-Beyond">Lang-NEXT Panel: Systems Programming in 2014 and Beyond</a></code></code> <pre> <code class="hljs rust"><code><code><code class="cpp"><span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>)     ,       (     ).        (std::rc::Rc)    (std::gc::Gc),      (   ). <br> <br></code>      <br>  ++: <br> #include &lt;stdio.h&gt; int *bar(int *p) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p; } int* foo(int n) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bar(&amp;n); } int main() { int *p1 = foo(<span class="hljs-number"><span class="hljs-number">1</span></span>); int *p2 = foo(<span class="hljs-number"><span class="hljs-number">2</span></span>); printf(<span class="hljs-string"><span class="hljs-string">"%d, %d\n"</span></span>, *p1, *p2); }</code> <br>  : <br> <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span> <br> <br>  Rust: <br> <code class="rust"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt;(p: &amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> int) -&gt; &amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> int { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>(n: int) -&gt; &amp;int { bar(&amp;n) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> p1 = foo(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> p2 = foo(<span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{}, {}"</span></span>, *p1, *p2); }</code> <br>  : <br> demo:<span class="hljs-number"><span class="hljs-number">5</span></span>:<span class="hljs-number"><span class="hljs-number">10</span></span>: <span class="hljs-number"><span class="hljs-number">5</span></span>:<span class="hljs-number"><span class="hljs-number">11</span></span> error: `n` does not live long enough <br> demo:<span class="hljs-number"><span class="hljs-number">5</span></span> bar(&amp;n) <br> ^ <br> demo:<span class="hljs-number"><span class="hljs-number">4</span></span>:<span class="hljs-number"><span class="hljs-number">24</span></span>: <span class="hljs-number"><span class="hljs-number">6</span></span>:<span class="hljs-number"><span class="hljs-number">2</span></span> note: reference must <span class="hljs-keyword"><span class="hljs-keyword">be</span></span> valid <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> the anonymous lifetime #<span class="hljs-number"><span class="hljs-number">1</span></span> defined on the block at <span class="hljs-number"><span class="hljs-number">4</span></span>:<span class="hljs-number"><span class="hljs-number">23</span></span>... <br> demo:<span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>(n: int) -&gt; &amp;int { <br> demo:<span class="hljs-number"><span class="hljs-number">5</span></span> bar(&amp;n) <br> demo:<span class="hljs-number"><span class="hljs-number">6</span></span> } <br> demo:<span class="hljs-number"><span class="hljs-number">4</span></span>:<span class="hljs-number"><span class="hljs-number">24</span></span>: <span class="hljs-number"><span class="hljs-number">6</span></span>:<span class="hljs-number"><span class="hljs-number">2</span></span> note: ...but borrowed value is only valid <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> the block at <span class="hljs-number"><span class="hljs-number">4</span></span>:<span class="hljs-number"><span class="hljs-number">23</span></span> <br> demo:<span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>(n: int) -&gt; &amp;int { <br> demo:<span class="hljs-number"><span class="hljs-number">5</span></span> bar(&amp;n) <br> demo:<span class="hljs-number"><span class="hljs-number">6</span></span> } <br> <br>   <br> <code class="cpp">#include &lt;stdio.h&gt; int minval(int *A, int n) { int currmin; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;n; i++) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (A[i] &lt; currmin) currmin = A[i]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> currmin; } int main() { int A[] = {<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>}; int min = minval(A,<span class="hljs-number"><span class="hljs-number">3</span></span>); printf(<span class="hljs-string"><span class="hljs-string">"%d\n"</span></span>, min); }</code> <br>   <span class="hljs-number"><span class="hljs-number">0</span></span>  ,     , ,  .       Rust ( - ): <br> <code class="rust"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">minval</span></span></span></span>(A: &amp;[int]) -&gt; int { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> currmin; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> a <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> A.iter() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> *a &lt; currmin { currmin = *a; } } currmin } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> A = [<span class="hljs-number"><span class="hljs-number">1</span></span>i,<span class="hljs-number"><span class="hljs-number">2</span></span>i,<span class="hljs-number"><span class="hljs-number">3</span></span>i]; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> min = minval(A.as_slice()); <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{}"</span></span>, min); }</code> <br>  , : <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> of possibly uninitialized variable: `currmin` <br>   ( )      : <br> <code class="rust"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">minval</span></span></span></span>(A: &amp;[int]) -&gt; int { A.iter().fold(A[<span class="hljs-number"><span class="hljs-number">0</span></span>], |u,&amp;a| { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> a&lt;u {a} <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {u} }) }</code> <br> <br>    <br> <code class="cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span></span>{ int *x; A(int v): x(new int(v)) {} ~A() {delete x;} }; int main() { A a(<span class="hljs-number"><span class="hljs-number">1</span></span>), b=a; }</code> <br> ,    : <br> *** glibc detected *** demo: double free or corruption (fasttop): <span class="hljs-number"><span class="hljs-number">0x0000000000601010</span></span> *** <br> <br>     Rust: <br> <code class="rust"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span></span>{ x: <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;int&gt; } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> A { <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">new</span></span></span></span>(v: int) -&gt; A { A{ x: <span class="hljs-keyword"><span class="hljs-keyword">box</span></span> v } } } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Drop</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> A { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drop</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) {} <span class="hljs-comment"><span class="hljs-comment">// ,     ++ } fn main() { let a = A::new(1); let _b = a; }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">     .   ,     </span></span><code><span class="hljs-comment"><span class="hljs-comment">trait Copy</span></span></code><span class="hljs-comment"><span class="hljs-comment"> . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> Rust       .    </span></span><code><span class="hljs-comment"><span class="hljs-comment">Eq</span></span></code><span class="hljs-comment"><span class="hljs-comment">  </span></span><code><span class="hljs-comment"><span class="hljs-comment">Clone</span></span></code><span class="hljs-comment"><span class="hljs-comment"> ?    </span></span><code><span class="hljs-comment"><span class="hljs-comment">deriving</span></span></code><span class="hljs-comment"><span class="hljs-comment">   : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="rust"><span class="hljs-comment"><span class="hljs-comment">#[deriving(Clone, Eq, Hash, PartialEq, PartialOrd, Ord, Show)] struct A{ x: Box&lt;int&gt; }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">    </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="cpp"><span class="hljs-comment"><span class="hljs-comment">#include &lt;stdio.h&gt; struct X { int a, b; }; void swap_from(X&amp; x, const X&amp; y) { xa = yb; xb = ya; } int main() { X x = {1,2}; swap_from(x,x); printf("%d,%d\n", xa, xb); }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> 2,2 </span></span><br><span class="hljs-comment"><span class="hljs-comment">    ,    cc      .   ,   ,  99  </span></span><a href="http://en.wikipedia.org/wiki/Restrict"><span class="hljs-comment"><span class="hljs-comment">restrict</span></span></a><span class="hljs-comment"><span class="hljs-comment"> ,            :        . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">       Rust: </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="rust"><span class="hljs-comment"><span class="hljs-comment">struct X { pub a: int, pub b: int } fn swap_from(x: &amp;mut X, y: &amp;X) { xa = yb; xb = ya; } fn main() { let mut x = X{a:1, b:2}; swap_from(&amp;mut x, &amp;x); }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">    : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7:24: 7:25 error: cannot borrow `x` as immutable because it is also borrowed as mutable </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7 swap_from(&amp;mut x, &amp;x); </span></span><br><span class="hljs-comment"><span class="hljs-comment"> ^ </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7:20: 7:21 note: previous borrow of `x` occurs here; the mutable borrow prevents subsequent moves, borrows, or modification of `x` until the borrow ends </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7 swap_from(&amp;mut x, &amp;x); </span></span><br><span class="hljs-comment"><span class="hljs-comment"> ^ </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7:26: 7:26 note: previous borrow ends here </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7 swap_from(&amp;mut x, &amp;x); </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  ,             " </span></span><code><span class="hljs-comment"><span class="hljs-comment">&amp;mut</span></span></code><span class="hljs-comment"><span class="hljs-comment"> "  " </span></span><code><span class="hljs-comment"><span class="hljs-comment">&amp;</span></span></code><span class="hljs-comment"><span class="hljs-comment"> " ,   ,          ,   </span></span><code><span class="hljs-comment"><span class="hljs-comment">&amp;mut</span></span></code><span class="hljs-comment"><span class="hljs-comment"> .            .  ,    ,      C99  </span></span><code><span class="hljs-comment"><span class="hljs-comment">restrict</span></span></code><span class="hljs-comment"><span class="hljs-comment">  (Rust  LLVM    ),    . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">   </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="cpp"><span class="hljs-comment"><span class="hljs-comment">#include &lt;vector&gt; int main() { std::vector&lt;int&gt; v; v.push_back(1); v.push_back(2); for(std::vector&lt;int&gt;::const_iterator it=v.begin(); it!=v.end(); ++it) { if (*it &lt; 5) v.push_back(5-*it); } }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">    ,    : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> Segmentation fault (core dumped) </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">    Rust: </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="rust"><span class="hljs-comment"><span class="hljs-comment">fn main() { let mut v: Vec&lt;int&gt; = Vec::new(); v.push(1); v.push(2); for x in v.iter() { if *x &lt; 5 { v.push(5-*x); } } }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">      ,  ,        : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7:13: 7:14 error: cannot borrow `v` as mutable because it is also borrowed as immutable </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7 v.push(5-*x); </span></span><br><span class="hljs-comment"><span class="hljs-comment"> ^ </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:5:14: 5:15 note: previous borrow of `v` occurs here; the immutable borrow prevents subsequent moves or mutable borrows of `v` until the borrow ends </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:5 for x in v.iter() { </span></span><br><span class="hljs-comment"><span class="hljs-comment"> ^ </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:10:2: 10:2 note: previous borrow ends here </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:5 for x in v.iter() { </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:6 if *x &lt; 5 { </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7 v.push(5-*x); </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:8 } </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:9 } </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:10 } </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  Switch </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="cpp"><span class="hljs-comment"><span class="hljs-comment">#include &lt;stdio.h&gt; enum {RED, BLUE, GRAY, UNKNOWN} color = GRAY; int main() { int x; switch(color) { case GRAY: x=1; case RED: case BLUE: x=2; } printf("%d", x); }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">   "2".  Rust          .  ,       ,    </span></span><code><span class="hljs-comment"><span class="hljs-comment">break</span></span></code><span class="hljs-comment"><span class="hljs-comment"> .    Rust   : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="rust"><span class="hljs-comment"><span class="hljs-comment">enum Color {RED, BLUE, GRAY, UNKNOWN} fn main() { let color = GRAY; let x = match color { GRAY =&gt; 1, RED | BLUE =&gt; 2, _ =&gt; 3, }; println!("{}", x); }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">     </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="cpp"><span class="hljs-comment"><span class="hljs-comment">int main() { int pixels = 1; for (int j=0; j&lt;5; j++); pixels++; }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  Rust          . , ,     . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="cpp"><span class="hljs-comment"><span class="hljs-comment">#include &lt;stdio.h&gt; #include &lt;pthread.h&gt; #include &lt;unistd.h&gt; class Resource { int *value; public: Resource(): value(NULL) {} ~Resource() {delete value;} int *acquire() { if (!value) { value = new int(0); } return value; } }; void* function(void *param) { int *value = ((Resource*)param)-&gt;acquire(); printf("resource: %p\n", (void*)value); return value; } int main() { Resource res; for (int i=0; i&lt;5; ++i) { pthread_t pt; pthread_create(&amp;pt, NULL, function, &amp;res); } //sleep(10); printf("done\n"); }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">     : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> done </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7f229c0008c0 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7f22840008c0 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7f228c0008c0 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7f22940008c0 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7f227c0008c0 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">     ,        .      Rust: </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="rust"><span class="hljs-comment"><span class="hljs-comment">struct Resource { value: Option&lt;int&gt;, } impl Resource { pub fn new() -&gt; Resource { Resource{ value: None } } pub fn acquire&lt;'a&gt;(&amp;'a mut self) -&gt; &amp;'a int { if self.value.is_none() { self.value = Some(1); } self.value.get_ref() } } fn main() { let mut res = Resource::new(); for _ in range(0,5) { spawn(proc() { let ptr = res.acquire(); println!("resource {}", ptr) }) } }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  ,            . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:20:23: 20:26 error: cannot borrow immutable captured outer variable in a proc `res` as mutable </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:20 let ptr = res.acquire(); </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">      ,   : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="rust"><span class="hljs-comment"><span class="hljs-comment">extern crate sync; use sync::{Arc, RWLock}; struct Resource { value: Option&lt;Box&lt;int&gt;&gt;, } impl Resource { pub fn new() -&gt; Resource { Resource{ value: None } } pub fn acquire(&amp;mut self) -&gt; *int { if self.value.is_none() { self.value = Some(box 1) } &amp;**self.value.get_ref() as *int } } fn main() { let arc_res = Arc::new(RWLock::new(Resource::new())); for _ in range(0,5) { let child_res = arc_res.clone(); spawn(proc() { let ptr = child_res.write().acquire(); println!("resource: {}", ptr) }) } }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">     </span></span><code><span class="hljs-comment"><span class="hljs-comment">Arc</span></span></code><span class="hljs-comment"><span class="hljs-comment"> ( </span></span><i><span class="hljs-comment"><span class="hljs-comment">Atomically Reference Counted</span></span></i><span class="hljs-comment"><span class="hljs-comment"> -        )  </span></span><code><span class="hljs-comment"><span class="hljs-comment">RWLock</span></span></code><span class="hljs-comment"><span class="hljs-comment"> (   ).   : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7ff4b0010378 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7ff4b0010378 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7ff4b0010378 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7ff4b0010378 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7ff4b0010378 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  ,   ++    .    . Rust        ,    .  ,   ,   .           ,       ( </span></span><a href="http://superwebdeveloper.com/2009/11/25/the-incredible-rate-of-diminishing-returns-of-fixing-software-bugs/"><span class="hljs-comment"><span class="hljs-comment">  </span></span></a><span class="hljs-comment"><span class="hljs-comment"> ). </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">     </span></span><br><span class="hljs-comment"><span class="hljs-comment"> Rust        ,     </span></span><code><span class="hljs-comment"><span class="hljs-comment">unsafe{}</span></span></code><span class="hljs-comment"><span class="hljs-comment"> .   ,     " </span></span><i><span class="hljs-comment"><span class="hljs-comment"> !  ,  .</span></span></i><span class="hljs-comment"><span class="hljs-comment"> ".  ,  ""  (    ,    )    .    ,           ( )  . , ,        </span></span><code><span class="hljs-comment"><span class="hljs-comment">Cell</span></span></code><span class="hljs-comment"><span class="hljs-comment">  </span></span><code><span class="hljs-comment"><span class="hljs-comment">Mutex</span></span></code><span class="hljs-comment"><span class="hljs-comment"> .             ,       (   </span></span><a href="http://en.wikipedia.org/wiki/Test-driven_development"><span class="hljs-comment"><span class="hljs-comment">TDD</span></span></a><span class="hljs-comment"><span class="hljs-comment"> !). </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="https://air.mozilla.org/guaranteeing-memory-safety-in-rust/"><span class="hljs-comment"><span class="hljs-comment">Guaranteeing Memory Safety in Rust (by Niko Matsakis)</span></span></a><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="http://www.techtalkshub.com/rust-safe-systems-programming-fun-fp/"><span class="hljs-comment"><span class="hljs-comment">Rust: Safe Systems Programming with the Fun of FP (by Felix Klock II)</span></span></a><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Keynote"><span class="hljs-comment"><span class="hljs-comment">Lang-NEXT: What ‚Äì if anything ‚Äì have we learned from C++? (by Bjarne Stroustrup)</span></span></a><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Panel-Systems-Programming-Languages-in-2014-and-Beyond"><span class="hljs-comment"><span class="hljs-comment">Lang-NEXT Panel: Systems Programming in 2014 and Beyond</span></span></a></code></code> </pre> <code><code><code><code class="cpp">Box)     ,       (     ).        (std::rc::Rc)    (std::gc::Gc),      (   ). <br> <br></code>      <br>  ++: <br> #include &lt;stdio.h&gt; int *bar(int *p) { return p; } int* foo(int n) { return bar(&amp;n); } int main() { int *p1 = foo(1); int *p2 = foo(2); printf("%d, %d\n", *p1, *p2); }</code> <br>  : <br> 2, 2 <br> <br>  Rust: <br> <code class="rust">fn bar&lt;'a&gt;(p: &amp;'a int) -&gt; &amp;'a int { return p; } fn foo(n: int) -&gt; &amp;int { bar(&amp;n) } fn main() { let p1 = foo(1); let p2 = foo(2); println!("{}, {}", *p1, *p2); }</code> <br>  : <br> demo:5:10: 5:11 error: `n` does not live long enough <br> demo:5 bar(&amp;n) <br> ^ <br> demo:4:24: 6:2 note: reference must be valid for the anonymous lifetime #1 defined on the block at 4:23... <br> demo:4 fn foo(n: int) -&gt; &amp;int { <br> demo:5 bar(&amp;n) <br> demo:6 } <br> demo:4:24: 6:2 note: ...but borrowed value is only valid for the block at 4:23 <br> demo:4 fn foo(n: int) -&gt; &amp;int { <br> demo:5 bar(&amp;n) <br> demo:6 } <br> <br>   <br> <code class="cpp">#include &lt;stdio.h&gt; int minval(int *A, int n) { int currmin; for (int i=0; i&lt;n; i++) if (A[i] &lt; currmin) currmin = A[i]; return currmin; } int main() { int A[] = {1,2,3}; int min = minval(A,3); printf("%d\n", min); }</code> <br>   0  ,     , ,  .       Rust ( - ): <br> <code class="rust">fn minval(A: &amp;[int]) -&gt; int { let mut currmin; for a in A.iter() { if *a &lt; currmin { currmin = *a; } } currmin } fn main() { let A = [1i,2i,3i]; let min = minval(A.as_slice()); println!("{}", min); }</code> <br>  , : use of possibly uninitialized variable: `currmin` <br>   ( )      : <br> <code class="rust">fn minval(A: &amp;[int]) -&gt; int { A.iter().fold(A[0], |u,&amp;a| { if a&lt;u {a} else {u} }) }</code> <br> <br>    <br> <code class="cpp">struct A{ int *x; A(int v): x(new int(v)) {} ~A() {delete x;} }; int main() { A a(1), b=a; }</code> <br> ,    : <br> *** glibc detected *** demo: double free or corruption (fasttop): 0x0000000000601010 *** <br> <br>     Rust: <br> <code class="rust">struct A{ x: Box&lt;int&gt; } impl A { pub fn new(v: int) -&gt; A { A{ x: box v } } } impl Drop for A { fn drop(&amp;mut self) {} // ,     ++ } fn main() { let a = A::new(1); let _b = a; }</code> <br>     .   ,     <code>trait Copy</code> . <br> Rust       .    <code>Eq</code>  <code>Clone</code> ?    <code>deriving</code>   : <br> <code class="rust">#[deriving(Clone, Eq, Hash, PartialEq, PartialOrd, Ord, Show)] struct A{ x: Box&lt;int&gt; }</code> <br> <br>    <br> <code class="cpp">#include &lt;stdio.h&gt; struct X { int a, b; }; void swap_from(X&amp; x, const X&amp; y) { xa = yb; xb = ya; } int main() { X x = {1,2}; swap_from(x,x); printf("%d,%d\n", xa, xb); }</code> <br>  : <br> 2,2 <br>    ,    cc      .   ,   ,  99  <a href="http://en.wikipedia.org/wiki/Restrict">restrict</a> ,            :        . <br> <br>       Rust: <br> <code class="rust">struct X { pub a: int, pub b: int } fn swap_from(x: &amp;mut X, y: &amp;X) { xa = yb; xb = ya; } fn main() { let mut x = X{a:1, b:2}; swap_from(&amp;mut x, &amp;x); }</code> <br>    : <br> demo:7:24: 7:25 error: cannot borrow `x` as immutable because it is also borrowed as mutable <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> ^ <br> demo:7:20: 7:21 note: previous borrow of `x` occurs here; the mutable borrow prevents subsequent moves, borrows, or modification of `x` until the borrow ends <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> ^ <br> demo:7:26: 7:26 note: previous borrow ends here <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> <br>  ,             " <code>&amp;mut</code> "  " <code>&amp;</code> " ,   ,          ,   <code>&amp;mut</code> .            .  ,    ,      C99  <code>restrict</code>  (Rust  LLVM    ),    . <br> <br>   <br> <code class="cpp">#include &lt;vector&gt; int main() { std::vector&lt;int&gt; v; v.push_back(1); v.push_back(2); for(std::vector&lt;int&gt;::const_iterator it=v.begin(); it!=v.end(); ++it) { if (*it &lt; 5) v.push_back(5-*it); } }</code> <br>    ,    : <br> Segmentation fault (core dumped) <br> <br>    Rust: <br> <code class="rust">fn main() { let mut v: Vec&lt;int&gt; = Vec::new(); v.push(1); v.push(2); for x in v.iter() { if *x &lt; 5 { v.push(5-*x); } } }</code> <br>      ,  ,        : <br> demo:7:13: 7:14 error: cannot borrow `v` as mutable because it is also borrowed as immutable <br> demo:7 v.push(5-*x); <br> ^ <br> demo:5:14: 5:15 note: previous borrow of `v` occurs here; the immutable borrow prevents subsequent moves or mutable borrows of `v` until the borrow ends <br> demo:5 for x in v.iter() { <br> ^ <br> demo:10:2: 10:2 note: previous borrow ends here <br> demo:5 for x in v.iter() { <br> demo:6 if *x &lt; 5 { <br> demo:7 v.push(5-*x); <br> demo:8 } <br> demo:9 } <br> demo:10 } <br> <br> <br>  Switch <br> <code class="cpp">#include &lt;stdio.h&gt; enum {RED, BLUE, GRAY, UNKNOWN} color = GRAY; int main() { int x; switch(color) { case GRAY: x=1; case RED: case BLUE: x=2; } printf("%d", x); }</code> <br>   "2".  Rust          .  ,       ,    <code>break</code> .    Rust   : <br> <code class="rust">enum Color {RED, BLUE, GRAY, UNKNOWN} fn main() { let color = GRAY; let x = match color { GRAY =&gt; 1, RED | BLUE =&gt; 2, _ =&gt; 3, }; println!("{}", x); }</code> <br> <br>     <br> <code class="cpp">int main() { int pixels = 1; for (int j=0; j&lt;5; j++); pixels++; }</code> <br>  Rust          . , ,     . <br> <br>  <br> <code class="cpp">#include &lt;stdio.h&gt; #include &lt;pthread.h&gt; #include &lt;unistd.h&gt; class Resource { int *value; public: Resource(): value(NULL) {} ~Resource() {delete value;} int *acquire() { if (!value) { value = new int(0); } return value; } }; void* function(void *param) { int *value = ((Resource*)param)-&gt;acquire(); printf("resource: %p\n", (void*)value); return value; } int main() { Resource res; for (int i=0; i&lt;5; ++i) { pthread_t pt; pthread_create(&amp;pt, NULL, function, &amp;res); } //sleep(10); printf("done\n"); }</code> <br>     : <br> done <br> resource: 0x7f229c0008c0 <br> resource: 0x7f22840008c0 <br> resource: 0x7f228c0008c0 <br> resource: 0x7f22940008c0 <br> resource: 0x7f227c0008c0 <br> <br>     ,        .      Rust: <br> <code class="rust">struct Resource { value: Option&lt;int&gt;, } impl Resource { pub fn new() -&gt; Resource { Resource{ value: None } } pub fn acquire&lt;'a&gt;(&amp;'a mut self) -&gt; &amp;'a int { if self.value.is_none() { self.value = Some(1); } self.value.get_ref() } } fn main() { let mut res = Resource::new(); for _ in range(0,5) { spawn(proc() { let ptr = res.acquire(); println!("resource {}", ptr) }) } }</code> <br>  ,            . <br> demo:20:23: 20:26 error: cannot borrow immutable captured outer variable in a proc `res` as mutable <br> demo:20 let ptr = res.acquire(); <br> <br>      ,   : <br> <code class="rust">extern crate sync; use sync::{Arc, RWLock}; struct Resource { value: Option&lt;Box&lt;int&gt;&gt;, } impl Resource { pub fn new() -&gt; Resource { Resource{ value: None } } pub fn acquire(&amp;mut self) -&gt; *int { if self.value.is_none() { self.value = Some(box 1) } &amp;**self.value.get_ref() as *int } } fn main() { let arc_res = Arc::new(RWLock::new(Resource::new())); for _ in range(0,5) { let child_res = arc_res.clone(); spawn(proc() { let ptr = child_res.write().acquire(); println!("resource: {}", ptr) }) } }</code> <br>     <code>Arc</code> ( <i>Atomically Reference Counted</i> -        )  <code>RWLock</code> (   ).   : <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> <br>  ,   ++    .    . Rust        ,    .  ,   ,   .           ,       ( <a href="http://superwebdeveloper.com/2009/11/25/the-incredible-rate-of-diminishing-returns-of-fixing-software-bugs/">  </a> ). <br> <br>     <br> Rust        ,     <code>unsafe{}</code> .   ,     " <i> !  ,  .</i> ".  ,  ""  (    ,    )    .    ,           ( )  . , ,        <code>Cell</code>  <code>Mutex</code> .             ,       (   <a href="http://en.wikipedia.org/wiki/Test-driven_development">TDD</a> !). <br> <br>  <br> <a href="https://air.mozilla.org/guaranteeing-memory-safety-in-rust/">Guaranteeing Memory Safety in Rust (by Niko Matsakis)</a> <br> <a href="http://www.techtalkshub.com/rust-safe-systems-programming-fun-fp/">Rust: Safe Systems Programming with the Fun of FP (by Felix Klock II)</a> <br> <a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Keynote">Lang-NEXT: What ‚Äì if anything ‚Äì have we learned from C++? (by Bjarne Stroustrup)</a> <br> <a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Panel-Systems-Programming-Languages-in-2014-and-Beyond">Lang-NEXT Panel: Systems Programming in 2014 and Beyond</a></code></code> <blockquote> <code><code><code><code class="cpp">Box)     ,       (     ).        (std::rc::Rc)    (std::gc::Gc),      (   ). <br> <br></code>      <br>  ++: <br> #include &lt;stdio.h&gt; int *bar(int *p) { return p; } int* foo(int n) { return bar(&amp;n); } int main() { int *p1 = foo(1); int *p2 = foo(2); printf("%d, %d\n", *p1, *p2); }</code> <br>  : <br> 2, 2 <br> <br>  Rust: <br> <code class="rust">fn bar&lt;'a&gt;(p: &amp;'a int) -&gt; &amp;'a int { return p; } fn foo(n: int) -&gt; &amp;int { bar(&amp;n) } fn main() { let p1 = foo(1); let p2 = foo(2); println!("{}, {}", *p1, *p2); }</code> <br>  : <br> demo:5:10: 5:11 error: `n` does not live long enough <br> demo:5 bar(&amp;n) <br> ^ <br> demo:4:24: 6:2 note: reference must be valid for the anonymous lifetime #1 defined on the block at 4:23... <br> demo:4 fn foo(n: int) -&gt; &amp;int { <br> demo:5 bar(&amp;n) <br> demo:6 } <br> demo:4:24: 6:2 note: ...but borrowed value is only valid for the block at 4:23 <br> demo:4 fn foo(n: int) -&gt; &amp;int { <br> demo:5 bar(&amp;n) <br> demo:6 } <br> <br>   <br> <code class="cpp">#include &lt;stdio.h&gt; int minval(int *A, int n) { int currmin; for (int i=0; i&lt;n; i++) if (A[i] &lt; currmin) currmin = A[i]; return currmin; } int main() { int A[] = {1,2,3}; int min = minval(A,3); printf("%d\n", min); }</code> <br>   0  ,     , ,  .       Rust ( - ): <br> <code class="rust">fn minval(A: &amp;[int]) -&gt; int { let mut currmin; for a in A.iter() { if *a &lt; currmin { currmin = *a; } } currmin } fn main() { let A = [1i,2i,3i]; let min = minval(A.as_slice()); println!("{}", min); }</code> <br>  , : use of possibly uninitialized variable: `currmin` <br>   ( )      : <br> <code class="rust">fn minval(A: &amp;[int]) -&gt; int { A.iter().fold(A[0], |u,&amp;a| { if a&lt;u {a} else {u} }) }</code> <br> <br>    <br> <code class="cpp">struct A{ int *x; A(int v): x(new int(v)) {} ~A() {delete x;} }; int main() { A a(1), b=a; }</code> <br> ,    : <br> *** glibc detected *** demo: double free or corruption (fasttop): 0x0000000000601010 *** <br> <br>     Rust: <br> <code class="rust">struct A{ x: Box&lt;int&gt; } impl A { pub fn new(v: int) -&gt; A { A{ x: box v } } } impl Drop for A { fn drop(&amp;mut self) {} // ,     ++ } fn main() { let a = A::new(1); let _b = a; }</code> <br>     .   ,     <code>trait Copy</code> . <br> Rust       .    <code>Eq</code>  <code>Clone</code> ?    <code>deriving</code>   : <br> <code class="rust">#[deriving(Clone, Eq, Hash, PartialEq, PartialOrd, Ord, Show)] struct A{ x: Box&lt;int&gt; }</code> <br> <br>    <br> <code class="cpp">#include &lt;stdio.h&gt; struct X { int a, b; }; void swap_from(X&amp; x, const X&amp; y) { xa = yb; xb = ya; } int main() { X x = {1,2}; swap_from(x,x); printf("%d,%d\n", xa, xb); }</code> <br>  : <br> 2,2 <br>    ,    cc      .   ,   ,  99  <a href="http://en.wikipedia.org/wiki/Restrict">restrict</a> ,            :        . <br> <br>       Rust: <br> <code class="rust">struct X { pub a: int, pub b: int } fn swap_from(x: &amp;mut X, y: &amp;X) { xa = yb; xb = ya; } fn main() { let mut x = X{a:1, b:2}; swap_from(&amp;mut x, &amp;x); }</code> <br>    : <br> demo:7:24: 7:25 error: cannot borrow `x` as immutable because it is also borrowed as mutable <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> ^ <br> demo:7:20: 7:21 note: previous borrow of `x` occurs here; the mutable borrow prevents subsequent moves, borrows, or modification of `x` until the borrow ends <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> ^ <br> demo:7:26: 7:26 note: previous borrow ends here <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> <br>  ,             " <code>&amp;mut</code> "  " <code>&amp;</code> " ,   ,          ,   <code>&amp;mut</code> .            .  ,    ,      C99  <code>restrict</code>  (Rust  LLVM    ),    . <br> <br>   <br> <code class="cpp">#include &lt;vector&gt; int main() { std::vector&lt;int&gt; v; v.push_back(1); v.push_back(2); for(std::vector&lt;int&gt;::const_iterator it=v.begin(); it!=v.end(); ++it) { if (*it &lt; 5) v.push_back(5-*it); } }</code> <br>    ,    : <br> Segmentation fault (core dumped) <br> <br>    Rust: <br> <code class="rust">fn main() { let mut v: Vec&lt;int&gt; = Vec::new(); v.push(1); v.push(2); for x in v.iter() { if *x &lt; 5 { v.push(5-*x); } } }</code> <br>      ,  ,        : <br> demo:7:13: 7:14 error: cannot borrow `v` as mutable because it is also borrowed as immutable <br> demo:7 v.push(5-*x); <br> ^ <br> demo:5:14: 5:15 note: previous borrow of `v` occurs here; the immutable borrow prevents subsequent moves or mutable borrows of `v` until the borrow ends <br> demo:5 for x in v.iter() { <br> ^ <br> demo:10:2: 10:2 note: previous borrow ends here <br> demo:5 for x in v.iter() { <br> demo:6 if *x &lt; 5 { <br> demo:7 v.push(5-*x); <br> demo:8 } <br> demo:9 } <br> demo:10 } <br> <br> <br>  Switch <br> <code class="cpp">#include &lt;stdio.h&gt; enum {RED, BLUE, GRAY, UNKNOWN} color = GRAY; int main() { int x; switch(color) { case GRAY: x=1; case RED: case BLUE: x=2; } printf("%d", x); }</code> <br>   "2".  Rust          .  ,       ,    <code>break</code> .    Rust   : <br> <code class="rust">enum Color {RED, BLUE, GRAY, UNKNOWN} fn main() { let color = GRAY; let x = match color { GRAY =&gt; 1, RED | BLUE =&gt; 2, _ =&gt; 3, }; println!("{}", x); }</code> <br> <br>     <br> <code class="cpp">int main() { int pixels = 1; for (int j=0; j&lt;5; j++); pixels++; }</code> <br>  Rust          . , ,     . <br> <br>  <br> <code class="cpp">#include &lt;stdio.h&gt; #include &lt;pthread.h&gt; #include &lt;unistd.h&gt; class Resource { int *value; public: Resource(): value(NULL) {} ~Resource() {delete value;} int *acquire() { if (!value) { value = new int(0); } return value; } }; void* function(void *param) { int *value = ((Resource*)param)-&gt;acquire(); printf("resource: %p\n", (void*)value); return value; } int main() { Resource res; for (int i=0; i&lt;5; ++i) { pthread_t pt; pthread_create(&amp;pt, NULL, function, &amp;res); } //sleep(10); printf("done\n"); }</code> <br>     : <br> done <br> resource: 0x7f229c0008c0 <br> resource: 0x7f22840008c0 <br> resource: 0x7f228c0008c0 <br> resource: 0x7f22940008c0 <br> resource: 0x7f227c0008c0 <br> <br>     ,        .      Rust: <br> <code class="rust">struct Resource { value: Option&lt;int&gt;, } impl Resource { pub fn new() -&gt; Resource { Resource{ value: None } } pub fn acquire&lt;'a&gt;(&amp;'a mut self) -&gt; &amp;'a int { if self.value.is_none() { self.value = Some(1); } self.value.get_ref() } } fn main() { let mut res = Resource::new(); for _ in range(0,5) { spawn(proc() { let ptr = res.acquire(); println!("resource {}", ptr) }) } }</code> <br>  ,            . <br> demo:20:23: 20:26 error: cannot borrow immutable captured outer variable in a proc `res` as mutable <br> demo:20 let ptr = res.acquire(); <br> <br>      ,   : <br> <code class="rust">extern crate sync; use sync::{Arc, RWLock}; struct Resource { value: Option&lt;Box&lt;int&gt;&gt;, } impl Resource { pub fn new() -&gt; Resource { Resource{ value: None } } pub fn acquire(&amp;mut self) -&gt; *int { if self.value.is_none() { self.value = Some(box 1) } &amp;**self.value.get_ref() as *int } } fn main() { let arc_res = Arc::new(RWLock::new(Resource::new())); for _ in range(0,5) { let child_res = arc_res.clone(); spawn(proc() { let ptr = child_res.write().acquire(); println!("resource: {}", ptr) }) } }</code> <br>     <code>Arc</code> ( <i>Atomically Reference Counted</i> -        )  <code>RWLock</code> (   ).   : <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> <br>  ,   ++    .    . Rust        ,    .  ,   ,   .           ,       ( <a href="http://superwebdeveloper.com/2009/11/25/the-incredible-rate-of-diminishing-returns-of-fixing-software-bugs/">  </a> ). <br> <br>     <br> Rust        ,     <code>unsafe{}</code> .   ,     " <i> !  ,  .</i> ".  ,  ""  (    ,    )    .    ,           ( )  . , ,        <code>Cell</code>  <code>Mutex</code> .             ,       (   <a href="http://en.wikipedia.org/wiki/Test-driven_development">TDD</a> !). <br> <br>  <br> <a href="https://air.mozilla.org/guaranteeing-memory-safety-in-rust/">Guaranteeing Memory Safety in Rust (by Niko Matsakis)</a> <br> <a href="http://www.techtalkshub.com/rust-safe-systems-programming-fun-fp/">Rust: Safe Systems Programming with the Fun of FP (by Felix Klock II)</a> <br> <a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Keynote">Lang-NEXT: What ‚Äì if anything ‚Äì have we learned from C++? (by Bjarne Stroustrup)</a> <br> <a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Panel-Systems-Programming-Languages-in-2014-and-Beyond">Lang-NEXT Panel: Systems Programming in 2014 and Beyond</a></code></code> </blockquote> <code><code><code><code class="cpp">Box)     ,       (     ).        (std::rc::Rc)    (std::gc::Gc),      (   ). <br> <br></code>      <br>  ++: <br> #include &lt;stdio.h&gt; int *bar(int *p) { return p; } int* foo(int n) { return bar(&amp;n); } int main() { int *p1 = foo(1); int *p2 = foo(2); printf("%d, %d\n", *p1, *p2); }</code> <br>  : <br> 2, 2 <br> <br>  Rust: <br> <code class="rust">fn bar&lt;'a&gt;(p: &amp;'a int) -&gt; &amp;'a int { return p; } fn foo(n: int) -&gt; &amp;int { bar(&amp;n) } fn main() { let p1 = foo(1); let p2 = foo(2); println!("{}, {}", *p1, *p2); }</code> <br>  : <br> demo:5:10: 5:11 error: `n` does not live long enough <br> demo:5 bar(&amp;n) <br> ^ <br> demo:4:24: 6:2 note: reference must be valid for the anonymous lifetime #1 defined on the block at 4:23... <br> demo:4 fn foo(n: int) -&gt; &amp;int { <br> demo:5 bar(&amp;n) <br> demo:6 } <br> demo:4:24: 6:2 note: ...but borrowed value is only valid for the block at 4:23 <br> demo:4 fn foo(n: int) -&gt; &amp;int { <br> demo:5 bar(&amp;n) <br> demo:6 } <br> <br>   <br> <code class="cpp">#include &lt;stdio.h&gt; int minval(int *A, int n) { int currmin; for (int i=0; i&lt;n; i++) if (A[i] &lt; currmin) currmin = A[i]; return currmin; } int main() { int A[] = {1,2,3}; int min = minval(A,3); printf("%d\n", min); }</code> <br>   0  ,     , ,  .       Rust ( - ): <br> <code class="rust">fn minval(A: &amp;[int]) -&gt; int { let mut currmin; for a in A.iter() { if *a &lt; currmin { currmin = *a; } } currmin } fn main() { let A = [1i,2i,3i]; let min = minval(A.as_slice()); println!("{}", min); }</code> <br>  , : use of possibly uninitialized variable: `currmin` <br>   ( )      : <br> <code class="rust">fn minval(A: &amp;[int]) -&gt; int { A.iter().fold(A[0], |u,&amp;a| { if a&lt;u {a} else {u} }) }</code> <br> <br>    <br> <code class="cpp">struct A{ int *x; A(int v): x(new int(v)) {} ~A() {delete x;} }; int main() { A a(1), b=a; }</code> <br> ,    : <br> *** glibc detected *** demo: double free or corruption (fasttop): 0x0000000000601010 *** <br> <br>     Rust: <br> <code class="rust">struct A{ x: Box&lt;int&gt; } impl A { pub fn new(v: int) -&gt; A { A{ x: box v } } } impl Drop for A { fn drop(&amp;mut self) {} // ,     ++ } fn main() { let a = A::new(1); let _b = a; }</code> <br>     .   ,     <code>trait Copy</code> . <br> Rust       .    <code>Eq</code>  <code>Clone</code> ?    <code>deriving</code>   : <br> <code class="rust">#[deriving(Clone, Eq, Hash, PartialEq, PartialOrd, Ord, Show)] struct A{ x: Box&lt;int&gt; }</code> <br> <br>    <br> <code class="cpp">#include &lt;stdio.h&gt; struct X { int a, b; }; void swap_from(X&amp; x, const X&amp; y) { xa = yb; xb = ya; } int main() { X x = {1,2}; swap_from(x,x); printf("%d,%d\n", xa, xb); }</code> <br>  : <br> 2,2 <br>    ,    cc      .   ,   ,  99  <a href="http://en.wikipedia.org/wiki/Restrict">restrict</a> ,            :        . <br> <br>       Rust: <br> <code class="rust">struct X { pub a: int, pub b: int } fn swap_from(x: &amp;mut X, y: &amp;X) { xa = yb; xb = ya; } fn main() { let mut x = X{a:1, b:2}; swap_from(&amp;mut x, &amp;x); }</code> <br>    : <br> demo:7:24: 7:25 error: cannot borrow `x` as immutable because it is also borrowed as mutable <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> ^ <br> demo:7:20: 7:21 note: previous borrow of `x` occurs here; the mutable borrow prevents subsequent moves, borrows, or modification of `x` until the borrow ends <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> ^ <br> demo:7:26: 7:26 note: previous borrow ends here <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> <br>  ,             " <code>&amp;mut</code> "  " <code>&amp;</code> " ,   ,          ,   <code>&amp;mut</code> .            .  ,    ,      C99  <code>restrict</code>  (Rust  LLVM    ),    . <br> <br>   <br> <code class="cpp">#include &lt;vector&gt; int main() { std::vector&lt;int&gt; v; v.push_back(1); v.push_back(2); for(std::vector&lt;int&gt;::const_iterator it=v.begin(); it!=v.end(); ++it) { if (*it &lt; 5) v.push_back(5-*it); } }</code> <br>    ,    : <br> Segmentation fault (core dumped) <br> <br>    Rust: <br> <code class="rust">fn main() { let mut v: Vec&lt;int&gt; = Vec::new(); v.push(1); v.push(2); for x in v.iter() { if *x &lt; 5 { v.push(5-*x); } } }</code> <br>      ,  ,        : <br> demo:7:13: 7:14 error: cannot borrow `v` as mutable because it is also borrowed as immutable <br> demo:7 v.push(5-*x); <br> ^ <br> demo:5:14: 5:15 note: previous borrow of `v` occurs here; the immutable borrow prevents subsequent moves or mutable borrows of `v` until the borrow ends <br> demo:5 for x in v.iter() { <br> ^ <br> demo:10:2: 10:2 note: previous borrow ends here <br> demo:5 for x in v.iter() { <br> demo:6 if *x &lt; 5 { <br> demo:7 v.push(5-*x); <br> demo:8 } <br> demo:9 } <br> demo:10 } <br> <br> <br>  Switch <br> <code class="cpp">#include &lt;stdio.h&gt; enum {RED, BLUE, GRAY, UNKNOWN} color = GRAY; int main() { int x; switch(color) { case GRAY: x=1; case RED: case BLUE: x=2; } printf("%d", x); }</code> <br>   "2".  Rust          .  ,       ,    <code>break</code> .    Rust   : <br> <code class="rust">enum Color {RED, BLUE, GRAY, UNKNOWN} fn main() { let color = GRAY; let x = match color { GRAY =&gt; 1, RED | BLUE =&gt; 2, _ =&gt; 3, }; println!("{}", x); }</code> <br> <br>     <br> <code class="cpp">int main() { int pixels = 1; for (int j=0; j&lt;5; j++); pixels++; }</code> <br>  Rust          . , ,     . <br> <br>  <br> <code class="cpp">#include &lt;stdio.h&gt; #include &lt;pthread.h&gt; #include &lt;unistd.h&gt; class Resource { int *value; public: Resource(): value(NULL) {} ~Resource() {delete value;} int *acquire() { if (!value) { value = new int(0); } return value; } }; void* function(void *param) { int *value = ((Resource*)param)-&gt;acquire(); printf("resource: %p\n", (void*)value); return value; } int main() { Resource res; for (int i=0; i&lt;5; ++i) { pthread_t pt; pthread_create(&amp;pt, NULL, function, &amp;res); } //sleep(10); printf("done\n"); }</code> <br>     : <br> done <br> resource: 0x7f229c0008c0 <br> resource: 0x7f22840008c0 <br> resource: 0x7f228c0008c0 <br> resource: 0x7f22940008c0 <br> resource: 0x7f227c0008c0 <br> <br>     ,        .      Rust: <br> <code class="rust">struct Resource { value: Option&lt;int&gt;, } impl Resource { pub fn new() -&gt; Resource { Resource{ value: None } } pub fn acquire&lt;'a&gt;(&amp;'a mut self) -&gt; &amp;'a int { if self.value.is_none() { self.value = Some(1); } self.value.get_ref() } } fn main() { let mut res = Resource::new(); for _ in range(0,5) { spawn(proc() { let ptr = res.acquire(); println!("resource {}", ptr) }) } }</code> <br>  ,            . <br> demo:20:23: 20:26 error: cannot borrow immutable captured outer variable in a proc `res` as mutable <br> demo:20 let ptr = res.acquire(); <br> <br>      ,   : <br> <code class="rust">extern crate sync; use sync::{Arc, RWLock}; struct Resource { value: Option&lt;Box&lt;int&gt;&gt;, } impl Resource { pub fn new() -&gt; Resource { Resource{ value: None } } pub fn acquire(&amp;mut self) -&gt; *int { if self.value.is_none() { self.value = Some(box 1) } &amp;**self.value.get_ref() as *int } } fn main() { let arc_res = Arc::new(RWLock::new(Resource::new())); for _ in range(0,5) { let child_res = arc_res.clone(); spawn(proc() { let ptr = child_res.write().acquire(); println!("resource: {}", ptr) }) } }</code> <br>     <code>Arc</code> ( <i>Atomically Reference Counted</i> -        )  <code>RWLock</code> (   ).   : <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> <br>  ,   ++    .    . Rust        ,    .  ,   ,   .           ,       ( <a href="http://superwebdeveloper.com/2009/11/25/the-incredible-rate-of-diminishing-returns-of-fixing-software-bugs/">  </a> ). <br> <br>     <br> Rust        ,     <code>unsafe{}</code> .   ,     " <i> !  ,  .</i> ".  ,  ""  (    ,    )    .    ,           ( )  . , ,        <code>Cell</code>  <code>Mutex</code> .             ,       (   <a href="http://en.wikipedia.org/wiki/Test-driven_development">TDD</a> !). <br> <br>  <br> <a href="https://air.mozilla.org/guaranteeing-memory-safety-in-rust/">Guaranteeing Memory Safety in Rust (by Niko Matsakis)</a> <br> <a href="http://www.techtalkshub.com/rust-safe-systems-programming-fun-fp/">Rust: Safe Systems Programming with the Fun of FP (by Felix Klock II)</a> <br> <a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Keynote">Lang-NEXT: What ‚Äì if anything ‚Äì have we learned from C++? (by Bjarne Stroustrup)</a> <br> <a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Panel-Systems-Programming-Languages-in-2014-and-Beyond">Lang-NEXT Panel: Systems Programming in 2014 and Beyond</a></code></code> <h4> <code><code><code><code class="cpp">Box)     ,       (     ).        (std::rc::Rc)    (std::gc::Gc),      (   ). <br> <br></code>      <br>  ++: <br> #include &lt;stdio.h&gt; int *bar(int *p) { return p; } int* foo(int n) { return bar(&amp;n); } int main() { int *p1 = foo(1); int *p2 = foo(2); printf("%d, %d\n", *p1, *p2); }</code> <br>  : <br> 2, 2 <br> <br>  Rust: <br> <code class="rust">fn bar&lt;'a&gt;(p: &amp;'a int) -&gt; &amp;'a int { return p; } fn foo(n: int) -&gt; &amp;int { bar(&amp;n) } fn main() { let p1 = foo(1); let p2 = foo(2); println!("{}, {}", *p1, *p2); }</code> <br>  : <br> demo:5:10: 5:11 error: `n` does not live long enough <br> demo:5 bar(&amp;n) <br> ^ <br> demo:4:24: 6:2 note: reference must be valid for the anonymous lifetime #1 defined on the block at 4:23... <br> demo:4 fn foo(n: int) -&gt; &amp;int { <br> demo:5 bar(&amp;n) <br> demo:6 } <br> demo:4:24: 6:2 note: ...but borrowed value is only valid for the block at 4:23 <br> demo:4 fn foo(n: int) -&gt; &amp;int { <br> demo:5 bar(&amp;n) <br> demo:6 } <br> <br>   <br> <code class="cpp">#include &lt;stdio.h&gt; int minval(int *A, int n) { int currmin; for (int i=0; i&lt;n; i++) if (A[i] &lt; currmin) currmin = A[i]; return currmin; } int main() { int A[] = {1,2,3}; int min = minval(A,3); printf("%d\n", min); }</code> <br>   0  ,     , ,  .       Rust ( - ): <br> <code class="rust">fn minval(A: &amp;[int]) -&gt; int { let mut currmin; for a in A.iter() { if *a &lt; currmin { currmin = *a; } } currmin } fn main() { let A = [1i,2i,3i]; let min = minval(A.as_slice()); println!("{}", min); }</code> <br>  , : use of possibly uninitialized variable: `currmin` <br>   ( )      : <br> <code class="rust">fn minval(A: &amp;[int]) -&gt; int { A.iter().fold(A[0], |u,&amp;a| { if a&lt;u {a} else {u} }) }</code> <br> <br>    <br> <code class="cpp">struct A{ int *x; A(int v): x(new int(v)) {} ~A() {delete x;} }; int main() { A a(1), b=a; }</code> <br> ,    : <br> *** glibc detected *** demo: double free or corruption (fasttop): 0x0000000000601010 *** <br> <br>     Rust: <br> <code class="rust">struct A{ x: Box&lt;int&gt; } impl A { pub fn new(v: int) -&gt; A { A{ x: box v } } } impl Drop for A { fn drop(&amp;mut self) {} // ,     ++ } fn main() { let a = A::new(1); let _b = a; }</code> <br>     .   ,     <code>trait Copy</code> . <br> Rust       .    <code>Eq</code>  <code>Clone</code> ?    <code>deriving</code>   : <br> <code class="rust">#[deriving(Clone, Eq, Hash, PartialEq, PartialOrd, Ord, Show)] struct A{ x: Box&lt;int&gt; }</code> <br> <br>    <br> <code class="cpp">#include &lt;stdio.h&gt; struct X { int a, b; }; void swap_from(X&amp; x, const X&amp; y) { xa = yb; xb = ya; } int main() { X x = {1,2}; swap_from(x,x); printf("%d,%d\n", xa, xb); }</code> <br>  : <br> 2,2 <br>    ,    cc      .   ,   ,  99  <a href="http://en.wikipedia.org/wiki/Restrict">restrict</a> ,            :        . <br> <br>       Rust: <br> <code class="rust">struct X { pub a: int, pub b: int } fn swap_from(x: &amp;mut X, y: &amp;X) { xa = yb; xb = ya; } fn main() { let mut x = X{a:1, b:2}; swap_from(&amp;mut x, &amp;x); }</code> <br>    : <br> demo:7:24: 7:25 error: cannot borrow `x` as immutable because it is also borrowed as mutable <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> ^ <br> demo:7:20: 7:21 note: previous borrow of `x` occurs here; the mutable borrow prevents subsequent moves, borrows, or modification of `x` until the borrow ends <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> ^ <br> demo:7:26: 7:26 note: previous borrow ends here <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> <br>  ,             " <code>&amp;mut</code> "  " <code>&amp;</code> " ,   ,          ,   <code>&amp;mut</code> .            .  ,    ,      C99  <code>restrict</code>  (Rust  LLVM    ),    . <br> <br>   <br> <code class="cpp">#include &lt;vector&gt; int main() { std::vector&lt;int&gt; v; v.push_back(1); v.push_back(2); for(std::vector&lt;int&gt;::const_iterator it=v.begin(); it!=v.end(); ++it) { if (*it &lt; 5) v.push_back(5-*it); } }</code> <br>    ,    : <br> Segmentation fault (core dumped) <br> <br>    Rust: <br> <code class="rust">fn main() { let mut v: Vec&lt;int&gt; = Vec::new(); v.push(1); v.push(2); for x in v.iter() { if *x &lt; 5 { v.push(5-*x); } } }</code> <br>      ,  ,        : <br> demo:7:13: 7:14 error: cannot borrow `v` as mutable because it is also borrowed as immutable <br> demo:7 v.push(5-*x); <br> ^ <br> demo:5:14: 5:15 note: previous borrow of `v` occurs here; the immutable borrow prevents subsequent moves or mutable borrows of `v` until the borrow ends <br> demo:5 for x in v.iter() { <br> ^ <br> demo:10:2: 10:2 note: previous borrow ends here <br> demo:5 for x in v.iter() { <br> demo:6 if *x &lt; 5 { <br> demo:7 v.push(5-*x); <br> demo:8 } <br> demo:9 } <br> demo:10 } <br> <br> <br>  Switch <br> <code class="cpp">#include &lt;stdio.h&gt; enum {RED, BLUE, GRAY, UNKNOWN} color = GRAY; int main() { int x; switch(color) { case GRAY: x=1; case RED: case BLUE: x=2; } printf("%d", x); }</code> <br>   "2".  Rust          .  ,       ,    <code>break</code> .    Rust   : <br> <code class="rust">enum Color {RED, BLUE, GRAY, UNKNOWN} fn main() { let color = GRAY; let x = match color { GRAY =&gt; 1, RED | BLUE =&gt; 2, _ =&gt; 3, }; println!("{}", x); }</code> <br> <br>     <br> <code class="cpp">int main() { int pixels = 1; for (int j=0; j&lt;5; j++); pixels++; }</code> <br>  Rust          . , ,     . <br> <br>  <br> <code class="cpp">#include &lt;stdio.h&gt; #include &lt;pthread.h&gt; #include &lt;unistd.h&gt; class Resource { int *value; public: Resource(): value(NULL) {} ~Resource() {delete value;} int *acquire() { if (!value) { value = new int(0); } return value; } }; void* function(void *param) { int *value = ((Resource*)param)-&gt;acquire(); printf("resource: %p\n", (void*)value); return value; } int main() { Resource res; for (int i=0; i&lt;5; ++i) { pthread_t pt; pthread_create(&amp;pt, NULL, function, &amp;res); } //sleep(10); printf("done\n"); }</code> <br>     : <br> done <br> resource: 0x7f229c0008c0 <br> resource: 0x7f22840008c0 <br> resource: 0x7f228c0008c0 <br> resource: 0x7f22940008c0 <br> resource: 0x7f227c0008c0 <br> <br>     ,        .      Rust: <br> <code class="rust">struct Resource { value: Option&lt;int&gt;, } impl Resource { pub fn new() -&gt; Resource { Resource{ value: None } } pub fn acquire&lt;'a&gt;(&amp;'a mut self) -&gt; &amp;'a int { if self.value.is_none() { self.value = Some(1); } self.value.get_ref() } } fn main() { let mut res = Resource::new(); for _ in range(0,5) { spawn(proc() { let ptr = res.acquire(); println!("resource {}", ptr) }) } }</code> <br>  ,            . <br> demo:20:23: 20:26 error: cannot borrow immutable captured outer variable in a proc `res` as mutable <br> demo:20 let ptr = res.acquire(); <br> <br>      ,   : <br> <code class="rust">extern crate sync; use sync::{Arc, RWLock}; struct Resource { value: Option&lt;Box&lt;int&gt;&gt;, } impl Resource { pub fn new() -&gt; Resource { Resource{ value: None } } pub fn acquire(&amp;mut self) -&gt; *int { if self.value.is_none() { self.value = Some(box 1) } &amp;**self.value.get_ref() as *int } } fn main() { let arc_res = Arc::new(RWLock::new(Resource::new())); for _ in range(0,5) { let child_res = arc_res.clone(); spawn(proc() { let ptr = child_res.write().acquire(); println!("resource: {}", ptr) }) } }</code> <br>     <code>Arc</code> ( <i>Atomically Reference Counted</i> -        )  <code>RWLock</code> (   ).   : <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> <br>  ,   ++    .    . Rust        ,    .  ,   ,   .           ,       ( <a href="http://superwebdeveloper.com/2009/11/25/the-incredible-rate-of-diminishing-returns-of-fixing-software-bugs/">  </a> ). <br> <br>     <br> Rust        ,     <code>unsafe{}</code> .   ,     " <i> !  ,  .</i> ".  ,  ""  (    ,    )    .    ,           ( )  . , ,        <code>Cell</code>  <code>Mutex</code> .             ,       (   <a href="http://en.wikipedia.org/wiki/Test-driven_development">TDD</a> !). <br> <br>  <br> <a href="https://air.mozilla.org/guaranteeing-memory-safety-in-rust/">Guaranteeing Memory Safety in Rust (by Niko Matsakis)</a> <br> <a href="http://www.techtalkshub.com/rust-safe-systems-programming-fun-fp/">Rust: Safe Systems Programming with the Fun of FP (by Felix Klock II)</a> <br> <a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Keynote">Lang-NEXT: What ‚Äì if anything ‚Äì have we learned from C++? (by Bjarne Stroustrup)</a> <br> <a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Panel-Systems-Programming-Languages-in-2014-and-Beyond">Lang-NEXT Panel: Systems Programming in 2014 and Beyond</a></code></code> </h4> <code><code><code><code class="cpp">Box)     ,       (     ).        (std::rc::Rc)    (std::gc::Gc),      (   ). <br> <br></code>      <br>  ++: <br> #include &lt;stdio.h&gt; int *bar(int *p) { return p; } int* foo(int n) { return bar(&amp;n); } int main() { int *p1 = foo(1); int *p2 = foo(2); printf("%d, %d\n", *p1, *p2); }</code> <br>  : <br> 2, 2 <br> <br>  Rust: <br> <code class="rust">fn bar&lt;'a&gt;(p: &amp;'a int) -&gt; &amp;'a int { return p; } fn foo(n: int) -&gt; &amp;int { bar(&amp;n) } fn main() { let p1 = foo(1); let p2 = foo(2); println!("{}, {}", *p1, *p2); }</code> <br>  : <br> demo:5:10: 5:11 error: `n` does not live long enough <br> demo:5 bar(&amp;n) <br> ^ <br> demo:4:24: 6:2 note: reference must be valid for the anonymous lifetime #1 defined on the block at 4:23... <br> demo:4 fn foo(n: int) -&gt; &amp;int { <br> demo:5 bar(&amp;n) <br> demo:6 } <br> demo:4:24: 6:2 note: ...but borrowed value is only valid for the block at 4:23 <br> demo:4 fn foo(n: int) -&gt; &amp;int { <br> demo:5 bar(&amp;n) <br> demo:6 } <br> <br>   <br> <code class="cpp">#include &lt;stdio.h&gt; int minval(int *A, int n) { int currmin; for (int i=0; i&lt;n; i++) if (A[i] &lt; currmin) currmin = A[i]; return currmin; } int main() { int A[] = {1,2,3}; int min = minval(A,3); printf("%d\n", min); }</code> <br>   0  ,     , ,  .       Rust ( - ): <br> <code class="rust">fn minval(A: &amp;[int]) -&gt; int { let mut currmin; for a in A.iter() { if *a &lt; currmin { currmin = *a; } } currmin } fn main() { let A = [1i,2i,3i]; let min = minval(A.as_slice()); println!("{}", min); }</code> <br>  , : use of possibly uninitialized variable: `currmin` <br>   ( )      : <br> <code class="rust">fn minval(A: &amp;[int]) -&gt; int { A.iter().fold(A[0], |u,&amp;a| { if a&lt;u {a} else {u} }) }</code> <br> <br>    <br> <code class="cpp">struct A{ int *x; A(int v): x(new int(v)) {} ~A() {delete x;} }; int main() { A a(1), b=a; }</code> <br> ,    : <br> *** glibc detected *** demo: double free or corruption (fasttop): 0x0000000000601010 *** <br> <br>     Rust: <br> <code class="rust">struct A{ x: Box&lt;int&gt; } impl A { pub fn new(v: int) -&gt; A { A{ x: box v } } } impl Drop for A { fn drop(&amp;mut self) {} // ,     ++ } fn main() { let a = A::new(1); let _b = a; }</code> <br>     .   ,     <code>trait Copy</code> . <br> Rust       .    <code>Eq</code>  <code>Clone</code> ?    <code>deriving</code>   : <br> <code class="rust">#[deriving(Clone, Eq, Hash, PartialEq, PartialOrd, Ord, Show)] struct A{ x: Box&lt;int&gt; }</code> <br> <br>    <br> <code class="cpp">#include &lt;stdio.h&gt; struct X { int a, b; }; void swap_from(X&amp; x, const X&amp; y) { xa = yb; xb = ya; } int main() { X x = {1,2}; swap_from(x,x); printf("%d,%d\n", xa, xb); }</code> <br>  : <br> 2,2 <br>    ,    cc      .   ,   ,  99  <a href="http://en.wikipedia.org/wiki/Restrict">restrict</a> ,            :        . <br> <br>       Rust: <br> <code class="rust">struct X { pub a: int, pub b: int } fn swap_from(x: &amp;mut X, y: &amp;X) { xa = yb; xb = ya; } fn main() { let mut x = X{a:1, b:2}; swap_from(&amp;mut x, &amp;x); }</code> <br>    : <br> demo:7:24: 7:25 error: cannot borrow `x` as immutable because it is also borrowed as mutable <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> ^ <br> demo:7:20: 7:21 note: previous borrow of `x` occurs here; the mutable borrow prevents subsequent moves, borrows, or modification of `x` until the borrow ends <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> ^ <br> demo:7:26: 7:26 note: previous borrow ends here <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> <br>  ,             " <code>&amp;mut</code> "  " <code>&amp;</code> " ,   ,          ,   <code>&amp;mut</code> .            .  ,    ,      C99  <code>restrict</code>  (Rust  LLVM    ),    . <br> <br>   <br> <code class="cpp">#include &lt;vector&gt; int main() { std::vector&lt;int&gt; v; v.push_back(1); v.push_back(2); for(std::vector&lt;int&gt;::const_iterator it=v.begin(); it!=v.end(); ++it) { if (*it &lt; 5) v.push_back(5-*it); } }</code> <br>    ,    : <br> Segmentation fault (core dumped) <br> <br>    Rust: <br> <code class="rust">fn main() { let mut v: Vec&lt;int&gt; = Vec::new(); v.push(1); v.push(2); for x in v.iter() { if *x &lt; 5 { v.push(5-*x); } } }</code> <br>      ,  ,        : <br> demo:7:13: 7:14 error: cannot borrow `v` as mutable because it is also borrowed as immutable <br> demo:7 v.push(5-*x); <br> ^ <br> demo:5:14: 5:15 note: previous borrow of `v` occurs here; the immutable borrow prevents subsequent moves or mutable borrows of `v` until the borrow ends <br> demo:5 for x in v.iter() { <br> ^ <br> demo:10:2: 10:2 note: previous borrow ends here <br> demo:5 for x in v.iter() { <br> demo:6 if *x &lt; 5 { <br> demo:7 v.push(5-*x); <br> demo:8 } <br> demo:9 } <br> demo:10 } <br> <br> <br>  Switch <br> <code class="cpp">#include &lt;stdio.h&gt; enum {RED, BLUE, GRAY, UNKNOWN} color = GRAY; int main() { int x; switch(color) { case GRAY: x=1; case RED: case BLUE: x=2; } printf("%d", x); }</code> <br>   "2".  Rust          .  ,       ,    <code>break</code> .    Rust   : <br> <code class="rust">enum Color {RED, BLUE, GRAY, UNKNOWN} fn main() { let color = GRAY; let x = match color { GRAY =&gt; 1, RED | BLUE =&gt; 2, _ =&gt; 3, }; println!("{}", x); }</code> <br> <br>     <br> <code class="cpp">int main() { int pixels = 1; for (int j=0; j&lt;5; j++); pixels++; }</code> <br>  Rust          . , ,     . <br> <br>  <br> <code class="cpp">#include &lt;stdio.h&gt; #include &lt;pthread.h&gt; #include &lt;unistd.h&gt; class Resource { int *value; public: Resource(): value(NULL) {} ~Resource() {delete value;} int *acquire() { if (!value) { value = new int(0); } return value; } }; void* function(void *param) { int *value = ((Resource*)param)-&gt;acquire(); printf("resource: %p\n", (void*)value); return value; } int main() { Resource res; for (int i=0; i&lt;5; ++i) { pthread_t pt; pthread_create(&amp;pt, NULL, function, &amp;res); } //sleep(10); printf("done\n"); }</code> <br>     : <br> done <br> resource: 0x7f229c0008c0 <br> resource: 0x7f22840008c0 <br> resource: 0x7f228c0008c0 <br> resource: 0x7f22940008c0 <br> resource: 0x7f227c0008c0 <br> <br>     ,        .      Rust: <br> <code class="rust">struct Resource { value: Option&lt;int&gt;, } impl Resource { pub fn new() -&gt; Resource { Resource{ value: None } } pub fn acquire&lt;'a&gt;(&amp;'a mut self) -&gt; &amp;'a int { if self.value.is_none() { self.value = Some(1); } self.value.get_ref() } } fn main() { let mut res = Resource::new(); for _ in range(0,5) { spawn(proc() { let ptr = res.acquire(); println!("resource {}", ptr) }) } }</code> <br>  ,            . <br> demo:20:23: 20:26 error: cannot borrow immutable captured outer variable in a proc `res` as mutable <br> demo:20 let ptr = res.acquire(); <br> <br>      ,   : <br> <code class="rust">extern crate sync; use sync::{Arc, RWLock}; struct Resource { value: Option&lt;Box&lt;int&gt;&gt;, } impl Resource { pub fn new() -&gt; Resource { Resource{ value: None } } pub fn acquire(&amp;mut self) -&gt; *int { if self.value.is_none() { self.value = Some(box 1) } &amp;**self.value.get_ref() as *int } } fn main() { let arc_res = Arc::new(RWLock::new(Resource::new())); for _ in range(0,5) { let child_res = arc_res.clone(); spawn(proc() { let ptr = child_res.write().acquire(); println!("resource: {}", ptr) }) } }</code> <br>     <code>Arc</code> ( <i>Atomically Reference Counted</i> -        )  <code>RWLock</code> (   ).   : <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> <br>  ,   ++    .    . Rust        ,    .  ,   ,   .           ,       ( <a href="http://superwebdeveloper.com/2009/11/25/the-incredible-rate-of-diminishing-returns-of-fixing-software-bugs/">  </a> ). <br> <br>     <br> Rust        ,     <code>unsafe{}</code> .   ,     " <i> !  ,  .</i> ".  ,  ""  (    ,    )    .    ,           ( )  . , ,        <code>Cell</code>  <code>Mutex</code> .             ,       (   <a href="http://en.wikipedia.org/wiki/Test-driven_development">TDD</a> !). <br> <br>  <br> <a href="https://air.mozilla.org/guaranteeing-memory-safety-in-rust/">Guaranteeing Memory Safety in Rust (by Niko Matsakis)</a> <br> <a href="http://www.techtalkshub.com/rust-safe-systems-programming-fun-fp/">Rust: Safe Systems Programming with the Fun of FP (by Felix Klock II)</a> <br> <a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Keynote">Lang-NEXT: What ‚Äì if anything ‚Äì have we learned from C++? (by Bjarne Stroustrup)</a> <br> <a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Panel-Systems-Programming-Languages-in-2014-and-Beyond">Lang-NEXT Panel: Systems Programming in 2014 and Beyond</a></code></code> <pre> <code class="hljs rust"><code><code><code class="cpp"><span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>)     ,       (     ).        (std::rc::Rc)    (std::gc::Gc),      (   ). <br> <br></code>      <br>  ++: <br> #include &lt;stdio.h&gt; int *bar(int *p) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p; } int* foo(int n) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bar(&amp;n); } int main() { int *p1 = foo(<span class="hljs-number"><span class="hljs-number">1</span></span>); int *p2 = foo(<span class="hljs-number"><span class="hljs-number">2</span></span>); printf(<span class="hljs-string"><span class="hljs-string">"%d, %d\n"</span></span>, *p1, *p2); }</code> <br>  : <br> <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span> <br> <br>  Rust: <br> <code class="rust"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt;(p: &amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> int) -&gt; &amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> int { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>(n: int) -&gt; &amp;int { bar(&amp;n) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> p1 = foo(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> p2 = foo(<span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{}, {}"</span></span>, *p1, *p2); }</code> <br>  : <br> demo:<span class="hljs-number"><span class="hljs-number">5</span></span>:<span class="hljs-number"><span class="hljs-number">10</span></span>: <span class="hljs-number"><span class="hljs-number">5</span></span>:<span class="hljs-number"><span class="hljs-number">11</span></span> error: `n` does not live long enough <br> demo:<span class="hljs-number"><span class="hljs-number">5</span></span> bar(&amp;n) <br> ^ <br> demo:<span class="hljs-number"><span class="hljs-number">4</span></span>:<span class="hljs-number"><span class="hljs-number">24</span></span>: <span class="hljs-number"><span class="hljs-number">6</span></span>:<span class="hljs-number"><span class="hljs-number">2</span></span> note: reference must <span class="hljs-keyword"><span class="hljs-keyword">be</span></span> valid <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> the anonymous lifetime #<span class="hljs-number"><span class="hljs-number">1</span></span> defined on the block at <span class="hljs-number"><span class="hljs-number">4</span></span>:<span class="hljs-number"><span class="hljs-number">23</span></span>... <br> demo:<span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>(n: int) -&gt; &amp;int { <br> demo:<span class="hljs-number"><span class="hljs-number">5</span></span> bar(&amp;n) <br> demo:<span class="hljs-number"><span class="hljs-number">6</span></span> } <br> demo:<span class="hljs-number"><span class="hljs-number">4</span></span>:<span class="hljs-number"><span class="hljs-number">24</span></span>: <span class="hljs-number"><span class="hljs-number">6</span></span>:<span class="hljs-number"><span class="hljs-number">2</span></span> note: ...but borrowed value is only valid <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> the block at <span class="hljs-number"><span class="hljs-number">4</span></span>:<span class="hljs-number"><span class="hljs-number">23</span></span> <br> demo:<span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>(n: int) -&gt; &amp;int { <br> demo:<span class="hljs-number"><span class="hljs-number">5</span></span> bar(&amp;n) <br> demo:<span class="hljs-number"><span class="hljs-number">6</span></span> } <br> <br>   <br> <code class="cpp">#include &lt;stdio.h&gt; int minval(int *A, int n) { int currmin; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;n; i++) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (A[i] &lt; currmin) currmin = A[i]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> currmin; } int main() { int A[] = {<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>}; int min = minval(A,<span class="hljs-number"><span class="hljs-number">3</span></span>); printf(<span class="hljs-string"><span class="hljs-string">"%d\n"</span></span>, min); }</code> <br>   <span class="hljs-number"><span class="hljs-number">0</span></span>  ,     , ,  .       Rust ( - ): <br> <code class="rust"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">minval</span></span></span></span>(A: &amp;[int]) -&gt; int { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> currmin; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> a <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> A.iter() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> *a &lt; currmin { currmin = *a; } } currmin } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> A = [<span class="hljs-number"><span class="hljs-number">1</span></span>i,<span class="hljs-number"><span class="hljs-number">2</span></span>i,<span class="hljs-number"><span class="hljs-number">3</span></span>i]; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> min = minval(A.as_slice()); <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{}"</span></span>, min); }</code> <br>  , : <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> of possibly uninitialized variable: `currmin` <br>   ( )      : <br> <code class="rust"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">minval</span></span></span></span>(A: &amp;[int]) -&gt; int { A.iter().fold(A[<span class="hljs-number"><span class="hljs-number">0</span></span>], |u,&amp;a| { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> a&lt;u {a} <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {u} }) }</code> <br> <br>    <br> <code class="cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span></span>{ int *x; A(int v): x(new int(v)) {} ~A() {delete x;} }; int main() { A a(<span class="hljs-number"><span class="hljs-number">1</span></span>), b=a; }</code> <br> ,    : <br> *** glibc detected *** demo: double free or corruption (fasttop): <span class="hljs-number"><span class="hljs-number">0x0000000000601010</span></span> *** <br> <br>     Rust: <br> <code class="rust"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span></span>{ x: <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;int&gt; } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> A { <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">new</span></span></span></span>(v: int) -&gt; A { A{ x: <span class="hljs-keyword"><span class="hljs-keyword">box</span></span> v } } } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Drop</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> A { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drop</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) {} <span class="hljs-comment"><span class="hljs-comment">// ,     ++ } fn main() { let a = A::new(1); let _b = a; }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">     .   ,     </span></span><code><span class="hljs-comment"><span class="hljs-comment">trait Copy</span></span></code><span class="hljs-comment"><span class="hljs-comment"> . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> Rust       .    </span></span><code><span class="hljs-comment"><span class="hljs-comment">Eq</span></span></code><span class="hljs-comment"><span class="hljs-comment">  </span></span><code><span class="hljs-comment"><span class="hljs-comment">Clone</span></span></code><span class="hljs-comment"><span class="hljs-comment"> ?    </span></span><code><span class="hljs-comment"><span class="hljs-comment">deriving</span></span></code><span class="hljs-comment"><span class="hljs-comment">   : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="rust"><span class="hljs-comment"><span class="hljs-comment">#[deriving(Clone, Eq, Hash, PartialEq, PartialOrd, Ord, Show)] struct A{ x: Box&lt;int&gt; }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">    </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="cpp"><span class="hljs-comment"><span class="hljs-comment">#include &lt;stdio.h&gt; struct X { int a, b; }; void swap_from(X&amp; x, const X&amp; y) { xa = yb; xb = ya; } int main() { X x = {1,2}; swap_from(x,x); printf("%d,%d\n", xa, xb); }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> 2,2 </span></span><br><span class="hljs-comment"><span class="hljs-comment">    ,    cc      .   ,   ,  99  </span></span><a href="http://en.wikipedia.org/wiki/Restrict"><span class="hljs-comment"><span class="hljs-comment">restrict</span></span></a><span class="hljs-comment"><span class="hljs-comment"> ,            :        . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">       Rust: </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="rust"><span class="hljs-comment"><span class="hljs-comment">struct X { pub a: int, pub b: int } fn swap_from(x: &amp;mut X, y: &amp;X) { xa = yb; xb = ya; } fn main() { let mut x = X{a:1, b:2}; swap_from(&amp;mut x, &amp;x); }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">    : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7:24: 7:25 error: cannot borrow `x` as immutable because it is also borrowed as mutable </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7 swap_from(&amp;mut x, &amp;x); </span></span><br><span class="hljs-comment"><span class="hljs-comment"> ^ </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7:20: 7:21 note: previous borrow of `x` occurs here; the mutable borrow prevents subsequent moves, borrows, or modification of `x` until the borrow ends </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7 swap_from(&amp;mut x, &amp;x); </span></span><br><span class="hljs-comment"><span class="hljs-comment"> ^ </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7:26: 7:26 note: previous borrow ends here </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7 swap_from(&amp;mut x, &amp;x); </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  ,             " </span></span><code><span class="hljs-comment"><span class="hljs-comment">&amp;mut</span></span></code><span class="hljs-comment"><span class="hljs-comment"> "  " </span></span><code><span class="hljs-comment"><span class="hljs-comment">&amp;</span></span></code><span class="hljs-comment"><span class="hljs-comment"> " ,   ,          ,   </span></span><code><span class="hljs-comment"><span class="hljs-comment">&amp;mut</span></span></code><span class="hljs-comment"><span class="hljs-comment"> .            .  ,    ,      C99  </span></span><code><span class="hljs-comment"><span class="hljs-comment">restrict</span></span></code><span class="hljs-comment"><span class="hljs-comment">  (Rust  LLVM    ),    . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">   </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="cpp"><span class="hljs-comment"><span class="hljs-comment">#include &lt;vector&gt; int main() { std::vector&lt;int&gt; v; v.push_back(1); v.push_back(2); for(std::vector&lt;int&gt;::const_iterator it=v.begin(); it!=v.end(); ++it) { if (*it &lt; 5) v.push_back(5-*it); } }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">    ,    : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> Segmentation fault (core dumped) </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">    Rust: </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="rust"><span class="hljs-comment"><span class="hljs-comment">fn main() { let mut v: Vec&lt;int&gt; = Vec::new(); v.push(1); v.push(2); for x in v.iter() { if *x &lt; 5 { v.push(5-*x); } } }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">      ,  ,        : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7:13: 7:14 error: cannot borrow `v` as mutable because it is also borrowed as immutable </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7 v.push(5-*x); </span></span><br><span class="hljs-comment"><span class="hljs-comment"> ^ </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:5:14: 5:15 note: previous borrow of `v` occurs here; the immutable borrow prevents subsequent moves or mutable borrows of `v` until the borrow ends </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:5 for x in v.iter() { </span></span><br><span class="hljs-comment"><span class="hljs-comment"> ^ </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:10:2: 10:2 note: previous borrow ends here </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:5 for x in v.iter() { </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:6 if *x &lt; 5 { </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7 v.push(5-*x); </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:8 } </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:9 } </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:10 } </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  Switch </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="cpp"><span class="hljs-comment"><span class="hljs-comment">#include &lt;stdio.h&gt; enum {RED, BLUE, GRAY, UNKNOWN} color = GRAY; int main() { int x; switch(color) { case GRAY: x=1; case RED: case BLUE: x=2; } printf("%d", x); }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">   "2".  Rust          .  ,       ,    </span></span><code><span class="hljs-comment"><span class="hljs-comment">break</span></span></code><span class="hljs-comment"><span class="hljs-comment"> .    Rust   : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="rust"><span class="hljs-comment"><span class="hljs-comment">enum Color {RED, BLUE, GRAY, UNKNOWN} fn main() { let color = GRAY; let x = match color { GRAY =&gt; 1, RED | BLUE =&gt; 2, _ =&gt; 3, }; println!("{}", x); }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">     </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="cpp"><span class="hljs-comment"><span class="hljs-comment">int main() { int pixels = 1; for (int j=0; j&lt;5; j++); pixels++; }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  Rust          . , ,     . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="cpp"><span class="hljs-comment"><span class="hljs-comment">#include &lt;stdio.h&gt; #include &lt;pthread.h&gt; #include &lt;unistd.h&gt; class Resource { int *value; public: Resource(): value(NULL) {} ~Resource() {delete value;} int *acquire() { if (!value) { value = new int(0); } return value; } }; void* function(void *param) { int *value = ((Resource*)param)-&gt;acquire(); printf("resource: %p\n", (void*)value); return value; } int main() { Resource res; for (int i=0; i&lt;5; ++i) { pthread_t pt; pthread_create(&amp;pt, NULL, function, &amp;res); } //sleep(10); printf("done\n"); }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">     : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> done </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7f229c0008c0 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7f22840008c0 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7f228c0008c0 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7f22940008c0 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7f227c0008c0 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">     ,        .      Rust: </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="rust"><span class="hljs-comment"><span class="hljs-comment">struct Resource { value: Option&lt;int&gt;, } impl Resource { pub fn new() -&gt; Resource { Resource{ value: None } } pub fn acquire&lt;'a&gt;(&amp;'a mut self) -&gt; &amp;'a int { if self.value.is_none() { self.value = Some(1); } self.value.get_ref() } } fn main() { let mut res = Resource::new(); for _ in range(0,5) { spawn(proc() { let ptr = res.acquire(); println!("resource {}", ptr) }) } }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  ,            . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:20:23: 20:26 error: cannot borrow immutable captured outer variable in a proc `res` as mutable </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:20 let ptr = res.acquire(); </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">      ,   : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="rust"><span class="hljs-comment"><span class="hljs-comment">extern crate sync; use sync::{Arc, RWLock}; struct Resource { value: Option&lt;Box&lt;int&gt;&gt;, } impl Resource { pub fn new() -&gt; Resource { Resource{ value: None } } pub fn acquire(&amp;mut self) -&gt; *int { if self.value.is_none() { self.value = Some(box 1) } &amp;**self.value.get_ref() as *int } } fn main() { let arc_res = Arc::new(RWLock::new(Resource::new())); for _ in range(0,5) { let child_res = arc_res.clone(); spawn(proc() { let ptr = child_res.write().acquire(); println!("resource: {}", ptr) }) } }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">     </span></span><code><span class="hljs-comment"><span class="hljs-comment">Arc</span></span></code><span class="hljs-comment"><span class="hljs-comment"> ( </span></span><i><span class="hljs-comment"><span class="hljs-comment">Atomically Reference Counted</span></span></i><span class="hljs-comment"><span class="hljs-comment"> -        )  </span></span><code><span class="hljs-comment"><span class="hljs-comment">RWLock</span></span></code><span class="hljs-comment"><span class="hljs-comment"> (   ).   : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7ff4b0010378 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7ff4b0010378 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7ff4b0010378 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7ff4b0010378 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7ff4b0010378 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  ,   ++    .    . Rust        ,    .  ,   ,   .           ,       ( </span></span><a href="http://superwebdeveloper.com/2009/11/25/the-incredible-rate-of-diminishing-returns-of-fixing-software-bugs/"><span class="hljs-comment"><span class="hljs-comment">  </span></span></a><span class="hljs-comment"><span class="hljs-comment"> ). </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">     </span></span><br><span class="hljs-comment"><span class="hljs-comment"> Rust        ,     </span></span><code><span class="hljs-comment"><span class="hljs-comment">unsafe{}</span></span></code><span class="hljs-comment"><span class="hljs-comment"> .   ,     " </span></span><i><span class="hljs-comment"><span class="hljs-comment"> !  ,  .</span></span></i><span class="hljs-comment"><span class="hljs-comment"> ".  ,  ""  (    ,    )    .    ,           ( )  . , ,        </span></span><code><span class="hljs-comment"><span class="hljs-comment">Cell</span></span></code><span class="hljs-comment"><span class="hljs-comment">  </span></span><code><span class="hljs-comment"><span class="hljs-comment">Mutex</span></span></code><span class="hljs-comment"><span class="hljs-comment"> .             ,       (   </span></span><a href="http://en.wikipedia.org/wiki/Test-driven_development"><span class="hljs-comment"><span class="hljs-comment">TDD</span></span></a><span class="hljs-comment"><span class="hljs-comment"> !). </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="https://air.mozilla.org/guaranteeing-memory-safety-in-rust/"><span class="hljs-comment"><span class="hljs-comment">Guaranteeing Memory Safety in Rust (by Niko Matsakis)</span></span></a><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="http://www.techtalkshub.com/rust-safe-systems-programming-fun-fp/"><span class="hljs-comment"><span class="hljs-comment">Rust: Safe Systems Programming with the Fun of FP (by Felix Klock II)</span></span></a><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Keynote"><span class="hljs-comment"><span class="hljs-comment">Lang-NEXT: What ‚Äì if anything ‚Äì have we learned from C++? (by Bjarne Stroustrup)</span></span></a><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Panel-Systems-Programming-Languages-in-2014-and-Beyond"><span class="hljs-comment"><span class="hljs-comment">Lang-NEXT Panel: Systems Programming in 2014 and Beyond</span></span></a></code></code> </pre> <code><code><code><code class="cpp">Box)     ,       (     ).        (std::rc::Rc)    (std::gc::Gc),      (   ). <br> <br></code>      <br>  ++: <br> #include &lt;stdio.h&gt; int *bar(int *p) { return p; } int* foo(int n) { return bar(&amp;n); } int main() { int *p1 = foo(1); int *p2 = foo(2); printf("%d, %d\n", *p1, *p2); }</code> <br>  : <br> 2, 2 <br> <br>  Rust: <br> <code class="rust">fn bar&lt;'a&gt;(p: &amp;'a int) -&gt; &amp;'a int { return p; } fn foo(n: int) -&gt; &amp;int { bar(&amp;n) } fn main() { let p1 = foo(1); let p2 = foo(2); println!("{}, {}", *p1, *p2); }</code> <br>  : <br> demo:5:10: 5:11 error: `n` does not live long enough <br> demo:5 bar(&amp;n) <br> ^ <br> demo:4:24: 6:2 note: reference must be valid for the anonymous lifetime #1 defined on the block at 4:23... <br> demo:4 fn foo(n: int) -&gt; &amp;int { <br> demo:5 bar(&amp;n) <br> demo:6 } <br> demo:4:24: 6:2 note: ...but borrowed value is only valid for the block at 4:23 <br> demo:4 fn foo(n: int) -&gt; &amp;int { <br> demo:5 bar(&amp;n) <br> demo:6 } <br> <br>   <br> <code class="cpp">#include &lt;stdio.h&gt; int minval(int *A, int n) { int currmin; for (int i=0; i&lt;n; i++) if (A[i] &lt; currmin) currmin = A[i]; return currmin; } int main() { int A[] = {1,2,3}; int min = minval(A,3); printf("%d\n", min); }</code> <br>   0  ,     , ,  .       Rust ( - ): <br> <code class="rust">fn minval(A: &amp;[int]) -&gt; int { let mut currmin; for a in A.iter() { if *a &lt; currmin { currmin = *a; } } currmin } fn main() { let A = [1i,2i,3i]; let min = minval(A.as_slice()); println!("{}", min); }</code> <br>  , : use of possibly uninitialized variable: `currmin` <br>   ( )      : <br> <code class="rust">fn minval(A: &amp;[int]) -&gt; int { A.iter().fold(A[0], |u,&amp;a| { if a&lt;u {a} else {u} }) }</code> <br> <br>    <br> <code class="cpp">struct A{ int *x; A(int v): x(new int(v)) {} ~A() {delete x;} }; int main() { A a(1), b=a; }</code> <br> ,    : <br> *** glibc detected *** demo: double free or corruption (fasttop): 0x0000000000601010 *** <br> <br>     Rust: <br> <code class="rust">struct A{ x: Box&lt;int&gt; } impl A { pub fn new(v: int) -&gt; A { A{ x: box v } } } impl Drop for A { fn drop(&amp;mut self) {} // ,     ++ } fn main() { let a = A::new(1); let _b = a; }</code> <br>     .   ,     <code>trait Copy</code> . <br> Rust       .    <code>Eq</code>  <code>Clone</code> ?    <code>deriving</code>   : <br> <code class="rust">#[deriving(Clone, Eq, Hash, PartialEq, PartialOrd, Ord, Show)] struct A{ x: Box&lt;int&gt; }</code> <br> <br>    <br> <code class="cpp">#include &lt;stdio.h&gt; struct X { int a, b; }; void swap_from(X&amp; x, const X&amp; y) { xa = yb; xb = ya; } int main() { X x = {1,2}; swap_from(x,x); printf("%d,%d\n", xa, xb); }</code> <br>  : <br> 2,2 <br>    ,    cc      .   ,   ,  99  <a href="http://en.wikipedia.org/wiki/Restrict">restrict</a> ,            :        . <br> <br>       Rust: <br> <code class="rust">struct X { pub a: int, pub b: int } fn swap_from(x: &amp;mut X, y: &amp;X) { xa = yb; xb = ya; } fn main() { let mut x = X{a:1, b:2}; swap_from(&amp;mut x, &amp;x); }</code> <br>    : <br> demo:7:24: 7:25 error: cannot borrow `x` as immutable because it is also borrowed as mutable <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> ^ <br> demo:7:20: 7:21 note: previous borrow of `x` occurs here; the mutable borrow prevents subsequent moves, borrows, or modification of `x` until the borrow ends <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> ^ <br> demo:7:26: 7:26 note: previous borrow ends here <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> <br>  ,             " <code>&amp;mut</code> "  " <code>&amp;</code> " ,   ,          ,   <code>&amp;mut</code> .            .  ,    ,      C99  <code>restrict</code>  (Rust  LLVM    ),    . <br> <br>   <br> <code class="cpp">#include &lt;vector&gt; int main() { std::vector&lt;int&gt; v; v.push_back(1); v.push_back(2); for(std::vector&lt;int&gt;::const_iterator it=v.begin(); it!=v.end(); ++it) { if (*it &lt; 5) v.push_back(5-*it); } }</code> <br>    ,    : <br> Segmentation fault (core dumped) <br> <br>    Rust: <br> <code class="rust">fn main() { let mut v: Vec&lt;int&gt; = Vec::new(); v.push(1); v.push(2); for x in v.iter() { if *x &lt; 5 { v.push(5-*x); } } }</code> <br>      ,  ,        : <br> demo:7:13: 7:14 error: cannot borrow `v` as mutable because it is also borrowed as immutable <br> demo:7 v.push(5-*x); <br> ^ <br> demo:5:14: 5:15 note: previous borrow of `v` occurs here; the immutable borrow prevents subsequent moves or mutable borrows of `v` until the borrow ends <br> demo:5 for x in v.iter() { <br> ^ <br> demo:10:2: 10:2 note: previous borrow ends here <br> demo:5 for x in v.iter() { <br> demo:6 if *x &lt; 5 { <br> demo:7 v.push(5-*x); <br> demo:8 } <br> demo:9 } <br> demo:10 } <br> <br> <br>  Switch <br> <code class="cpp">#include &lt;stdio.h&gt; enum {RED, BLUE, GRAY, UNKNOWN} color = GRAY; int main() { int x; switch(color) { case GRAY: x=1; case RED: case BLUE: x=2; } printf("%d", x); }</code> <br>   "2".  Rust          .  ,       ,    <code>break</code> .    Rust   : <br> <code class="rust">enum Color {RED, BLUE, GRAY, UNKNOWN} fn main() { let color = GRAY; let x = match color { GRAY =&gt; 1, RED | BLUE =&gt; 2, _ =&gt; 3, }; println!("{}", x); }</code> <br> <br>     <br> <code class="cpp">int main() { int pixels = 1; for (int j=0; j&lt;5; j++); pixels++; }</code> <br>  Rust          . , ,     . <br> <br>  <br> <code class="cpp">#include &lt;stdio.h&gt; #include &lt;pthread.h&gt; #include &lt;unistd.h&gt; class Resource { int *value; public: Resource(): value(NULL) {} ~Resource() {delete value;} int *acquire() { if (!value) { value = new int(0); } return value; } }; void* function(void *param) { int *value = ((Resource*)param)-&gt;acquire(); printf("resource: %p\n", (void*)value); return value; } int main() { Resource res; for (int i=0; i&lt;5; ++i) { pthread_t pt; pthread_create(&amp;pt, NULL, function, &amp;res); } //sleep(10); printf("done\n"); }</code> <br>     : <br> done <br> resource: 0x7f229c0008c0 <br> resource: 0x7f22840008c0 <br> resource: 0x7f228c0008c0 <br> resource: 0x7f22940008c0 <br> resource: 0x7f227c0008c0 <br> <br>     ,        .      Rust: <br> <code class="rust">struct Resource { value: Option&lt;int&gt;, } impl Resource { pub fn new() -&gt; Resource { Resource{ value: None } } pub fn acquire&lt;'a&gt;(&amp;'a mut self) -&gt; &amp;'a int { if self.value.is_none() { self.value = Some(1); } self.value.get_ref() } } fn main() { let mut res = Resource::new(); for _ in range(0,5) { spawn(proc() { let ptr = res.acquire(); println!("resource {}", ptr) }) } }</code> <br>  ,            . <br> demo:20:23: 20:26 error: cannot borrow immutable captured outer variable in a proc `res` as mutable <br> demo:20 let ptr = res.acquire(); <br> <br>      ,   : <br> <code class="rust">extern crate sync; use sync::{Arc, RWLock}; struct Resource { value: Option&lt;Box&lt;int&gt;&gt;, } impl Resource { pub fn new() -&gt; Resource { Resource{ value: None } } pub fn acquire(&amp;mut self) -&gt; *int { if self.value.is_none() { self.value = Some(box 1) } &amp;**self.value.get_ref() as *int } } fn main() { let arc_res = Arc::new(RWLock::new(Resource::new())); for _ in range(0,5) { let child_res = arc_res.clone(); spawn(proc() { let ptr = child_res.write().acquire(); println!("resource: {}", ptr) }) } }</code> <br>     <code>Arc</code> ( <i>Atomically Reference Counted</i> -        )  <code>RWLock</code> (   ).   : <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> <br>  ,   ++    .    . Rust        ,    .  ,   ,   .           ,       ( <a href="http://superwebdeveloper.com/2009/11/25/the-incredible-rate-of-diminishing-returns-of-fixing-software-bugs/">  </a> ). <br> <br>     <br> Rust        ,     <code>unsafe{}</code> .   ,     " <i> !  ,  .</i> ".  ,  ""  (    ,    )    .    ,           ( )  . , ,        <code>Cell</code>  <code>Mutex</code> .             ,       (   <a href="http://en.wikipedia.org/wiki/Test-driven_development">TDD</a> !). <br> <br>  <br> <a href="https://air.mozilla.org/guaranteeing-memory-safety-in-rust/">Guaranteeing Memory Safety in Rust (by Niko Matsakis)</a> <br> <a href="http://www.techtalkshub.com/rust-safe-systems-programming-fun-fp/">Rust: Safe Systems Programming with the Fun of FP (by Felix Klock II)</a> <br> <a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Keynote">Lang-NEXT: What ‚Äì if anything ‚Äì have we learned from C++? (by Bjarne Stroustrup)</a> <br> <a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Panel-Systems-Programming-Languages-in-2014-and-Beyond">Lang-NEXT Panel: Systems Programming in 2014 and Beyond</a></code></code> <blockquote> <code><code><code><code class="cpp">Box)     ,       (     ).        (std::rc::Rc)    (std::gc::Gc),      (   ). <br> <br></code>      <br>  ++: <br> #include &lt;stdio.h&gt; int *bar(int *p) { return p; } int* foo(int n) { return bar(&amp;n); } int main() { int *p1 = foo(1); int *p2 = foo(2); printf("%d, %d\n", *p1, *p2); }</code> <br>  : <br> 2, 2 <br> <br>  Rust: <br> <code class="rust">fn bar&lt;'a&gt;(p: &amp;'a int) -&gt; &amp;'a int { return p; } fn foo(n: int) -&gt; &amp;int { bar(&amp;n) } fn main() { let p1 = foo(1); let p2 = foo(2); println!("{}, {}", *p1, *p2); }</code> <br>  : <br> demo:5:10: 5:11 error: `n` does not live long enough <br> demo:5 bar(&amp;n) <br> ^ <br> demo:4:24: 6:2 note: reference must be valid for the anonymous lifetime #1 defined on the block at 4:23... <br> demo:4 fn foo(n: int) -&gt; &amp;int { <br> demo:5 bar(&amp;n) <br> demo:6 } <br> demo:4:24: 6:2 note: ...but borrowed value is only valid for the block at 4:23 <br> demo:4 fn foo(n: int) -&gt; &amp;int { <br> demo:5 bar(&amp;n) <br> demo:6 } <br> <br>   <br> <code class="cpp">#include &lt;stdio.h&gt; int minval(int *A, int n) { int currmin; for (int i=0; i&lt;n; i++) if (A[i] &lt; currmin) currmin = A[i]; return currmin; } int main() { int A[] = {1,2,3}; int min = minval(A,3); printf("%d\n", min); }</code> <br>   0  ,     , ,  .       Rust ( - ): <br> <code class="rust">fn minval(A: &amp;[int]) -&gt; int { let mut currmin; for a in A.iter() { if *a &lt; currmin { currmin = *a; } } currmin } fn main() { let A = [1i,2i,3i]; let min = minval(A.as_slice()); println!("{}", min); }</code> <br>  , : use of possibly uninitialized variable: `currmin` <br>   ( )      : <br> <code class="rust">fn minval(A: &amp;[int]) -&gt; int { A.iter().fold(A[0], |u,&amp;a| { if a&lt;u {a} else {u} }) }</code> <br> <br>    <br> <code class="cpp">struct A{ int *x; A(int v): x(new int(v)) {} ~A() {delete x;} }; int main() { A a(1), b=a; }</code> <br> ,    : <br> *** glibc detected *** demo: double free or corruption (fasttop): 0x0000000000601010 *** <br> <br>     Rust: <br> <code class="rust">struct A{ x: Box&lt;int&gt; } impl A { pub fn new(v: int) -&gt; A { A{ x: box v } } } impl Drop for A { fn drop(&amp;mut self) {} // ,     ++ } fn main() { let a = A::new(1); let _b = a; }</code> <br>     .   ,     <code>trait Copy</code> . <br> Rust       .    <code>Eq</code>  <code>Clone</code> ?    <code>deriving</code>   : <br> <code class="rust">#[deriving(Clone, Eq, Hash, PartialEq, PartialOrd, Ord, Show)] struct A{ x: Box&lt;int&gt; }</code> <br> <br>    <br> <code class="cpp">#include &lt;stdio.h&gt; struct X { int a, b; }; void swap_from(X&amp; x, const X&amp; y) { xa = yb; xb = ya; } int main() { X x = {1,2}; swap_from(x,x); printf("%d,%d\n", xa, xb); }</code> <br>  : <br> 2,2 <br>    ,    cc      .   ,   ,  99  <a href="http://en.wikipedia.org/wiki/Restrict">restrict</a> ,            :        . <br> <br>       Rust: <br> <code class="rust">struct X { pub a: int, pub b: int } fn swap_from(x: &amp;mut X, y: &amp;X) { xa = yb; xb = ya; } fn main() { let mut x = X{a:1, b:2}; swap_from(&amp;mut x, &amp;x); }</code> <br>    : <br> demo:7:24: 7:25 error: cannot borrow `x` as immutable because it is also borrowed as mutable <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> ^ <br> demo:7:20: 7:21 note: previous borrow of `x` occurs here; the mutable borrow prevents subsequent moves, borrows, or modification of `x` until the borrow ends <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> ^ <br> demo:7:26: 7:26 note: previous borrow ends here <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> <br>  ,             " <code>&amp;mut</code> "  " <code>&amp;</code> " ,   ,          ,   <code>&amp;mut</code> .            .  ,    ,      C99  <code>restrict</code>  (Rust  LLVM    ),    . <br> <br>   <br> <code class="cpp">#include &lt;vector&gt; int main() { std::vector&lt;int&gt; v; v.push_back(1); v.push_back(2); for(std::vector&lt;int&gt;::const_iterator it=v.begin(); it!=v.end(); ++it) { if (*it &lt; 5) v.push_back(5-*it); } }</code> <br>    ,    : <br> Segmentation fault (core dumped) <br> <br>    Rust: <br> <code class="rust">fn main() { let mut v: Vec&lt;int&gt; = Vec::new(); v.push(1); v.push(2); for x in v.iter() { if *x &lt; 5 { v.push(5-*x); } } }</code> <br>      ,  ,        : <br> demo:7:13: 7:14 error: cannot borrow `v` as mutable because it is also borrowed as immutable <br> demo:7 v.push(5-*x); <br> ^ <br> demo:5:14: 5:15 note: previous borrow of `v` occurs here; the immutable borrow prevents subsequent moves or mutable borrows of `v` until the borrow ends <br> demo:5 for x in v.iter() { <br> ^ <br> demo:10:2: 10:2 note: previous borrow ends here <br> demo:5 for x in v.iter() { <br> demo:6 if *x &lt; 5 { <br> demo:7 v.push(5-*x); <br> demo:8 } <br> demo:9 } <br> demo:10 } <br> <br> <br>  Switch <br> <code class="cpp">#include &lt;stdio.h&gt; enum {RED, BLUE, GRAY, UNKNOWN} color = GRAY; int main() { int x; switch(color) { case GRAY: x=1; case RED: case BLUE: x=2; } printf("%d", x); }</code> <br>   "2".  Rust          .  ,       ,    <code>break</code> .    Rust   : <br> <code class="rust">enum Color {RED, BLUE, GRAY, UNKNOWN} fn main() { let color = GRAY; let x = match color { GRAY =&gt; 1, RED | BLUE =&gt; 2, _ =&gt; 3, }; println!("{}", x); }</code> <br> <br>     <br> <code class="cpp">int main() { int pixels = 1; for (int j=0; j&lt;5; j++); pixels++; }</code> <br>  Rust          . , ,     . <br> <br>  <br> <code class="cpp">#include &lt;stdio.h&gt; #include &lt;pthread.h&gt; #include &lt;unistd.h&gt; class Resource { int *value; public: Resource(): value(NULL) {} ~Resource() {delete value;} int *acquire() { if (!value) { value = new int(0); } return value; } }; void* function(void *param) { int *value = ((Resource*)param)-&gt;acquire(); printf("resource: %p\n", (void*)value); return value; } int main() { Resource res; for (int i=0; i&lt;5; ++i) { pthread_t pt; pthread_create(&amp;pt, NULL, function, &amp;res); } //sleep(10); printf("done\n"); }</code> <br>     : <br> done <br> resource: 0x7f229c0008c0 <br> resource: 0x7f22840008c0 <br> resource: 0x7f228c0008c0 <br> resource: 0x7f22940008c0 <br> resource: 0x7f227c0008c0 <br> <br>     ,        .      Rust: <br> <code class="rust">struct Resource { value: Option&lt;int&gt;, } impl Resource { pub fn new() -&gt; Resource { Resource{ value: None } } pub fn acquire&lt;'a&gt;(&amp;'a mut self) -&gt; &amp;'a int { if self.value.is_none() { self.value = Some(1); } self.value.get_ref() } } fn main() { let mut res = Resource::new(); for _ in range(0,5) { spawn(proc() { let ptr = res.acquire(); println!("resource {}", ptr) }) } }</code> <br>  ,            . <br> demo:20:23: 20:26 error: cannot borrow immutable captured outer variable in a proc `res` as mutable <br> demo:20 let ptr = res.acquire(); <br> <br>      ,   : <br> <code class="rust">extern crate sync; use sync::{Arc, RWLock}; struct Resource { value: Option&lt;Box&lt;int&gt;&gt;, } impl Resource { pub fn new() -&gt; Resource { Resource{ value: None } } pub fn acquire(&amp;mut self) -&gt; *int { if self.value.is_none() { self.value = Some(box 1) } &amp;**self.value.get_ref() as *int } } fn main() { let arc_res = Arc::new(RWLock::new(Resource::new())); for _ in range(0,5) { let child_res = arc_res.clone(); spawn(proc() { let ptr = child_res.write().acquire(); println!("resource: {}", ptr) }) } }</code> <br>     <code>Arc</code> ( <i>Atomically Reference Counted</i> -        )  <code>RWLock</code> (   ).   : <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> <br>  ,   ++    .    . Rust        ,    .  ,   ,   .           ,       ( <a href="http://superwebdeveloper.com/2009/11/25/the-incredible-rate-of-diminishing-returns-of-fixing-software-bugs/">  </a> ). <br> <br>     <br> Rust        ,     <code>unsafe{}</code> .   ,     " <i> !  ,  .</i> ".  ,  ""  (    ,    )    .    ,           ( )  . , ,        <code>Cell</code>  <code>Mutex</code> .             ,       (   <a href="http://en.wikipedia.org/wiki/Test-driven_development">TDD</a> !). <br> <br>  <br> <a href="https://air.mozilla.org/guaranteeing-memory-safety-in-rust/">Guaranteeing Memory Safety in Rust (by Niko Matsakis)</a> <br> <a href="http://www.techtalkshub.com/rust-safe-systems-programming-fun-fp/">Rust: Safe Systems Programming with the Fun of FP (by Felix Klock II)</a> <br> <a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Keynote">Lang-NEXT: What ‚Äì if anything ‚Äì have we learned from C++? (by Bjarne Stroustrup)</a> <br> <a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Panel-Systems-Programming-Languages-in-2014-and-Beyond">Lang-NEXT Panel: Systems Programming in 2014 and Beyond</a></code></code> </blockquote> <code><code><code><code class="cpp">Box)     ,       (     ).        (std::rc::Rc)    (std::gc::Gc),      (   ). <br> <br></code>      <br>  ++: <br> #include &lt;stdio.h&gt; int *bar(int *p) { return p; } int* foo(int n) { return bar(&amp;n); } int main() { int *p1 = foo(1); int *p2 = foo(2); printf("%d, %d\n", *p1, *p2); }</code> <br>  : <br> 2, 2 <br> <br>  Rust: <br> <code class="rust">fn bar&lt;'a&gt;(p: &amp;'a int) -&gt; &amp;'a int { return p; } fn foo(n: int) -&gt; &amp;int { bar(&amp;n) } fn main() { let p1 = foo(1); let p2 = foo(2); println!("{}, {}", *p1, *p2); }</code> <br>  : <br> demo:5:10: 5:11 error: `n` does not live long enough <br> demo:5 bar(&amp;n) <br> ^ <br> demo:4:24: 6:2 note: reference must be valid for the anonymous lifetime #1 defined on the block at 4:23... <br> demo:4 fn foo(n: int) -&gt; &amp;int { <br> demo:5 bar(&amp;n) <br> demo:6 } <br> demo:4:24: 6:2 note: ...but borrowed value is only valid for the block at 4:23 <br> demo:4 fn foo(n: int) -&gt; &amp;int { <br> demo:5 bar(&amp;n) <br> demo:6 } <br> <br>   <br> <code class="cpp">#include &lt;stdio.h&gt; int minval(int *A, int n) { int currmin; for (int i=0; i&lt;n; i++) if (A[i] &lt; currmin) currmin = A[i]; return currmin; } int main() { int A[] = {1,2,3}; int min = minval(A,3); printf("%d\n", min); }</code> <br>   0  ,     , ,  .       Rust ( - ): <br> <code class="rust">fn minval(A: &amp;[int]) -&gt; int { let mut currmin; for a in A.iter() { if *a &lt; currmin { currmin = *a; } } currmin } fn main() { let A = [1i,2i,3i]; let min = minval(A.as_slice()); println!("{}", min); }</code> <br>  , : use of possibly uninitialized variable: `currmin` <br>   ( )      : <br> <code class="rust">fn minval(A: &amp;[int]) -&gt; int { A.iter().fold(A[0], |u,&amp;a| { if a&lt;u {a} else {u} }) }</code> <br> <br>    <br> <code class="cpp">struct A{ int *x; A(int v): x(new int(v)) {} ~A() {delete x;} }; int main() { A a(1), b=a; }</code> <br> ,    : <br> *** glibc detected *** demo: double free or corruption (fasttop): 0x0000000000601010 *** <br> <br>     Rust: <br> <code class="rust">struct A{ x: Box&lt;int&gt; } impl A { pub fn new(v: int) -&gt; A { A{ x: box v } } } impl Drop for A { fn drop(&amp;mut self) {} // ,     ++ } fn main() { let a = A::new(1); let _b = a; }</code> <br>     .   ,     <code>trait Copy</code> . <br> Rust       .    <code>Eq</code>  <code>Clone</code> ?    <code>deriving</code>   : <br> <code class="rust">#[deriving(Clone, Eq, Hash, PartialEq, PartialOrd, Ord, Show)] struct A{ x: Box&lt;int&gt; }</code> <br> <br>    <br> <code class="cpp">#include &lt;stdio.h&gt; struct X { int a, b; }; void swap_from(X&amp; x, const X&amp; y) { xa = yb; xb = ya; } int main() { X x = {1,2}; swap_from(x,x); printf("%d,%d\n", xa, xb); }</code> <br>  : <br> 2,2 <br>    ,    cc      .   ,   ,  99  <a href="http://en.wikipedia.org/wiki/Restrict">restrict</a> ,            :        . <br> <br>       Rust: <br> <code class="rust">struct X { pub a: int, pub b: int } fn swap_from(x: &amp;mut X, y: &amp;X) { xa = yb; xb = ya; } fn main() { let mut x = X{a:1, b:2}; swap_from(&amp;mut x, &amp;x); }</code> <br>    : <br> demo:7:24: 7:25 error: cannot borrow `x` as immutable because it is also borrowed as mutable <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> ^ <br> demo:7:20: 7:21 note: previous borrow of `x` occurs here; the mutable borrow prevents subsequent moves, borrows, or modification of `x` until the borrow ends <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> ^ <br> demo:7:26: 7:26 note: previous borrow ends here <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> <br>  ,             " <code>&amp;mut</code> "  " <code>&amp;</code> " ,   ,          ,   <code>&amp;mut</code> .            .  ,    ,      C99  <code>restrict</code>  (Rust  LLVM    ),    . <br> <br>   <br> <code class="cpp">#include &lt;vector&gt; int main() { std::vector&lt;int&gt; v; v.push_back(1); v.push_back(2); for(std::vector&lt;int&gt;::const_iterator it=v.begin(); it!=v.end(); ++it) { if (*it &lt; 5) v.push_back(5-*it); } }</code> <br>    ,    : <br> Segmentation fault (core dumped) <br> <br>    Rust: <br> <code class="rust">fn main() { let mut v: Vec&lt;int&gt; = Vec::new(); v.push(1); v.push(2); for x in v.iter() { if *x &lt; 5 { v.push(5-*x); } } }</code> <br>      ,  ,        : <br> demo:7:13: 7:14 error: cannot borrow `v` as mutable because it is also borrowed as immutable <br> demo:7 v.push(5-*x); <br> ^ <br> demo:5:14: 5:15 note: previous borrow of `v` occurs here; the immutable borrow prevents subsequent moves or mutable borrows of `v` until the borrow ends <br> demo:5 for x in v.iter() { <br> ^ <br> demo:10:2: 10:2 note: previous borrow ends here <br> demo:5 for x in v.iter() { <br> demo:6 if *x &lt; 5 { <br> demo:7 v.push(5-*x); <br> demo:8 } <br> demo:9 } <br> demo:10 } <br> <br> <br>  Switch <br> <code class="cpp">#include &lt;stdio.h&gt; enum {RED, BLUE, GRAY, UNKNOWN} color = GRAY; int main() { int x; switch(color) { case GRAY: x=1; case RED: case BLUE: x=2; } printf("%d", x); }</code> <br>   "2".  Rust          .  ,       ,    <code>break</code> .    Rust   : <br> <code class="rust">enum Color {RED, BLUE, GRAY, UNKNOWN} fn main() { let color = GRAY; let x = match color { GRAY =&gt; 1, RED | BLUE =&gt; 2, _ =&gt; 3, }; println!("{}", x); }</code> <br> <br>     <br> <code class="cpp">int main() { int pixels = 1; for (int j=0; j&lt;5; j++); pixels++; }</code> <br>  Rust          . , ,     . <br> <br>  <br> <code class="cpp">#include &lt;stdio.h&gt; #include &lt;pthread.h&gt; #include &lt;unistd.h&gt; class Resource { int *value; public: Resource(): value(NULL) {} ~Resource() {delete value;} int *acquire() { if (!value) { value = new int(0); } return value; } }; void* function(void *param) { int *value = ((Resource*)param)-&gt;acquire(); printf("resource: %p\n", (void*)value); return value; } int main() { Resource res; for (int i=0; i&lt;5; ++i) { pthread_t pt; pthread_create(&amp;pt, NULL, function, &amp;res); } //sleep(10); printf("done\n"); }</code> <br>     : <br> done <br> resource: 0x7f229c0008c0 <br> resource: 0x7f22840008c0 <br> resource: 0x7f228c0008c0 <br> resource: 0x7f22940008c0 <br> resource: 0x7f227c0008c0 <br> <br>     ,        .      Rust: <br> <code class="rust">struct Resource { value: Option&lt;int&gt;, } impl Resource { pub fn new() -&gt; Resource { Resource{ value: None } } pub fn acquire&lt;'a&gt;(&amp;'a mut self) -&gt; &amp;'a int { if self.value.is_none() { self.value = Some(1); } self.value.get_ref() } } fn main() { let mut res = Resource::new(); for _ in range(0,5) { spawn(proc() { let ptr = res.acquire(); println!("resource {}", ptr) }) } }</code> <br>  ,            . <br> demo:20:23: 20:26 error: cannot borrow immutable captured outer variable in a proc `res` as mutable <br> demo:20 let ptr = res.acquire(); <br> <br>      ,   : <br> <code class="rust">extern crate sync; use sync::{Arc, RWLock}; struct Resource { value: Option&lt;Box&lt;int&gt;&gt;, } impl Resource { pub fn new() -&gt; Resource { Resource{ value: None } } pub fn acquire(&amp;mut self) -&gt; *int { if self.value.is_none() { self.value = Some(box 1) } &amp;**self.value.get_ref() as *int } } fn main() { let arc_res = Arc::new(RWLock::new(Resource::new())); for _ in range(0,5) { let child_res = arc_res.clone(); spawn(proc() { let ptr = child_res.write().acquire(); println!("resource: {}", ptr) }) } }</code> <br>     <code>Arc</code> ( <i>Atomically Reference Counted</i> -        )  <code>RWLock</code> (   ).   : <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> <br>  ,   ++    .    . Rust        ,    .  ,   ,   .           ,       ( <a href="http://superwebdeveloper.com/2009/11/25/the-incredible-rate-of-diminishing-returns-of-fixing-software-bugs/">  </a> ). <br> <br>     <br> Rust        ,     <code>unsafe{}</code> .   ,     " <i> !  ,  .</i> ".  ,  ""  (    ,    )    .    ,           ( )  . , ,        <code>Cell</code>  <code>Mutex</code> .             ,       (   <a href="http://en.wikipedia.org/wiki/Test-driven_development">TDD</a> !). <br> <br>  <br> <a href="https://air.mozilla.org/guaranteeing-memory-safety-in-rust/">Guaranteeing Memory Safety in Rust (by Niko Matsakis)</a> <br> <a href="http://www.techtalkshub.com/rust-safe-systems-programming-fun-fp/">Rust: Safe Systems Programming with the Fun of FP (by Felix Klock II)</a> <br> <a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Keynote">Lang-NEXT: What ‚Äì if anything ‚Äì have we learned from C++? (by Bjarne Stroustrup)</a> <br> <a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Panel-Systems-Programming-Languages-in-2014-and-Beyond">Lang-NEXT Panel: Systems Programming in 2014 and Beyond</a></code></code> <pre> <code class="hljs rust"><code><code><code class="cpp"><span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>)     ,       (     ).        (std::rc::Rc)    (std::gc::Gc),      (   ). <br> <br></code>      <br>  ++: <br> #include &lt;stdio.h&gt; int *bar(int *p) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p; } int* foo(int n) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bar(&amp;n); } int main() { int *p1 = foo(<span class="hljs-number"><span class="hljs-number">1</span></span>); int *p2 = foo(<span class="hljs-number"><span class="hljs-number">2</span></span>); printf(<span class="hljs-string"><span class="hljs-string">"%d, %d\n"</span></span>, *p1, *p2); }</code> <br>  : <br> <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span> <br> <br>  Rust: <br> <code class="rust"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt;(p: &amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> int) -&gt; &amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> int { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>(n: int) -&gt; &amp;int { bar(&amp;n) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> p1 = foo(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> p2 = foo(<span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{}, {}"</span></span>, *p1, *p2); }</code> <br>  : <br> demo:<span class="hljs-number"><span class="hljs-number">5</span></span>:<span class="hljs-number"><span class="hljs-number">10</span></span>: <span class="hljs-number"><span class="hljs-number">5</span></span>:<span class="hljs-number"><span class="hljs-number">11</span></span> error: `n` does not live long enough <br> demo:<span class="hljs-number"><span class="hljs-number">5</span></span> bar(&amp;n) <br> ^ <br> demo:<span class="hljs-number"><span class="hljs-number">4</span></span>:<span class="hljs-number"><span class="hljs-number">24</span></span>: <span class="hljs-number"><span class="hljs-number">6</span></span>:<span class="hljs-number"><span class="hljs-number">2</span></span> note: reference must <span class="hljs-keyword"><span class="hljs-keyword">be</span></span> valid <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> the anonymous lifetime #<span class="hljs-number"><span class="hljs-number">1</span></span> defined on the block at <span class="hljs-number"><span class="hljs-number">4</span></span>:<span class="hljs-number"><span class="hljs-number">23</span></span>... <br> demo:<span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>(n: int) -&gt; &amp;int { <br> demo:<span class="hljs-number"><span class="hljs-number">5</span></span> bar(&amp;n) <br> demo:<span class="hljs-number"><span class="hljs-number">6</span></span> } <br> demo:<span class="hljs-number"><span class="hljs-number">4</span></span>:<span class="hljs-number"><span class="hljs-number">24</span></span>: <span class="hljs-number"><span class="hljs-number">6</span></span>:<span class="hljs-number"><span class="hljs-number">2</span></span> note: ...but borrowed value is only valid <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> the block at <span class="hljs-number"><span class="hljs-number">4</span></span>:<span class="hljs-number"><span class="hljs-number">23</span></span> <br> demo:<span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>(n: int) -&gt; &amp;int { <br> demo:<span class="hljs-number"><span class="hljs-number">5</span></span> bar(&amp;n) <br> demo:<span class="hljs-number"><span class="hljs-number">6</span></span> } <br> <br>   <br> <code class="cpp">#include &lt;stdio.h&gt; int minval(int *A, int n) { int currmin; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;n; i++) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (A[i] &lt; currmin) currmin = A[i]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> currmin; } int main() { int A[] = {<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>}; int min = minval(A,<span class="hljs-number"><span class="hljs-number">3</span></span>); printf(<span class="hljs-string"><span class="hljs-string">"%d\n"</span></span>, min); }</code> <br>   <span class="hljs-number"><span class="hljs-number">0</span></span>  ,     , ,  .       Rust ( - ): <br> <code class="rust"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">minval</span></span></span></span>(A: &amp;[int]) -&gt; int { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> currmin; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> a <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> A.iter() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> *a &lt; currmin { currmin = *a; } } currmin } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> A = [<span class="hljs-number"><span class="hljs-number">1</span></span>i,<span class="hljs-number"><span class="hljs-number">2</span></span>i,<span class="hljs-number"><span class="hljs-number">3</span></span>i]; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> min = minval(A.as_slice()); <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{}"</span></span>, min); }</code> <br>  , : <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> of possibly uninitialized variable: `currmin` <br>   ( )      : <br> <code class="rust"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">minval</span></span></span></span>(A: &amp;[int]) -&gt; int { A.iter().fold(A[<span class="hljs-number"><span class="hljs-number">0</span></span>], |u,&amp;a| { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> a&lt;u {a} <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {u} }) }</code> <br> <br>    <br> <code class="cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span></span>{ int *x; A(int v): x(new int(v)) {} ~A() {delete x;} }; int main() { A a(<span class="hljs-number"><span class="hljs-number">1</span></span>), b=a; }</code> <br> ,    : <br> *** glibc detected *** demo: double free or corruption (fasttop): <span class="hljs-number"><span class="hljs-number">0x0000000000601010</span></span> *** <br> <br>     Rust: <br> <code class="rust"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span></span>{ x: <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;int&gt; } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> A { <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">new</span></span></span></span>(v: int) -&gt; A { A{ x: <span class="hljs-keyword"><span class="hljs-keyword">box</span></span> v } } } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Drop</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> A { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drop</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) {} <span class="hljs-comment"><span class="hljs-comment">// ,     ++ } fn main() { let a = A::new(1); let _b = a; }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">     .   ,     </span></span><code><span class="hljs-comment"><span class="hljs-comment">trait Copy</span></span></code><span class="hljs-comment"><span class="hljs-comment"> . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> Rust       .    </span></span><code><span class="hljs-comment"><span class="hljs-comment">Eq</span></span></code><span class="hljs-comment"><span class="hljs-comment">  </span></span><code><span class="hljs-comment"><span class="hljs-comment">Clone</span></span></code><span class="hljs-comment"><span class="hljs-comment"> ?    </span></span><code><span class="hljs-comment"><span class="hljs-comment">deriving</span></span></code><span class="hljs-comment"><span class="hljs-comment">   : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="rust"><span class="hljs-comment"><span class="hljs-comment">#[deriving(Clone, Eq, Hash, PartialEq, PartialOrd, Ord, Show)] struct A{ x: Box&lt;int&gt; }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">    </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="cpp"><span class="hljs-comment"><span class="hljs-comment">#include &lt;stdio.h&gt; struct X { int a, b; }; void swap_from(X&amp; x, const X&amp; y) { xa = yb; xb = ya; } int main() { X x = {1,2}; swap_from(x,x); printf("%d,%d\n", xa, xb); }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> 2,2 </span></span><br><span class="hljs-comment"><span class="hljs-comment">    ,    cc      .   ,   ,  99  </span></span><a href="http://en.wikipedia.org/wiki/Restrict"><span class="hljs-comment"><span class="hljs-comment">restrict</span></span></a><span class="hljs-comment"><span class="hljs-comment"> ,            :        . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">       Rust: </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="rust"><span class="hljs-comment"><span class="hljs-comment">struct X { pub a: int, pub b: int } fn swap_from(x: &amp;mut X, y: &amp;X) { xa = yb; xb = ya; } fn main() { let mut x = X{a:1, b:2}; swap_from(&amp;mut x, &amp;x); }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">    : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7:24: 7:25 error: cannot borrow `x` as immutable because it is also borrowed as mutable </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7 swap_from(&amp;mut x, &amp;x); </span></span><br><span class="hljs-comment"><span class="hljs-comment"> ^ </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7:20: 7:21 note: previous borrow of `x` occurs here; the mutable borrow prevents subsequent moves, borrows, or modification of `x` until the borrow ends </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7 swap_from(&amp;mut x, &amp;x); </span></span><br><span class="hljs-comment"><span class="hljs-comment"> ^ </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7:26: 7:26 note: previous borrow ends here </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7 swap_from(&amp;mut x, &amp;x); </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  ,             " </span></span><code><span class="hljs-comment"><span class="hljs-comment">&amp;mut</span></span></code><span class="hljs-comment"><span class="hljs-comment"> "  " </span></span><code><span class="hljs-comment"><span class="hljs-comment">&amp;</span></span></code><span class="hljs-comment"><span class="hljs-comment"> " ,   ,          ,   </span></span><code><span class="hljs-comment"><span class="hljs-comment">&amp;mut</span></span></code><span class="hljs-comment"><span class="hljs-comment"> .            .  ,    ,      C99  </span></span><code><span class="hljs-comment"><span class="hljs-comment">restrict</span></span></code><span class="hljs-comment"><span class="hljs-comment">  (Rust  LLVM    ),    . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">   </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="cpp"><span class="hljs-comment"><span class="hljs-comment">#include &lt;vector&gt; int main() { std::vector&lt;int&gt; v; v.push_back(1); v.push_back(2); for(std::vector&lt;int&gt;::const_iterator it=v.begin(); it!=v.end(); ++it) { if (*it &lt; 5) v.push_back(5-*it); } }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">    ,    : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> Segmentation fault (core dumped) </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">    Rust: </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="rust"><span class="hljs-comment"><span class="hljs-comment">fn main() { let mut v: Vec&lt;int&gt; = Vec::new(); v.push(1); v.push(2); for x in v.iter() { if *x &lt; 5 { v.push(5-*x); } } }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">      ,  ,        : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7:13: 7:14 error: cannot borrow `v` as mutable because it is also borrowed as immutable </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7 v.push(5-*x); </span></span><br><span class="hljs-comment"><span class="hljs-comment"> ^ </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:5:14: 5:15 note: previous borrow of `v` occurs here; the immutable borrow prevents subsequent moves or mutable borrows of `v` until the borrow ends </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:5 for x in v.iter() { </span></span><br><span class="hljs-comment"><span class="hljs-comment"> ^ </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:10:2: 10:2 note: previous borrow ends here </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:5 for x in v.iter() { </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:6 if *x &lt; 5 { </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7 v.push(5-*x); </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:8 } </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:9 } </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:10 } </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  Switch </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="cpp"><span class="hljs-comment"><span class="hljs-comment">#include &lt;stdio.h&gt; enum {RED, BLUE, GRAY, UNKNOWN} color = GRAY; int main() { int x; switch(color) { case GRAY: x=1; case RED: case BLUE: x=2; } printf("%d", x); }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">   "2".  Rust          .  ,       ,    </span></span><code><span class="hljs-comment"><span class="hljs-comment">break</span></span></code><span class="hljs-comment"><span class="hljs-comment"> .    Rust   : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="rust"><span class="hljs-comment"><span class="hljs-comment">enum Color {RED, BLUE, GRAY, UNKNOWN} fn main() { let color = GRAY; let x = match color { GRAY =&gt; 1, RED | BLUE =&gt; 2, _ =&gt; 3, }; println!("{}", x); }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">     </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="cpp"><span class="hljs-comment"><span class="hljs-comment">int main() { int pixels = 1; for (int j=0; j&lt;5; j++); pixels++; }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  Rust          . , ,     . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="cpp"><span class="hljs-comment"><span class="hljs-comment">#include &lt;stdio.h&gt; #include &lt;pthread.h&gt; #include &lt;unistd.h&gt; class Resource { int *value; public: Resource(): value(NULL) {} ~Resource() {delete value;} int *acquire() { if (!value) { value = new int(0); } return value; } }; void* function(void *param) { int *value = ((Resource*)param)-&gt;acquire(); printf("resource: %p\n", (void*)value); return value; } int main() { Resource res; for (int i=0; i&lt;5; ++i) { pthread_t pt; pthread_create(&amp;pt, NULL, function, &amp;res); } //sleep(10); printf("done\n"); }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">     : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> done </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7f229c0008c0 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7f22840008c0 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7f228c0008c0 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7f22940008c0 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7f227c0008c0 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">     ,        .      Rust: </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="rust"><span class="hljs-comment"><span class="hljs-comment">struct Resource { value: Option&lt;int&gt;, } impl Resource { pub fn new() -&gt; Resource { Resource{ value: None } } pub fn acquire&lt;'a&gt;(&amp;'a mut self) -&gt; &amp;'a int { if self.value.is_none() { self.value = Some(1); } self.value.get_ref() } } fn main() { let mut res = Resource::new(); for _ in range(0,5) { spawn(proc() { let ptr = res.acquire(); println!("resource {}", ptr) }) } }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  ,            . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:20:23: 20:26 error: cannot borrow immutable captured outer variable in a proc `res` as mutable </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:20 let ptr = res.acquire(); </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">      ,   : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="rust"><span class="hljs-comment"><span class="hljs-comment">extern crate sync; use sync::{Arc, RWLock}; struct Resource { value: Option&lt;Box&lt;int&gt;&gt;, } impl Resource { pub fn new() -&gt; Resource { Resource{ value: None } } pub fn acquire(&amp;mut self) -&gt; *int { if self.value.is_none() { self.value = Some(box 1) } &amp;**self.value.get_ref() as *int } } fn main() { let arc_res = Arc::new(RWLock::new(Resource::new())); for _ in range(0,5) { let child_res = arc_res.clone(); spawn(proc() { let ptr = child_res.write().acquire(); println!("resource: {}", ptr) }) } }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">     </span></span><code><span class="hljs-comment"><span class="hljs-comment">Arc</span></span></code><span class="hljs-comment"><span class="hljs-comment"> ( </span></span><i><span class="hljs-comment"><span class="hljs-comment">Atomically Reference Counted</span></span></i><span class="hljs-comment"><span class="hljs-comment"> -        )  </span></span><code><span class="hljs-comment"><span class="hljs-comment">RWLock</span></span></code><span class="hljs-comment"><span class="hljs-comment"> (   ).   : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7ff4b0010378 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7ff4b0010378 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7ff4b0010378 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7ff4b0010378 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7ff4b0010378 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  ,   ++    .    . Rust        ,    .  ,   ,   .           ,       ( </span></span><a href="http://superwebdeveloper.com/2009/11/25/the-incredible-rate-of-diminishing-returns-of-fixing-software-bugs/"><span class="hljs-comment"><span class="hljs-comment">  </span></span></a><span class="hljs-comment"><span class="hljs-comment"> ). </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">     </span></span><br><span class="hljs-comment"><span class="hljs-comment"> Rust        ,     </span></span><code><span class="hljs-comment"><span class="hljs-comment">unsafe{}</span></span></code><span class="hljs-comment"><span class="hljs-comment"> .   ,     " </span></span><i><span class="hljs-comment"><span class="hljs-comment"> !  ,  .</span></span></i><span class="hljs-comment"><span class="hljs-comment"> ".  ,  ""  (    ,    )    .    ,           ( )  . , ,        </span></span><code><span class="hljs-comment"><span class="hljs-comment">Cell</span></span></code><span class="hljs-comment"><span class="hljs-comment">  </span></span><code><span class="hljs-comment"><span class="hljs-comment">Mutex</span></span></code><span class="hljs-comment"><span class="hljs-comment"> .             ,       (   </span></span><a href="http://en.wikipedia.org/wiki/Test-driven_development"><span class="hljs-comment"><span class="hljs-comment">TDD</span></span></a><span class="hljs-comment"><span class="hljs-comment"> !). </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="https://air.mozilla.org/guaranteeing-memory-safety-in-rust/"><span class="hljs-comment"><span class="hljs-comment">Guaranteeing Memory Safety in Rust (by Niko Matsakis)</span></span></a><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="http://www.techtalkshub.com/rust-safe-systems-programming-fun-fp/"><span class="hljs-comment"><span class="hljs-comment">Rust: Safe Systems Programming with the Fun of FP (by Felix Klock II)</span></span></a><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Keynote"><span class="hljs-comment"><span class="hljs-comment">Lang-NEXT: What ‚Äì if anything ‚Äì have we learned from C++? (by Bjarne Stroustrup)</span></span></a><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Panel-Systems-Programming-Languages-in-2014-and-Beyond"><span class="hljs-comment"><span class="hljs-comment">Lang-NEXT Panel: Systems Programming in 2014 and Beyond</span></span></a></code></code> </pre> <code><code><code><code class="cpp">Box)     ,       (     ).        (std::rc::Rc)    (std::gc::Gc),      (   ). <br> <br></code>      <br>  ++: <br> #include &lt;stdio.h&gt; int *bar(int *p) { return p; } int* foo(int n) { return bar(&amp;n); } int main() { int *p1 = foo(1); int *p2 = foo(2); printf("%d, %d\n", *p1, *p2); }</code> <br>  : <br> 2, 2 <br> <br>  Rust: <br> <code class="rust">fn bar&lt;'a&gt;(p: &amp;'a int) -&gt; &amp;'a int { return p; } fn foo(n: int) -&gt; &amp;int { bar(&amp;n) } fn main() { let p1 = foo(1); let p2 = foo(2); println!("{}, {}", *p1, *p2); }</code> <br>  : <br> demo:5:10: 5:11 error: `n` does not live long enough <br> demo:5 bar(&amp;n) <br> ^ <br> demo:4:24: 6:2 note: reference must be valid for the anonymous lifetime #1 defined on the block at 4:23... <br> demo:4 fn foo(n: int) -&gt; &amp;int { <br> demo:5 bar(&amp;n) <br> demo:6 } <br> demo:4:24: 6:2 note: ...but borrowed value is only valid for the block at 4:23 <br> demo:4 fn foo(n: int) -&gt; &amp;int { <br> demo:5 bar(&amp;n) <br> demo:6 } <br> <br>   <br> <code class="cpp">#include &lt;stdio.h&gt; int minval(int *A, int n) { int currmin; for (int i=0; i&lt;n; i++) if (A[i] &lt; currmin) currmin = A[i]; return currmin; } int main() { int A[] = {1,2,3}; int min = minval(A,3); printf("%d\n", min); }</code> <br>   0  ,     , ,  .       Rust ( - ): <br> <code class="rust">fn minval(A: &amp;[int]) -&gt; int { let mut currmin; for a in A.iter() { if *a &lt; currmin { currmin = *a; } } currmin } fn main() { let A = [1i,2i,3i]; let min = minval(A.as_slice()); println!("{}", min); }</code> <br>  , : use of possibly uninitialized variable: `currmin` <br>   ( )      : <br> <code class="rust">fn minval(A: &amp;[int]) -&gt; int { A.iter().fold(A[0], |u,&amp;a| { if a&lt;u {a} else {u} }) }</code> <br> <br>    <br> <code class="cpp">struct A{ int *x; A(int v): x(new int(v)) {} ~A() {delete x;} }; int main() { A a(1), b=a; }</code> <br> ,    : <br> *** glibc detected *** demo: double free or corruption (fasttop): 0x0000000000601010 *** <br> <br>     Rust: <br> <code class="rust">struct A{ x: Box&lt;int&gt; } impl A { pub fn new(v: int) -&gt; A { A{ x: box v } } } impl Drop for A { fn drop(&amp;mut self) {} // ,     ++ } fn main() { let a = A::new(1); let _b = a; }</code> <br>     .   ,     <code>trait Copy</code> . <br> Rust       .    <code>Eq</code>  <code>Clone</code> ?    <code>deriving</code>   : <br> <code class="rust">#[deriving(Clone, Eq, Hash, PartialEq, PartialOrd, Ord, Show)] struct A{ x: Box&lt;int&gt; }</code> <br> <br>    <br> <code class="cpp">#include &lt;stdio.h&gt; struct X { int a, b; }; void swap_from(X&amp; x, const X&amp; y) { xa = yb; xb = ya; } int main() { X x = {1,2}; swap_from(x,x); printf("%d,%d\n", xa, xb); }</code> <br>  : <br> 2,2 <br>    ,    cc      .   ,   ,  99  <a href="http://en.wikipedia.org/wiki/Restrict">restrict</a> ,            :        . <br> <br>       Rust: <br> <code class="rust">struct X { pub a: int, pub b: int } fn swap_from(x: &amp;mut X, y: &amp;X) { xa = yb; xb = ya; } fn main() { let mut x = X{a:1, b:2}; swap_from(&amp;mut x, &amp;x); }</code> <br>    : <br> demo:7:24: 7:25 error: cannot borrow `x` as immutable because it is also borrowed as mutable <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> ^ <br> demo:7:20: 7:21 note: previous borrow of `x` occurs here; the mutable borrow prevents subsequent moves, borrows, or modification of `x` until the borrow ends <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> ^ <br> demo:7:26: 7:26 note: previous borrow ends here <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> <br>  ,             " <code>&amp;mut</code> "  " <code>&amp;</code> " ,   ,          ,   <code>&amp;mut</code> .            .  ,    ,      C99  <code>restrict</code>  (Rust  LLVM    ),    . <br> <br>   <br> <code class="cpp">#include &lt;vector&gt; int main() { std::vector&lt;int&gt; v; v.push_back(1); v.push_back(2); for(std::vector&lt;int&gt;::const_iterator it=v.begin(); it!=v.end(); ++it) { if (*it &lt; 5) v.push_back(5-*it); } }</code> <br>    ,    : <br> Segmentation fault (core dumped) <br> <br>    Rust: <br> <code class="rust">fn main() { let mut v: Vec&lt;int&gt; = Vec::new(); v.push(1); v.push(2); for x in v.iter() { if *x &lt; 5 { v.push(5-*x); } } }</code> <br>      ,  ,        : <br> demo:7:13: 7:14 error: cannot borrow `v` as mutable because it is also borrowed as immutable <br> demo:7 v.push(5-*x); <br> ^ <br> demo:5:14: 5:15 note: previous borrow of `v` occurs here; the immutable borrow prevents subsequent moves or mutable borrows of `v` until the borrow ends <br> demo:5 for x in v.iter() { <br> ^ <br> demo:10:2: 10:2 note: previous borrow ends here <br> demo:5 for x in v.iter() { <br> demo:6 if *x &lt; 5 { <br> demo:7 v.push(5-*x); <br> demo:8 } <br> demo:9 } <br> demo:10 } <br> <br> <br>  Switch <br> <code class="cpp">#include &lt;stdio.h&gt; enum {RED, BLUE, GRAY, UNKNOWN} color = GRAY; int main() { int x; switch(color) { case GRAY: x=1; case RED: case BLUE: x=2; } printf("%d", x); }</code> <br>   "2".  Rust          .  ,       ,    <code>break</code> .    Rust   : <br> <code class="rust">enum Color {RED, BLUE, GRAY, UNKNOWN} fn main() { let color = GRAY; let x = match color { GRAY =&gt; 1, RED | BLUE =&gt; 2, _ =&gt; 3, }; println!("{}", x); }</code> <br> <br>     <br> <code class="cpp">int main() { int pixels = 1; for (int j=0; j&lt;5; j++); pixels++; }</code> <br>  Rust          . , ,     . <br> <br>  <br> <code class="cpp">#include &lt;stdio.h&gt; #include &lt;pthread.h&gt; #include &lt;unistd.h&gt; class Resource { int *value; public: Resource(): value(NULL) {} ~Resource() {delete value;} int *acquire() { if (!value) { value = new int(0); } return value; } }; void* function(void *param) { int *value = ((Resource*)param)-&gt;acquire(); printf("resource: %p\n", (void*)value); return value; } int main() { Resource res; for (int i=0; i&lt;5; ++i) { pthread_t pt; pthread_create(&amp;pt, NULL, function, &amp;res); } //sleep(10); printf("done\n"); }</code> <br>     : <br> done <br> resource: 0x7f229c0008c0 <br> resource: 0x7f22840008c0 <br> resource: 0x7f228c0008c0 <br> resource: 0x7f22940008c0 <br> resource: 0x7f227c0008c0 <br> <br>     ,        .      Rust: <br> <code class="rust">struct Resource { value: Option&lt;int&gt;, } impl Resource { pub fn new() -&gt; Resource { Resource{ value: None } } pub fn acquire&lt;'a&gt;(&amp;'a mut self) -&gt; &amp;'a int { if self.value.is_none() { self.value = Some(1); } self.value.get_ref() } } fn main() { let mut res = Resource::new(); for _ in range(0,5) { spawn(proc() { let ptr = res.acquire(); println!("resource {}", ptr) }) } }</code> <br>  ,            . <br> demo:20:23: 20:26 error: cannot borrow immutable captured outer variable in a proc `res` as mutable <br> demo:20 let ptr = res.acquire(); <br> <br>      ,   : <br> <code class="rust">extern crate sync; use sync::{Arc, RWLock}; struct Resource { value: Option&lt;Box&lt;int&gt;&gt;, } impl Resource { pub fn new() -&gt; Resource { Resource{ value: None } } pub fn acquire(&amp;mut self) -&gt; *int { if self.value.is_none() { self.value = Some(box 1) } &amp;**self.value.get_ref() as *int } } fn main() { let arc_res = Arc::new(RWLock::new(Resource::new())); for _ in range(0,5) { let child_res = arc_res.clone(); spawn(proc() { let ptr = child_res.write().acquire(); println!("resource: {}", ptr) }) } }</code> <br>     <code>Arc</code> ( <i>Atomically Reference Counted</i> -        )  <code>RWLock</code> (   ).   : <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> <br>  ,   ++    .    . Rust        ,    .  ,   ,   .           ,       ( <a href="http://superwebdeveloper.com/2009/11/25/the-incredible-rate-of-diminishing-returns-of-fixing-software-bugs/">  </a> ). <br> <br>     <br> Rust        ,     <code>unsafe{}</code> .   ,     " <i> !  ,  .</i> ".  ,  ""  (    ,    )    .    ,           ( )  . , ,        <code>Cell</code>  <code>Mutex</code> .             ,       (   <a href="http://en.wikipedia.org/wiki/Test-driven_development">TDD</a> !). <br> <br>  <br> <a href="https://air.mozilla.org/guaranteeing-memory-safety-in-rust/">Guaranteeing Memory Safety in Rust (by Niko Matsakis)</a> <br> <a href="http://www.techtalkshub.com/rust-safe-systems-programming-fun-fp/">Rust: Safe Systems Programming with the Fun of FP (by Felix Klock II)</a> <br> <a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Keynote">Lang-NEXT: What ‚Äì if anything ‚Äì have we learned from C++? (by Bjarne Stroustrup)</a> <br> <a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Panel-Systems-Programming-Languages-in-2014-and-Beyond">Lang-NEXT Panel: Systems Programming in 2014 and Beyond</a></code></code> <blockquote> <code><code><code><code class="cpp">Box)     ,       (     ).        (std::rc::Rc)    (std::gc::Gc),      (   ). <br> <br></code>      <br>  ++: <br> #include &lt;stdio.h&gt; int *bar(int *p) { return p; } int* foo(int n) { return bar(&amp;n); } int main() { int *p1 = foo(1); int *p2 = foo(2); printf("%d, %d\n", *p1, *p2); }</code> <br>  : <br> 2, 2 <br> <br>  Rust: <br> <code class="rust">fn bar&lt;'a&gt;(p: &amp;'a int) -&gt; &amp;'a int { return p; } fn foo(n: int) -&gt; &amp;int { bar(&amp;n) } fn main() { let p1 = foo(1); let p2 = foo(2); println!("{}, {}", *p1, *p2); }</code> <br>  : <br> demo:5:10: 5:11 error: `n` does not live long enough <br> demo:5 bar(&amp;n) <br> ^ <br> demo:4:24: 6:2 note: reference must be valid for the anonymous lifetime #1 defined on the block at 4:23... <br> demo:4 fn foo(n: int) -&gt; &amp;int { <br> demo:5 bar(&amp;n) <br> demo:6 } <br> demo:4:24: 6:2 note: ...but borrowed value is only valid for the block at 4:23 <br> demo:4 fn foo(n: int) -&gt; &amp;int { <br> demo:5 bar(&amp;n) <br> demo:6 } <br> <br>   <br> <code class="cpp">#include &lt;stdio.h&gt; int minval(int *A, int n) { int currmin; for (int i=0; i&lt;n; i++) if (A[i] &lt; currmin) currmin = A[i]; return currmin; } int main() { int A[] = {1,2,3}; int min = minval(A,3); printf("%d\n", min); }</code> <br>   0  ,     , ,  .       Rust ( - ): <br> <code class="rust">fn minval(A: &amp;[int]) -&gt; int { let mut currmin; for a in A.iter() { if *a &lt; currmin { currmin = *a; } } currmin } fn main() { let A = [1i,2i,3i]; let min = minval(A.as_slice()); println!("{}", min); }</code> <br>  , : use of possibly uninitialized variable: `currmin` <br>   ( )      : <br> <code class="rust">fn minval(A: &amp;[int]) -&gt; int { A.iter().fold(A[0], |u,&amp;a| { if a&lt;u {a} else {u} }) }</code> <br> <br>    <br> <code class="cpp">struct A{ int *x; A(int v): x(new int(v)) {} ~A() {delete x;} }; int main() { A a(1), b=a; }</code> <br> ,    : <br> *** glibc detected *** demo: double free or corruption (fasttop): 0x0000000000601010 *** <br> <br>     Rust: <br> <code class="rust">struct A{ x: Box&lt;int&gt; } impl A { pub fn new(v: int) -&gt; A { A{ x: box v } } } impl Drop for A { fn drop(&amp;mut self) {} // ,     ++ } fn main() { let a = A::new(1); let _b = a; }</code> <br>     .   ,     <code>trait Copy</code> . <br> Rust       .    <code>Eq</code>  <code>Clone</code> ?    <code>deriving</code>   : <br> <code class="rust">#[deriving(Clone, Eq, Hash, PartialEq, PartialOrd, Ord, Show)] struct A{ x: Box&lt;int&gt; }</code> <br> <br>    <br> <code class="cpp">#include &lt;stdio.h&gt; struct X { int a, b; }; void swap_from(X&amp; x, const X&amp; y) { xa = yb; xb = ya; } int main() { X x = {1,2}; swap_from(x,x); printf("%d,%d\n", xa, xb); }</code> <br>  : <br> 2,2 <br>    ,    cc      .   ,   ,  99  <a href="http://en.wikipedia.org/wiki/Restrict">restrict</a> ,            :        . <br> <br>       Rust: <br> <code class="rust">struct X { pub a: int, pub b: int } fn swap_from(x: &amp;mut X, y: &amp;X) { xa = yb; xb = ya; } fn main() { let mut x = X{a:1, b:2}; swap_from(&amp;mut x, &amp;x); }</code> <br>    : <br> demo:7:24: 7:25 error: cannot borrow `x` as immutable because it is also borrowed as mutable <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> ^ <br> demo:7:20: 7:21 note: previous borrow of `x` occurs here; the mutable borrow prevents subsequent moves, borrows, or modification of `x` until the borrow ends <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> ^ <br> demo:7:26: 7:26 note: previous borrow ends here <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> <br>  ,             " <code>&amp;mut</code> "  " <code>&amp;</code> " ,   ,          ,   <code>&amp;mut</code> .            .  ,    ,      C99  <code>restrict</code>  (Rust  LLVM    ),    . <br> <br>   <br> <code class="cpp">#include &lt;vector&gt; int main() { std::vector&lt;int&gt; v; v.push_back(1); v.push_back(2); for(std::vector&lt;int&gt;::const_iterator it=v.begin(); it!=v.end(); ++it) { if (*it &lt; 5) v.push_back(5-*it); } }</code> <br>    ,    : <br> Segmentation fault (core dumped) <br> <br>    Rust: <br> <code class="rust">fn main() { let mut v: Vec&lt;int&gt; = Vec::new(); v.push(1); v.push(2); for x in v.iter() { if *x &lt; 5 { v.push(5-*x); } } }</code> <br>      ,  ,        : <br> demo:7:13: 7:14 error: cannot borrow `v` as mutable because it is also borrowed as immutable <br> demo:7 v.push(5-*x); <br> ^ <br> demo:5:14: 5:15 note: previous borrow of `v` occurs here; the immutable borrow prevents subsequent moves or mutable borrows of `v` until the borrow ends <br> demo:5 for x in v.iter() { <br> ^ <br> demo:10:2: 10:2 note: previous borrow ends here <br> demo:5 for x in v.iter() { <br> demo:6 if *x &lt; 5 { <br> demo:7 v.push(5-*x); <br> demo:8 } <br> demo:9 } <br> demo:10 } <br> <br> <br>  Switch <br> <code class="cpp">#include &lt;stdio.h&gt; enum {RED, BLUE, GRAY, UNKNOWN} color = GRAY; int main() { int x; switch(color) { case GRAY: x=1; case RED: case BLUE: x=2; } printf("%d", x); }</code> <br>   "2".  Rust          .  ,       ,    <code>break</code> .    Rust   : <br> <code class="rust">enum Color {RED, BLUE, GRAY, UNKNOWN} fn main() { let color = GRAY; let x = match color { GRAY =&gt; 1, RED | BLUE =&gt; 2, _ =&gt; 3, }; println!("{}", x); }</code> <br> <br>     <br> <code class="cpp">int main() { int pixels = 1; for (int j=0; j&lt;5; j++); pixels++; }</code> <br>  Rust          . , ,     . <br> <br>  <br> <code class="cpp">#include &lt;stdio.h&gt; #include &lt;pthread.h&gt; #include &lt;unistd.h&gt; class Resource { int *value; public: Resource(): value(NULL) {} ~Resource() {delete value;} int *acquire() { if (!value) { value = new int(0); } return value; } }; void* function(void *param) { int *value = ((Resource*)param)-&gt;acquire(); printf("resource: %p\n", (void*)value); return value; } int main() { Resource res; for (int i=0; i&lt;5; ++i) { pthread_t pt; pthread_create(&amp;pt, NULL, function, &amp;res); } //sleep(10); printf("done\n"); }</code> <br>     : <br> done <br> resource: 0x7f229c0008c0 <br> resource: 0x7f22840008c0 <br> resource: 0x7f228c0008c0 <br> resource: 0x7f22940008c0 <br> resource: 0x7f227c0008c0 <br> <br>     ,        .      Rust: <br> <code class="rust">struct Resource { value: Option&lt;int&gt;, } impl Resource { pub fn new() -&gt; Resource { Resource{ value: None } } pub fn acquire&lt;'a&gt;(&amp;'a mut self) -&gt; &amp;'a int { if self.value.is_none() { self.value = Some(1); } self.value.get_ref() } } fn main() { let mut res = Resource::new(); for _ in range(0,5) { spawn(proc() { let ptr = res.acquire(); println!("resource {}", ptr) }) } }</code> <br>  ,            . <br> demo:20:23: 20:26 error: cannot borrow immutable captured outer variable in a proc `res` as mutable <br> demo:20 let ptr = res.acquire(); <br> <br>      ,   : <br> <code class="rust">extern crate sync; use sync::{Arc, RWLock}; struct Resource { value: Option&lt;Box&lt;int&gt;&gt;, } impl Resource { pub fn new() -&gt; Resource { Resource{ value: None } } pub fn acquire(&amp;mut self) -&gt; *int { if self.value.is_none() { self.value = Some(box 1) } &amp;**self.value.get_ref() as *int } } fn main() { let arc_res = Arc::new(RWLock::new(Resource::new())); for _ in range(0,5) { let child_res = arc_res.clone(); spawn(proc() { let ptr = child_res.write().acquire(); println!("resource: {}", ptr) }) } }</code> <br>     <code>Arc</code> ( <i>Atomically Reference Counted</i> -        )  <code>RWLock</code> (   ).   : <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> <br>  ,   ++    .    . Rust        ,    .  ,   ,   .           ,       ( <a href="http://superwebdeveloper.com/2009/11/25/the-incredible-rate-of-diminishing-returns-of-fixing-software-bugs/">  </a> ). <br> <br>     <br> Rust        ,     <code>unsafe{}</code> .   ,     " <i> !  ,  .</i> ".  ,  ""  (    ,    )    .    ,           ( )  . , ,        <code>Cell</code>  <code>Mutex</code> .             ,       (   <a href="http://en.wikipedia.org/wiki/Test-driven_development">TDD</a> !). <br> <br>  <br> <a href="https://air.mozilla.org/guaranteeing-memory-safety-in-rust/">Guaranteeing Memory Safety in Rust (by Niko Matsakis)</a> <br> <a href="http://www.techtalkshub.com/rust-safe-systems-programming-fun-fp/">Rust: Safe Systems Programming with the Fun of FP (by Felix Klock II)</a> <br> <a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Keynote">Lang-NEXT: What ‚Äì if anything ‚Äì have we learned from C++? (by Bjarne Stroustrup)</a> <br> <a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Panel-Systems-Programming-Languages-in-2014-and-Beyond">Lang-NEXT Panel: Systems Programming in 2014 and Beyond</a></code></code> </blockquote> <code><code><code><code class="cpp">Box)     ,       (     ).        (std::rc::Rc)    (std::gc::Gc),      (   ). <br> <br></code>      <br>  ++: <br> #include &lt;stdio.h&gt; int *bar(int *p) { return p; } int* foo(int n) { return bar(&amp;n); } int main() { int *p1 = foo(1); int *p2 = foo(2); printf("%d, %d\n", *p1, *p2); }</code> <br>  : <br> 2, 2 <br> <br>  Rust: <br> <code class="rust">fn bar&lt;'a&gt;(p: &amp;'a int) -&gt; &amp;'a int { return p; } fn foo(n: int) -&gt; &amp;int { bar(&amp;n) } fn main() { let p1 = foo(1); let p2 = foo(2); println!("{}, {}", *p1, *p2); }</code> <br>  : <br> demo:5:10: 5:11 error: `n` does not live long enough <br> demo:5 bar(&amp;n) <br> ^ <br> demo:4:24: 6:2 note: reference must be valid for the anonymous lifetime #1 defined on the block at 4:23... <br> demo:4 fn foo(n: int) -&gt; &amp;int { <br> demo:5 bar(&amp;n) <br> demo:6 } <br> demo:4:24: 6:2 note: ...but borrowed value is only valid for the block at 4:23 <br> demo:4 fn foo(n: int) -&gt; &amp;int { <br> demo:5 bar(&amp;n) <br> demo:6 } <br> <br>   <br> <code class="cpp">#include &lt;stdio.h&gt; int minval(int *A, int n) { int currmin; for (int i=0; i&lt;n; i++) if (A[i] &lt; currmin) currmin = A[i]; return currmin; } int main() { int A[] = {1,2,3}; int min = minval(A,3); printf("%d\n", min); }</code> <br>   0  ,     , ,  .       Rust ( - ): <br> <code class="rust">fn minval(A: &amp;[int]) -&gt; int { let mut currmin; for a in A.iter() { if *a &lt; currmin { currmin = *a; } } currmin } fn main() { let A = [1i,2i,3i]; let min = minval(A.as_slice()); println!("{}", min); }</code> <br>  , : use of possibly uninitialized variable: `currmin` <br>   ( )      : <br> <code class="rust">fn minval(A: &amp;[int]) -&gt; int { A.iter().fold(A[0], |u,&amp;a| { if a&lt;u {a} else {u} }) }</code> <br> <br>    <br> <code class="cpp">struct A{ int *x; A(int v): x(new int(v)) {} ~A() {delete x;} }; int main() { A a(1), b=a; }</code> <br> ,    : <br> *** glibc detected *** demo: double free or corruption (fasttop): 0x0000000000601010 *** <br> <br>     Rust: <br> <code class="rust">struct A{ x: Box&lt;int&gt; } impl A { pub fn new(v: int) -&gt; A { A{ x: box v } } } impl Drop for A { fn drop(&amp;mut self) {} // ,     ++ } fn main() { let a = A::new(1); let _b = a; }</code> <br>     .   ,     <code>trait Copy</code> . <br> Rust       .    <code>Eq</code>  <code>Clone</code> ?    <code>deriving</code>   : <br> <code class="rust">#[deriving(Clone, Eq, Hash, PartialEq, PartialOrd, Ord, Show)] struct A{ x: Box&lt;int&gt; }</code> <br> <br>    <br> <code class="cpp">#include &lt;stdio.h&gt; struct X { int a, b; }; void swap_from(X&amp; x, const X&amp; y) { xa = yb; xb = ya; } int main() { X x = {1,2}; swap_from(x,x); printf("%d,%d\n", xa, xb); }</code> <br>  : <br> 2,2 <br>    ,    cc      .   ,   ,  99  <a href="http://en.wikipedia.org/wiki/Restrict">restrict</a> ,            :        . <br> <br>       Rust: <br> <code class="rust">struct X { pub a: int, pub b: int } fn swap_from(x: &amp;mut X, y: &amp;X) { xa = yb; xb = ya; } fn main() { let mut x = X{a:1, b:2}; swap_from(&amp;mut x, &amp;x); }</code> <br>    : <br> demo:7:24: 7:25 error: cannot borrow `x` as immutable because it is also borrowed as mutable <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> ^ <br> demo:7:20: 7:21 note: previous borrow of `x` occurs here; the mutable borrow prevents subsequent moves, borrows, or modification of `x` until the borrow ends <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> ^ <br> demo:7:26: 7:26 note: previous borrow ends here <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> <br>  ,             " <code>&amp;mut</code> "  " <code>&amp;</code> " ,   ,          ,   <code>&amp;mut</code> .            .  ,    ,      C99  <code>restrict</code>  (Rust  LLVM    ),    . <br> <br>   <br> <code class="cpp">#include &lt;vector&gt; int main() { std::vector&lt;int&gt; v; v.push_back(1); v.push_back(2); for(std::vector&lt;int&gt;::const_iterator it=v.begin(); it!=v.end(); ++it) { if (*it &lt; 5) v.push_back(5-*it); } }</code> <br>    ,    : <br> Segmentation fault (core dumped) <br> <br>    Rust: <br> <code class="rust">fn main() { let mut v: Vec&lt;int&gt; = Vec::new(); v.push(1); v.push(2); for x in v.iter() { if *x &lt; 5 { v.push(5-*x); } } }</code> <br>      ,  ,        : <br> demo:7:13: 7:14 error: cannot borrow `v` as mutable because it is also borrowed as immutable <br> demo:7 v.push(5-*x); <br> ^ <br> demo:5:14: 5:15 note: previous borrow of `v` occurs here; the immutable borrow prevents subsequent moves or mutable borrows of `v` until the borrow ends <br> demo:5 for x in v.iter() { <br> ^ <br> demo:10:2: 10:2 note: previous borrow ends here <br> demo:5 for x in v.iter() { <br> demo:6 if *x &lt; 5 { <br> demo:7 v.push(5-*x); <br> demo:8 } <br> demo:9 } <br> demo:10 } <br> <br> <br>  Switch <br> <code class="cpp">#include &lt;stdio.h&gt; enum {RED, BLUE, GRAY, UNKNOWN} color = GRAY; int main() { int x; switch(color) { case GRAY: x=1; case RED: case BLUE: x=2; } printf("%d", x); }</code> <br>   "2".  Rust          .  ,       ,    <code>break</code> .    Rust   : <br> <code class="rust">enum Color {RED, BLUE, GRAY, UNKNOWN} fn main() { let color = GRAY; let x = match color { GRAY =&gt; 1, RED | BLUE =&gt; 2, _ =&gt; 3, }; println!("{}", x); }</code> <br> <br>     <br> <code class="cpp">int main() { int pixels = 1; for (int j=0; j&lt;5; j++); pixels++; }</code> <br>  Rust          . , ,     . <br> <br>  <br> <code class="cpp">#include &lt;stdio.h&gt; #include &lt;pthread.h&gt; #include &lt;unistd.h&gt; class Resource { int *value; public: Resource(): value(NULL) {} ~Resource() {delete value;} int *acquire() { if (!value) { value = new int(0); } return value; } }; void* function(void *param) { int *value = ((Resource*)param)-&gt;acquire(); printf("resource: %p\n", (void*)value); return value; } int main() { Resource res; for (int i=0; i&lt;5; ++i) { pthread_t pt; pthread_create(&amp;pt, NULL, function, &amp;res); } //sleep(10); printf("done\n"); }</code> <br>     : <br> done <br> resource: 0x7f229c0008c0 <br> resource: 0x7f22840008c0 <br> resource: 0x7f228c0008c0 <br> resource: 0x7f22940008c0 <br> resource: 0x7f227c0008c0 <br> <br>     ,        .      Rust: <br> <code class="rust">struct Resource { value: Option&lt;int&gt;, } impl Resource { pub fn new() -&gt; Resource { Resource{ value: None } } pub fn acquire&lt;'a&gt;(&amp;'a mut self) -&gt; &amp;'a int { if self.value.is_none() { self.value = Some(1); } self.value.get_ref() } } fn main() { let mut res = Resource::new(); for _ in range(0,5) { spawn(proc() { let ptr = res.acquire(); println!("resource {}", ptr) }) } }</code> <br>  ,            . <br> demo:20:23: 20:26 error: cannot borrow immutable captured outer variable in a proc `res` as mutable <br> demo:20 let ptr = res.acquire(); <br> <br>      ,   : <br> <code class="rust">extern crate sync; use sync::{Arc, RWLock}; struct Resource { value: Option&lt;Box&lt;int&gt;&gt;, } impl Resource { pub fn new() -&gt; Resource { Resource{ value: None } } pub fn acquire(&amp;mut self) -&gt; *int { if self.value.is_none() { self.value = Some(box 1) } &amp;**self.value.get_ref() as *int } } fn main() { let arc_res = Arc::new(RWLock::new(Resource::new())); for _ in range(0,5) { let child_res = arc_res.clone(); spawn(proc() { let ptr = child_res.write().acquire(); println!("resource: {}", ptr) }) } }</code> <br>     <code>Arc</code> ( <i>Atomically Reference Counted</i> -        )  <code>RWLock</code> (   ).   : <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> <br>  ,   ++    .    . Rust        ,    .  ,   ,   .           ,       ( <a href="http://superwebdeveloper.com/2009/11/25/the-incredible-rate-of-diminishing-returns-of-fixing-software-bugs/">  </a> ). <br> <br>     <br> Rust        ,     <code>unsafe{}</code> .   ,     " <i> !  ,  .</i> ".  ,  ""  (    ,    )    .    ,           ( )  . , ,        <code>Cell</code>  <code>Mutex</code> .             ,       (   <a href="http://en.wikipedia.org/wiki/Test-driven_development">TDD</a> !). <br> <br>  <br> <a href="https://air.mozilla.org/guaranteeing-memory-safety-in-rust/">Guaranteeing Memory Safety in Rust (by Niko Matsakis)</a> <br> <a href="http://www.techtalkshub.com/rust-safe-systems-programming-fun-fp/">Rust: Safe Systems Programming with the Fun of FP (by Felix Klock II)</a> <br> <a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Keynote">Lang-NEXT: What ‚Äì if anything ‚Äì have we learned from C++? (by Bjarne Stroustrup)</a> <br> <a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Panel-Systems-Programming-Languages-in-2014-and-Beyond">Lang-NEXT Panel: Systems Programming in 2014 and Beyond</a></code></code> <h4> <code><code><code><code class="cpp">Box)     ,       (     ).        (std::rc::Rc)    (std::gc::Gc),      (   ). <br> <br></code>      <br>  ++: <br> #include &lt;stdio.h&gt; int *bar(int *p) { return p; } int* foo(int n) { return bar(&amp;n); } int main() { int *p1 = foo(1); int *p2 = foo(2); printf("%d, %d\n", *p1, *p2); }</code> <br>  : <br> 2, 2 <br> <br>  Rust: <br> <code class="rust">fn bar&lt;'a&gt;(p: &amp;'a int) -&gt; &amp;'a int { return p; } fn foo(n: int) -&gt; &amp;int { bar(&amp;n) } fn main() { let p1 = foo(1); let p2 = foo(2); println!("{}, {}", *p1, *p2); }</code> <br>  : <br> demo:5:10: 5:11 error: `n` does not live long enough <br> demo:5 bar(&amp;n) <br> ^ <br> demo:4:24: 6:2 note: reference must be valid for the anonymous lifetime #1 defined on the block at 4:23... <br> demo:4 fn foo(n: int) -&gt; &amp;int { <br> demo:5 bar(&amp;n) <br> demo:6 } <br> demo:4:24: 6:2 note: ...but borrowed value is only valid for the block at 4:23 <br> demo:4 fn foo(n: int) -&gt; &amp;int { <br> demo:5 bar(&amp;n) <br> demo:6 } <br> <br>   <br> <code class="cpp">#include &lt;stdio.h&gt; int minval(int *A, int n) { int currmin; for (int i=0; i&lt;n; i++) if (A[i] &lt; currmin) currmin = A[i]; return currmin; } int main() { int A[] = {1,2,3}; int min = minval(A,3); printf("%d\n", min); }</code> <br>   0  ,     , ,  .       Rust ( - ): <br> <code class="rust">fn minval(A: &amp;[int]) -&gt; int { let mut currmin; for a in A.iter() { if *a &lt; currmin { currmin = *a; } } currmin } fn main() { let A = [1i,2i,3i]; let min = minval(A.as_slice()); println!("{}", min); }</code> <br>  , : use of possibly uninitialized variable: `currmin` <br>   ( )      : <br> <code class="rust">fn minval(A: &amp;[int]) -&gt; int { A.iter().fold(A[0], |u,&amp;a| { if a&lt;u {a} else {u} }) }</code> <br> <br>    <br> <code class="cpp">struct A{ int *x; A(int v): x(new int(v)) {} ~A() {delete x;} }; int main() { A a(1), b=a; }</code> <br> ,    : <br> *** glibc detected *** demo: double free or corruption (fasttop): 0x0000000000601010 *** <br> <br>     Rust: <br> <code class="rust">struct A{ x: Box&lt;int&gt; } impl A { pub fn new(v: int) -&gt; A { A{ x: box v } } } impl Drop for A { fn drop(&amp;mut self) {} // ,     ++ } fn main() { let a = A::new(1); let _b = a; }</code> <br>     .   ,     <code>trait Copy</code> . <br> Rust       .    <code>Eq</code>  <code>Clone</code> ?    <code>deriving</code>   : <br> <code class="rust">#[deriving(Clone, Eq, Hash, PartialEq, PartialOrd, Ord, Show)] struct A{ x: Box&lt;int&gt; }</code> <br> <br>    <br> <code class="cpp">#include &lt;stdio.h&gt; struct X { int a, b; }; void swap_from(X&amp; x, const X&amp; y) { xa = yb; xb = ya; } int main() { X x = {1,2}; swap_from(x,x); printf("%d,%d\n", xa, xb); }</code> <br>  : <br> 2,2 <br>    ,    cc      .   ,   ,  99  <a href="http://en.wikipedia.org/wiki/Restrict">restrict</a> ,            :        . <br> <br>       Rust: <br> <code class="rust">struct X { pub a: int, pub b: int } fn swap_from(x: &amp;mut X, y: &amp;X) { xa = yb; xb = ya; } fn main() { let mut x = X{a:1, b:2}; swap_from(&amp;mut x, &amp;x); }</code> <br>    : <br> demo:7:24: 7:25 error: cannot borrow `x` as immutable because it is also borrowed as mutable <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> ^ <br> demo:7:20: 7:21 note: previous borrow of `x` occurs here; the mutable borrow prevents subsequent moves, borrows, or modification of `x` until the borrow ends <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> ^ <br> demo:7:26: 7:26 note: previous borrow ends here <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> <br>  ,             " <code>&amp;mut</code> "  " <code>&amp;</code> " ,   ,          ,   <code>&amp;mut</code> .            .  ,    ,      C99  <code>restrict</code>  (Rust  LLVM    ),    . <br> <br>   <br> <code class="cpp">#include &lt;vector&gt; int main() { std::vector&lt;int&gt; v; v.push_back(1); v.push_back(2); for(std::vector&lt;int&gt;::const_iterator it=v.begin(); it!=v.end(); ++it) { if (*it &lt; 5) v.push_back(5-*it); } }</code> <br>    ,    : <br> Segmentation fault (core dumped) <br> <br>    Rust: <br> <code class="rust">fn main() { let mut v: Vec&lt;int&gt; = Vec::new(); v.push(1); v.push(2); for x in v.iter() { if *x &lt; 5 { v.push(5-*x); } } }</code> <br>      ,  ,        : <br> demo:7:13: 7:14 error: cannot borrow `v` as mutable because it is also borrowed as immutable <br> demo:7 v.push(5-*x); <br> ^ <br> demo:5:14: 5:15 note: previous borrow of `v` occurs here; the immutable borrow prevents subsequent moves or mutable borrows of `v` until the borrow ends <br> demo:5 for x in v.iter() { <br> ^ <br> demo:10:2: 10:2 note: previous borrow ends here <br> demo:5 for x in v.iter() { <br> demo:6 if *x &lt; 5 { <br> demo:7 v.push(5-*x); <br> demo:8 } <br> demo:9 } <br> demo:10 } <br> <br> <br>  Switch <br> <code class="cpp">#include &lt;stdio.h&gt; enum {RED, BLUE, GRAY, UNKNOWN} color = GRAY; int main() { int x; switch(color) { case GRAY: x=1; case RED: case BLUE: x=2; } printf("%d", x); }</code> <br>   "2".  Rust          .  ,       ,    <code>break</code> .    Rust   : <br> <code class="rust">enum Color {RED, BLUE, GRAY, UNKNOWN} fn main() { let color = GRAY; let x = match color { GRAY =&gt; 1, RED | BLUE =&gt; 2, _ =&gt; 3, }; println!("{}", x); }</code> <br> <br>     <br> <code class="cpp">int main() { int pixels = 1; for (int j=0; j&lt;5; j++); pixels++; }</code> <br>  Rust          . , ,     . <br> <br>  <br> <code class="cpp">#include &lt;stdio.h&gt; #include &lt;pthread.h&gt; #include &lt;unistd.h&gt; class Resource { int *value; public: Resource(): value(NULL) {} ~Resource() {delete value;} int *acquire() { if (!value) { value = new int(0); } return value; } }; void* function(void *param) { int *value = ((Resource*)param)-&gt;acquire(); printf("resource: %p\n", (void*)value); return value; } int main() { Resource res; for (int i=0; i&lt;5; ++i) { pthread_t pt; pthread_create(&amp;pt, NULL, function, &amp;res); } //sleep(10); printf("done\n"); }</code> <br>     : <br> done <br> resource: 0x7f229c0008c0 <br> resource: 0x7f22840008c0 <br> resource: 0x7f228c0008c0 <br> resource: 0x7f22940008c0 <br> resource: 0x7f227c0008c0 <br> <br>     ,        .      Rust: <br> <code class="rust">struct Resource { value: Option&lt;int&gt;, } impl Resource { pub fn new() -&gt; Resource { Resource{ value: None } } pub fn acquire&lt;'a&gt;(&amp;'a mut self) -&gt; &amp;'a int { if self.value.is_none() { self.value = Some(1); } self.value.get_ref() } } fn main() { let mut res = Resource::new(); for _ in range(0,5) { spawn(proc() { let ptr = res.acquire(); println!("resource {}", ptr) }) } }</code> <br>  ,            . <br> demo:20:23: 20:26 error: cannot borrow immutable captured outer variable in a proc `res` as mutable <br> demo:20 let ptr = res.acquire(); <br> <br>      ,   : <br> <code class="rust">extern crate sync; use sync::{Arc, RWLock}; struct Resource { value: Option&lt;Box&lt;int&gt;&gt;, } impl Resource { pub fn new() -&gt; Resource { Resource{ value: None } } pub fn acquire(&amp;mut self) -&gt; *int { if self.value.is_none() { self.value = Some(box 1) } &amp;**self.value.get_ref() as *int } } fn main() { let arc_res = Arc::new(RWLock::new(Resource::new())); for _ in range(0,5) { let child_res = arc_res.clone(); spawn(proc() { let ptr = child_res.write().acquire(); println!("resource: {}", ptr) }) } }</code> <br>     <code>Arc</code> ( <i>Atomically Reference Counted</i> -        )  <code>RWLock</code> (   ).   : <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> <br>  ,   ++    .    . Rust        ,    .  ,   ,   .           ,       ( <a href="http://superwebdeveloper.com/2009/11/25/the-incredible-rate-of-diminishing-returns-of-fixing-software-bugs/">  </a> ). <br> <br>     <br> Rust        ,     <code>unsafe{}</code> .   ,     " <i> !  ,  .</i> ".  ,  ""  (    ,    )    .    ,           ( )  . , ,        <code>Cell</code>  <code>Mutex</code> .             ,       (   <a href="http://en.wikipedia.org/wiki/Test-driven_development">TDD</a> !). <br> <br>  <br> <a href="https://air.mozilla.org/guaranteeing-memory-safety-in-rust/">Guaranteeing Memory Safety in Rust (by Niko Matsakis)</a> <br> <a href="http://www.techtalkshub.com/rust-safe-systems-programming-fun-fp/">Rust: Safe Systems Programming with the Fun of FP (by Felix Klock II)</a> <br> <a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Keynote">Lang-NEXT: What ‚Äì if anything ‚Äì have we learned from C++? (by Bjarne Stroustrup)</a> <br> <a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Panel-Systems-Programming-Languages-in-2014-and-Beyond">Lang-NEXT Panel: Systems Programming in 2014 and Beyond</a></code></code> </h4> <code><code><code><code class="cpp">Box)     ,       (     ).        (std::rc::Rc)    (std::gc::Gc),      (   ). <br> <br></code>      <br>  ++: <br> #include &lt;stdio.h&gt; int *bar(int *p) { return p; } int* foo(int n) { return bar(&amp;n); } int main() { int *p1 = foo(1); int *p2 = foo(2); printf("%d, %d\n", *p1, *p2); }</code> <br>  : <br> 2, 2 <br> <br>  Rust: <br> <code class="rust">fn bar&lt;'a&gt;(p: &amp;'a int) -&gt; &amp;'a int { return p; } fn foo(n: int) -&gt; &amp;int { bar(&amp;n) } fn main() { let p1 = foo(1); let p2 = foo(2); println!("{}, {}", *p1, *p2); }</code> <br>  : <br> demo:5:10: 5:11 error: `n` does not live long enough <br> demo:5 bar(&amp;n) <br> ^ <br> demo:4:24: 6:2 note: reference must be valid for the anonymous lifetime #1 defined on the block at 4:23... <br> demo:4 fn foo(n: int) -&gt; &amp;int { <br> demo:5 bar(&amp;n) <br> demo:6 } <br> demo:4:24: 6:2 note: ...but borrowed value is only valid for the block at 4:23 <br> demo:4 fn foo(n: int) -&gt; &amp;int { <br> demo:5 bar(&amp;n) <br> demo:6 } <br> <br>   <br> <code class="cpp">#include &lt;stdio.h&gt; int minval(int *A, int n) { int currmin; for (int i=0; i&lt;n; i++) if (A[i] &lt; currmin) currmin = A[i]; return currmin; } int main() { int A[] = {1,2,3}; int min = minval(A,3); printf("%d\n", min); }</code> <br>   0  ,     , ,  .       Rust ( - ): <br> <code class="rust">fn minval(A: &amp;[int]) -&gt; int { let mut currmin; for a in A.iter() { if *a &lt; currmin { currmin = *a; } } currmin } fn main() { let A = [1i,2i,3i]; let min = minval(A.as_slice()); println!("{}", min); }</code> <br>  , : use of possibly uninitialized variable: `currmin` <br>   ( )      : <br> <code class="rust">fn minval(A: &amp;[int]) -&gt; int { A.iter().fold(A[0], |u,&amp;a| { if a&lt;u {a} else {u} }) }</code> <br> <br>    <br> <code class="cpp">struct A{ int *x; A(int v): x(new int(v)) {} ~A() {delete x;} }; int main() { A a(1), b=a; }</code> <br> ,    : <br> *** glibc detected *** demo: double free or corruption (fasttop): 0x0000000000601010 *** <br> <br>     Rust: <br> <code class="rust">struct A{ x: Box&lt;int&gt; } impl A { pub fn new(v: int) -&gt; A { A{ x: box v } } } impl Drop for A { fn drop(&amp;mut self) {} // ,     ++ } fn main() { let a = A::new(1); let _b = a; }</code> <br>     .   ,     <code>trait Copy</code> . <br> Rust       .    <code>Eq</code>  <code>Clone</code> ?    <code>deriving</code>   : <br> <code class="rust">#[deriving(Clone, Eq, Hash, PartialEq, PartialOrd, Ord, Show)] struct A{ x: Box&lt;int&gt; }</code> <br> <br>    <br> <code class="cpp">#include &lt;stdio.h&gt; struct X { int a, b; }; void swap_from(X&amp; x, const X&amp; y) { xa = yb; xb = ya; } int main() { X x = {1,2}; swap_from(x,x); printf("%d,%d\n", xa, xb); }</code> <br>  : <br> 2,2 <br>    ,    cc      .   ,   ,  99  <a href="http://en.wikipedia.org/wiki/Restrict">restrict</a> ,            :        . <br> <br>       Rust: <br> <code class="rust">struct X { pub a: int, pub b: int } fn swap_from(x: &amp;mut X, y: &amp;X) { xa = yb; xb = ya; } fn main() { let mut x = X{a:1, b:2}; swap_from(&amp;mut x, &amp;x); }</code> <br>    : <br> demo:7:24: 7:25 error: cannot borrow `x` as immutable because it is also borrowed as mutable <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> ^ <br> demo:7:20: 7:21 note: previous borrow of `x` occurs here; the mutable borrow prevents subsequent moves, borrows, or modification of `x` until the borrow ends <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> ^ <br> demo:7:26: 7:26 note: previous borrow ends here <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> <br>  ,             " <code>&amp;mut</code> "  " <code>&amp;</code> " ,   ,          ,   <code>&amp;mut</code> .            .  ,    ,      C99  <code>restrict</code>  (Rust  LLVM    ),    . <br> <br>   <br> <code class="cpp">#include &lt;vector&gt; int main() { std::vector&lt;int&gt; v; v.push_back(1); v.push_back(2); for(std::vector&lt;int&gt;::const_iterator it=v.begin(); it!=v.end(); ++it) { if (*it &lt; 5) v.push_back(5-*it); } }</code> <br>    ,    : <br> Segmentation fault (core dumped) <br> <br>    Rust: <br> <code class="rust">fn main() { let mut v: Vec&lt;int&gt; = Vec::new(); v.push(1); v.push(2); for x in v.iter() { if *x &lt; 5 { v.push(5-*x); } } }</code> <br>      ,  ,        : <br> demo:7:13: 7:14 error: cannot borrow `v` as mutable because it is also borrowed as immutable <br> demo:7 v.push(5-*x); <br> ^ <br> demo:5:14: 5:15 note: previous borrow of `v` occurs here; the immutable borrow prevents subsequent moves or mutable borrows of `v` until the borrow ends <br> demo:5 for x in v.iter() { <br> ^ <br> demo:10:2: 10:2 note: previous borrow ends here <br> demo:5 for x in v.iter() { <br> demo:6 if *x &lt; 5 { <br> demo:7 v.push(5-*x); <br> demo:8 } <br> demo:9 } <br> demo:10 } <br> <br> <br>  Switch <br> <code class="cpp">#include &lt;stdio.h&gt; enum {RED, BLUE, GRAY, UNKNOWN} color = GRAY; int main() { int x; switch(color) { case GRAY: x=1; case RED: case BLUE: x=2; } printf("%d", x); }</code> <br>   "2".  Rust          .  ,       ,    <code>break</code> .    Rust   : <br> <code class="rust">enum Color {RED, BLUE, GRAY, UNKNOWN} fn main() { let color = GRAY; let x = match color { GRAY =&gt; 1, RED | BLUE =&gt; 2, _ =&gt; 3, }; println!("{}", x); }</code> <br> <br>     <br> <code class="cpp">int main() { int pixels = 1; for (int j=0; j&lt;5; j++); pixels++; }</code> <br>  Rust          . , ,     . <br> <br>  <br> <code class="cpp">#include &lt;stdio.h&gt; #include &lt;pthread.h&gt; #include &lt;unistd.h&gt; class Resource { int *value; public: Resource(): value(NULL) {} ~Resource() {delete value;} int *acquire() { if (!value) { value = new int(0); } return value; } }; void* function(void *param) { int *value = ((Resource*)param)-&gt;acquire(); printf("resource: %p\n", (void*)value); return value; } int main() { Resource res; for (int i=0; i&lt;5; ++i) { pthread_t pt; pthread_create(&amp;pt, NULL, function, &amp;res); } //sleep(10); printf("done\n"); }</code> <br>     : <br> done <br> resource: 0x7f229c0008c0 <br> resource: 0x7f22840008c0 <br> resource: 0x7f228c0008c0 <br> resource: 0x7f22940008c0 <br> resource: 0x7f227c0008c0 <br> <br>     ,        .      Rust: <br> <code class="rust">struct Resource { value: Option&lt;int&gt;, } impl Resource { pub fn new() -&gt; Resource { Resource{ value: None } } pub fn acquire&lt;'a&gt;(&amp;'a mut self) -&gt; &amp;'a int { if self.value.is_none() { self.value = Some(1); } self.value.get_ref() } } fn main() { let mut res = Resource::new(); for _ in range(0,5) { spawn(proc() { let ptr = res.acquire(); println!("resource {}", ptr) }) } }</code> <br>  ,            . <br> demo:20:23: 20:26 error: cannot borrow immutable captured outer variable in a proc `res` as mutable <br> demo:20 let ptr = res.acquire(); <br> <br>      ,   : <br> <code class="rust">extern crate sync; use sync::{Arc, RWLock}; struct Resource { value: Option&lt;Box&lt;int&gt;&gt;, } impl Resource { pub fn new() -&gt; Resource { Resource{ value: None } } pub fn acquire(&amp;mut self) -&gt; *int { if self.value.is_none() { self.value = Some(box 1) } &amp;**self.value.get_ref() as *int } } fn main() { let arc_res = Arc::new(RWLock::new(Resource::new())); for _ in range(0,5) { let child_res = arc_res.clone(); spawn(proc() { let ptr = child_res.write().acquire(); println!("resource: {}", ptr) }) } }</code> <br>     <code>Arc</code> ( <i>Atomically Reference Counted</i> -        )  <code>RWLock</code> (   ).   : <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> <br>  ,   ++    .    . Rust        ,    .  ,   ,   .           ,       ( <a href="http://superwebdeveloper.com/2009/11/25/the-incredible-rate-of-diminishing-returns-of-fixing-software-bugs/">  </a> ). <br> <br>     <br> Rust        ,     <code>unsafe{}</code> .   ,     " <i> !  ,  .</i> ".  ,  ""  (    ,    )    .    ,           ( )  . , ,        <code>Cell</code>  <code>Mutex</code> .             ,       (   <a href="http://en.wikipedia.org/wiki/Test-driven_development">TDD</a> !). <br> <br>  <br> <a href="https://air.mozilla.org/guaranteeing-memory-safety-in-rust/">Guaranteeing Memory Safety in Rust (by Niko Matsakis)</a> <br> <a href="http://www.techtalkshub.com/rust-safe-systems-programming-fun-fp/">Rust: Safe Systems Programming with the Fun of FP (by Felix Klock II)</a> <br> <a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Keynote">Lang-NEXT: What ‚Äì if anything ‚Äì have we learned from C++? (by Bjarne Stroustrup)</a> <br> <a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Panel-Systems-Programming-Languages-in-2014-and-Beyond">Lang-NEXT Panel: Systems Programming in 2014 and Beyond</a></code></code> <pre> <code class="hljs rust"><code><code><code class="cpp"><span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>)     ,       (     ).        (std::rc::Rc)    (std::gc::Gc),      (   ). <br> <br></code>      <br>  ++: <br> #include &lt;stdio.h&gt; int *bar(int *p) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p; } int* foo(int n) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bar(&amp;n); } int main() { int *p1 = foo(<span class="hljs-number"><span class="hljs-number">1</span></span>); int *p2 = foo(<span class="hljs-number"><span class="hljs-number">2</span></span>); printf(<span class="hljs-string"><span class="hljs-string">"%d, %d\n"</span></span>, *p1, *p2); }</code> <br>  : <br> <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span> <br> <br>  Rust: <br> <code class="rust"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt;(p: &amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> int) -&gt; &amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> int { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>(n: int) -&gt; &amp;int { bar(&amp;n) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> p1 = foo(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> p2 = foo(<span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{}, {}"</span></span>, *p1, *p2); }</code> <br>  : <br> demo:<span class="hljs-number"><span class="hljs-number">5</span></span>:<span class="hljs-number"><span class="hljs-number">10</span></span>: <span class="hljs-number"><span class="hljs-number">5</span></span>:<span class="hljs-number"><span class="hljs-number">11</span></span> error: `n` does not live long enough <br> demo:<span class="hljs-number"><span class="hljs-number">5</span></span> bar(&amp;n) <br> ^ <br> demo:<span class="hljs-number"><span class="hljs-number">4</span></span>:<span class="hljs-number"><span class="hljs-number">24</span></span>: <span class="hljs-number"><span class="hljs-number">6</span></span>:<span class="hljs-number"><span class="hljs-number">2</span></span> note: reference must <span class="hljs-keyword"><span class="hljs-keyword">be</span></span> valid <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> the anonymous lifetime #<span class="hljs-number"><span class="hljs-number">1</span></span> defined on the block at <span class="hljs-number"><span class="hljs-number">4</span></span>:<span class="hljs-number"><span class="hljs-number">23</span></span>... <br> demo:<span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>(n: int) -&gt; &amp;int { <br> demo:<span class="hljs-number"><span class="hljs-number">5</span></span> bar(&amp;n) <br> demo:<span class="hljs-number"><span class="hljs-number">6</span></span> } <br> demo:<span class="hljs-number"><span class="hljs-number">4</span></span>:<span class="hljs-number"><span class="hljs-number">24</span></span>: <span class="hljs-number"><span class="hljs-number">6</span></span>:<span class="hljs-number"><span class="hljs-number">2</span></span> note: ...but borrowed value is only valid <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> the block at <span class="hljs-number"><span class="hljs-number">4</span></span>:<span class="hljs-number"><span class="hljs-number">23</span></span> <br> demo:<span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>(n: int) -&gt; &amp;int { <br> demo:<span class="hljs-number"><span class="hljs-number">5</span></span> bar(&amp;n) <br> demo:<span class="hljs-number"><span class="hljs-number">6</span></span> } <br> <br>   <br> <code class="cpp">#include &lt;stdio.h&gt; int minval(int *A, int n) { int currmin; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;n; i++) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (A[i] &lt; currmin) currmin = A[i]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> currmin; } int main() { int A[] = {<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>}; int min = minval(A,<span class="hljs-number"><span class="hljs-number">3</span></span>); printf(<span class="hljs-string"><span class="hljs-string">"%d\n"</span></span>, min); }</code> <br>   <span class="hljs-number"><span class="hljs-number">0</span></span>  ,     , ,  .       Rust ( - ): <br> <code class="rust"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">minval</span></span></span></span>(A: &amp;[int]) -&gt; int { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> currmin; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> a <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> A.iter() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> *a &lt; currmin { currmin = *a; } } currmin } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> A = [<span class="hljs-number"><span class="hljs-number">1</span></span>i,<span class="hljs-number"><span class="hljs-number">2</span></span>i,<span class="hljs-number"><span class="hljs-number">3</span></span>i]; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> min = minval(A.as_slice()); <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{}"</span></span>, min); }</code> <br>  , : <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> of possibly uninitialized variable: `currmin` <br>   ( )      : <br> <code class="rust"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">minval</span></span></span></span>(A: &amp;[int]) -&gt; int { A.iter().fold(A[<span class="hljs-number"><span class="hljs-number">0</span></span>], |u,&amp;a| { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> a&lt;u {a} <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {u} }) }</code> <br> <br>    <br> <code class="cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span></span>{ int *x; A(int v): x(new int(v)) {} ~A() {delete x;} }; int main() { A a(<span class="hljs-number"><span class="hljs-number">1</span></span>), b=a; }</code> <br> ,    : <br> *** glibc detected *** demo: double free or corruption (fasttop): <span class="hljs-number"><span class="hljs-number">0x0000000000601010</span></span> *** <br> <br>     Rust: <br> <code class="rust"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span></span>{ x: <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;int&gt; } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> A { <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">new</span></span></span></span>(v: int) -&gt; A { A{ x: <span class="hljs-keyword"><span class="hljs-keyword">box</span></span> v } } } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Drop</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> A { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drop</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) {} <span class="hljs-comment"><span class="hljs-comment">// ,     ++ } fn main() { let a = A::new(1); let _b = a; }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">     .   ,     </span></span><code><span class="hljs-comment"><span class="hljs-comment">trait Copy</span></span></code><span class="hljs-comment"><span class="hljs-comment"> . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> Rust       .    </span></span><code><span class="hljs-comment"><span class="hljs-comment">Eq</span></span></code><span class="hljs-comment"><span class="hljs-comment">  </span></span><code><span class="hljs-comment"><span class="hljs-comment">Clone</span></span></code><span class="hljs-comment"><span class="hljs-comment"> ?    </span></span><code><span class="hljs-comment"><span class="hljs-comment">deriving</span></span></code><span class="hljs-comment"><span class="hljs-comment">   : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="rust"><span class="hljs-comment"><span class="hljs-comment">#[deriving(Clone, Eq, Hash, PartialEq, PartialOrd, Ord, Show)] struct A{ x: Box&lt;int&gt; }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">    </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="cpp"><span class="hljs-comment"><span class="hljs-comment">#include &lt;stdio.h&gt; struct X { int a, b; }; void swap_from(X&amp; x, const X&amp; y) { xa = yb; xb = ya; } int main() { X x = {1,2}; swap_from(x,x); printf("%d,%d\n", xa, xb); }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> 2,2 </span></span><br><span class="hljs-comment"><span class="hljs-comment">    ,    cc      .   ,   ,  99  </span></span><a href="http://en.wikipedia.org/wiki/Restrict"><span class="hljs-comment"><span class="hljs-comment">restrict</span></span></a><span class="hljs-comment"><span class="hljs-comment"> ,            :        . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">       Rust: </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="rust"><span class="hljs-comment"><span class="hljs-comment">struct X { pub a: int, pub b: int } fn swap_from(x: &amp;mut X, y: &amp;X) { xa = yb; xb = ya; } fn main() { let mut x = X{a:1, b:2}; swap_from(&amp;mut x, &amp;x); }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">    : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7:24: 7:25 error: cannot borrow `x` as immutable because it is also borrowed as mutable </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7 swap_from(&amp;mut x, &amp;x); </span></span><br><span class="hljs-comment"><span class="hljs-comment"> ^ </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7:20: 7:21 note: previous borrow of `x` occurs here; the mutable borrow prevents subsequent moves, borrows, or modification of `x` until the borrow ends </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7 swap_from(&amp;mut x, &amp;x); </span></span><br><span class="hljs-comment"><span class="hljs-comment"> ^ </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7:26: 7:26 note: previous borrow ends here </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7 swap_from(&amp;mut x, &amp;x); </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  ,             " </span></span><code><span class="hljs-comment"><span class="hljs-comment">&amp;mut</span></span></code><span class="hljs-comment"><span class="hljs-comment"> "  " </span></span><code><span class="hljs-comment"><span class="hljs-comment">&amp;</span></span></code><span class="hljs-comment"><span class="hljs-comment"> " ,   ,          ,   </span></span><code><span class="hljs-comment"><span class="hljs-comment">&amp;mut</span></span></code><span class="hljs-comment"><span class="hljs-comment"> .            .  ,    ,      C99  </span></span><code><span class="hljs-comment"><span class="hljs-comment">restrict</span></span></code><span class="hljs-comment"><span class="hljs-comment">  (Rust  LLVM    ),    . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">   </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="cpp"><span class="hljs-comment"><span class="hljs-comment">#include &lt;vector&gt; int main() { std::vector&lt;int&gt; v; v.push_back(1); v.push_back(2); for(std::vector&lt;int&gt;::const_iterator it=v.begin(); it!=v.end(); ++it) { if (*it &lt; 5) v.push_back(5-*it); } }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">    ,    : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> Segmentation fault (core dumped) </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">    Rust: </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="rust"><span class="hljs-comment"><span class="hljs-comment">fn main() { let mut v: Vec&lt;int&gt; = Vec::new(); v.push(1); v.push(2); for x in v.iter() { if *x &lt; 5 { v.push(5-*x); } } }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">      ,  ,        : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7:13: 7:14 error: cannot borrow `v` as mutable because it is also borrowed as immutable </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7 v.push(5-*x); </span></span><br><span class="hljs-comment"><span class="hljs-comment"> ^ </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:5:14: 5:15 note: previous borrow of `v` occurs here; the immutable borrow prevents subsequent moves or mutable borrows of `v` until the borrow ends </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:5 for x in v.iter() { </span></span><br><span class="hljs-comment"><span class="hljs-comment"> ^ </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:10:2: 10:2 note: previous borrow ends here </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:5 for x in v.iter() { </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:6 if *x &lt; 5 { </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7 v.push(5-*x); </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:8 } </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:9 } </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:10 } </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  Switch </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="cpp"><span class="hljs-comment"><span class="hljs-comment">#include &lt;stdio.h&gt; enum {RED, BLUE, GRAY, UNKNOWN} color = GRAY; int main() { int x; switch(color) { case GRAY: x=1; case RED: case BLUE: x=2; } printf("%d", x); }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">   "2".  Rust          .  ,       ,    </span></span><code><span class="hljs-comment"><span class="hljs-comment">break</span></span></code><span class="hljs-comment"><span class="hljs-comment"> .    Rust   : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="rust"><span class="hljs-comment"><span class="hljs-comment">enum Color {RED, BLUE, GRAY, UNKNOWN} fn main() { let color = GRAY; let x = match color { GRAY =&gt; 1, RED | BLUE =&gt; 2, _ =&gt; 3, }; println!("{}", x); }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">     </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="cpp"><span class="hljs-comment"><span class="hljs-comment">int main() { int pixels = 1; for (int j=0; j&lt;5; j++); pixels++; }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  Rust          . , ,     . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="cpp"><span class="hljs-comment"><span class="hljs-comment">#include &lt;stdio.h&gt; #include &lt;pthread.h&gt; #include &lt;unistd.h&gt; class Resource { int *value; public: Resource(): value(NULL) {} ~Resource() {delete value;} int *acquire() { if (!value) { value = new int(0); } return value; } }; void* function(void *param) { int *value = ((Resource*)param)-&gt;acquire(); printf("resource: %p\n", (void*)value); return value; } int main() { Resource res; for (int i=0; i&lt;5; ++i) { pthread_t pt; pthread_create(&amp;pt, NULL, function, &amp;res); } //sleep(10); printf("done\n"); }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">     : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> done </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7f229c0008c0 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7f22840008c0 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7f228c0008c0 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7f22940008c0 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7f227c0008c0 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">     ,        .      Rust: </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="rust"><span class="hljs-comment"><span class="hljs-comment">struct Resource { value: Option&lt;int&gt;, } impl Resource { pub fn new() -&gt; Resource { Resource{ value: None } } pub fn acquire&lt;'a&gt;(&amp;'a mut self) -&gt; &amp;'a int { if self.value.is_none() { self.value = Some(1); } self.value.get_ref() } } fn main() { let mut res = Resource::new(); for _ in range(0,5) { spawn(proc() { let ptr = res.acquire(); println!("resource {}", ptr) }) } }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  ,            . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:20:23: 20:26 error: cannot borrow immutable captured outer variable in a proc `res` as mutable </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:20 let ptr = res.acquire(); </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">      ,   : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="rust"><span class="hljs-comment"><span class="hljs-comment">extern crate sync; use sync::{Arc, RWLock}; struct Resource { value: Option&lt;Box&lt;int&gt;&gt;, } impl Resource { pub fn new() -&gt; Resource { Resource{ value: None } } pub fn acquire(&amp;mut self) -&gt; *int { if self.value.is_none() { self.value = Some(box 1) } &amp;**self.value.get_ref() as *int } } fn main() { let arc_res = Arc::new(RWLock::new(Resource::new())); for _ in range(0,5) { let child_res = arc_res.clone(); spawn(proc() { let ptr = child_res.write().acquire(); println!("resource: {}", ptr) }) } }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">     </span></span><code><span class="hljs-comment"><span class="hljs-comment">Arc</span></span></code><span class="hljs-comment"><span class="hljs-comment"> ( </span></span><i><span class="hljs-comment"><span class="hljs-comment">Atomically Reference Counted</span></span></i><span class="hljs-comment"><span class="hljs-comment"> -        )  </span></span><code><span class="hljs-comment"><span class="hljs-comment">RWLock</span></span></code><span class="hljs-comment"><span class="hljs-comment"> (   ).   : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7ff4b0010378 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7ff4b0010378 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7ff4b0010378 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7ff4b0010378 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7ff4b0010378 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  ,   ++    .    . Rust        ,    .  ,   ,   .           ,       ( </span></span><a href="http://superwebdeveloper.com/2009/11/25/the-incredible-rate-of-diminishing-returns-of-fixing-software-bugs/"><span class="hljs-comment"><span class="hljs-comment">  </span></span></a><span class="hljs-comment"><span class="hljs-comment"> ). </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">     </span></span><br><span class="hljs-comment"><span class="hljs-comment"> Rust        ,     </span></span><code><span class="hljs-comment"><span class="hljs-comment">unsafe{}</span></span></code><span class="hljs-comment"><span class="hljs-comment"> .   ,     " </span></span><i><span class="hljs-comment"><span class="hljs-comment"> !  ,  .</span></span></i><span class="hljs-comment"><span class="hljs-comment"> ".  ,  ""  (    ,    )    .    ,           ( )  . , ,        </span></span><code><span class="hljs-comment"><span class="hljs-comment">Cell</span></span></code><span class="hljs-comment"><span class="hljs-comment">  </span></span><code><span class="hljs-comment"><span class="hljs-comment">Mutex</span></span></code><span class="hljs-comment"><span class="hljs-comment"> .             ,       (   </span></span><a href="http://en.wikipedia.org/wiki/Test-driven_development"><span class="hljs-comment"><span class="hljs-comment">TDD</span></span></a><span class="hljs-comment"><span class="hljs-comment"> !). </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="https://air.mozilla.org/guaranteeing-memory-safety-in-rust/"><span class="hljs-comment"><span class="hljs-comment">Guaranteeing Memory Safety in Rust (by Niko Matsakis)</span></span></a><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="http://www.techtalkshub.com/rust-safe-systems-programming-fun-fp/"><span class="hljs-comment"><span class="hljs-comment">Rust: Safe Systems Programming with the Fun of FP (by Felix Klock II)</span></span></a><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Keynote"><span class="hljs-comment"><span class="hljs-comment">Lang-NEXT: What ‚Äì if anything ‚Äì have we learned from C++? (by Bjarne Stroustrup)</span></span></a><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Panel-Systems-Programming-Languages-in-2014-and-Beyond"><span class="hljs-comment"><span class="hljs-comment">Lang-NEXT Panel: Systems Programming in 2014 and Beyond</span></span></a></code></code> </pre> <code><code><code><code class="cpp">Box)     ,       (     ).        (std::rc::Rc)    (std::gc::Gc),      (   ). <br> <br></code>      <br>  ++: <br> #include &lt;stdio.h&gt; int *bar(int *p) { return p; } int* foo(int n) { return bar(&amp;n); } int main() { int *p1 = foo(1); int *p2 = foo(2); printf("%d, %d\n", *p1, *p2); }</code> <br>  : <br> 2, 2 <br> <br>  Rust: <br> <code class="rust">fn bar&lt;'a&gt;(p: &amp;'a int) -&gt; &amp;'a int { return p; } fn foo(n: int) -&gt; &amp;int { bar(&amp;n) } fn main() { let p1 = foo(1); let p2 = foo(2); println!("{}, {}", *p1, *p2); }</code> <br>  : <br> demo:5:10: 5:11 error: `n` does not live long enough <br> demo:5 bar(&amp;n) <br> ^ <br> demo:4:24: 6:2 note: reference must be valid for the anonymous lifetime #1 defined on the block at 4:23... <br> demo:4 fn foo(n: int) -&gt; &amp;int { <br> demo:5 bar(&amp;n) <br> demo:6 } <br> demo:4:24: 6:2 note: ...but borrowed value is only valid for the block at 4:23 <br> demo:4 fn foo(n: int) -&gt; &amp;int { <br> demo:5 bar(&amp;n) <br> demo:6 } <br> <br>   <br> <code class="cpp">#include &lt;stdio.h&gt; int minval(int *A, int n) { int currmin; for (int i=0; i&lt;n; i++) if (A[i] &lt; currmin) currmin = A[i]; return currmin; } int main() { int A[] = {1,2,3}; int min = minval(A,3); printf("%d\n", min); }</code> <br>   0  ,     , ,  .       Rust ( - ): <br> <code class="rust">fn minval(A: &amp;[int]) -&gt; int { let mut currmin; for a in A.iter() { if *a &lt; currmin { currmin = *a; } } currmin } fn main() { let A = [1i,2i,3i]; let min = minval(A.as_slice()); println!("{}", min); }</code> <br>  , : use of possibly uninitialized variable: `currmin` <br>   ( )      : <br> <code class="rust">fn minval(A: &amp;[int]) -&gt; int { A.iter().fold(A[0], |u,&amp;a| { if a&lt;u {a} else {u} }) }</code> <br> <br>    <br> <code class="cpp">struct A{ int *x; A(int v): x(new int(v)) {} ~A() {delete x;} }; int main() { A a(1), b=a; }</code> <br> ,    : <br> *** glibc detected *** demo: double free or corruption (fasttop): 0x0000000000601010 *** <br> <br>     Rust: <br> <code class="rust">struct A{ x: Box&lt;int&gt; } impl A { pub fn new(v: int) -&gt; A { A{ x: box v } } } impl Drop for A { fn drop(&amp;mut self) {} // ,     ++ } fn main() { let a = A::new(1); let _b = a; }</code> <br>     .   ,     <code>trait Copy</code> . <br> Rust       .    <code>Eq</code>  <code>Clone</code> ?    <code>deriving</code>   : <br> <code class="rust">#[deriving(Clone, Eq, Hash, PartialEq, PartialOrd, Ord, Show)] struct A{ x: Box&lt;int&gt; }</code> <br> <br>    <br> <code class="cpp">#include &lt;stdio.h&gt; struct X { int a, b; }; void swap_from(X&amp; x, const X&amp; y) { xa = yb; xb = ya; } int main() { X x = {1,2}; swap_from(x,x); printf("%d,%d\n", xa, xb); }</code> <br>  : <br> 2,2 <br>    ,    cc      .   ,   ,  99  <a href="http://en.wikipedia.org/wiki/Restrict">restrict</a> ,            :        . <br> <br>       Rust: <br> <code class="rust">struct X { pub a: int, pub b: int } fn swap_from(x: &amp;mut X, y: &amp;X) { xa = yb; xb = ya; } fn main() { let mut x = X{a:1, b:2}; swap_from(&amp;mut x, &amp;x); }</code> <br>    : <br> demo:7:24: 7:25 error: cannot borrow `x` as immutable because it is also borrowed as mutable <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> ^ <br> demo:7:20: 7:21 note: previous borrow of `x` occurs here; the mutable borrow prevents subsequent moves, borrows, or modification of `x` until the borrow ends <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> ^ <br> demo:7:26: 7:26 note: previous borrow ends here <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> <br>  ,             " <code>&amp;mut</code> "  " <code>&amp;</code> " ,   ,          ,   <code>&amp;mut</code> .            .  ,    ,      C99  <code>restrict</code>  (Rust  LLVM    ),    . <br> <br>   <br> <code class="cpp">#include &lt;vector&gt; int main() { std::vector&lt;int&gt; v; v.push_back(1); v.push_back(2); for(std::vector&lt;int&gt;::const_iterator it=v.begin(); it!=v.end(); ++it) { if (*it &lt; 5) v.push_back(5-*it); } }</code> <br>    ,    : <br> Segmentation fault (core dumped) <br> <br>    Rust: <br> <code class="rust">fn main() { let mut v: Vec&lt;int&gt; = Vec::new(); v.push(1); v.push(2); for x in v.iter() { if *x &lt; 5 { v.push(5-*x); } } }</code> <br>      ,  ,        : <br> demo:7:13: 7:14 error: cannot borrow `v` as mutable because it is also borrowed as immutable <br> demo:7 v.push(5-*x); <br> ^ <br> demo:5:14: 5:15 note: previous borrow of `v` occurs here; the immutable borrow prevents subsequent moves or mutable borrows of `v` until the borrow ends <br> demo:5 for x in v.iter() { <br> ^ <br> demo:10:2: 10:2 note: previous borrow ends here <br> demo:5 for x in v.iter() { <br> demo:6 if *x &lt; 5 { <br> demo:7 v.push(5-*x); <br> demo:8 } <br> demo:9 } <br> demo:10 } <br> <br> <br>  Switch <br> <code class="cpp">#include &lt;stdio.h&gt; enum {RED, BLUE, GRAY, UNKNOWN} color = GRAY; int main() { int x; switch(color) { case GRAY: x=1; case RED: case BLUE: x=2; } printf("%d", x); }</code> <br>   "2".  Rust          .  ,       ,    <code>break</code> .    Rust   : <br> <code class="rust">enum Color {RED, BLUE, GRAY, UNKNOWN} fn main() { let color = GRAY; let x = match color { GRAY =&gt; 1, RED | BLUE =&gt; 2, _ =&gt; 3, }; println!("{}", x); }</code> <br> <br>     <br> <code class="cpp">int main() { int pixels = 1; for (int j=0; j&lt;5; j++); pixels++; }</code> <br>  Rust          . , ,     . <br> <br>  <br> <code class="cpp">#include &lt;stdio.h&gt; #include &lt;pthread.h&gt; #include &lt;unistd.h&gt; class Resource { int *value; public: Resource(): value(NULL) {} ~Resource() {delete value;} int *acquire() { if (!value) { value = new int(0); } return value; } }; void* function(void *param) { int *value = ((Resource*)param)-&gt;acquire(); printf("resource: %p\n", (void*)value); return value; } int main() { Resource res; for (int i=0; i&lt;5; ++i) { pthread_t pt; pthread_create(&amp;pt, NULL, function, &amp;res); } //sleep(10); printf("done\n"); }</code> <br>     : <br> done <br> resource: 0x7f229c0008c0 <br> resource: 0x7f22840008c0 <br> resource: 0x7f228c0008c0 <br> resource: 0x7f22940008c0 <br> resource: 0x7f227c0008c0 <br> <br>     ,        .      Rust: <br> <code class="rust">struct Resource { value: Option&lt;int&gt;, } impl Resource { pub fn new() -&gt; Resource { Resource{ value: None } } pub fn acquire&lt;'a&gt;(&amp;'a mut self) -&gt; &amp;'a int { if self.value.is_none() { self.value = Some(1); } self.value.get_ref() } } fn main() { let mut res = Resource::new(); for _ in range(0,5) { spawn(proc() { let ptr = res.acquire(); println!("resource {}", ptr) }) } }</code> <br>  ,            . <br> demo:20:23: 20:26 error: cannot borrow immutable captured outer variable in a proc `res` as mutable <br> demo:20 let ptr = res.acquire(); <br> <br>      ,   : <br> <code class="rust">extern crate sync; use sync::{Arc, RWLock}; struct Resource { value: Option&lt;Box&lt;int&gt;&gt;, } impl Resource { pub fn new() -&gt; Resource { Resource{ value: None } } pub fn acquire(&amp;mut self) -&gt; *int { if self.value.is_none() { self.value = Some(box 1) } &amp;**self.value.get_ref() as *int } } fn main() { let arc_res = Arc::new(RWLock::new(Resource::new())); for _ in range(0,5) { let child_res = arc_res.clone(); spawn(proc() { let ptr = child_res.write().acquire(); println!("resource: {}", ptr) }) } }</code> <br>     <code>Arc</code> ( <i>Atomically Reference Counted</i> -        )  <code>RWLock</code> (   ).   : <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> <br>  ,   ++    .    . Rust        ,    .  ,   ,   .           ,       ( <a href="http://superwebdeveloper.com/2009/11/25/the-incredible-rate-of-diminishing-returns-of-fixing-software-bugs/">  </a> ). <br> <br>     <br> Rust        ,     <code>unsafe{}</code> .   ,     " <i> !  ,  .</i> ".  ,  ""  (    ,    )    .    ,           ( )  . , ,        <code>Cell</code>  <code>Mutex</code> .             ,       (   <a href="http://en.wikipedia.org/wiki/Test-driven_development">TDD</a> !). <br> <br>  <br> <a href="https://air.mozilla.org/guaranteeing-memory-safety-in-rust/">Guaranteeing Memory Safety in Rust (by Niko Matsakis)</a> <br> <a href="http://www.techtalkshub.com/rust-safe-systems-programming-fun-fp/">Rust: Safe Systems Programming with the Fun of FP (by Felix Klock II)</a> <br> <a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Keynote">Lang-NEXT: What ‚Äì if anything ‚Äì have we learned from C++? (by Bjarne Stroustrup)</a> <br> <a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Panel-Systems-Programming-Languages-in-2014-and-Beyond">Lang-NEXT Panel: Systems Programming in 2014 and Beyond</a></code></code> <pre> <code class="hljs rust"><code><code><code class="cpp"><span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>)     ,       (     ).        (std::rc::Rc)    (std::gc::Gc),      (   ). <br> <br></code>      <br>  ++: <br> #include &lt;stdio.h&gt; int *bar(int *p) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p; } int* foo(int n) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bar(&amp;n); } int main() { int *p1 = foo(<span class="hljs-number"><span class="hljs-number">1</span></span>); int *p2 = foo(<span class="hljs-number"><span class="hljs-number">2</span></span>); printf(<span class="hljs-string"><span class="hljs-string">"%d, %d\n"</span></span>, *p1, *p2); }</code> <br>  : <br> <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span> <br> <br>  Rust: <br> <code class="rust"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt;(p: &amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> int) -&gt; &amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> int { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>(n: int) -&gt; &amp;int { bar(&amp;n) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> p1 = foo(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> p2 = foo(<span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{}, {}"</span></span>, *p1, *p2); }</code> <br>  : <br> demo:<span class="hljs-number"><span class="hljs-number">5</span></span>:<span class="hljs-number"><span class="hljs-number">10</span></span>: <span class="hljs-number"><span class="hljs-number">5</span></span>:<span class="hljs-number"><span class="hljs-number">11</span></span> error: `n` does not live long enough <br> demo:<span class="hljs-number"><span class="hljs-number">5</span></span> bar(&amp;n) <br> ^ <br> demo:<span class="hljs-number"><span class="hljs-number">4</span></span>:<span class="hljs-number"><span class="hljs-number">24</span></span>: <span class="hljs-number"><span class="hljs-number">6</span></span>:<span class="hljs-number"><span class="hljs-number">2</span></span> note: reference must <span class="hljs-keyword"><span class="hljs-keyword">be</span></span> valid <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> the anonymous lifetime #<span class="hljs-number"><span class="hljs-number">1</span></span> defined on the block at <span class="hljs-number"><span class="hljs-number">4</span></span>:<span class="hljs-number"><span class="hljs-number">23</span></span>... <br> demo:<span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>(n: int) -&gt; &amp;int { <br> demo:<span class="hljs-number"><span class="hljs-number">5</span></span> bar(&amp;n) <br> demo:<span class="hljs-number"><span class="hljs-number">6</span></span> } <br> demo:<span class="hljs-number"><span class="hljs-number">4</span></span>:<span class="hljs-number"><span class="hljs-number">24</span></span>: <span class="hljs-number"><span class="hljs-number">6</span></span>:<span class="hljs-number"><span class="hljs-number">2</span></span> note: ...but borrowed value is only valid <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> the block at <span class="hljs-number"><span class="hljs-number">4</span></span>:<span class="hljs-number"><span class="hljs-number">23</span></span> <br> demo:<span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>(n: int) -&gt; &amp;int { <br> demo:<span class="hljs-number"><span class="hljs-number">5</span></span> bar(&amp;n) <br> demo:<span class="hljs-number"><span class="hljs-number">6</span></span> } <br> <br>   <br> <code class="cpp">#include &lt;stdio.h&gt; int minval(int *A, int n) { int currmin; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;n; i++) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (A[i] &lt; currmin) currmin = A[i]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> currmin; } int main() { int A[] = {<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>}; int min = minval(A,<span class="hljs-number"><span class="hljs-number">3</span></span>); printf(<span class="hljs-string"><span class="hljs-string">"%d\n"</span></span>, min); }</code> <br>   <span class="hljs-number"><span class="hljs-number">0</span></span>  ,     , ,  .       Rust ( - ): <br> <code class="rust"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">minval</span></span></span></span>(A: &amp;[int]) -&gt; int { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> currmin; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> a <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> A.iter() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> *a &lt; currmin { currmin = *a; } } currmin } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> A = [<span class="hljs-number"><span class="hljs-number">1</span></span>i,<span class="hljs-number"><span class="hljs-number">2</span></span>i,<span class="hljs-number"><span class="hljs-number">3</span></span>i]; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> min = minval(A.as_slice()); <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{}"</span></span>, min); }</code> <br>  , : <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> of possibly uninitialized variable: `currmin` <br>   ( )      : <br> <code class="rust"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">minval</span></span></span></span>(A: &amp;[int]) -&gt; int { A.iter().fold(A[<span class="hljs-number"><span class="hljs-number">0</span></span>], |u,&amp;a| { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> a&lt;u {a} <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {u} }) }</code> <br> <br>    <br> <code class="cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span></span>{ int *x; A(int v): x(new int(v)) {} ~A() {delete x;} }; int main() { A a(<span class="hljs-number"><span class="hljs-number">1</span></span>), b=a; }</code> <br> ,    : <br> *** glibc detected *** demo: double free or corruption (fasttop): <span class="hljs-number"><span class="hljs-number">0x0000000000601010</span></span> *** <br> <br>     Rust: <br> <code class="rust"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span></span>{ x: <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;int&gt; } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> A { <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">new</span></span></span></span>(v: int) -&gt; A { A{ x: <span class="hljs-keyword"><span class="hljs-keyword">box</span></span> v } } } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Drop</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> A { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drop</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) {} <span class="hljs-comment"><span class="hljs-comment">// ,     ++ } fn main() { let a = A::new(1); let _b = a; }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">     .   ,     </span></span><code><span class="hljs-comment"><span class="hljs-comment">trait Copy</span></span></code><span class="hljs-comment"><span class="hljs-comment"> . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> Rust       .    </span></span><code><span class="hljs-comment"><span class="hljs-comment">Eq</span></span></code><span class="hljs-comment"><span class="hljs-comment">  </span></span><code><span class="hljs-comment"><span class="hljs-comment">Clone</span></span></code><span class="hljs-comment"><span class="hljs-comment"> ?    </span></span><code><span class="hljs-comment"><span class="hljs-comment">deriving</span></span></code><span class="hljs-comment"><span class="hljs-comment">   : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="rust"><span class="hljs-comment"><span class="hljs-comment">#[deriving(Clone, Eq, Hash, PartialEq, PartialOrd, Ord, Show)] struct A{ x: Box&lt;int&gt; }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">    </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="cpp"><span class="hljs-comment"><span class="hljs-comment">#include &lt;stdio.h&gt; struct X { int a, b; }; void swap_from(X&amp; x, const X&amp; y) { xa = yb; xb = ya; } int main() { X x = {1,2}; swap_from(x,x); printf("%d,%d\n", xa, xb); }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> 2,2 </span></span><br><span class="hljs-comment"><span class="hljs-comment">    ,    cc      .   ,   ,  99  </span></span><a href="http://en.wikipedia.org/wiki/Restrict"><span class="hljs-comment"><span class="hljs-comment">restrict</span></span></a><span class="hljs-comment"><span class="hljs-comment"> ,            :        . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">       Rust: </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="rust"><span class="hljs-comment"><span class="hljs-comment">struct X { pub a: int, pub b: int } fn swap_from(x: &amp;mut X, y: &amp;X) { xa = yb; xb = ya; } fn main() { let mut x = X{a:1, b:2}; swap_from(&amp;mut x, &amp;x); }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">    : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7:24: 7:25 error: cannot borrow `x` as immutable because it is also borrowed as mutable </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7 swap_from(&amp;mut x, &amp;x); </span></span><br><span class="hljs-comment"><span class="hljs-comment"> ^ </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7:20: 7:21 note: previous borrow of `x` occurs here; the mutable borrow prevents subsequent moves, borrows, or modification of `x` until the borrow ends </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7 swap_from(&amp;mut x, &amp;x); </span></span><br><span class="hljs-comment"><span class="hljs-comment"> ^ </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7:26: 7:26 note: previous borrow ends here </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7 swap_from(&amp;mut x, &amp;x); </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  ,             " </span></span><code><span class="hljs-comment"><span class="hljs-comment">&amp;mut</span></span></code><span class="hljs-comment"><span class="hljs-comment"> "  " </span></span><code><span class="hljs-comment"><span class="hljs-comment">&amp;</span></span></code><span class="hljs-comment"><span class="hljs-comment"> " ,   ,          ,   </span></span><code><span class="hljs-comment"><span class="hljs-comment">&amp;mut</span></span></code><span class="hljs-comment"><span class="hljs-comment"> .            .  ,    ,      C99  </span></span><code><span class="hljs-comment"><span class="hljs-comment">restrict</span></span></code><span class="hljs-comment"><span class="hljs-comment">  (Rust  LLVM    ),    . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">   </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="cpp"><span class="hljs-comment"><span class="hljs-comment">#include &lt;vector&gt; int main() { std::vector&lt;int&gt; v; v.push_back(1); v.push_back(2); for(std::vector&lt;int&gt;::const_iterator it=v.begin(); it!=v.end(); ++it) { if (*it &lt; 5) v.push_back(5-*it); } }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">    ,    : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> Segmentation fault (core dumped) </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">    Rust: </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="rust"><span class="hljs-comment"><span class="hljs-comment">fn main() { let mut v: Vec&lt;int&gt; = Vec::new(); v.push(1); v.push(2); for x in v.iter() { if *x &lt; 5 { v.push(5-*x); } } }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">      ,  ,        : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7:13: 7:14 error: cannot borrow `v` as mutable because it is also borrowed as immutable </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7 v.push(5-*x); </span></span><br><span class="hljs-comment"><span class="hljs-comment"> ^ </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:5:14: 5:15 note: previous borrow of `v` occurs here; the immutable borrow prevents subsequent moves or mutable borrows of `v` until the borrow ends </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:5 for x in v.iter() { </span></span><br><span class="hljs-comment"><span class="hljs-comment"> ^ </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:10:2: 10:2 note: previous borrow ends here </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:5 for x in v.iter() { </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:6 if *x &lt; 5 { </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7 v.push(5-*x); </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:8 } </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:9 } </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:10 } </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  Switch </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="cpp"><span class="hljs-comment"><span class="hljs-comment">#include &lt;stdio.h&gt; enum {RED, BLUE, GRAY, UNKNOWN} color = GRAY; int main() { int x; switch(color) { case GRAY: x=1; case RED: case BLUE: x=2; } printf("%d", x); }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">   "2".  Rust          .  ,       ,    </span></span><code><span class="hljs-comment"><span class="hljs-comment">break</span></span></code><span class="hljs-comment"><span class="hljs-comment"> .    Rust   : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="rust"><span class="hljs-comment"><span class="hljs-comment">enum Color {RED, BLUE, GRAY, UNKNOWN} fn main() { let color = GRAY; let x = match color { GRAY =&gt; 1, RED | BLUE =&gt; 2, _ =&gt; 3, }; println!("{}", x); }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">     </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="cpp"><span class="hljs-comment"><span class="hljs-comment">int main() { int pixels = 1; for (int j=0; j&lt;5; j++); pixels++; }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  Rust          . , ,     . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="cpp"><span class="hljs-comment"><span class="hljs-comment">#include &lt;stdio.h&gt; #include &lt;pthread.h&gt; #include &lt;unistd.h&gt; class Resource { int *value; public: Resource(): value(NULL) {} ~Resource() {delete value;} int *acquire() { if (!value) { value = new int(0); } return value; } }; void* function(void *param) { int *value = ((Resource*)param)-&gt;acquire(); printf("resource: %p\n", (void*)value); return value; } int main() { Resource res; for (int i=0; i&lt;5; ++i) { pthread_t pt; pthread_create(&amp;pt, NULL, function, &amp;res); } //sleep(10); printf("done\n"); }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">     : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> done </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7f229c0008c0 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7f22840008c0 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7f228c0008c0 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7f22940008c0 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7f227c0008c0 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">     ,        .      Rust: </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="rust"><span class="hljs-comment"><span class="hljs-comment">struct Resource { value: Option&lt;int&gt;, } impl Resource { pub fn new() -&gt; Resource { Resource{ value: None } } pub fn acquire&lt;'a&gt;(&amp;'a mut self) -&gt; &amp;'a int { if self.value.is_none() { self.value = Some(1); } self.value.get_ref() } } fn main() { let mut res = Resource::new(); for _ in range(0,5) { spawn(proc() { let ptr = res.acquire(); println!("resource {}", ptr) }) } }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  ,            . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:20:23: 20:26 error: cannot borrow immutable captured outer variable in a proc `res` as mutable </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:20 let ptr = res.acquire(); </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">      ,   : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="rust"><span class="hljs-comment"><span class="hljs-comment">extern crate sync; use sync::{Arc, RWLock}; struct Resource { value: Option&lt;Box&lt;int&gt;&gt;, } impl Resource { pub fn new() -&gt; Resource { Resource{ value: None } } pub fn acquire(&amp;mut self) -&gt; *int { if self.value.is_none() { self.value = Some(box 1) } &amp;**self.value.get_ref() as *int } } fn main() { let arc_res = Arc::new(RWLock::new(Resource::new())); for _ in range(0,5) { let child_res = arc_res.clone(); spawn(proc() { let ptr = child_res.write().acquire(); println!("resource: {}", ptr) }) } }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">     </span></span><code><span class="hljs-comment"><span class="hljs-comment">Arc</span></span></code><span class="hljs-comment"><span class="hljs-comment"> ( </span></span><i><span class="hljs-comment"><span class="hljs-comment">Atomically Reference Counted</span></span></i><span class="hljs-comment"><span class="hljs-comment"> -        )  </span></span><code><span class="hljs-comment"><span class="hljs-comment">RWLock</span></span></code><span class="hljs-comment"><span class="hljs-comment"> (   ).   : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7ff4b0010378 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7ff4b0010378 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7ff4b0010378 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7ff4b0010378 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7ff4b0010378 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  ,   ++    .    . Rust        ,    .  ,   ,   .           ,       ( </span></span><a href="http://superwebdeveloper.com/2009/11/25/the-incredible-rate-of-diminishing-returns-of-fixing-software-bugs/"><span class="hljs-comment"><span class="hljs-comment">  </span></span></a><span class="hljs-comment"><span class="hljs-comment"> ). </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">     </span></span><br><span class="hljs-comment"><span class="hljs-comment"> Rust        ,     </span></span><code><span class="hljs-comment"><span class="hljs-comment">unsafe{}</span></span></code><span class="hljs-comment"><span class="hljs-comment"> .   ,     " </span></span><i><span class="hljs-comment"><span class="hljs-comment"> !  ,  .</span></span></i><span class="hljs-comment"><span class="hljs-comment"> ".  ,  ""  (    ,    )    .    ,           ( )  . , ,        </span></span><code><span class="hljs-comment"><span class="hljs-comment">Cell</span></span></code><span class="hljs-comment"><span class="hljs-comment">  </span></span><code><span class="hljs-comment"><span class="hljs-comment">Mutex</span></span></code><span class="hljs-comment"><span class="hljs-comment"> .             ,       (   </span></span><a href="http://en.wikipedia.org/wiki/Test-driven_development"><span class="hljs-comment"><span class="hljs-comment">TDD</span></span></a><span class="hljs-comment"><span class="hljs-comment"> !). </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="https://air.mozilla.org/guaranteeing-memory-safety-in-rust/"><span class="hljs-comment"><span class="hljs-comment">Guaranteeing Memory Safety in Rust (by Niko Matsakis)</span></span></a><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="http://www.techtalkshub.com/rust-safe-systems-programming-fun-fp/"><span class="hljs-comment"><span class="hljs-comment">Rust: Safe Systems Programming with the Fun of FP (by Felix Klock II)</span></span></a><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Keynote"><span class="hljs-comment"><span class="hljs-comment">Lang-NEXT: What ‚Äì if anything ‚Äì have we learned from C++? (by Bjarne Stroustrup)</span></span></a><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Panel-Systems-Programming-Languages-in-2014-and-Beyond"><span class="hljs-comment"><span class="hljs-comment">Lang-NEXT Panel: Systems Programming in 2014 and Beyond</span></span></a></code></code> </pre> <code><code><code><code class="cpp">Box)     ,       (     ).        (std::rc::Rc)    (std::gc::Gc),      (   ). <br> <br></code>      <br>  ++: <br> #include &lt;stdio.h&gt; int *bar(int *p) { return p; } int* foo(int n) { return bar(&amp;n); } int main() { int *p1 = foo(1); int *p2 = foo(2); printf("%d, %d\n", *p1, *p2); }</code> <br>  : <br> 2, 2 <br> <br>  Rust: <br> <code class="rust">fn bar&lt;'a&gt;(p: &amp;'a int) -&gt; &amp;'a int { return p; } fn foo(n: int) -&gt; &amp;int { bar(&amp;n) } fn main() { let p1 = foo(1); let p2 = foo(2); println!("{}, {}", *p1, *p2); }</code> <br>  : <br> demo:5:10: 5:11 error: `n` does not live long enough <br> demo:5 bar(&amp;n) <br> ^ <br> demo:4:24: 6:2 note: reference must be valid for the anonymous lifetime #1 defined on the block at 4:23... <br> demo:4 fn foo(n: int) -&gt; &amp;int { <br> demo:5 bar(&amp;n) <br> demo:6 } <br> demo:4:24: 6:2 note: ...but borrowed value is only valid for the block at 4:23 <br> demo:4 fn foo(n: int) -&gt; &amp;int { <br> demo:5 bar(&amp;n) <br> demo:6 } <br> <br>   <br> <code class="cpp">#include &lt;stdio.h&gt; int minval(int *A, int n) { int currmin; for (int i=0; i&lt;n; i++) if (A[i] &lt; currmin) currmin = A[i]; return currmin; } int main() { int A[] = {1,2,3}; int min = minval(A,3); printf("%d\n", min); }</code> <br>   0  ,     , ,  .       Rust ( - ): <br> <code class="rust">fn minval(A: &amp;[int]) -&gt; int { let mut currmin; for a in A.iter() { if *a &lt; currmin { currmin = *a; } } currmin } fn main() { let A = [1i,2i,3i]; let min = minval(A.as_slice()); println!("{}", min); }</code> <br>  , : use of possibly uninitialized variable: `currmin` <br>   ( )      : <br> <code class="rust">fn minval(A: &amp;[int]) -&gt; int { A.iter().fold(A[0], |u,&amp;a| { if a&lt;u {a} else {u} }) }</code> <br> <br>    <br> <code class="cpp">struct A{ int *x; A(int v): x(new int(v)) {} ~A() {delete x;} }; int main() { A a(1), b=a; }</code> <br> ,    : <br> *** glibc detected *** demo: double free or corruption (fasttop): 0x0000000000601010 *** <br> <br>     Rust: <br> <code class="rust">struct A{ x: Box&lt;int&gt; } impl A { pub fn new(v: int) -&gt; A { A{ x: box v } } } impl Drop for A { fn drop(&amp;mut self) {} // ,     ++ } fn main() { let a = A::new(1); let _b = a; }</code> <br>     .   ,     <code>trait Copy</code> . <br> Rust       .    <code>Eq</code>  <code>Clone</code> ?    <code>deriving</code>   : <br> <code class="rust">#[deriving(Clone, Eq, Hash, PartialEq, PartialOrd, Ord, Show)] struct A{ x: Box&lt;int&gt; }</code> <br> <br>    <br> <code class="cpp">#include &lt;stdio.h&gt; struct X { int a, b; }; void swap_from(X&amp; x, const X&amp; y) { xa = yb; xb = ya; } int main() { X x = {1,2}; swap_from(x,x); printf("%d,%d\n", xa, xb); }</code> <br>  : <br> 2,2 <br>    ,    cc      .   ,   ,  99  <a href="http://en.wikipedia.org/wiki/Restrict">restrict</a> ,            :        . <br> <br>       Rust: <br> <code class="rust">struct X { pub a: int, pub b: int } fn swap_from(x: &amp;mut X, y: &amp;X) { xa = yb; xb = ya; } fn main() { let mut x = X{a:1, b:2}; swap_from(&amp;mut x, &amp;x); }</code> <br>    : <br> demo:7:24: 7:25 error: cannot borrow `x` as immutable because it is also borrowed as mutable <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> ^ <br> demo:7:20: 7:21 note: previous borrow of `x` occurs here; the mutable borrow prevents subsequent moves, borrows, or modification of `x` until the borrow ends <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> ^ <br> demo:7:26: 7:26 note: previous borrow ends here <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> <br>  ,             " <code>&amp;mut</code> "  " <code>&amp;</code> " ,   ,          ,   <code>&amp;mut</code> .            .  ,    ,      C99  <code>restrict</code>  (Rust  LLVM    ),    . <br> <br>   <br> <code class="cpp">#include &lt;vector&gt; int main() { std::vector&lt;int&gt; v; v.push_back(1); v.push_back(2); for(std::vector&lt;int&gt;::const_iterator it=v.begin(); it!=v.end(); ++it) { if (*it &lt; 5) v.push_back(5-*it); } }</code> <br>    ,    : <br> Segmentation fault (core dumped) <br> <br>    Rust: <br> <code class="rust">fn main() { let mut v: Vec&lt;int&gt; = Vec::new(); v.push(1); v.push(2); for x in v.iter() { if *x &lt; 5 { v.push(5-*x); } } }</code> <br>      ,  ,        : <br> demo:7:13: 7:14 error: cannot borrow `v` as mutable because it is also borrowed as immutable <br> demo:7 v.push(5-*x); <br> ^ <br> demo:5:14: 5:15 note: previous borrow of `v` occurs here; the immutable borrow prevents subsequent moves or mutable borrows of `v` until the borrow ends <br> demo:5 for x in v.iter() { <br> ^ <br> demo:10:2: 10:2 note: previous borrow ends here <br> demo:5 for x in v.iter() { <br> demo:6 if *x &lt; 5 { <br> demo:7 v.push(5-*x); <br> demo:8 } <br> demo:9 } <br> demo:10 } <br> <br> <br>  Switch <br> <code class="cpp">#include &lt;stdio.h&gt; enum {RED, BLUE, GRAY, UNKNOWN} color = GRAY; int main() { int x; switch(color) { case GRAY: x=1; case RED: case BLUE: x=2; } printf("%d", x); }</code> <br>   "2".  Rust          .  ,       ,    <code>break</code> .    Rust   : <br> <code class="rust">enum Color {RED, BLUE, GRAY, UNKNOWN} fn main() { let color = GRAY; let x = match color { GRAY =&gt; 1, RED | BLUE =&gt; 2, _ =&gt; 3, }; println!("{}", x); }</code> <br> <br>     <br> <code class="cpp">int main() { int pixels = 1; for (int j=0; j&lt;5; j++); pixels++; }</code> <br>  Rust          . , ,     . <br> <br>  <br> <code class="cpp">#include &lt;stdio.h&gt; #include &lt;pthread.h&gt; #include &lt;unistd.h&gt; class Resource { int *value; public: Resource(): value(NULL) {} ~Resource() {delete value;} int *acquire() { if (!value) { value = new int(0); } return value; } }; void* function(void *param) { int *value = ((Resource*)param)-&gt;acquire(); printf("resource: %p\n", (void*)value); return value; } int main() { Resource res; for (int i=0; i&lt;5; ++i) { pthread_t pt; pthread_create(&amp;pt, NULL, function, &amp;res); } //sleep(10); printf("done\n"); }</code> <br>     : <br> done <br> resource: 0x7f229c0008c0 <br> resource: 0x7f22840008c0 <br> resource: 0x7f228c0008c0 <br> resource: 0x7f22940008c0 <br> resource: 0x7f227c0008c0 <br> <br>     ,        .      Rust: <br> <code class="rust">struct Resource { value: Option&lt;int&gt;, } impl Resource { pub fn new() -&gt; Resource { Resource{ value: None } } pub fn acquire&lt;'a&gt;(&amp;'a mut self) -&gt; &amp;'a int { if self.value.is_none() { self.value = Some(1); } self.value.get_ref() } } fn main() { let mut res = Resource::new(); for _ in range(0,5) { spawn(proc() { let ptr = res.acquire(); println!("resource {}", ptr) }) } }</code> <br>  ,            . <br> demo:20:23: 20:26 error: cannot borrow immutable captured outer variable in a proc `res` as mutable <br> demo:20 let ptr = res.acquire(); <br> <br>      ,   : <br> <code class="rust">extern crate sync; use sync::{Arc, RWLock}; struct Resource { value: Option&lt;Box&lt;int&gt;&gt;, } impl Resource { pub fn new() -&gt; Resource { Resource{ value: None } } pub fn acquire(&amp;mut self) -&gt; *int { if self.value.is_none() { self.value = Some(box 1) } &amp;**self.value.get_ref() as *int } } fn main() { let arc_res = Arc::new(RWLock::new(Resource::new())); for _ in range(0,5) { let child_res = arc_res.clone(); spawn(proc() { let ptr = child_res.write().acquire(); println!("resource: {}", ptr) }) } }</code> <br>     <code>Arc</code> ( <i>Atomically Reference Counted</i> -        )  <code>RWLock</code> (   ).   : <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> <br>  ,   ++    .    . Rust        ,    .  ,   ,   .           ,       ( <a href="http://superwebdeveloper.com/2009/11/25/the-incredible-rate-of-diminishing-returns-of-fixing-software-bugs/">  </a> ). <br> <br>     <br> Rust        ,     <code>unsafe{}</code> .   ,     " <i> !  ,  .</i> ".  ,  ""  (    ,    )    .    ,           ( )  . , ,        <code>Cell</code>  <code>Mutex</code> .             ,       (   <a href="http://en.wikipedia.org/wiki/Test-driven_development">TDD</a> !). <br> <br>  <br> <a href="https://air.mozilla.org/guaranteeing-memory-safety-in-rust/">Guaranteeing Memory Safety in Rust (by Niko Matsakis)</a> <br> <a href="http://www.techtalkshub.com/rust-safe-systems-programming-fun-fp/">Rust: Safe Systems Programming with the Fun of FP (by Felix Klock II)</a> <br> <a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Keynote">Lang-NEXT: What ‚Äì if anything ‚Äì have we learned from C++? (by Bjarne Stroustrup)</a> <br> <a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Panel-Systems-Programming-Languages-in-2014-and-Beyond">Lang-NEXT Panel: Systems Programming in 2014 and Beyond</a></code></code> <h5> <code><code><code><code class="cpp">Box)     ,       (     ).        (std::rc::Rc)    (std::gc::Gc),      (   ). <br> <br></code>      <br>  ++: <br> #include &lt;stdio.h&gt; int *bar(int *p) { return p; } int* foo(int n) { return bar(&amp;n); } int main() { int *p1 = foo(1); int *p2 = foo(2); printf("%d, %d\n", *p1, *p2); }</code> <br>  : <br> 2, 2 <br> <br>  Rust: <br> <code class="rust">fn bar&lt;'a&gt;(p: &amp;'a int) -&gt; &amp;'a int { return p; } fn foo(n: int) -&gt; &amp;int { bar(&amp;n) } fn main() { let p1 = foo(1); let p2 = foo(2); println!("{}, {}", *p1, *p2); }</code> <br>  : <br> demo:5:10: 5:11 error: `n` does not live long enough <br> demo:5 bar(&amp;n) <br> ^ <br> demo:4:24: 6:2 note: reference must be valid for the anonymous lifetime #1 defined on the block at 4:23... <br> demo:4 fn foo(n: int) -&gt; &amp;int { <br> demo:5 bar(&amp;n) <br> demo:6 } <br> demo:4:24: 6:2 note: ...but borrowed value is only valid for the block at 4:23 <br> demo:4 fn foo(n: int) -&gt; &amp;int { <br> demo:5 bar(&amp;n) <br> demo:6 } <br> <br>   <br> <code class="cpp">#include &lt;stdio.h&gt; int minval(int *A, int n) { int currmin; for (int i=0; i&lt;n; i++) if (A[i] &lt; currmin) currmin = A[i]; return currmin; } int main() { int A[] = {1,2,3}; int min = minval(A,3); printf("%d\n", min); }</code> <br>   0  ,     , ,  .       Rust ( - ): <br> <code class="rust">fn minval(A: &amp;[int]) -&gt; int { let mut currmin; for a in A.iter() { if *a &lt; currmin { currmin = *a; } } currmin } fn main() { let A = [1i,2i,3i]; let min = minval(A.as_slice()); println!("{}", min); }</code> <br>  , : use of possibly uninitialized variable: `currmin` <br>   ( )      : <br> <code class="rust">fn minval(A: &amp;[int]) -&gt; int { A.iter().fold(A[0], |u,&amp;a| { if a&lt;u {a} else {u} }) }</code> <br> <br>    <br> <code class="cpp">struct A{ int *x; A(int v): x(new int(v)) {} ~A() {delete x;} }; int main() { A a(1), b=a; }</code> <br> ,    : <br> *** glibc detected *** demo: double free or corruption (fasttop): 0x0000000000601010 *** <br> <br>     Rust: <br> <code class="rust">struct A{ x: Box&lt;int&gt; } impl A { pub fn new(v: int) -&gt; A { A{ x: box v } } } impl Drop for A { fn drop(&amp;mut self) {} // ,     ++ } fn main() { let a = A::new(1); let _b = a; }</code> <br>     .   ,     <code>trait Copy</code> . <br> Rust       .    <code>Eq</code>  <code>Clone</code> ?    <code>deriving</code>   : <br> <code class="rust">#[deriving(Clone, Eq, Hash, PartialEq, PartialOrd, Ord, Show)] struct A{ x: Box&lt;int&gt; }</code> <br> <br>    <br> <code class="cpp">#include &lt;stdio.h&gt; struct X { int a, b; }; void swap_from(X&amp; x, const X&amp; y) { xa = yb; xb = ya; } int main() { X x = {1,2}; swap_from(x,x); printf("%d,%d\n", xa, xb); }</code> <br>  : <br> 2,2 <br>    ,    cc      .   ,   ,  99  <a href="http://en.wikipedia.org/wiki/Restrict">restrict</a> ,            :        . <br> <br>       Rust: <br> <code class="rust">struct X { pub a: int, pub b: int } fn swap_from(x: &amp;mut X, y: &amp;X) { xa = yb; xb = ya; } fn main() { let mut x = X{a:1, b:2}; swap_from(&amp;mut x, &amp;x); }</code> <br>    : <br> demo:7:24: 7:25 error: cannot borrow `x` as immutable because it is also borrowed as mutable <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> ^ <br> demo:7:20: 7:21 note: previous borrow of `x` occurs here; the mutable borrow prevents subsequent moves, borrows, or modification of `x` until the borrow ends <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> ^ <br> demo:7:26: 7:26 note: previous borrow ends here <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> <br>  ,             " <code>&amp;mut</code> "  " <code>&amp;</code> " ,   ,          ,   <code>&amp;mut</code> .            .  ,    ,      C99  <code>restrict</code>  (Rust  LLVM    ),    . <br> <br>   <br> <code class="cpp">#include &lt;vector&gt; int main() { std::vector&lt;int&gt; v; v.push_back(1); v.push_back(2); for(std::vector&lt;int&gt;::const_iterator it=v.begin(); it!=v.end(); ++it) { if (*it &lt; 5) v.push_back(5-*it); } }</code> <br>    ,    : <br> Segmentation fault (core dumped) <br> <br>    Rust: <br> <code class="rust">fn main() { let mut v: Vec&lt;int&gt; = Vec::new(); v.push(1); v.push(2); for x in v.iter() { if *x &lt; 5 { v.push(5-*x); } } }</code> <br>      ,  ,        : <br> demo:7:13: 7:14 error: cannot borrow `v` as mutable because it is also borrowed as immutable <br> demo:7 v.push(5-*x); <br> ^ <br> demo:5:14: 5:15 note: previous borrow of `v` occurs here; the immutable borrow prevents subsequent moves or mutable borrows of `v` until the borrow ends <br> demo:5 for x in v.iter() { <br> ^ <br> demo:10:2: 10:2 note: previous borrow ends here <br> demo:5 for x in v.iter() { <br> demo:6 if *x &lt; 5 { <br> demo:7 v.push(5-*x); <br> demo:8 } <br> demo:9 } <br> demo:10 } <br> <br> <br>  Switch <br> <code class="cpp">#include &lt;stdio.h&gt; enum {RED, BLUE, GRAY, UNKNOWN} color = GRAY; int main() { int x; switch(color) { case GRAY: x=1; case RED: case BLUE: x=2; } printf("%d", x); }</code> <br>   "2".  Rust          .  ,       ,    <code>break</code> .    Rust   : <br> <code class="rust">enum Color {RED, BLUE, GRAY, UNKNOWN} fn main() { let color = GRAY; let x = match color { GRAY =&gt; 1, RED | BLUE =&gt; 2, _ =&gt; 3, }; println!("{}", x); }</code> <br> <br>     <br> <code class="cpp">int main() { int pixels = 1; for (int j=0; j&lt;5; j++); pixels++; }</code> <br>  Rust          . , ,     . <br> <br>  <br> <code class="cpp">#include &lt;stdio.h&gt; #include &lt;pthread.h&gt; #include &lt;unistd.h&gt; class Resource { int *value; public: Resource(): value(NULL) {} ~Resource() {delete value;} int *acquire() { if (!value) { value = new int(0); } return value; } }; void* function(void *param) { int *value = ((Resource*)param)-&gt;acquire(); printf("resource: %p\n", (void*)value); return value; } int main() { Resource res; for (int i=0; i&lt;5; ++i) { pthread_t pt; pthread_create(&amp;pt, NULL, function, &amp;res); } //sleep(10); printf("done\n"); }</code> <br>     : <br> done <br> resource: 0x7f229c0008c0 <br> resource: 0x7f22840008c0 <br> resource: 0x7f228c0008c0 <br> resource: 0x7f22940008c0 <br> resource: 0x7f227c0008c0 <br> <br>     ,        .      Rust: <br> <code class="rust">struct Resource { value: Option&lt;int&gt;, } impl Resource { pub fn new() -&gt; Resource { Resource{ value: None } } pub fn acquire&lt;'a&gt;(&amp;'a mut self) -&gt; &amp;'a int { if self.value.is_none() { self.value = Some(1); } self.value.get_ref() } } fn main() { let mut res = Resource::new(); for _ in range(0,5) { spawn(proc() { let ptr = res.acquire(); println!("resource {}", ptr) }) } }</code> <br>  ,            . <br> demo:20:23: 20:26 error: cannot borrow immutable captured outer variable in a proc `res` as mutable <br> demo:20 let ptr = res.acquire(); <br> <br>      ,   : <br> <code class="rust">extern crate sync; use sync::{Arc, RWLock}; struct Resource { value: Option&lt;Box&lt;int&gt;&gt;, } impl Resource { pub fn new() -&gt; Resource { Resource{ value: None } } pub fn acquire(&amp;mut self) -&gt; *int { if self.value.is_none() { self.value = Some(box 1) } &amp;**self.value.get_ref() as *int } } fn main() { let arc_res = Arc::new(RWLock::new(Resource::new())); for _ in range(0,5) { let child_res = arc_res.clone(); spawn(proc() { let ptr = child_res.write().acquire(); println!("resource: {}", ptr) }) } }</code> <br>     <code>Arc</code> ( <i>Atomically Reference Counted</i> -        )  <code>RWLock</code> (   ).   : <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> <br>  ,   ++    .    . Rust        ,    .  ,   ,   .           ,       ( <a href="http://superwebdeveloper.com/2009/11/25/the-incredible-rate-of-diminishing-returns-of-fixing-software-bugs/">  </a> ). <br> <br>     <br> Rust        ,     <code>unsafe{}</code> .   ,     " <i> !  ,  .</i> ".  ,  ""  (    ,    )    .    ,           ( )  . , ,        <code>Cell</code>  <code>Mutex</code> .             ,       (   <a href="http://en.wikipedia.org/wiki/Test-driven_development">TDD</a> !). <br> <br>  <br> <a href="https://air.mozilla.org/guaranteeing-memory-safety-in-rust/">Guaranteeing Memory Safety in Rust (by Niko Matsakis)</a> <br> <a href="http://www.techtalkshub.com/rust-safe-systems-programming-fun-fp/">Rust: Safe Systems Programming with the Fun of FP (by Felix Klock II)</a> <br> <a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Keynote">Lang-NEXT: What ‚Äì if anything ‚Äì have we learned from C++? (by Bjarne Stroustrup)</a> <br> <a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Panel-Systems-Programming-Languages-in-2014-and-Beyond">Lang-NEXT Panel: Systems Programming in 2014 and Beyond</a></code></code> </h5> <code><code><code><code class="cpp">Box)     ,       (     ).        (std::rc::Rc)    (std::gc::Gc),      (   ). <br> <br></code>      <br>  ++: <br> #include &lt;stdio.h&gt; int *bar(int *p) { return p; } int* foo(int n) { return bar(&amp;n); } int main() { int *p1 = foo(1); int *p2 = foo(2); printf("%d, %d\n", *p1, *p2); }</code> <br>  : <br> 2, 2 <br> <br>  Rust: <br> <code class="rust">fn bar&lt;'a&gt;(p: &amp;'a int) -&gt; &amp;'a int { return p; } fn foo(n: int) -&gt; &amp;int { bar(&amp;n) } fn main() { let p1 = foo(1); let p2 = foo(2); println!("{}, {}", *p1, *p2); }</code> <br>  : <br> demo:5:10: 5:11 error: `n` does not live long enough <br> demo:5 bar(&amp;n) <br> ^ <br> demo:4:24: 6:2 note: reference must be valid for the anonymous lifetime #1 defined on the block at 4:23... <br> demo:4 fn foo(n: int) -&gt; &amp;int { <br> demo:5 bar(&amp;n) <br> demo:6 } <br> demo:4:24: 6:2 note: ...but borrowed value is only valid for the block at 4:23 <br> demo:4 fn foo(n: int) -&gt; &amp;int { <br> demo:5 bar(&amp;n) <br> demo:6 } <br> <br>   <br> <code class="cpp">#include &lt;stdio.h&gt; int minval(int *A, int n) { int currmin; for (int i=0; i&lt;n; i++) if (A[i] &lt; currmin) currmin = A[i]; return currmin; } int main() { int A[] = {1,2,3}; int min = minval(A,3); printf("%d\n", min); }</code> <br>   0  ,     , ,  .       Rust ( - ): <br> <code class="rust">fn minval(A: &amp;[int]) -&gt; int { let mut currmin; for a in A.iter() { if *a &lt; currmin { currmin = *a; } } currmin } fn main() { let A = [1i,2i,3i]; let min = minval(A.as_slice()); println!("{}", min); }</code> <br>  , : use of possibly uninitialized variable: `currmin` <br>   ( )      : <br> <code class="rust">fn minval(A: &amp;[int]) -&gt; int { A.iter().fold(A[0], |u,&amp;a| { if a&lt;u {a} else {u} }) }</code> <br> <br>    <br> <code class="cpp">struct A{ int *x; A(int v): x(new int(v)) {} ~A() {delete x;} }; int main() { A a(1), b=a; }</code> <br> ,    : <br> *** glibc detected *** demo: double free or corruption (fasttop): 0x0000000000601010 *** <br> <br>     Rust: <br> <code class="rust">struct A{ x: Box&lt;int&gt; } impl A { pub fn new(v: int) -&gt; A { A{ x: box v } } } impl Drop for A { fn drop(&amp;mut self) {} // ,     ++ } fn main() { let a = A::new(1); let _b = a; }</code> <br>     .   ,     <code>trait Copy</code> . <br> Rust       .    <code>Eq</code>  <code>Clone</code> ?    <code>deriving</code>   : <br> <code class="rust">#[deriving(Clone, Eq, Hash, PartialEq, PartialOrd, Ord, Show)] struct A{ x: Box&lt;int&gt; }</code> <br> <br>    <br> <code class="cpp">#include &lt;stdio.h&gt; struct X { int a, b; }; void swap_from(X&amp; x, const X&amp; y) { xa = yb; xb = ya; } int main() { X x = {1,2}; swap_from(x,x); printf("%d,%d\n", xa, xb); }</code> <br>  : <br> 2,2 <br>    ,    cc      .   ,   ,  99  <a href="http://en.wikipedia.org/wiki/Restrict">restrict</a> ,            :        . <br> <br>       Rust: <br> <code class="rust">struct X { pub a: int, pub b: int } fn swap_from(x: &amp;mut X, y: &amp;X) { xa = yb; xb = ya; } fn main() { let mut x = X{a:1, b:2}; swap_from(&amp;mut x, &amp;x); }</code> <br>    : <br> demo:7:24: 7:25 error: cannot borrow `x` as immutable because it is also borrowed as mutable <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> ^ <br> demo:7:20: 7:21 note: previous borrow of `x` occurs here; the mutable borrow prevents subsequent moves, borrows, or modification of `x` until the borrow ends <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> ^ <br> demo:7:26: 7:26 note: previous borrow ends here <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> <br>  ,             " <code>&amp;mut</code> "  " <code>&amp;</code> " ,   ,          ,   <code>&amp;mut</code> .            .  ,    ,      C99  <code>restrict</code>  (Rust  LLVM    ),    . <br> <br>   <br> <code class="cpp">#include &lt;vector&gt; int main() { std::vector&lt;int&gt; v; v.push_back(1); v.push_back(2); for(std::vector&lt;int&gt;::const_iterator it=v.begin(); it!=v.end(); ++it) { if (*it &lt; 5) v.push_back(5-*it); } }</code> <br>    ,    : <br> Segmentation fault (core dumped) <br> <br>    Rust: <br> <code class="rust">fn main() { let mut v: Vec&lt;int&gt; = Vec::new(); v.push(1); v.push(2); for x in v.iter() { if *x &lt; 5 { v.push(5-*x); } } }</code> <br>      ,  ,        : <br> demo:7:13: 7:14 error: cannot borrow `v` as mutable because it is also borrowed as immutable <br> demo:7 v.push(5-*x); <br> ^ <br> demo:5:14: 5:15 note: previous borrow of `v` occurs here; the immutable borrow prevents subsequent moves or mutable borrows of `v` until the borrow ends <br> demo:5 for x in v.iter() { <br> ^ <br> demo:10:2: 10:2 note: previous borrow ends here <br> demo:5 for x in v.iter() { <br> demo:6 if *x &lt; 5 { <br> demo:7 v.push(5-*x); <br> demo:8 } <br> demo:9 } <br> demo:10 } <br> <br> <br>  Switch <br> <code class="cpp">#include &lt;stdio.h&gt; enum {RED, BLUE, GRAY, UNKNOWN} color = GRAY; int main() { int x; switch(color) { case GRAY: x=1; case RED: case BLUE: x=2; } printf("%d", x); }</code> <br>   "2".  Rust          .  ,       ,    <code>break</code> .    Rust   : <br> <code class="rust">enum Color {RED, BLUE, GRAY, UNKNOWN} fn main() { let color = GRAY; let x = match color { GRAY =&gt; 1, RED | BLUE =&gt; 2, _ =&gt; 3, }; println!("{}", x); }</code> <br> <br>     <br> <code class="cpp">int main() { int pixels = 1; for (int j=0; j&lt;5; j++); pixels++; }</code> <br>  Rust          . , ,     . <br> <br>  <br> <code class="cpp">#include &lt;stdio.h&gt; #include &lt;pthread.h&gt; #include &lt;unistd.h&gt; class Resource { int *value; public: Resource(): value(NULL) {} ~Resource() {delete value;} int *acquire() { if (!value) { value = new int(0); } return value; } }; void* function(void *param) { int *value = ((Resource*)param)-&gt;acquire(); printf("resource: %p\n", (void*)value); return value; } int main() { Resource res; for (int i=0; i&lt;5; ++i) { pthread_t pt; pthread_create(&amp;pt, NULL, function, &amp;res); } //sleep(10); printf("done\n"); }</code> <br>     : <br> done <br> resource: 0x7f229c0008c0 <br> resource: 0x7f22840008c0 <br> resource: 0x7f228c0008c0 <br> resource: 0x7f22940008c0 <br> resource: 0x7f227c0008c0 <br> <br>     ,        .      Rust: <br> <code class="rust">struct Resource { value: Option&lt;int&gt;, } impl Resource { pub fn new() -&gt; Resource { Resource{ value: None } } pub fn acquire&lt;'a&gt;(&amp;'a mut self) -&gt; &amp;'a int { if self.value.is_none() { self.value = Some(1); } self.value.get_ref() } } fn main() { let mut res = Resource::new(); for _ in range(0,5) { spawn(proc() { let ptr = res.acquire(); println!("resource {}", ptr) }) } }</code> <br>  ,            . <br> demo:20:23: 20:26 error: cannot borrow immutable captured outer variable in a proc `res` as mutable <br> demo:20 let ptr = res.acquire(); <br> <br>      ,   : <br> <code class="rust">extern crate sync; use sync::{Arc, RWLock}; struct Resource { value: Option&lt;Box&lt;int&gt;&gt;, } impl Resource { pub fn new() -&gt; Resource { Resource{ value: None } } pub fn acquire(&amp;mut self) -&gt; *int { if self.value.is_none() { self.value = Some(box 1) } &amp;**self.value.get_ref() as *int } } fn main() { let arc_res = Arc::new(RWLock::new(Resource::new())); for _ in range(0,5) { let child_res = arc_res.clone(); spawn(proc() { let ptr = child_res.write().acquire(); println!("resource: {}", ptr) }) } }</code> <br>     <code>Arc</code> ( <i>Atomically Reference Counted</i> -        )  <code>RWLock</code> (   ).   : <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> <br>  ,   ++    .    . Rust        ,    .  ,   ,   .           ,       ( <a href="http://superwebdeveloper.com/2009/11/25/the-incredible-rate-of-diminishing-returns-of-fixing-software-bugs/">  </a> ). <br> <br>     <br> Rust        ,     <code>unsafe{}</code> .   ,     " <i> !  ,  .</i> ".  ,  ""  (    ,    )    .    ,           ( )  . , ,        <code>Cell</code>  <code>Mutex</code> .             ,       (   <a href="http://en.wikipedia.org/wiki/Test-driven_development">TDD</a> !). <br> <br>  <br> <a href="https://air.mozilla.org/guaranteeing-memory-safety-in-rust/">Guaranteeing Memory Safety in Rust (by Niko Matsakis)</a> <br> <a href="http://www.techtalkshub.com/rust-safe-systems-programming-fun-fp/">Rust: Safe Systems Programming with the Fun of FP (by Felix Klock II)</a> <br> <a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Keynote">Lang-NEXT: What ‚Äì if anything ‚Äì have we learned from C++? (by Bjarne Stroustrup)</a> <br> <a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Panel-Systems-Programming-Languages-in-2014-and-Beyond">Lang-NEXT Panel: Systems Programming in 2014 and Beyond</a></code></code> <pre> <code class="hljs rust"><code><code><code class="cpp"><span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>)     ,       (     ).        (std::rc::Rc)    (std::gc::Gc),      (   ). <br> <br></code>      <br>  ++: <br> #include &lt;stdio.h&gt; int *bar(int *p) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p; } int* foo(int n) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bar(&amp;n); } int main() { int *p1 = foo(<span class="hljs-number"><span class="hljs-number">1</span></span>); int *p2 = foo(<span class="hljs-number"><span class="hljs-number">2</span></span>); printf(<span class="hljs-string"><span class="hljs-string">"%d, %d\n"</span></span>, *p1, *p2); }</code> <br>  : <br> <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span> <br> <br>  Rust: <br> <code class="rust"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt;(p: &amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> int) -&gt; &amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> int { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>(n: int) -&gt; &amp;int { bar(&amp;n) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> p1 = foo(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> p2 = foo(<span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{}, {}"</span></span>, *p1, *p2); }</code> <br>  : <br> demo:<span class="hljs-number"><span class="hljs-number">5</span></span>:<span class="hljs-number"><span class="hljs-number">10</span></span>: <span class="hljs-number"><span class="hljs-number">5</span></span>:<span class="hljs-number"><span class="hljs-number">11</span></span> error: `n` does not live long enough <br> demo:<span class="hljs-number"><span class="hljs-number">5</span></span> bar(&amp;n) <br> ^ <br> demo:<span class="hljs-number"><span class="hljs-number">4</span></span>:<span class="hljs-number"><span class="hljs-number">24</span></span>: <span class="hljs-number"><span class="hljs-number">6</span></span>:<span class="hljs-number"><span class="hljs-number">2</span></span> note: reference must <span class="hljs-keyword"><span class="hljs-keyword">be</span></span> valid <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> the anonymous lifetime #<span class="hljs-number"><span class="hljs-number">1</span></span> defined on the block at <span class="hljs-number"><span class="hljs-number">4</span></span>:<span class="hljs-number"><span class="hljs-number">23</span></span>... <br> demo:<span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>(n: int) -&gt; &amp;int { <br> demo:<span class="hljs-number"><span class="hljs-number">5</span></span> bar(&amp;n) <br> demo:<span class="hljs-number"><span class="hljs-number">6</span></span> } <br> demo:<span class="hljs-number"><span class="hljs-number">4</span></span>:<span class="hljs-number"><span class="hljs-number">24</span></span>: <span class="hljs-number"><span class="hljs-number">6</span></span>:<span class="hljs-number"><span class="hljs-number">2</span></span> note: ...but borrowed value is only valid <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> the block at <span class="hljs-number"><span class="hljs-number">4</span></span>:<span class="hljs-number"><span class="hljs-number">23</span></span> <br> demo:<span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>(n: int) -&gt; &amp;int { <br> demo:<span class="hljs-number"><span class="hljs-number">5</span></span> bar(&amp;n) <br> demo:<span class="hljs-number"><span class="hljs-number">6</span></span> } <br> <br>   <br> <code class="cpp">#include &lt;stdio.h&gt; int minval(int *A, int n) { int currmin; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;n; i++) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (A[i] &lt; currmin) currmin = A[i]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> currmin; } int main() { int A[] = {<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>}; int min = minval(A,<span class="hljs-number"><span class="hljs-number">3</span></span>); printf(<span class="hljs-string"><span class="hljs-string">"%d\n"</span></span>, min); }</code> <br>   <span class="hljs-number"><span class="hljs-number">0</span></span>  ,     , ,  .       Rust ( - ): <br> <code class="rust"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">minval</span></span></span></span>(A: &amp;[int]) -&gt; int { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> currmin; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> a <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> A.iter() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> *a &lt; currmin { currmin = *a; } } currmin } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> A = [<span class="hljs-number"><span class="hljs-number">1</span></span>i,<span class="hljs-number"><span class="hljs-number">2</span></span>i,<span class="hljs-number"><span class="hljs-number">3</span></span>i]; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> min = minval(A.as_slice()); <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{}"</span></span>, min); }</code> <br>  , : <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> of possibly uninitialized variable: `currmin` <br>   ( )      : <br> <code class="rust"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">minval</span></span></span></span>(A: &amp;[int]) -&gt; int { A.iter().fold(A[<span class="hljs-number"><span class="hljs-number">0</span></span>], |u,&amp;a| { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> a&lt;u {a} <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {u} }) }</code> <br> <br>    <br> <code class="cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span></span>{ int *x; A(int v): x(new int(v)) {} ~A() {delete x;} }; int main() { A a(<span class="hljs-number"><span class="hljs-number">1</span></span>), b=a; }</code> <br> ,    : <br> *** glibc detected *** demo: double free or corruption (fasttop): <span class="hljs-number"><span class="hljs-number">0x0000000000601010</span></span> *** <br> <br>     Rust: <br> <code class="rust"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span></span>{ x: <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;int&gt; } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> A { <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">new</span></span></span></span>(v: int) -&gt; A { A{ x: <span class="hljs-keyword"><span class="hljs-keyword">box</span></span> v } } } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Drop</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> A { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drop</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) {} <span class="hljs-comment"><span class="hljs-comment">// ,     ++ } fn main() { let a = A::new(1); let _b = a; }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">     .   ,     </span></span><code><span class="hljs-comment"><span class="hljs-comment">trait Copy</span></span></code><span class="hljs-comment"><span class="hljs-comment"> . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> Rust       .    </span></span><code><span class="hljs-comment"><span class="hljs-comment">Eq</span></span></code><span class="hljs-comment"><span class="hljs-comment">  </span></span><code><span class="hljs-comment"><span class="hljs-comment">Clone</span></span></code><span class="hljs-comment"><span class="hljs-comment"> ?    </span></span><code><span class="hljs-comment"><span class="hljs-comment">deriving</span></span></code><span class="hljs-comment"><span class="hljs-comment">   : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="rust"><span class="hljs-comment"><span class="hljs-comment">#[deriving(Clone, Eq, Hash, PartialEq, PartialOrd, Ord, Show)] struct A{ x: Box&lt;int&gt; }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">    </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="cpp"><span class="hljs-comment"><span class="hljs-comment">#include &lt;stdio.h&gt; struct X { int a, b; }; void swap_from(X&amp; x, const X&amp; y) { xa = yb; xb = ya; } int main() { X x = {1,2}; swap_from(x,x); printf("%d,%d\n", xa, xb); }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> 2,2 </span></span><br><span class="hljs-comment"><span class="hljs-comment">    ,    cc      .   ,   ,  99  </span></span><a href="http://en.wikipedia.org/wiki/Restrict"><span class="hljs-comment"><span class="hljs-comment">restrict</span></span></a><span class="hljs-comment"><span class="hljs-comment"> ,            :        . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">       Rust: </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="rust"><span class="hljs-comment"><span class="hljs-comment">struct X { pub a: int, pub b: int } fn swap_from(x: &amp;mut X, y: &amp;X) { xa = yb; xb = ya; } fn main() { let mut x = X{a:1, b:2}; swap_from(&amp;mut x, &amp;x); }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">    : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7:24: 7:25 error: cannot borrow `x` as immutable because it is also borrowed as mutable </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7 swap_from(&amp;mut x, &amp;x); </span></span><br><span class="hljs-comment"><span class="hljs-comment"> ^ </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7:20: 7:21 note: previous borrow of `x` occurs here; the mutable borrow prevents subsequent moves, borrows, or modification of `x` until the borrow ends </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7 swap_from(&amp;mut x, &amp;x); </span></span><br><span class="hljs-comment"><span class="hljs-comment"> ^ </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7:26: 7:26 note: previous borrow ends here </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7 swap_from(&amp;mut x, &amp;x); </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  ,             " </span></span><code><span class="hljs-comment"><span class="hljs-comment">&amp;mut</span></span></code><span class="hljs-comment"><span class="hljs-comment"> "  " </span></span><code><span class="hljs-comment"><span class="hljs-comment">&amp;</span></span></code><span class="hljs-comment"><span class="hljs-comment"> " ,   ,          ,   </span></span><code><span class="hljs-comment"><span class="hljs-comment">&amp;mut</span></span></code><span class="hljs-comment"><span class="hljs-comment"> .            .  ,    ,      C99  </span></span><code><span class="hljs-comment"><span class="hljs-comment">restrict</span></span></code><span class="hljs-comment"><span class="hljs-comment">  (Rust  LLVM    ),    . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">   </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="cpp"><span class="hljs-comment"><span class="hljs-comment">#include &lt;vector&gt; int main() { std::vector&lt;int&gt; v; v.push_back(1); v.push_back(2); for(std::vector&lt;int&gt;::const_iterator it=v.begin(); it!=v.end(); ++it) { if (*it &lt; 5) v.push_back(5-*it); } }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">    ,    : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> Segmentation fault (core dumped) </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">    Rust: </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="rust"><span class="hljs-comment"><span class="hljs-comment">fn main() { let mut v: Vec&lt;int&gt; = Vec::new(); v.push(1); v.push(2); for x in v.iter() { if *x &lt; 5 { v.push(5-*x); } } }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">      ,  ,        : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7:13: 7:14 error: cannot borrow `v` as mutable because it is also borrowed as immutable </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7 v.push(5-*x); </span></span><br><span class="hljs-comment"><span class="hljs-comment"> ^ </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:5:14: 5:15 note: previous borrow of `v` occurs here; the immutable borrow prevents subsequent moves or mutable borrows of `v` until the borrow ends </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:5 for x in v.iter() { </span></span><br><span class="hljs-comment"><span class="hljs-comment"> ^ </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:10:2: 10:2 note: previous borrow ends here </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:5 for x in v.iter() { </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:6 if *x &lt; 5 { </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7 v.push(5-*x); </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:8 } </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:9 } </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:10 } </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  Switch </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="cpp"><span class="hljs-comment"><span class="hljs-comment">#include &lt;stdio.h&gt; enum {RED, BLUE, GRAY, UNKNOWN} color = GRAY; int main() { int x; switch(color) { case GRAY: x=1; case RED: case BLUE: x=2; } printf("%d", x); }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">   "2".  Rust          .  ,       ,    </span></span><code><span class="hljs-comment"><span class="hljs-comment">break</span></span></code><span class="hljs-comment"><span class="hljs-comment"> .    Rust   : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="rust"><span class="hljs-comment"><span class="hljs-comment">enum Color {RED, BLUE, GRAY, UNKNOWN} fn main() { let color = GRAY; let x = match color { GRAY =&gt; 1, RED | BLUE =&gt; 2, _ =&gt; 3, }; println!("{}", x); }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">     </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="cpp"><span class="hljs-comment"><span class="hljs-comment">int main() { int pixels = 1; for (int j=0; j&lt;5; j++); pixels++; }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  Rust          . , ,     . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="cpp"><span class="hljs-comment"><span class="hljs-comment">#include &lt;stdio.h&gt; #include &lt;pthread.h&gt; #include &lt;unistd.h&gt; class Resource { int *value; public: Resource(): value(NULL) {} ~Resource() {delete value;} int *acquire() { if (!value) { value = new int(0); } return value; } }; void* function(void *param) { int *value = ((Resource*)param)-&gt;acquire(); printf("resource: %p\n", (void*)value); return value; } int main() { Resource res; for (int i=0; i&lt;5; ++i) { pthread_t pt; pthread_create(&amp;pt, NULL, function, &amp;res); } //sleep(10); printf("done\n"); }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">     : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> done </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7f229c0008c0 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7f22840008c0 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7f228c0008c0 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7f22940008c0 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7f227c0008c0 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">     ,        .      Rust: </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="rust"><span class="hljs-comment"><span class="hljs-comment">struct Resource { value: Option&lt;int&gt;, } impl Resource { pub fn new() -&gt; Resource { Resource{ value: None } } pub fn acquire&lt;'a&gt;(&amp;'a mut self) -&gt; &amp;'a int { if self.value.is_none() { self.value = Some(1); } self.value.get_ref() } } fn main() { let mut res = Resource::new(); for _ in range(0,5) { spawn(proc() { let ptr = res.acquire(); println!("resource {}", ptr) }) } }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  ,            . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:20:23: 20:26 error: cannot borrow immutable captured outer variable in a proc `res` as mutable </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:20 let ptr = res.acquire(); </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">      ,   : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="rust"><span class="hljs-comment"><span class="hljs-comment">extern crate sync; use sync::{Arc, RWLock}; struct Resource { value: Option&lt;Box&lt;int&gt;&gt;, } impl Resource { pub fn new() -&gt; Resource { Resource{ value: None } } pub fn acquire(&amp;mut self) -&gt; *int { if self.value.is_none() { self.value = Some(box 1) } &amp;**self.value.get_ref() as *int } } fn main() { let arc_res = Arc::new(RWLock::new(Resource::new())); for _ in range(0,5) { let child_res = arc_res.clone(); spawn(proc() { let ptr = child_res.write().acquire(); println!("resource: {}", ptr) }) } }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">     </span></span><code><span class="hljs-comment"><span class="hljs-comment">Arc</span></span></code><span class="hljs-comment"><span class="hljs-comment"> ( </span></span><i><span class="hljs-comment"><span class="hljs-comment">Atomically Reference Counted</span></span></i><span class="hljs-comment"><span class="hljs-comment"> -        )  </span></span><code><span class="hljs-comment"><span class="hljs-comment">RWLock</span></span></code><span class="hljs-comment"><span class="hljs-comment"> (   ).   : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7ff4b0010378 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7ff4b0010378 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7ff4b0010378 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7ff4b0010378 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7ff4b0010378 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  ,   ++    .    . Rust        ,    .  ,   ,   .           ,       ( </span></span><a href="http://superwebdeveloper.com/2009/11/25/the-incredible-rate-of-diminishing-returns-of-fixing-software-bugs/"><span class="hljs-comment"><span class="hljs-comment">  </span></span></a><span class="hljs-comment"><span class="hljs-comment"> ). </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">     </span></span><br><span class="hljs-comment"><span class="hljs-comment"> Rust        ,     </span></span><code><span class="hljs-comment"><span class="hljs-comment">unsafe{}</span></span></code><span class="hljs-comment"><span class="hljs-comment"> .   ,     " </span></span><i><span class="hljs-comment"><span class="hljs-comment"> !  ,  .</span></span></i><span class="hljs-comment"><span class="hljs-comment"> ".  ,  ""  (    ,    )    .    ,           ( )  . , ,        </span></span><code><span class="hljs-comment"><span class="hljs-comment">Cell</span></span></code><span class="hljs-comment"><span class="hljs-comment">  </span></span><code><span class="hljs-comment"><span class="hljs-comment">Mutex</span></span></code><span class="hljs-comment"><span class="hljs-comment"> .             ,       (   </span></span><a href="http://en.wikipedia.org/wiki/Test-driven_development"><span class="hljs-comment"><span class="hljs-comment">TDD</span></span></a><span class="hljs-comment"><span class="hljs-comment"> !). </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="https://air.mozilla.org/guaranteeing-memory-safety-in-rust/"><span class="hljs-comment"><span class="hljs-comment">Guaranteeing Memory Safety in Rust (by Niko Matsakis)</span></span></a><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="http://www.techtalkshub.com/rust-safe-systems-programming-fun-fp/"><span class="hljs-comment"><span class="hljs-comment">Rust: Safe Systems Programming with the Fun of FP (by Felix Klock II)</span></span></a><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Keynote"><span class="hljs-comment"><span class="hljs-comment">Lang-NEXT: What ‚Äì if anything ‚Äì have we learned from C++? (by Bjarne Stroustrup)</span></span></a><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Panel-Systems-Programming-Languages-in-2014-and-Beyond"><span class="hljs-comment"><span class="hljs-comment">Lang-NEXT Panel: Systems Programming in 2014 and Beyond</span></span></a></code></code> </pre> <code><code><code><code class="cpp">Box)     ,       (     ).        (std::rc::Rc)    (std::gc::Gc),      (   ). <br> <br></code>      <br>  ++: <br> #include &lt;stdio.h&gt; int *bar(int *p) { return p; } int* foo(int n) { return bar(&amp;n); } int main() { int *p1 = foo(1); int *p2 = foo(2); printf("%d, %d\n", *p1, *p2); }</code> <br>  : <br> 2, 2 <br> <br>  Rust: <br> <code class="rust">fn bar&lt;'a&gt;(p: &amp;'a int) -&gt; &amp;'a int { return p; } fn foo(n: int) -&gt; &amp;int { bar(&amp;n) } fn main() { let p1 = foo(1); let p2 = foo(2); println!("{}, {}", *p1, *p2); }</code> <br>  : <br> demo:5:10: 5:11 error: `n` does not live long enough <br> demo:5 bar(&amp;n) <br> ^ <br> demo:4:24: 6:2 note: reference must be valid for the anonymous lifetime #1 defined on the block at 4:23... <br> demo:4 fn foo(n: int) -&gt; &amp;int { <br> demo:5 bar(&amp;n) <br> demo:6 } <br> demo:4:24: 6:2 note: ...but borrowed value is only valid for the block at 4:23 <br> demo:4 fn foo(n: int) -&gt; &amp;int { <br> demo:5 bar(&amp;n) <br> demo:6 } <br> <br>   <br> <code class="cpp">#include &lt;stdio.h&gt; int minval(int *A, int n) { int currmin; for (int i=0; i&lt;n; i++) if (A[i] &lt; currmin) currmin = A[i]; return currmin; } int main() { int A[] = {1,2,3}; int min = minval(A,3); printf("%d\n", min); }</code> <br>   0  ,     , ,  .       Rust ( - ): <br> <code class="rust">fn minval(A: &amp;[int]) -&gt; int { let mut currmin; for a in A.iter() { if *a &lt; currmin { currmin = *a; } } currmin } fn main() { let A = [1i,2i,3i]; let min = minval(A.as_slice()); println!("{}", min); }</code> <br>  , : use of possibly uninitialized variable: `currmin` <br>   ( )      : <br> <code class="rust">fn minval(A: &amp;[int]) -&gt; int { A.iter().fold(A[0], |u,&amp;a| { if a&lt;u {a} else {u} }) }</code> <br> <br>    <br> <code class="cpp">struct A{ int *x; A(int v): x(new int(v)) {} ~A() {delete x;} }; int main() { A a(1), b=a; }</code> <br> ,    : <br> *** glibc detected *** demo: double free or corruption (fasttop): 0x0000000000601010 *** <br> <br>     Rust: <br> <code class="rust">struct A{ x: Box&lt;int&gt; } impl A { pub fn new(v: int) -&gt; A { A{ x: box v } } } impl Drop for A { fn drop(&amp;mut self) {} // ,     ++ } fn main() { let a = A::new(1); let _b = a; }</code> <br>     .   ,     <code>trait Copy</code> . <br> Rust       .    <code>Eq</code>  <code>Clone</code> ?    <code>deriving</code>   : <br> <code class="rust">#[deriving(Clone, Eq, Hash, PartialEq, PartialOrd, Ord, Show)] struct A{ x: Box&lt;int&gt; }</code> <br> <br>    <br> <code class="cpp">#include &lt;stdio.h&gt; struct X { int a, b; }; void swap_from(X&amp; x, const X&amp; y) { xa = yb; xb = ya; } int main() { X x = {1,2}; swap_from(x,x); printf("%d,%d\n", xa, xb); }</code> <br>  : <br> 2,2 <br>    ,    cc      .   ,   ,  99  <a href="http://en.wikipedia.org/wiki/Restrict">restrict</a> ,            :        . <br> <br>       Rust: <br> <code class="rust">struct X { pub a: int, pub b: int } fn swap_from(x: &amp;mut X, y: &amp;X) { xa = yb; xb = ya; } fn main() { let mut x = X{a:1, b:2}; swap_from(&amp;mut x, &amp;x); }</code> <br>    : <br> demo:7:24: 7:25 error: cannot borrow `x` as immutable because it is also borrowed as mutable <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> ^ <br> demo:7:20: 7:21 note: previous borrow of `x` occurs here; the mutable borrow prevents subsequent moves, borrows, or modification of `x` until the borrow ends <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> ^ <br> demo:7:26: 7:26 note: previous borrow ends here <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> <br>  ,             " <code>&amp;mut</code> "  " <code>&amp;</code> " ,   ,          ,   <code>&amp;mut</code> .            .  ,    ,      C99  <code>restrict</code>  (Rust  LLVM    ),    . <br> <br>   <br> <code class="cpp">#include &lt;vector&gt; int main() { std::vector&lt;int&gt; v; v.push_back(1); v.push_back(2); for(std::vector&lt;int&gt;::const_iterator it=v.begin(); it!=v.end(); ++it) { if (*it &lt; 5) v.push_back(5-*it); } }</code> <br>    ,    : <br> Segmentation fault (core dumped) <br> <br>    Rust: <br> <code class="rust">fn main() { let mut v: Vec&lt;int&gt; = Vec::new(); v.push(1); v.push(2); for x in v.iter() { if *x &lt; 5 { v.push(5-*x); } } }</code> <br>      ,  ,        : <br> demo:7:13: 7:14 error: cannot borrow `v` as mutable because it is also borrowed as immutable <br> demo:7 v.push(5-*x); <br> ^ <br> demo:5:14: 5:15 note: previous borrow of `v` occurs here; the immutable borrow prevents subsequent moves or mutable borrows of `v` until the borrow ends <br> demo:5 for x in v.iter() { <br> ^ <br> demo:10:2: 10:2 note: previous borrow ends here <br> demo:5 for x in v.iter() { <br> demo:6 if *x &lt; 5 { <br> demo:7 v.push(5-*x); <br> demo:8 } <br> demo:9 } <br> demo:10 } <br> <br> <br>  Switch <br> <code class="cpp">#include &lt;stdio.h&gt; enum {RED, BLUE, GRAY, UNKNOWN} color = GRAY; int main() { int x; switch(color) { case GRAY: x=1; case RED: case BLUE: x=2; } printf("%d", x); }</code> <br>   "2".  Rust          .  ,       ,    <code>break</code> .    Rust   : <br> <code class="rust">enum Color {RED, BLUE, GRAY, UNKNOWN} fn main() { let color = GRAY; let x = match color { GRAY =&gt; 1, RED | BLUE =&gt; 2, _ =&gt; 3, }; println!("{}", x); }</code> <br> <br>     <br> <code class="cpp">int main() { int pixels = 1; for (int j=0; j&lt;5; j++); pixels++; }</code> <br>  Rust          . , ,     . <br> <br>  <br> <code class="cpp">#include &lt;stdio.h&gt; #include &lt;pthread.h&gt; #include &lt;unistd.h&gt; class Resource { int *value; public: Resource(): value(NULL) {} ~Resource() {delete value;} int *acquire() { if (!value) { value = new int(0); } return value; } }; void* function(void *param) { int *value = ((Resource*)param)-&gt;acquire(); printf("resource: %p\n", (void*)value); return value; } int main() { Resource res; for (int i=0; i&lt;5; ++i) { pthread_t pt; pthread_create(&amp;pt, NULL, function, &amp;res); } //sleep(10); printf("done\n"); }</code> <br>     : <br> done <br> resource: 0x7f229c0008c0 <br> resource: 0x7f22840008c0 <br> resource: 0x7f228c0008c0 <br> resource: 0x7f22940008c0 <br> resource: 0x7f227c0008c0 <br> <br>     ,        .      Rust: <br> <code class="rust">struct Resource { value: Option&lt;int&gt;, } impl Resource { pub fn new() -&gt; Resource { Resource{ value: None } } pub fn acquire&lt;'a&gt;(&amp;'a mut self) -&gt; &amp;'a int { if self.value.is_none() { self.value = Some(1); } self.value.get_ref() } } fn main() { let mut res = Resource::new(); for _ in range(0,5) { spawn(proc() { let ptr = res.acquire(); println!("resource {}", ptr) }) } }</code> <br>  ,            . <br> demo:20:23: 20:26 error: cannot borrow immutable captured outer variable in a proc `res` as mutable <br> demo:20 let ptr = res.acquire(); <br> <br>      ,   : <br> <code class="rust">extern crate sync; use sync::{Arc, RWLock}; struct Resource { value: Option&lt;Box&lt;int&gt;&gt;, } impl Resource { pub fn new() -&gt; Resource { Resource{ value: None } } pub fn acquire(&amp;mut self) -&gt; *int { if self.value.is_none() { self.value = Some(box 1) } &amp;**self.value.get_ref() as *int } } fn main() { let arc_res = Arc::new(RWLock::new(Resource::new())); for _ in range(0,5) { let child_res = arc_res.clone(); spawn(proc() { let ptr = child_res.write().acquire(); println!("resource: {}", ptr) }) } }</code> <br>     <code>Arc</code> ( <i>Atomically Reference Counted</i> -        )  <code>RWLock</code> (   ).   : <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> <br>  ,   ++    .    . Rust        ,    .  ,   ,   .           ,       ( <a href="http://superwebdeveloper.com/2009/11/25/the-incredible-rate-of-diminishing-returns-of-fixing-software-bugs/">  </a> ). <br> <br>     <br> Rust        ,     <code>unsafe{}</code> .   ,     " <i> !  ,  .</i> ".  ,  ""  (    ,    )    .    ,           ( )  . , ,        <code>Cell</code>  <code>Mutex</code> .             ,       (   <a href="http://en.wikipedia.org/wiki/Test-driven_development">TDD</a> !). <br> <br>  <br> <a href="https://air.mozilla.org/guaranteeing-memory-safety-in-rust/">Guaranteeing Memory Safety in Rust (by Niko Matsakis)</a> <br> <a href="http://www.techtalkshub.com/rust-safe-systems-programming-fun-fp/">Rust: Safe Systems Programming with the Fun of FP (by Felix Klock II)</a> <br> <a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Keynote">Lang-NEXT: What ‚Äì if anything ‚Äì have we learned from C++? (by Bjarne Stroustrup)</a> <br> <a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Panel-Systems-Programming-Languages-in-2014-and-Beyond">Lang-NEXT Panel: Systems Programming in 2014 and Beyond</a></code></code> <h4> <code><code><code><code class="cpp">Box)     ,       (     ).        (std::rc::Rc)    (std::gc::Gc),      (   ). <br> <br></code>      <br>  ++: <br> #include &lt;stdio.h&gt; int *bar(int *p) { return p; } int* foo(int n) { return bar(&amp;n); } int main() { int *p1 = foo(1); int *p2 = foo(2); printf("%d, %d\n", *p1, *p2); }</code> <br>  : <br> 2, 2 <br> <br>  Rust: <br> <code class="rust">fn bar&lt;'a&gt;(p: &amp;'a int) -&gt; &amp;'a int { return p; } fn foo(n: int) -&gt; &amp;int { bar(&amp;n) } fn main() { let p1 = foo(1); let p2 = foo(2); println!("{}, {}", *p1, *p2); }</code> <br>  : <br> demo:5:10: 5:11 error: `n` does not live long enough <br> demo:5 bar(&amp;n) <br> ^ <br> demo:4:24: 6:2 note: reference must be valid for the anonymous lifetime #1 defined on the block at 4:23... <br> demo:4 fn foo(n: int) -&gt; &amp;int { <br> demo:5 bar(&amp;n) <br> demo:6 } <br> demo:4:24: 6:2 note: ...but borrowed value is only valid for the block at 4:23 <br> demo:4 fn foo(n: int) -&gt; &amp;int { <br> demo:5 bar(&amp;n) <br> demo:6 } <br> <br>   <br> <code class="cpp">#include &lt;stdio.h&gt; int minval(int *A, int n) { int currmin; for (int i=0; i&lt;n; i++) if (A[i] &lt; currmin) currmin = A[i]; return currmin; } int main() { int A[] = {1,2,3}; int min = minval(A,3); printf("%d\n", min); }</code> <br>   0  ,     , ,  .       Rust ( - ): <br> <code class="rust">fn minval(A: &amp;[int]) -&gt; int { let mut currmin; for a in A.iter() { if *a &lt; currmin { currmin = *a; } } currmin } fn main() { let A = [1i,2i,3i]; let min = minval(A.as_slice()); println!("{}", min); }</code> <br>  , : use of possibly uninitialized variable: `currmin` <br>   ( )      : <br> <code class="rust">fn minval(A: &amp;[int]) -&gt; int { A.iter().fold(A[0], |u,&amp;a| { if a&lt;u {a} else {u} }) }</code> <br> <br>    <br> <code class="cpp">struct A{ int *x; A(int v): x(new int(v)) {} ~A() {delete x;} }; int main() { A a(1), b=a; }</code> <br> ,    : <br> *** glibc detected *** demo: double free or corruption (fasttop): 0x0000000000601010 *** <br> <br>     Rust: <br> <code class="rust">struct A{ x: Box&lt;int&gt; } impl A { pub fn new(v: int) -&gt; A { A{ x: box v } } } impl Drop for A { fn drop(&amp;mut self) {} // ,     ++ } fn main() { let a = A::new(1); let _b = a; }</code> <br>     .   ,     <code>trait Copy</code> . <br> Rust       .    <code>Eq</code>  <code>Clone</code> ?    <code>deriving</code>   : <br> <code class="rust">#[deriving(Clone, Eq, Hash, PartialEq, PartialOrd, Ord, Show)] struct A{ x: Box&lt;int&gt; }</code> <br> <br>    <br> <code class="cpp">#include &lt;stdio.h&gt; struct X { int a, b; }; void swap_from(X&amp; x, const X&amp; y) { xa = yb; xb = ya; } int main() { X x = {1,2}; swap_from(x,x); printf("%d,%d\n", xa, xb); }</code> <br>  : <br> 2,2 <br>    ,    cc      .   ,   ,  99  <a href="http://en.wikipedia.org/wiki/Restrict">restrict</a> ,            :        . <br> <br>       Rust: <br> <code class="rust">struct X { pub a: int, pub b: int } fn swap_from(x: &amp;mut X, y: &amp;X) { xa = yb; xb = ya; } fn main() { let mut x = X{a:1, b:2}; swap_from(&amp;mut x, &amp;x); }</code> <br>    : <br> demo:7:24: 7:25 error: cannot borrow `x` as immutable because it is also borrowed as mutable <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> ^ <br> demo:7:20: 7:21 note: previous borrow of `x` occurs here; the mutable borrow prevents subsequent moves, borrows, or modification of `x` until the borrow ends <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> ^ <br> demo:7:26: 7:26 note: previous borrow ends here <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> <br>  ,             " <code>&amp;mut</code> "  " <code>&amp;</code> " ,   ,          ,   <code>&amp;mut</code> .            .  ,    ,      C99  <code>restrict</code>  (Rust  LLVM    ),    . <br> <br>   <br> <code class="cpp">#include &lt;vector&gt; int main() { std::vector&lt;int&gt; v; v.push_back(1); v.push_back(2); for(std::vector&lt;int&gt;::const_iterator it=v.begin(); it!=v.end(); ++it) { if (*it &lt; 5) v.push_back(5-*it); } }</code> <br>    ,    : <br> Segmentation fault (core dumped) <br> <br>    Rust: <br> <code class="rust">fn main() { let mut v: Vec&lt;int&gt; = Vec::new(); v.push(1); v.push(2); for x in v.iter() { if *x &lt; 5 { v.push(5-*x); } } }</code> <br>      ,  ,        : <br> demo:7:13: 7:14 error: cannot borrow `v` as mutable because it is also borrowed as immutable <br> demo:7 v.push(5-*x); <br> ^ <br> demo:5:14: 5:15 note: previous borrow of `v` occurs here; the immutable borrow prevents subsequent moves or mutable borrows of `v` until the borrow ends <br> demo:5 for x in v.iter() { <br> ^ <br> demo:10:2: 10:2 note: previous borrow ends here <br> demo:5 for x in v.iter() { <br> demo:6 if *x &lt; 5 { <br> demo:7 v.push(5-*x); <br> demo:8 } <br> demo:9 } <br> demo:10 } <br> <br> <br>  Switch <br> <code class="cpp">#include &lt;stdio.h&gt; enum {RED, BLUE, GRAY, UNKNOWN} color = GRAY; int main() { int x; switch(color) { case GRAY: x=1; case RED: case BLUE: x=2; } printf("%d", x); }</code> <br>   "2".  Rust          .  ,       ,    <code>break</code> .    Rust   : <br> <code class="rust">enum Color {RED, BLUE, GRAY, UNKNOWN} fn main() { let color = GRAY; let x = match color { GRAY =&gt; 1, RED | BLUE =&gt; 2, _ =&gt; 3, }; println!("{}", x); }</code> <br> <br>     <br> <code class="cpp">int main() { int pixels = 1; for (int j=0; j&lt;5; j++); pixels++; }</code> <br>  Rust          . , ,     . <br> <br>  <br> <code class="cpp">#include &lt;stdio.h&gt; #include &lt;pthread.h&gt; #include &lt;unistd.h&gt; class Resource { int *value; public: Resource(): value(NULL) {} ~Resource() {delete value;} int *acquire() { if (!value) { value = new int(0); } return value; } }; void* function(void *param) { int *value = ((Resource*)param)-&gt;acquire(); printf("resource: %p\n", (void*)value); return value; } int main() { Resource res; for (int i=0; i&lt;5; ++i) { pthread_t pt; pthread_create(&amp;pt, NULL, function, &amp;res); } //sleep(10); printf("done\n"); }</code> <br>     : <br> done <br> resource: 0x7f229c0008c0 <br> resource: 0x7f22840008c0 <br> resource: 0x7f228c0008c0 <br> resource: 0x7f22940008c0 <br> resource: 0x7f227c0008c0 <br> <br>     ,        .      Rust: <br> <code class="rust">struct Resource { value: Option&lt;int&gt;, } impl Resource { pub fn new() -&gt; Resource { Resource{ value: None } } pub fn acquire&lt;'a&gt;(&amp;'a mut self) -&gt; &amp;'a int { if self.value.is_none() { self.value = Some(1); } self.value.get_ref() } } fn main() { let mut res = Resource::new(); for _ in range(0,5) { spawn(proc() { let ptr = res.acquire(); println!("resource {}", ptr) }) } }</code> <br>  ,            . <br> demo:20:23: 20:26 error: cannot borrow immutable captured outer variable in a proc `res` as mutable <br> demo:20 let ptr = res.acquire(); <br> <br>      ,   : <br> <code class="rust">extern crate sync; use sync::{Arc, RWLock}; struct Resource { value: Option&lt;Box&lt;int&gt;&gt;, } impl Resource { pub fn new() -&gt; Resource { Resource{ value: None } } pub fn acquire(&amp;mut self) -&gt; *int { if self.value.is_none() { self.value = Some(box 1) } &amp;**self.value.get_ref() as *int } } fn main() { let arc_res = Arc::new(RWLock::new(Resource::new())); for _ in range(0,5) { let child_res = arc_res.clone(); spawn(proc() { let ptr = child_res.write().acquire(); println!("resource: {}", ptr) }) } }</code> <br>     <code>Arc</code> ( <i>Atomically Reference Counted</i> -        )  <code>RWLock</code> (   ).   : <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> <br>  ,   ++    .    . Rust        ,    .  ,   ,   .           ,       ( <a href="http://superwebdeveloper.com/2009/11/25/the-incredible-rate-of-diminishing-returns-of-fixing-software-bugs/">  </a> ). <br> <br>     <br> Rust        ,     <code>unsafe{}</code> .   ,     " <i> !  ,  .</i> ".  ,  ""  (    ,    )    .    ,           ( )  . , ,        <code>Cell</code>  <code>Mutex</code> .             ,       (   <a href="http://en.wikipedia.org/wiki/Test-driven_development">TDD</a> !). <br> <br>  <br> <a href="https://air.mozilla.org/guaranteeing-memory-safety-in-rust/">Guaranteeing Memory Safety in Rust (by Niko Matsakis)</a> <br> <a href="http://www.techtalkshub.com/rust-safe-systems-programming-fun-fp/">Rust: Safe Systems Programming with the Fun of FP (by Felix Klock II)</a> <br> <a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Keynote">Lang-NEXT: What ‚Äì if anything ‚Äì have we learned from C++? (by Bjarne Stroustrup)</a> <br> <a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Panel-Systems-Programming-Languages-in-2014-and-Beyond">Lang-NEXT Panel: Systems Programming in 2014 and Beyond</a></code></code> </h4> <code><code><code><code class="cpp">Box)     ,       (     ).        (std::rc::Rc)    (std::gc::Gc),      (   ). <br> <br></code>      <br>  ++: <br> #include &lt;stdio.h&gt; int *bar(int *p) { return p; } int* foo(int n) { return bar(&amp;n); } int main() { int *p1 = foo(1); int *p2 = foo(2); printf("%d, %d\n", *p1, *p2); }</code> <br>  : <br> 2, 2 <br> <br>  Rust: <br> <code class="rust">fn bar&lt;'a&gt;(p: &amp;'a int) -&gt; &amp;'a int { return p; } fn foo(n: int) -&gt; &amp;int { bar(&amp;n) } fn main() { let p1 = foo(1); let p2 = foo(2); println!("{}, {}", *p1, *p2); }</code> <br>  : <br> demo:5:10: 5:11 error: `n` does not live long enough <br> demo:5 bar(&amp;n) <br> ^ <br> demo:4:24: 6:2 note: reference must be valid for the anonymous lifetime #1 defined on the block at 4:23... <br> demo:4 fn foo(n: int) -&gt; &amp;int { <br> demo:5 bar(&amp;n) <br> demo:6 } <br> demo:4:24: 6:2 note: ...but borrowed value is only valid for the block at 4:23 <br> demo:4 fn foo(n: int) -&gt; &amp;int { <br> demo:5 bar(&amp;n) <br> demo:6 } <br> <br>   <br> <code class="cpp">#include &lt;stdio.h&gt; int minval(int *A, int n) { int currmin; for (int i=0; i&lt;n; i++) if (A[i] &lt; currmin) currmin = A[i]; return currmin; } int main() { int A[] = {1,2,3}; int min = minval(A,3); printf("%d\n", min); }</code> <br>   0  ,     , ,  .       Rust ( - ): <br> <code class="rust">fn minval(A: &amp;[int]) -&gt; int { let mut currmin; for a in A.iter() { if *a &lt; currmin { currmin = *a; } } currmin } fn main() { let A = [1i,2i,3i]; let min = minval(A.as_slice()); println!("{}", min); }</code> <br>  , : use of possibly uninitialized variable: `currmin` <br>   ( )      : <br> <code class="rust">fn minval(A: &amp;[int]) -&gt; int { A.iter().fold(A[0], |u,&amp;a| { if a&lt;u {a} else {u} }) }</code> <br> <br>    <br> <code class="cpp">struct A{ int *x; A(int v): x(new int(v)) {} ~A() {delete x;} }; int main() { A a(1), b=a; }</code> <br> ,    : <br> *** glibc detected *** demo: double free or corruption (fasttop): 0x0000000000601010 *** <br> <br>     Rust: <br> <code class="rust">struct A{ x: Box&lt;int&gt; } impl A { pub fn new(v: int) -&gt; A { A{ x: box v } } } impl Drop for A { fn drop(&amp;mut self) {} // ,     ++ } fn main() { let a = A::new(1); let _b = a; }</code> <br>     .   ,     <code>trait Copy</code> . <br> Rust       .    <code>Eq</code>  <code>Clone</code> ?    <code>deriving</code>   : <br> <code class="rust">#[deriving(Clone, Eq, Hash, PartialEq, PartialOrd, Ord, Show)] struct A{ x: Box&lt;int&gt; }</code> <br> <br>    <br> <code class="cpp">#include &lt;stdio.h&gt; struct X { int a, b; }; void swap_from(X&amp; x, const X&amp; y) { xa = yb; xb = ya; } int main() { X x = {1,2}; swap_from(x,x); printf("%d,%d\n", xa, xb); }</code> <br>  : <br> 2,2 <br>    ,    cc      .   ,   ,  99  <a href="http://en.wikipedia.org/wiki/Restrict">restrict</a> ,            :        . <br> <br>       Rust: <br> <code class="rust">struct X { pub a: int, pub b: int } fn swap_from(x: &amp;mut X, y: &amp;X) { xa = yb; xb = ya; } fn main() { let mut x = X{a:1, b:2}; swap_from(&amp;mut x, &amp;x); }</code> <br>    : <br> demo:7:24: 7:25 error: cannot borrow `x` as immutable because it is also borrowed as mutable <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> ^ <br> demo:7:20: 7:21 note: previous borrow of `x` occurs here; the mutable borrow prevents subsequent moves, borrows, or modification of `x` until the borrow ends <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> ^ <br> demo:7:26: 7:26 note: previous borrow ends here <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> <br>  ,             " <code>&amp;mut</code> "  " <code>&amp;</code> " ,   ,          ,   <code>&amp;mut</code> .            .  ,    ,      C99  <code>restrict</code>  (Rust  LLVM    ),    . <br> <br>   <br> <code class="cpp">#include &lt;vector&gt; int main() { std::vector&lt;int&gt; v; v.push_back(1); v.push_back(2); for(std::vector&lt;int&gt;::const_iterator it=v.begin(); it!=v.end(); ++it) { if (*it &lt; 5) v.push_back(5-*it); } }</code> <br>    ,    : <br> Segmentation fault (core dumped) <br> <br>    Rust: <br> <code class="rust">fn main() { let mut v: Vec&lt;int&gt; = Vec::new(); v.push(1); v.push(2); for x in v.iter() { if *x &lt; 5 { v.push(5-*x); } } }</code> <br>      ,  ,        : <br> demo:7:13: 7:14 error: cannot borrow `v` as mutable because it is also borrowed as immutable <br> demo:7 v.push(5-*x); <br> ^ <br> demo:5:14: 5:15 note: previous borrow of `v` occurs here; the immutable borrow prevents subsequent moves or mutable borrows of `v` until the borrow ends <br> demo:5 for x in v.iter() { <br> ^ <br> demo:10:2: 10:2 note: previous borrow ends here <br> demo:5 for x in v.iter() { <br> demo:6 if *x &lt; 5 { <br> demo:7 v.push(5-*x); <br> demo:8 } <br> demo:9 } <br> demo:10 } <br> <br> <br>  Switch <br> <code class="cpp">#include &lt;stdio.h&gt; enum {RED, BLUE, GRAY, UNKNOWN} color = GRAY; int main() { int x; switch(color) { case GRAY: x=1; case RED: case BLUE: x=2; } printf("%d", x); }</code> <br>   "2".  Rust          .  ,       ,    <code>break</code> .    Rust   : <br> <code class="rust">enum Color {RED, BLUE, GRAY, UNKNOWN} fn main() { let color = GRAY; let x = match color { GRAY =&gt; 1, RED | BLUE =&gt; 2, _ =&gt; 3, }; println!("{}", x); }</code> <br> <br>     <br> <code class="cpp">int main() { int pixels = 1; for (int j=0; j&lt;5; j++); pixels++; }</code> <br>  Rust          . , ,     . <br> <br>  <br> <code class="cpp">#include &lt;stdio.h&gt; #include &lt;pthread.h&gt; #include &lt;unistd.h&gt; class Resource { int *value; public: Resource(): value(NULL) {} ~Resource() {delete value;} int *acquire() { if (!value) { value = new int(0); } return value; } }; void* function(void *param) { int *value = ((Resource*)param)-&gt;acquire(); printf("resource: %p\n", (void*)value); return value; } int main() { Resource res; for (int i=0; i&lt;5; ++i) { pthread_t pt; pthread_create(&amp;pt, NULL, function, &amp;res); } //sleep(10); printf("done\n"); }</code> <br>     : <br> done <br> resource: 0x7f229c0008c0 <br> resource: 0x7f22840008c0 <br> resource: 0x7f228c0008c0 <br> resource: 0x7f22940008c0 <br> resource: 0x7f227c0008c0 <br> <br>     ,        .      Rust: <br> <code class="rust">struct Resource { value: Option&lt;int&gt;, } impl Resource { pub fn new() -&gt; Resource { Resource{ value: None } } pub fn acquire&lt;'a&gt;(&amp;'a mut self) -&gt; &amp;'a int { if self.value.is_none() { self.value = Some(1); } self.value.get_ref() } } fn main() { let mut res = Resource::new(); for _ in range(0,5) { spawn(proc() { let ptr = res.acquire(); println!("resource {}", ptr) }) } }</code> <br>  ,            . <br> demo:20:23: 20:26 error: cannot borrow immutable captured outer variable in a proc `res` as mutable <br> demo:20 let ptr = res.acquire(); <br> <br>      ,   : <br> <code class="rust">extern crate sync; use sync::{Arc, RWLock}; struct Resource { value: Option&lt;Box&lt;int&gt;&gt;, } impl Resource { pub fn new() -&gt; Resource { Resource{ value: None } } pub fn acquire(&amp;mut self) -&gt; *int { if self.value.is_none() { self.value = Some(box 1) } &amp;**self.value.get_ref() as *int } } fn main() { let arc_res = Arc::new(RWLock::new(Resource::new())); for _ in range(0,5) { let child_res = arc_res.clone(); spawn(proc() { let ptr = child_res.write().acquire(); println!("resource: {}", ptr) }) } }</code> <br>     <code>Arc</code> ( <i>Atomically Reference Counted</i> -        )  <code>RWLock</code> (   ).   : <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> <br>  ,   ++    .    . Rust        ,    .  ,   ,   .           ,       ( <a href="http://superwebdeveloper.com/2009/11/25/the-incredible-rate-of-diminishing-returns-of-fixing-software-bugs/">  </a> ). <br> <br>     <br> Rust        ,     <code>unsafe{}</code> .   ,     " <i> !  ,  .</i> ".  ,  ""  (    ,    )    .    ,           ( )  . , ,        <code>Cell</code>  <code>Mutex</code> .             ,       (   <a href="http://en.wikipedia.org/wiki/Test-driven_development">TDD</a> !). <br> <br>  <br> <a href="https://air.mozilla.org/guaranteeing-memory-safety-in-rust/">Guaranteeing Memory Safety in Rust (by Niko Matsakis)</a> <br> <a href="http://www.techtalkshub.com/rust-safe-systems-programming-fun-fp/">Rust: Safe Systems Programming with the Fun of FP (by Felix Klock II)</a> <br> <a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Keynote">Lang-NEXT: What ‚Äì if anything ‚Äì have we learned from C++? (by Bjarne Stroustrup)</a> <br> <a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Panel-Systems-Programming-Languages-in-2014-and-Beyond">Lang-NEXT Panel: Systems Programming in 2014 and Beyond</a></code></code> <pre> <code class="hljs rust"><code><code><code class="cpp"><span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>)     ,       (     ).        (std::rc::Rc)    (std::gc::Gc),      (   ). <br> <br></code>      <br>  ++: <br> #include &lt;stdio.h&gt; int *bar(int *p) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p; } int* foo(int n) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bar(&amp;n); } int main() { int *p1 = foo(<span class="hljs-number"><span class="hljs-number">1</span></span>); int *p2 = foo(<span class="hljs-number"><span class="hljs-number">2</span></span>); printf(<span class="hljs-string"><span class="hljs-string">"%d, %d\n"</span></span>, *p1, *p2); }</code> <br>  : <br> <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span> <br> <br>  Rust: <br> <code class="rust"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt;(p: &amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> int) -&gt; &amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> int { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>(n: int) -&gt; &amp;int { bar(&amp;n) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> p1 = foo(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> p2 = foo(<span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{}, {}"</span></span>, *p1, *p2); }</code> <br>  : <br> demo:<span class="hljs-number"><span class="hljs-number">5</span></span>:<span class="hljs-number"><span class="hljs-number">10</span></span>: <span class="hljs-number"><span class="hljs-number">5</span></span>:<span class="hljs-number"><span class="hljs-number">11</span></span> error: `n` does not live long enough <br> demo:<span class="hljs-number"><span class="hljs-number">5</span></span> bar(&amp;n) <br> ^ <br> demo:<span class="hljs-number"><span class="hljs-number">4</span></span>:<span class="hljs-number"><span class="hljs-number">24</span></span>: <span class="hljs-number"><span class="hljs-number">6</span></span>:<span class="hljs-number"><span class="hljs-number">2</span></span> note: reference must <span class="hljs-keyword"><span class="hljs-keyword">be</span></span> valid <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> the anonymous lifetime #<span class="hljs-number"><span class="hljs-number">1</span></span> defined on the block at <span class="hljs-number"><span class="hljs-number">4</span></span>:<span class="hljs-number"><span class="hljs-number">23</span></span>... <br> demo:<span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>(n: int) -&gt; &amp;int { <br> demo:<span class="hljs-number"><span class="hljs-number">5</span></span> bar(&amp;n) <br> demo:<span class="hljs-number"><span class="hljs-number">6</span></span> } <br> demo:<span class="hljs-number"><span class="hljs-number">4</span></span>:<span class="hljs-number"><span class="hljs-number">24</span></span>: <span class="hljs-number"><span class="hljs-number">6</span></span>:<span class="hljs-number"><span class="hljs-number">2</span></span> note: ...but borrowed value is only valid <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> the block at <span class="hljs-number"><span class="hljs-number">4</span></span>:<span class="hljs-number"><span class="hljs-number">23</span></span> <br> demo:<span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>(n: int) -&gt; &amp;int { <br> demo:<span class="hljs-number"><span class="hljs-number">5</span></span> bar(&amp;n) <br> demo:<span class="hljs-number"><span class="hljs-number">6</span></span> } <br> <br>   <br> <code class="cpp">#include &lt;stdio.h&gt; int minval(int *A, int n) { int currmin; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;n; i++) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (A[i] &lt; currmin) currmin = A[i]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> currmin; } int main() { int A[] = {<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>}; int min = minval(A,<span class="hljs-number"><span class="hljs-number">3</span></span>); printf(<span class="hljs-string"><span class="hljs-string">"%d\n"</span></span>, min); }</code> <br>   <span class="hljs-number"><span class="hljs-number">0</span></span>  ,     , ,  .       Rust ( - ): <br> <code class="rust"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">minval</span></span></span></span>(A: &amp;[int]) -&gt; int { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> currmin; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> a <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> A.iter() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> *a &lt; currmin { currmin = *a; } } currmin } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> A = [<span class="hljs-number"><span class="hljs-number">1</span></span>i,<span class="hljs-number"><span class="hljs-number">2</span></span>i,<span class="hljs-number"><span class="hljs-number">3</span></span>i]; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> min = minval(A.as_slice()); <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{}"</span></span>, min); }</code> <br>  , : <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> of possibly uninitialized variable: `currmin` <br>   ( )      : <br> <code class="rust"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">minval</span></span></span></span>(A: &amp;[int]) -&gt; int { A.iter().fold(A[<span class="hljs-number"><span class="hljs-number">0</span></span>], |u,&amp;a| { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> a&lt;u {a} <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {u} }) }</code> <br> <br>    <br> <code class="cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span></span>{ int *x; A(int v): x(new int(v)) {} ~A() {delete x;} }; int main() { A a(<span class="hljs-number"><span class="hljs-number">1</span></span>), b=a; }</code> <br> ,    : <br> *** glibc detected *** demo: double free or corruption (fasttop): <span class="hljs-number"><span class="hljs-number">0x0000000000601010</span></span> *** <br> <br>     Rust: <br> <code class="rust"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span></span>{ x: <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;int&gt; } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> A { <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">new</span></span></span></span>(v: int) -&gt; A { A{ x: <span class="hljs-keyword"><span class="hljs-keyword">box</span></span> v } } } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Drop</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> A { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drop</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) {} <span class="hljs-comment"><span class="hljs-comment">// ,     ++ } fn main() { let a = A::new(1); let _b = a; }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">     .   ,     </span></span><code><span class="hljs-comment"><span class="hljs-comment">trait Copy</span></span></code><span class="hljs-comment"><span class="hljs-comment"> . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> Rust       .    </span></span><code><span class="hljs-comment"><span class="hljs-comment">Eq</span></span></code><span class="hljs-comment"><span class="hljs-comment">  </span></span><code><span class="hljs-comment"><span class="hljs-comment">Clone</span></span></code><span class="hljs-comment"><span class="hljs-comment"> ?    </span></span><code><span class="hljs-comment"><span class="hljs-comment">deriving</span></span></code><span class="hljs-comment"><span class="hljs-comment">   : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="rust"><span class="hljs-comment"><span class="hljs-comment">#[deriving(Clone, Eq, Hash, PartialEq, PartialOrd, Ord, Show)] struct A{ x: Box&lt;int&gt; }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">    </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="cpp"><span class="hljs-comment"><span class="hljs-comment">#include &lt;stdio.h&gt; struct X { int a, b; }; void swap_from(X&amp; x, const X&amp; y) { xa = yb; xb = ya; } int main() { X x = {1,2}; swap_from(x,x); printf("%d,%d\n", xa, xb); }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> 2,2 </span></span><br><span class="hljs-comment"><span class="hljs-comment">    ,    cc      .   ,   ,  99  </span></span><a href="http://en.wikipedia.org/wiki/Restrict"><span class="hljs-comment"><span class="hljs-comment">restrict</span></span></a><span class="hljs-comment"><span class="hljs-comment"> ,            :        . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">       Rust: </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="rust"><span class="hljs-comment"><span class="hljs-comment">struct X { pub a: int, pub b: int } fn swap_from(x: &amp;mut X, y: &amp;X) { xa = yb; xb = ya; } fn main() { let mut x = X{a:1, b:2}; swap_from(&amp;mut x, &amp;x); }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">    : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7:24: 7:25 error: cannot borrow `x` as immutable because it is also borrowed as mutable </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7 swap_from(&amp;mut x, &amp;x); </span></span><br><span class="hljs-comment"><span class="hljs-comment"> ^ </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7:20: 7:21 note: previous borrow of `x` occurs here; the mutable borrow prevents subsequent moves, borrows, or modification of `x` until the borrow ends </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7 swap_from(&amp;mut x, &amp;x); </span></span><br><span class="hljs-comment"><span class="hljs-comment"> ^ </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7:26: 7:26 note: previous borrow ends here </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7 swap_from(&amp;mut x, &amp;x); </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  ,             " </span></span><code><span class="hljs-comment"><span class="hljs-comment">&amp;mut</span></span></code><span class="hljs-comment"><span class="hljs-comment"> "  " </span></span><code><span class="hljs-comment"><span class="hljs-comment">&amp;</span></span></code><span class="hljs-comment"><span class="hljs-comment"> " ,   ,          ,   </span></span><code><span class="hljs-comment"><span class="hljs-comment">&amp;mut</span></span></code><span class="hljs-comment"><span class="hljs-comment"> .            .  ,    ,      C99  </span></span><code><span class="hljs-comment"><span class="hljs-comment">restrict</span></span></code><span class="hljs-comment"><span class="hljs-comment">  (Rust  LLVM    ),    . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">   </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="cpp"><span class="hljs-comment"><span class="hljs-comment">#include &lt;vector&gt; int main() { std::vector&lt;int&gt; v; v.push_back(1); v.push_back(2); for(std::vector&lt;int&gt;::const_iterator it=v.begin(); it!=v.end(); ++it) { if (*it &lt; 5) v.push_back(5-*it); } }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">    ,    : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> Segmentation fault (core dumped) </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">    Rust: </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="rust"><span class="hljs-comment"><span class="hljs-comment">fn main() { let mut v: Vec&lt;int&gt; = Vec::new(); v.push(1); v.push(2); for x in v.iter() { if *x &lt; 5 { v.push(5-*x); } } }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">      ,  ,        : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7:13: 7:14 error: cannot borrow `v` as mutable because it is also borrowed as immutable </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7 v.push(5-*x); </span></span><br><span class="hljs-comment"><span class="hljs-comment"> ^ </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:5:14: 5:15 note: previous borrow of `v` occurs here; the immutable borrow prevents subsequent moves or mutable borrows of `v` until the borrow ends </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:5 for x in v.iter() { </span></span><br><span class="hljs-comment"><span class="hljs-comment"> ^ </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:10:2: 10:2 note: previous borrow ends here </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:5 for x in v.iter() { </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:6 if *x &lt; 5 { </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7 v.push(5-*x); </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:8 } </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:9 } </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:10 } </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  Switch </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="cpp"><span class="hljs-comment"><span class="hljs-comment">#include &lt;stdio.h&gt; enum {RED, BLUE, GRAY, UNKNOWN} color = GRAY; int main() { int x; switch(color) { case GRAY: x=1; case RED: case BLUE: x=2; } printf("%d", x); }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">   "2".  Rust          .  ,       ,    </span></span><code><span class="hljs-comment"><span class="hljs-comment">break</span></span></code><span class="hljs-comment"><span class="hljs-comment"> .    Rust   : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="rust"><span class="hljs-comment"><span class="hljs-comment">enum Color {RED, BLUE, GRAY, UNKNOWN} fn main() { let color = GRAY; let x = match color { GRAY =&gt; 1, RED | BLUE =&gt; 2, _ =&gt; 3, }; println!("{}", x); }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">     </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="cpp"><span class="hljs-comment"><span class="hljs-comment">int main() { int pixels = 1; for (int j=0; j&lt;5; j++); pixels++; }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  Rust          . , ,     . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="cpp"><span class="hljs-comment"><span class="hljs-comment">#include &lt;stdio.h&gt; #include &lt;pthread.h&gt; #include &lt;unistd.h&gt; class Resource { int *value; public: Resource(): value(NULL) {} ~Resource() {delete value;} int *acquire() { if (!value) { value = new int(0); } return value; } }; void* function(void *param) { int *value = ((Resource*)param)-&gt;acquire(); printf("resource: %p\n", (void*)value); return value; } int main() { Resource res; for (int i=0; i&lt;5; ++i) { pthread_t pt; pthread_create(&amp;pt, NULL, function, &amp;res); } //sleep(10); printf("done\n"); }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">     : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> done </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7f229c0008c0 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7f22840008c0 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7f228c0008c0 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7f22940008c0 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7f227c0008c0 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">     ,        .      Rust: </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="rust"><span class="hljs-comment"><span class="hljs-comment">struct Resource { value: Option&lt;int&gt;, } impl Resource { pub fn new() -&gt; Resource { Resource{ value: None } } pub fn acquire&lt;'a&gt;(&amp;'a mut self) -&gt; &amp;'a int { if self.value.is_none() { self.value = Some(1); } self.value.get_ref() } } fn main() { let mut res = Resource::new(); for _ in range(0,5) { spawn(proc() { let ptr = res.acquire(); println!("resource {}", ptr) }) } }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  ,            . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:20:23: 20:26 error: cannot borrow immutable captured outer variable in a proc `res` as mutable </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:20 let ptr = res.acquire(); </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">      ,   : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="rust"><span class="hljs-comment"><span class="hljs-comment">extern crate sync; use sync::{Arc, RWLock}; struct Resource { value: Option&lt;Box&lt;int&gt;&gt;, } impl Resource { pub fn new() -&gt; Resource { Resource{ value: None } } pub fn acquire(&amp;mut self) -&gt; *int { if self.value.is_none() { self.value = Some(box 1) } &amp;**self.value.get_ref() as *int } } fn main() { let arc_res = Arc::new(RWLock::new(Resource::new())); for _ in range(0,5) { let child_res = arc_res.clone(); spawn(proc() { let ptr = child_res.write().acquire(); println!("resource: {}", ptr) }) } }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">     </span></span><code><span class="hljs-comment"><span class="hljs-comment">Arc</span></span></code><span class="hljs-comment"><span class="hljs-comment"> ( </span></span><i><span class="hljs-comment"><span class="hljs-comment">Atomically Reference Counted</span></span></i><span class="hljs-comment"><span class="hljs-comment"> -        )  </span></span><code><span class="hljs-comment"><span class="hljs-comment">RWLock</span></span></code><span class="hljs-comment"><span class="hljs-comment"> (   ).   : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7ff4b0010378 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7ff4b0010378 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7ff4b0010378 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7ff4b0010378 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7ff4b0010378 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  ,   ++    .    . Rust        ,    .  ,   ,   .           ,       ( </span></span><a href="http://superwebdeveloper.com/2009/11/25/the-incredible-rate-of-diminishing-returns-of-fixing-software-bugs/"><span class="hljs-comment"><span class="hljs-comment">  </span></span></a><span class="hljs-comment"><span class="hljs-comment"> ). </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">     </span></span><br><span class="hljs-comment"><span class="hljs-comment"> Rust        ,     </span></span><code><span class="hljs-comment"><span class="hljs-comment">unsafe{}</span></span></code><span class="hljs-comment"><span class="hljs-comment"> .   ,     " </span></span><i><span class="hljs-comment"><span class="hljs-comment"> !  ,  .</span></span></i><span class="hljs-comment"><span class="hljs-comment"> ".  ,  ""  (    ,    )    .    ,           ( )  . , ,        </span></span><code><span class="hljs-comment"><span class="hljs-comment">Cell</span></span></code><span class="hljs-comment"><span class="hljs-comment">  </span></span><code><span class="hljs-comment"><span class="hljs-comment">Mutex</span></span></code><span class="hljs-comment"><span class="hljs-comment"> .             ,       (   </span></span><a href="http://en.wikipedia.org/wiki/Test-driven_development"><span class="hljs-comment"><span class="hljs-comment">TDD</span></span></a><span class="hljs-comment"><span class="hljs-comment"> !). </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="https://air.mozilla.org/guaranteeing-memory-safety-in-rust/"><span class="hljs-comment"><span class="hljs-comment">Guaranteeing Memory Safety in Rust (by Niko Matsakis)</span></span></a><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="http://www.techtalkshub.com/rust-safe-systems-programming-fun-fp/"><span class="hljs-comment"><span class="hljs-comment">Rust: Safe Systems Programming with the Fun of FP (by Felix Klock II)</span></span></a><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Keynote"><span class="hljs-comment"><span class="hljs-comment">Lang-NEXT: What ‚Äì if anything ‚Äì have we learned from C++? (by Bjarne Stroustrup)</span></span></a><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Panel-Systems-Programming-Languages-in-2014-and-Beyond"><span class="hljs-comment"><span class="hljs-comment">Lang-NEXT Panel: Systems Programming in 2014 and Beyond</span></span></a></code></code> </pre> <code><code><code><code class="cpp">Box)     ,       (     ).        (std::rc::Rc)    (std::gc::Gc),      (   ). <br> <br></code>      <br>  ++: <br> #include &lt;stdio.h&gt; int *bar(int *p) { return p; } int* foo(int n) { return bar(&amp;n); } int main() { int *p1 = foo(1); int *p2 = foo(2); printf("%d, %d\n", *p1, *p2); }</code> <br>  : <br> 2, 2 <br> <br>  Rust: <br> <code class="rust">fn bar&lt;'a&gt;(p: &amp;'a int) -&gt; &amp;'a int { return p; } fn foo(n: int) -&gt; &amp;int { bar(&amp;n) } fn main() { let p1 = foo(1); let p2 = foo(2); println!("{}, {}", *p1, *p2); }</code> <br>  : <br> demo:5:10: 5:11 error: `n` does not live long enough <br> demo:5 bar(&amp;n) <br> ^ <br> demo:4:24: 6:2 note: reference must be valid for the anonymous lifetime #1 defined on the block at 4:23... <br> demo:4 fn foo(n: int) -&gt; &amp;int { <br> demo:5 bar(&amp;n) <br> demo:6 } <br> demo:4:24: 6:2 note: ...but borrowed value is only valid for the block at 4:23 <br> demo:4 fn foo(n: int) -&gt; &amp;int { <br> demo:5 bar(&amp;n) <br> demo:6 } <br> <br>   <br> <code class="cpp">#include &lt;stdio.h&gt; int minval(int *A, int n) { int currmin; for (int i=0; i&lt;n; i++) if (A[i] &lt; currmin) currmin = A[i]; return currmin; } int main() { int A[] = {1,2,3}; int min = minval(A,3); printf("%d\n", min); }</code> <br>   0  ,     , ,  .       Rust ( - ): <br> <code class="rust">fn minval(A: &amp;[int]) -&gt; int { let mut currmin; for a in A.iter() { if *a &lt; currmin { currmin = *a; } } currmin } fn main() { let A = [1i,2i,3i]; let min = minval(A.as_slice()); println!("{}", min); }</code> <br>  , : use of possibly uninitialized variable: `currmin` <br>   ( )      : <br> <code class="rust">fn minval(A: &amp;[int]) -&gt; int { A.iter().fold(A[0], |u,&amp;a| { if a&lt;u {a} else {u} }) }</code> <br> <br>    <br> <code class="cpp">struct A{ int *x; A(int v): x(new int(v)) {} ~A() {delete x;} }; int main() { A a(1), b=a; }</code> <br> ,    : <br> *** glibc detected *** demo: double free or corruption (fasttop): 0x0000000000601010 *** <br> <br>     Rust: <br> <code class="rust">struct A{ x: Box&lt;int&gt; } impl A { pub fn new(v: int) -&gt; A { A{ x: box v } } } impl Drop for A { fn drop(&amp;mut self) {} // ,     ++ } fn main() { let a = A::new(1); let _b = a; }</code> <br>     .   ,     <code>trait Copy</code> . <br> Rust       .    <code>Eq</code>  <code>Clone</code> ?    <code>deriving</code>   : <br> <code class="rust">#[deriving(Clone, Eq, Hash, PartialEq, PartialOrd, Ord, Show)] struct A{ x: Box&lt;int&gt; }</code> <br> <br>    <br> <code class="cpp">#include &lt;stdio.h&gt; struct X { int a, b; }; void swap_from(X&amp; x, const X&amp; y) { xa = yb; xb = ya; } int main() { X x = {1,2}; swap_from(x,x); printf("%d,%d\n", xa, xb); }</code> <br>  : <br> 2,2 <br>    ,    cc      .   ,   ,  99  <a href="http://en.wikipedia.org/wiki/Restrict">restrict</a> ,            :        . <br> <br>       Rust: <br> <code class="rust">struct X { pub a: int, pub b: int } fn swap_from(x: &amp;mut X, y: &amp;X) { xa = yb; xb = ya; } fn main() { let mut x = X{a:1, b:2}; swap_from(&amp;mut x, &amp;x); }</code> <br>    : <br> demo:7:24: 7:25 error: cannot borrow `x` as immutable because it is also borrowed as mutable <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> ^ <br> demo:7:20: 7:21 note: previous borrow of `x` occurs here; the mutable borrow prevents subsequent moves, borrows, or modification of `x` until the borrow ends <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> ^ <br> demo:7:26: 7:26 note: previous borrow ends here <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> <br>  ,             " <code>&amp;mut</code> "  " <code>&amp;</code> " ,   ,          ,   <code>&amp;mut</code> .            .  ,    ,      C99  <code>restrict</code>  (Rust  LLVM    ),    . <br> <br>   <br> <code class="cpp">#include &lt;vector&gt; int main() { std::vector&lt;int&gt; v; v.push_back(1); v.push_back(2); for(std::vector&lt;int&gt;::const_iterator it=v.begin(); it!=v.end(); ++it) { if (*it &lt; 5) v.push_back(5-*it); } }</code> <br>    ,    : <br> Segmentation fault (core dumped) <br> <br>    Rust: <br> <code class="rust">fn main() { let mut v: Vec&lt;int&gt; = Vec::new(); v.push(1); v.push(2); for x in v.iter() { if *x &lt; 5 { v.push(5-*x); } } }</code> <br>      ,  ,        : <br> demo:7:13: 7:14 error: cannot borrow `v` as mutable because it is also borrowed as immutable <br> demo:7 v.push(5-*x); <br> ^ <br> demo:5:14: 5:15 note: previous borrow of `v` occurs here; the immutable borrow prevents subsequent moves or mutable borrows of `v` until the borrow ends <br> demo:5 for x in v.iter() { <br> ^ <br> demo:10:2: 10:2 note: previous borrow ends here <br> demo:5 for x in v.iter() { <br> demo:6 if *x &lt; 5 { <br> demo:7 v.push(5-*x); <br> demo:8 } <br> demo:9 } <br> demo:10 } <br> <br> <br>  Switch <br> <code class="cpp">#include &lt;stdio.h&gt; enum {RED, BLUE, GRAY, UNKNOWN} color = GRAY; int main() { int x; switch(color) { case GRAY: x=1; case RED: case BLUE: x=2; } printf("%d", x); }</code> <br>   "2".  Rust          .  ,       ,    <code>break</code> .    Rust   : <br> <code class="rust">enum Color {RED, BLUE, GRAY, UNKNOWN} fn main() { let color = GRAY; let x = match color { GRAY =&gt; 1, RED | BLUE =&gt; 2, _ =&gt; 3, }; println!("{}", x); }</code> <br> <br>     <br> <code class="cpp">int main() { int pixels = 1; for (int j=0; j&lt;5; j++); pixels++; }</code> <br>  Rust          . , ,     . <br> <br>  <br> <code class="cpp">#include &lt;stdio.h&gt; #include &lt;pthread.h&gt; #include &lt;unistd.h&gt; class Resource { int *value; public: Resource(): value(NULL) {} ~Resource() {delete value;} int *acquire() { if (!value) { value = new int(0); } return value; } }; void* function(void *param) { int *value = ((Resource*)param)-&gt;acquire(); printf("resource: %p\n", (void*)value); return value; } int main() { Resource res; for (int i=0; i&lt;5; ++i) { pthread_t pt; pthread_create(&amp;pt, NULL, function, &amp;res); } //sleep(10); printf("done\n"); }</code> <br>     : <br> done <br> resource: 0x7f229c0008c0 <br> resource: 0x7f22840008c0 <br> resource: 0x7f228c0008c0 <br> resource: 0x7f22940008c0 <br> resource: 0x7f227c0008c0 <br> <br>     ,        .      Rust: <br> <code class="rust">struct Resource { value: Option&lt;int&gt;, } impl Resource { pub fn new() -&gt; Resource { Resource{ value: None } } pub fn acquire&lt;'a&gt;(&amp;'a mut self) -&gt; &amp;'a int { if self.value.is_none() { self.value = Some(1); } self.value.get_ref() } } fn main() { let mut res = Resource::new(); for _ in range(0,5) { spawn(proc() { let ptr = res.acquire(); println!("resource {}", ptr) }) } }</code> <br>  ,            . <br> demo:20:23: 20:26 error: cannot borrow immutable captured outer variable in a proc `res` as mutable <br> demo:20 let ptr = res.acquire(); <br> <br>      ,   : <br> <code class="rust">extern crate sync; use sync::{Arc, RWLock}; struct Resource { value: Option&lt;Box&lt;int&gt;&gt;, } impl Resource { pub fn new() -&gt; Resource { Resource{ value: None } } pub fn acquire(&amp;mut self) -&gt; *int { if self.value.is_none() { self.value = Some(box 1) } &amp;**self.value.get_ref() as *int } } fn main() { let arc_res = Arc::new(RWLock::new(Resource::new())); for _ in range(0,5) { let child_res = arc_res.clone(); spawn(proc() { let ptr = child_res.write().acquire(); println!("resource: {}", ptr) }) } }</code> <br>     <code>Arc</code> ( <i>Atomically Reference Counted</i> -        )  <code>RWLock</code> (   ).   : <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> <br>  ,   ++    .    . Rust        ,    .  ,   ,   .           ,       ( <a href="http://superwebdeveloper.com/2009/11/25/the-incredible-rate-of-diminishing-returns-of-fixing-software-bugs/">  </a> ). <br> <br>     <br> Rust        ,     <code>unsafe{}</code> .   ,     " <i> !  ,  .</i> ".  ,  ""  (    ,    )    .    ,           ( )  . , ,        <code>Cell</code>  <code>Mutex</code> .             ,       (   <a href="http://en.wikipedia.org/wiki/Test-driven_development">TDD</a> !). <br> <br>  <br> <a href="https://air.mozilla.org/guaranteeing-memory-safety-in-rust/">Guaranteeing Memory Safety in Rust (by Niko Matsakis)</a> <br> <a href="http://www.techtalkshub.com/rust-safe-systems-programming-fun-fp/">Rust: Safe Systems Programming with the Fun of FP (by Felix Klock II)</a> <br> <a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Keynote">Lang-NEXT: What ‚Äì if anything ‚Äì have we learned from C++? (by Bjarne Stroustrup)</a> <br> <a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Panel-Systems-Programming-Languages-in-2014-and-Beyond">Lang-NEXT Panel: Systems Programming in 2014 and Beyond</a></code></code> <blockquote> <code><code><code><code class="cpp">Box)     ,       (     ).        (std::rc::Rc)    (std::gc::Gc),      (   ). <br> <br></code>      <br>  ++: <br> #include &lt;stdio.h&gt; int *bar(int *p) { return p; } int* foo(int n) { return bar(&amp;n); } int main() { int *p1 = foo(1); int *p2 = foo(2); printf("%d, %d\n", *p1, *p2); }</code> <br>  : <br> 2, 2 <br> <br>  Rust: <br> <code class="rust">fn bar&lt;'a&gt;(p: &amp;'a int) -&gt; &amp;'a int { return p; } fn foo(n: int) -&gt; &amp;int { bar(&amp;n) } fn main() { let p1 = foo(1); let p2 = foo(2); println!("{}, {}", *p1, *p2); }</code> <br>  : <br> demo:5:10: 5:11 error: `n` does not live long enough <br> demo:5 bar(&amp;n) <br> ^ <br> demo:4:24: 6:2 note: reference must be valid for the anonymous lifetime #1 defined on the block at 4:23... <br> demo:4 fn foo(n: int) -&gt; &amp;int { <br> demo:5 bar(&amp;n) <br> demo:6 } <br> demo:4:24: 6:2 note: ...but borrowed value is only valid for the block at 4:23 <br> demo:4 fn foo(n: int) -&gt; &amp;int { <br> demo:5 bar(&amp;n) <br> demo:6 } <br> <br>   <br> <code class="cpp">#include &lt;stdio.h&gt; int minval(int *A, int n) { int currmin; for (int i=0; i&lt;n; i++) if (A[i] &lt; currmin) currmin = A[i]; return currmin; } int main() { int A[] = {1,2,3}; int min = minval(A,3); printf("%d\n", min); }</code> <br>   0  ,     , ,  .       Rust ( - ): <br> <code class="rust">fn minval(A: &amp;[int]) -&gt; int { let mut currmin; for a in A.iter() { if *a &lt; currmin { currmin = *a; } } currmin } fn main() { let A = [1i,2i,3i]; let min = minval(A.as_slice()); println!("{}", min); }</code> <br>  , : use of possibly uninitialized variable: `currmin` <br>   ( )      : <br> <code class="rust">fn minval(A: &amp;[int]) -&gt; int { A.iter().fold(A[0], |u,&amp;a| { if a&lt;u {a} else {u} }) }</code> <br> <br>    <br> <code class="cpp">struct A{ int *x; A(int v): x(new int(v)) {} ~A() {delete x;} }; int main() { A a(1), b=a; }</code> <br> ,    : <br> *** glibc detected *** demo: double free or corruption (fasttop): 0x0000000000601010 *** <br> <br>     Rust: <br> <code class="rust">struct A{ x: Box&lt;int&gt; } impl A { pub fn new(v: int) -&gt; A { A{ x: box v } } } impl Drop for A { fn drop(&amp;mut self) {} // ,     ++ } fn main() { let a = A::new(1); let _b = a; }</code> <br>     .   ,     <code>trait Copy</code> . <br> Rust       .    <code>Eq</code>  <code>Clone</code> ?    <code>deriving</code>   : <br> <code class="rust">#[deriving(Clone, Eq, Hash, PartialEq, PartialOrd, Ord, Show)] struct A{ x: Box&lt;int&gt; }</code> <br> <br>    <br> <code class="cpp">#include &lt;stdio.h&gt; struct X { int a, b; }; void swap_from(X&amp; x, const X&amp; y) { xa = yb; xb = ya; } int main() { X x = {1,2}; swap_from(x,x); printf("%d,%d\n", xa, xb); }</code> <br>  : <br> 2,2 <br>    ,    cc      .   ,   ,  99  <a href="http://en.wikipedia.org/wiki/Restrict">restrict</a> ,            :        . <br> <br>       Rust: <br> <code class="rust">struct X { pub a: int, pub b: int } fn swap_from(x: &amp;mut X, y: &amp;X) { xa = yb; xb = ya; } fn main() { let mut x = X{a:1, b:2}; swap_from(&amp;mut x, &amp;x); }</code> <br>    : <br> demo:7:24: 7:25 error: cannot borrow `x` as immutable because it is also borrowed as mutable <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> ^ <br> demo:7:20: 7:21 note: previous borrow of `x` occurs here; the mutable borrow prevents subsequent moves, borrows, or modification of `x` until the borrow ends <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> ^ <br> demo:7:26: 7:26 note: previous borrow ends here <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> <br>  ,             " <code>&amp;mut</code> "  " <code>&amp;</code> " ,   ,          ,   <code>&amp;mut</code> .            .  ,    ,      C99  <code>restrict</code>  (Rust  LLVM    ),    . <br> <br>   <br> <code class="cpp">#include &lt;vector&gt; int main() { std::vector&lt;int&gt; v; v.push_back(1); v.push_back(2); for(std::vector&lt;int&gt;::const_iterator it=v.begin(); it!=v.end(); ++it) { if (*it &lt; 5) v.push_back(5-*it); } }</code> <br>    ,    : <br> Segmentation fault (core dumped) <br> <br>    Rust: <br> <code class="rust">fn main() { let mut v: Vec&lt;int&gt; = Vec::new(); v.push(1); v.push(2); for x in v.iter() { if *x &lt; 5 { v.push(5-*x); } } }</code> <br>      ,  ,        : <br> demo:7:13: 7:14 error: cannot borrow `v` as mutable because it is also borrowed as immutable <br> demo:7 v.push(5-*x); <br> ^ <br> demo:5:14: 5:15 note: previous borrow of `v` occurs here; the immutable borrow prevents subsequent moves or mutable borrows of `v` until the borrow ends <br> demo:5 for x in v.iter() { <br> ^ <br> demo:10:2: 10:2 note: previous borrow ends here <br> demo:5 for x in v.iter() { <br> demo:6 if *x &lt; 5 { <br> demo:7 v.push(5-*x); <br> demo:8 } <br> demo:9 } <br> demo:10 } <br> <br> <br>  Switch <br> <code class="cpp">#include &lt;stdio.h&gt; enum {RED, BLUE, GRAY, UNKNOWN} color = GRAY; int main() { int x; switch(color) { case GRAY: x=1; case RED: case BLUE: x=2; } printf("%d", x); }</code> <br>   "2".  Rust          .  ,       ,    <code>break</code> .    Rust   : <br> <code class="rust">enum Color {RED, BLUE, GRAY, UNKNOWN} fn main() { let color = GRAY; let x = match color { GRAY =&gt; 1, RED | BLUE =&gt; 2, _ =&gt; 3, }; println!("{}", x); }</code> <br> <br>     <br> <code class="cpp">int main() { int pixels = 1; for (int j=0; j&lt;5; j++); pixels++; }</code> <br>  Rust          . , ,     . <br> <br>  <br> <code class="cpp">#include &lt;stdio.h&gt; #include &lt;pthread.h&gt; #include &lt;unistd.h&gt; class Resource { int *value; public: Resource(): value(NULL) {} ~Resource() {delete value;} int *acquire() { if (!value) { value = new int(0); } return value; } }; void* function(void *param) { int *value = ((Resource*)param)-&gt;acquire(); printf("resource: %p\n", (void*)value); return value; } int main() { Resource res; for (int i=0; i&lt;5; ++i) { pthread_t pt; pthread_create(&amp;pt, NULL, function, &amp;res); } //sleep(10); printf("done\n"); }</code> <br>     : <br> done <br> resource: 0x7f229c0008c0 <br> resource: 0x7f22840008c0 <br> resource: 0x7f228c0008c0 <br> resource: 0x7f22940008c0 <br> resource: 0x7f227c0008c0 <br> <br>     ,        .      Rust: <br> <code class="rust">struct Resource { value: Option&lt;int&gt;, } impl Resource { pub fn new() -&gt; Resource { Resource{ value: None } } pub fn acquire&lt;'a&gt;(&amp;'a mut self) -&gt; &amp;'a int { if self.value.is_none() { self.value = Some(1); } self.value.get_ref() } } fn main() { let mut res = Resource::new(); for _ in range(0,5) { spawn(proc() { let ptr = res.acquire(); println!("resource {}", ptr) }) } }</code> <br>  ,            . <br> demo:20:23: 20:26 error: cannot borrow immutable captured outer variable in a proc `res` as mutable <br> demo:20 let ptr = res.acquire(); <br> <br>      ,   : <br> <code class="rust">extern crate sync; use sync::{Arc, RWLock}; struct Resource { value: Option&lt;Box&lt;int&gt;&gt;, } impl Resource { pub fn new() -&gt; Resource { Resource{ value: None } } pub fn acquire(&amp;mut self) -&gt; *int { if self.value.is_none() { self.value = Some(box 1) } &amp;**self.value.get_ref() as *int } } fn main() { let arc_res = Arc::new(RWLock::new(Resource::new())); for _ in range(0,5) { let child_res = arc_res.clone(); spawn(proc() { let ptr = child_res.write().acquire(); println!("resource: {}", ptr) }) } }</code> <br>     <code>Arc</code> ( <i>Atomically Reference Counted</i> -        )  <code>RWLock</code> (   ).   : <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> <br>  ,   ++    .    . Rust        ,    .  ,   ,   .           ,       ( <a href="http://superwebdeveloper.com/2009/11/25/the-incredible-rate-of-diminishing-returns-of-fixing-software-bugs/">  </a> ). <br> <br>     <br> Rust        ,     <code>unsafe{}</code> .   ,     " <i> !  ,  .</i> ".  ,  ""  (    ,    )    .    ,           ( )  . , ,        <code>Cell</code>  <code>Mutex</code> .             ,       (   <a href="http://en.wikipedia.org/wiki/Test-driven_development">TDD</a> !). <br> <br>  <br> <a href="https://air.mozilla.org/guaranteeing-memory-safety-in-rust/">Guaranteeing Memory Safety in Rust (by Niko Matsakis)</a> <br> <a href="http://www.techtalkshub.com/rust-safe-systems-programming-fun-fp/">Rust: Safe Systems Programming with the Fun of FP (by Felix Klock II)</a> <br> <a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Keynote">Lang-NEXT: What ‚Äì if anything ‚Äì have we learned from C++? (by Bjarne Stroustrup)</a> <br> <a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Panel-Systems-Programming-Languages-in-2014-and-Beyond">Lang-NEXT Panel: Systems Programming in 2014 and Beyond</a></code></code> </blockquote> <code><code><code><code class="cpp">Box)     ,       (     ).        (std::rc::Rc)    (std::gc::Gc),      (   ). <br> <br></code>      <br>  ++: <br> #include &lt;stdio.h&gt; int *bar(int *p) { return p; } int* foo(int n) { return bar(&amp;n); } int main() { int *p1 = foo(1); int *p2 = foo(2); printf("%d, %d\n", *p1, *p2); }</code> <br>  : <br> 2, 2 <br> <br>  Rust: <br> <code class="rust">fn bar&lt;'a&gt;(p: &amp;'a int) -&gt; &amp;'a int { return p; } fn foo(n: int) -&gt; &amp;int { bar(&amp;n) } fn main() { let p1 = foo(1); let p2 = foo(2); println!("{}, {}", *p1, *p2); }</code> <br>  : <br> demo:5:10: 5:11 error: `n` does not live long enough <br> demo:5 bar(&amp;n) <br> ^ <br> demo:4:24: 6:2 note: reference must be valid for the anonymous lifetime #1 defined on the block at 4:23... <br> demo:4 fn foo(n: int) -&gt; &amp;int { <br> demo:5 bar(&amp;n) <br> demo:6 } <br> demo:4:24: 6:2 note: ...but borrowed value is only valid for the block at 4:23 <br> demo:4 fn foo(n: int) -&gt; &amp;int { <br> demo:5 bar(&amp;n) <br> demo:6 } <br> <br>   <br> <code class="cpp">#include &lt;stdio.h&gt; int minval(int *A, int n) { int currmin; for (int i=0; i&lt;n; i++) if (A[i] &lt; currmin) currmin = A[i]; return currmin; } int main() { int A[] = {1,2,3}; int min = minval(A,3); printf("%d\n", min); }</code> <br>   0  ,     , ,  .       Rust ( - ): <br> <code class="rust">fn minval(A: &amp;[int]) -&gt; int { let mut currmin; for a in A.iter() { if *a &lt; currmin { currmin = *a; } } currmin } fn main() { let A = [1i,2i,3i]; let min = minval(A.as_slice()); println!("{}", min); }</code> <br>  , : use of possibly uninitialized variable: `currmin` <br>   ( )      : <br> <code class="rust">fn minval(A: &amp;[int]) -&gt; int { A.iter().fold(A[0], |u,&amp;a| { if a&lt;u {a} else {u} }) }</code> <br> <br>    <br> <code class="cpp">struct A{ int *x; A(int v): x(new int(v)) {} ~A() {delete x;} }; int main() { A a(1), b=a; }</code> <br> ,    : <br> *** glibc detected *** demo: double free or corruption (fasttop): 0x0000000000601010 *** <br> <br>     Rust: <br> <code class="rust">struct A{ x: Box&lt;int&gt; } impl A { pub fn new(v: int) -&gt; A { A{ x: box v } } } impl Drop for A { fn drop(&amp;mut self) {} // ,     ++ } fn main() { let a = A::new(1); let _b = a; }</code> <br>     .   ,     <code>trait Copy</code> . <br> Rust       .    <code>Eq</code>  <code>Clone</code> ?    <code>deriving</code>   : <br> <code class="rust">#[deriving(Clone, Eq, Hash, PartialEq, PartialOrd, Ord, Show)] struct A{ x: Box&lt;int&gt; }</code> <br> <br>    <br> <code class="cpp">#include &lt;stdio.h&gt; struct X { int a, b; }; void swap_from(X&amp; x, const X&amp; y) { xa = yb; xb = ya; } int main() { X x = {1,2}; swap_from(x,x); printf("%d,%d\n", xa, xb); }</code> <br>  : <br> 2,2 <br>    ,    cc      .   ,   ,  99  <a href="http://en.wikipedia.org/wiki/Restrict">restrict</a> ,            :        . <br> <br>       Rust: <br> <code class="rust">struct X { pub a: int, pub b: int } fn swap_from(x: &amp;mut X, y: &amp;X) { xa = yb; xb = ya; } fn main() { let mut x = X{a:1, b:2}; swap_from(&amp;mut x, &amp;x); }</code> <br>    : <br> demo:7:24: 7:25 error: cannot borrow `x` as immutable because it is also borrowed as mutable <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> ^ <br> demo:7:20: 7:21 note: previous borrow of `x` occurs here; the mutable borrow prevents subsequent moves, borrows, or modification of `x` until the borrow ends <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> ^ <br> demo:7:26: 7:26 note: previous borrow ends here <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> <br>  ,             " <code>&amp;mut</code> "  " <code>&amp;</code> " ,   ,          ,   <code>&amp;mut</code> .            .  ,    ,      C99  <code>restrict</code>  (Rust  LLVM    ),    . <br> <br>   <br> <code class="cpp">#include &lt;vector&gt; int main() { std::vector&lt;int&gt; v; v.push_back(1); v.push_back(2); for(std::vector&lt;int&gt;::const_iterator it=v.begin(); it!=v.end(); ++it) { if (*it &lt; 5) v.push_back(5-*it); } }</code> <br>    ,    : <br> Segmentation fault (core dumped) <br> <br>    Rust: <br> <code class="rust">fn main() { let mut v: Vec&lt;int&gt; = Vec::new(); v.push(1); v.push(2); for x in v.iter() { if *x &lt; 5 { v.push(5-*x); } } }</code> <br>      ,  ,        : <br> demo:7:13: 7:14 error: cannot borrow `v` as mutable because it is also borrowed as immutable <br> demo:7 v.push(5-*x); <br> ^ <br> demo:5:14: 5:15 note: previous borrow of `v` occurs here; the immutable borrow prevents subsequent moves or mutable borrows of `v` until the borrow ends <br> demo:5 for x in v.iter() { <br> ^ <br> demo:10:2: 10:2 note: previous borrow ends here <br> demo:5 for x in v.iter() { <br> demo:6 if *x &lt; 5 { <br> demo:7 v.push(5-*x); <br> demo:8 } <br> demo:9 } <br> demo:10 } <br> <br> <br>  Switch <br> <code class="cpp">#include &lt;stdio.h&gt; enum {RED, BLUE, GRAY, UNKNOWN} color = GRAY; int main() { int x; switch(color) { case GRAY: x=1; case RED: case BLUE: x=2; } printf("%d", x); }</code> <br>   "2".  Rust          .  ,       ,    <code>break</code> .    Rust   : <br> <code class="rust">enum Color {RED, BLUE, GRAY, UNKNOWN} fn main() { let color = GRAY; let x = match color { GRAY =&gt; 1, RED | BLUE =&gt; 2, _ =&gt; 3, }; println!("{}", x); }</code> <br> <br>     <br> <code class="cpp">int main() { int pixels = 1; for (int j=0; j&lt;5; j++); pixels++; }</code> <br>  Rust          . , ,     . <br> <br>  <br> <code class="cpp">#include &lt;stdio.h&gt; #include &lt;pthread.h&gt; #include &lt;unistd.h&gt; class Resource { int *value; public: Resource(): value(NULL) {} ~Resource() {delete value;} int *acquire() { if (!value) { value = new int(0); } return value; } }; void* function(void *param) { int *value = ((Resource*)param)-&gt;acquire(); printf("resource: %p\n", (void*)value); return value; } int main() { Resource res; for (int i=0; i&lt;5; ++i) { pthread_t pt; pthread_create(&amp;pt, NULL, function, &amp;res); } //sleep(10); printf("done\n"); }</code> <br>     : <br> done <br> resource: 0x7f229c0008c0 <br> resource: 0x7f22840008c0 <br> resource: 0x7f228c0008c0 <br> resource: 0x7f22940008c0 <br> resource: 0x7f227c0008c0 <br> <br>     ,        .      Rust: <br> <code class="rust">struct Resource { value: Option&lt;int&gt;, } impl Resource { pub fn new() -&gt; Resource { Resource{ value: None } } pub fn acquire&lt;'a&gt;(&amp;'a mut self) -&gt; &amp;'a int { if self.value.is_none() { self.value = Some(1); } self.value.get_ref() } } fn main() { let mut res = Resource::new(); for _ in range(0,5) { spawn(proc() { let ptr = res.acquire(); println!("resource {}", ptr) }) } }</code> <br>  ,            . <br> demo:20:23: 20:26 error: cannot borrow immutable captured outer variable in a proc `res` as mutable <br> demo:20 let ptr = res.acquire(); <br> <br>      ,   : <br> <code class="rust">extern crate sync; use sync::{Arc, RWLock}; struct Resource { value: Option&lt;Box&lt;int&gt;&gt;, } impl Resource { pub fn new() -&gt; Resource { Resource{ value: None } } pub fn acquire(&amp;mut self) -&gt; *int { if self.value.is_none() { self.value = Some(box 1) } &amp;**self.value.get_ref() as *int } } fn main() { let arc_res = Arc::new(RWLock::new(Resource::new())); for _ in range(0,5) { let child_res = arc_res.clone(); spawn(proc() { let ptr = child_res.write().acquire(); println!("resource: {}", ptr) }) } }</code> <br>     <code>Arc</code> ( <i>Atomically Reference Counted</i> -        )  <code>RWLock</code> (   ).   : <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> <br>  ,   ++    .    . Rust        ,    .  ,   ,   .           ,       ( <a href="http://superwebdeveloper.com/2009/11/25/the-incredible-rate-of-diminishing-returns-of-fixing-software-bugs/">  </a> ). <br> <br>     <br> Rust        ,     <code>unsafe{}</code> .   ,     " <i> !  ,  .</i> ".  ,  ""  (    ,    )    .    ,           ( )  . , ,        <code>Cell</code>  <code>Mutex</code> .             ,       (   <a href="http://en.wikipedia.org/wiki/Test-driven_development">TDD</a> !). <br> <br>  <br> <a href="https://air.mozilla.org/guaranteeing-memory-safety-in-rust/">Guaranteeing Memory Safety in Rust (by Niko Matsakis)</a> <br> <a href="http://www.techtalkshub.com/rust-safe-systems-programming-fun-fp/">Rust: Safe Systems Programming with the Fun of FP (by Felix Klock II)</a> <br> <a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Keynote">Lang-NEXT: What ‚Äì if anything ‚Äì have we learned from C++? (by Bjarne Stroustrup)</a> <br> <a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Panel-Systems-Programming-Languages-in-2014-and-Beyond">Lang-NEXT Panel: Systems Programming in 2014 and Beyond</a></code></code> <pre> <code class="hljs rust"><code><code><code class="cpp"><span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>)     ,       (     ).        (std::rc::Rc)    (std::gc::Gc),      (   ). <br> <br></code>      <br>  ++: <br> #include &lt;stdio.h&gt; int *bar(int *p) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p; } int* foo(int n) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bar(&amp;n); } int main() { int *p1 = foo(<span class="hljs-number"><span class="hljs-number">1</span></span>); int *p2 = foo(<span class="hljs-number"><span class="hljs-number">2</span></span>); printf(<span class="hljs-string"><span class="hljs-string">"%d, %d\n"</span></span>, *p1, *p2); }</code> <br>  : <br> <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span> <br> <br>  Rust: <br> <code class="rust"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt;(p: &amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> int) -&gt; &amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> int { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>(n: int) -&gt; &amp;int { bar(&amp;n) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> p1 = foo(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> p2 = foo(<span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{}, {}"</span></span>, *p1, *p2); }</code> <br>  : <br> demo:<span class="hljs-number"><span class="hljs-number">5</span></span>:<span class="hljs-number"><span class="hljs-number">10</span></span>: <span class="hljs-number"><span class="hljs-number">5</span></span>:<span class="hljs-number"><span class="hljs-number">11</span></span> error: `n` does not live long enough <br> demo:<span class="hljs-number"><span class="hljs-number">5</span></span> bar(&amp;n) <br> ^ <br> demo:<span class="hljs-number"><span class="hljs-number">4</span></span>:<span class="hljs-number"><span class="hljs-number">24</span></span>: <span class="hljs-number"><span class="hljs-number">6</span></span>:<span class="hljs-number"><span class="hljs-number">2</span></span> note: reference must <span class="hljs-keyword"><span class="hljs-keyword">be</span></span> valid <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> the anonymous lifetime #<span class="hljs-number"><span class="hljs-number">1</span></span> defined on the block at <span class="hljs-number"><span class="hljs-number">4</span></span>:<span class="hljs-number"><span class="hljs-number">23</span></span>... <br> demo:<span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>(n: int) -&gt; &amp;int { <br> demo:<span class="hljs-number"><span class="hljs-number">5</span></span> bar(&amp;n) <br> demo:<span class="hljs-number"><span class="hljs-number">6</span></span> } <br> demo:<span class="hljs-number"><span class="hljs-number">4</span></span>:<span class="hljs-number"><span class="hljs-number">24</span></span>: <span class="hljs-number"><span class="hljs-number">6</span></span>:<span class="hljs-number"><span class="hljs-number">2</span></span> note: ...but borrowed value is only valid <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> the block at <span class="hljs-number"><span class="hljs-number">4</span></span>:<span class="hljs-number"><span class="hljs-number">23</span></span> <br> demo:<span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>(n: int) -&gt; &amp;int { <br> demo:<span class="hljs-number"><span class="hljs-number">5</span></span> bar(&amp;n) <br> demo:<span class="hljs-number"><span class="hljs-number">6</span></span> } <br> <br>   <br> <code class="cpp">#include &lt;stdio.h&gt; int minval(int *A, int n) { int currmin; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;n; i++) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (A[i] &lt; currmin) currmin = A[i]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> currmin; } int main() { int A[] = {<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>}; int min = minval(A,<span class="hljs-number"><span class="hljs-number">3</span></span>); printf(<span class="hljs-string"><span class="hljs-string">"%d\n"</span></span>, min); }</code> <br>   <span class="hljs-number"><span class="hljs-number">0</span></span>  ,     , ,  .       Rust ( - ): <br> <code class="rust"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">minval</span></span></span></span>(A: &amp;[int]) -&gt; int { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> currmin; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> a <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> A.iter() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> *a &lt; currmin { currmin = *a; } } currmin } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> A = [<span class="hljs-number"><span class="hljs-number">1</span></span>i,<span class="hljs-number"><span class="hljs-number">2</span></span>i,<span class="hljs-number"><span class="hljs-number">3</span></span>i]; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> min = minval(A.as_slice()); <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{}"</span></span>, min); }</code> <br>  , : <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> of possibly uninitialized variable: `currmin` <br>   ( )      : <br> <code class="rust"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">minval</span></span></span></span>(A: &amp;[int]) -&gt; int { A.iter().fold(A[<span class="hljs-number"><span class="hljs-number">0</span></span>], |u,&amp;a| { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> a&lt;u {a} <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {u} }) }</code> <br> <br>    <br> <code class="cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span></span>{ int *x; A(int v): x(new int(v)) {} ~A() {delete x;} }; int main() { A a(<span class="hljs-number"><span class="hljs-number">1</span></span>), b=a; }</code> <br> ,    : <br> *** glibc detected *** demo: double free or corruption (fasttop): <span class="hljs-number"><span class="hljs-number">0x0000000000601010</span></span> *** <br> <br>     Rust: <br> <code class="rust"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span></span>{ x: <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;int&gt; } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> A { <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">new</span></span></span></span>(v: int) -&gt; A { A{ x: <span class="hljs-keyword"><span class="hljs-keyword">box</span></span> v } } } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Drop</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> A { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drop</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) {} <span class="hljs-comment"><span class="hljs-comment">// ,     ++ } fn main() { let a = A::new(1); let _b = a; }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">     .   ,     </span></span><code><span class="hljs-comment"><span class="hljs-comment">trait Copy</span></span></code><span class="hljs-comment"><span class="hljs-comment"> . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> Rust       .    </span></span><code><span class="hljs-comment"><span class="hljs-comment">Eq</span></span></code><span class="hljs-comment"><span class="hljs-comment">  </span></span><code><span class="hljs-comment"><span class="hljs-comment">Clone</span></span></code><span class="hljs-comment"><span class="hljs-comment"> ?    </span></span><code><span class="hljs-comment"><span class="hljs-comment">deriving</span></span></code><span class="hljs-comment"><span class="hljs-comment">   : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="rust"><span class="hljs-comment"><span class="hljs-comment">#[deriving(Clone, Eq, Hash, PartialEq, PartialOrd, Ord, Show)] struct A{ x: Box&lt;int&gt; }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">    </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="cpp"><span class="hljs-comment"><span class="hljs-comment">#include &lt;stdio.h&gt; struct X { int a, b; }; void swap_from(X&amp; x, const X&amp; y) { xa = yb; xb = ya; } int main() { X x = {1,2}; swap_from(x,x); printf("%d,%d\n", xa, xb); }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> 2,2 </span></span><br><span class="hljs-comment"><span class="hljs-comment">    ,    cc      .   ,   ,  99  </span></span><a href="http://en.wikipedia.org/wiki/Restrict"><span class="hljs-comment"><span class="hljs-comment">restrict</span></span></a><span class="hljs-comment"><span class="hljs-comment"> ,            :        . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">       Rust: </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="rust"><span class="hljs-comment"><span class="hljs-comment">struct X { pub a: int, pub b: int } fn swap_from(x: &amp;mut X, y: &amp;X) { xa = yb; xb = ya; } fn main() { let mut x = X{a:1, b:2}; swap_from(&amp;mut x, &amp;x); }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">    : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7:24: 7:25 error: cannot borrow `x` as immutable because it is also borrowed as mutable </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7 swap_from(&amp;mut x, &amp;x); </span></span><br><span class="hljs-comment"><span class="hljs-comment"> ^ </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7:20: 7:21 note: previous borrow of `x` occurs here; the mutable borrow prevents subsequent moves, borrows, or modification of `x` until the borrow ends </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7 swap_from(&amp;mut x, &amp;x); </span></span><br><span class="hljs-comment"><span class="hljs-comment"> ^ </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7:26: 7:26 note: previous borrow ends here </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7 swap_from(&amp;mut x, &amp;x); </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  ,             " </span></span><code><span class="hljs-comment"><span class="hljs-comment">&amp;mut</span></span></code><span class="hljs-comment"><span class="hljs-comment"> "  " </span></span><code><span class="hljs-comment"><span class="hljs-comment">&amp;</span></span></code><span class="hljs-comment"><span class="hljs-comment"> " ,   ,          ,   </span></span><code><span class="hljs-comment"><span class="hljs-comment">&amp;mut</span></span></code><span class="hljs-comment"><span class="hljs-comment"> .            .  ,    ,      C99  </span></span><code><span class="hljs-comment"><span class="hljs-comment">restrict</span></span></code><span class="hljs-comment"><span class="hljs-comment">  (Rust  LLVM    ),    . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">   </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="cpp"><span class="hljs-comment"><span class="hljs-comment">#include &lt;vector&gt; int main() { std::vector&lt;int&gt; v; v.push_back(1); v.push_back(2); for(std::vector&lt;int&gt;::const_iterator it=v.begin(); it!=v.end(); ++it) { if (*it &lt; 5) v.push_back(5-*it); } }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">    ,    : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> Segmentation fault (core dumped) </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">    Rust: </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="rust"><span class="hljs-comment"><span class="hljs-comment">fn main() { let mut v: Vec&lt;int&gt; = Vec::new(); v.push(1); v.push(2); for x in v.iter() { if *x &lt; 5 { v.push(5-*x); } } }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">      ,  ,        : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7:13: 7:14 error: cannot borrow `v` as mutable because it is also borrowed as immutable </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7 v.push(5-*x); </span></span><br><span class="hljs-comment"><span class="hljs-comment"> ^ </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:5:14: 5:15 note: previous borrow of `v` occurs here; the immutable borrow prevents subsequent moves or mutable borrows of `v` until the borrow ends </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:5 for x in v.iter() { </span></span><br><span class="hljs-comment"><span class="hljs-comment"> ^ </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:10:2: 10:2 note: previous borrow ends here </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:5 for x in v.iter() { </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:6 if *x &lt; 5 { </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7 v.push(5-*x); </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:8 } </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:9 } </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:10 } </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  Switch </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="cpp"><span class="hljs-comment"><span class="hljs-comment">#include &lt;stdio.h&gt; enum {RED, BLUE, GRAY, UNKNOWN} color = GRAY; int main() { int x; switch(color) { case GRAY: x=1; case RED: case BLUE: x=2; } printf("%d", x); }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">   "2".  Rust          .  ,       ,    </span></span><code><span class="hljs-comment"><span class="hljs-comment">break</span></span></code><span class="hljs-comment"><span class="hljs-comment"> .    Rust   : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="rust"><span class="hljs-comment"><span class="hljs-comment">enum Color {RED, BLUE, GRAY, UNKNOWN} fn main() { let color = GRAY; let x = match color { GRAY =&gt; 1, RED | BLUE =&gt; 2, _ =&gt; 3, }; println!("{}", x); }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">     </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="cpp"><span class="hljs-comment"><span class="hljs-comment">int main() { int pixels = 1; for (int j=0; j&lt;5; j++); pixels++; }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  Rust          . , ,     . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="cpp"><span class="hljs-comment"><span class="hljs-comment">#include &lt;stdio.h&gt; #include &lt;pthread.h&gt; #include &lt;unistd.h&gt; class Resource { int *value; public: Resource(): value(NULL) {} ~Resource() {delete value;} int *acquire() { if (!value) { value = new int(0); } return value; } }; void* function(void *param) { int *value = ((Resource*)param)-&gt;acquire(); printf("resource: %p\n", (void*)value); return value; } int main() { Resource res; for (int i=0; i&lt;5; ++i) { pthread_t pt; pthread_create(&amp;pt, NULL, function, &amp;res); } //sleep(10); printf("done\n"); }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">     : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> done </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7f229c0008c0 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7f22840008c0 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7f228c0008c0 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7f22940008c0 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7f227c0008c0 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">     ,        .      Rust: </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="rust"><span class="hljs-comment"><span class="hljs-comment">struct Resource { value: Option&lt;int&gt;, } impl Resource { pub fn new() -&gt; Resource { Resource{ value: None } } pub fn acquire&lt;'a&gt;(&amp;'a mut self) -&gt; &amp;'a int { if self.value.is_none() { self.value = Some(1); } self.value.get_ref() } } fn main() { let mut res = Resource::new(); for _ in range(0,5) { spawn(proc() { let ptr = res.acquire(); println!("resource {}", ptr) }) } }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  ,            . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:20:23: 20:26 error: cannot borrow immutable captured outer variable in a proc `res` as mutable </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:20 let ptr = res.acquire(); </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">      ,   : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="rust"><span class="hljs-comment"><span class="hljs-comment">extern crate sync; use sync::{Arc, RWLock}; struct Resource { value: Option&lt;Box&lt;int&gt;&gt;, } impl Resource { pub fn new() -&gt; Resource { Resource{ value: None } } pub fn acquire(&amp;mut self) -&gt; *int { if self.value.is_none() { self.value = Some(box 1) } &amp;**self.value.get_ref() as *int } } fn main() { let arc_res = Arc::new(RWLock::new(Resource::new())); for _ in range(0,5) { let child_res = arc_res.clone(); spawn(proc() { let ptr = child_res.write().acquire(); println!("resource: {}", ptr) }) } }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">     </span></span><code><span class="hljs-comment"><span class="hljs-comment">Arc</span></span></code><span class="hljs-comment"><span class="hljs-comment"> ( </span></span><i><span class="hljs-comment"><span class="hljs-comment">Atomically Reference Counted</span></span></i><span class="hljs-comment"><span class="hljs-comment"> -        )  </span></span><code><span class="hljs-comment"><span class="hljs-comment">RWLock</span></span></code><span class="hljs-comment"><span class="hljs-comment"> (   ).   : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7ff4b0010378 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7ff4b0010378 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7ff4b0010378 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7ff4b0010378 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7ff4b0010378 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  ,   ++    .    . Rust        ,    .  ,   ,   .           ,       ( </span></span><a href="http://superwebdeveloper.com/2009/11/25/the-incredible-rate-of-diminishing-returns-of-fixing-software-bugs/"><span class="hljs-comment"><span class="hljs-comment">  </span></span></a><span class="hljs-comment"><span class="hljs-comment"> ). </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">     </span></span><br><span class="hljs-comment"><span class="hljs-comment"> Rust        ,     </span></span><code><span class="hljs-comment"><span class="hljs-comment">unsafe{}</span></span></code><span class="hljs-comment"><span class="hljs-comment"> .   ,     " </span></span><i><span class="hljs-comment"><span class="hljs-comment"> !  ,  .</span></span></i><span class="hljs-comment"><span class="hljs-comment"> ".  ,  ""  (    ,    )    .    ,           ( )  . , ,        </span></span><code><span class="hljs-comment"><span class="hljs-comment">Cell</span></span></code><span class="hljs-comment"><span class="hljs-comment">  </span></span><code><span class="hljs-comment"><span class="hljs-comment">Mutex</span></span></code><span class="hljs-comment"><span class="hljs-comment"> .             ,       (   </span></span><a href="http://en.wikipedia.org/wiki/Test-driven_development"><span class="hljs-comment"><span class="hljs-comment">TDD</span></span></a><span class="hljs-comment"><span class="hljs-comment"> !). </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="https://air.mozilla.org/guaranteeing-memory-safety-in-rust/"><span class="hljs-comment"><span class="hljs-comment">Guaranteeing Memory Safety in Rust (by Niko Matsakis)</span></span></a><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="http://www.techtalkshub.com/rust-safe-systems-programming-fun-fp/"><span class="hljs-comment"><span class="hljs-comment">Rust: Safe Systems Programming with the Fun of FP (by Felix Klock II)</span></span></a><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Keynote"><span class="hljs-comment"><span class="hljs-comment">Lang-NEXT: What ‚Äì if anything ‚Äì have we learned from C++? (by Bjarne Stroustrup)</span></span></a><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Panel-Systems-Programming-Languages-in-2014-and-Beyond"><span class="hljs-comment"><span class="hljs-comment">Lang-NEXT Panel: Systems Programming in 2014 and Beyond</span></span></a></code></code> </pre> <code><code><code><code class="cpp">Box)     ,       (     ).        (std::rc::Rc)    (std::gc::Gc),      (   ). <br> <br></code>      <br>  ++: <br> #include &lt;stdio.h&gt; int *bar(int *p) { return p; } int* foo(int n) { return bar(&amp;n); } int main() { int *p1 = foo(1); int *p2 = foo(2); printf("%d, %d\n", *p1, *p2); }</code> <br>  : <br> 2, 2 <br> <br>  Rust: <br> <code class="rust">fn bar&lt;'a&gt;(p: &amp;'a int) -&gt; &amp;'a int { return p; } fn foo(n: int) -&gt; &amp;int { bar(&amp;n) } fn main() { let p1 = foo(1); let p2 = foo(2); println!("{}, {}", *p1, *p2); }</code> <br>  : <br> demo:5:10: 5:11 error: `n` does not live long enough <br> demo:5 bar(&amp;n) <br> ^ <br> demo:4:24: 6:2 note: reference must be valid for the anonymous lifetime #1 defined on the block at 4:23... <br> demo:4 fn foo(n: int) -&gt; &amp;int { <br> demo:5 bar(&amp;n) <br> demo:6 } <br> demo:4:24: 6:2 note: ...but borrowed value is only valid for the block at 4:23 <br> demo:4 fn foo(n: int) -&gt; &amp;int { <br> demo:5 bar(&amp;n) <br> demo:6 } <br> <br>   <br> <code class="cpp">#include &lt;stdio.h&gt; int minval(int *A, int n) { int currmin; for (int i=0; i&lt;n; i++) if (A[i] &lt; currmin) currmin = A[i]; return currmin; } int main() { int A[] = {1,2,3}; int min = minval(A,3); printf("%d\n", min); }</code> <br>   0  ,     , ,  .       Rust ( - ): <br> <code class="rust">fn minval(A: &amp;[int]) -&gt; int { let mut currmin; for a in A.iter() { if *a &lt; currmin { currmin = *a; } } currmin } fn main() { let A = [1i,2i,3i]; let min = minval(A.as_slice()); println!("{}", min); }</code> <br>  , : use of possibly uninitialized variable: `currmin` <br>   ( )      : <br> <code class="rust">fn minval(A: &amp;[int]) -&gt; int { A.iter().fold(A[0], |u,&amp;a| { if a&lt;u {a} else {u} }) }</code> <br> <br>    <br> <code class="cpp">struct A{ int *x; A(int v): x(new int(v)) {} ~A() {delete x;} }; int main() { A a(1), b=a; }</code> <br> ,    : <br> *** glibc detected *** demo: double free or corruption (fasttop): 0x0000000000601010 *** <br> <br>     Rust: <br> <code class="rust">struct A{ x: Box&lt;int&gt; } impl A { pub fn new(v: int) -&gt; A { A{ x: box v } } } impl Drop for A { fn drop(&amp;mut self) {} // ,     ++ } fn main() { let a = A::new(1); let _b = a; }</code> <br>     .   ,     <code>trait Copy</code> . <br> Rust       .    <code>Eq</code>  <code>Clone</code> ?    <code>deriving</code>   : <br> <code class="rust">#[deriving(Clone, Eq, Hash, PartialEq, PartialOrd, Ord, Show)] struct A{ x: Box&lt;int&gt; }</code> <br> <br>    <br> <code class="cpp">#include &lt;stdio.h&gt; struct X { int a, b; }; void swap_from(X&amp; x, const X&amp; y) { xa = yb; xb = ya; } int main() { X x = {1,2}; swap_from(x,x); printf("%d,%d\n", xa, xb); }</code> <br>  : <br> 2,2 <br>    ,    cc      .   ,   ,  99  <a href="http://en.wikipedia.org/wiki/Restrict">restrict</a> ,            :        . <br> <br>       Rust: <br> <code class="rust">struct X { pub a: int, pub b: int } fn swap_from(x: &amp;mut X, y: &amp;X) { xa = yb; xb = ya; } fn main() { let mut x = X{a:1, b:2}; swap_from(&amp;mut x, &amp;x); }</code> <br>    : <br> demo:7:24: 7:25 error: cannot borrow `x` as immutable because it is also borrowed as mutable <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> ^ <br> demo:7:20: 7:21 note: previous borrow of `x` occurs here; the mutable borrow prevents subsequent moves, borrows, or modification of `x` until the borrow ends <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> ^ <br> demo:7:26: 7:26 note: previous borrow ends here <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> <br>  ,             " <code>&amp;mut</code> "  " <code>&amp;</code> " ,   ,          ,   <code>&amp;mut</code> .            .  ,    ,      C99  <code>restrict</code>  (Rust  LLVM    ),    . <br> <br>   <br> <code class="cpp">#include &lt;vector&gt; int main() { std::vector&lt;int&gt; v; v.push_back(1); v.push_back(2); for(std::vector&lt;int&gt;::const_iterator it=v.begin(); it!=v.end(); ++it) { if (*it &lt; 5) v.push_back(5-*it); } }</code> <br>    ,    : <br> Segmentation fault (core dumped) <br> <br>    Rust: <br> <code class="rust">fn main() { let mut v: Vec&lt;int&gt; = Vec::new(); v.push(1); v.push(2); for x in v.iter() { if *x &lt; 5 { v.push(5-*x); } } }</code> <br>      ,  ,        : <br> demo:7:13: 7:14 error: cannot borrow `v` as mutable because it is also borrowed as immutable <br> demo:7 v.push(5-*x); <br> ^ <br> demo:5:14: 5:15 note: previous borrow of `v` occurs here; the immutable borrow prevents subsequent moves or mutable borrows of `v` until the borrow ends <br> demo:5 for x in v.iter() { <br> ^ <br> demo:10:2: 10:2 note: previous borrow ends here <br> demo:5 for x in v.iter() { <br> demo:6 if *x &lt; 5 { <br> demo:7 v.push(5-*x); <br> demo:8 } <br> demo:9 } <br> demo:10 } <br> <br> <br>  Switch <br> <code class="cpp">#include &lt;stdio.h&gt; enum {RED, BLUE, GRAY, UNKNOWN} color = GRAY; int main() { int x; switch(color) { case GRAY: x=1; case RED: case BLUE: x=2; } printf("%d", x); }</code> <br>   "2".  Rust          .  ,       ,    <code>break</code> .    Rust   : <br> <code class="rust">enum Color {RED, BLUE, GRAY, UNKNOWN} fn main() { let color = GRAY; let x = match color { GRAY =&gt; 1, RED | BLUE =&gt; 2, _ =&gt; 3, }; println!("{}", x); }</code> <br> <br>     <br> <code class="cpp">int main() { int pixels = 1; for (int j=0; j&lt;5; j++); pixels++; }</code> <br>  Rust          . , ,     . <br> <br>  <br> <code class="cpp">#include &lt;stdio.h&gt; #include &lt;pthread.h&gt; #include &lt;unistd.h&gt; class Resource { int *value; public: Resource(): value(NULL) {} ~Resource() {delete value;} int *acquire() { if (!value) { value = new int(0); } return value; } }; void* function(void *param) { int *value = ((Resource*)param)-&gt;acquire(); printf("resource: %p\n", (void*)value); return value; } int main() { Resource res; for (int i=0; i&lt;5; ++i) { pthread_t pt; pthread_create(&amp;pt, NULL, function, &amp;res); } //sleep(10); printf("done\n"); }</code> <br>     : <br> done <br> resource: 0x7f229c0008c0 <br> resource: 0x7f22840008c0 <br> resource: 0x7f228c0008c0 <br> resource: 0x7f22940008c0 <br> resource: 0x7f227c0008c0 <br> <br>     ,        .      Rust: <br> <code class="rust">struct Resource { value: Option&lt;int&gt;, } impl Resource { pub fn new() -&gt; Resource { Resource{ value: None } } pub fn acquire&lt;'a&gt;(&amp;'a mut self) -&gt; &amp;'a int { if self.value.is_none() { self.value = Some(1); } self.value.get_ref() } } fn main() { let mut res = Resource::new(); for _ in range(0,5) { spawn(proc() { let ptr = res.acquire(); println!("resource {}", ptr) }) } }</code> <br>  ,            . <br> demo:20:23: 20:26 error: cannot borrow immutable captured outer variable in a proc `res` as mutable <br> demo:20 let ptr = res.acquire(); <br> <br>      ,   : <br> <code class="rust">extern crate sync; use sync::{Arc, RWLock}; struct Resource { value: Option&lt;Box&lt;int&gt;&gt;, } impl Resource { pub fn new() -&gt; Resource { Resource{ value: None } } pub fn acquire(&amp;mut self) -&gt; *int { if self.value.is_none() { self.value = Some(box 1) } &amp;**self.value.get_ref() as *int } } fn main() { let arc_res = Arc::new(RWLock::new(Resource::new())); for _ in range(0,5) { let child_res = arc_res.clone(); spawn(proc() { let ptr = child_res.write().acquire(); println!("resource: {}", ptr) }) } }</code> <br>     <code>Arc</code> ( <i>Atomically Reference Counted</i> -        )  <code>RWLock</code> (   ).   : <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> <br>  ,   ++    .    . Rust        ,    .  ,   ,   .           ,       ( <a href="http://superwebdeveloper.com/2009/11/25/the-incredible-rate-of-diminishing-returns-of-fixing-software-bugs/">  </a> ). <br> <br>     <br> Rust        ,     <code>unsafe{}</code> .   ,     " <i> !  ,  .</i> ".  ,  ""  (    ,    )    .    ,           ( )  . , ,        <code>Cell</code>  <code>Mutex</code> .             ,       (   <a href="http://en.wikipedia.org/wiki/Test-driven_development">TDD</a> !). <br> <br>  <br> <a href="https://air.mozilla.org/guaranteeing-memory-safety-in-rust/">Guaranteeing Memory Safety in Rust (by Niko Matsakis)</a> <br> <a href="http://www.techtalkshub.com/rust-safe-systems-programming-fun-fp/">Rust: Safe Systems Programming with the Fun of FP (by Felix Klock II)</a> <br> <a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Keynote">Lang-NEXT: What ‚Äì if anything ‚Äì have we learned from C++? (by Bjarne Stroustrup)</a> <br> <a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Panel-Systems-Programming-Languages-in-2014-and-Beyond">Lang-NEXT Panel: Systems Programming in 2014 and Beyond</a></code></code> <blockquote> <code><code><code><code class="cpp">Box)     ,       (     ).        (std::rc::Rc)    (std::gc::Gc),      (   ). <br> <br></code>      <br>  ++: <br> #include &lt;stdio.h&gt; int *bar(int *p) { return p; } int* foo(int n) { return bar(&amp;n); } int main() { int *p1 = foo(1); int *p2 = foo(2); printf("%d, %d\n", *p1, *p2); }</code> <br>  : <br> 2, 2 <br> <br>  Rust: <br> <code class="rust">fn bar&lt;'a&gt;(p: &amp;'a int) -&gt; &amp;'a int { return p; } fn foo(n: int) -&gt; &amp;int { bar(&amp;n) } fn main() { let p1 = foo(1); let p2 = foo(2); println!("{}, {}", *p1, *p2); }</code> <br>  : <br> demo:5:10: 5:11 error: `n` does not live long enough <br> demo:5 bar(&amp;n) <br> ^ <br> demo:4:24: 6:2 note: reference must be valid for the anonymous lifetime #1 defined on the block at 4:23... <br> demo:4 fn foo(n: int) -&gt; &amp;int { <br> demo:5 bar(&amp;n) <br> demo:6 } <br> demo:4:24: 6:2 note: ...but borrowed value is only valid for the block at 4:23 <br> demo:4 fn foo(n: int) -&gt; &amp;int { <br> demo:5 bar(&amp;n) <br> demo:6 } <br> <br>   <br> <code class="cpp">#include &lt;stdio.h&gt; int minval(int *A, int n) { int currmin; for (int i=0; i&lt;n; i++) if (A[i] &lt; currmin) currmin = A[i]; return currmin; } int main() { int A[] = {1,2,3}; int min = minval(A,3); printf("%d\n", min); }</code> <br>   0  ,     , ,  .       Rust ( - ): <br> <code class="rust">fn minval(A: &amp;[int]) -&gt; int { let mut currmin; for a in A.iter() { if *a &lt; currmin { currmin = *a; } } currmin } fn main() { let A = [1i,2i,3i]; let min = minval(A.as_slice()); println!("{}", min); }</code> <br>  , : use of possibly uninitialized variable: `currmin` <br>   ( )      : <br> <code class="rust">fn minval(A: &amp;[int]) -&gt; int { A.iter().fold(A[0], |u,&amp;a| { if a&lt;u {a} else {u} }) }</code> <br> <br>    <br> <code class="cpp">struct A{ int *x; A(int v): x(new int(v)) {} ~A() {delete x;} }; int main() { A a(1), b=a; }</code> <br> ,    : <br> *** glibc detected *** demo: double free or corruption (fasttop): 0x0000000000601010 *** <br> <br>     Rust: <br> <code class="rust">struct A{ x: Box&lt;int&gt; } impl A { pub fn new(v: int) -&gt; A { A{ x: box v } } } impl Drop for A { fn drop(&amp;mut self) {} // ,     ++ } fn main() { let a = A::new(1); let _b = a; }</code> <br>     .   ,     <code>trait Copy</code> . <br> Rust       .    <code>Eq</code>  <code>Clone</code> ?    <code>deriving</code>   : <br> <code class="rust">#[deriving(Clone, Eq, Hash, PartialEq, PartialOrd, Ord, Show)] struct A{ x: Box&lt;int&gt; }</code> <br> <br>    <br> <code class="cpp">#include &lt;stdio.h&gt; struct X { int a, b; }; void swap_from(X&amp; x, const X&amp; y) { xa = yb; xb = ya; } int main() { X x = {1,2}; swap_from(x,x); printf("%d,%d\n", xa, xb); }</code> <br>  : <br> 2,2 <br>    ,    cc      .   ,   ,  99  <a href="http://en.wikipedia.org/wiki/Restrict">restrict</a> ,            :        . <br> <br>       Rust: <br> <code class="rust">struct X { pub a: int, pub b: int } fn swap_from(x: &amp;mut X, y: &amp;X) { xa = yb; xb = ya; } fn main() { let mut x = X{a:1, b:2}; swap_from(&amp;mut x, &amp;x); }</code> <br>    : <br> demo:7:24: 7:25 error: cannot borrow `x` as immutable because it is also borrowed as mutable <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> ^ <br> demo:7:20: 7:21 note: previous borrow of `x` occurs here; the mutable borrow prevents subsequent moves, borrows, or modification of `x` until the borrow ends <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> ^ <br> demo:7:26: 7:26 note: previous borrow ends here <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> <br>  ,             " <code>&amp;mut</code> "  " <code>&amp;</code> " ,   ,          ,   <code>&amp;mut</code> .            .  ,    ,      C99  <code>restrict</code>  (Rust  LLVM    ),    . <br> <br>   <br> <code class="cpp">#include &lt;vector&gt; int main() { std::vector&lt;int&gt; v; v.push_back(1); v.push_back(2); for(std::vector&lt;int&gt;::const_iterator it=v.begin(); it!=v.end(); ++it) { if (*it &lt; 5) v.push_back(5-*it); } }</code> <br>    ,    : <br> Segmentation fault (core dumped) <br> <br>    Rust: <br> <code class="rust">fn main() { let mut v: Vec&lt;int&gt; = Vec::new(); v.push(1); v.push(2); for x in v.iter() { if *x &lt; 5 { v.push(5-*x); } } }</code> <br>      ,  ,        : <br> demo:7:13: 7:14 error: cannot borrow `v` as mutable because it is also borrowed as immutable <br> demo:7 v.push(5-*x); <br> ^ <br> demo:5:14: 5:15 note: previous borrow of `v` occurs here; the immutable borrow prevents subsequent moves or mutable borrows of `v` until the borrow ends <br> demo:5 for x in v.iter() { <br> ^ <br> demo:10:2: 10:2 note: previous borrow ends here <br> demo:5 for x in v.iter() { <br> demo:6 if *x &lt; 5 { <br> demo:7 v.push(5-*x); <br> demo:8 } <br> demo:9 } <br> demo:10 } <br> <br> <br>  Switch <br> <code class="cpp">#include &lt;stdio.h&gt; enum {RED, BLUE, GRAY, UNKNOWN} color = GRAY; int main() { int x; switch(color) { case GRAY: x=1; case RED: case BLUE: x=2; } printf("%d", x); }</code> <br>   "2".  Rust          .  ,       ,    <code>break</code> .    Rust   : <br> <code class="rust">enum Color {RED, BLUE, GRAY, UNKNOWN} fn main() { let color = GRAY; let x = match color { GRAY =&gt; 1, RED | BLUE =&gt; 2, _ =&gt; 3, }; println!("{}", x); }</code> <br> <br>     <br> <code class="cpp">int main() { int pixels = 1; for (int j=0; j&lt;5; j++); pixels++; }</code> <br>  Rust          . , ,     . <br> <br>  <br> <code class="cpp">#include &lt;stdio.h&gt; #include &lt;pthread.h&gt; #include &lt;unistd.h&gt; class Resource { int *value; public: Resource(): value(NULL) {} ~Resource() {delete value;} int *acquire() { if (!value) { value = new int(0); } return value; } }; void* function(void *param) { int *value = ((Resource*)param)-&gt;acquire(); printf("resource: %p\n", (void*)value); return value; } int main() { Resource res; for (int i=0; i&lt;5; ++i) { pthread_t pt; pthread_create(&amp;pt, NULL, function, &amp;res); } //sleep(10); printf("done\n"); }</code> <br>     : <br> done <br> resource: 0x7f229c0008c0 <br> resource: 0x7f22840008c0 <br> resource: 0x7f228c0008c0 <br> resource: 0x7f22940008c0 <br> resource: 0x7f227c0008c0 <br> <br>     ,        .      Rust: <br> <code class="rust">struct Resource { value: Option&lt;int&gt;, } impl Resource { pub fn new() -&gt; Resource { Resource{ value: None } } pub fn acquire&lt;'a&gt;(&amp;'a mut self) -&gt; &amp;'a int { if self.value.is_none() { self.value = Some(1); } self.value.get_ref() } } fn main() { let mut res = Resource::new(); for _ in range(0,5) { spawn(proc() { let ptr = res.acquire(); println!("resource {}", ptr) }) } }</code> <br>  ,            . <br> demo:20:23: 20:26 error: cannot borrow immutable captured outer variable in a proc `res` as mutable <br> demo:20 let ptr = res.acquire(); <br> <br>      ,   : <br> <code class="rust">extern crate sync; use sync::{Arc, RWLock}; struct Resource { value: Option&lt;Box&lt;int&gt;&gt;, } impl Resource { pub fn new() -&gt; Resource { Resource{ value: None } } pub fn acquire(&amp;mut self) -&gt; *int { if self.value.is_none() { self.value = Some(box 1) } &amp;**self.value.get_ref() as *int } } fn main() { let arc_res = Arc::new(RWLock::new(Resource::new())); for _ in range(0,5) { let child_res = arc_res.clone(); spawn(proc() { let ptr = child_res.write().acquire(); println!("resource: {}", ptr) }) } }</code> <br>     <code>Arc</code> ( <i>Atomically Reference Counted</i> -        )  <code>RWLock</code> (   ).   : <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> <br>  ,   ++    .    . Rust        ,    .  ,   ,   .           ,       ( <a href="http://superwebdeveloper.com/2009/11/25/the-incredible-rate-of-diminishing-returns-of-fixing-software-bugs/">  </a> ). <br> <br>     <br> Rust        ,     <code>unsafe{}</code> .   ,     " <i> !  ,  .</i> ".  ,  ""  (    ,    )    .    ,           ( )  . , ,        <code>Cell</code>  <code>Mutex</code> .             ,       (   <a href="http://en.wikipedia.org/wiki/Test-driven_development">TDD</a> !). <br> <br>  <br> <a href="https://air.mozilla.org/guaranteeing-memory-safety-in-rust/">Guaranteeing Memory Safety in Rust (by Niko Matsakis)</a> <br> <a href="http://www.techtalkshub.com/rust-safe-systems-programming-fun-fp/">Rust: Safe Systems Programming with the Fun of FP (by Felix Klock II)</a> <br> <a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Keynote">Lang-NEXT: What ‚Äì if anything ‚Äì have we learned from C++? (by Bjarne Stroustrup)</a> <br> <a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Panel-Systems-Programming-Languages-in-2014-and-Beyond">Lang-NEXT Panel: Systems Programming in 2014 and Beyond</a></code></code> </blockquote> <code><code><code><code class="cpp">Box)     ,       (     ).        (std::rc::Rc)    (std::gc::Gc),      (   ). <br> <br></code>      <br>  ++: <br> #include &lt;stdio.h&gt; int *bar(int *p) { return p; } int* foo(int n) { return bar(&amp;n); } int main() { int *p1 = foo(1); int *p2 = foo(2); printf("%d, %d\n", *p1, *p2); }</code> <br>  : <br> 2, 2 <br> <br>  Rust: <br> <code class="rust">fn bar&lt;'a&gt;(p: &amp;'a int) -&gt; &amp;'a int { return p; } fn foo(n: int) -&gt; &amp;int { bar(&amp;n) } fn main() { let p1 = foo(1); let p2 = foo(2); println!("{}, {}", *p1, *p2); }</code> <br>  : <br> demo:5:10: 5:11 error: `n` does not live long enough <br> demo:5 bar(&amp;n) <br> ^ <br> demo:4:24: 6:2 note: reference must be valid for the anonymous lifetime #1 defined on the block at 4:23... <br> demo:4 fn foo(n: int) -&gt; &amp;int { <br> demo:5 bar(&amp;n) <br> demo:6 } <br> demo:4:24: 6:2 note: ...but borrowed value is only valid for the block at 4:23 <br> demo:4 fn foo(n: int) -&gt; &amp;int { <br> demo:5 bar(&amp;n) <br> demo:6 } <br> <br>   <br> <code class="cpp">#include &lt;stdio.h&gt; int minval(int *A, int n) { int currmin; for (int i=0; i&lt;n; i++) if (A[i] &lt; currmin) currmin = A[i]; return currmin; } int main() { int A[] = {1,2,3}; int min = minval(A,3); printf("%d\n", min); }</code> <br>   0  ,     , ,  .       Rust ( - ): <br> <code class="rust">fn minval(A: &amp;[int]) -&gt; int { let mut currmin; for a in A.iter() { if *a &lt; currmin { currmin = *a; } } currmin } fn main() { let A = [1i,2i,3i]; let min = minval(A.as_slice()); println!("{}", min); }</code> <br>  , : use of possibly uninitialized variable: `currmin` <br>   ( )      : <br> <code class="rust">fn minval(A: &amp;[int]) -&gt; int { A.iter().fold(A[0], |u,&amp;a| { if a&lt;u {a} else {u} }) }</code> <br> <br>    <br> <code class="cpp">struct A{ int *x; A(int v): x(new int(v)) {} ~A() {delete x;} }; int main() { A a(1), b=a; }</code> <br> ,    : <br> *** glibc detected *** demo: double free or corruption (fasttop): 0x0000000000601010 *** <br> <br>     Rust: <br> <code class="rust">struct A{ x: Box&lt;int&gt; } impl A { pub fn new(v: int) -&gt; A { A{ x: box v } } } impl Drop for A { fn drop(&amp;mut self) {} // ,     ++ } fn main() { let a = A::new(1); let _b = a; }</code> <br>     .   ,     <code>trait Copy</code> . <br> Rust       .    <code>Eq</code>  <code>Clone</code> ?    <code>deriving</code>   : <br> <code class="rust">#[deriving(Clone, Eq, Hash, PartialEq, PartialOrd, Ord, Show)] struct A{ x: Box&lt;int&gt; }</code> <br> <br>    <br> <code class="cpp">#include &lt;stdio.h&gt; struct X { int a, b; }; void swap_from(X&amp; x, const X&amp; y) { xa = yb; xb = ya; } int main() { X x = {1,2}; swap_from(x,x); printf("%d,%d\n", xa, xb); }</code> <br>  : <br> 2,2 <br>    ,    cc      .   ,   ,  99  <a href="http://en.wikipedia.org/wiki/Restrict">restrict</a> ,            :        . <br> <br>       Rust: <br> <code class="rust">struct X { pub a: int, pub b: int } fn swap_from(x: &amp;mut X, y: &amp;X) { xa = yb; xb = ya; } fn main() { let mut x = X{a:1, b:2}; swap_from(&amp;mut x, &amp;x); }</code> <br>    : <br> demo:7:24: 7:25 error: cannot borrow `x` as immutable because it is also borrowed as mutable <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> ^ <br> demo:7:20: 7:21 note: previous borrow of `x` occurs here; the mutable borrow prevents subsequent moves, borrows, or modification of `x` until the borrow ends <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> ^ <br> demo:7:26: 7:26 note: previous borrow ends here <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> <br>  ,             " <code>&amp;mut</code> "  " <code>&amp;</code> " ,   ,          ,   <code>&amp;mut</code> .            .  ,    ,      C99  <code>restrict</code>  (Rust  LLVM    ),    . <br> <br>   <br> <code class="cpp">#include &lt;vector&gt; int main() { std::vector&lt;int&gt; v; v.push_back(1); v.push_back(2); for(std::vector&lt;int&gt;::const_iterator it=v.begin(); it!=v.end(); ++it) { if (*it &lt; 5) v.push_back(5-*it); } }</code> <br>    ,    : <br> Segmentation fault (core dumped) <br> <br>    Rust: <br> <code class="rust">fn main() { let mut v: Vec&lt;int&gt; = Vec::new(); v.push(1); v.push(2); for x in v.iter() { if *x &lt; 5 { v.push(5-*x); } } }</code> <br>      ,  ,        : <br> demo:7:13: 7:14 error: cannot borrow `v` as mutable because it is also borrowed as immutable <br> demo:7 v.push(5-*x); <br> ^ <br> demo:5:14: 5:15 note: previous borrow of `v` occurs here; the immutable borrow prevents subsequent moves or mutable borrows of `v` until the borrow ends <br> demo:5 for x in v.iter() { <br> ^ <br> demo:10:2: 10:2 note: previous borrow ends here <br> demo:5 for x in v.iter() { <br> demo:6 if *x &lt; 5 { <br> demo:7 v.push(5-*x); <br> demo:8 } <br> demo:9 } <br> demo:10 } <br> <br> <br>  Switch <br> <code class="cpp">#include &lt;stdio.h&gt; enum {RED, BLUE, GRAY, UNKNOWN} color = GRAY; int main() { int x; switch(color) { case GRAY: x=1; case RED: case BLUE: x=2; } printf("%d", x); }</code> <br>   "2".  Rust          .  ,       ,    <code>break</code> .    Rust   : <br> <code class="rust">enum Color {RED, BLUE, GRAY, UNKNOWN} fn main() { let color = GRAY; let x = match color { GRAY =&gt; 1, RED | BLUE =&gt; 2, _ =&gt; 3, }; println!("{}", x); }</code> <br> <br>     <br> <code class="cpp">int main() { int pixels = 1; for (int j=0; j&lt;5; j++); pixels++; }</code> <br>  Rust          . , ,     . <br> <br>  <br> <code class="cpp">#include &lt;stdio.h&gt; #include &lt;pthread.h&gt; #include &lt;unistd.h&gt; class Resource { int *value; public: Resource(): value(NULL) {} ~Resource() {delete value;} int *acquire() { if (!value) { value = new int(0); } return value; } }; void* function(void *param) { int *value = ((Resource*)param)-&gt;acquire(); printf("resource: %p\n", (void*)value); return value; } int main() { Resource res; for (int i=0; i&lt;5; ++i) { pthread_t pt; pthread_create(&amp;pt, NULL, function, &amp;res); } //sleep(10); printf("done\n"); }</code> <br>     : <br> done <br> resource: 0x7f229c0008c0 <br> resource: 0x7f22840008c0 <br> resource: 0x7f228c0008c0 <br> resource: 0x7f22940008c0 <br> resource: 0x7f227c0008c0 <br> <br>     ,        .      Rust: <br> <code class="rust">struct Resource { value: Option&lt;int&gt;, } impl Resource { pub fn new() -&gt; Resource { Resource{ value: None } } pub fn acquire&lt;'a&gt;(&amp;'a mut self) -&gt; &amp;'a int { if self.value.is_none() { self.value = Some(1); } self.value.get_ref() } } fn main() { let mut res = Resource::new(); for _ in range(0,5) { spawn(proc() { let ptr = res.acquire(); println!("resource {}", ptr) }) } }</code> <br>  ,            . <br> demo:20:23: 20:26 error: cannot borrow immutable captured outer variable in a proc `res` as mutable <br> demo:20 let ptr = res.acquire(); <br> <br>      ,   : <br> <code class="rust">extern crate sync; use sync::{Arc, RWLock}; struct Resource { value: Option&lt;Box&lt;int&gt;&gt;, } impl Resource { pub fn new() -&gt; Resource { Resource{ value: None } } pub fn acquire(&amp;mut self) -&gt; *int { if self.value.is_none() { self.value = Some(box 1) } &amp;**self.value.get_ref() as *int } } fn main() { let arc_res = Arc::new(RWLock::new(Resource::new())); for _ in range(0,5) { let child_res = arc_res.clone(); spawn(proc() { let ptr = child_res.write().acquire(); println!("resource: {}", ptr) }) } }</code> <br>     <code>Arc</code> ( <i>Atomically Reference Counted</i> -        )  <code>RWLock</code> (   ).   : <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> <br>  ,   ++    .    . Rust        ,    .  ,   ,   .           ,       ( <a href="http://superwebdeveloper.com/2009/11/25/the-incredible-rate-of-diminishing-returns-of-fixing-software-bugs/">  </a> ). <br> <br>     <br> Rust        ,     <code>unsafe{}</code> .   ,     " <i> !  ,  .</i> ".  ,  ""  (    ,    )    .    ,           ( )  . , ,        <code>Cell</code>  <code>Mutex</code> .             ,       (   <a href="http://en.wikipedia.org/wiki/Test-driven_development">TDD</a> !). <br> <br>  <br> <a href="https://air.mozilla.org/guaranteeing-memory-safety-in-rust/">Guaranteeing Memory Safety in Rust (by Niko Matsakis)</a> <br> <a href="http://www.techtalkshub.com/rust-safe-systems-programming-fun-fp/">Rust: Safe Systems Programming with the Fun of FP (by Felix Klock II)</a> <br> <a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Keynote">Lang-NEXT: What ‚Äì if anything ‚Äì have we learned from C++? (by Bjarne Stroustrup)</a> <br> <a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Panel-Systems-Programming-Languages-in-2014-and-Beyond">Lang-NEXT Panel: Systems Programming in 2014 and Beyond</a></code></code> <pre> <code class="hljs rust"><code><code><code class="cpp"><span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>)     ,       (     ).        (std::rc::Rc)    (std::gc::Gc),      (   ). <br> <br></code>      <br>  ++: <br> #include &lt;stdio.h&gt; int *bar(int *p) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p; } int* foo(int n) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bar(&amp;n); } int main() { int *p1 = foo(<span class="hljs-number"><span class="hljs-number">1</span></span>); int *p2 = foo(<span class="hljs-number"><span class="hljs-number">2</span></span>); printf(<span class="hljs-string"><span class="hljs-string">"%d, %d\n"</span></span>, *p1, *p2); }</code> <br>  : <br> <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span> <br> <br>  Rust: <br> <code class="rust"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt;(p: &amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> int) -&gt; &amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> int { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>(n: int) -&gt; &amp;int { bar(&amp;n) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> p1 = foo(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> p2 = foo(<span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{}, {}"</span></span>, *p1, *p2); }</code> <br>  : <br> demo:<span class="hljs-number"><span class="hljs-number">5</span></span>:<span class="hljs-number"><span class="hljs-number">10</span></span>: <span class="hljs-number"><span class="hljs-number">5</span></span>:<span class="hljs-number"><span class="hljs-number">11</span></span> error: `n` does not live long enough <br> demo:<span class="hljs-number"><span class="hljs-number">5</span></span> bar(&amp;n) <br> ^ <br> demo:<span class="hljs-number"><span class="hljs-number">4</span></span>:<span class="hljs-number"><span class="hljs-number">24</span></span>: <span class="hljs-number"><span class="hljs-number">6</span></span>:<span class="hljs-number"><span class="hljs-number">2</span></span> note: reference must <span class="hljs-keyword"><span class="hljs-keyword">be</span></span> valid <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> the anonymous lifetime #<span class="hljs-number"><span class="hljs-number">1</span></span> defined on the block at <span class="hljs-number"><span class="hljs-number">4</span></span>:<span class="hljs-number"><span class="hljs-number">23</span></span>... <br> demo:<span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>(n: int) -&gt; &amp;int { <br> demo:<span class="hljs-number"><span class="hljs-number">5</span></span> bar(&amp;n) <br> demo:<span class="hljs-number"><span class="hljs-number">6</span></span> } <br> demo:<span class="hljs-number"><span class="hljs-number">4</span></span>:<span class="hljs-number"><span class="hljs-number">24</span></span>: <span class="hljs-number"><span class="hljs-number">6</span></span>:<span class="hljs-number"><span class="hljs-number">2</span></span> note: ...but borrowed value is only valid <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> the block at <span class="hljs-number"><span class="hljs-number">4</span></span>:<span class="hljs-number"><span class="hljs-number">23</span></span> <br> demo:<span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>(n: int) -&gt; &amp;int { <br> demo:<span class="hljs-number"><span class="hljs-number">5</span></span> bar(&amp;n) <br> demo:<span class="hljs-number"><span class="hljs-number">6</span></span> } <br> <br>   <br> <code class="cpp">#include &lt;stdio.h&gt; int minval(int *A, int n) { int currmin; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;n; i++) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (A[i] &lt; currmin) currmin = A[i]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> currmin; } int main() { int A[] = {<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>}; int min = minval(A,<span class="hljs-number"><span class="hljs-number">3</span></span>); printf(<span class="hljs-string"><span class="hljs-string">"%d\n"</span></span>, min); }</code> <br>   <span class="hljs-number"><span class="hljs-number">0</span></span>  ,     , ,  .       Rust ( - ): <br> <code class="rust"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">minval</span></span></span></span>(A: &amp;[int]) -&gt; int { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> currmin; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> a <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> A.iter() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> *a &lt; currmin { currmin = *a; } } currmin } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> A = [<span class="hljs-number"><span class="hljs-number">1</span></span>i,<span class="hljs-number"><span class="hljs-number">2</span></span>i,<span class="hljs-number"><span class="hljs-number">3</span></span>i]; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> min = minval(A.as_slice()); <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{}"</span></span>, min); }</code> <br>  , : <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> of possibly uninitialized variable: `currmin` <br>   ( )      : <br> <code class="rust"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">minval</span></span></span></span>(A: &amp;[int]) -&gt; int { A.iter().fold(A[<span class="hljs-number"><span class="hljs-number">0</span></span>], |u,&amp;a| { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> a&lt;u {a} <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {u} }) }</code> <br> <br>    <br> <code class="cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span></span>{ int *x; A(int v): x(new int(v)) {} ~A() {delete x;} }; int main() { A a(<span class="hljs-number"><span class="hljs-number">1</span></span>), b=a; }</code> <br> ,    : <br> *** glibc detected *** demo: double free or corruption (fasttop): <span class="hljs-number"><span class="hljs-number">0x0000000000601010</span></span> *** <br> <br>     Rust: <br> <code class="rust"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span></span>{ x: <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;int&gt; } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> A { <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">new</span></span></span></span>(v: int) -&gt; A { A{ x: <span class="hljs-keyword"><span class="hljs-keyword">box</span></span> v } } } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Drop</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> A { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drop</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) {} <span class="hljs-comment"><span class="hljs-comment">// ,     ++ } fn main() { let a = A::new(1); let _b = a; }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">     .   ,     </span></span><code><span class="hljs-comment"><span class="hljs-comment">trait Copy</span></span></code><span class="hljs-comment"><span class="hljs-comment"> . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> Rust       .    </span></span><code><span class="hljs-comment"><span class="hljs-comment">Eq</span></span></code><span class="hljs-comment"><span class="hljs-comment">  </span></span><code><span class="hljs-comment"><span class="hljs-comment">Clone</span></span></code><span class="hljs-comment"><span class="hljs-comment"> ?    </span></span><code><span class="hljs-comment"><span class="hljs-comment">deriving</span></span></code><span class="hljs-comment"><span class="hljs-comment">   : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="rust"><span class="hljs-comment"><span class="hljs-comment">#[deriving(Clone, Eq, Hash, PartialEq, PartialOrd, Ord, Show)] struct A{ x: Box&lt;int&gt; }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">    </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="cpp"><span class="hljs-comment"><span class="hljs-comment">#include &lt;stdio.h&gt; struct X { int a, b; }; void swap_from(X&amp; x, const X&amp; y) { xa = yb; xb = ya; } int main() { X x = {1,2}; swap_from(x,x); printf("%d,%d\n", xa, xb); }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> 2,2 </span></span><br><span class="hljs-comment"><span class="hljs-comment">    ,    cc      .   ,   ,  99  </span></span><a href="http://en.wikipedia.org/wiki/Restrict"><span class="hljs-comment"><span class="hljs-comment">restrict</span></span></a><span class="hljs-comment"><span class="hljs-comment"> ,            :        . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">       Rust: </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="rust"><span class="hljs-comment"><span class="hljs-comment">struct X { pub a: int, pub b: int } fn swap_from(x: &amp;mut X, y: &amp;X) { xa = yb; xb = ya; } fn main() { let mut x = X{a:1, b:2}; swap_from(&amp;mut x, &amp;x); }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">    : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7:24: 7:25 error: cannot borrow `x` as immutable because it is also borrowed as mutable </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7 swap_from(&amp;mut x, &amp;x); </span></span><br><span class="hljs-comment"><span class="hljs-comment"> ^ </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7:20: 7:21 note: previous borrow of `x` occurs here; the mutable borrow prevents subsequent moves, borrows, or modification of `x` until the borrow ends </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7 swap_from(&amp;mut x, &amp;x); </span></span><br><span class="hljs-comment"><span class="hljs-comment"> ^ </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7:26: 7:26 note: previous borrow ends here </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7 swap_from(&amp;mut x, &amp;x); </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  ,             " </span></span><code><span class="hljs-comment"><span class="hljs-comment">&amp;mut</span></span></code><span class="hljs-comment"><span class="hljs-comment"> "  " </span></span><code><span class="hljs-comment"><span class="hljs-comment">&amp;</span></span></code><span class="hljs-comment"><span class="hljs-comment"> " ,   ,          ,   </span></span><code><span class="hljs-comment"><span class="hljs-comment">&amp;mut</span></span></code><span class="hljs-comment"><span class="hljs-comment"> .            .  ,    ,      C99  </span></span><code><span class="hljs-comment"><span class="hljs-comment">restrict</span></span></code><span class="hljs-comment"><span class="hljs-comment">  (Rust  LLVM    ),    . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">   </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="cpp"><span class="hljs-comment"><span class="hljs-comment">#include &lt;vector&gt; int main() { std::vector&lt;int&gt; v; v.push_back(1); v.push_back(2); for(std::vector&lt;int&gt;::const_iterator it=v.begin(); it!=v.end(); ++it) { if (*it &lt; 5) v.push_back(5-*it); } }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">    ,    : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> Segmentation fault (core dumped) </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">    Rust: </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="rust"><span class="hljs-comment"><span class="hljs-comment">fn main() { let mut v: Vec&lt;int&gt; = Vec::new(); v.push(1); v.push(2); for x in v.iter() { if *x &lt; 5 { v.push(5-*x); } } }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">      ,  ,        : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7:13: 7:14 error: cannot borrow `v` as mutable because it is also borrowed as immutable </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7 v.push(5-*x); </span></span><br><span class="hljs-comment"><span class="hljs-comment"> ^ </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:5:14: 5:15 note: previous borrow of `v` occurs here; the immutable borrow prevents subsequent moves or mutable borrows of `v` until the borrow ends </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:5 for x in v.iter() { </span></span><br><span class="hljs-comment"><span class="hljs-comment"> ^ </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:10:2: 10:2 note: previous borrow ends here </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:5 for x in v.iter() { </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:6 if *x &lt; 5 { </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:7 v.push(5-*x); </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:8 } </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:9 } </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:10 } </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  Switch </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="cpp"><span class="hljs-comment"><span class="hljs-comment">#include &lt;stdio.h&gt; enum {RED, BLUE, GRAY, UNKNOWN} color = GRAY; int main() { int x; switch(color) { case GRAY: x=1; case RED: case BLUE: x=2; } printf("%d", x); }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">   "2".  Rust          .  ,       ,    </span></span><code><span class="hljs-comment"><span class="hljs-comment">break</span></span></code><span class="hljs-comment"><span class="hljs-comment"> .    Rust   : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="rust"><span class="hljs-comment"><span class="hljs-comment">enum Color {RED, BLUE, GRAY, UNKNOWN} fn main() { let color = GRAY; let x = match color { GRAY =&gt; 1, RED | BLUE =&gt; 2, _ =&gt; 3, }; println!("{}", x); }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">     </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="cpp"><span class="hljs-comment"><span class="hljs-comment">int main() { int pixels = 1; for (int j=0; j&lt;5; j++); pixels++; }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  Rust          . , ,     . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="cpp"><span class="hljs-comment"><span class="hljs-comment">#include &lt;stdio.h&gt; #include &lt;pthread.h&gt; #include &lt;unistd.h&gt; class Resource { int *value; public: Resource(): value(NULL) {} ~Resource() {delete value;} int *acquire() { if (!value) { value = new int(0); } return value; } }; void* function(void *param) { int *value = ((Resource*)param)-&gt;acquire(); printf("resource: %p\n", (void*)value); return value; } int main() { Resource res; for (int i=0; i&lt;5; ++i) { pthread_t pt; pthread_create(&amp;pt, NULL, function, &amp;res); } //sleep(10); printf("done\n"); }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">     : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> done </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7f229c0008c0 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7f22840008c0 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7f228c0008c0 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7f22940008c0 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7f227c0008c0 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">     ,        .      Rust: </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="rust"><span class="hljs-comment"><span class="hljs-comment">struct Resource { value: Option&lt;int&gt;, } impl Resource { pub fn new() -&gt; Resource { Resource{ value: None } } pub fn acquire&lt;'a&gt;(&amp;'a mut self) -&gt; &amp;'a int { if self.value.is_none() { self.value = Some(1); } self.value.get_ref() } } fn main() { let mut res = Resource::new(); for _ in range(0,5) { spawn(proc() { let ptr = res.acquire(); println!("resource {}", ptr) }) } }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  ,            . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:20:23: 20:26 error: cannot borrow immutable captured outer variable in a proc `res` as mutable </span></span><br><span class="hljs-comment"><span class="hljs-comment"> demo:20 let ptr = res.acquire(); </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">      ,   : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="rust"><span class="hljs-comment"><span class="hljs-comment">extern crate sync; use sync::{Arc, RWLock}; struct Resource { value: Option&lt;Box&lt;int&gt;&gt;, } impl Resource { pub fn new() -&gt; Resource { Resource{ value: None } } pub fn acquire(&amp;mut self) -&gt; *int { if self.value.is_none() { self.value = Some(box 1) } &amp;**self.value.get_ref() as *int } } fn main() { let arc_res = Arc::new(RWLock::new(Resource::new())); for _ in range(0,5) { let child_res = arc_res.clone(); spawn(proc() { let ptr = child_res.write().acquire(); println!("resource: {}", ptr) }) } }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">     </span></span><code><span class="hljs-comment"><span class="hljs-comment">Arc</span></span></code><span class="hljs-comment"><span class="hljs-comment"> ( </span></span><i><span class="hljs-comment"><span class="hljs-comment">Atomically Reference Counted</span></span></i><span class="hljs-comment"><span class="hljs-comment"> -        )  </span></span><code><span class="hljs-comment"><span class="hljs-comment">RWLock</span></span></code><span class="hljs-comment"><span class="hljs-comment"> (   ).   : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7ff4b0010378 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7ff4b0010378 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7ff4b0010378 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7ff4b0010378 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> resource: 0x7ff4b0010378 </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  ,   ++    .    . Rust        ,    .  ,   ,   .           ,       ( </span></span><a href="http://superwebdeveloper.com/2009/11/25/the-incredible-rate-of-diminishing-returns-of-fixing-software-bugs/"><span class="hljs-comment"><span class="hljs-comment">  </span></span></a><span class="hljs-comment"><span class="hljs-comment"> ). </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">     </span></span><br><span class="hljs-comment"><span class="hljs-comment"> Rust        ,     </span></span><code><span class="hljs-comment"><span class="hljs-comment">unsafe{}</span></span></code><span class="hljs-comment"><span class="hljs-comment"> .   ,     " </span></span><i><span class="hljs-comment"><span class="hljs-comment"> !  ,  .</span></span></i><span class="hljs-comment"><span class="hljs-comment"> ".  ,  ""  (    ,    )    .    ,           ( )  . , ,        </span></span><code><span class="hljs-comment"><span class="hljs-comment">Cell</span></span></code><span class="hljs-comment"><span class="hljs-comment">  </span></span><code><span class="hljs-comment"><span class="hljs-comment">Mutex</span></span></code><span class="hljs-comment"><span class="hljs-comment"> .             ,       (   </span></span><a href="http://en.wikipedia.org/wiki/Test-driven_development"><span class="hljs-comment"><span class="hljs-comment">TDD</span></span></a><span class="hljs-comment"><span class="hljs-comment"> !). </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="https://air.mozilla.org/guaranteeing-memory-safety-in-rust/"><span class="hljs-comment"><span class="hljs-comment">Guaranteeing Memory Safety in Rust (by Niko Matsakis)</span></span></a><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="http://www.techtalkshub.com/rust-safe-systems-programming-fun-fp/"><span class="hljs-comment"><span class="hljs-comment">Rust: Safe Systems Programming with the Fun of FP (by Felix Klock II)</span></span></a><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Keynote"><span class="hljs-comment"><span class="hljs-comment">Lang-NEXT: What ‚Äì if anything ‚Äì have we learned from C++? (by Bjarne Stroustrup)</span></span></a><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Panel-Systems-Programming-Languages-in-2014-and-Beyond"><span class="hljs-comment"><span class="hljs-comment">Lang-NEXT Panel: Systems Programming in 2014 and Beyond</span></span></a></code></code> </pre> <code><code><code><code class="cpp">Box)     ,       (     ).        (std::rc::Rc)    (std::gc::Gc),      (   ). <br> <br></code>      <br>  ++: <br> #include &lt;stdio.h&gt; int *bar(int *p) { return p; } int* foo(int n) { return bar(&amp;n); } int main() { int *p1 = foo(1); int *p2 = foo(2); printf("%d, %d\n", *p1, *p2); }</code> <br>  : <br> 2, 2 <br> <br>  Rust: <br> <code class="rust">fn bar&lt;'a&gt;(p: &amp;'a int) -&gt; &amp;'a int { return p; } fn foo(n: int) -&gt; &amp;int { bar(&amp;n) } fn main() { let p1 = foo(1); let p2 = foo(2); println!("{}, {}", *p1, *p2); }</code> <br>  : <br> demo:5:10: 5:11 error: `n` does not live long enough <br> demo:5 bar(&amp;n) <br> ^ <br> demo:4:24: 6:2 note: reference must be valid for the anonymous lifetime #1 defined on the block at 4:23... <br> demo:4 fn foo(n: int) -&gt; &amp;int { <br> demo:5 bar(&amp;n) <br> demo:6 } <br> demo:4:24: 6:2 note: ...but borrowed value is only valid for the block at 4:23 <br> demo:4 fn foo(n: int) -&gt; &amp;int { <br> demo:5 bar(&amp;n) <br> demo:6 } <br> <br>   <br> <code class="cpp">#include &lt;stdio.h&gt; int minval(int *A, int n) { int currmin; for (int i=0; i&lt;n; i++) if (A[i] &lt; currmin) currmin = A[i]; return currmin; } int main() { int A[] = {1,2,3}; int min = minval(A,3); printf("%d\n", min); }</code> <br>   0  ,     , ,  .       Rust ( - ): <br> <code class="rust">fn minval(A: &amp;[int]) -&gt; int { let mut currmin; for a in A.iter() { if *a &lt; currmin { currmin = *a; } } currmin } fn main() { let A = [1i,2i,3i]; let min = minval(A.as_slice()); println!("{}", min); }</code> <br>  , : use of possibly uninitialized variable: `currmin` <br>   ( )      : <br> <code class="rust">fn minval(A: &amp;[int]) -&gt; int { A.iter().fold(A[0], |u,&amp;a| { if a&lt;u {a} else {u} }) }</code> <br> <br>    <br> <code class="cpp">struct A{ int *x; A(int v): x(new int(v)) {} ~A() {delete x;} }; int main() { A a(1), b=a; }</code> <br> ,    : <br> *** glibc detected *** demo: double free or corruption (fasttop): 0x0000000000601010 *** <br> <br>     Rust: <br> <code class="rust">struct A{ x: Box&lt;int&gt; } impl A { pub fn new(v: int) -&gt; A { A{ x: box v } } } impl Drop for A { fn drop(&amp;mut self) {} // ,     ++ } fn main() { let a = A::new(1); let _b = a; }</code> <br>     .   ,     <code>trait Copy</code> . <br> Rust       .    <code>Eq</code>  <code>Clone</code> ?    <code>deriving</code>   : <br> <code class="rust">#[deriving(Clone, Eq, Hash, PartialEq, PartialOrd, Ord, Show)] struct A{ x: Box&lt;int&gt; }</code> <br> <br>    <br> <code class="cpp">#include &lt;stdio.h&gt; struct X { int a, b; }; void swap_from(X&amp; x, const X&amp; y) { xa = yb; xb = ya; } int main() { X x = {1,2}; swap_from(x,x); printf("%d,%d\n", xa, xb); }</code> <br>  : <br> 2,2 <br>    ,    cc      .   ,   ,  99  <a href="http://en.wikipedia.org/wiki/Restrict">restrict</a> ,            :        . <br> <br>       Rust: <br> <code class="rust">struct X { pub a: int, pub b: int } fn swap_from(x: &amp;mut X, y: &amp;X) { xa = yb; xb = ya; } fn main() { let mut x = X{a:1, b:2}; swap_from(&amp;mut x, &amp;x); }</code> <br>    : <br> demo:7:24: 7:25 error: cannot borrow `x` as immutable because it is also borrowed as mutable <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> ^ <br> demo:7:20: 7:21 note: previous borrow of `x` occurs here; the mutable borrow prevents subsequent moves, borrows, or modification of `x` until the borrow ends <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> ^ <br> demo:7:26: 7:26 note: previous borrow ends here <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> <br>  ,             " <code>&amp;mut</code> "  " <code>&amp;</code> " ,   ,          ,   <code>&amp;mut</code> .            .  ,    ,      C99  <code>restrict</code>  (Rust  LLVM    ),    . <br> <br>   <br> <code class="cpp">#include &lt;vector&gt; int main() { std::vector&lt;int&gt; v; v.push_back(1); v.push_back(2); for(std::vector&lt;int&gt;::const_iterator it=v.begin(); it!=v.end(); ++it) { if (*it &lt; 5) v.push_back(5-*it); } }</code> <br>    ,    : <br> Segmentation fault (core dumped) <br> <br>    Rust: <br> <code class="rust">fn main() { let mut v: Vec&lt;int&gt; = Vec::new(); v.push(1); v.push(2); for x in v.iter() { if *x &lt; 5 { v.push(5-*x); } } }</code> <br>      ,  ,        : <br> demo:7:13: 7:14 error: cannot borrow `v` as mutable because it is also borrowed as immutable <br> demo:7 v.push(5-*x); <br> ^ <br> demo:5:14: 5:15 note: previous borrow of `v` occurs here; the immutable borrow prevents subsequent moves or mutable borrows of `v` until the borrow ends <br> demo:5 for x in v.iter() { <br> ^ <br> demo:10:2: 10:2 note: previous borrow ends here <br> demo:5 for x in v.iter() { <br> demo:6 if *x &lt; 5 { <br> demo:7 v.push(5-*x); <br> demo:8 } <br> demo:9 } <br> demo:10 } <br> <br> <br>  Switch <br> <code class="cpp">#include &lt;stdio.h&gt; enum {RED, BLUE, GRAY, UNKNOWN} color = GRAY; int main() { int x; switch(color) { case GRAY: x=1; case RED: case BLUE: x=2; } printf("%d", x); }</code> <br>   "2".  Rust          .  ,       ,    <code>break</code> .    Rust   : <br> <code class="rust">enum Color {RED, BLUE, GRAY, UNKNOWN} fn main() { let color = GRAY; let x = match color { GRAY =&gt; 1, RED | BLUE =&gt; 2, _ =&gt; 3, }; println!("{}", x); }</code> <br> <br>     <br> <code class="cpp">int main() { int pixels = 1; for (int j=0; j&lt;5; j++); pixels++; }</code> <br>  Rust          . , ,     . <br> <br>  <br> <code class="cpp">#include &lt;stdio.h&gt; #include &lt;pthread.h&gt; #include &lt;unistd.h&gt; class Resource { int *value; public: Resource(): value(NULL) {} ~Resource() {delete value;} int *acquire() { if (!value) { value = new int(0); } return value; } }; void* function(void *param) { int *value = ((Resource*)param)-&gt;acquire(); printf("resource: %p\n", (void*)value); return value; } int main() { Resource res; for (int i=0; i&lt;5; ++i) { pthread_t pt; pthread_create(&amp;pt, NULL, function, &amp;res); } //sleep(10); printf("done\n"); }</code> <br>     : <br> done <br> resource: 0x7f229c0008c0 <br> resource: 0x7f22840008c0 <br> resource: 0x7f228c0008c0 <br> resource: 0x7f22940008c0 <br> resource: 0x7f227c0008c0 <br> <br>     ,        .      Rust: <br> <code class="rust">struct Resource { value: Option&lt;int&gt;, } impl Resource { pub fn new() -&gt; Resource { Resource{ value: None } } pub fn acquire&lt;'a&gt;(&amp;'a mut self) -&gt; &amp;'a int { if self.value.is_none() { self.value = Some(1); } self.value.get_ref() } } fn main() { let mut res = Resource::new(); for _ in range(0,5) { spawn(proc() { let ptr = res.acquire(); println!("resource {}", ptr) }) } }</code> <br>  ,            . <br> demo:20:23: 20:26 error: cannot borrow immutable captured outer variable in a proc `res` as mutable <br> demo:20 let ptr = res.acquire(); <br> <br>      ,   : <br> <code class="rust">extern crate sync; use sync::{Arc, RWLock}; struct Resource { value: Option&lt;Box&lt;int&gt;&gt;, } impl Resource { pub fn new() -&gt; Resource { Resource{ value: None } } pub fn acquire(&amp;mut self) -&gt; *int { if self.value.is_none() { self.value = Some(box 1) } &amp;**self.value.get_ref() as *int } } fn main() { let arc_res = Arc::new(RWLock::new(Resource::new())); for _ in range(0,5) { let child_res = arc_res.clone(); spawn(proc() { let ptr = child_res.write().acquire(); println!("resource: {}", ptr) }) } }</code> <br>     <code>Arc</code> ( <i>Atomically Reference Counted</i> -        )  <code>RWLock</code> (   ).   : <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> <br>  ,   ++    .    . Rust        ,    .  ,   ,   .           ,       ( <a href="http://superwebdeveloper.com/2009/11/25/the-incredible-rate-of-diminishing-returns-of-fixing-software-bugs/">  </a> ). <br> <br>     <br> Rust        ,     <code>unsafe{}</code> .   ,     " <i> !  ,  .</i> ".  ,  ""  (    ,    )    .    ,           ( )  . , ,        <code>Cell</code>  <code>Mutex</code> .             ,       (   <a href="http://en.wikipedia.org/wiki/Test-driven_development">TDD</a> !). <br> <br>  <br> <a href="https://air.mozilla.org/guaranteeing-memory-safety-in-rust/">Guaranteeing Memory Safety in Rust (by Niko Matsakis)</a> <br> <a href="http://www.techtalkshub.com/rust-safe-systems-programming-fun-fp/">Rust: Safe Systems Programming with the Fun of FP (by Felix Klock II)</a> <br> <a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Keynote">Lang-NEXT: What ‚Äì if anything ‚Äì have we learned from C++? (by Bjarne Stroustrup)</a> <br> <a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Panel-Systems-Programming-Languages-in-2014-and-Beyond">Lang-NEXT Panel: Systems Programming in 2014 and Beyond</a></code></code> <blockquote> <code><code><code><code class="cpp">Box)     ,       (     ).        (std::rc::Rc)    (std::gc::Gc),      (   ). <br> <br></code>      <br>  ++: <br> #include &lt;stdio.h&gt; int *bar(int *p) { return p; } int* foo(int n) { return bar(&amp;n); } int main() { int *p1 = foo(1); int *p2 = foo(2); printf("%d, %d\n", *p1, *p2); }</code> <br>  : <br> 2, 2 <br> <br>  Rust: <br> <code class="rust">fn bar&lt;'a&gt;(p: &amp;'a int) -&gt; &amp;'a int { return p; } fn foo(n: int) -&gt; &amp;int { bar(&amp;n) } fn main() { let p1 = foo(1); let p2 = foo(2); println!("{}, {}", *p1, *p2); }</code> <br>  : <br> demo:5:10: 5:11 error: `n` does not live long enough <br> demo:5 bar(&amp;n) <br> ^ <br> demo:4:24: 6:2 note: reference must be valid for the anonymous lifetime #1 defined on the block at 4:23... <br> demo:4 fn foo(n: int) -&gt; &amp;int { <br> demo:5 bar(&amp;n) <br> demo:6 } <br> demo:4:24: 6:2 note: ...but borrowed value is only valid for the block at 4:23 <br> demo:4 fn foo(n: int) -&gt; &amp;int { <br> demo:5 bar(&amp;n) <br> demo:6 } <br> <br>   <br> <code class="cpp">#include &lt;stdio.h&gt; int minval(int *A, int n) { int currmin; for (int i=0; i&lt;n; i++) if (A[i] &lt; currmin) currmin = A[i]; return currmin; } int main() { int A[] = {1,2,3}; int min = minval(A,3); printf("%d\n", min); }</code> <br>   0  ,     , ,  .       Rust ( - ): <br> <code class="rust">fn minval(A: &amp;[int]) -&gt; int { let mut currmin; for a in A.iter() { if *a &lt; currmin { currmin = *a; } } currmin } fn main() { let A = [1i,2i,3i]; let min = minval(A.as_slice()); println!("{}", min); }</code> <br>  , : use of possibly uninitialized variable: `currmin` <br>   ( )      : <br> <code class="rust">fn minval(A: &amp;[int]) -&gt; int { A.iter().fold(A[0], |u,&amp;a| { if a&lt;u {a} else {u} }) }</code> <br> <br>    <br> <code class="cpp">struct A{ int *x; A(int v): x(new int(v)) {} ~A() {delete x;} }; int main() { A a(1), b=a; }</code> <br> ,    : <br> *** glibc detected *** demo: double free or corruption (fasttop): 0x0000000000601010 *** <br> <br>     Rust: <br> <code class="rust">struct A{ x: Box&lt;int&gt; } impl A { pub fn new(v: int) -&gt; A { A{ x: box v } } } impl Drop for A { fn drop(&amp;mut self) {} // ,     ++ } fn main() { let a = A::new(1); let _b = a; }</code> <br>     .   ,     <code>trait Copy</code> . <br> Rust       .    <code>Eq</code>  <code>Clone</code> ?    <code>deriving</code>   : <br> <code class="rust">#[deriving(Clone, Eq, Hash, PartialEq, PartialOrd, Ord, Show)] struct A{ x: Box&lt;int&gt; }</code> <br> <br>    <br> <code class="cpp">#include &lt;stdio.h&gt; struct X { int a, b; }; void swap_from(X&amp; x, const X&amp; y) { xa = yb; xb = ya; } int main() { X x = {1,2}; swap_from(x,x); printf("%d,%d\n", xa, xb); }</code> <br>  : <br> 2,2 <br>    ,    cc      .   ,   ,  99  <a href="http://en.wikipedia.org/wiki/Restrict">restrict</a> ,            :        . <br> <br>       Rust: <br> <code class="rust">struct X { pub a: int, pub b: int } fn swap_from(x: &amp;mut X, y: &amp;X) { xa = yb; xb = ya; } fn main() { let mut x = X{a:1, b:2}; swap_from(&amp;mut x, &amp;x); }</code> <br>    : <br> demo:7:24: 7:25 error: cannot borrow `x` as immutable because it is also borrowed as mutable <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> ^ <br> demo:7:20: 7:21 note: previous borrow of `x` occurs here; the mutable borrow prevents subsequent moves, borrows, or modification of `x` until the borrow ends <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> ^ <br> demo:7:26: 7:26 note: previous borrow ends here <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> <br>  ,             " <code>&amp;mut</code> "  " <code>&amp;</code> " ,   ,          ,   <code>&amp;mut</code> .            .  ,    ,      C99  <code>restrict</code>  (Rust  LLVM    ),    . <br> <br>   <br> <code class="cpp">#include &lt;vector&gt; int main() { std::vector&lt;int&gt; v; v.push_back(1); v.push_back(2); for(std::vector&lt;int&gt;::const_iterator it=v.begin(); it!=v.end(); ++it) { if (*it &lt; 5) v.push_back(5-*it); } }</code> <br>    ,    : <br> Segmentation fault (core dumped) <br> <br>    Rust: <br> <code class="rust">fn main() { let mut v: Vec&lt;int&gt; = Vec::new(); v.push(1); v.push(2); for x in v.iter() { if *x &lt; 5 { v.push(5-*x); } } }</code> <br>      ,  ,        : <br> demo:7:13: 7:14 error: cannot borrow `v` as mutable because it is also borrowed as immutable <br> demo:7 v.push(5-*x); <br> ^ <br> demo:5:14: 5:15 note: previous borrow of `v` occurs here; the immutable borrow prevents subsequent moves or mutable borrows of `v` until the borrow ends <br> demo:5 for x in v.iter() { <br> ^ <br> demo:10:2: 10:2 note: previous borrow ends here <br> demo:5 for x in v.iter() { <br> demo:6 if *x &lt; 5 { <br> demo:7 v.push(5-*x); <br> demo:8 } <br> demo:9 } <br> demo:10 } <br> <br> <br>  Switch <br> <code class="cpp">#include &lt;stdio.h&gt; enum {RED, BLUE, GRAY, UNKNOWN} color = GRAY; int main() { int x; switch(color) { case GRAY: x=1; case RED: case BLUE: x=2; } printf("%d", x); }</code> <br>   "2".  Rust          .  ,       ,    <code>break</code> .    Rust   : <br> <code class="rust">enum Color {RED, BLUE, GRAY, UNKNOWN} fn main() { let color = GRAY; let x = match color { GRAY =&gt; 1, RED | BLUE =&gt; 2, _ =&gt; 3, }; println!("{}", x); }</code> <br> <br>     <br> <code class="cpp">int main() { int pixels = 1; for (int j=0; j&lt;5; j++); pixels++; }</code> <br>  Rust          . , ,     . <br> <br>  <br> <code class="cpp">#include &lt;stdio.h&gt; #include &lt;pthread.h&gt; #include &lt;unistd.h&gt; class Resource { int *value; public: Resource(): value(NULL) {} ~Resource() {delete value;} int *acquire() { if (!value) { value = new int(0); } return value; } }; void* function(void *param) { int *value = ((Resource*)param)-&gt;acquire(); printf("resource: %p\n", (void*)value); return value; } int main() { Resource res; for (int i=0; i&lt;5; ++i) { pthread_t pt; pthread_create(&amp;pt, NULL, function, &amp;res); } //sleep(10); printf("done\n"); }</code> <br>     : <br> done <br> resource: 0x7f229c0008c0 <br> resource: 0x7f22840008c0 <br> resource: 0x7f228c0008c0 <br> resource: 0x7f22940008c0 <br> resource: 0x7f227c0008c0 <br> <br>     ,        .      Rust: <br> <code class="rust">struct Resource { value: Option&lt;int&gt;, } impl Resource { pub fn new() -&gt; Resource { Resource{ value: None } } pub fn acquire&lt;'a&gt;(&amp;'a mut self) -&gt; &amp;'a int { if self.value.is_none() { self.value = Some(1); } self.value.get_ref() } } fn main() { let mut res = Resource::new(); for _ in range(0,5) { spawn(proc() { let ptr = res.acquire(); println!("resource {}", ptr) }) } }</code> <br>  ,            . <br> demo:20:23: 20:26 error: cannot borrow immutable captured outer variable in a proc `res` as mutable <br> demo:20 let ptr = res.acquire(); <br> <br>      ,   : <br> <code class="rust">extern crate sync; use sync::{Arc, RWLock}; struct Resource { value: Option&lt;Box&lt;int&gt;&gt;, } impl Resource { pub fn new() -&gt; Resource { Resource{ value: None } } pub fn acquire(&amp;mut self) -&gt; *int { if self.value.is_none() { self.value = Some(box 1) } &amp;**self.value.get_ref() as *int } } fn main() { let arc_res = Arc::new(RWLock::new(Resource::new())); for _ in range(0,5) { let child_res = arc_res.clone(); spawn(proc() { let ptr = child_res.write().acquire(); println!("resource: {}", ptr) }) } }</code> <br>     <code>Arc</code> ( <i>Atomically Reference Counted</i> -        )  <code>RWLock</code> (   ).   : <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> <br>  ,   ++    .    . Rust        ,    .  ,   ,   .           ,       ( <a href="http://superwebdeveloper.com/2009/11/25/the-incredible-rate-of-diminishing-returns-of-fixing-software-bugs/">  </a> ). <br> <br>     <br> Rust        ,     <code>unsafe{}</code> .   ,     " <i> !  ,  .</i> ".  ,  ""  (    ,    )    .    ,           ( )  . , ,        <code>Cell</code>  <code>Mutex</code> .             ,       (   <a href="http://en.wikipedia.org/wiki/Test-driven_development">TDD</a> !). <br> <br>  <br> <a href="https://air.mozilla.org/guaranteeing-memory-safety-in-rust/">Guaranteeing Memory Safety in Rust (by Niko Matsakis)</a> <br> <a href="http://www.techtalkshub.com/rust-safe-systems-programming-fun-fp/">Rust: Safe Systems Programming with the Fun of FP (by Felix Klock II)</a> <br> <a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Keynote">Lang-NEXT: What ‚Äì if anything ‚Äì have we learned from C++? (by Bjarne Stroustrup)</a> <br> <a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Panel-Systems-Programming-Languages-in-2014-and-Beyond">Lang-NEXT Panel: Systems Programming in 2014 and Beyond</a></code></code> </blockquote> <code><code><code><code class="cpp">Box)     ,       (     ).        (std::rc::Rc)    (std::gc::Gc),      (   ). <br> <br></code>      <br>  ++: <br> #include &lt;stdio.h&gt; int *bar(int *p) { return p; } int* foo(int n) { return bar(&amp;n); } int main() { int *p1 = foo(1); int *p2 = foo(2); printf("%d, %d\n", *p1, *p2); }</code> <br>  : <br> 2, 2 <br> <br>  Rust: <br> <code class="rust">fn bar&lt;'a&gt;(p: &amp;'a int) -&gt; &amp;'a int { return p; } fn foo(n: int) -&gt; &amp;int { bar(&amp;n) } fn main() { let p1 = foo(1); let p2 = foo(2); println!("{}, {}", *p1, *p2); }</code> <br>  : <br> demo:5:10: 5:11 error: `n` does not live long enough <br> demo:5 bar(&amp;n) <br> ^ <br> demo:4:24: 6:2 note: reference must be valid for the anonymous lifetime #1 defined on the block at 4:23... <br> demo:4 fn foo(n: int) -&gt; &amp;int { <br> demo:5 bar(&amp;n) <br> demo:6 } <br> demo:4:24: 6:2 note: ...but borrowed value is only valid for the block at 4:23 <br> demo:4 fn foo(n: int) -&gt; &amp;int { <br> demo:5 bar(&amp;n) <br> demo:6 } <br> <br>   <br> <code class="cpp">#include &lt;stdio.h&gt; int minval(int *A, int n) { int currmin; for (int i=0; i&lt;n; i++) if (A[i] &lt; currmin) currmin = A[i]; return currmin; } int main() { int A[] = {1,2,3}; int min = minval(A,3); printf("%d\n", min); }</code> <br>   0  ,     , ,  .       Rust ( - ): <br> <code class="rust">fn minval(A: &amp;[int]) -&gt; int { let mut currmin; for a in A.iter() { if *a &lt; currmin { currmin = *a; } } currmin } fn main() { let A = [1i,2i,3i]; let min = minval(A.as_slice()); println!("{}", min); }</code> <br>  , : use of possibly uninitialized variable: `currmin` <br>   ( )      : <br> <code class="rust">fn minval(A: &amp;[int]) -&gt; int { A.iter().fold(A[0], |u,&amp;a| { if a&lt;u {a} else {u} }) }</code> <br> <br>    <br> <code class="cpp">struct A{ int *x; A(int v): x(new int(v)) {} ~A() {delete x;} }; int main() { A a(1), b=a; }</code> <br> ,    : <br> *** glibc detected *** demo: double free or corruption (fasttop): 0x0000000000601010 *** <br> <br>     Rust: <br> <code class="rust">struct A{ x: Box&lt;int&gt; } impl A { pub fn new(v: int) -&gt; A { A{ x: box v } } } impl Drop for A { fn drop(&amp;mut self) {} // ,     ++ } fn main() { let a = A::new(1); let _b = a; }</code> <br>     .   ,     <code>trait Copy</code> . <br> Rust       .    <code>Eq</code>  <code>Clone</code> ?    <code>deriving</code>   : <br> <code class="rust">#[deriving(Clone, Eq, Hash, PartialEq, PartialOrd, Ord, Show)] struct A{ x: Box&lt;int&gt; }</code> <br> <br>    <br> <code class="cpp">#include &lt;stdio.h&gt; struct X { int a, b; }; void swap_from(X&amp; x, const X&amp; y) { xa = yb; xb = ya; } int main() { X x = {1,2}; swap_from(x,x); printf("%d,%d\n", xa, xb); }</code> <br>  : <br> 2,2 <br>    ,    cc      .   ,   ,  99  <a href="http://en.wikipedia.org/wiki/Restrict">restrict</a> ,            :        . <br> <br>       Rust: <br> <code class="rust">struct X { pub a: int, pub b: int } fn swap_from(x: &amp;mut X, y: &amp;X) { xa = yb; xb = ya; } fn main() { let mut x = X{a:1, b:2}; swap_from(&amp;mut x, &amp;x); }</code> <br>    : <br> demo:7:24: 7:25 error: cannot borrow `x` as immutable because it is also borrowed as mutable <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> ^ <br> demo:7:20: 7:21 note: previous borrow of `x` occurs here; the mutable borrow prevents subsequent moves, borrows, or modification of `x` until the borrow ends <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> ^ <br> demo:7:26: 7:26 note: previous borrow ends here <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> <br>  ,             " <code>&amp;mut</code> "  " <code>&amp;</code> " ,   ,          ,   <code>&amp;mut</code> .            .  ,    ,      C99  <code>restrict</code>  (Rust  LLVM    ),    . <br> <br>   <br> <code class="cpp">#include &lt;vector&gt; int main() { std::vector&lt;int&gt; v; v.push_back(1); v.push_back(2); for(std::vector&lt;int&gt;::const_iterator it=v.begin(); it!=v.end(); ++it) { if (*it &lt; 5) v.push_back(5-*it); } }</code> <br>    ,    : <br> Segmentation fault (core dumped) <br> <br>    Rust: <br> <code class="rust">fn main() { let mut v: Vec&lt;int&gt; = Vec::new(); v.push(1); v.push(2); for x in v.iter() { if *x &lt; 5 { v.push(5-*x); } } }</code> <br>      ,  ,        : <br> demo:7:13: 7:14 error: cannot borrow `v` as mutable because it is also borrowed as immutable <br> demo:7 v.push(5-*x); <br> ^ <br> demo:5:14: 5:15 note: previous borrow of `v` occurs here; the immutable borrow prevents subsequent moves or mutable borrows of `v` until the borrow ends <br> demo:5 for x in v.iter() { <br> ^ <br> demo:10:2: 10:2 note: previous borrow ends here <br> demo:5 for x in v.iter() { <br> demo:6 if *x &lt; 5 { <br> demo:7 v.push(5-*x); <br> demo:8 } <br> demo:9 } <br> demo:10 } <br> <br> <br>  Switch <br> <code class="cpp">#include &lt;stdio.h&gt; enum {RED, BLUE, GRAY, UNKNOWN} color = GRAY; int main() { int x; switch(color) { case GRAY: x=1; case RED: case BLUE: x=2; } printf("%d", x); }</code> <br>   "2".  Rust          .  ,       ,    <code>break</code> .    Rust   : <br> <code class="rust">enum Color {RED, BLUE, GRAY, UNKNOWN} fn main() { let color = GRAY; let x = match color { GRAY =&gt; 1, RED | BLUE =&gt; 2, _ =&gt; 3, }; println!("{}", x); }</code> <br> <br>     <br> <code class="cpp">int main() { int pixels = 1; for (int j=0; j&lt;5; j++); pixels++; }</code> <br>  Rust          . , ,     . <br> <br>  <br> <code class="cpp">#include &lt;stdio.h&gt; #include &lt;pthread.h&gt; #include &lt;unistd.h&gt; class Resource { int *value; public: Resource(): value(NULL) {} ~Resource() {delete value;} int *acquire() { if (!value) { value = new int(0); } return value; } }; void* function(void *param) { int *value = ((Resource*)param)-&gt;acquire(); printf("resource: %p\n", (void*)value); return value; } int main() { Resource res; for (int i=0; i&lt;5; ++i) { pthread_t pt; pthread_create(&amp;pt, NULL, function, &amp;res); } //sleep(10); printf("done\n"); }</code> <br>     : <br> done <br> resource: 0x7f229c0008c0 <br> resource: 0x7f22840008c0 <br> resource: 0x7f228c0008c0 <br> resource: 0x7f22940008c0 <br> resource: 0x7f227c0008c0 <br> <br>     ,        .      Rust: <br> <code class="rust">struct Resource { value: Option&lt;int&gt;, } impl Resource { pub fn new() -&gt; Resource { Resource{ value: None } } pub fn acquire&lt;'a&gt;(&amp;'a mut self) -&gt; &amp;'a int { if self.value.is_none() { self.value = Some(1); } self.value.get_ref() } } fn main() { let mut res = Resource::new(); for _ in range(0,5) { spawn(proc() { let ptr = res.acquire(); println!("resource {}", ptr) }) } }</code> <br>  ,            . <br> demo:20:23: 20:26 error: cannot borrow immutable captured outer variable in a proc `res` as mutable <br> demo:20 let ptr = res.acquire(); <br> <br>      ,   : <br> <code class="rust">extern crate sync; use sync::{Arc, RWLock}; struct Resource { value: Option&lt;Box&lt;int&gt;&gt;, } impl Resource { pub fn new() -&gt; Resource { Resource{ value: None } } pub fn acquire(&amp;mut self) -&gt; *int { if self.value.is_none() { self.value = Some(box 1) } &amp;**self.value.get_ref() as *int } } fn main() { let arc_res = Arc::new(RWLock::new(Resource::new())); for _ in range(0,5) { let child_res = arc_res.clone(); spawn(proc() { let ptr = child_res.write().acquire(); println!("resource: {}", ptr) }) } }</code> <br>     <code>Arc</code> ( <i>Atomically Reference Counted</i> -        )  <code>RWLock</code> (   ).   : <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> <br>  ,   ++    .    . Rust        ,    .  ,   ,   .           ,       ( <a href="http://superwebdeveloper.com/2009/11/25/the-incredible-rate-of-diminishing-returns-of-fixing-software-bugs/">  </a> ). <br> <br>     <br> Rust        ,     <code>unsafe{}</code> .   ,     " <i> !  ,  .</i> ".  ,  ""  (    ,    )    .    ,           ( )  . , ,        <code>Cell</code>  <code>Mutex</code> .             ,       (   <a href="http://en.wikipedia.org/wiki/Test-driven_development">TDD</a> !). <br> <br>  <br> <a href="https://air.mozilla.org/guaranteeing-memory-safety-in-rust/">Guaranteeing Memory Safety in Rust (by Niko Matsakis)</a> <br> <a href="http://www.techtalkshub.com/rust-safe-systems-programming-fun-fp/">Rust: Safe Systems Programming with the Fun of FP (by Felix Klock II)</a> <br> <a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Keynote">Lang-NEXT: What ‚Äì if anything ‚Äì have we learned from C++? (by Bjarne Stroustrup)</a> <br> <a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Panel-Systems-Programming-Languages-in-2014-and-Beyond">Lang-NEXT Panel: Systems Programming in 2014 and Beyond</a></code></code> <h4> <code><code><code><code class="cpp">Box)     ,       (     ).        (std::rc::Rc)    (std::gc::Gc),      (   ). <br> <br></code>      <br>  ++: <br> #include &lt;stdio.h&gt; int *bar(int *p) { return p; } int* foo(int n) { return bar(&amp;n); } int main() { int *p1 = foo(1); int *p2 = foo(2); printf("%d, %d\n", *p1, *p2); }</code> <br>  : <br> 2, 2 <br> <br>  Rust: <br> <code class="rust">fn bar&lt;'a&gt;(p: &amp;'a int) -&gt; &amp;'a int { return p; } fn foo(n: int) -&gt; &amp;int { bar(&amp;n) } fn main() { let p1 = foo(1); let p2 = foo(2); println!("{}, {}", *p1, *p2); }</code> <br>  : <br> demo:5:10: 5:11 error: `n` does not live long enough <br> demo:5 bar(&amp;n) <br> ^ <br> demo:4:24: 6:2 note: reference must be valid for the anonymous lifetime #1 defined on the block at 4:23... <br> demo:4 fn foo(n: int) -&gt; &amp;int { <br> demo:5 bar(&amp;n) <br> demo:6 } <br> demo:4:24: 6:2 note: ...but borrowed value is only valid for the block at 4:23 <br> demo:4 fn foo(n: int) -&gt; &amp;int { <br> demo:5 bar(&amp;n) <br> demo:6 } <br> <br>   <br> <code class="cpp">#include &lt;stdio.h&gt; int minval(int *A, int n) { int currmin; for (int i=0; i&lt;n; i++) if (A[i] &lt; currmin) currmin = A[i]; return currmin; } int main() { int A[] = {1,2,3}; int min = minval(A,3); printf("%d\n", min); }</code> <br>   0  ,     , ,  .       Rust ( - ): <br> <code class="rust">fn minval(A: &amp;[int]) -&gt; int { let mut currmin; for a in A.iter() { if *a &lt; currmin { currmin = *a; } } currmin } fn main() { let A = [1i,2i,3i]; let min = minval(A.as_slice()); println!("{}", min); }</code> <br>  , : use of possibly uninitialized variable: `currmin` <br>   ( )      : <br> <code class="rust">fn minval(A: &amp;[int]) -&gt; int { A.iter().fold(A[0], |u,&amp;a| { if a&lt;u {a} else {u} }) }</code> <br> <br>    <br> <code class="cpp">struct A{ int *x; A(int v): x(new int(v)) {} ~A() {delete x;} }; int main() { A a(1), b=a; }</code> <br> ,    : <br> *** glibc detected *** demo: double free or corruption (fasttop): 0x0000000000601010 *** <br> <br>     Rust: <br> <code class="rust">struct A{ x: Box&lt;int&gt; } impl A { pub fn new(v: int) -&gt; A { A{ x: box v } } } impl Drop for A { fn drop(&amp;mut self) {} // ,     ++ } fn main() { let a = A::new(1); let _b = a; }</code> <br>     .   ,     <code>trait Copy</code> . <br> Rust       .    <code>Eq</code>  <code>Clone</code> ?    <code>deriving</code>   : <br> <code class="rust">#[deriving(Clone, Eq, Hash, PartialEq, PartialOrd, Ord, Show)] struct A{ x: Box&lt;int&gt; }</code> <br> <br>    <br> <code class="cpp">#include &lt;stdio.h&gt; struct X { int a, b; }; void swap_from(X&amp; x, const X&amp; y) { xa = yb; xb = ya; } int main() { X x = {1,2}; swap_from(x,x); printf("%d,%d\n", xa, xb); }</code> <br>  : <br> 2,2 <br>    ,    cc      .   ,   ,  99  <a href="http://en.wikipedia.org/wiki/Restrict">restrict</a> ,            :        . <br> <br>       Rust: <br> <code class="rust">struct X { pub a: int, pub b: int } fn swap_from(x: &amp;mut X, y: &amp;X) { xa = yb; xb = ya; } fn main() { let mut x = X{a:1, b:2}; swap_from(&amp;mut x, &amp;x); }</code> <br>    : <br> demo:7:24: 7:25 error: cannot borrow `x` as immutable because it is also borrowed as mutable <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> ^ <br> demo:7:20: 7:21 note: previous borrow of `x` occurs here; the mutable borrow prevents subsequent moves, borrows, or modification of `x` until the borrow ends <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> ^ <br> demo:7:26: 7:26 note: previous borrow ends here <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> <br>  ,             " <code>&amp;mut</code> "  " <code>&amp;</code> " ,   ,          ,   <code>&amp;mut</code> .            .  ,    ,      C99  <code>restrict</code>  (Rust  LLVM    ),    . <br> <br>   <br> <code class="cpp">#include &lt;vector&gt; int main() { std::vector&lt;int&gt; v; v.push_back(1); v.push_back(2); for(std::vector&lt;int&gt;::const_iterator it=v.begin(); it!=v.end(); ++it) { if (*it &lt; 5) v.push_back(5-*it); } }</code> <br>    ,    : <br> Segmentation fault (core dumped) <br> <br>    Rust: <br> <code class="rust">fn main() { let mut v: Vec&lt;int&gt; = Vec::new(); v.push(1); v.push(2); for x in v.iter() { if *x &lt; 5 { v.push(5-*x); } } }</code> <br>      ,  ,        : <br> demo:7:13: 7:14 error: cannot borrow `v` as mutable because it is also borrowed as immutable <br> demo:7 v.push(5-*x); <br> ^ <br> demo:5:14: 5:15 note: previous borrow of `v` occurs here; the immutable borrow prevents subsequent moves or mutable borrows of `v` until the borrow ends <br> demo:5 for x in v.iter() { <br> ^ <br> demo:10:2: 10:2 note: previous borrow ends here <br> demo:5 for x in v.iter() { <br> demo:6 if *x &lt; 5 { <br> demo:7 v.push(5-*x); <br> demo:8 } <br> demo:9 } <br> demo:10 } <br> <br> <br>  Switch <br> <code class="cpp">#include &lt;stdio.h&gt; enum {RED, BLUE, GRAY, UNKNOWN} color = GRAY; int main() { int x; switch(color) { case GRAY: x=1; case RED: case BLUE: x=2; } printf("%d", x); }</code> <br>   "2".  Rust          .  ,       ,    <code>break</code> .    Rust   : <br> <code class="rust">enum Color {RED, BLUE, GRAY, UNKNOWN} fn main() { let color = GRAY; let x = match color { GRAY =&gt; 1, RED | BLUE =&gt; 2, _ =&gt; 3, }; println!("{}", x); }</code> <br> <br>     <br> <code class="cpp">int main() { int pixels = 1; for (int j=0; j&lt;5; j++); pixels++; }</code> <br>  Rust          . , ,     . <br> <br>  <br> <code class="cpp">#include &lt;stdio.h&gt; #include &lt;pthread.h&gt; #include &lt;unistd.h&gt; class Resource { int *value; public: Resource(): value(NULL) {} ~Resource() {delete value;} int *acquire() { if (!value) { value = new int(0); } return value; } }; void* function(void *param) { int *value = ((Resource*)param)-&gt;acquire(); printf("resource: %p\n", (void*)value); return value; } int main() { Resource res; for (int i=0; i&lt;5; ++i) { pthread_t pt; pthread_create(&amp;pt, NULL, function, &amp;res); } //sleep(10); printf("done\n"); }</code> <br>     : <br> done <br> resource: 0x7f229c0008c0 <br> resource: 0x7f22840008c0 <br> resource: 0x7f228c0008c0 <br> resource: 0x7f22940008c0 <br> resource: 0x7f227c0008c0 <br> <br>     ,        .      Rust: <br> <code class="rust">struct Resource { value: Option&lt;int&gt;, } impl Resource { pub fn new() -&gt; Resource { Resource{ value: None } } pub fn acquire&lt;'a&gt;(&amp;'a mut self) -&gt; &amp;'a int { if self.value.is_none() { self.value = Some(1); } self.value.get_ref() } } fn main() { let mut res = Resource::new(); for _ in range(0,5) { spawn(proc() { let ptr = res.acquire(); println!("resource {}", ptr) }) } }</code> <br>  ,            . <br> demo:20:23: 20:26 error: cannot borrow immutable captured outer variable in a proc `res` as mutable <br> demo:20 let ptr = res.acquire(); <br> <br>      ,   : <br> <code class="rust">extern crate sync; use sync::{Arc, RWLock}; struct Resource { value: Option&lt;Box&lt;int&gt;&gt;, } impl Resource { pub fn new() -&gt; Resource { Resource{ value: None } } pub fn acquire(&amp;mut self) -&gt; *int { if self.value.is_none() { self.value = Some(box 1) } &amp;**self.value.get_ref() as *int } } fn main() { let arc_res = Arc::new(RWLock::new(Resource::new())); for _ in range(0,5) { let child_res = arc_res.clone(); spawn(proc() { let ptr = child_res.write().acquire(); println!("resource: {}", ptr) }) } }</code> <br>     <code>Arc</code> ( <i>Atomically Reference Counted</i> -        )  <code>RWLock</code> (   ).   : <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> <br>  ,   ++    .    . Rust        ,    .  ,   ,   .           ,       ( <a href="http://superwebdeveloper.com/2009/11/25/the-incredible-rate-of-diminishing-returns-of-fixing-software-bugs/">  </a> ). <br> <br>     <br> Rust        ,     <code>unsafe{}</code> .   ,     " <i> !  ,  .</i> ".  ,  ""  (    ,    )    .    ,           ( )  . , ,        <code>Cell</code>  <code>Mutex</code> .             ,       (   <a href="http://en.wikipedia.org/wiki/Test-driven_development">TDD</a> !). <br> <br>  <br> <a href="https://air.mozilla.org/guaranteeing-memory-safety-in-rust/">Guaranteeing Memory Safety in Rust (by Niko Matsakis)</a> <br> <a href="http://www.techtalkshub.com/rust-safe-systems-programming-fun-fp/">Rust: Safe Systems Programming with the Fun of FP (by Felix Klock II)</a> <br> <a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Keynote">Lang-NEXT: What ‚Äì if anything ‚Äì have we learned from C++? (by Bjarne Stroustrup)</a> <br> <a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Panel-Systems-Programming-Languages-in-2014-and-Beyond">Lang-NEXT Panel: Systems Programming in 2014 and Beyond</a></code></code> </h4> <code><code><code><code class="cpp">Box)     ,       (     ).        (std::rc::Rc)    (std::gc::Gc),      (   ). <br> <br></code>      <br>  ++: <br> #include &lt;stdio.h&gt; int *bar(int *p) { return p; } int* foo(int n) { return bar(&amp;n); } int main() { int *p1 = foo(1); int *p2 = foo(2); printf("%d, %d\n", *p1, *p2); }</code> <br>  : <br> 2, 2 <br> <br>  Rust: <br> <code class="rust">fn bar&lt;'a&gt;(p: &amp;'a int) -&gt; &amp;'a int { return p; } fn foo(n: int) -&gt; &amp;int { bar(&amp;n) } fn main() { let p1 = foo(1); let p2 = foo(2); println!("{}, {}", *p1, *p2); }</code> <br>  : <br> demo:5:10: 5:11 error: `n` does not live long enough <br> demo:5 bar(&amp;n) <br> ^ <br> demo:4:24: 6:2 note: reference must be valid for the anonymous lifetime #1 defined on the block at 4:23... <br> demo:4 fn foo(n: int) -&gt; &amp;int { <br> demo:5 bar(&amp;n) <br> demo:6 } <br> demo:4:24: 6:2 note: ...but borrowed value is only valid for the block at 4:23 <br> demo:4 fn foo(n: int) -&gt; &amp;int { <br> demo:5 bar(&amp;n) <br> demo:6 } <br> <br>   <br> <code class="cpp">#include &lt;stdio.h&gt; int minval(int *A, int n) { int currmin; for (int i=0; i&lt;n; i++) if (A[i] &lt; currmin) currmin = A[i]; return currmin; } int main() { int A[] = {1,2,3}; int min = minval(A,3); printf("%d\n", min); }</code> <br>   0  ,     , ,  .       Rust ( - ): <br> <code class="rust">fn minval(A: &amp;[int]) -&gt; int { let mut currmin; for a in A.iter() { if *a &lt; currmin { currmin = *a; } } currmin } fn main() { let A = [1i,2i,3i]; let min = minval(A.as_slice()); println!("{}", min); }</code> <br>  , : use of possibly uninitialized variable: `currmin` <br>   ( )      : <br> <code class="rust">fn minval(A: &amp;[int]) -&gt; int { A.iter().fold(A[0], |u,&amp;a| { if a&lt;u {a} else {u} }) }</code> <br> <br>    <br> <code class="cpp">struct A{ int *x; A(int v): x(new int(v)) {} ~A() {delete x;} }; int main() { A a(1), b=a; }</code> <br> ,    : <br> *** glibc detected *** demo: double free or corruption (fasttop): 0x0000000000601010 *** <br> <br>     Rust: <br> <code class="rust">struct A{ x: Box&lt;int&gt; } impl A { pub fn new(v: int) -&gt; A { A{ x: box v } } } impl Drop for A { fn drop(&amp;mut self) {} // ,     ++ } fn main() { let a = A::new(1); let _b = a; }</code> <br>     .   ,     <code>trait Copy</code> . <br> Rust       .    <code>Eq</code>  <code>Clone</code> ?    <code>deriving</code>   : <br> <code class="rust">#[deriving(Clone, Eq, Hash, PartialEq, PartialOrd, Ord, Show)] struct A{ x: Box&lt;int&gt; }</code> <br> <br>    <br> <code class="cpp">#include &lt;stdio.h&gt; struct X { int a, b; }; void swap_from(X&amp; x, const X&amp; y) { xa = yb; xb = ya; } int main() { X x = {1,2}; swap_from(x,x); printf("%d,%d\n", xa, xb); }</code> <br>  : <br> 2,2 <br>    ,    cc      .   ,   ,  99  <a href="http://en.wikipedia.org/wiki/Restrict">restrict</a> ,            :        . <br> <br>       Rust: <br> <code class="rust">struct X { pub a: int, pub b: int } fn swap_from(x: &amp;mut X, y: &amp;X) { xa = yb; xb = ya; } fn main() { let mut x = X{a:1, b:2}; swap_from(&amp;mut x, &amp;x); }</code> <br>    : <br> demo:7:24: 7:25 error: cannot borrow `x` as immutable because it is also borrowed as mutable <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> ^ <br> demo:7:20: 7:21 note: previous borrow of `x` occurs here; the mutable borrow prevents subsequent moves, borrows, or modification of `x` until the borrow ends <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> ^ <br> demo:7:26: 7:26 note: previous borrow ends here <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> <br>  ,             " <code>&amp;mut</code> "  " <code>&amp;</code> " ,   ,          ,   <code>&amp;mut</code> .            .  ,    ,      C99  <code>restrict</code>  (Rust  LLVM    ),    . <br> <br>   <br> <code class="cpp">#include &lt;vector&gt; int main() { std::vector&lt;int&gt; v; v.push_back(1); v.push_back(2); for(std::vector&lt;int&gt;::const_iterator it=v.begin(); it!=v.end(); ++it) { if (*it &lt; 5) v.push_back(5-*it); } }</code> <br>    ,    : <br> Segmentation fault (core dumped) <br> <br>    Rust: <br> <code class="rust">fn main() { let mut v: Vec&lt;int&gt; = Vec::new(); v.push(1); v.push(2); for x in v.iter() { if *x &lt; 5 { v.push(5-*x); } } }</code> <br>      ,  ,        : <br> demo:7:13: 7:14 error: cannot borrow `v` as mutable because it is also borrowed as immutable <br> demo:7 v.push(5-*x); <br> ^ <br> demo:5:14: 5:15 note: previous borrow of `v` occurs here; the immutable borrow prevents subsequent moves or mutable borrows of `v` until the borrow ends <br> demo:5 for x in v.iter() { <br> ^ <br> demo:10:2: 10:2 note: previous borrow ends here <br> demo:5 for x in v.iter() { <br> demo:6 if *x &lt; 5 { <br> demo:7 v.push(5-*x); <br> demo:8 } <br> demo:9 } <br> demo:10 } <br> <br> <br>  Switch <br> <code class="cpp">#include &lt;stdio.h&gt; enum {RED, BLUE, GRAY, UNKNOWN} color = GRAY; int main() { int x; switch(color) { case GRAY: x=1; case RED: case BLUE: x=2; } printf("%d", x); }</code> <br>   "2".  Rust          .  ,       ,    <code>break</code> .    Rust   : <br> <code class="rust">enum Color {RED, BLUE, GRAY, UNKNOWN} fn main() { let color = GRAY; let x = match color { GRAY =&gt; 1, RED | BLUE =&gt; 2, _ =&gt; 3, }; println!("{}", x); }</code> <br> <br>     <br> <code class="cpp">int main() { int pixels = 1; for (int j=0; j&lt;5; j++); pixels++; }</code> <br>  Rust          . , ,     . <br> <br>  <br> <code class="cpp">#include &lt;stdio.h&gt; #include &lt;pthread.h&gt; #include &lt;unistd.h&gt; class Resource { int *value; public: Resource(): value(NULL) {} ~Resource() {delete value;} int *acquire() { if (!value) { value = new int(0); } return value; } }; void* function(void *param) { int *value = ((Resource*)param)-&gt;acquire(); printf("resource: %p\n", (void*)value); return value; } int main() { Resource res; for (int i=0; i&lt;5; ++i) { pthread_t pt; pthread_create(&amp;pt, NULL, function, &amp;res); } //sleep(10); printf("done\n"); }</code> <br>     : <br> done <br> resource: 0x7f229c0008c0 <br> resource: 0x7f22840008c0 <br> resource: 0x7f228c0008c0 <br> resource: 0x7f22940008c0 <br> resource: 0x7f227c0008c0 <br> <br>     ,        .      Rust: <br> <code class="rust">struct Resource { value: Option&lt;int&gt;, } impl Resource { pub fn new() -&gt; Resource { Resource{ value: None } } pub fn acquire&lt;'a&gt;(&amp;'a mut self) -&gt; &amp;'a int { if self.value.is_none() { self.value = Some(1); } self.value.get_ref() } } fn main() { let mut res = Resource::new(); for _ in range(0,5) { spawn(proc() { let ptr = res.acquire(); println!("resource {}", ptr) }) } }</code> <br>  ,            . <br> demo:20:23: 20:26 error: cannot borrow immutable captured outer variable in a proc `res` as mutable <br> demo:20 let ptr = res.acquire(); <br> <br>      ,   : <br> <code class="rust">extern crate sync; use sync::{Arc, RWLock}; struct Resource { value: Option&lt;Box&lt;int&gt;&gt;, } impl Resource { pub fn new() -&gt; Resource { Resource{ value: None } } pub fn acquire(&amp;mut self) -&gt; *int { if self.value.is_none() { self.value = Some(box 1) } &amp;**self.value.get_ref() as *int } } fn main() { let arc_res = Arc::new(RWLock::new(Resource::new())); for _ in range(0,5) { let child_res = arc_res.clone(); spawn(proc() { let ptr = child_res.write().acquire(); println!("resource: {}", ptr) }) } }</code> <br>     <code>Arc</code> ( <i>Atomically Reference Counted</i> -        )  <code>RWLock</code> (   ).   : <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> <br>  ,   ++    .    . Rust        ,    .  ,   ,   .           ,       ( <a href="http://superwebdeveloper.com/2009/11/25/the-incredible-rate-of-diminishing-returns-of-fixing-software-bugs/">  </a> ). <br> <br>     <br> Rust        ,     <code>unsafe{}</code> .   ,     " <i> !  ,  .</i> ".  ,  ""  (    ,    )    .    ,           ( )  . , ,        <code>Cell</code>  <code>Mutex</code> .             ,       (   <a href="http://en.wikipedia.org/wiki/Test-driven_development">TDD</a> !). <br> <br>  <br> <a href="https://air.mozilla.org/guaranteeing-memory-safety-in-rust/">Guaranteeing Memory Safety in Rust (by Niko Matsakis)</a> <br> <a href="http://www.techtalkshub.com/rust-safe-systems-programming-fun-fp/">Rust: Safe Systems Programming with the Fun of FP (by Felix Klock II)</a> <br> <a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Keynote">Lang-NEXT: What ‚Äì if anything ‚Äì have we learned from C++? (by Bjarne Stroustrup)</a> <br> <a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Panel-Systems-Programming-Languages-in-2014-and-Beyond">Lang-NEXT Panel: Systems Programming in 2014 and Beyond</a></code></code> <h3> <code><code><code><code class="cpp">Box)     ,       (     ).        (std::rc::Rc)    (std::gc::Gc),      (   ). <br> <br></code>      <br>  ++: <br> #include &lt;stdio.h&gt; int *bar(int *p) { return p; } int* foo(int n) { return bar(&amp;n); } int main() { int *p1 = foo(1); int *p2 = foo(2); printf("%d, %d\n", *p1, *p2); }</code> <br>  : <br> 2, 2 <br> <br>  Rust: <br> <code class="rust">fn bar&lt;'a&gt;(p: &amp;'a int) -&gt; &amp;'a int { return p; } fn foo(n: int) -&gt; &amp;int { bar(&amp;n) } fn main() { let p1 = foo(1); let p2 = foo(2); println!("{}, {}", *p1, *p2); }</code> <br>  : <br> demo:5:10: 5:11 error: `n` does not live long enough <br> demo:5 bar(&amp;n) <br> ^ <br> demo:4:24: 6:2 note: reference must be valid for the anonymous lifetime #1 defined on the block at 4:23... <br> demo:4 fn foo(n: int) -&gt; &amp;int { <br> demo:5 bar(&amp;n) <br> demo:6 } <br> demo:4:24: 6:2 note: ...but borrowed value is only valid for the block at 4:23 <br> demo:4 fn foo(n: int) -&gt; &amp;int { <br> demo:5 bar(&amp;n) <br> demo:6 } <br> <br>   <br> <code class="cpp">#include &lt;stdio.h&gt; int minval(int *A, int n) { int currmin; for (int i=0; i&lt;n; i++) if (A[i] &lt; currmin) currmin = A[i]; return currmin; } int main() { int A[] = {1,2,3}; int min = minval(A,3); printf("%d\n", min); }</code> <br>   0  ,     , ,  .       Rust ( - ): <br> <code class="rust">fn minval(A: &amp;[int]) -&gt; int { let mut currmin; for a in A.iter() { if *a &lt; currmin { currmin = *a; } } currmin } fn main() { let A = [1i,2i,3i]; let min = minval(A.as_slice()); println!("{}", min); }</code> <br>  , : use of possibly uninitialized variable: `currmin` <br>   ( )      : <br> <code class="rust">fn minval(A: &amp;[int]) -&gt; int { A.iter().fold(A[0], |u,&amp;a| { if a&lt;u {a} else {u} }) }</code> <br> <br>    <br> <code class="cpp">struct A{ int *x; A(int v): x(new int(v)) {} ~A() {delete x;} }; int main() { A a(1), b=a; }</code> <br> ,    : <br> *** glibc detected *** demo: double free or corruption (fasttop): 0x0000000000601010 *** <br> <br>     Rust: <br> <code class="rust">struct A{ x: Box&lt;int&gt; } impl A { pub fn new(v: int) -&gt; A { A{ x: box v } } } impl Drop for A { fn drop(&amp;mut self) {} // ,     ++ } fn main() { let a = A::new(1); let _b = a; }</code> <br>     .   ,     <code>trait Copy</code> . <br> Rust       .    <code>Eq</code>  <code>Clone</code> ?    <code>deriving</code>   : <br> <code class="rust">#[deriving(Clone, Eq, Hash, PartialEq, PartialOrd, Ord, Show)] struct A{ x: Box&lt;int&gt; }</code> <br> <br>    <br> <code class="cpp">#include &lt;stdio.h&gt; struct X { int a, b; }; void swap_from(X&amp; x, const X&amp; y) { xa = yb; xb = ya; } int main() { X x = {1,2}; swap_from(x,x); printf("%d,%d\n", xa, xb); }</code> <br>  : <br> 2,2 <br>    ,    cc      .   ,   ,  99  <a href="http://en.wikipedia.org/wiki/Restrict">restrict</a> ,            :        . <br> <br>       Rust: <br> <code class="rust">struct X { pub a: int, pub b: int } fn swap_from(x: &amp;mut X, y: &amp;X) { xa = yb; xb = ya; } fn main() { let mut x = X{a:1, b:2}; swap_from(&amp;mut x, &amp;x); }</code> <br>    : <br> demo:7:24: 7:25 error: cannot borrow `x` as immutable because it is also borrowed as mutable <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> ^ <br> demo:7:20: 7:21 note: previous borrow of `x` occurs here; the mutable borrow prevents subsequent moves, borrows, or modification of `x` until the borrow ends <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> ^ <br> demo:7:26: 7:26 note: previous borrow ends here <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> <br>  ,             " <code>&amp;mut</code> "  " <code>&amp;</code> " ,   ,          ,   <code>&amp;mut</code> .            .  ,    ,      C99  <code>restrict</code>  (Rust  LLVM    ),    . <br> <br>   <br> <code class="cpp">#include &lt;vector&gt; int main() { std::vector&lt;int&gt; v; v.push_back(1); v.push_back(2); for(std::vector&lt;int&gt;::const_iterator it=v.begin(); it!=v.end(); ++it) { if (*it &lt; 5) v.push_back(5-*it); } }</code> <br>    ,    : <br> Segmentation fault (core dumped) <br> <br>    Rust: <br> <code class="rust">fn main() { let mut v: Vec&lt;int&gt; = Vec::new(); v.push(1); v.push(2); for x in v.iter() { if *x &lt; 5 { v.push(5-*x); } } }</code> <br>      ,  ,        : <br> demo:7:13: 7:14 error: cannot borrow `v` as mutable because it is also borrowed as immutable <br> demo:7 v.push(5-*x); <br> ^ <br> demo:5:14: 5:15 note: previous borrow of `v` occurs here; the immutable borrow prevents subsequent moves or mutable borrows of `v` until the borrow ends <br> demo:5 for x in v.iter() { <br> ^ <br> demo:10:2: 10:2 note: previous borrow ends here <br> demo:5 for x in v.iter() { <br> demo:6 if *x &lt; 5 { <br> demo:7 v.push(5-*x); <br> demo:8 } <br> demo:9 } <br> demo:10 } <br> <br> <br>  Switch <br> <code class="cpp">#include &lt;stdio.h&gt; enum {RED, BLUE, GRAY, UNKNOWN} color = GRAY; int main() { int x; switch(color) { case GRAY: x=1; case RED: case BLUE: x=2; } printf("%d", x); }</code> <br>   "2".  Rust          .  ,       ,    <code>break</code> .    Rust   : <br> <code class="rust">enum Color {RED, BLUE, GRAY, UNKNOWN} fn main() { let color = GRAY; let x = match color { GRAY =&gt; 1, RED | BLUE =&gt; 2, _ =&gt; 3, }; println!("{}", x); }</code> <br> <br>     <br> <code class="cpp">int main() { int pixels = 1; for (int j=0; j&lt;5; j++); pixels++; }</code> <br>  Rust          . , ,     . <br> <br>  <br> <code class="cpp">#include &lt;stdio.h&gt; #include &lt;pthread.h&gt; #include &lt;unistd.h&gt; class Resource { int *value; public: Resource(): value(NULL) {} ~Resource() {delete value;} int *acquire() { if (!value) { value = new int(0); } return value; } }; void* function(void *param) { int *value = ((Resource*)param)-&gt;acquire(); printf("resource: %p\n", (void*)value); return value; } int main() { Resource res; for (int i=0; i&lt;5; ++i) { pthread_t pt; pthread_create(&amp;pt, NULL, function, &amp;res); } //sleep(10); printf("done\n"); }</code> <br>     : <br> done <br> resource: 0x7f229c0008c0 <br> resource: 0x7f22840008c0 <br> resource: 0x7f228c0008c0 <br> resource: 0x7f22940008c0 <br> resource: 0x7f227c0008c0 <br> <br>     ,        .      Rust: <br> <code class="rust">struct Resource { value: Option&lt;int&gt;, } impl Resource { pub fn new() -&gt; Resource { Resource{ value: None } } pub fn acquire&lt;'a&gt;(&amp;'a mut self) -&gt; &amp;'a int { if self.value.is_none() { self.value = Some(1); } self.value.get_ref() } } fn main() { let mut res = Resource::new(); for _ in range(0,5) { spawn(proc() { let ptr = res.acquire(); println!("resource {}", ptr) }) } }</code> <br>  ,            . <br> demo:20:23: 20:26 error: cannot borrow immutable captured outer variable in a proc `res` as mutable <br> demo:20 let ptr = res.acquire(); <br> <br>      ,   : <br> <code class="rust">extern crate sync; use sync::{Arc, RWLock}; struct Resource { value: Option&lt;Box&lt;int&gt;&gt;, } impl Resource { pub fn new() -&gt; Resource { Resource{ value: None } } pub fn acquire(&amp;mut self) -&gt; *int { if self.value.is_none() { self.value = Some(box 1) } &amp;**self.value.get_ref() as *int } } fn main() { let arc_res = Arc::new(RWLock::new(Resource::new())); for _ in range(0,5) { let child_res = arc_res.clone(); spawn(proc() { let ptr = child_res.write().acquire(); println!("resource: {}", ptr) }) } }</code> <br>     <code>Arc</code> ( <i>Atomically Reference Counted</i> -        )  <code>RWLock</code> (   ).   : <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> <br>  ,   ++    .    . Rust        ,    .  ,   ,   .           ,       ( <a href="http://superwebdeveloper.com/2009/11/25/the-incredible-rate-of-diminishing-returns-of-fixing-software-bugs/">  </a> ). <br> <br>     <br> Rust        ,     <code>unsafe{}</code> .   ,     " <i> !  ,  .</i> ".  ,  ""  (    ,    )    .    ,           ( )  . , ,        <code>Cell</code>  <code>Mutex</code> .             ,       (   <a href="http://en.wikipedia.org/wiki/Test-driven_development">TDD</a> !). <br> <br>  <br> <a href="https://air.mozilla.org/guaranteeing-memory-safety-in-rust/">Guaranteeing Memory Safety in Rust (by Niko Matsakis)</a> <br> <a href="http://www.techtalkshub.com/rust-safe-systems-programming-fun-fp/">Rust: Safe Systems Programming with the Fun of FP (by Felix Klock II)</a> <br> <a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Keynote">Lang-NEXT: What ‚Äì if anything ‚Äì have we learned from C++? (by Bjarne Stroustrup)</a> <br> <a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Panel-Systems-Programming-Languages-in-2014-and-Beyond">Lang-NEXT Panel: Systems Programming in 2014 and Beyond</a></code></code> </h3> <code><code><code><code class="cpp">Box)     ,       (     ).        (std::rc::Rc)    (std::gc::Gc),      (   ). <br> <br></code>      <br>  ++: <br> #include &lt;stdio.h&gt; int *bar(int *p) { return p; } int* foo(int n) { return bar(&amp;n); } int main() { int *p1 = foo(1); int *p2 = foo(2); printf("%d, %d\n", *p1, *p2); }</code> <br>  : <br> 2, 2 <br> <br>  Rust: <br> <code class="rust">fn bar&lt;'a&gt;(p: &amp;'a int) -&gt; &amp;'a int { return p; } fn foo(n: int) -&gt; &amp;int { bar(&amp;n) } fn main() { let p1 = foo(1); let p2 = foo(2); println!("{}, {}", *p1, *p2); }</code> <br>  : <br> demo:5:10: 5:11 error: `n` does not live long enough <br> demo:5 bar(&amp;n) <br> ^ <br> demo:4:24: 6:2 note: reference must be valid for the anonymous lifetime #1 defined on the block at 4:23... <br> demo:4 fn foo(n: int) -&gt; &amp;int { <br> demo:5 bar(&amp;n) <br> demo:6 } <br> demo:4:24: 6:2 note: ...but borrowed value is only valid for the block at 4:23 <br> demo:4 fn foo(n: int) -&gt; &amp;int { <br> demo:5 bar(&amp;n) <br> demo:6 } <br> <br>   <br> <code class="cpp">#include &lt;stdio.h&gt; int minval(int *A, int n) { int currmin; for (int i=0; i&lt;n; i++) if (A[i] &lt; currmin) currmin = A[i]; return currmin; } int main() { int A[] = {1,2,3}; int min = minval(A,3); printf("%d\n", min); }</code> <br>   0  ,     , ,  .       Rust ( - ): <br> <code class="rust">fn minval(A: &amp;[int]) -&gt; int { let mut currmin; for a in A.iter() { if *a &lt; currmin { currmin = *a; } } currmin } fn main() { let A = [1i,2i,3i]; let min = minval(A.as_slice()); println!("{}", min); }</code> <br>  , : use of possibly uninitialized variable: `currmin` <br>   ( )      : <br> <code class="rust">fn minval(A: &amp;[int]) -&gt; int { A.iter().fold(A[0], |u,&amp;a| { if a&lt;u {a} else {u} }) }</code> <br> <br>    <br> <code class="cpp">struct A{ int *x; A(int v): x(new int(v)) {} ~A() {delete x;} }; int main() { A a(1), b=a; }</code> <br> ,    : <br> *** glibc detected *** demo: double free or corruption (fasttop): 0x0000000000601010 *** <br> <br>     Rust: <br> <code class="rust">struct A{ x: Box&lt;int&gt; } impl A { pub fn new(v: int) -&gt; A { A{ x: box v } } } impl Drop for A { fn drop(&amp;mut self) {} // ,     ++ } fn main() { let a = A::new(1); let _b = a; }</code> <br>     .   ,     <code>trait Copy</code> . <br> Rust       .    <code>Eq</code>  <code>Clone</code> ?    <code>deriving</code>   : <br> <code class="rust">#[deriving(Clone, Eq, Hash, PartialEq, PartialOrd, Ord, Show)] struct A{ x: Box&lt;int&gt; }</code> <br> <br>    <br> <code class="cpp">#include &lt;stdio.h&gt; struct X { int a, b; }; void swap_from(X&amp; x, const X&amp; y) { xa = yb; xb = ya; } int main() { X x = {1,2}; swap_from(x,x); printf("%d,%d\n", xa, xb); }</code> <br>  : <br> 2,2 <br>    ,    cc      .   ,   ,  99  <a href="http://en.wikipedia.org/wiki/Restrict">restrict</a> ,            :        . <br> <br>       Rust: <br> <code class="rust">struct X { pub a: int, pub b: int } fn swap_from(x: &amp;mut X, y: &amp;X) { xa = yb; xb = ya; } fn main() { let mut x = X{a:1, b:2}; swap_from(&amp;mut x, &amp;x); }</code> <br>    : <br> demo:7:24: 7:25 error: cannot borrow `x` as immutable because it is also borrowed as mutable <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> ^ <br> demo:7:20: 7:21 note: previous borrow of `x` occurs here; the mutable borrow prevents subsequent moves, borrows, or modification of `x` until the borrow ends <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> ^ <br> demo:7:26: 7:26 note: previous borrow ends here <br> demo:7 swap_from(&amp;mut x, &amp;x); <br> <br>  ,             " <code>&amp;mut</code> "  " <code>&amp;</code> " ,   ,          ,   <code>&amp;mut</code> .            .  ,    ,      C99  <code>restrict</code>  (Rust  LLVM    ),    . <br> <br>   <br> <code class="cpp">#include &lt;vector&gt; int main() { std::vector&lt;int&gt; v; v.push_back(1); v.push_back(2); for(std::vector&lt;int&gt;::const_iterator it=v.begin(); it!=v.end(); ++it) { if (*it &lt; 5) v.push_back(5-*it); } }</code> <br>    ,    : <br> Segmentation fault (core dumped) <br> <br>    Rust: <br> <code class="rust">fn main() { let mut v: Vec&lt;int&gt; = Vec::new(); v.push(1); v.push(2); for x in v.iter() { if *x &lt; 5 { v.push(5-*x); } } }</code> <br>      ,  ,        : <br> demo:7:13: 7:14 error: cannot borrow `v` as mutable because it is also borrowed as immutable <br> demo:7 v.push(5-*x); <br> ^ <br> demo:5:14: 5:15 note: previous borrow of `v` occurs here; the immutable borrow prevents subsequent moves or mutable borrows of `v` until the borrow ends <br> demo:5 for x in v.iter() { <br> ^ <br> demo:10:2: 10:2 note: previous borrow ends here <br> demo:5 for x in v.iter() { <br> demo:6 if *x &lt; 5 { <br> demo:7 v.push(5-*x); <br> demo:8 } <br> demo:9 } <br> demo:10 } <br> <br> <br>  Switch <br> <code class="cpp">#include &lt;stdio.h&gt; enum {RED, BLUE, GRAY, UNKNOWN} color = GRAY; int main() { int x; switch(color) { case GRAY: x=1; case RED: case BLUE: x=2; } printf("%d", x); }</code> <br>   "2".  Rust          .  ,       ,    <code>break</code> .    Rust   : <br> <code class="rust">enum Color {RED, BLUE, GRAY, UNKNOWN} fn main() { let color = GRAY; let x = match color { GRAY =&gt; 1, RED | BLUE =&gt; 2, _ =&gt; 3, }; println!("{}", x); }</code> <br> <br>     <br> <code class="cpp">int main() { int pixels = 1; for (int j=0; j&lt;5; j++); pixels++; }</code> <br>  Rust          . , ,     . <br> <br>  <br> <code class="cpp">#include &lt;stdio.h&gt; #include &lt;pthread.h&gt; #include &lt;unistd.h&gt; class Resource { int *value; public: Resource(): value(NULL) {} ~Resource() {delete value;} int *acquire() { if (!value) { value = new int(0); } return value; } }; void* function(void *param) { int *value = ((Resource*)param)-&gt;acquire(); printf("resource: %p\n", (void*)value); return value; } int main() { Resource res; for (int i=0; i&lt;5; ++i) { pthread_t pt; pthread_create(&amp;pt, NULL, function, &amp;res); } //sleep(10); printf("done\n"); }</code> <br>     : <br> done <br> resource: 0x7f229c0008c0 <br> resource: 0x7f22840008c0 <br> resource: 0x7f228c0008c0 <br> resource: 0x7f22940008c0 <br> resource: 0x7f227c0008c0 <br> <br>     ,        .      Rust: <br> <code class="rust">struct Resource { value: Option&lt;int&gt;, } impl Resource { pub fn new() -&gt; Resource { Resource{ value: None } } pub fn acquire&lt;'a&gt;(&amp;'a mut self) -&gt; &amp;'a int { if self.value.is_none() { self.value = Some(1); } self.value.get_ref() } } fn main() { let mut res = Resource::new(); for _ in range(0,5) { spawn(proc() { let ptr = res.acquire(); println!("resource {}", ptr) }) } }</code> <br>  ,            . <br> demo:20:23: 20:26 error: cannot borrow immutable captured outer variable in a proc `res` as mutable <br> demo:20 let ptr = res.acquire(); <br> <br>      ,   : <br> <code class="rust">extern crate sync; use sync::{Arc, RWLock}; struct Resource { value: Option&lt;Box&lt;int&gt;&gt;, } impl Resource { pub fn new() -&gt; Resource { Resource{ value: None } } pub fn acquire(&amp;mut self) -&gt; *int { if self.value.is_none() { self.value = Some(box 1) } &amp;**self.value.get_ref() as *int } } fn main() { let arc_res = Arc::new(RWLock::new(Resource::new())); for _ in range(0,5) { let child_res = arc_res.clone(); spawn(proc() { let ptr = child_res.write().acquire(); println!("resource: {}", ptr) }) } }</code> <br>     <code>Arc</code> ( <i>Atomically Reference Counted</i> -        )  <code>RWLock</code> (   ).   : <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> resource: 0x7ff4b0010378 <br> <br>  ,   ++    .    . Rust        ,    .  ,   ,   .           ,       ( <a href="http://superwebdeveloper.com/2009/11/25/the-incredible-rate-of-diminishing-returns-of-fixing-software-bugs/">  </a> ). <br> <br>     <br> Rust        ,     <code>unsafe{}</code> .   ,     " <i> !  ,  .</i> ".  ,  ""  (    ,    )    .    ,           ( )  . , ,        <code>Cell</code>  <code>Mutex</code> .             ,       (   <a href="http://en.wikipedia.org/wiki/Test-driven_development">TDD</a> !). <br> <br>  <br> <a href="https://air.mozilla.org/guaranteeing-memory-safety-in-rust/">Guaranteeing Memory Safety in Rust (by Niko Matsakis)</a> <br> <a href="http://www.techtalkshub.com/rust-safe-systems-programming-fun-fp/">Rust: Safe Systems Programming with the Fun of FP (by Felix Klock II)</a> <br> <a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Keynote">Lang-NEXT: What ‚Äì if anything ‚Äì have we learned from C++? (by Bjarne Stroustrup)</a> <br> <a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Panel-Systems-Programming-Languages-in-2014-and-Beyond">Lang-NEXT Panel: Systems Programming in 2014 and Beyond</a></code></code> </div><p>Source: <a href="https://habr.com/ru/post/225003/">https://habr.com/ru/post/225003/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../224987/index.html">New life old synthesizer. Part 2</a></li>
<li><a href="../224991/index.html">Yandex will place its shares on the Moscow Exchange</a></li>
<li><a href="../224993/index.html">Capsule Audio System</a></li>
<li><a href="../224999/index.html">The latest addition to Visual Studio for creating cross-platform applications in HTML and JavaScript</a></li>
<li><a href="../225001/index.html">Solar Impulse 2 successfully completed its first flight</a></li>
<li><a href="../225007/index.html">In Asterisk version 12 appeared REST interface (Asterisk REST Interface - ARI)</a></li>
<li><a href="../225009/index.html">3G SG-1CR video recorder</a></li>
<li><a href="../225013/index.html">Functional typology</a></li>
<li><a href="../225015/index.html">Experiments in the genre of match3, ‚ÄúHunger Games‚Äù from Kabam and updated HockeyApp - the main mobile news of the week</a></li>
<li><a href="../225017/index.html">Post inspiration: the best time to start your own business</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>