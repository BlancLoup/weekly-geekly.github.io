<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Results and analysis of tasks for the final of the Yandex. Algorithm 2016</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="On July 29, Minsk hosted the final round of the Yandex Programming Championship. Algorithm . The winner was Egor EgorK Kulikov - a graduate of the Mos...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Results and analysis of tasks for the final of the Yandex. Algorithm 2016</h1><div class="post__text post__text-html js-mediator-article"><p>  On July 29, Minsk hosted the final round of the <a href="https://contest.yandex.ru/algorithm2016/">Yandex</a> Programming Championship. <a href="https://contest.yandex.ru/algorithm2016/">Algorithm</a> .  The winner was Egor <a href="https://habrahabr.ru/users/egork/" class="user_link">EgorK</a> Kulikov - a graduate of the Moscow State University and a former employee of Yandex.  The second place was <a href="http://codeforces.com/profile/W4yneb0t">taken</a> by <a href="http://codeforces.com/profile/W4yneb0t">Nikola Jokic</a> from the Swiss Higher Technical School of Zurich.  As part of the school team, he was a finalist for the ACM ICPC.  Third place went to <a href="http://codeforces.com/profile/rng_58">Makoto Soejima</a> , a graduate of the University of Tokyo.  <a href="http://codeforces.com/profile/tourist">Gennady Korotkevich</a> , the winner of the two previous Algorithms, took the sixth place. </p><br><p>  As in previous years, we publish a detailed analysis of the final tasks.  July 31, we first held a mirror of the algorithm.  Therefore, in order not to spoil its participants' pleasure, they did not publish the answers immediately after the final, as we usually do. </p><br><p> <a href="https://habrahabr.ru/company/yandex/blog/306872/"><img src="https://avatars.mds.yandex.net/get-yablogs/39006/file_1469799274028/orig" alt="image"></a> </p><br><p>  This year we received a quarter more applications to participate in the Algorithm than a year ago - 4578. There are still a few girls among the participants - 372. There are representatives of 70 countries in the list of registered participants;  most competing - from Russia, India, Ukraine, Belarus, Kazakhstan, USA and China.  The final was attended by 25 people. </p><br><p>  Tasks for Yandex.Algorithm are Yandex employees and invited experts, among which are the finalists and prize-winners of the ACM ICPC.  Under the terms of the competition, participants can use different programming languages.  Statistics Yandex. Algorithm shows that the most popular language - C ++;  He was chosen by more than two thousand people.  The second place was shared by Python and Java. </p><a name="habracut"></a><br><h3>  Objective A. Venue finals </h3><br><p>  <strong>Problem authors</strong> : Alexey Tolstikov, Roman Udovichenko </p><br><table><thead><tr><th>  Input File Name: </th><th>  Output File Name: </th><th>  Time limit: </th><th>  Memory limit: </th></tr></thead><tbody><tr><td>  standard input </td><td>  standard output </td><td>  3 seconds </td><td>  512 megabytes </td></tr></tbody></table><br><p>  This year, the final Yandex.Algorithm is held at the National Library of Belarus.  It should be noted that the building of the library has a very unusual form - a rhombocuboctahedron. </p><br><p>  A rhombicobooctahedron is a semiregular polyhedron whose faces are 18 squares and 8 triangles.  In total, the rhombicuboctahedron has 24 vertices and 48 edges.  An image of a rhombicuboctahedron is shown below: </p><br><img src="https://habrastorage.org/getpro/habr/post_images/d13/996/63f/d1399663f8884b2e763364526098f07a.jpg" width="200"><br><p>  In this task, you need to determine the number of ways to paint the faces of a rhombocuboctahedron so that no two faces that have a common edge are painted in the same color.  In total, there are k colors at your disposal. </p><br><p>  Since the answer can be quite large, calculate it modulo 10 <sup>9</sup> + 7. </p><br><h4>  Input Format </h4><br><p>  The single line of input data contains a single integer k (1 ‚©Ω k ‚©Ω 50), the number of colors at your disposal. </p><br><h4>  Output format </h4><br><p>  In the only line print the answer to the problem. </p><br><h4>  Examples </h4><br><table><thead><tr><th>  standard input </th><th>  standard output </th></tr></thead><tbody><tr><td>  one </td><td>  0 </td></tr><tr><td>  3 </td><td>  356928 </td></tr></tbody></table><br><h4>  Comment </h4><br><p>  One of the options for the correct coloring for k = 3 is to paint all triangular faces in the first color (8 faces), all square faces adjacent along the edge with one of the triangular faces, in the second color (12 faces), and all remaining square faces in the third color (6 faces). </p><br><h3>  Parsing task A </h3><br><p>  Consider a new graph whose vertices are the faces of a rhombicubooctahedron, and the vertices are connected to the vertices that correspond to the faces adjacent to the side (the so-called dual graph of the polyhedron).  Our task takes the following form: we need to calculate the number of correct colorings of the resulting graph in k colors, where the correct coloring is such a coloring that the neighboring vertices are painted in different colors. </p><br><p>  Note that our graph is bipartite: its vertices can be divided into two groups consisting of 12 vertices and 14 vertices, so that the edges connect only the vertices of different groups.  In fact, the condition even states exactly how this partition is arranged: the first segment of the partition is formed by the vertices, which, in the explanation, are proposed to be painted in the second color, and the second segment - all the others. </p><br><p>  We will first paint the first part, and only then the second.  Note that with a fixed coloring of the first beat, it‚Äôs easy to calculate the number of ways to finish the second beat: we paint each vertex of the second beat separately, which means that the total number of ways is the product of all vertices of the second beat v of k - adj ( v), where adj (v) is the number of different colors among the vertices adjacent v. </p><br><p>  Now we must somehow sort out the coloring of the first lobe.  If we explicitly touch the color for each vertex, it will require about 50 <sup>12</sup> ‚âà 2.4 ¬∑ 10 <sup>20</sup> operations, which will not fit into any reasonable timeframe.  We will go through not the colors of the vertices themselves, but only their division into identical / different color groups.  Namely - for each next vertex during the search, we will decide whether to assign it to one of the existing vertex colors, or whether to create a new one for it.  There are not so many such ‚Äúcompressed‚Äù colorings, a total of 4,213,597 pieces.  Obviously, the information contained in the compressed coloring of the first beat is enough to understand how many ways the second beat can be colored, just remember to multiply this number by the number of ways to turn this compressed coloring into a full coloring (it equals A (k, c ) = k (k - 1) (k - 2) ... (k - c + 1), where c is the number of colors used in the compressed coloring). </p><br><p>  If the written solution does not fit into the time limit, but it does not work very long on one test, then you can cheat and use the fact that the limit on k is not very large by calculating all 50 answers to the tests on the local computer and simply driving into the program. </p><br><p>  An alternative solution can enumerate the coloring on the belt of 8 medium squares, and then count the number of ways to paint one of the halves and square it, since the upper and lower half of the rhomb cubobooctahedron are colored independently of each other. </p><br><hr><br><h3>  Task B. Transform Sequence </h3><br><p>  <strong>Problem authors</strong> : Maxim Akhmedov, Gleb Evstropov </p><br><table><thead><tr><th>  Input File Name: </th><th>  Output File Name: </th><th>  Time limit: </th><th>  Memory limit: </th></tr></thead><tbody><tr><td>  standard input </td><td>  standard output </td><td>  1 second </td><td>  512 megabytes </td></tr></tbody></table><br><p>  You are given a sequence a <sub>1</sub> , a <sub>2</sub> , ..., a <sub>n</sub> , originally consisting of n zeros.  In one move, you can choose any of its sub-slices a <sub>l</sub> , a <sub>l + 1</sub> , ..., a <sub>r</sub> , as well as an arbitrary integer x and convert the sequence of this sub-slices, replacing a <sub>l + k</sub> with a <sub>l + k</sub> + (‚àí1 ) <sup>k</sup> ¬∑ x for all integers 0 ‚©Ω k ‚©Ω r - l. </p><br><p>  It is required to convert the initial zero sequence to the given sequence b <sub>1</sub> , b <sub>2</sub> , ..., b <sub>n</sub> in the minimum number of moves.  There is an important restriction on the sequence b <sub>i</sub> : it is guaranteed that all its elements belong to the set {‚àí1, 0, 1}. </p><br><h4>  Input Format </h4><br><p>  The first line of input contains a single integer n (1 ‚©Ω n ‚©Ω 10 <sup>5</sup> ).  The second line contains n integers b <sub>1</sub> , b <sub>2</sub> , ..., b <sub>n</sub> (‚àí1 ‚©Ω b <sub>i</sub> ‚©Ω 1). </p><br><h4>  Output format </h4><br><p>  Print the minimum number of moves needed to convert the original sequence to the required one. </p><br><h4>  Examples </h4><br><table><tbody><tr><td>  <strong>standard input</strong> </td><td>  <strong>standard output</strong> </td></tr><tr><td>  2 <br>  -eleven </td><td>  one </td></tr><tr><td>  five <br>  1 -1 1 1 0 </td><td>  2 </td></tr></tbody></table><br><h4>  Comment </h4><br><p>  In the first test, from the condition one can get the required sequence in one move, in which x = ‚àí1, l = 1 and r = 2. </p><br><p>  In the second test from the condition, you can act as follows: <br>  0 0 0 0 0 ‚Üí 2 -2 2 0 0 ‚Üí 1 -1 1 1 0 </p><br><h3>  Parsing task B </h3><br><p>  We will gradually understand the design.  First, we invert the signs of all the numbers in even positions.  Now the operation specified in the condition will be simpler: we are allowed to choose any sub-segment and add the same number t to all the numbers on it. </p><br><p>  Since we are dealing with operations of the form ‚Äúadd the same number on the subsegment‚Äù, it is useful to proceed to a sequence consisting of the differences of neighboring elements: we move from a <sub>1</sub> , a <sub>2</sub> , ..., a <sub>n</sub> to the sequence b <sub>0</sub> = a <sub>1</sub> , b <sub>1</sub> = a <sub>2</sub> - a <sub>1</sub> , ..., b <sub>i</sub> = a <sub>i + 1</sub> - a <sub>i</sub> , ..., b <sub>n</sub> = ‚àía <sub>n</sub> .  In this sequence of elements, one is greater, and it satisfies the special condition that b <sub>0</sub> + b <sub>1</sub> + ... + b <sub>n</sub> = 0. </p><br><p>  Then adding the constant x on the interval [l, r] of the original sequence is equivalent to replacing b <sub>l ‚àí 1</sub> ‚Üí b <sub>l ‚àí 1</sub> + x and b <sub>r</sub> ‚Üí b <sub>r</sub> - x. </p><br><p>  In the sequence a <sub>i there</sub> were integers from ‚àí1 to 1, therefore in the sequence b <sub>i there</sub> will be integers from ‚àí2 to 2. In one move, as we have already found out, we can add x to one of the numbers, and subtract from the other x, and we want to ensure that the sequence contains only zeros. </p><br><p>  The term ‚Äúx‚Äù is called the ‚Äúweight‚Äù of adding x and ‚àíx to two elements of the sequence. </p><br><p>  Let us prove an auxiliary fact: if the number b <sub>i is</sub> greater than (less than) zero, then it is not beneficial to apply operations in which the number b <sub>i</sub> increases.  Formally speaking, if there is an optimal (i.e., shortest) sequence of operations in which some b <sub>i</sub> increases at some time, then a sequence of operations can be presented in which no b <sub>i</sub> never increases and which has same length. </p><br><p>  Indeed, let two operations be applied to b <sub>i</sub> , say 1) b <sub>i</sub> ‚Üí b <sub>i</sub> + x, b <sub>j</sub> ‚Üí b <sub>j</sub> - x and 2) b <sub>i</sub> + x ‚Üí b <sub>i</sub> + x - y, b <sub>k</sub> ‚Üí b <sub>k</sub> + y, and, for definiteness, where x, y&gt; 0 and, for definiteness, x ‚©Ω y. </p><br><p>  Let's replace these two operations with two others: 1) b <sub>i</sub> ‚Üí b <sub>i</sub> - (y - x) = b <sub>i</sub> + x - y, b <sub>k</sub> ‚Üí b <sub>k</sub> + y - x and b <sub>j</sub> ‚Üí b <sub>j</sub> - x, b <sub>k</sub> + y - x ‚Üí b <sub>k</sub> + y - x + x = b <sub>k</sub> + y.  These are two equivalent operations, they lead to the same results, but you can see that the total weight of the two new operations has decreased: | y - x |  + | x |  = y - x + x = y &lt;x + y = | x |  + | y ‚Äã‚Äã|. </p><br><p>  Repeating such replacements, while it is possible, we will sooner or later stop (because the total weight of operations cannot decrease indefinitely, since it is always whole and non-negative), which means you can find a sequence of operations of the same length, in which any positive element is always only decreases.  Similarly, it is possible to ensure that any positive element will only increase. </p><br><p>  This allows us to describe all the operations available to us.  We can either get rid of ‚àí2 and 2 in one move, or get rid of ‚àí1 and 1 in one move, or get rid of ‚àí2, 1, 1 in two moves, or get rid of 2, ‚àí1, ‚àí1 in two moves . </p><br><p> It is clear that the total weight of all operations that we perform is the sum of all positive numbers among b <sub>i</sub> (which is opposite in sign to the sum of all negative numbers).  We now have operations of weight 1 and weight 2, and it is clear that in order to minimize the total number of operations, we need to do as many operations of weight 2 as possible. This leads us to the greedy algorithm, namely, to reduce the two to the minus two, while we can, but when no longer can, reduce edinichki and minus edinichki with what happens. </p><br><p>  Thus, the answer is the sum of all positive b <sub>i</sub> minus the minimum of the number of twos and the number of minus twos. </p><br><hr><br><h3>  Problem C. Hat game </h3><br><p>  <strong>Problem Author</strong> : Gleb Evstropov </p><br><table><thead><tr><th>  Input File Name: </th><th>  Output File Name: </th><th>  Time limit: </th><th>  Memory limit: </th></tr></thead><tbody><tr><td>  standard input </td><td>  standard output </td><td>  1 second </td><td>  512 megabytes </td></tr></tbody></table><br><p>  The hat is a popular game in Russian-speaking countries, designed for a great friendly company.  Participants are divided into teams of two and sit in a circle in such a way that everyone sits strictly opposite his partner.  The players write a lot of words on small pieces of paper, put them in a hat, after which each of the players in turn tries to explain the word to his partner without naming him explicitly. </p><br><p>  Consider the following problem.  At the round table sit 2n people.  They want to play with a hat, and in some way they have already broken into teams of two.  Now they want to move in such a way that each person sits opposite his partner.  To do this, they can perform the following operation several times: they select two people from those sitting at the table and ask them to switch places. </p><br><p>  You are given the initial arrangement of people at the table.  Determine what the minimum number of operations of the type described should be made so that each person sits opposite his partner. </p><br><h4>  Input Format </h4><br><p>  The first line of input contains an integer n (1 ‚©Ω n ‚©Ω 10 <sup>5</sup> ), which means that 2n people are sitting at the table. </p><br><p>  The second line contains a sequence of 2n integers.  Each integer from 1 to n occurs in this sequence exactly two times.  This sequence describes the division of people sitting around the table, into teams, if we write them out in a clockwise order. </p><br><h4>  Output format </h4><br><p>  Print the minimum number of operations that need to be performed so that each person is facing his partner. </p><br><h4>  Examples </h4><br><table><tbody><tr><td>  <strong>standard input</strong> </td><td>  <strong>standard output</strong> </td></tr><tr><td>  3 <br>  2 1 3 2 1 3 </td><td>  0 </td></tr><tr><td>  four <br>  2 1 4 2 3 1 3 4 </td><td>  2 </td></tr></tbody></table><br><h4>  Comment </h4><br><p>  In the first test of the condition, the initial seating is already suitable for playing with a hat. </p><br><p>  In the second test from the condition one of the best ways will first swap people sitting in the first and seventh positions, and then swap people sitting in the seventh and eighth positions, which will lead us to the correct seating: 3 1 4 2 3 1 4 2 . </p><br><h3>  Parsing task C </h3><br><p>  Consider the following graph: its vertices will be 2n positions at the table, and the edges will be connected, firstly, the vertices corresponding to diametrically opposite positions, and secondly - the vertices corresponding to the positions on which people from the same team are sitting.  In particular, if people from the same team are already sitting opposite each other, then between the peaks corresponding to their positions, two ribs will be drawn. </p><br><p>  The resulting graph has the property that in it from each vertex there are exactly two edges (one is the diameter and the second is the top in which a person from the same team sits).  Such a graph is always a union of some number of cycles. </p><br><p>  We strive to achieve a situation where each cycle consists of exactly two diametrically opposite vertices, that is, when there are exactly n cycles of length 2. </p><br><p>  Let us understand how our graph changes under the influence of the operation available to us.  Let them swap two people from more than one team (otherwise it is a meaningless operation), say, a person from the top of a with a person from the top of b.  Let the person's partner a sit at the vertex a ‚Ä≤, and let the person's partner b sit at the top of b ‚Ä≤.  Then two edges aa ‚Ä≤ and bb ‚Ä≤ disappear from the graph and two new edges ba ‚Ä≤ and ab ‚Ä≤ are formed (that is, new edges will cross over between the ends of the old ones).  It is easy to see that such an operation can either divide one cycle into two, or not change the number of cycles, or glue two cycles together.  This means that the answer is no less than n - c, where c is the initial number of cycles.  On the other hand, one can always achieve the required exactly in so many moves: it‚Äôs enough at each step to take a couple of teammates who do not sit opposite each other, and simply replant one of them so that he sits in front of his partner.  This operation strictly increases the number of cycles by one. </p><br><p>  Thus, the answer is n - c, where c is the number of cycles, or, equivalently, the connected components in the specified graph.  This problem can be solved simply by clearly modeling the process of seating people in pairs, and this is correct for the same reasons as described above. </p><br><hr><br><h3>  Problem D. Cumulate me completely </h3><br><p>  <strong>Problem Author</strong> : Maxim Akhmedov </p><br><table><thead><tr><th>  Input File Name: </th><th>  Output File Name: </th><th>  Time limit: </th><th>  Memory limit: </th></tr></thead><tbody><tr><td>  standard input </td><td>  standard output </td><td>  2 seconds </td><td>  512 megabytes </td></tr></tbody></table><br><p>  You are a simple guy who wants only one thing: to be presented with a binary maximum pile for his birthday, because all of your friends already have one!  Finally, you went to the store with your parents, but unfortunately, all the binary heaps ended there, and all that was left was the old full binary tree.  It consists of n = 2 <sup>h</sup> - 1 vertices, in which some values ‚Äã‚Äãare written, which do not necessarily satisfy the main property of the maximum heap.  Fortunately, Old Joe agreed to help you turn this tree into a binary heap for a fee. </p><br><p>  <em>A complete binary tree of</em> height h is a rooted tree consisting of n = 2 <sup>h</sup> - 1 vertices numbered from 1 to n, such that for any 1 ‚©Ω v ‚©Ω 2 <sup>h-1</sup> - 1 the vertex v is an ancestor of the vertices 2v and 2v + one. </p><br><p>  <em>The binary maximum heap of</em> height h is a full binary tree of height h, whose values ‚Äã‚Äãare h <sub>1</sub> , h <sub>2</sub> , ..., h <sub>n</sub> at the vertices, and the value at any vertex is not less than the value of its children (if it has children). </p><br><p>  You are given a complete binary tree of height h, at the vertices of which are the values ‚Äã‚Äãa <sub>1</sub> , a <sub>2</sub> , ..., a <sub>n</sub> .  Also, a value c <sub>v</sub> is associated with each vertex, meaning that Old Joe can either increase or decrease the value at vertex v by an arbitrary value x&gt; 0 for the cost in c <sub>v</sub> x.  You can change the values ‚Äã‚Äãin any number of vertices. </p><br><p>  Determine the minimum cost of converting a given full binary tree to a maximum pile. </p><br><h4>  Input Format </h4><br><p>  The first line of input contains a single integer n (1 ‚©Ω n ‚©Ω 2 <sup>18</sup> ‚àí1), the number of vertices in the complete binary tree that you got.  It is guaranteed that n = 2 <sup>h</sup> - 1 for some integer h. </p><br><p>  The second input line contains n integers a <sub>1</sub> , a <sub>2</sub> , ..., a <sub>n</sub> (0 ‚©Ω a <sub>i</sub> ‚©Ω 10 <sup>6</sup> ), the current values ‚Äã‚Äãof the tree vertices. </p><br><p>  The third line contains n integers c <sub>1</sub> , c <sub>2</sub> , ..., c <sub>n</sub> (0 ‚©Ω c <sub>i</sub> ‚©Ω 10 <sup>6</sup> ), the cost of changing the values ‚Äã‚Äãat the vertices of the tree. </p><br><h4>  Output format </h4><br><p>  Output the minimum cost of converting the given full binary tree to the maximum heap. </p><br><h4>  Example </h4><br><table><tbody><tr><td>  <strong>standard input</strong> </td><td>  <strong>standard output</strong> </td></tr><tr><td>  7 <br>  4 5 3 1 2 6 6 <br>  4 7 8 0 10 2 3 </td><td>  nineteen </td></tr></tbody></table><br><h4>  Comment </h4><br><p>  In the test from the condition, the optimal way is to increase the value at vertex 1 by 2 by 4 ¬∑ 2 = 8 and decrease the values ‚Äã‚Äãat vertices 6 and 7 by 3 by 2 ¬∑ 3 = 6 and 3 ¬∑ 3 = 9, respectively.  Thus, the total cost will be equal to 8 + 6 + 9 = 23. </p><br><h3>  Analysis of task D </h3><br><p>  We introduce the notation.  Let L <sub>v</sub> (x) be the minimum price that must be paid for the subtree of the top of v to become a valid heap, and at the very top of v there is a number that does not exceed x.  Let S <sub>v</sub> (x) be a quantity that is determined absolutely analogously, only at the very vertex v there must be a strictly x number.  Then the answer to the problem is equal to the minimum value of the function S <sub>v</sub> (x). </p><br><p>  For leaf vertices of v, by the condition, we have that S <sub>v</sub> (x) = c <sub>v</sub> | x - a <sub>v</sub> |.  Similarly, we can understand that L <sub>v</sub> (x) = max {0, c <sub>v</sub> (a <sub>v</sub> - x)}. </p><br><p>  Let us express S <sub>v</sub> (x) through L <sub>2v</sub> (x) and L <sub>2v + 1</sub> (x) (that is, the function S of the vertex v through the functions L of its children).  The following relation is true: </p><br><p>  S <sub>v</sub> (x) = c <sub>v</sub> | x - a <sub>v</sub> |  + L <sub>2v</sub> (x) + L <sub>2v + 1</sub> (x). </p><br><p>  Indeed, if we put the value of x at the vertex v, then we pay, first, for changing the vertex v itself, and second, we must change the subtrees v in some way so that the value in v turns out to be no less than its value children, and we can get this value from the L function for children. </p><br><p>  L <sub>v</sub> (x) we now learn to count by S <sub>v</sub> (x).  But let's stop at this point and suggest what kind of functions L <sub>v</sub> and S <sub>v have</sub> .  One can guess that they will be piecewise linear functions of the variable x, but in fact even a stronger condition is true: they will be convex piecewise linear functions (in other words, the slope of each next link increases).  Let us prove this strictly: let it be true for vertices 2v and 2v + 1. Then S <sub>v</sub> (x), as follows from the formula above, is also a convex piecewise-linear function (since it is the sum of three convex piecewise-linear functions). </p><br><p>  Now L <sub>v</sub> (x) is easy to obtain from S <sub>v</sub> (x): consider the global minimum point S <sub>v</sub> (x).  Up to this point, S <sub>v</sub> (x) decreases, and after it increases.  In order to get L <sub>v</sub> (x), you just need to replace the ascending section of S <sub>v</sub> (x) with a constant horizontal section with a value equal to the global minimum of the function S <sub>v</sub> (x). </p><br><p>  Note that in order to set the functions L <sub>v</sub> and S <sub>v</sub> , you need O (size (v)) information about the break points of these functions, where size (v) is the size of the subtree of v.  Indeed, the break points in the graph of the function S <sub>v</sub> (x) are no more than the total break points in the graphs of the functions S <sub>2v</sub> and S <sub>2v + 1</sub> plus one more break point due to the term c <sub>v</sub> | x - a <sub>v</sub> |.  It turns out the recurrence T (v) = T (2v) + T (2v + 1) + 1 for the amount of information stored in the worst case, the solution of which is T (v) = size (v). </p><br><p>  Directly implement the basic formula used in the problem, it is possible for the linear complexity of the size of the merged functions.  Thus, the solution for <img src="https://tex.s2cms.ru/svg/%5Csum%5Climits_%7Bv%7D">  size (v) = nk = n ¬∑ log <sub>2</sub> n. </p><br><hr><br><h3>  Problem E. Separate and Conquer </h3><br><p>  Problem Author: Mikhail Tikhomirov </p><br><table><thead><tr><th>  Input File Name: </th><th>  Output File Name: </th><th>  Time limit: </th><th>  Memory limit: </th></tr></thead><tbody><tr><td>  standard input </td><td>  standard output </td><td>  5 second </td><td>  512 megabytes </td></tr></tbody></table><br><p>  A sequence of numbers is called <em>good</em> if it can be built according to the following rules: </p><br><ul><li>  empty sequence is good; </li><li>  if X and Y are good sequences, then XY (concatenation of X and Y) is also <br>  good; </li><li>  if X is a good sequence, and n is any number, then nXn (number n, then all elements of X, and finally, number n) is also a good sequence. </li></ul><br><p>  For example, the sequence (1, 2, 2, 1, 3, 3) is good, and the sequence (1, 2, 1, 2) is not. </p><br><p>  A sequence is called separable if there is a way to split it into two good subsequences (any of them can be empty).  For example, the sequence (1, 2, 1, 2) is separable (since it can be divided into good subsequences (1, 1) and (2, 2)), and the sequence (1, 2, 3, 1, 2, 3) - not. </p><br><p>  Consider all sequences of 2n numbers, such that each number from 1 to n occurs exactly twice.  How many of them are separable?  Find the answer modulo 10 <sup>9</sup> + 7. </p><br><h4>  Input Format </h4><br><p>  The only input line contains one integer n (1 ‚©Ω n ‚©Ω 500). </p><br><h4>  Output format </h4><br><p>  Print a single integer - the answer to the problem modulo 10 <sup>9</sup> + 7. </p><br><h4>  Examples </h4><br><table><tbody><tr><td>  <strong>standard input</strong> </td><td>  <strong>standard output</strong> </td></tr><tr><td>  one </td><td>  one </td></tr><tr><td>  2 </td><td>  6 </td></tr><tr><td>  four </td><td>  2016 </td></tr></tbody></table><br><h3>  Parsing task E </h3><br><p>  How to check if a sequence is separable?  For this sequence, we construct a graph on n vertices.  Connect vertices i and j by an edge if the pairs of corresponding numbers cannot be included in one memory band (i.e., for example, when the numbers are arranged as (i, j, i, j) or (j, i, j, i), but not (i, i, j, j) or (i, j, j, i)).  A sequence is separable if and only if the resulting graph is duplex. </p><br><p>  Denote by f (n) the number of separable sequences of n pairs of numbers, while the sequences differing in renumbering numbers will be considered identical.  We introduce an auxiliary function g (n) ‚Äîthe number of <em>primitive</em> sequences, i.e., separable sequences of n pairs of numbers for which there is exactly one way of dividing into two memory bands (these are exactly the same sequences for which the graph described above is connected) . </p><br><p>  Suppose we know the values ‚Äã‚Äãof g (n), we now calculate f (n).  For an arbitrary separable sequence, consider the connected component containing the first number.  Let it contain k pairs of numbers, then there are 2k spaces between its elements, in each of which you can put any separable sequence independently of each other.  Denote by F (n, k) the number of ways to choose k separable sequences of total length 2n.  Then from the reasoning above we get f (n) = <img src="https://tex.s2cms.ru/svg/%5Csum%5Climits_%7Bk%3D1%7D%5E%7Bn%7D">  g (k) F (n - k, 2k).  The values ‚Äã‚Äãof F (n, k) are trivially recalculated through each other and the next values ‚Äã‚Äãof f (n). </p><br><p>  How to find g (n)?  Let us call the <em>configuration of the</em> ways to split 2n elements into two sets and construct the SRP on each of them independently.  The number of configurations on 2n elements t (n) is calculated trivially.  Subtract from this number all configurations that are not related to primitive sequences, the remaining number will be 2g (n).  Consider again the connected component containing the first number, even if there are k pairs of numbers in it.  The number of such configurations is 2g (k) T (n - k, 2k), where T (n, k) is the number of ways to select k configurations with a total number of elements 2n.  Thus, g (n) = <img src="https://tex.s2cms.ru/svg/1%20%5Cover%202">  (T (n) - <img src="https://tex.s2cms.ru/svg/%5Csum_%7Bk%3D1%7D%5E%7Bn-1%7D">  g (k) T (n - k, 2k).  The values ‚Äã‚Äãof T (n, k) are calculated trivially through t (n), which are explicitly.  The total complexity of this solution is O (n <sup>3</sup> ). </p><br><hr><br><h3>  Problem F. Shot </h3><br><p>  <strong>Problem Author</strong> : Oleg Khristenko </p><br><table><thead><tr><th>  Input File Name: </th><th>  Output File Name: </th><th>  Time limit: </th><th>  Memory limit: </th></tr></thead><tbody><tr><td>  standard input </td><td>  standard output </td><td>  2 seconds </td><td>  512 megabytes </td></tr></tbody></table><br><p>  Given a sequence a <sub>1</sub> , a <sub>2</sub> , ..., a <sub>n</sub> , the elements a <sub>i of</sub> which are fractions written as p / q, where p is an integer and q is a positive integer (while their mutual simplicity is not guaranteed). <br>  Check that for each pair i, j (1 ‚â§ i &lt;j ‚â§ n) there exists at least one 1 ‚â§ k ‚â§ n such that a <sub>i</sub> ¬∑ a <sub>j</sub> = a <sub>k</sub> . </p><br><h4>  Input Format </h4><br><p>  The first line of the input data contains a single integer n (1 ‚©Ω n ‚©Ω 3 ¬∑ 10 <sup>5</sup> ) - the length of the sequence.  The next line contains n fractions in p / q format (p and q are integers, | p | ‚©Ω 10 <sup>9</sup> , 1 ‚©Ω q ‚©Ω 10 <sup>9</sup> ). </p><br><h4>  Output format </h4><br><p>  Output "Yes" if for each pair of different i and j there is the required k, and "No" otherwise. </p><br><h4>  Examples </h4><br><table><tbody><tr><td>  <strong>standard input</strong> </td><td>  <strong>standard output</strong> </td></tr><tr><td>  one <br>  7/42 </td><td>  Yes </td></tr><tr><td>  3 <br>  3/3 0/1 -5/5 </td><td>  Yes </td></tr><tr><td>  2 <br>  2/1 3/2 </td><td>  No </td></tr></tbody></table><br><h3>  Parsing task F </h3><br><p>  Reduce all fractions.  We make several observations. </p><br><p>  First, if a certain number occurs more than twice, you can delete all its copies. <br>  except for two: it does not affect many of the various pairwise works. </p><br><p>  Secondly, we note that in each of the sets 0 &lt;| x |  &lt;1 and 1 &lt;| x |  there is no more than one number.  Indeed, if, for example, on 0 &lt;| x |  &lt;1 is more than one number, then from all the numbers presented there we choose two minimum absolute values ‚Äã‚Äã(say, a and b), take their product ab, and it will have an even smaller non-zero absolute value: 0 &lt;| ab |  = | a || b |  &lt;min {| a |, | b |}, which means that it does not coincide with any of the numbers in our set.  Similarly, with a range of 1 &lt;| x |. </p><br><p>  Thus, after reducing and removing duplicates, provided that the answer is Yes, in our set there can be no more than eight numbers: two zeros, two ones, two minus ones, and one number from the specified ranges.  So, you can adhere to the following logic: reduce all the numbers, leave no more than two copies of each number.  If you get more than eight numbers, the answer is definitely No, otherwise you can consider all the pairs of numbers, the benefit of them quite a bit, and honestly check the required condition. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/306872/">https://habr.com/ru/post/306872/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../306860/index.html">GitLab 8.10 released</a></li>
<li><a href="../306862/index.html">All kernel mode drivers for Windows 10 (1607) should now be signed by Microsoft</a></li>
<li><a href="../306864/index.html">A brief reminder of the demiurge</a></li>
<li><a href="../306866/index.html">Automate the installation of updates on the client machine with the elimination of erroneous updates</a></li>
<li><a href="../306868/index.html">Connecting Intel Internet of Things Gateways to IBM Watson</a></li>
<li><a href="../306874/index.html">Uber does not always win</a></li>
<li><a href="../306876/index.html">As I wrote game design documentation for my game.</a></li>
<li><a href="../306878/index.html">The digest of interesting events from the world of Java, and around it # 7 (07/18/2016 - 07/31/2016)</a></li>
<li><a href="../306880/index.html">Login to IT</a></li>
<li><a href="../306882/index.html">ICFPC 2016 coming soon</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>