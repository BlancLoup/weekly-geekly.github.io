<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Procedurally generated world maps on Unity C #, Part 4 (traffic)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This is the last article in a series on procedurally generated world maps using Unity and C #. Carefully, under the cut 7 MB images. 

 Content 

 Par...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Procedurally generated world maps on Unity C #, Part 4 (traffic)</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/b82/7d0/bc3/b827d0bc3650436b985c103dc5dbc539.png" alt="image"><br><br>  This is the last article in a series on procedurally generated world maps using Unity and C #.  <i>Carefully, under the cut 7 MB images.</i> <br><a name="habracut"></a><br>  <b>Content</b> <br><br>  <a href="https://habrahabr.ru/post/276251/">Part 1</a> : 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Introduction <br>  Noise generation <br>  Beginning of work <br>  Generate elevation map <br><br>  <a href="https://habrahabr.ru/post/276281/">Part 2</a> : <br><br>  Map folding on one axis <br>  Map folding on both axes <br>  Neighbor Search <br>  Bit masks <br>  Fill <br><br>  <a href="https://habrahabr.ru/post/276533/">Part 3</a> : <br><br>  Heat map generation <br>  Humidity Map Generation <br>  River generation <br><br>  Part 4 (this article): <br><br>  Biome generation <br>  Spherical map generation <br><br>  <b>Biome generation</b> <br><br>  Biomes are a way to classify terrestrial types.  Our biome generator will be based on the popular Whittaker model, in which biomes are classified by rainfall and temperature.  We have already generated a heat map and a moisture map for our world, so the definition of biomes will be quite simple.  The Whittaker classification scheme is presented in the following illustration: <br><br><img src="https://habrastorage.org/files/c5c/429/528/c5c42952847e4046a1494c3e898cb7df.jpg" alt="image"><br><br>  We can separate different types of biomes by a given temperature and humidity level.  First, create a new enumeration in which these types of biomes will be stored: <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> BiomeType { Desert, Savanna, TropicalRainforest, Grassland, Woodland, SeasonalForest, TemperateRainforest, BorealForest, Tundra, Ice }</code> </pre> <br>  Then you need to create a table that will help us determine the type of biome based on temperature and humidity.  We already have HeatType and MoistureType.  Each of these listings contains 6 specific types.  The following table was created to compare each of these types with the Whittaker scheme: <br><br><img src="https://habrastorage.org/files/bcf/2f9/246/bcf2f924695d43c1bf87e04b2af8c4dd.jpg" alt="image"><br><br>  To make it easier to find this data in the code, we will transform the table into a two-dimensional array.  It will be like this: <br><br><pre> <code class="cs hljs">BiomeType[,] BiomeTable = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BiomeType[<span class="hljs-number"><span class="hljs-number">6</span></span>,<span class="hljs-number"><span class="hljs-number">6</span></span>] { <span class="hljs-comment"><span class="hljs-comment">//COLDEST //COLDER //COLD //HOT //HOTTER //HOTTEST { BiomeType.Ice, BiomeType.Tundra, BiomeType.Grassland, BiomeType.Desert, BiomeType.Desert, BiomeType.Desert }, //DRYEST { BiomeType.Ice, BiomeType.Tundra, BiomeType.Grassland, BiomeType.Desert, BiomeType.Desert, BiomeType.Desert }, //DRYER { BiomeType.Ice, BiomeType.Tundra, BiomeType.Woodland, BiomeType.Woodland, BiomeType.Savanna, BiomeType.Savanna }, //DRY { BiomeType.Ice, BiomeType.Tundra, BiomeType.BorealForest, BiomeType.Woodland, BiomeType.Savanna, BiomeType.Savanna }, //WET { BiomeType.Ice, BiomeType.Tundra, BiomeType.BorealForest, BiomeType.SeasonalForest, BiomeType.TropicalRainforest, BiomeType.TropicalRainforest }, //WETTER { BiomeType.Ice, BiomeType.Tundra, BiomeType.BorealForest, BiomeType.TemperateRainforest, BiomeType.TropicalRainforest, BiomeType.TropicalRainforest } //WETTEST };</span></span></code> </pre><br>  To further simplify the search, add a new function that returns the type of biome of any tile.  This part is quite simple, because each tile has already been assigned a type of heat and humidity. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> BiomeType </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetBiomeType</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Tile tile</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> BiomeTable [(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)tile.MoistureType, (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)tile.HeatType]; }</code> </pre><br>  This check is performed for each tile and sets the biome areas for the entire map. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateBiomeMap</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; Width; x++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> y = <span class="hljs-number"><span class="hljs-number">0</span></span>; y &lt; Height; y++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!Tiles[x, y].Collidable) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; Tile t = Tiles[x,y]; t.BiomeType = GetBiomeType(t); } } }</code> </pre><br>  Great, we've identified all the biomes.  However, while we can not visualize them.  The next step is to assign colors to each type.  This will allow us to visualize the area of ‚Äã‚Äãeach biome in the image.  I chose the following colors: <br><br><img src="https://habrastorage.org/files/da0/73f/281/da073f281bca462991ee9dd2542a315c.jpg" alt="image"><br><br>  The color values ‚Äã‚Äãare inserted into the TextureGenerator class along with the biome texture generation code: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//  private static Color Ice = Color.white; private static Color Desert = new Color(238/255f, 218/255f, 130/255f, 1); private static Color Savanna = new Color(177/255f, 209/255f, 110/255f, 1); private static Color TropicalRainforest = new Color(66/255f, 123/255f, 25/255f, 1); private static Color Tundra = new Color(96/255f, 131/255f, 112/255f, 1); private static Color TemperateRainforest = new Color(29/255f, 73/255f, 40/255f, 1); private static Color Grassland = new Color(164/255f, 225/255f, 99/255f, 1); private static Color SeasonalForest = new Color(73/255f, 100/255f, 35/255f, 1); private static Color BorealForest = new Color(95/255f, 115/255f, 62/255f, 1); private static Color Woodland = new Color(139/255f, 175/255f, 90/255f, 1); public static Texture2D GetBiomeMapTexture(int width, int height, Tile[,] tiles, float coldest, float colder, float cold) { var texture = new Texture2D(width, height); var pixels = new Color[width * height]; for (var x = 0; x &lt; width; x++) { for (var y = 0; y &lt; height; y++) { BiomeType value = tiles[x, y].BiomeType; switch(value){ case BiomeType.Ice: pixels[x + y * width] = Ice; break; case BiomeType.BorealForest: pixels[x + y * width] = BorealForest; break; case BiomeType.Desert: pixels[x + y * width] = Desert; break; case BiomeType.Grassland: pixels[x + y * width] = Grassland; break; case BiomeType.SeasonalForest: pixels[x + y * width] = SeasonalForest; break; case BiomeType.Tundra: pixels[x + y * width] = Tundra; break; case BiomeType.Savanna: pixels[x + y * width] = Savanna; break; case BiomeType.TemperateRainforest: pixels[x + y * width] = TemperateRainforest; break; case BiomeType.TropicalRainforest: pixels[x + y * width] = TropicalRainforest; break; case BiomeType.Woodland: pixels[x + y * width] = Woodland; break; } //   if (tiles[x,y].HeightType == HeightType.DeepWater) { pixels[x + y * width] = DeepColor; } else if (tiles[x,y].HeightType == HeightType.ShallowWater) { pixels[x + y * width] = ShallowColor; } //   if (tiles[x,y].HeightType == HeightType.River) { float heatValue = tiles[x,y].HeatValue; if (tiles[x,y].HeatType == HeatType.Coldest) pixels[x + y * width] = Color.Lerp (IceWater, ColdWater, (heatValue) / (coldest)); else if (tiles[x,y].HeatType == HeatType.Colder) pixels[x + y * width] = Color.Lerp (ColdWater, RiverWater, (heatValue - coldest) / (colder - coldest)); else if (tiles[x,y].HeatType == HeatType.Cold) pixels[x + y * width] = Color.Lerp (RiverWater, ShallowColor, (heatValue - colder) / (cold - colder)); else pixels[x + y * width] = ShallowColor; } //   if (tiles[x,y].HeightType &gt;= HeightType.Shore &amp;&amp; tiles[x,y].HeightType != HeightType.River) { if (tiles[x,y].BiomeBitmask != 15) pixels[x + y * width] = Color.Lerp (pixels[x + y * width], Color.black, 0.35f); } } } texture.SetPixels(pixels); texture.wrapMode = TextureWrapMode.Clamp; texture.Apply(); return texture; }</span></span></code> </pre><br>  When rendering biome maps, it turns out beautiful folding maps of the world. <br><br><img src="https://habrastorage.org/files/c26/77f/8ae/c2677f8ae5524be7926c76e834d64479.png" alt="image"><img src="https://habrastorage.org/files/9d7/0f3/036/9d70f30361644383819f15c5f3730635.png" alt="image"><br><br>  <b>Spherical map generation</b> <br><br>  Up to this point, we created worlds that collapse along the X and Y axes. Such maps are great for games, because the data is easily rendered into a game map. <br><br>  If you try to design such collapsible textures onto a sphere, they will look strange.  In order for our world to overlap with a sphere, it is necessary to write a generator of spherical textures.  In this part we will add such a function for the worlds we have generated. <br><br>  Spherical generation is slightly different from generating rolled maps, because it requires other noise schemes and texture mapping.  For this reason, we divide the generator class into two branches of subclasses: WrappableWorldGenerator and SphericalWorldGenerator.  Each of them will inherit the base class Generator. <br><br>  This will allow us to have a common functional core, providing advanced features to each type of generator. <br><br>  The original Generator class, as well as some of its functions, will become abstract: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">abstract</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">abstract</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetData</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">abstract</span></span></span><span class="hljs-function"> Tile </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetTop</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Tile tile</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">abstract</span></span></span><span class="hljs-function"> Tile </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetBottom</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Tile tile</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">abstract</span></span></span><span class="hljs-function"> Tile </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetLeft</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Tile tile</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">abstract</span></span></span><span class="hljs-function"> Tile </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetRight</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Tile tile</span></span></span><span class="hljs-function">)</span></span>;</code> </pre><br>  The functions Initialize () and GetData () that we have were created for collapsing worlds, so we need to write new ones for the spherical generator.  We will also create new classes for obtaining tiles, because the folding will take place on the X axis with spherical projection. <br><br>  Initialization of noise occurs in a manner similar to that previously described, with the exception of one major difference.  The heat map in the new generator will not roll up on the Y axis. Therefore, we cannot create the correct gradient for multiplication.  We will have to do it manually during data generation. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HeightMap = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ImplicitFractal (FractalType.MULTI, BasisType.SIMPLEX, InterpolationType.QUINTIC, TerrainOctaves, TerrainFrequency, Seed); HeatMap = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ImplicitFractal(FractalType.MULTI, BasisType.SIMPLEX, InterpolationType.QUINTIC, HeatOctaves, HeatFrequency, Seed); MoistureMap = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ImplicitFractal (FractalType.MULTI, BasisType.SIMPLEX, InterpolationType.QUINTIC, MoistureOctaves, MoistureFrequency, Seed); }</code> </pre><br>  The GetData function will change significantly.  We will return to the three-dimensional noise sampling.  The noise will be sampled based on a coordinate system with latitude and longitude. <br><br>  I looked at how spherical projection into <a href="http://libnoise.sourceforge.net/tutorials/tutorial8.html">libnoise was performed</a> , and used the same concept.  The main code that converts the latitude and longitude coordinates to Cartesian coordinates of a three-dimensional spherical map will be as follows: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LatLonToXYZ</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> lat, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> lon, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> r = Mathf.Cos (Mathf.Deg2Rad * lon); x = r * Mathf.Cos (Mathf.Deg2Rad * lat); y = Mathf.Sin (Mathf.Deg2Rad * lon); z = r * Mathf.Sin (Mathf.Deg2Rad * lat); }</code> </pre><br>  The GetData function cycles through all coordinates using this conversion method to generate map data.  With this method we create heat, altitude and humidity data.  The biome map is generated in the same way as before - from the final heat map and the humidity map. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetData</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HeightData = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MapData (Width, Height); HeatData = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MapData (Width, Height); MoistureData = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MapData (Width, Height); <span class="hljs-comment"><span class="hljs-comment">//      / float southLatBound = -180; float northLatBound = 180; float westLonBound = -90; float eastLonBound = 90; float lonExtent = eastLonBound - westLonBound; float latExtent = northLatBound - southLatBound; float xDelta = lonExtent / (float)Width; float yDelta = latExtent / (float)Height; float curLon = westLonBound; float curLat = southLatBound; //         / for (var x = 0; x &lt; Width; x++) { curLon = westLonBound; for (var y = 0; y &lt; Height; y++) { float x1 = 0, y1 = 0, z1 = 0; //      x, y, z LatLonToXYZ (curLat, curLon, ref x1, ref y1, ref z1); //   float sphereValue = (float)HeatMap.Get (x1, y1, z1); if (sphereValue &gt; HeatData.Max) HeatData.Max = sphereValue; if (sphereValue &lt; HeatData.Min) HeatData.Min = sphereValue; HeatData.Data [x, y] = sphereValue; //      float coldness = Mathf.Abs (curLon) / 90f; float heat = 1 - Mathf.Abs (curLon) / 90f; HeatData.Data [x, y] += heat; HeatData.Data [x, y] -= coldness; //   float heightValue = (float)HeightMap.Get (x1, y1, z1); if (heightValue &gt; HeightData.Max) HeightData.Max = heightValue; if (heightValue &lt; HeightData.Min) HeightData.Min = heightValue; HeightData.Data [x, y] = heightValue; //   float moistureValue = (float)MoistureMap.Get (x1, y1, z1); if (moistureValue &gt; MoistureData.Max) MoistureData.Max = moistureValue; if (moistureValue &lt; MoistureData.Min) MoistureData.Min = moistureValue; MoistureData.Data [x, y] = moistureValue; curLon += xDelta; } curLat += yDelta; } }</span></span></code> </pre><br>  We obtain, respectively, a height map, a heat map, a humidity map and a biome map: <br><br><img src="https://habrastorage.org/files/759/8f5/6e8/7598f56e8dc545bda89fc7969107a469.png" alt="image"><br><br>  Notice that the cards bend near the corners.  This is done on purpose, this is how spherical projection works.  Let's apply the biome texture to the sphere and see what happens: <br><br><img src="https://habrastorage.org/files/1d0/225/446/1d022544603043eb8e8d8813911ed282.png" alt="image"><br><br>  Not a bad start.  Please note, our elevation map has become black and white.  We did this in order to use the height map as a shader sphere.  For the best effect, we need a relief texture, so we will first render a black and white texture that reflects the displacements we need.  This texture will then be converted into a relief texture with the following code: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Texture2D </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CalculateBumpMap</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Texture2D source, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> strength</span></span></span><span class="hljs-function">)</span></span> { Texture2D result; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> xLeft, xRight; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> yUp, yDown; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> yDelta, xDelta; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pixels = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Color[source.width * source.height]; strength = Mathf.Clamp(strength, <span class="hljs-number"><span class="hljs-number">0.0F</span></span>, <span class="hljs-number"><span class="hljs-number">10.0F</span></span>); result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Texture2D(source.width, source.height, TextureFormat.ARGB32, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> &lt; result.height; <span class="hljs-keyword"><span class="hljs-keyword">by</span></span>++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> bx = <span class="hljs-number"><span class="hljs-number">0</span></span>; bx &lt; result.width; bx++) { xLeft = source.GetPixel(bx - <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">by</span></span>).grayscale * strength; xRight = source.GetPixel(bx + <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">by</span></span>).grayscale * strength; yUp = source.GetPixel(bx, <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> - <span class="hljs-number"><span class="hljs-number">1</span></span>).grayscale * strength; yDown = source.GetPixel(bx, <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>).grayscale * strength; xDelta = ((xLeft - xRight) + <span class="hljs-number"><span class="hljs-number">1</span></span>) * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; yDelta = ((yUp - yDown) + <span class="hljs-number"><span class="hljs-number">1</span></span>) * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; pixels[bx + <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> * source.width] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Color(xDelta, yDelta, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, yDelta); } } result.SetPixels(pixels); result.wrapMode = TextureWrapMode.Clamp; result.Apply(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre><br>  By transferring the left texture to this function, we obtain the relief texture shown on the right: <br><br><img src="https://habrastorage.org/files/fee/790/230/fee7902301124dfe9a48b77786e5da22.png" alt="image"><br><br>  Now, if we apply this relief map along with a height map through a standard shader to our sphere, we will get the following: <br><br><img src="https://habrastorage.org/files/2e0/0a1/6e4/2e00a16e4ca54ba39c79bfa06fd55da1.png" alt="image"><br><br>  To further enhance the image, we will add a couple of cloud layers.  Generating clouds using noise is very simple, so why not.  We use a billow noise module to create clouds. <br><br>  Add two layers of clouds to give them depth.  The cloud noise generator code is shown below: <br><br><pre> <code class="cs hljs">Cloud1Map = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ImplicitFractal(FractalType.BILLOW, BasisType.SIMPLEX, InterpolationType.QUINTIC, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">1.65f</span></span>, Seed); Cloud2Map = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ImplicitFractal (FractalType.BILLOW, BasisType.SIMPLEX, InterpolationType.QUINTIC, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">1.75f</span></span>, Seed);</code> </pre><br>  We use data in the same way.  The cloud texture generator is a simple linear interpolator (lerp) from white to transparent white.  We cut the clouds to the set value, making everything else transparent.  The cloud texture generator code is as follows: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Texture2D </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetCloudTexture</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> width, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> height, Tile[,] tiles, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> cutoff</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> texture = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Texture2D(width, height); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pixels = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Color[width * height]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; width; x++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> y = <span class="hljs-number"><span class="hljs-number">0</span></span>; y &lt; height; y++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tiles[x,y].CloudValue &gt; cutoff) pixels[x + y * width] = Color.Lerp(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Color(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), Color.white, tiles[x,y].CloudValue); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> pixels[x + y * width] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Color(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>); } } texture.SetPixels(pixels); texture.wrapMode = TextureWrapMode.Clamp; texture.Apply(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> texture; }</code> </pre><br>  Let's create with it two different cloud textures.  These textures are also created for spherical projection, therefore they have bends along the edges: <br><br><img src="https://habrastorage.org/files/78f/76e/a55/78f76ea556854318a45514eed3ff7f8f.png" alt="image"><br><br>  Now add two spherical meshes a bit larger than the original sphere.  By applying cloud textures to the standard fade shader, we get beautiful looking cloudiness: <br><br><img src="https://habrastorage.org/files/aae/4e7/7a5/aae4e77a5b8746808094ae86cd312a49.gif" alt="image"><br><br>  At the end, I provide a screenshot of all the generated textures used to create the final render of the planet: <br><br><img src="https://habrastorage.org/files/9f7/399/f89/9f7399f89c2144f1a6b4188b1da057b5.png" alt="image"><br><br>  This concludes the series of articles.  The source code of the entire project on github: <a href="https://github.com/jongallant/WorldGeneratorFinal">World Generator Final</a> . </div><p>Source: <a href="https://habr.com/ru/post/276551/">https://habr.com/ru/post/276551/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../276539/index.html">This is the future</a></li>
<li><a href="../276541/index.html">The report on the results of visits to ISC-2015</a></li>
<li><a href="../276545/index.html">FBI: Hedge Fund Traders Share Insider Information in the Call of Duty Game Chat</a></li>
<li><a href="../276547/index.html">Install Azure Stack TP1</a></li>
<li><a href="../276549/index.html">Query Performance Insight: Who Eats Your Database Resources?</a></li>
<li><a href="../276557/index.html">Methods of creating images on the example of Docker</a></li>
<li><a href="../276561/index.html">Automated access to SharePoint. How to facilitate the work of the administrator and to establish control over the distribution of rights</a></li>
<li><a href="../276563/index.html">Connectivity components in a dynamic graph in one pass</a></li>
<li><a href="../276565/index.html">You are not that paranoidÔºÅ (pre-friday post)</a></li>
<li><a href="../276567/index.html">Online audio advertising: everyone will be heard</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>