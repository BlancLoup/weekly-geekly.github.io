<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Looking for the perfect file storage</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Earlier we considered a prototype of a scalable read-only file system. It was possible to show that, using the proposed architecture, it is possible t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Looking for the perfect file storage</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/924/599/415/924599415dd64a0b8c896e38d32567e4.PNG"><br>  <a href="http://habrahabr.ru/company/2gis/blog/198564/">Earlier</a> we considered a prototype of a scalable read-only file system.  It was possible to show that, using the proposed architecture, it is possible to build a file system of any capacity, with guaranteed access time, commensurate with that for accessing a file within one physical disk. <br>  Next, we will try to figure out whether such an approach can be useful in building a general-purpose file system. <br><a name="habracut"></a><br>  It is worth noting in advance that the author is not a recognized expert in the field of distributed file systems and does not set as his goal to bring happiness to mankind with another ingenious invention.  Rather, I want to demonstrate the community a sensible idea and try to shake it in the discussion.  In addition, public discussion can save the idea from enclosing patents. <br><br><h4>  So, we recall the main conclusions </h4>  which were made when building a read-only prototype system: <br><ol><li>  The contents of the file system can be divided into two parts. <br><ul><li>  Actually data, file contents </li><li>  Metadata describing the location of files and related information </li></ul></li><li>  Metadata should not be part of the file system structure; it is just data about other data.  There should be no special mechanisms responsible for the user-defined structure of the file system. </li><li>  To describe a file system, its representation is well suited as a tree, in which the key is the path, and the value is the file data (and the appendage from the attributes). </li><li>  Metadata is easily compressed. </li><li>  Data and metadata can be stored on various media, including media with different physical structure.  So, relatively small in terms of metadata can be placed on faster and more expensive devices, and the actual file data - on something simpler. </li></ol><br><br><h4>  Now the goals you want to achieve: </h4><br><ol><li>  Modularity (scalability) by capacity </li><li>  Performance modularity </li><li>  External Interface Modularity </li><li>  Logarithmic performance degradation with data growth </li></ol>  Under the modularity refers to the ability to increase the corresponding capacity block by block if they become a bottleneck. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In general, we are not talking about a distributed network of devices laid on a physical network of an incomprehensible topology.  It is assumed that everything looks like a single device that implements the functions of a general-purpose file system.  And the internal structure is our purely internal matter. <br><br><h4>  Little about the problems </h4>  . <br>  Modularity is good, but let's start from the end, with logarithmic performance degradation.  What does the use of a balanced tree mean? <br><br>  A tree is a well-known and understandable structure that has long been successfully used in DBMS and file systems.  The undoubted advantage of balanced trees is the ability to grow and shrink without degradation, while maintaining acceptable utilization of disk space. <br><br>  In our case, the file system is the tree, where the key is the path to the file, and the value is its attributes and the file body.  Moreover, the body is an analogue of a BLOB and can be located in another address space, for example, in a different storage environment. <br><br>  The initial impulse was just that - but what if you make a ‚Äúsuper-tree‚Äù, the ‚Äúsuper-pages‚Äù of which will be autonomous disk subsystems that, when overflowed, logically fall apart in two, just like in the B-tree.  In case of under-fulfillment, two super-pages logically merge into one, unnecessary disk space goes back to the reserve.  It is assumed that the transitions within the super-pages are relatively cheap, and between them - are expensive. <br><br>  Unfortunately, being implemented in the forehead, such a scheme is not viable.  The explanation is rather boring, but it is necessary. <br><br>  Trees imply a paged organization of disk space.  Once the pages link to each other, page identifiers must exist.  A page identifier is a number that can easily be converted to an offset within a file / device.  The identifier space is one-dimensional, even if the pages are on a heap of disks, we must indicate in advance (possibly implicitly) how we are going to cut the address space on these devices. <br><br>  What follows from this?  On the one hand, when writing to the file system, we deal with the one-dimensional order of the file paths, and we do not manage these paths, the user is free to name the files / directories as he pleases. <br>  On the other hand, there is a one-dimensional page identifier space, the order of which is somehow related to the sequence of file creation.  We also do not control this order. <br><br>  There is no natural connection between the order of traversing the tree of files and the order of pages that you have to read, there is no.  Of course, correlations can occur, for example, when unpacking from an archive, but it is hardly reasonable to rely on such a link.  And the situation when logically similar information is physically strongly divided (the locality of links is broken) is quite normal and very likely. <br><br>  Here is the phase diagram of reading pages when the test B-tree is thrown over, constructed by inserting it in an arbitrary order: <br><img src="https://habrastorage.org/files/0ce/59a/b85/0ce59ab85ded48088c34529d5b6bc03e.PNG" alt="image"><br>  <b>FIG.</b>  <b>one</b> <br><br>  On the abscissa - the number of the current readable page, on the ordinate - read the last time. <br><br>  And so - a tree containing the same data passed through the ‚Äúsettler‚Äù, a buffer-drive, when overflowed which data is sorted before recording: <br><img src="https://habrastorage.org/files/3cb/978/cb9/3cb978cb910b4eec89dea44ac9be36eb.PNG" alt="image"><br>  <b>Fig 2</b> <br><br>  Ideally, when the order of insertion coincides with the natural order of the key, we would have just a diagonal line. <br><br>  In the case of recording file system metadata, the use of a ‚Äúsettling tank‚Äù is impossible and when filling the tree, the pages will be allocated in accordance with, rather, the first option. <br><br>  What does it threaten with?  The fact that when it comes time to cut the super-page, we will face a difficult choice: <br><ul><li>  or perezalit content half of the page on the free space of the new page, which may require a lot of time.  In an ordinary B-tree, there is no such problem.  The overflowed page is already in RAM and copying a part of its contents is dismissively cheap compared to the allocation of a new page. </li><li>  or reconcile with the fact that it is not possible to isolate the super-pages from each other and when splitting a mass of horizontal links will arise.  Over time, this will lead to erosion of link locality and performance degradation .. Let us turn once more to Fig 1 and imagine that we have 6 super pages (by the number of cells) and every time the beam goes across the grid, we switch from one super- pages to another.  And, of course, we pay for it with time.  You can, of course, console yourself with the fact that the logarithmic degradation of performance with the growth of a tree is achieved by the very fact of the existence of the tree.  Even if every step during the descent through the tree will be accompanied by a transition to another super-page, it will still be logarithm, albeit with an unpleasant coefficient.  As if we had turned off the disk cache in the normal file system and every access required physical operations with the device.  But no, I want something more effective. </li></ul><br><h4>  On the dimension of the space of identifiers. </h4><br>  An awkward question, why do we consider the page identifier space to be one-dimensional?  Partly for historical reasons, but mainly because it suits everyone and there is no reason to change anything.  Technically, it is not difficult, with hundreds / thousands of disks, to make two-dimensional page addressing - (disk ID, position on disk) or three-dimensional (pile ID, disk ID, disk space).  It is not clear, however, what to do with such an anisotropic address space, but the fact of technical possibility has yet to be comprehended. <br><br>  It's funny, before the author had to puzzle over the question of how to compact the 2-4 dimensional spatial index more efficiently into a one-dimensional page address space.  And now we need to construct the page space in such a way as to place two one-dimensional spaces in it ‚Äî the paths and the order in which the files are created.  A successful design will be able to perform the role of a ‚Äúsump‚Äù, increase the locality of the file system and reduce the number of long / expensive transitions in it. <br><br><h4>  Let's start, perhaps. </h4><br>  Let's start with the description of the basic elements: <br><ul><li>  <b>metadata tree</b> - file system metadata storage.  The key in the tree is the file path, the value is the file metadata and a link to the file body.  The tree is completely balanced.  The expected tree height depends on the number of elements that can be placed on the page.  For example, if it is an average of 10 elements, then for a billion files a tree of height 9 is required, if 100 is then 5. Accordingly, the access speed will differ by 2 times. </li><li> <b>page</b> - metadata tree element.  Sheet pages contain both key and metadata, intermediate pages contain only keys and links to child pages.  The link to the page must be unique within the entire file system.  How to achieve this, see below.  It is expected that the pages lie on fast storage devices with minimal positioning time, SSD, for example. <br>  Separately dwell on the root page of the tree.  As the tree grows, the root page can wander from place to place and a mechanism is needed by which at any time you can find out which page is currently the root page.  This indicates the need for a registry. <br>  In general, it is assumed that the tree page contains at least 2 elements.  And in every element we have a key of arbitrary length.  This is a difficult moment, we will not delve into it for now, let's just assume that a solution exists based on, for example, the fact that <br><ul><li>  Page elements are ordered and most likely contain a common prefix. </li><li>  This prefix can be calculated when browsing the parent pages. </li><li>  Paths are easily compressed </li><li>  The use of dictionaries is possible. </li><li>  The size of the page we choose </li><li>  There may be reasonable restrictions on the lengths of names and paths. </li></ul><br></li><li>  <b>The body of the</b> file is what it was all about.  Everything else is just a frame for this jewel.  We will assume that, unlike pages, access to bodies is more streaming and less erratic.  So it is possible to locate them on cheaper ordinary hard drives.  The body can consist of several fragments; for each fragment, its own entry is made in the tree.  It is important that the fragments of a single body are physically located as close as possible. </li><li>  <b>the disk</b> .  There are two types - SSD (for pages) and regular hard drives (HDD) (for phone files).  We assume that it is fail-safe, for example, when implemented as a RAID.  It has a unique identifier within the entire file system. </li><li>  <b>storage module</b> .  What we called above the ‚Äúsuper page‚Äù.  Designed to work with both pages and file bodies.  Consequently, consists of two types of disks.  Wherein <br><ul><li>  The module contains those body fragments, links to which are in its pages.  In this sense, it is autonomous. </li><li>  It has a unique identifier within the entire file system. </li><li>  A module may consist of a different, albeit limited, number of disks of both types. </li><li>  It is assumed that there is a pool of free disks from which the module can draw them as its fullness grows. </li><li>  This pool can be common to all modules and then there should be a mechanism for switching disks with storage modules.  Or another extreme option - the module holds some number of disks in the reserve and signals when the reserve runs out, after which the disks can be connected ‚Äúby hand‚Äù.  And maybe some intermediate option. </li><li>  At some point, the number of serviced disks of one of the types ends and the storage module becomes crowded. </li></ul></li><li>  <b>Executive module</b> - implements work with the tree.  And also carries out the appropriate work with the bodies of files.  Able to search, add, delete and modify elements on pages and data regardless of which storage modules all this is located on.  Consequently, it assumes the role of a distributed transaction manager. </li></ul><br><h4>  Let us analyze how the filling of our file system. </h4><br><ul><li>  Suppose we ask the executive module to create a file with a certain name in a certain directory. </li><li>  The executive module creates a global transaction. </li><li>  It also prepares a key - the full file name and tries to insert a new entry into the tree.  The record includes, of course, the file metadata (host, rights, ...), but we keep silent about them for simplicity. </li><li>  Information about the location of the root page is well known. </li><li>  We subtract it and find it in accordance with our key ID of the downstream page (if any). </li><li>  Each page is located on a disk, which in turn belongs to a storage module.  It would be logical if the identifiers of the module and the disk together with the position on the disk make up the page identifier. </li><li>  Thus, from the ID of the lower page, the executive module will find out which storage module which page should be accessed from which disk. </li><li>  We read this page, etc.  recursively down to the leaf page </li><li>  In the leaf page we find a place for our new record and try to insert it.  To do this, we have to capture it by writing from the corresponding storage module.  What, in turn, need a local transaction </li><li>  It may happen that there is not enough space on the leaf page for our new record.  In this case, as it should be, we will create a new page and divide roughly the contents of the old one.  Wherein <br><ul><li>  it makes sense if we create a new page in the same storage module.  The module selects the appropriate disk and creates a page for us on it. </li><li>  We go up one step on the stack of read pages and try to insert a record corresponding to the newly created page into the parent page. </li><li>  To do this, we will have to capture it by writing from its storage module. </li><li>  It may happen that this page is also full and we will have to go a step higher.  And so on up to increasing the height of the tree and creating a new root page. </li></ul></li><li>  As a result, after inserting a new record, we have a global transaction and a number of local transactions.  To fix the insertion, the mechanism of a two-phase commit, for example, an <a href="https://ru.wikipedia.org/wiki/XA_%25D2%25F0%25E0%25ED%25E7%25E0%25EA%25F6%25E8%25E8">XA transaction</a> , suggests itself, where the resource managers (RM) are the storage modules and the system registry, and the transaction manager (TM) is the executive module </li><li>  Since  we are talking about the parallel operation of several executive modules; rather, the XA + model is applicable.  The question of who will take on the role of the CRM (communication resource manager) remains open.  Most likely the same one who keeps the registry </li><li>  When creating a new page, it may be that the storage node of the leaf page is full.  The choice in this situation is small - either to create a new storage module, or to cling to the already existing under-filled one.  Creating new modules is dangerous, it is a rather expensive resource, and their number is physically limited. </li><li>  For a list of incomplete storage modules, you can contact the registry, but the registry knows nothing about the context of the current request and can only issue a random module.  This is fraught with the fact that new pages sprouting from our crowded module will begin to crawl through all other modules, destroying the locality of the data and inhibiting the overall performance.  The script, which I would like to avoid. </li><li>  On the other hand, no one knows the context of the current request better than the current request itself.  We already have a stack of read pages, each of which is assigned to some storage module.  Thus, we have the opportunity to find a new module among the superiors. </li><li>  However, you will have to contact the registry to check for module overcrowding. </li><li>  If it so happens that there are no under-filled ones among them (or all the pages lie in one module), you can dig deeper.  View the contents of all non-leaf pages on the stack in the hope of finding references to previously used storage modules.  If there are several links, you should select the closest one. </li><li>  You can go even further, but for this you have to change the structure of the page.  We will distribute up the stack information about the used storage modules. <br><ul><li>  Let's make every non-leaf page store a list of storage modules in which the page itself and all its descendants are located </li><li>  Each time after creating a new page and after the tree structure has been established (after a possible rebalancing, for example), we spread information about the storage module of this page up the stack of its predecessors. </li><li>  If this module is already registered, nothing happens.  Otherwise, you will have to capture higher-level pages for writing and register a new module in them.  How to make it so that it does not have to rebalance the tree anew, the question is open, you may need to limit the number of registered modules to some reasonable number and reserve space for them </li><li>  Now, when we have a question, to which module to bind a new page (more precisely, which storage module to ask for a new page), we will go up the stack and look for a suitable module in the lists of registered. </li></ul></li><li>  Well, if this does not help, you will have to contact the system to create a new storage module. </li><li>  This is how we got rid of the one-dimensional page address space.  The page identifier has as many as three dimensions (module ID, disk ID, position on disk), although it was possible to do with two, if you throw out the disk identifier and assign the storage module to deal with its addresses.  What does this give?  Flexibility.  For example, if suddenly a tree begins to grow vigorously in some local place, our addresses simply grow in breadth, more or less maintaining their locality.  in a one-dimensional case, this would be much more difficult. </li><li>  Ok, we created an entry in the tree, what about the file body?  With them, the situation is simpler.  bodies do not depend on each other. <br><ul><li>  The file storage module is selected along with the page, the link to which this body points to. </li><li>  As with the page, the body identifier consists of the storage module ID, disk ID, and disk space. </li><li>  Undoubtedly, in the storage module there should be a disk memory distributor, one for all or one for each plug-in drive, it is not important now. </li><li>  Also at the moment it does not matter how this memory distributor works. </li><li>  But it is important that working with file bodies supports distributed transactions at the resource manager level. </li><li>  It is worth noting one subtle point. <br><ul><li>  Suppose some sheet page is full and we are going to cut it. </li><li>  It so happened that the fragments of the page fell into different storage modules. </li><li>  But there were already some records on this page and they pointed to disks from the old module. </li><li>  It would be nice to take and transfer files from one module to another.  But after all, these files can be of considerable size and their transfer can take a lot of time, which we cannot afford </li><li>  Well, okay, let's just allow leaf pages to point to file disks from another storage module.  It turns out something like NUMA, access to other people's file disks from the storage module is possible, but it costs more. </li><li>  Fortunately, this is a relatively rare case, and it can not significantly affect the overall performance. </li><li>  And you can imagine a demon who will walk on a tree and in the background to correct the consequences of such excesses. </li></ul><br></li></ul><br></li></ul><br><h4>  It's time to look at the big picture: </h4><br><img src="https://habrastorage.org/files/b27/306/1d5/b273061d544d414fa1c31dac5ae6e67c.png" alt="image"><br><ol><li>  Front end, </li><li>  I / O module (IO).  Accepts requests from the outside, appoints the performer, waits for a response and sends the result.  By increasing their number, we scale the external bandwidth </li><li>  An internal bus (for example, local ethernet) through which IO modules and executive modules communicate. </li><li>  Another internal tire.  Through it, the storage modules communicate with the executive modules. </li><li>  The executive module implements work with the tree and manages distributed transactions.  Increasing their number, we scale the possibilities of parallel execution of requests. </li><li>  Storage module  With their help, we scale the capacity of the entire system. </li><li>  System registry </li></ol><br><br><h4>  It is time to turn our gaze to the real world and see how the problems described are actually solved. </h4><br>  <b>GlusterFS</b> <br>  Consider the <a href="http://en.wikipedia.org/wiki/Distributed_hash_table">DHT</a> mode as closest to the topic of this article. <br><ul><li>  GlusterFS <b>does not have a dedicated metadata service.</b> </li><li>  Files are distributed between servers using the file systems of these servers (with all their pluses and minuses) </li><li>  File structure is projected onto server file systems (brick in terms of Gluster) </li><li>  It is claimed that distributed storage is based on <a href="http://en.wikipedia.org/wiki/Consistent_hashing">sequential hashing</a> technology, but this is some kind of degenerate case. <br><ul><li>  The full file name is passed through a hash function, which yields a 32-bit value. </li><li>  32-bit range in advance, when setting up the system is divided into ranges - each of which points to a specific server </li><li>  Ranges can be customized by hand, but in this case, you need to very accurately understand what you are doing. </li><li>  Automatic splitting will be performed in chunks of 0xffffffff / (number of servers) </li><li>  When a file is created, its server number is calculated and the file is created in the file system of this server. </li><li>  When searching for a file, <br><ul><li>  the server is calculated in the same way where it should be </li><li>  An attempt is made to read a file from this server. </li><li>  if the attempt is unsuccessful, there is no such file <br><ul><li>  Requests to search for this file are sent to all servers of the system. </li><li>  if the file was found on one of them, a link is created on the source server - a file with the desired name, but zero length, enabled by sticky-bit and xattr, indicating the current server </li><li>  The next time you search for this file, you can not make a broadcast request, and immediately contact the desired server </li></ul></li></ul></li></ul></li><li>  How could it happen that the file was on a foreign server?  For example, the regular server of this file is full.  Or there was a redistribution of the ranges of the hash values, for example, after adding a new server. <br></li><li>  Adding a new server invalidates the share in 1 / (new number of servers) hash values ‚Äã‚Äãduring sequential hashing.  But in the case of the Gluster, this share may be significantly larger due to its ‚Äúnaive‚Äù way of distributing the hash ranges </li><li>  All this leads to the fact that over time the storage facility degrades and special efforts should be made to maintain it in adequate condition. <br><ul><li>  'fix-layout' - go through the node and try to drag files to it, accessible via Link-and </li><li>  'migration' - for each file the server is calculated, where it should be and, if necessary, an attempt is made to transfer there.  Very expensive procedure. </li></ul></li></ul><br>  Sources: <br>  <a href="http://www.gluster.org/">http://www.gluster.org/</a> <br>  <a href="http://cloudfs.org/index.php/2012/03/glusterfs-algorithms-distribution/">http://cloudfs.org/index.php/2012/03/glusterfs-algorithms-distribution/</a> <br>  <a href="http://people.redhat.com/ndevos/talks/Gluster-data-distribution_20120218.pdf">http://people.redhat.com/ndevos/talks/Gluster-data-distribution_20120218.pdf</a> <br><br>  <b>Swift</b> <br><ul><li>  Swift is not a universal file system, but an <a href="https://ru.wikipedia.org/wiki/Amazon_S3">S3-compatible</a> object storage.  Any object is described by the triple ‚Äú/ account / container / object‚Äù, where account indicates the user, container is the user-defined way of grouping objects, and object is the actual path. </li><li>  To simulate the file system, the server for processing containers and accounts that store data in their sqlite3 databases is used. </li><li>  Object storage is similar to GlusterFS, but uses honest sequential hashing, in local terminology this ring <br><img src="https://habrastorage.org/files/251/4db/6d4/2514db6d4bb24126a21bb52a707e2626.png" alt="image"><br><ul><li>  The 160-bit SHA-1 hash value is obtained from the file name. </li><li>  For data storage (in this example) we use 4 nodes </li><li>  The range of hash values ‚Äã‚Äãof the key (in this example) is divided by 32, because  we decided that 32 sections are enough for us </li><li>  Each section is assigned to its node, possibly uneven distribution in accordance with the specified weights. </li><li>  Thus, by the hash value we get the partition number, and by it the number of the storage node </li><li>  The storage node stores files as is, using the native file system (it is important that it supports xattrs) </li><li>  Now, if we decide to add a fifth node to the system, we must <br><ul><li>  reassign the fifth part of each node to a new node </li><li>  Migrate data whose hash values ‚Äã‚Äãare in the ranges of these reassigned sections to the new node.  The 8 (i.e., 32/4) sections are divided into 5 not very well, but at large values ‚Äã‚Äãthe granularity is not so noticeable. </li></ul></li><li>  Be that as it may, data migration is a very expensive procedure, even just filling a terabyte disk takes several hours.  But without migration within the framework of the architecture with sequential hashing, alas, nothing. </li></ul></li><li>  For the purpose of data replication, the concept of a zone is introduced - a storage unit that does not depend on single failures from other zones.  By default, each section consists of three zones.  It is not necessary that all zones be operational at the time of writing the file, after the absent nodes go up, the data is automatically replicated to them. </li><li>  Container and account servers also have their rings, Their sqlite3 databases are also stored and replicated on storage nodes. </li></ul><br>  Sources: <br>  <a href="http://docs.openstack.org/developer/swift/">http://docs.openstack.org/developer/swift/</a> <br>  <a href="http://habrahabr.ru/company/mirantis_openstack/blog/176195/">http://habrahabr.ru/company/mirantis_openstack/blog/176195/</a> <br>  <a href="https://julien.danjou.info/blog/2012/openstack-swift-consistency-analysis">https://julien.danjou.info/blog/2012/openstack-swift-consistency-anysis</a> <br><br>  <b>Cephfs</b> <br><ul><li>  Has a dedicated metadata service - Metadata Cluster, consisting of several Metadata Storage (MDS) in terms of Ceph </li><li>  Data is stored on Object Storage Data (OSD) </li><li>  Including on the ODS store their data and MDS </li><li>  <b>The file system structure is explicitly described in MDS.</b> File system changes are logged and replicated to ODS. </li><li>  It is believed that MDS should mostly work with the cache and read data from the ODS only as a last resort.  Therefore, at some point MDS overflows. </li><li>  Crowded MDS splits.  To make it painlessly <br><ul><li>  It looks like this <img src="https://habrastorage.org/files/a63/232/aa7/a63232aa7bb94586becf1cb73a85db6c.png" alt="image"></li><li>  Each MDS measures the popularity of its subdirectories using a counter with exponential decay over time.  Each operation with a directory increases this counter at the directory itself and all its parent directories of this MDS </li><li>  When MDS overflows, a suitable sub-hierarchy is extracted and transferred to another MDS. </li><li>  This is done invisibly to users, using transactional mechanisms. </li><li>  If a super-popular directory is found, the references to which are far superior to everything else, there is a mechanism to smudge this directory across several MDS </li></ul></li><li>     ODS   <a href="http://ceph.com/papers/weil-crush-sc06.pdf">CRUSH</a> <br><ul><li>   ,      ,  ,    ( )  . </li><li>   ,        . </li><li> ,       ,          .     ethernet ,     .        ,    . </li><li>  , ,  ‚Äî           . </li><li> ,    CRUSH      ,        ODS,        ,           . </li><li>        ,          . </li></ul></li><li>   Ceph    (CephFS)    S3  : <a href="http://ceph.com/papers/weil-rados-pdsw07.pdf">RADOS</a> . Ceph S3  CephFS       .  RADOS  SWIFT     ‚Äî    CRUSH. <br></li></ul><br>  Sources: <br> <a href="http://ceph.com/">http://ceph.com/</a> <br> <a href="http://ceph.com/papers/weil-ceph-osdi06.pdf">http://ceph.com/papers/weil-ceph-osdi06.pdf</a> <br> <a href="http://ceph.com/papers/weil-mds-sc04.pdf">http://ceph.com/papers/weil-mds-sc04.pdf</a> <br> <a href="http://ceph.com/papers/weil-crush-sc06.pdf">http://ceph.com/papers/weil-crush-sc06.pdf</a> <br> <a href="http://ceph.com/papers/weil-rados-pdsw07.pdf">http://ceph.com/papers/weil-rados-pdsw07.pdf</a> <br><br>  ,         ,         . <br><br>  CephFS         .      , , ,       (,  )    . <br><br>      CephFS    . ,    ,    ,     .               .   ,   ,            . <br><br>   S3-         ‚Äî     .         . ,           . <br><br><h4>  . </h4><br>       ?     .     ‚Äú     ‚Äù(). ,         .               . <br><br> <b>PS</b>      (DataEast),   (2)    (2)      . <br><br> <b>PPS</b>       .. ¬´ :    ¬ª. </div><p>Source: <a href="https://habr.com/ru/post/244491/">https://habr.com/ru/post/244491/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../244477/index.html">Web on pure java. Learn Vaadin - a cool web application framework</a></li>
<li><a href="../244479/index.html">Funny bugs</a></li>
<li><a href="../244481/index.html">A few words about working at home</a></li>
<li><a href="../244485/index.html">Sniff the output Tor node and analyze the resulting content.</a></li>
<li><a href="../244487/index.html">Swift Multiple Functions</a></li>
<li><a href="../244493/index.html">Creating the game on your eyes - part 8: Visual scripting of cut scenes in Unity (uScript)</a></li>
<li><a href="../244497/index.html">Factory method without placement in dynamic memory</a></li>
<li><a href="../244505/index.html">Vectorization of cycles: diagnosis and control</a></li>
<li><a href="../244507/index.html">Equalization of histograms for image enhancement</a></li>
<li><a href="../244509/index.html">The project 1C-Tools became the winner of the selection in U.M.NI.K.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>