<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>A bit about JIT compilation or writing an optimized Brainfuck interpreter</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The essence of the language Brainfuck is that we always run through the cells of the tape, reducing or increasing the values ‚Äã‚Äãin them. In cycles, we ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>A bit about JIT compilation or writing an optimized Brainfuck interpreter</h1><div class="post__text post__text-html js-mediator-article">  The essence of the language Brainfuck is that we always run through the cells of the tape, reducing or increasing the values ‚Äã‚Äãin them.  In cycles, we can run from one end to the other, counting something, often using many nested loops.  It is not difficult to guess that the interpretation of this language is relatively slow.  Of course, on modern computers this is almost not noticeable, but ... I offer a small test: take the interpreter written by you, and run this code that is not tricky: <br><br><pre><code class="perl hljs">&gt;+&gt;+&gt;+&gt;+&gt;++&lt;[&gt;[&lt;+++&gt;- &gt;&gt;&gt;&gt;&gt; &gt;+&gt;+&gt;+&gt;+&gt;++&lt;[&gt;[&lt;+++&gt;- &gt;&gt;&gt;&gt;&gt; &gt;+&gt;+&gt;+&gt;+&gt;++&lt;[&gt;[&lt;+++&gt;- &gt;&gt;&gt;&gt;&gt; &gt;+&gt;+&gt;+&gt;+&gt;++&lt;[&gt;[&lt;+++&gt;- &gt;&gt;&gt;&gt;&gt; +++[-&gt;+++++&lt;]&gt;[-]&lt; &lt;&lt;&lt;&lt;&lt; ]&lt;&lt;]&gt;[-] &lt;&lt;&lt;&lt;&lt; ]&lt;&lt;]&gt;[-] &lt;&lt;&lt;&lt;&lt; ]&lt;&lt;]&gt;[-] &lt;&lt;&lt;&lt;&lt; ]&lt;&lt;]&gt;.</code> </pre> <br><br>  Waited for the end of execution?  Agree that it was not as fast as it seemed at once.  Well, let's see how to make an interpreter that will execute this code in no more than a few seconds. <br><a name="habracut"></a><br>  At the core lies the idea of ‚Äã‚ÄãJIT compilation.  Wikipedia tells us that JIT compilation is a technology to increase the performance of software systems that use bytecode by compiling bytecode into native code while the program is running.  A little thought, I decided that it would be much more expedient to immediately build the entire necessary array of machine code, and not replace it during operation.  I think that the essence of this does not change much.  But, let's order. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      So, as everyone already knows, the syntax of the Brainfuck language consists of only 8 operators.  There is a set of memory cells and a pointer to the current cell.  In fact, as a result of the program execution, we need to convert the code on Brainfuck into assembly commands (their machine codes) of the x86 processor.  For this, it is nice to have some idea of ‚Äã‚Äãthe assembly language, as well as the rules for generating machine codes (opcodes).  We will replace each command on Brainfuck with one or several x86 processor commands. <br><br>  First of all, you need to create an array of memory cells and get a pointer to it.  This can be done using the dynamic allocation function.  So, in the Pascal programming language (and the further code of examples will be on it), this can be done as follows: <br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">Var</span></span> Stack : Pointer; Begin GetMem(Stack,<span class="hljs-number"><span class="hljs-number">30000</span></span>); <span class="hljs-comment"><span class="hljs-comment">//    brainfuck - 30000 End;</span></span></code> </pre><br>  Next, you need to think about the strategy for processing Brainfuck commands.  I used the following: <br>  We agree that the pointer to the array of cells will be stored in the <strong>ESI</strong> register. <br><pre> <code class="php hljs">mov esi, Stack</code> </pre><br><br>  Then, the remaining teams will be: <br><table><tbody><tr><td>  Brainfuck </td><td>  Assembler </td><td>  Opcode </td></tr><tr><td>  + </td><td>  inc byte [esi] </td><td>  FE 06 </td></tr><tr><td>  - </td><td>  dec byte [esi] </td><td>  FE 0E </td></tr><tr><td>  &gt; </td><td>  inc esi </td><td>  46 </td></tr><tr><td>  &lt; </td><td>  dec esi </td><td>  4E </td></tr><tr><td>  [ </td><td>  cmp byte [esi], 0 </td><td>  80 3E 00 </td></tr><tr><td></td><td>  je "] +1" </td><td>  0F 84 xx xx xx xx or 74 xx </td></tr><tr><td>  ] </td><td>  jmp "[" </td><td>  E9 xx xx xx xx or EB xx </td></tr></tbody></table><br><br>  As for the commands '.'  and ',', then the procedure for displaying the symbol and the water symbol function will be needed here.  They can be implemented as follows: <br><br><pre> <code class="php hljs">procedure WriteChar(S: Char); begin Write(S); end; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReadChar</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Char</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> c : char; begin Read(c ); ReadChar := c; end;</code> </pre><br>  Then, it can be agreed that the <strong>EDX</strong> register, when the executable code starts, contains the address of the procedure for printing the character <br><pre> <code class="php hljs">mov edx, offset WriteChar</code> </pre> <br>  and EBX register is the address of the character input function: <br><pre> <code class="php hljs">mov ebx, offset ReadChar</code> </pre> <br>  Then, handle the '.'  Can be as follows: <br><pre> <code class="php hljs">mov al,[esi] <span class="hljs-number"><span class="hljs-number">8</span></span>A <span class="hljs-number"><span class="hljs-number">06</span></span> ;  AL    cbw <span class="hljs-number"><span class="hljs-number">66</span></span> <span class="hljs-number"><span class="hljs-number">98</span></span> ;    EAX push eax <span class="hljs-number"><span class="hljs-number">50</span></span> ;     () call edx FF D2 ;  WriteChar</code> </pre> <br>  And the command ‚Äú,‚Äù like this: <br><pre> <code class="php hljs">call ebx FF D3;  ReadChar mov [esi],al <span class="hljs-number"><span class="hljs-number">88</span></span> <span class="hljs-number"><span class="hljs-number">06</span></span>;      </code> </pre><br>  For simplicity, we will create a static array of ExBuf, where we will put all our opcodes, and then transfer control to the beginning of the array.  The variable ptr will be the pointer of the last opcode entered. <br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">Var</span></span> ExBuf : <span class="hljs-keyword"><span class="hljs-keyword">Array</span></span> [<span class="hljs-number"><span class="hljs-number">1.</span></span><span class="hljs-number"><span class="hljs-number">.65535</span></span>] of Byte; Ptr : Word; Tmp : LongInt;</code> </pre> <br>  The first three commands in our code block are, as we agreed, setting the <strong>ESI</strong> register to the cell pointer, the <strong>EDX</strong> register to the WriteChar procedure pointer, and the <strong>EBX</strong> register to the ReadChar function pointer.  You can do it like this: <br><pre> <code class="php hljs"> ptr := <span class="hljs-number"><span class="hljs-number">1</span></span>; ExBuf[ptr] := $BE; inc(ptr); <span class="hljs-comment"><span class="hljs-comment">// mov esi,Stack asm mov edx,Stack mov Tmp,edx end; Move(Tmp,ExBuf[ptr],4); inc(ptr,4); ExBuf[ptr] := $BA; inc(ptr); // mov edx,offset WriteChar asm mov edx, offset WriteChar mov Tmp, edx end; Move(Tmp,ExBuf[ptr],4); inc(ptr,4); ExBuf[ptr] := $BB; inc(ptr); // mov ebx,offset ReadChar asm mov edx, offset ReadChar mov Tmp, edx end; Move(Tmp,ExBuf[ptr],4); inc(ptr,4);</span></span></code> </pre> <br><br>  Everything, primary initialization is carried out.  Now you need to write a procedure for processing Brainfuck codes.  For the first teams, it can be like this: <br><pre> <code class="php hljs">Procedure JITCode(S: Char); Begin <span class="hljs-keyword"><span class="hljs-keyword">Case</span></span> S of <span class="hljs-string"><span class="hljs-string">'+'</span></span>: Begin ExBuf[ptr] := $FE; <span class="hljs-comment"><span class="hljs-comment">//inc byte ptr [esi] ExBuf[ptr+1] := $06; Inc(ptr,2); End; '-': Begin ExBuf[ptr] := $FE; //dec byte ptr [esi] ExBuf[ptr+1] := $0E; Inc(ptr,2); End; '&gt;': Begin ExBuf[ptr] := $46; //inc esi Inc(ptr); End; '&lt;': Begin ExBuf[ptr] := $4E; //dec esi Inc(ptr); End; '.': Begin ExBuf[ptr] := $8A; //mov al,[esi] ExBuf[ptr+1] := $06; Inc(ptr,2); ExBuf[ptr] := $66; //cbw ExBuf[ptr+1] := $98; Inc(ptr,2); ExBuf[ptr] := $50; //push eax Inc(ptr); ExBuf[ptr] := $FF; //call edx ExBuf[ptr+1] := $D2; Inc(ptr,2); End; ',': Begin ExBuf[ptr] := $FF; //call ReadChar ExBuf[ptr+1] := $D3; Inc(ptr,2); ExBuf[ptr] := $88; //mov [esi],al ExBuf[ptr+1] := $06; Inc(ptr,2); End; End;</span></span></code> </pre> <br>  At the input of the procedure, we alternately transfer Brainfuck codes, which are converted into machine codes and are gradually entered into the ExBuf array. <br>  The situation with the '[' and ']' loop commands is somewhat more complicated.  As we all remember, x86 processors have several addressing modes, and accordingly, several near commands or short (short) transitions.  So, if the total length of opcodes between a transition command and a label does not exceed 127 bytes, you can use short (short) transitions.  If it is more, then near commands will be needed.  I implemented it as follows: when meeting the command '[', I generate the command je near xxx and memorize in the additional array the current position of the command buffer.  After, when the ']' command is encountered in the code, I calculate the difference between the beginning of the cycle and the end (byte length), and if it is less than 127 bytes, I return to the memorized position, overwrite the old je near xxx with je short xxx and transfer the rest of the code four bytes ahead.  With this in mind, it remains to supplement the above JITCode procedure: <br><pre> <code class="php hljs"> <span class="hljs-string"><span class="hljs-string">'['</span></span>: Begin ExBuf[ptr] := $<span class="hljs-number"><span class="hljs-number">80</span></span>; <span class="hljs-comment"><span class="hljs-comment">//cmp byte ptr [esi],0 ExBuf[ptr+1] := $3E; ExBuf[ptr+2] := $00; Inc(ptr,3); ExBuf[ptr] := $0F; //je near xxx ExBuf[ptr+1] := $84; Inc(ptr,2); bstack[bcnt] := ptr; inc(bcnt); Inc(ptr,4); End; ']': Begin Tmp := ptr - bstack[bcnt-1]; If Tmp &gt; 122 then begin ExBuf[ptr] := $E9; //jmp Inc(ptr); Inc(Tmp); Move(Tmp,ExBuf[bstack[bcnt-1]],4); Tmp := -Tmp-9; Move(Tmp,ExBuf[ptr],4); Inc(ptr,4); Dec(bcnt); end else begin ExBuf[ptr] := $EB; //jmp short Inc(ptr); ExBuf[bstack[bcnt-1]-2] := $74; // je short xxx Dec(Tmp,2); Move(Tmp,ExBuf[bstack[bcnt-1]-1],1); Tmp := -Tmp-5; Move(Tmp,ExBuf[ptr],1); Inc(ptr); Move(ExBuf[bstack[bcnt-1]+4],ExBuf[bstack[bcnt-1]],ptr-bstack[bcnt-1]-4); Dec(ptr,4); Dec(bcnt); end; End;</span></span></code> </pre> <br>  That's practically all, this is a ready-made working implementation.  It remains not much at all - write the last command ret (return from the procedure).  Its opcode is 0xC3: <br><pre> <code class="php hljs"> ExBuf[ptr] := $C3; <span class="hljs-comment"><span class="hljs-comment">//retn</span></span></code> </pre> <br>  And transfer control to the generated machine instruction buffer: <br><pre> <code class="php hljs"> asm mov edx,offset ExBuf call edx end;</code> </pre> <br><br>  But let's see what else can be done with the optimization of our program.  An idea that literally lies on the surface: in the Brainfuck code, repetitive commands of the same type are often encountered, for example +++++++++++ or &lt;&lt;&lt;&lt;.  What does it mean to increase the current cell by 11 or move the cell pointer 4 left?  You can enter additional characters to indicate the following: <br><br>  &lt;&lt;&lt;&lt;&lt; = is replaced by p # (prev) right shift of the pointer to the left by # values <br>  &gt;&gt;&gt;&gt;&gt; = replaced by n # (next) right shift of pointer to # of values <br>  +++++ = is replaced by i # (inc) increasing the current cell immediately to # <br>  - = is replaced by d # (dec) decrementing the current cell immediately to # <br>  [-], [+] = is replaced by z (zero) setting the cell value to 0 <br><br>  Such preprocessing can be carried out at the beginning of the interpreter.  Sometimes, this gives a significant decrease in the source code on Brainfuck, and as a result, a decrease in the x86 code.  After this processing, it remains to supplement our JITCode procedure: <br><pre> <code class="php hljs"> <span class="hljs-string"><span class="hljs-string">'i'</span></span>: Begin ExBuf[ptr] := $<span class="hljs-number"><span class="hljs-number">80</span></span>; <span class="hljs-comment"><span class="hljs-comment">//add byte ptr [esi],xx ExBuf[ptr+1] := $06; ExBuf[ptr+2] := Ord(Buf[i+1]); Inc(i); Inc(ptr,3); End; 'd': Begin ExBuf[ptr] := $80; //sub byte ptr [esi],xx ExBuf[ptr+1] := $2E; ExBuf[ptr+2] := Ord(Buf[i+1]); Inc(i); Inc(ptr,3); End; 'n': Begin ExBuf[ptr] := $83; //add esi,xx ExBuf[ptr+1] := $C6; ExBuf[ptr+2] := Ord(Buf[i+1]); Inc(i); Inc(ptr,3); End; 'p': Begin ExBuf[ptr] := $83; //sub esi,xx ExBuf[ptr+1] := $EE; ExBuf[ptr+2] := Ord(Buf[i+1]); Inc(i); Inc(ptr,3); End; 'z': Begin ExBuf[ptr] := $C6; //mov byte ptr [esi],0 ExBuf[ptr+1] := $06; ExBuf[ptr+2] := $00; Inc(ptr,3); End;</span></span></code> </pre> <br><br>  Download the source code and compiled Win32 version here: <a href="http://rghost.ru/4249797">rghost.ru/4249797</a> <br><br>  The program has the keys: <br>  -c - create an OUT.BC file on the disk containing an intermediate byte code after the preprocessor. <br>  -b - create the BF.BIN file on the disk containing the generated array of machine codes.  If you open it in HIEW, then you can see the usual assembly commands. <br><br>  Good luck to all. </div><p>Source: <a href="https://habr.com/ru/post/113339/">https://habr.com/ru/post/113339/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../113334/index.html">All Google I / O tickets sold out in 59 minutes</a></li>
<li><a href="../113335/index.html">Cambridge is better than Moscow</a></li>
<li><a href="../113336/index.html">Calculating the cost of developing the site. Some automation</a></li>
<li><a href="../113337/index.html">Mozilla plans to release four versions of Firefox this year.</a></li>
<li><a href="../113338/index.html">Travel with google</a></li>
<li><a href="../113342/index.html">SCO OpenServer 5.0.7V Virtualization under Hyper-V</a></li>
<li><a href="../113343/index.html">Social goals</a></li>
<li><a href="../113344/index.html">JavaScript 1.8</a></li>
<li><a href="../113345/index.html">Attachment Contest for Internet Explorer 9</a></li>
<li><a href="../113349/index.html">Droider Chart. Issue 38</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>