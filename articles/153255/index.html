<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Methods for calculating multinomial coefficients</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="One day, scrolling through the popular Q & A in mathematics ( math.stackexchange.com ), I discovered a question about calculating multinomial coeffici...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Methods for calculating multinomial coefficients</h1><div class="post__text post__text-html js-mediator-article">  One day, scrolling through the popular Q &amp; A in mathematics ( <a href="http://math.stackexchange.com/">math.stackexchange.com</a> ), I discovered a <a href="http://math.stackexchange.com/q/204085/37427">question</a> about calculating multinomial coefficients and he became interested in me.  Note, for those who do not know what it is, there is an article in <a href="http://en.wikipedia.org/wiki/Multinomial_theorem">Wikipedia</a> .  So, we need to calculate the following expression: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ea4/f21/ff0/ea4f21ff0e387eedd2ed7b10875846c4.png"><br><br>  It seemed, why on Habr√© lay out the solution to such a simple task?  The answer is that the simplest naive method, consisting in multiplying the factorial of the sum and then dividing it by the product of factorials, will not work because intermediate calculations will go beyond the bit grid of the <b>uint</b> type and even <b>ulong</b> , although the result may be within values ‚Äã‚Äãof these types.  I liked this problem, and I immediately sat down to solve it and came up with three ways.  I borrowed the other two ways from other answers.  So, the article will be about the description and comparison of all the methods I implemented in C # under .NET. <br><a name="habracut"></a><br><ul><li>  Big numbers </li><li>  Tabular method </li><li>  Multiplication of binomial coefficients </li><li>  The sum and difference of logarithms </li><li>  The sum and difference of the functions of the "logarithm of factorial" </li><li>  My way </li></ul><br>  Next, I will describe each method. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Big numbers </h4><br>  Of course, the first thing that came to mind was the use of a special type of <b>BigInteger</b> , capable of storing numbers with an arbitrary number of digits.  But this, firstly, is not sporty, and, secondly, not all languages ‚Äã‚Äãhave support for these types (although of course you can write it yourself), but this method certainly always returns the correct result, unlike other methods that have rounding.  By the way, this property allows you to test the accuracy of other methods, which will be discussed later. <br><br>  The code of this method is no different from the naive implementation, except that <b>BigInteger is</b> everywhere instead of <b>uint</b> types.  Therefore, of particular interest is not. <br><div class="spoiler">  <b class="spoiler_title">BigInteger source</b> <div class="spoiler_text"><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> BigInteger </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BigAr</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] numbers</span></span></span><span class="hljs-function">)</span></span> { BigInteger numbersSum = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> number <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> numbers) numbersSum += number; BigInteger nominator = Factorial(numbersSum); BigInteger denominator = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> number <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> numbers) denominator *= Factorial(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BigInteger(number)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> nominator / denominator; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> BigInteger </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Factorial</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BigInteger n</span></span></span><span class="hljs-function">)</span></span> { BigInteger result = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">ulong</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt;= n; i++) result = result * i; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br></div></div><br><br><h4>  Tabular method </h4><br>  It consists in counting all the multinomial coefficients from the given arguments in Microsoft Excel, <a href="http://wolframalpha.com/">wolframalpha.com</a> or other third-party programs / services and entering the calculated coefficients into the source code or a single file.  The disadvantages of this approach are obvious: high memory consumption, the calculation of coefficients not from all the possible possible values ‚Äã‚Äãof the arguments.  Although the performance of this method, of course, on top.  One way or another, this method was not even implemented by me. <br><br><h4>  Binomial coefficients </h4><br>  This method consists in decomposing the expression of a multinomial coefficient into the product of several binomial coefficients according to the following formula: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9b2/3a7/5b6/9b23a75b6ec82752cb1474937a4218c1.png"><br><br>  But here, again, overflow is possible already when calculating the last binomial coefficients.  In order to prevent this from happening, a recursive calculation algorithm for each binomial coefficient is used according to the following formula: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f54/15e/9fe/f5415e9fee17b812fb6583613a58771a.png"><br><br>  The C # code is as follows: <br><div class="spoiler">  <b class="spoiler_title">Binomial source</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">ulong</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BinomAr</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] numbers</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (numbers.Length == <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">ulong</span></span> result = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint</span></span> sum = numbers[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; numbers.Length; i++) { sum += numbers[i]; result *= Binominal(sum, numbers[i]); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">ulong</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Binominal</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ulong</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ulong</span></span></span></span><span class="hljs-function"><span class="hljs-params"> k</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">ulong</span></span> r = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">ulong</span></span> d; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (k &gt; n) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (d = <span class="hljs-number"><span class="hljs-number">1</span></span>; d &lt;= k; d++) { r *= n--; r /= d; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> r; }</code> </pre><br></div></div><br><br><h4>  Logarithms </h4><br>  This method consists in decomposing the original formula into the sum and difference of logarithms as follows: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/393/1e0/473/3931e04732c611da19c6ac01e52d46f5.png"><br><br>  At the very end, of course, it is necessary to raise <b>e</b> to the degree obtained, which will be the result.  A small optimization was also performed, which consisted in dropping the maximum factorial of the denominator from the numerator and denominator.  In order to speed up subsequent calculations, all logarithms are cached into a list (at the end of the article, the performance of this optimization is tested). <br><div class="spoiler">  <b class="spoiler_title">Log source</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> List&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt; Logarithms = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt;(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">ulong</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Log</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">params</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] numbers</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> LogAr(numbers); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">ulong</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LogAr</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] numbers</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> maxNumber = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)numbers.Max(); <span class="hljs-keyword"><span class="hljs-keyword">uint</span></span> numbersSum = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> number <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> numbers) numbersSum += number; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> sum = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">2</span></span>; i &lt;= numbersSum; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i &lt;= maxNumber) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i - <span class="hljs-number"><span class="hljs-number">2</span></span> &gt;= Logarithms.Count) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> log = Math.Log(i); Logarithms.Add(log); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i - <span class="hljs-number"><span class="hljs-number">2</span></span> &lt; Logarithms.Count) sum += Logarithms[i - <span class="hljs-number"><span class="hljs-number">2</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> log = Math.Log(i); Logarithms.Add(log); sum += log; } } } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> maxNumberFirst = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> number <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> numbers) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (number == maxNumber &amp;&amp; !maxNumberFirst) maxNumberFirst = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">2</span></span>; i &lt;= number; i++) sum -= Logarithms[i - <span class="hljs-number"><span class="hljs-number">2</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">ulong</span></span>)Math.Round(Math.Exp(sum)); }</code> </pre><br></div></div><br><br><h4>  Logarithms from factorials </h4><br>  This method does not differ much from the previous one, except that instead of decomposing the logarithm of factorial by the sum of logarithms, a special logarithm function from the gamma function is used, the implementation of which was taken from <a href="http://www.alglib.net/specialfunctions/gamma.php">alglib</a> .  In fact, there are other, shorter implementations (for example, in Math.NET), but it seemed to me that if the size of the implementation code in alglib is the largest, the implementation itself is the most accurate. <br><div class="spoiler">  <b class="spoiler_title">LogGamma source</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt; LnFacts = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt;(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">ulong</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LogGammaAr</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] numbers</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> maxNumber = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)numbers.Max(); <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> denom = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint</span></span> numbersSum = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> number <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> numbers) { numbersSum += number; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (LnFacts.TryGetValue(number, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>)) denom += <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = LnGamma(number + <span class="hljs-number"><span class="hljs-number">1</span></span>); LnFacts.Add(number, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>); denom += <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> numer; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (LnFacts.TryGetValue(numbersSum, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>)) numer = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = LnGamma(numbersSum + <span class="hljs-number"><span class="hljs-number">1</span></span>); LnFacts.Add(numbersSum, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>); numer = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">ulong</span></span>)Math.Round(Math.Exp(numer - denom)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LnGamma</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> sign = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> LnGamma(x, <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> sign); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LnGamma</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sgngam</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> result = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> a = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> b = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> c = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> p = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> q = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> u = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> w = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> z = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> logpi = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> ls2pi = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> tmp = <span class="hljs-number"><span class="hljs-number">0</span></span>; sgngam = <span class="hljs-number"><span class="hljs-number">0</span></span>; sgngam = <span class="hljs-number"><span class="hljs-number">1</span></span>; logpi = <span class="hljs-number"><span class="hljs-number">1.14472988584940017414</span></span>; ls2pi = <span class="hljs-number"><span class="hljs-number">0.91893853320467274178</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>)(x) &lt; (<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>)(<span class="hljs-number"><span class="hljs-number">-34.0</span></span>)) { q = -x; w = LnGamma(q, <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> tmp); p = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)Math.Floor(q); i = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)Math.Round(p); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i % <span class="hljs-number"><span class="hljs-number">2</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span>) { sgngam = <span class="hljs-number"><span class="hljs-number">-1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { sgngam = <span class="hljs-number"><span class="hljs-number">1</span></span>; } z = q - p; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>)(z) &gt; (<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>)(<span class="hljs-number"><span class="hljs-number">0.5</span></span>)) { p = p + <span class="hljs-number"><span class="hljs-number">1</span></span>; z = p - q; } z = q * Math.Sin(Math.PI * z); result = logpi - Math.Log(z) - w; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>)(x) &lt; (<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>)(<span class="hljs-number"><span class="hljs-number">13</span></span>)) { z = <span class="hljs-number"><span class="hljs-number">1</span></span>; p = <span class="hljs-number"><span class="hljs-number">0</span></span>; u = x; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ((<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>)(u) &gt;= (<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>)(<span class="hljs-number"><span class="hljs-number">3</span></span>)) { p = p - <span class="hljs-number"><span class="hljs-number">1</span></span>; u = x + p; z = z * u; } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ((<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>)(u) &lt; (<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>)(<span class="hljs-number"><span class="hljs-number">2</span></span>)) { z = z / u; p = p + <span class="hljs-number"><span class="hljs-number">1</span></span>; u = x + p; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>)(z) &lt; (<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>)(<span class="hljs-number"><span class="hljs-number">0</span></span>)) { sgngam = <span class="hljs-number"><span class="hljs-number">-1</span></span>; z = -z; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { sgngam = <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>)(u) == (<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>)(<span class="hljs-number"><span class="hljs-number">2</span></span>)) { result = Math.Log(z); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } p = p - <span class="hljs-number"><span class="hljs-number">2</span></span>; x = x + p; b = <span class="hljs-number"><span class="hljs-number">-1378.25152569120859100</span></span>; b = <span class="hljs-number"><span class="hljs-number">-38801.6315134637840924</span></span> + x * b; b = <span class="hljs-number"><span class="hljs-number">-331612.992738871184744</span></span> + x * b; b = <span class="hljs-number"><span class="hljs-number">-1162370.97492762307383</span></span> + x * b; b = <span class="hljs-number"><span class="hljs-number">-1721737.00820839662146</span></span> + x * b; b = <span class="hljs-number"><span class="hljs-number">-853555.664245765465627</span></span> + x * b; c = <span class="hljs-number"><span class="hljs-number">1</span></span>; c = <span class="hljs-number"><span class="hljs-number">-351.815701436523470549</span></span> + x * c; c = <span class="hljs-number"><span class="hljs-number">-17064.2106651881159223</span></span> + x * c; c = <span class="hljs-number"><span class="hljs-number">-220528.590553854454839</span></span> + x * c; c = <span class="hljs-number"><span class="hljs-number">-1139334.44367982507207</span></span> + x * c; c = <span class="hljs-number"><span class="hljs-number">-2532523.07177582951285</span></span> + x * c; c = <span class="hljs-number"><span class="hljs-number">-2018891.41433532773231</span></span> + x * c; p = x * b / c; result = Math.Log(z) + p; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } q = (x - <span class="hljs-number"><span class="hljs-number">0.5</span></span>) * Math.Log(x) - x + ls2pi; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>)(x) &gt; (<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>)(<span class="hljs-number"><span class="hljs-number">100000000</span></span>)) { result = q; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } p = <span class="hljs-number"><span class="hljs-number">1</span></span> / (x * x); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>)(x) &gt;= (<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>)(<span class="hljs-number"><span class="hljs-number">1000.0</span></span>)) { q = q + ((<span class="hljs-number"><span class="hljs-number">7.9365079365079365079365</span></span> * <span class="hljs-number"><span class="hljs-number">0.0001</span></span> * p - <span class="hljs-number"><span class="hljs-number">2.7777777777777777777778</span></span> * <span class="hljs-number"><span class="hljs-number">0.001</span></span>) * p + <span class="hljs-number"><span class="hljs-number">0.0833333333333333333333</span></span>) / x; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { a = <span class="hljs-number"><span class="hljs-number">8.11614167470508450300</span></span> * <span class="hljs-number"><span class="hljs-number">0.0001</span></span>; a = -(<span class="hljs-number"><span class="hljs-number">5.95061904284301438324</span></span> * <span class="hljs-number"><span class="hljs-number">0.0001</span></span>) + p * a; a = <span class="hljs-number"><span class="hljs-number">7.93650340457716943945</span></span> * <span class="hljs-number"><span class="hljs-number">0.0001</span></span> + p * a; a = -(<span class="hljs-number"><span class="hljs-number">2.77777777730099687205</span></span> * <span class="hljs-number"><span class="hljs-number">0.001</span></span>) + p * a; a = <span class="hljs-number"><span class="hljs-number">8.33333333333331927722</span></span> * <span class="hljs-number"><span class="hljs-number">0.01</span></span> + p * a; q = q + a / x; } result = q; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre><br></div></div><br><br><h4>  My method </h4><br>  My method is to apply a sequence of the following operations: <br><ul><li>  Counting the powers of the numbers in the denominator.  For example, for arguments (5, 5, 5) they will be as follows: denomFactorPowers [6] = {0, 0, 2, 2, 2, 2}.  Those.  If you multiply all factorials in the denominator, you get 3 ^ 2 * 4 ^ 2 * 5 ^ 2 * 6 ^ 2.  And the degree is exactly the second, because part of the degrees was reduced with the numerator, and in the numerator it became 6 * ... * 15, instead of 1 * ... * 15. </li><li>  Initialization <b>result = 1</b> (result of the function);  <b>tempDenom = 1</b> (the result of multiplying the numbers in the denominator);  <b>currentFactor</b> (current factor in the denominator). </li><li>  The cycle of the variable <b>i</b> over all the remaining numerators of the numerator <b>(maxNumber + 1 ... numbersSum)</b> . </li><li>  Calculate <b>tempDenom</b> until <b>tempDenom</b> &lt; <b>result</b> and the denominator have run out of numbers <b>(currentFactor &lt;denomFactorPowers.Length)</b> . </li><li>  If <b>tempDenom&gt; result</b> or the denominator ran out of numbers <b>(currentFactor&gt; = denomFactorPowers.Length)</b> , then calculate the result as follows: <b>result = result / tempDenom * i</b> .  This technique allows you to calculate the result as accurately as possible and without overflow, because <b>result / tempDenom ‚Üí 1</b> . </li></ul><br><div class="spoiler">  <b class="spoiler_title">My method source</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">ulong</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyAr</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] numbers</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">uint</span></span> numbersSum = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> number <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> numbers) numbersSum += number; <span class="hljs-keyword"><span class="hljs-keyword">uint</span></span> maxNumber = numbers.Max(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> denomFactorPowers = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint</span></span>[maxNumber + <span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> number <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> numbers) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">2</span></span>; i &lt;= number; i++) denomFactorPowers[i]++; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">2</span></span>; i &lt; denomFactorPowers.Length; i++) denomFactorPowers[i]--; <span class="hljs-comment"><span class="hljs-comment">// reduce with nominator; uint currentFactor = 2; uint currentPower = 1; double result = 1; for (uint i = maxNumber + 1; i &lt;= numbersSum; i++) { uint tempDenom = 1; while (tempDenom &lt; result &amp;&amp; currentFactor &lt; denomFactorPowers.Length) { if (currentPower &gt; denomFactorPowers[currentFactor]) { currentFactor++; currentPower = 1; } else { tempDenom *= currentFactor; currentPower++; } } result = result / tempDenom * i; } return (ulong)Math.Round(result); }</span></span></code> </pre><br></div></div><br><br><h4>  Testing </h4><br>  Testing of all methods took place in two stages: this is a test for the maximum number that can be calculated by any method without overflow and rounding errors, as well as a test for speed. <br><br><h4>  Test for the highest possible computable number </h4><br>  It is easy to prove that the multinomial coefficient is a commutative operation, i.e.  for example, M (a, b, c) = M (a, c, b) = M (c, b, a), etc.  So for checking all combinations of numbers with a given number of arguments, you can use <i>permutations with repetitions</i> .  For these purposes, a library was used to generate data and other combinations of the <a href="http://www.codeproject.com/Articles/26050/Permutations-Combinations-and-Variations-using-C-G">codeproject</a> .  Thus, all the combinations were arranged in lexicographical order. <br><br>  The two graphs below show the dependence of the number of permutation of the maximum possible computable number on the number of arguments in the multinomial function. <br><br>  For a better understanding, I will explain the first set of values ‚Äã‚Äãwith the number of arguments 2: <br><br><pre> <code class="cs hljs">Arg count: <span class="hljs-number"><span class="hljs-number">2</span></span> Naive(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">19</span></span>) = <span class="hljs-number"><span class="hljs-number">20</span></span>; <span class="hljs-meta"><span class="hljs-meta">#18; overflow Binom(1,61) = 62; #60; overflow LogGamma(5,623) = 801096582000; #4612; rounding(</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">error</span></span></span><span class="hljs-meta"> = 1) Log(6,588) = 59481941558292; #5572; rounding(</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">error</span></span></span><span class="hljs-meta"> = 1) My(7,503) = 1708447057008120; #6481; rounding(</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">error</span></span></span><span class="hljs-meta"> = 1) Big(8,959) = 18419736117819661560; #7930</span></span></code> </pre><br><br>  In the test above, it is clear that, for example, the maximum <b>ulong</b> value that can be calculated using logarithms is 59481941558292. It was calculated from arguments 6 and 588, which corresponds to permutation 6481, if generated in the lexicographical order.  This number is displayed on the green graph.  The term <b>rounding</b> says that if we take the next permutation, i.e.  (6.589), this method will consider a multinomial coefficient with an error of 1. And the term <b>overflow</b> says that if you calculate the coefficient from the next permutation (for example, if you take (1.63) for <b>Binom</b> ), then somewhere inside the method an overflow occurs . <br><br>  Since the difference between the first and last permutation numbers is too large, I divided the graph into two parts (with the number of arguments 2-10 and 11-20).  On twenty-one and more arguments, all functions give an incorrect result even on the first permutation (this is understandable, because Multinomial (1,1, ..., 1) = 21! And this number is greater than the maximum <b>ulong</b> . Further increase of any argument only increase the result. I will leave this statement without proof). <br><br>  The orange graph shows the perfect result, i.e.  generally the most maximal <b>ulong</b> that can only be computed by a multinomial function with a given number of arguments.  Those.  A further permutation increment will result in the result going beyond the <b>ulong</b> type.  The values ‚Äã‚Äãfor this graph were calculated using large integers, which were discussed at the very beginning of the article. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/06f/0e0/949/06f0e0949d79167f6900953c2283e019.png"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/bc4/4ea/ceb/bc44eacebf069f21d165a7e1f2baeff8.png"><br><br>  So, my method, as can be seen from both graphs, allows us to calculate a larger coefficient in almost all cases, with the exception of 12 and 13 arguments.  Despite the high expectations of binomial coefficients, it turned out that they cover a small set of values ‚Äã‚Äãin the case of a small number of them (from 2 to 8).  Starting at 9, they begin to cover a larger range than <b>Log</b> and <b>LogGamma</b> , and at 12 and 13 they even bypass my method.  After 13, they are calculated perfectly, however, as they are calculated, and my method. <br><br>  The <b>Log</b> and <b>LogGamma methods</b> cover approximately the same range, especially with a large number of arguments.  The fact that <b>Log</b> is still ahead of <b>LogGamma</b> by 1-12 is probably due to the fact that the Log (N!) Function is calculated less accurately than the sum of real numbers (logarithms).  And the simple method even turned out to be more efficient than logarithms by 15-19 number of arguments. <br><br>  It should be noted that the picture did not change much when the absolute error <b>Max Error</b> changed (i.e., the maximum permissible error during rounding), so I did not give other graphs with <b>Max Error</b> equal to 10 and 100. <br><br><h4>  Performance test methods </h4><br>  For measuring the speed of each method, I used two test sets.  The first covers fairly large numbers, on which the simple <b>Naive</b> method crashes with an <b>overflow</b> error, so it was not taken into account.  BigInteger is also not taken into account.  Each set was chased 20,000 times, and the given time of calculation was measured. <br><br>  Also, these methods were tested with a preliminary calculation ( <b>prefetch</b> ) and without.  This is relevant only for the <b>Log</b> and <b>LogGamma methods</b> , since only they use pre-calculated logarithms and logarithms from factorials. <br><br><h5>  The first test argument set </h5><br><pre> <code class="cs hljs">(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>) (<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) (<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>) (<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>) (<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>) (<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">15</span></span>) (<span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>) (<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>) (<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>)</code> </pre><br><br><img src="https://habrastorage.org/getpro/habr/post_images/cd4/201/9f9/cd42019f96726ced6286a856f10d01f1.png"><br><br>  As you can see, my method here turned out to be worse than the other methods every 3 times. <br><br>  The fact that <b>Binom</b> calculated everything faster is explained by the fact that it uses only integer arithmetic, which is a priori faster. <br><br>  A small advance of <b>LogGamma</b> compared to <b>Log</b> is explained by the fact that it does not add up logarithms again, but the logarithm of factorial, i.e.  for example, instead of Ln (2) + Ln (3) + Ln (4), Ln (4!) is used. <br><br>  It can also be seen that prefetch, as it turned out, has practically no effect on the <b>Log</b> and <b>LogGamma speed</b> , and this suggests that apparently calculating these functions is comparable to extracting the already calculated values ‚Äã‚Äãor that the time to calculate them is too short compared to the total time remaining operations. <br><br><h5>  Second test argument set </h5><br>  The following set was intended even for the simplest naive function.  Larger numbers were also included in the following chart: <br><br><pre> <code class="cs hljs">(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>) (<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) (<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>) (<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>) (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>) (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>)</code> </pre><br><br><img src="https://habrastorage.org/getpro/habr/post_images/153/e92/e36/153e92e36a8b1478e4ba879be0bd62cc.png"><br><br>  As you can see, in this case, my method showed a smaller lag from the rest of the functions (except for <b>Big</b> ), and the method with large numbers was 4 times worse than even my method.  This is because the implementation of large numbers in .NET is far from ideal.  Decompiling some of the System.Numerics library methods using ILSpy confirmed my assumptions (the code shows that even for such a simple operation as addition, a large amount of safe code is used): <br><div class="spoiler">  <b class="spoiler_title">Add operation for BigInteger in .NET</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> BigInteger <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> +(BigInteger left, BigInteger right) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (right.IsZero) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> left; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (left.IsZero) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> right; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> num = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> num2 = <span class="hljs-number"><span class="hljs-number">1</span></span>; BigIntegerBuilder bigIntegerBuilder = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BigIntegerBuilder(left, <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> num); BigIntegerBuilder bigIntegerBuilder2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BigIntegerBuilder(right, <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> num2); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (num == num2) { bigIntegerBuilder.Add(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> bigIntegerBuilder2); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { bigIntegerBuilder.Sub(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> num, <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> bigIntegerBuilder2); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bigIntegerBuilder.GetInteger(num); } ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Add</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> BigIntegerBuilder reg</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (reg._iuLast == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Add(reg._uSmall); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._iuLast != <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.EnsureWritable(Math.Max(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._iuLast, reg._iuLast) + <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> num = reg._iuLast + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._iuLast &lt; reg._iuLast) { num = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._iuLast + <span class="hljs-number"><span class="hljs-number">1</span></span>; Array.Copy(reg._rgu, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._iuLast + <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._rgu, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._iuLast + <span class="hljs-number"><span class="hljs-number">1</span></span>, reg._iuLast - <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._iuLast); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._iuLast = reg._iuLast; } <span class="hljs-keyword"><span class="hljs-keyword">uint</span></span> num2 = <span class="hljs-number"><span class="hljs-number">0u</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; num; i++) { num2 = BigIntegerBuilder.AddCarry(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._rgu[i], reg._rgu[i], num2); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (num2 != <span class="hljs-number"><span class="hljs-number">0u</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.ApplyCarry(num); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">uint</span></span> uSmall = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._uSmall; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (uSmall == <span class="hljs-number"><span class="hljs-number">0u</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BigIntegerBuilder(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> reg); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Load(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> reg, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Add(uSmall); }</code> </pre><br></div></div><br><br><h4>  Conclusion </h4><br>  Experiments have shown that my method turned out to be better than the others in the context of the most computable number (but still worse than ideal), but worse in the context of performance (but much better than the implementation with large numbers in .NET).  You can also conclude that the implementation of the arithmetic of large numbers is far from ideal in .NET and if it is possible to replace it with another method, it is better to use it. <br><br>  The method with binomial coefficients turned out to be the fastest, even faster than the simple implementation, but this is quite obvious, since it uses only integer arithmetic.  On the other hand, this method does not cover such a large range of values, especially with a small number of arguments. <br><br>  Also, experiments have shown that the reuse of calculated values ‚Äã‚Äãof logarithms and logarithms from factorials does not give a significant performance gain, so that they can not be used. <br><br>  I hope that the work done with the experiments will be interesting and useful not only for me, so I post the source code along with unit tests and tests on github: <a href="https://github.com/KvanTTT/Multinimonal-Coefficient">Multinimonal-Coefficient</a> . <br><br>  <b>UPDATE</b> <br><ul><li>  Updated the method with binomial coefficients: <a href="http://habrahabr.ru/post/153255/">link</a> , author: <a href="https://habrahabr.ru/users/mrrl/" class="user_link">Mrrl</a> </li><li>  Added method with decomposition into powers of primes: <a href="http://habrahabr.ru/post/153255/">link</a> , author: <a href="https://habrahabr.ru/users/mrrl/" class="user_link">Mrrl</a> </li><li>  Added a method with the calculation of combinations of coefficients obtained by decomposing the degree of the sum into the following terms: <a href="https://github.com/KvanTTT/Multinomial-Coefficient">description and source</a> </li></ul></div><p>Source: <a href="https://habr.com/ru/post/153255/">https://habr.com/ru/post/153255/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../153237/index.html">CSS (ISO 24730-5) Measurement of distances without tape measure and wires</a></li>
<li><a href="../153239/index.html">Search contacts performers on Free-lans.ru</a></li>
<li><a href="../153245/index.html">How to avoid becoming a poor IT person because of a translation error</a></li>
<li><a href="../153247/index.html">Ukrainians will receive electronic passports</a></li>
<li><a href="../153249/index.html">Publicity-privacy: a matter of respected public</a></li>
<li><a href="../153257/index.html">The simplest free-lance board on Ruby on Rails</a></li>
<li><a href="../153259/index.html">iTunes 10.7 tried to connect to the domain bogusapple.com</a></li>
<li><a href="../153261/index.html">MODX Revolution - a pair of crutches for unusual situations</a></li>
<li><a href="../153263/index.html">LEGO laptop docking station</a></li>
<li><a href="../153265/index.html">Start selling software on Steam</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>