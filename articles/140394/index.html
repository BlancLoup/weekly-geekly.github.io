<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Towards Skein: Blowfish is simple and straightforward.</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="‚ÄúSack-shaped outgrowths move away from the stomach of puffer fish. When danger arises, they are filled with water or air, which makes the fish look li...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Towards Skein: Blowfish is simple and straightforward.</h1><div class="post__text post__text-html js-mediator-article"><img align="left" src="https://habrastorage.org/storage2/b52/27e/1e5/b5227e1e575ca5d6dfbee7ff425c3854.jpg">  <i>‚ÄúSack-shaped outgrowths move away from the stomach of puffer fish.</i>  <i>When danger arises, they are filled with water or air, which makes the fish look like a swollen ball.</i> <i><br></i>  <i>with protruding spines.</i>  <i>The spherical state makes the fish almost invulnerable.</i>  <i>If, however, a large enough predator tries to swallow such a ball, then it gets stuck</i> <i><br></i>  <i>in the throat of a predator who later dies "</i> <br><br>  <i>Wikipedia, the free encyclopedia.</i> <br><br>  By the end of 1993, a very awkward situation arose in the world of cryptography.  The DES symmetric encryption algorithm, with its weak 56-bit key, was close to a fiasco, and the existing <br>  at that time, alternatives such as Khufu, REDOC II, IDEA were protected by patents <br>  and are not available for free use.  The RC2 and RC4 algorithms developed by RSA Security at that time also required a licensing procedure.  And in general, the cryptography industry within government organizations and large corporations has been <br>  turned towards the use of secret algorithms such as Skipjack. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      There was a certain vacuum.  An encryption algorithm was needed, more cryptographic than dying DES, and at the same time without any restrictions on the right to use it. <br><br>  <b>And he appeared.</b> <br><a name="habracut"></a><br>  In 1994, at the Fast Software Encryption seminar in Cambridge, and subsequently in the journal Lecture Notes in Computer Science (# 809, 1994), Bruce Schneier presented his block cipher algorithm, which was named Blowfish. <br><br>  Distinctive features of this algorithm were a higher degree of cryptographic strength than the DES algorithm (including through the use of a variable key length, up to 448 bits), high encryption / decryption speed (due to the generation of replacement tables) and of course the possibility of its free use for any goals. <br><br>  Bruce Schneier's original article from the archive in 1994: <br>  Block Ciphers II, Bruce Schneier (bottom of page): <br>  <a href="http://www.informatik.uni-trier.de/~ley/db/conf/fse/fse93.html">Description of a New Variable-Length Key, 64-bit Block Cipher (Blowfish).</a>  <a href="http://www.informatik.uni-trier.de/~ley/db/conf/fse/fse93.html">191-204</a> <br><br>  Or <a href="http://citeseerx.ist.psu.edu/viewdoc/download%3Fdoi%3D10.1.1.135.1231%26rep%3Drep1%26type%3Dpdf">in pdf format</a> <br><br><h4>  Introduction </h4><br>  BlowFish is a 64-bit block cipher algorithm with a variable-length key.  It was developed by a well-known specialist in the field of cryptography and information security, Bruce Schneier, in 1993. <br><br>  In general, the algorithm consists of two stages - key expansion and encryption / decryption of the source data. <br><br><img src="https://habrastorage.org/storage2/174/07a/354/17407a3541a3d56c7b10ef315d358b89.png"><br><br>  At the key expansion stage, the source key is converted into a matrix of round keys (P) <br>  and a substitution matrix (S, Substitution-box) (or replacement), with a total of 4168 bytes.  In all likelihood, this ‚Äúextension‚Äù (from 448 bits to 4168 bytes) explains the choice of the name <br>  Blowfish algorithm. <br><br>  Data encryption, as well as the creation of a matrix of round keys and substitutions, occurs through the use of the Feistel network, which in turn consists of 16 rounds.  Therefore, before we consider the steps of expanding the key and encrypting the data in detail, we need to decide what the Feistel network is. <br><br>  <i>In the process, we implement the software code of the encoder using the Blowfish algorithm in C ++.</i>  <i>Ready-made implementations for high-level languages ‚Äã‚Äã(such as C / C ++ / Haskell / Perl / ...) are available on the page.</i> <i><br></i>  <i>with the <a href="http://www.schneier.com/blowfish-download.html">source code</a> on the Bruce Schneier website.</i> <br><br><h4>  Feistel Network </h4><br>  In 1971, the godfather of the DES standard, Horst Feistel (Horst Feistel), within the walls of IBM Corporation, developed two devices that implemented various encryption algorithms, then called the general name Lucifer.  In one of these devices, he used a scheme that was later called the Feistel Network.  This network is a certain repeatedly iterated (repetitive) structure, which is called a Feistel cell. <br><br><img src="https://habrastorage.org/storage2/6bc/382/716/6bc38271606fa8df1362129e3cd2c495.png"><br><br>  The principle of the network is quite simple: <br><br><ol><li>  The source data is divided into blocks of fixed length (usually a multiple of a power of two - 64 bits, 128 bits).  If the length of the source data block is less than the length of the cipher, then the block is supplemented in some way known in advance. <br><br></li><li>  The block is divided into two equal sub-blocks - the ‚Äúleft‚Äù L <sub>0</sub> and the ‚Äúright‚Äù R <sub>0</sub> . <br>  In the case of 64-bit bit depth, two blocks with a length of 32 bits each. <br><br></li><li>  The ‚Äúleft sub block‚Äù L <sub>0 is</sub> modified by the iteration function <i>F</i> (L <sub>0</sub> , P <sub>0</sub> ) depending on the key P <sub>0</sub> , <br>  after which it is folded modulo 2 (XOR) with the ‚Äúright subblock‚Äù R <sub>0</sub> . <br><br></li><li>  The result of the addition is assigned to the new left sub-block L <sub>1</sub> , which becomes the left half of the input data for the next round, and the ‚Äúleft sub-block‚Äù L <sub>0 is</sub> assigned without changes to the new right sub-block R <sub>1</sub> , which becomes the right half. <br><br></li><li>  This operation is repeated n-1 times, with the transition from one stage to another changing round keys (P <sub>0</sub> , P <sub>1</sub> , P <sub>2</sub> , etc.), where n is the number of rounds for the algorithm used. </li></ol><br>  The decryption process is similar to the encryption process, except that round keys are used in the reverse order. <br><br>  <b>Let's go back to the Blowfish algorithm.</b> <br><br>  In general, the Blowfish encryption algorithm is a Feistel network, but with some features of generating and using round keys (P <sub>0</sub> , P <sub>1</sub> ...). <br><br>  To begin with, let's assume that the iteration function <i>F</i> in the Blowfish algorithm is some kind of <b>‚Äúblack box‚Äù</b> that accepts a 32-bit number (DWORD) at the input and outputs it. <br><br>  In this case, 32-bit round keys Pn: <br><br><ol><li>  calculated according to some rule from the source key (up to 448 bits in length); </li><li>  are not arguments for the iteration function <i>F</i> ; </li><li>  directly stack modulo 2 (XOR) with a ‚Äúleft block‚Äù. <br>  The result of this operation is an incoming 32-bit argument for the function <i>F.</i> </li></ol><br><img src="https://habrastorage.org/storage2/9d7/ec8/87f/9d7ec887fa50737170f8e0811ecb1e9c.png"><br><br>  In the Blowfish algorithm, 16 rounds are performed during encryption (within the Feistel network), and the 17th and 18th keys are added to the left and right output blocks of the last round.  This number of rounds was chosen because it determines the length of the possible key. <br><br>  But here the attentive reader may ask: if 18 round keys are used, each of which has a length of 32 bits, then we end up with a key of 576 bits (18 keys √ó 32 bits).  Why is the original key length in Blowfish originally limited to 448 bits? <br><br>  The answer is simple - it is not limited.  You can use keys up to 576 bits.  But!  The restriction was made based on the requirements for compliance with the security and cryptographic strength of the algorithm. <br><br>  Let's implement the Feistel network for the Blowfish algorithm in C ++: <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">swap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *b)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> temp; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a &amp;&amp; b) { temp = *a, *a = *b, *b = temp; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">blowfish_encrypt_block</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(blowfish_ctx *ctx, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *high, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *low)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">16</span></span>; i++) { *high ^= ctx-&gt;p[i]; *low ^= F(ctx, *high); swap(low, high); } swap(low, high); *low ^= ctx-&gt;p[<span class="hljs-number"><span class="hljs-number">16</span></span>]; *high ^= ctx-&gt;p[<span class="hljs-number"><span class="hljs-number">17</span></span>]; }</code> </pre> <br><br><h4>  Key Expansion (Blow it up!) </h4><br>  The preparatory stage of the Blowfish algorithm is the key expansion phase.  During this stage, the matrix of round keys Pn and the substitution matrix are built - 4 S-Box replacement blocks (Substitution-boxes), each of which consists of 256 32-bit elements. <br><br><img src="https://habrastorage.org/storage2/0ce/91a/46b/0ce91a46bcef6f3e9c70d63c4e611819.png"><br><br>  The elements of these matrices are encrypted (computed) using the Feistel network discussed above for the Blowfish algorithm.  Thus, the Feistel network in the Blowfish algorithm is used: <br><br><ul><li>  to encrypt / decrypt source data; </li><li>  to generate a matrix of round keys and a substitution matrix (i.e. a key extension). </li></ul><br>  The generated round key matrix and the substitution matrix are subsequently used. <br>  in the process of encryption / decryption. <br><br>  The key expansion process is processed. <br>  18 √ó 32 (P <sub>1</sub> , P <sub>2</sub> ...) + 4 √ó 256 √ó 32 (S <sub>1</sub> ‚ÄîS <sub>4</sub> ) = 33344 bits or 4168 bytes of data. <br><br>  When this is done (18 (Pn) + 4 √ó 256 (S <sub>1</sub> ‚ÄîS <sub>4</sub> )) / 2 = 521, a full iteration of the Feistel network. <br><br>  All this is a very time-consuming operation, and that is why the Blowfish algorithm <br>  It is not recommended to use where frequent change of key is required. <br><br>  <b>We describe the key expansion algorithm.</b> <br><br><ol><li>  A ‚Äúsincere number‚Äù is chosen (or else ‚ÄúNothing up my sleeve number‚Äù).  This is a number that does not initially contain any duplicate sequences and is known.  This is done in order to show that the constant was chosen by the developers without pursuing any ‚Äúvile‚Äù goals, for example, to create a loophole in the algorithm (backdoor). <br><br>  Blowfish usually uses the PI number as such a sincere number.  We will not calculate the hexadecimal representation of the PI number, but use the ready-made solution: <a href="http://www.herongyang.com/Cryptography/Blowfish-First-8366-Hex-Digits-of-PI.html">8366 hexadecimal numbers of the mantissa for the PI number</a> . <br><br></li><li>  The value of the PI mantissa is filled with a matrix of round keys (FIXED_P) and a substitution matrix (FIXED_S): <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">blowfish_ctx</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> p[<span class="hljs-number"><span class="hljs-number">18</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> sbox[<span class="hljs-number"><span class="hljs-number">4</span></span>][<span class="hljs-number"><span class="hljs-number">256</span></span>]; } blowfish_ctx; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> FIXED_S[<span class="hljs-number"><span class="hljs-number">4</span></span>][<span class="hljs-number"><span class="hljs-number">256</span></span>] = { { <span class="hljs-number"><span class="hljs-number">0xD1310BA6</span></span>, <span class="hljs-number"><span class="hljs-number">0x98DFB5AC</span></span>, <span class="hljs-number"><span class="hljs-number">0x2FFD72DB</span></span>, <span class="hljs-number"><span class="hljs-number">0xD01ADFB7</span></span>, <span class="hljs-number"><span class="hljs-number">0xB8E1AFED</span></span>, <span class="hljs-number"><span class="hljs-number">0x6A267E96</span></span>, <span class="hljs-number"><span class="hljs-number">0xBA7C9045</span></span>, <span class="hljs-number"><span class="hljs-number">0xF12C7F99</span></span>, <span class="hljs-number"><span class="hljs-number">0x24A19947</span></span>, <span class="hljs-number"><span class="hljs-number">0xB3916CF7</span></span>, <span class="hljs-number"><span class="hljs-number">0x0801F2E2</span></span>, <span class="hljs-number"><span class="hljs-number">0x858EFC16</span></span>, <span class="hljs-number"><span class="hljs-number">0x636920D8</span></span>, <span class="hljs-number"><span class="hljs-number">0x71574E69</span></span>, <span class="hljs-number"><span class="hljs-number">0xA458FEA3</span></span>, <span class="hljs-number"><span class="hljs-number">0xF4933D7E</span></span>, <span class="hljs-number"><span class="hljs-number">0x0D95748F</span></span>, <span class="hljs-number"><span class="hljs-number">0x728EB658</span></span>, <span class="hljs-number"><span class="hljs-number">0x718BCD58</span></span>, <span class="hljs-number"><span class="hljs-number">0x82154AEE</span></span>, <span class="hljs-number"><span class="hljs-number">0x7B54A41D</span></span>, <span class="hljs-number"><span class="hljs-number">0xC25A59B5</span></span>, <span class="hljs-number"><span class="hljs-number">0x9C30D539</span></span>, <span class="hljs-number"><span class="hljs-number">0x2AF26013</span></span>, ....        .... <span class="hljs-number"><span class="hljs-number">0xB74E6132</span></span>, <span class="hljs-number"><span class="hljs-number">0xCE77E25B</span></span>, <span class="hljs-number"><span class="hljs-number">0x578FDFE3</span></span>, <span class="hljs-number"><span class="hljs-number">0x3AC372E6</span></span> } }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> FIXED_P[] = { <span class="hljs-number"><span class="hljs-number">0x243F6A88</span></span>, <span class="hljs-number"><span class="hljs-number">0x85A308D3</span></span>, <span class="hljs-number"><span class="hljs-number">0x13198A2E</span></span>, <span class="hljs-number"><span class="hljs-number">0x03707344</span></span>, <span class="hljs-number"><span class="hljs-number">0xA4093822</span></span>, <span class="hljs-number"><span class="hljs-number">0x299F31D0</span></span>, <span class="hljs-number"><span class="hljs-number">0x082EFA98</span></span>, <span class="hljs-number"><span class="hljs-number">0xEC4E6C89</span></span>, <span class="hljs-number"><span class="hljs-number">0x452821E6</span></span>, <span class="hljs-number"><span class="hljs-number">0x38D01377</span></span>, <span class="hljs-number"><span class="hljs-number">0xBE5466CF</span></span>, <span class="hljs-number"><span class="hljs-number">0x34E90C6C</span></span>, <span class="hljs-number"><span class="hljs-number">0xC0AC29B7</span></span>, <span class="hljs-number"><span class="hljs-number">0xC97C50DD</span></span>, <span class="hljs-number"><span class="hljs-number">0x3F84D5B5</span></span>, <span class="hljs-number"><span class="hljs-number">0xB5470917</span></span>, <span class="hljs-number"><span class="hljs-number">0x9216D5D9</span></span>, <span class="hljs-number"><span class="hljs-number">0x8979FB1B</span></span> };</code> </pre> <br><br></li><li>  The value of each round key Pn (P <sub>1</sub> , P <sub>2</sub> ...) is added modulo 2 (XOR) with the corresponding elements of the source key K. For example, the XOR round key P <sub>1</sub> is performed <br>  with the first 32 bits of the original key K, P <sub>2</sub> with the second 32 bits of the original key K, and so on.  If the source key K is shorter than the length of all round keys (576 bits), then it concatenates itself <br>  with you: KK, KKK and so on. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(i = <span class="hljs-number"><span class="hljs-number">0</span></span>, k = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">18</span></span>; i++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(j = <span class="hljs-number"><span class="hljs-number">0</span></span>, long_key = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; <span class="hljs-number"><span class="hljs-number">4</span></span>; j++, k++) { long_key = (long_key &lt;&lt; <span class="hljs-number"><span class="hljs-number">8</span></span>) | key[k % key_len]; } ctx-&gt;p[i] ^= long_key; }</code> </pre> <br><br></li><li>  Next, we need to encrypt (calculate new values) the elements of the matrix of round keys and the substitution matrix.  To do this, we will use the Blowfish Feistel network algorithm that we have implemented. <br><br><ol><li>  Using the current round keys P <sub>1</sub> ‚ÄîP <sub>18</sub> and the S <sub>1</sub> ‚ÄîS <sub>4</sub> permutation matrixes (where exactly the permutation matrices are used will be described below), we encrypt the 64-bit zero sequence: 0x00000000 0x00000000, and write the result in P <sub>1</sub> and P <sub>2</sub> . <br><br></li><li>  P <sub>1</sub> and P <sub>2</sub> are encrypted with modified values ‚Äã‚Äãof round keys and substitution matrices, the result is written to P <sub>3</sub> and P <sub>4,</sub> respectively. <br><br></li><li>  Encryption continues until all round keys P <sub>1</sub> ‚ÄîP <sub>18</sub> and the elements of the permutation matrices S <sub>1</sub> ‚ÄìS <sub>4 are</sub> changed. <br><br>  Those.  ultimately, we need to obtain the result of the calculation according to the Feistel network scheme of the Blowfish algorithm for (18 Pn + 4 √ó 256 (S <sub>1</sub> ‚ÄîS <sub>4</sub> )) / 2 = 521 iterations.  We divided by 2, because for each iteration we calculate two new values ‚Äã‚Äãfor the elements of the matrix of round keys or the matrix of substitutions. </li></ol><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>, k = <span class="hljs-number"><span class="hljs-number">0</span></span>, l = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">18</span></span>; i++) { blowfish_encrypt_block(ctx, (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>*)&amp;k, (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>*)&amp;l); ctx-&gt;p[i] = k; ctx-&gt;p[++i] = l; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">4</span></span>; i++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; <span class="hljs-number"><span class="hljs-number">256</span></span>; j++) { blowfish_encrypt_block(ctx, (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>*)&amp;k, (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>*)&amp;l); ctx-&gt;sbox[i][j] = k; ctx-&gt;sbox[i][++j] = l; } }</code> </pre> <br></li></ol><br>  At this point, the preparatory stage of the Blowfish algorithm ‚Äî the key expansion ‚Äî is completed.  But before considering the stage of encryption / decryption, let‚Äôs still reveal our <b>‚Äúblack box‚Äù</b> - the F function, which is executed at each round within iterations of the Feistel network for the Blowfish algorithm. <br><br><img src="https://habrastorage.org/storage2/b6d/f68/863/b6df68863b71046e42c60e39a0fddc73.png"><br><br><h4>  Iteration function (round) </h4><br>  The function of a round or iteration (since it is common to the entire Feistel network used) is very simple and uses only a few logical operations on the permutation matrix.  Initially, while developing Lucifer, Horst Feistel even suggested using electronic substitution for a matrix with a simple linear circuit. <br><br><img src="https://habrastorage.org/storage2/943/81f/7e9/94381f7e90f5ac53644465619f78baeb.png"><br><br>  So: <br><br><ol><li>  The incoming 32-bit block is divided into four 8-bit blocks, let's call them X <sub>1</sub> , X <sub>2</sub> , X <sub>3</sub> , X <sub>4</sub> <br>  (see picture above). <br><br></li><li>  Each of which is an index of the array of the replacement table S <sub>1</sub> ‚ÄîS <sub>4</sub> . </li><li>  S <sub>1</sub> [X <sub>1</sub> ] and S <sub>2</sub> [X <sub>2</sub> ] values ‚Äã‚Äãare added modulo 2 <sup>32</sup> , then the result is added <br>  modulo 2 (XOR) with S <sub>3</sub> [X <sub>3</sub> ] and, finally, add up with S <sub>4</sub> [X <sub>4</sub> ] again modulo 2 <sup>32</sup> . </li><li>  The result of the calculation will be the value of the function F (X <sub>1</sub> ‚ÄîX <sub>4</sub> ). </li></ol><br>  Formula function: <br><img src="https://habrastorage.org/storage2/d3a/659/ed5/d3a659ed5486de345c5eaf856bdc68ea.png"><br><br>  Everything is extremely simple.  The function uses the S <sub>1</sub> ‚ÄîS <sub>4</sub> permutation matrix to linearly translate the incoming 32 bits of data into a value from the substitution matrix.  And the values ‚Äã‚Äãthemselves <br>  in matrices, substitutions are calculated at the key expansion stage that we considered earlier. <br><br>  Implementing a function in C ++: <br><br><pre> <code class="hljs markdown">unsigned long F(blowfish_ctx *ctx, unsigned long x) { return ((ctx-&gt;sbox[<span class="hljs-string"><span class="hljs-string">0</span></span>][<span class="hljs-symbol"><span class="hljs-symbol">(x &gt;&gt; 24) &amp; 0xFF</span></span>] + ctx-&gt;sbox[<span class="hljs-string"><span class="hljs-string">1</span></span>][<span class="hljs-symbol"><span class="hljs-symbol">(x &gt;&gt; 16) &amp; 0xFF</span></span>]) ^ ctx-&gt;sbox[<span class="hljs-string"><span class="hljs-string">2</span></span>][<span class="hljs-symbol"><span class="hljs-symbol">(x &gt;&gt; 8) &amp; 0xFF</span></span>]) + ctx-&gt;sbox[<span class="hljs-string"><span class="hljs-string">3</span></span>][<span class="hljs-symbol"><span class="hljs-symbol">(x) &amp; 0xFF</span></span>]; }</code> </pre> <br><br>  And now let's move on to the actual process of encrypting the source data. <br><br><h4>  Encryption / decryption of source data </h4><br>  Surprise!  In fact, we have already considered the algorithm for encrypting and decrypting source data.  The thing is that, as we noticed at the very beginning, data encryption / decryption, and the creation of the aforementioned matrix of round keys and a substitution matrix, occurs with the help of the considered Feistel network for the Blowfish algorithm. <br><br>  Those.  in our software implementation, the entire process of encrypting the source data is built by analogy with the encryption process at the key expansion stage.  Those.  is an iterative execution of the blowfish_encrypt_block function (implementation of a Feistel network) over every 64 bits of source data.  The round keys P (P <sub>1</sub> , P <sub>2</sub> , &amp; hellip) and the substitution matrices S <sub>1</sub> ‚ÄîS <sub>4</sub> are the input parameters for the Feistel network and the <i>F</i> function, respectively, within this network. <br><br><img src="https://habrastorage.org/storage2/9d7/ec8/87f/9d7ec887fa50737170f8e0811ecb1e9c.png"><br><br>  <b>In summary, if we summarize the encryption or decryption algorithm in the Blowfish algorithm,</b> <b><br></b>  <b>then we get the following steps:</b> <br><br><ol><li>  We select an array of 18 elements for the round keys of the Feistel network and 4 substitution matrices of 256 elements each. <br><br></li><li>  Fill the selected array with the value of the PI mantissa. <br><br></li><li>  Make an iterative XOR: Pi = Pi XOR Ki (where Pi is the round key and Ki is the original key). <br><br></li><li>  We encrypt round keys and substitution matrices using a Feistel network (the substitution matrix is ‚Äã‚Äãused as an input parameter for the function within the network; the round keys within the network are taken from the matrix of round keys). <br><br></li><li>  We encrypt / decrypt 64-bit input data blocks also using a Feistel network. <br><br></li></ol>  <b>It's simple.</b> <br><br><h4>  Summary </h4><br>  Dear readers.  To be able to describe complex things in simple words is very difficult. <br><br>  Before you start writing this text, I tried to put myself in the developer‚Äôs place, <br>  who wants to try to study the considered Blowfish algorithm. <br><br>  So, I set a goal to find in the network a document describing this algorithm with sufficient, for its understanding, completeness.  In the end, of course, I got on the pages of Wikipedia, and on the forums, and even on different term papers.  But reading the description presented there often raised more questions than answers. <br><br>  All this confirmed me in the opinion that a simple and at the same time detailed description with examples would be useful and in demand.  Therefore, for my part, I tried to ‚Äúarrange everything on the shelves‚Äù as far as possible.  But how well I did it - to judge you. <br><br>  Thank. <br>  Yours sincerely, AB <br><br>  ps It is planned to continue ... </div><p>Source: <a href="https://habr.com/ru/post/140394/">https://habr.com/ru/post/140394/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../140384/index.html">Teach HID device (read BT-keyboard) to work correctly</a></li>
<li><a href="../140387/index.html">What is the role of the first "random" layer in the Rosenblatt perceptron</a></li>
<li><a href="../140388/index.html">Description of how to work with Virtual Grid Control in Visual C ++</a></li>
<li><a href="../140390/index.html">Mysterious signs in the fields - solution</a></li>
<li><a href="../140391/index.html">Forecasting currency fluctuations by statistical methods</a></li>
<li><a href="../140395/index.html">Meeting with the developers of the CUBRID DBMS at the RIT ++ 2012 conference in Moscow</a></li>
<li><a href="../140396/index.html">Atmel Studio 6 supports both AVR and ARM</a></li>
<li><a href="../140397/index.html">Integration of the program on C # with the calculated core ANSYS 11</a></li>
<li><a href="../140399/index.html">About the computational complexity of HTML and CSS algorithms</a></li>
<li><a href="../140400/index.html">jQuery File Upload</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>