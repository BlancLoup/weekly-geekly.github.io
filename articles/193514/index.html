<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>About automating chord selection</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I have long been interested in the question: ‚Äúwhat if I tried to get rid of the digital recording of a song through the Fourier transform, look at the...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>About automating chord selection</h1><div class="post__text post__text-html js-mediator-article">  I have long been interested in the question: ‚Äúwhat if I tried to get rid of the digital recording of a song through the Fourier transform, look at the dependence of the spectrum on time and try to pull out the chords of the song from the information received?‚Äù.  Here, finally, I found the time to try ... <br><a name="habracut"></a><br>  So, the statement of the problem: <br>  There is a file with digitized music (not MIDI!), For definiteness mp3.  It is necessary to determine the sequence of chord changes, forming the harmony of the piece.  By "music" we will mean typical European music - 12 semitones in an octave, harmony mainly based on major / minor triads, also reduced and increased triads and * sus2 / * sus4 are acceptable (chords with 2nd / 4th step instead of 3 th) <br><br><h5>  Some theory </h5><br>  Notes in European music are sounds with frequencies from a fixed set (more on this below), and sounds that differ in frequency of 2, 4, 8 ... are indicated by one note.  Musical intervals are fixed frequency ratios of two notes.  This interval system is organized as follows: <br><ul><li>  the interval <b>f1 / f2</b> == 2 is called an octave </li><li>  The octave is divided into 12 equal (in the "logarithmic" sense) minimum intervals, called small seconds or semitones.  If notes n1 and n2 are small seconds, then their frequencies <b>f1</b> and <b>f2 are</b> related as <br>  <b>f2 / f1 = 2 <sup>1/12</sup></b> .  Two small seconds make up a large second, three - a small third, four - a large third, seven - a fifth.  The rest of the intervals we will not need. </li></ul><br>  The letter designations of the notes in the notation adopted in Russia are: <br>  A - A, B - B-flat, H - B, C - C, D - D, E - M, F - F, G - Sal. <br>  # (sharp) indicates an increase in frequency by 1/2 tones, b (flat) - a decrease by 1/2 tones.  Per octave of 12 semitones, the notes are displayed as follows: <br><br>  ABHCC # / Db DD # / Eb EFF # / Gb GG # / Ab 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Octaves have tricky names and numbers, but we are not interested, it is enough to know that the frequency of the ‚Äúla‚Äù note of the first octave is 440 Hz.  The frequencies of the remaining notes are easy to calculate, based on what was written above. <br>  A chord consists of several simultaneously sounding notes.  At the same time, they can be extracted sequentially (arpeggio, it is ‚Äúbusting‚Äù in the jargon of yard guitarists), but since the sound does not calm down immediately, the notes have time to sound together for a while.  In the European tradition, the most common chords of the three sounds (actually triad).  Major and minor triads are commonly used.  In major chords, the 1st (starting from the lowest) and 2nd notes form a large third, and the 2nd and 3rd ones form the minor third, while in the minor, the 1st and 2nd ones form the minor, 2nd and 3rd is great.  The 1st and 3rd notes in both cases form a fifth.  There are also reduced (two small third) and increased (two large third) triads, and in rock music, sustained-chords are quite common (I don‚Äôt know how they are in Russian) - sus2 with a 2 nd note for 1/2 tone lower than that of the minor and sus4 with a 2 nd note ¬Ω tones higher than that of the major.  The 3rd note in both versions of the sustained-chord forms the 1st ordinary fifth. <br>  In a single piece of music, it is rarely when all 12 notes are used equally.  As a rule, there is a ‚Äúbase‚Äù subset of 7 notes, and notes are taken mainly from it.  Such a subset can be defined using a mask of 0 and 1, superimposed on a vector of 12 notes.  If to exaggerate, such a subset is called a tonality, and the set of all possible cyclic shifts of a tonality mask is called a fret.  In European music, two frets are mainly used: <br><ul><li>  major with mask 1 0 1 0 1 1 0 1 0 1 0 1 </li><li>  minor with mask 1 0 1 1 0 1 0 1 1 0 1 0 </li></ul><br>  The chords used in a particular key are constructed, to the extent possible, from the notes of that key. <br>  You may notice that the masks of major and minor differ to the accuracy of the shift.  Accordingly, the chords, for example, in C major and the corresponding A minor, are used the same (it was we who so unobtrusively returned to our task). <br>  The note ‚Äúfrom which‚Äù the mask was applied was called tonic.  The number of the note entering the key, starting with the tonic, is called the degree.  When talking about the structure of a particular chord, the steps are counted from its 1st note (the so-called pitch). <br>  Chords are traditionally denoted by the symbol of its pitch, to which a chord type suffix is ‚Äã‚Äãassigned to the right without a space.  For example, note A (A): <br><ul><li>  A - major triad </li><li>  Am - minor triad </li><li>  A5 + - increased triad (he has another, official designation, but I often come across this) </li><li>  Am5- - diminished triad (again, there are other designations) </li><li>  Asus2 - sustained second stage </li><li>  Asus4 - sustained fourth stage </li></ul><br>  <b>[Offtopic for those who studied in the "muzykalka"]</b> I heard about the differences between the melodic and harmonic minor and about the problems of temperament (going back to the roots of the 12th degree) too.  But, as it seems to me, in the framework of this article, the above simplified description of the subject area is sufficient. <br><br><h5>  Go to practice </h5><br>  So, we need: <br><ul><li>  unpack mp3 into an array of numbers, which is a graph of sound amplitude versus time </li><li>  determine which notes sound at any given time </li><li>  determine which chords form these notes </li></ul><br>  I didn‚Äôt bother with the first task - I took a ready sox sound converter that supports both mp3 and ‚Äúraw‚Äù formats, where the sound is stored just like a graph of the amplitude versus time.  In * nix-systems, it is trivially set using the package manager - on Ubuntu it looks like this: <br>  $ sudo apt-get install sox <br>  $ sudo apt-get install lame <br>  The second line puts the LAME mp3 encoder. <br>  Under Windows, sox can be downloaded from the official site, but then you have to suffer a little with searching the Internet for suitable LAME DLLs. <br>  With the second task, in principle, everything is simple.  In order to understand which notes sound at a particular point in time, it is necessary to perform a spectral analysis of a piece of our array with amplitudes in the range of indices corresponding to a small neighborhood of this moment.  As a result of spectral analysis, we obtain amplitudes for a variety of frequencies that "compose" the analyzed piece of sound.  It is necessary to filter the frequencies, highlighting those of them that are close to the frequencies of the notes, and select the largest of them - they correspond to the loudest notes.  I say ‚Äúclose,‚Äù not ‚Äúequal,‚Äù because in nature there are no perfectly tuned musical instruments;  This especially applies to guitars. <br>  For spectral analysis of a discrete representation of a time-varying signal, you can use the window fast Fourier transform.  I tore the simplest non-optimized FFT implementation from the Internet, translated it from C ++ to Scala, and took the Hanna function as a window function.  More about this all can be read in the relevant articles of Wikipedia. <br>  After receiving an array of amplitudes by frequency, we select frequencies in the vicinity (its default size is 1/4 semitones) around the frequency of each note in a certain octave range (experience shows that it is best to analyze octaves with a large second or third).  In each such neighborhood, we calculate the maximum amplitude and consider it as the loudness of the corresponding note.  After that, we summarize the ‚Äúloudness‚Äù of each note by all octaves and, finally, we divide all the elements of the resulting array of 12 ‚Äúloudnesses‚Äù by the value of its maximum element.  The resulting vector of 12 elements in different sources is called a chromogram (chromagram). <br>  Here it is impossible not to mention a pair of subtleties.  Firstly, for different works the convenient range of octaves for analysis is different - for example, the introduction to My Friend Of Misery Metallics is played, apparently, on a bass guitar and sounds quite low;  in the upper octaves, there are mostly overtones and left frequencies from the distortion, which only interfere. <br>  Secondly, there are no perfectly tuned guitars in nature.  This is probably due to the fact that the strings depending on the frets are differently extended during clamping (well, in general, the fingers put uneven pressure on them).  In addition, this tool quickly gets upset in the process of playing on it.  For example, in the acoustic recordings of Letov with the setting of the full finish - well, this can be understood.  But why, in the same My Friend Of Misery, one not-remember-which note stably sounds exactly a quarter of a tone, not that higher, not that lower ‚Äî a mystery.  And even with well-tuned guitars on the records of all kinds of home-based artists, the line usually does not coincide with the canonical one in terms of total height ‚Äî i.e.  The ‚Äúla‚Äù of the first octave may not be exactly 440 hertz. <br>  In order to neutralize such shoals, it was necessary to envisage in the program the possibility of compensating for a general shift in the order.  But with the frustration of individual strings and, in general, the indispensable ‚Äúinconvenience‚Äù of guitars can not be helped.  So ambush with the main rock instrument. <br>  <b>[Another Offtopic] The</b> set of songs that will be mentioned in this, so to speak, ‚Äúessay‚Äù may seem somewhat wild.  However, the selection criteria were very simple: <br><ul><li>  the piece must begin with the introduction ‚Äúon some chords‚Äù (without a complex melody) </li><li>  it is desirable that the main instrument in the arrangement was a piano or, even better, electronic keys.  If the arrangement is guitar, the recording should be studio (see above for the features of this wonderful instrument) </li></ul><br>  That is, I tried to simplify my life, at least at the beginning of torment with the selection of each song. <br>  But back to our three tasks. <br>  The remaining, third, task seems trivial - we select the three loudest notes and add a chord out of them.  But in reality, this will not work (well, not quite anything - see below, but there is very little sense from this approach).  And in general, this task was the most difficult of all. <br>  Now about everything in order. <br><br><h5>  Naive chord determination method </h5><br>  At first, I did exactly as described above - after analyzing each ‚Äúwindow‚Äù of the sound file I selected the three loudest notes and tried to make a chord out of them. <br>  The first composition in which I tried to experience the magical effect of my miracle program was ‚ÄúJudas will be in paradise‚Äù by Letov in the variant from the Tyumen bootleg aka ‚ÄúRussian Field of Experiments (Acoustics)‚Äù.  Vstulenie to this song is a dolbyob on a minor triad for about ten seconds. <br>  However, having banished my program at the beginning of this song, I did not find a single (!) Chord Em in the output.  Basically nothing was determined; occasionally any completely ‚Äúleft‚Äù nonsense climbed.  What was the matter, it was not clear.  I had to implement a private dump of each window in the form of a histogram of '*' symbols.  From the histogram, first of all, it turned out that the structure of the guitar differs by about a quarter of a tone from nominal.  OK, we introduce the amendment.  Hooray!  The notes E and H began to be determined - the 1st and 3rd in the chord.  But where is G? <br>  Further investigation of the dump revealed the following: <br><ul><li>  The bass "mi" spectrum is smeared from D to F # with several local maxima, as a result, the second loudest note sometimes turns out to be D # </li><li>  From somewhere persistently climbs "la" (maybe this is a quint unterton from "mi"?).  And when D # disappears somewhere, it takes its place.  In this case, there is a chance to get in the output of Asus2, which is the same as Esus4, up to the choice of the bass note (in music this is called ‚Äúappeal‚Äù).  Already something, but I need Em! </li><li>  ‚ÄúSalt‚Äù in the chord Em in its standard fingering (in the first position) sounds only on one string - on the third (for comparison, ‚Äúmi‚Äù - on three).  And in this underground record, apparently, due to the poor quality of the equipment, most of the frequencies are severely cut. </li></ul><br>  Apparently, therefore, G rarely even turns out to be in 4th place. <br>  In general, I scored on the selection of Letov.  And in general, it became clear that we need to look for another way to analyze the chromogram.  But, in fairness, I must say that there exists in nature at least one fragment, which is normally chosen in this way.  This is an introduction to the song of Olga Pulatova ‚ÄúPink Elephant‚Äù, which is an arpeggio on electronic keys.  The program on it produced the following result (after manual cleaning of artifacts formed at the junctions of chords and removing consecutive repeats): Fm Cm (c db f) Ab Abm Eb Ebm B. ((c db f) - non-standard consonance, which without special damage may be replaced by Db).  An independent check shows that the chords are correct. <br>  Here it is, the power of a blunt piece of iron!  With the hands of Olin delicacy with three tonalities for 8 chords, you can select a long and unsuccessfully ... But, alas, I repeat, this is the only composition I know that is successfully analyzed in this way.  The reasons for the failure are understandable - on the one hand, the overtones and ‚Äúleft‚Äù frequencies of the guitar ‚Äúlotions‚Äù interfere, on the other hand, the chords rarely sound by themselves, over them with higher, and the loudness usually includes the melody - vocals, guitar / keyboard solo and t .P.  Melody rarely fits completely into harmony on notes - it is too sad, as a result, ‚Äútemporary‚Äù harmonies are constantly formed in the stream of sound that do not correspond to any canonical chords, and everything breaks. <br><br><h5>  Slightly less naive way </h5><br>  I had to go to Google and dig.  The topic turned out to be quite popular in the scientific and near-scientific environment, and in nature there is something to read about it, if you are not afraid of terms like hidden Markov model, naive bayesian classifier, gaussian mix, expectation maximization etc.  At first I was afraid to climb into all this jungle.  Then figured out on the sly. <br>  Here is the article that turned out to be the most useful for me: <br>  <a href="http://academia.edu/1026470/Enhancing_chord_classification_through_neighbourhood_histograms">http://academia.edu/1026470/Enhancing_chord_classification_through_neighbourhood_histograms</a> <br>  To begin with, the authors propose not to look for exact matches with chords, but to evaluate the degree of ‚Äúproximity‚Äù of the chromogram to the chord.  They offer three ways to assess such proximity: <br><ul><li>  maximal chromogram dot product per chord pattern </li><li>  naive bayes classifier </li><li>  estimating the parameters of a Gaussian mixture using the expectation maximization method and using the Mahalanobis distance as a measure of proximity of chromograms </li></ul><br>  After a few more detailed studies from other sources, I threw the third way out - he, judging by the conclusions from the above article, gives results a little better than the trivial first method, and hemorrhoids with matrix arithmetic, calculation of determinants, etc.  lot. <br>  But the first two I implemented. <br>  The first way is super simple.  Suppose we have a chord (for definiteness Am) and a chromogram.  How to determine how the hromogram "similar" to the chord? <br>  We take the mask of notes that sound in a chord - like the one we drew for the key.  For Am, it will be 1 0 0 1 0 0 0 1 0 0 0 0. We multiply this mask as a scalar by the chromogram, as if they were 12-dimensional vectors (well, that is, we stupidly summarize the elements of the chromogram with those indices that are marked by one in the mask) .  Voila - here it is, a measure of "similarity."  We look through all the chords that we know, we find the one with the ‚Äúsimilarity‚Äù the biggest - we believe that it sounds. <br>  The second method is slightly more difficult to implement, but requires training data.  It is based on the Bayes theorem.  "On the fingers" it looks like this. <br>  There is a concept of conditional probability: conditional probability <b>P (A | B)</b> is the probability of an event <b>A</b> , provided that event B has occurred.  This value is determined by the following identity: <b>P (AB) == P (A | B) * P (B)</b> , where <b>P (AB)</b> is the probability of the joint occurrence of events <b>A</b> and <b>B.</b> <br>  From here: <br>  <b>P (AB) == P (A | B) * P (B)</b> <br>  <b>P (AB) == P (B | A) * P (A)</b> <br>  That is, under the condition of nonzero <b>P (A)</b> <br>  <b>P (B | A) == P (A | B) * P (B) / P (A)</b> <br>  This is the Bayes theorem. <br>  How do we use it?  Let us rewrite the formulation of the theorem in convenient notation for our problem: <br>  <b>P (Chord | Chroma) = P (Chroma | Chord) * P (Chord) / P (Chroma)</b> , <br>  where <b>Chord</b> is a chord, <b>Chroma</b> is a chromogram <br>  If we learn from somewhere the distribution of chromograms depending on the chord, then we can find the most plausible chord for a given chromogram, by maximizing the piece <b>P (Chroma | Chord) * P (Chord)</b> - since the chromogram is given, and <b>P (Chroma)</b> , so constant. <br>  It remains to understand where to get the distribution of <b>P (Chroma | Chord)</b> .  For example, you can let the program ‚Äúlisten‚Äù to the recordings of specific known chords so that it can estimate these distributions based on them.  But there is a nuance.  The probability of obtaining a specific value of a chromogram in the ‚Äútraining‚Äù examples is negligible - simply because there are very many possible values.  As a result, when using learning results for real work in the overwhelming majority of cases, <b>P (Chroma | Chord)</b> will be zero for all <b>Chord</b> values, and there will be nothing to maximize. <br>  It is possible (and necessary) before classification to simplify chromograms, for example, by dividing the range of relative amplitude [0, 1], on which the components of the chromogram are defined, say, 3 parts (with the meaning ‚Äúalmost as loud as the loudest note‚Äù, ‚Äúseveral quieter than the loudest note "," very quiet compared to the loudest note ").  But still there will be too many options. <br>  The next thing you can do is to assume that the probability distribution of each component of the chromogram is independent of the other components.  In this case, <b>P (Chroma | Chord) = P (c <sub>1</sub> | Chord) * ... * P (c <sub>12</sub> | Chord)</b> , where <b>c <sub>1</sub> .. c <sub>12</sub></b> are components. <br>  chromograms, and for this particular case we obtain the following formulation of the Bayes theorem: <br><br><img src="https://habrastorage.org/storage3/b0d/7b8/1fe/b0d7b81fe8c7d8924b915199d4b6552f.png" alt="image"><br><br>  But <b>P (c <sub>i</sub> | Chord)</b> can already be extracted even from a scant amount of training data - if, of course, the chromogram is ‚Äúsimplified‚Äù by limiting the definition of ci to three values, as we agreed above. <br>  It remains to take <b>P (Chord)</b> from somewhere for all the chords in question.  It does not matter - any collection of songs with chords will do for this, the main thing is that there are a lot of songs and they are different authors. <br>  A classifier based on maximizing the expression <b>P (c <sub>1</sub> | Chord) * ... * P (c <sub>12</sub> | Chord) * P (Chord)</b> using the <b>Chord</b> parameter is called a naive Bayesian classifier.  And in this particular case, its ‚Äúnaivety‚Äù is essential, since in reality the components of the chromogram are dependent random variables - for example, due to the same overtones.  However, as we will see later, this approach works. <br>  All this is easily realized - the code of the classifier itself and the ‚Äúsubsystem‚Äù of its training is far less than the description given here.  I taught him on a set of major and minor piano chords from some free samples website and a compilation of an original song of the 90s with chords (the first thing that was found on the Internet as a single text file). <br>  Now about the results of field trials.  In the tests participated, in addition to the already mentioned My Friend Of Misery and ‚ÄúPink Elephant‚Äù, the following compositions: <br><ul><li>  Chizh &amp; Co "Assol".  Acoustic guitar, "tricky" chords, the first half of the song in a re-minor with not too strong missing in some places </li><li>  E.Letov "Soldiers are not born" in the version from the concert collection "Music of Spring".  Acoustic guitar, seemingly normally tuned ... Chords - the usual triads, marcheshaped "battle", all in one key.  The recording, albeit a concert, of good quality </li><li>  O. Pulatova "In a dream" from "Home Records".  Acoustic piano, terrible recording quality;  begins with the usual triad, perhaps with a modified bass, then melodic decorations begin.  There are sounds for tonality at the hearing, but not very radical ... Although at the ‚ÄúElephant‚Äù they are not very radical at the hearing ... </li></ul><br>  What happened.  Both classifiers work very hard, all the while jumping from chord to chord.  Naive Bayes are slightly more stable than the maximum of the scalar product, but it seems that only because it ‚Äúknows‚Äù less chords (only major and minor).  Since he, in contrast to the ‚Äúscalar‚Äù brother, ‚Äúknows‚Äù the probabilities with which different chords occur in the author‚Äôs damn song of the 90s, he behaves somewhat bydlovato, trying, roughly speaking, to shove the ‚Äúthree thugs‚Äù everywhere .  Glimpses of reason are found in both classifiers, but for some reason, as a rule, on different fragments of the same work.  Best of all, they coped with Misery.  Bayes periodically fairly consistently gave out Dm and Am locomotives, which is correct (there is Dsus2 / E type harmony Am / E many, many times; / E is with bass "mi" in the sense).  The ‚Äúscalar‚Äù classifier who knows too many chords randomly wandered between Dsus2, Asus2 (aka Dsus4), D, Dm, D5 + and the left trash trying to recognize Dm, and behaved in the same way on Am. <br>  Something managed to pull out of the "In a dream."  Despite the poor sound quality, it was possible to manually identify the almost correct chords of the entry Cm Eb Bm (actually, the last chord B, as it should be in C minor) and the verse Cm Gm Cm Gm Ab F Ab F. The second, ‚Äúdecorated‚Äù part of the entry drowned in the garbage (looking ahead - I never picked it up, the more advanced classification methods also give out nonsense). <br>  From ‚ÄúSoldiers Are Not Born,‚Äù they didn‚Äôt manage to get anything at all ... I don‚Äôt understand why.  In the dump spectrum garbage.  But it sounds normal to hear and pick up by hand is quite possible - Am CGH is there in the introduction, however, I‚Äôm not sure about tonality - the famous beast has arrived in the ear). <br>  Naive Bayes coped better with ‚ÄúAssol‚Äù.  He clearly liked the CSP-shnaya harmony in the d-minor, and glimpses of reason he happened quite often - he picked up the percentages of 20-25 chords correctly, which is against the general sad background and taking into account the ‚Äúcunning‚Äù chords Comrade.  Chigrakova not bad.  But why did he replace almost all A on F # and F # m?  Nonconformist, however. <br>  In general, it was clear that we need to dig further. <br><br><h5>  We are in flight, and we have nothing to lose except chains.  But not his, and Markov </h5><br>  Why do the above methods work so badly?  If you know how to play something, imagine that you are offered to pick up a song, playing separately fragments in length of half a second, and not in order, but separately, so that you could not take into account the already selected part when working with the next ‚Äúquantum‚Äù.  Will you have something?  I would venture to suggest that even if you have absolute hearing, the result will be deplorable. <br>  Therefore, the authors of the above-mentioned work (as well as other similar studies) suggest using musical knowledge as they are expressed by evaluating the ‚Äúsimilarity‚Äù of a chromogram to different chords.  They have this secret knowledge that the probability of meeting one of the chords, which has already been encountered in the composition (or rather, in some of its time window), is higher than this probability for previously unseen chords.  At the same time, they take into account the "fuzziness" of recognition of chords, the frequency of their occurrence in the analyzed window, etc. <br>  In general, this is equivalent to such empirical knowledge "Songs are usually written in one, maximum two tonalities, and therefore the set of chords used in them is limited." <br>  I decided to go a little different way.  I proceeded from the following: <br><ul><li>  Firstly, it should be noted that with a small size of the analyzed using the Fourier transform of the window, it is likely that the chord between two successively running windows does not change (several consecutive windows fall within the period of one chord) </li><li> -,             .   , ,              ¬´¬ª (,     G  Gm,   Am Dm,  ,  G,   B Dm ‚Äî  Gm).         ,         . </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">With this assumption, you can use Markov chains to simulate the process of changing chords. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Imagine a system with a finite (or infinite but countable, i.e. "numbered") the set of states </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">S</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Let it ‚Äúlive‚Äù in discrete time, which has an initial ‚Äú0th‚Äù moment and then each moment of time can be designated by its number - </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , t </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sub></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , etc. Let given probability distribution for the initial state of the system </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (S </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></sub></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) and transition probabilities </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P (S (t </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) = S </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> | S (t </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n-1</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) = S </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">j</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Such a random process, when the probability of a system transitioning to a specific state depends only on its current state, is called a Markov chain (in our case, with discrete time). If the transition probability distribution does not depend on the time </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></sub></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , the Markov chain is called homogeneous.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I nadergal distribution of the first chord and transitions from a heap of songs, unpacking 40-megabyte chm-nickname with the name like "all Russian rock with chords." However, the authors ‚Äúdrive‚Äù - there are no chords there even for some Cinema and Crematorium albums, not to mention such exotic as Pulatova (there are texts, interestingly, there are). Still, the array of collections is quite large, so we can assume that the sample is representative enough to estimate the parameters of our Markov chain. Analysis of the songs was from 10 pm to at least 5 am the next day, however, on the "atomic" netbook.</font></font><br>  Go ahead.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Remember the Bayes theorem - </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P (Chord | Chroma) = P (Chroma | Chord) * P (Chord) / P (Chroma)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ? With the help of our Markov chain, we will evaluate </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P (Chord)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , and </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P (Chroma | Chord),</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> let it still be evaluated by naive Bayesian and "scalar" classifiers. Regarding the latter, we, in fact, don‚Äôt need a ‚Äúreal‚Äù probability, so we can consider our inner product for chromogram to chord mask as ‚Äúprobability‚Äù that this chromogram corresponds to this chord. Well, you can also normalize these scalar pieces so that their sum over all chords is equal to 1, although it is not necessary to search for the maximum, and I scored them. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So we can estimate </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P (Chord (t </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) = C </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, based on the statistical evaluation of the distribution of the first chords in the Russian rock compilation (in this way, we take into account the actually different frequency of using different tonalities). For the next windows, we can evaluate </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P (Chord (t </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) = C </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> as </font></font><br><br><img src="https://habrastorage.org/storage3/c2b/e8d/ad8/c2be8dad81ac2ab9e0dd0b018051c17a.png" alt="image"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">where </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P (Chord (t </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n-1</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) = C </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">j</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> were evaluated at the previous step. Find the maximum value of this expression for all i and get the most likely chord. Please note - here we take into account the fact that we do not know for sure what chord sounded in the previous window, we only have an estimate of the probability distribution of different chords.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As for the probability of ‚Äúnot moving‚Äù from chord to chord, I added the corresponding command line parameter and select the optimal value manually. </font><font style="vertical-align: inherit;">In fact, this probability depends on the ratio between the duration of the stream window being analyzed and the musical tempo of the piece. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The above algorithm with proper selection of parameters proved to be very stable. </font><font style="vertical-align: inherit;">Stumbling off the right path when trying to ‚Äúbydolofikatsii‚Äù some difficult harmony, he honestly tries to return from the split ball, and most often he succeeds.</font></font><br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> A couple of small optimizations </font></font></h5><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Optimization number 1.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> It was noted that the classifier "blows the roof", as a rule, on different fragments. It is also noted that if the same chord defined the classifier several times in a row, this chord is usually correct. These observations led to the following optimization: we start the ring buffer for several chords and push the chords there from the output of both classifiers. If once again the classifiers gave out different chords for the same window, take the one that occurs more often in the buffer (well, if it is equally common or not at all, then the first of the two). </font></font><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Optimization ‚Ññ2.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Different tonalities are used in music (especially guitar, where the fingering depends on them) with different frequencies. Basically, the people, of course, love those who have fewer alteration icons in the key ‚Äî that is, in A minor / C major, E minor / G major, D minor / F major, or in the extreme case of B minor / D major. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Because of this, the statistics on transitions between chords for the most common keys are ‚Äúbetter‚Äù than for less common ones. Hence the possibility of the possibility of ‚Äúvirtual transposition‚Äù ‚Äîthe command line keys that say the program ‚Äúpick up chords in the tone that you see, but take the transition probabilities as if everything sounds n / half lower / higher‚Äù.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This approach is often used in manual selection - for example, we know that the song is in C minor, but we pick up chords in A minor, mumbling a melody a half tone lower, because what are the chords in this C minor? and the fingers keep the barre tired all the time. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The results of this stage are as follows: when applying the approach described above with both optimizations, we managed to find chords for the songs of O. Pulatova ‚ÄúIn a dream‚Äù (except for the second part of the introduction) and ‚ÄúThe river of times‚Äù (introduction and verse; tonality is a certain mixture of ly minor) with the accuracy of selection of about 70% or even slightly more.</font></font> Hooray! <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> As for the second half of the introduction to "In a dream" - the best implementation, apparently, will be to go to Odessa, by chance there meet the author, ask her for chords, hardcore. </font></font><br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Viterbi Algorithm </font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The Viterbi algorithm allows using indirect data (well, that is, in our case, chromogram) for a certain period of the Markov chain‚Äôs life, to obtain the most likely sequence of states (chords) that the process has gone through during this period. The algorithm is very simple, and I tried to implement it, but, I see, I do not know how to prepare it. Depending on the likelihood of ‚Äúnot moving,‚Äù it either sticks on one chord, or gives out a bunch of garbage (though usually in the right tone). Perhaps this is due to the requirement that ‚Äúthe results of the observations should be 1-to-1 correspond to the‚Äú steps ‚Äùof the random process passed.‚Äù But, on the other hand, who prevents us from believing that our ‚Äústep‚Äù has a fixed physical lifetime, and then the next step comes, even if the state has not changed?</font></font> I do not know.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Or maybe just somewhere there are errors in the code - debugging such things is not easy ... </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Well, that's all.</font></font> Thanks for attention! <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sources can be taken here: </font></font><a href="https://github.com/t0mm/ChordDetector"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://github.com/t0mm/ChordDetector</font></font></a> </div><p>Source: <a href="https://habr.com/ru/post/193514/">https://habr.com/ru/post/193514/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../193502/index.html">Web Studio / Agency Marketing Strategy</a></li>
<li><a href="../193504/index.html">Webcast: Dell Virtual Desktop Infrastructure Solutions</a></li>
<li><a href="../193508/index.html">2Giga: Special Edition</a></li>
<li><a href="../193510/index.html">The first tests DIY-dimmer "Smart Home"</a></li>
<li><a href="../193512/index.html">IBM Pure Flex System Overview</a></li>
<li><a href="../193516/index.html">Gamification of the educational process</a></li>
<li><a href="../193518/index.html">Happy programmer!</a></li>
<li><a href="../193524/index.html">786,432 cores of the IBM MIRA supercomputer began to model the early Universe</a></li>
<li><a href="../193528/index.html">Analytics. Cat. Friday</a></li>
<li><a href="../193530/index.html">[contest] DevOps Brainwashing</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>