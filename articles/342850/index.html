<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>RxPM - reactive implementation of the Presentation Model pattern</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Half a year after the last article about comparing RxPM with other presentation patterns, we are ready to present with Jeevuz with Jeevuz the library ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>RxPM - reactive implementation of the Presentation Model pattern</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/bs/sp/du/bsspduk6c_cyqko1jsbxefafbzg.png"><br><p>  Half a year after the last <a href="https://habrahabr.ru/company/mobileup/blog/326962/">article</a> about comparing RxPM with other presentation patterns, we are ready to present with <a href="https://habrahabr.ru/users/jeevuz/" class="user_link">Jeevuz</a> with <a href="https://habrahabr.ru/users/jeevuz/" class="user_link">Jeevuz the</a> library <strong>RxPM</strong> - a reactive implementation of the <a href="https://martinfowler.com/eaaDev/PresentationModel.html">Presentation Model</a> pattern.  Let's take a quick overview of the main components of the library and show how to use them. </p><br><a name="habracut"></a><br><p>  First, let's look at the general scheme: </p><br><img src="https://habrastorage.org/webt/rz/nb/rh/rznbrht-4vw_74h6wzrjrui8upk.png"><br><p></p><br><ul><li>  PresentationModel stores the state for the View, responds to UI events by changing the model and the View state. </li><li>  View subscribes to state changes and sends user actions to PresentationModel. </li><li>  Model is the layer behind which business logic, data storage and retrieval is hidden. </li></ul><br><p>  Let us turn to the consideration of the main components of the library. </p><br><h1 id="state">  State </h1><br><p>  The main objective of RxPM is to describe all the states in PresentationModel and provide the ability to interact with them in a reactive style.  Often we need not only to access the state, but also to react to its changes in order to synchronize the view (View).  For this, the library has a class <strong>State</strong> that implements a reactive property. </p><br><p>  <em>A reactive property is a type of property that notifies of its changes and provides reactive interfaces for interacting with it.</em> </p><br><p>  In the <a href="https://habrahabr.ru/company/mobileup/blog/326962">article</a> about the pattern, we said that, we need to describe two properties in order to hide access to the state change from View: </p><br><pre><code class="hljs scala"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> inProgressRelay = <span class="hljs-type"><span class="hljs-type">BehaviorRelay</span></span>.create() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> inProgressObservable = inProgressRelay.hide()</code> </pre> <br><p>  It was one of the annoying moments in the pattern, so we decided to wrap the <a href="https://github.com/JakeWharton/RxRelay"><code>BehaviorRelay</code></a> in the <strong>State</strong> and provide the <code>observable</code> and <code>consumer</code> to interact with it.  Now we can write in one line: </p><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> inProgress = State&lt;<span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span>&gt;(initialValue = <span class="hljs-literal"><span class="hljs-literal">false</span></span>)</code> </pre> <br><p>  In View we subscribe to state changes: </p><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">pm</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.inProgress</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.observable</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.bindTo</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">progressBar</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.visibility</span></span>())</code> </pre> <br><p>  <em><code>bindTo</code> - library extension for binding to reactive properties</em> </p><br><p>  You can change the state through the <a href="">consumer</a> , which is available only inside the PresentationModel: </p><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">inProgress</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.consumer</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.accept</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">true</span></span>)</code> </pre> <br><p>  As with the regular property, we can take the current state value: </p><br><pre> <code class="hljs cs">inProgress.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span></code> </pre> <br><p>  <strong>The advantage of the reactive property is</strong> not only that one can observe its change, but also to link and link it with other reactive properties.  So we get a new state that will depend on and respond to the changes of others.  For example, you can block a button for the duration of the request to the network: </p><br><pre> <code class="hljs scala"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> inProgress = <span class="hljs-type"><span class="hljs-type">State</span></span>(initialValue = <span class="hljs-literal"><span class="hljs-literal">false</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> buttonEnabled = <span class="hljs-type"><span class="hljs-type">State</span></span>(initialValue = <span class="hljs-literal"><span class="hljs-literal">true</span></span>) inProgress.observable .map { progress -&gt; !progress } .subscribe(buttonEnabled.consumer) .untilDestroy()</code> </pre> <br><p>  <em><code>untilDestroy</code> is an extension to PresentationModel that adds <code>Disposable</code> to <code>CompositeDisposable</code></em> . </p><br><p>  Another example is to enable and disable a button depending on the fill in the fields in the form: </p><br><pre> <code class="hljs cmake">//       View: val nameChanges = Action&lt;<span class="hljs-keyword"><span class="hljs-keyword">String</span></span>&gt;() val phoneChanges = Action&lt;<span class="hljs-keyword"><span class="hljs-keyword">String</span></span>&gt;() val buttonEnabled = State(initialValue = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) Observable.combineLatest(nameChanges.observable, phoneChanges.observable, BiFunction { name: <span class="hljs-keyword"><span class="hljs-keyword">String</span></span>, phone: <span class="hljs-keyword"><span class="hljs-keyword">String</span></span> -&gt; name.isNotEmpty() &amp;&amp; phone.isNotEmpty() }) .subscribe(buttonEnabled.consumer) .untilDestroy()</code> </pre> <br><blockquote>  Thus, we can declaratively bind some reactive properties (states) and get others - dependent.  This is the essence of reactive programming. </blockquote><br><h1 id="action">  Action </h1><br><p>  Similar to <strong>State,</strong> this class encapsulates access to <code>PublishRelay</code> and is intended to describe user actions, such as pushing buttons, switching, and so on. </p><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> buttonClicks = Action&lt;<span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>&gt;() buttonClicks.observable .subscribe { <span class="hljs-comment"><span class="hljs-comment">// handle click } .untilDestroy()</span></span></code> </pre> <br><p>  It would be a logical question, and not easier to describe a method in PresentationModel, why declare a property and subscribe to it?  In some cases this is true.  For example, if the action is very simple, such as opening the next screen or calling the model directly.  However, if you need to make a request to the network on a click, and at the same time filter clicks during progress, then in this case interaction via <strong>Action is</strong> preferable.  The main advantage of <strong>Action</strong> is that it does not break the Rx chain.  I will explain with an example. </p><br><p>  Option with method: </p><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> requestDisposable: Disposable? = <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sendRequest</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { requestDisposable?.dispose() requestDisposable = model.sendRequest().subscribe() } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onDestroy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onDestroy() requestDisposable?.dispose() }</code> </pre> <br><p>  As you can see from the example above, it is necessary to declare <code>Disposable</code> variable for each request in order to complete the previous request with each new click.  And also do not forget to unsubscribe in <code>onDestroy</code> .  This is due to the fact that every time the <code>sendRequest</code> method is <code>sendRequest</code> by clicking on a button, a new Rx chain is created. </p><br><p>  Option with <strong>Action</strong> : </p><br><pre> <code class="hljs">buttonClicks.observable .switchMapSingle { model.sendRequest() } .subscribe() .untilDestroy()</code> </pre> <br><p>  Using <strong>Action</strong> , you only need to initialize the Rx chain once and subscribe to it.  In addition, we can use numerous useful Rx operators, such as <code>debounce</code> , <code>filter</code> , <code>map</code> , etc. </p><br><p>  For example, consider the delay in the query when entering a string to search: </p><br><pre> <code class="hljs scala"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> searchResult = <span class="hljs-type"><span class="hljs-type">State</span></span>&lt;<span class="hljs-type"><span class="hljs-type">List</span></span>&lt;<span class="hljs-type"><span class="hljs-type">Item</span></span>&gt;&gt;() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> searchQuery = <span class="hljs-type"><span class="hljs-type">Action</span></span>&lt;<span class="hljs-type"><span class="hljs-type">String</span></span>&gt;() searchQuery.observable .debounce(<span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-type"><span class="hljs-type">TimeUnit</span></span>.<span class="hljs-type"><span class="hljs-type">MILLISECONDS</span></span>) .switchMapSingle { <span class="hljs-comment"><span class="hljs-comment">// send request } .subscribe(searchResult.consumer) .untilDestroy()</span></span></code> </pre> <br><p>  And in combination with <a href="https://github.com/JakeWharton/RxBinding%255D">RxBinding</a> , it is even more convenient to link View and PresentationModel: </p><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">button</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.clicks</span></span>()<span class="hljs-selector-class"><span class="hljs-selector-class">.bindTo</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">pm</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.buttonClicks</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.consumer</span></span>)</code> </pre> <br><h1 id="command">  Command </h1><br><p>  Another important problem is the display of errors and dialogs, or other commands.  They are not a state, as they must be executed once.  For example, to show the dialogue, the <strong>State</strong> will not work for us, since each subscription to the <strong>State</strong> will receive the last value, respectively, each time a new dialogue will be shown.  To solve this problem, a <strong>Command</strong> class was created that implements the desired behavior by encapsulating <code>PublishRelay</code> . </p><br><p>  But what happens if you send a command at a time when View is not yet attached to a PresentationModel?  We will lose this team.  To prevent this, we have provided a <strong>buffer</strong> that accumulates commands, while the View is absent, and sends them when the View is bound.  When View is bound to PresentationModel, then <strong>Command</strong> works just like <code>PublishRelay</code> . </p><br><p>  By default, the buffer accumulates an unlimited number of commands, but you can set a specific buffer size: </p><br><pre> <code class="hljs lisp">val errorMessage = Command&lt;String&gt;(<span class="hljs-name"><span class="hljs-name">bufferSize</span></span> = <span class="hljs-number"><span class="hljs-number">3</span></span>)</code> </pre> <br><p>  If you want to save only the last command: </p><br><pre> <code class="hljs lisp">val errorMessage = Command&lt;String&gt;(<span class="hljs-name"><span class="hljs-name">bufferSize</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre> <br><p>  If you specify 0, then the <strong>Command</strong> will work as <code>PublishRelay</code> : </p><br><pre> <code class="hljs lisp">val errorMessage = Command&lt;String&gt;(<span class="hljs-name"><span class="hljs-name">bufferSize</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>)</code> </pre> <br><p>  Attached to View: </p><br><pre> <code class="hljs cmake">errorMessage.observable().bindTo { <span class="hljs-keyword"><span class="hljs-keyword">message</span></span> -&gt; Toast.makeText(context, <span class="hljs-keyword"><span class="hljs-keyword">message</span></span>, Toast.LENGTH_SHORT).show() }</code> </pre> <br><p>  The most illustrative work of the <strong>Command</strong> is the marble diagram: </p><br><img src="https://habrastorage.org/webt/u3/nw/7f/u3nw7fi8jjxi6lpvkvvasrt-p6k.png"><br><p>  By default, the buffer is turned on when binding a View to a PresentationModel.  But you can implement your mechanism by specifying the opening / closing <code>observable</code> . </p><br><img src="https://habrastorage.org/webt/bo/co/ct/bococtb-1wod0aduw200c8mjlks.png"><br><p>  For example, when working with Google Maps, a sign of readiness to View is not only binding to the PresentationModel, but also the readiness of the map.  The library already has a ready command for working with the map: </p><br><pre> <code class="hljs lisp">val moveToLocation = mapCommand&lt;LatLng&gt;()</code> </pre> <br><h1 id="presentationmodel">  PresentationModel </h1><br><p>  We described the basic RxPM primitives: <strong>State</strong> , <strong>Action,</strong> and <strong>Command</strong> , from which the PresentationModel is built.  Now let's look at the base class <code>PresentationModel</code> .  It carries out all the main work with the life cycle.  In total, we have 4 callbacks: </p><br><ul><li>  <code>onCreate</code> - called when first created, this is a good place to initialize Rx chains and link states. </li><li>  <code>onBind</code> - called when the View is bound to PresentationModel. </li><li>  <code>onUnbind</code> ‚Äî Called when the View is unbound from the PresentationModel. </li><li>  <code>onDestroy</code> - PresentationModel completes its work.  The right place to free up resources. </li></ul><br><p>  You can also monitor the life cycle through <code>lifecycleObservable</code> . </p><br><p>  For a convenient unsubscribe, there are <code>Disposable</code> extensions available in <code>PresentationModel</code> : </p><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> Disposable.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">untilUnbind</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { compositeUnbind.add(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> Disposable.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">untilDestroy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { compositeDestroy.add(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) }</code> </pre> <br><p>  <code>onBind</code> and <code>onDestroy</code> are cleared with <code>compositeUnbind</code> and <code>compositeDestroy</code> respectively. </p><br><p>  Let's look at an example of working with <code>PresentationModel</code> : <br>  It is necessary to send a request to the network via <em>Pull To Refresh</em> and update the data on the screen, display the progress at the time of the request, and in the case of an error show the user a dialogue with the message. </p><br><p>  First you need to determine which states and commands are needed for the View and which custom events we can receive from the View: </p><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DataPresentationModel</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> dataModel: DataModel ) : PresentationModel() { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> <span class="hljs-keyword"><span class="hljs-keyword">data</span></span> = State&lt;List&lt;Item&gt;&gt;(emptyList()) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> inProgress = State(<span class="hljs-literal"><span class="hljs-literal">false</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> errorMessage = Command&lt;String&gt;() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> refreshAction = Action&lt;<span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>&gt;() <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre> <br><p>  Now we need to bind the properties and model in the <code>onCreate</code> method: </p><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DataPresentationModel</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> dataModel: DataModel ) : PresentationModel() { <span class="hljs-comment"><span class="hljs-comment">// ... override fun onCreate() { super.onCreate() refreshAction.observable //    .skipWhileInProgress(inProgress.observable) .flatMapSingle { dataModel.loadData() .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) //    .bindProgress(inProgress.consumer) .doOnError { errorMessage.consumer.accept("Loading data error") } } .retry() .subscribe(data.consumer) .untilDestroy() //       refreshAction.consumer.accept(Unit) } }</span></span></code> </pre> <br><blockquote>  Pay attention to the operator <code>retry</code> , it is necessary here, because when an error is received, the chain will complete its work and the actions will no longer be processed.  The operator <code>retry</code> chain in case of an error.  But be careful and do not use it if you start the chain from <strong>State</strong> . </blockquote><br><h1 id="pmview">  Pmview </h1><br><p>  When PresentationModel is designed, it remains only to bind it to the View. <br>  The library already has base classes for implementing <strong>PmView</strong> : <code>PmSupportActivity</code> , <code>PmSupportFragment</code> and <code>PmController</code> (for users of the <a href="https://github.com/bluelinelabs/Conductor/">Conductor</a> framework).  Each of them implements the <code>AndroidPmView</code> interface and pushes the necessary callbacks to the corresponding delegate, which manages the PresentationModel life cycle and ensures that it is correctly stored during the screen rotation. </p><br><p>  Inherit from <code>PmSupportFragment</code> and implement only two mandatory methods: </p><br><ul><li>  <code>providePresentationModel</code> - called when the PresentationModel is created. </li><li>  <code>onBindPresentationModel</code> - in this method you need to bind to the PresentationModel properties (use <a href="https://github.com/JakeWharton/RxBinding">RxBinding</a> and the <code>bindTo</code> extension). </li></ul><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DataFragment</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">PmSupportFragment</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DataPresentationModel</span></span></span><span class="hljs-class">&gt;</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">providePresentationModel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> = DataPresentationModel(DataModel()) <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onBindPresentationModel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pm: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">DataPresentationModel</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { pm.inProgress.observable.bindTo(swipeRefreshLayout.refreshing()) pm.<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.observable.bindTo { <span class="hljs-comment"><span class="hljs-comment">// adapter.setItems(it) } pm.errorMessage.observable.bindTo { // show alert dialog } swipeRefreshLayout.refreshes().bindTo(pm.refreshAction.consumer) } }</span></span></code> </pre> <br><p>  <strong><code>bindTo</code></strong> is a handy extension to <code>AndroidPmView</code> .  Using it, you do not need to worry about unsubscribing from the properties from PresentationModel and switching to the main thread. </p><br><p>  To work with Google Maps in the library there are additional base classes: <code>MapPmSupportActivity</code> , <code>MapPmSupportFragment</code> and <code>MapPmController</code> .  They add a separate method to bind <code>GoogleMap</code> : </p><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onBindMapPresentationModel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pm: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">PM</span></span></span></span><span class="hljs-function"><span class="hljs-params">, googleMap: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">GoogleMap</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span></code> </pre> <br><p>  In this method we can display pins on a map, move and animate a location, etc. </p><br><h1 id="two-way-data-binding">  Two-way Data Binding </h1><br><p>  So far, we have only considered a one-way change of <strong>State</strong> , when the PresentationModel changes state, and View subscribes to it.  But quite often there is a need to change the state from two sides.  The classic example is an input field: its value can be changed by both the user and PresentationModel, initializing with the initial value or formatting the input.  This bundle is called bilateral databing.  Let us show in the diagram how it is implemented in RxPM: </p><br><img src="https://habrastorage.org/webt/8w/5f/w3/8w5fw3lmyhc2poeqqopjps2nzd8.png" width="400"><br><br><p>  The user enters the text  the listener triggers the change is transferred to Action Action PresentationModel filters and formats the text and substitutes it in State State the changed state receives View View the text is inserted in the input field the listener triggers ‚ûî the circle closes and the system runs into an endless loop. </p><br><p>  We have written an <code>InputControl</code> class that implements this two-way binding for input fields and solves the looping problem. </p><br><p>  We declare in PresentationModel: </p><br><pre> <code class="hljs pgsql">val <span class="hljs-type"><span class="hljs-type">name</span></span> = inputControl()</code> </pre> <br><p>  We bind to View through the usual <code>bindTo</code> </p><br><pre> <code class="hljs pgsql">pm.name bindTo editText</code> </pre> <br><p>  You can also set the formatter: </p><br><pre> <code class="hljs lisp">val name = inputControl( <span class="hljs-name"><span class="hljs-name">formatter</span></span> = { it.take(<span class="hljs-number"><span class="hljs-number">50</span></span>).capitalize().replace(<span class="hljs-string"><span class="hljs-string">"[^a-zA-Z- ]"</span></span>.toRegex(), <span class="hljs-string"><span class="hljs-string">""</span></span>) } )</code> </pre> <br><p>  <code>CheckControl</code> solves a similar problem of looping and <code>CheckControl</code> for <code>CheckBox</code> . </p><br><h1 id="rxpm">  Rxpm </h1><br><p>  We reviewed the main classes and features of the library.  This is not a complete list of features that are in RxPM: </p><br><ul><li>  Basic implementation of <code>PresentationModel</code> . </li><li>  Saving the <code>PresentationModel</code> while rotating the screen. </li><li>  Life cycle processing, subscription and unsubscribe. </li><li>  Base classes for implementing <code>PmView</code> , including for the Conductor. </li><li>  <code>State</code> , <code>Action</code> , <code>Command</code> . </li><li>  <code>InputControl</code> , <code>CheckContol</code> , <code>ClickControl</code> . </li><li>  <code>bindTo</code> properties through <code>bindTo</code> and other useful extensions. </li><li>  Base classes for working with Google Maps. </li></ul><br><p>  The library is written in Kotlin and uses RxJava2. <br>  RxPM is already used in several applications in production and has shown stability in its work.  But we continue to work on it, there are many ideas for further development and improvement.  Version 1.1 recently came out with a very useful feature for navigation, but we'll talk about this in the next article. </p><br><p>  Only one article will not be enough to understand the possibilities of RxPM.  So try, see the source and examples, ask your questions.  We welcome feedback. </p><br><p>  RxPM: <a href="https://github.com/dmdevgo/RxPM">https://github.com/dmdevgo/RxPM</a> <br>  Sample: <a href="https://github.com/dmdevgo/RxPM/tree/develop/sample">https://github.com/dmdevgo/RxPM/tree/develop/sample</a> <br>  Chat in telegrams: <a href="https://t.me/Rx_PM">https://t.me/Rx_PM</a> </p><br><h6 id="p-s">  PS </h6><br><p>  November 24 (this Friday) I will give a mini-report about RxPM on <a href="http://droidcon.moscow/">Droidcon Moscow 2017</a> .  Come - let's talk. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/342850/">https://habr.com/ru/post/342850/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../342838/index.html">Sparse columns or sparse columns in MS SQL Server. Real experience</a></li>
<li><a href="../342840/index.html">Performance in all senses: how did DotNext 2017 Moscow go</a></li>
<li><a href="../342842/index.html">The internal structure and optimization of the webpack bundle</a></li>
<li><a href="../342846/index.html">ENOG'14 - the impact of content locks on the Internet infrastructure</a></li>
<li><a href="../342848/index.html">Using SVG as a Placeholder</a></li>
<li><a href="../342852/index.html">LiveXAML is a useful tool for Xamarin developer</a></li>
<li><a href="../342860/index.html">Startup history ROI4CIO: Is it possible to automate the sale of IT solutions in the B2B sector and not only?</a></li>
<li><a href="../342862/index.html">Should I use the tabular model SSAS?</a></li>
<li><a href="../342864/index.html">The second wave cnPilot</a></li>
<li><a href="../342868/index.html">Indexing is global and not very</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>