<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>CMD on ATmega16</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Spoiler : this article does not squeeze nostalgic tears. 

 Having decided not so long ago to get acquainted closer (after the Arduino) with microcont...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>CMD on ATmega16</h1><div class="post__text post__text-html js-mediator-article">  <b>Spoiler</b> : this article does not squeeze nostalgic tears. <br><br>  Having decided not so long ago to get acquainted closer (after the Arduino) with microcontrollers in general <br>  and with ATmega microcontrollers in particular, I quickly realized that just reading about MK, <br>  run the code in the emulator, ‚Äúblinking LED‚Äù - this is somehow not the case.  So I decided <br>  "Gash" any - even if useless - project, and deal with everything <br>  already along the way.  Microprocessor labs came to mind <br>  and the training stand on which these works were performed - the so-called educational microprocessor <br>  set (UMK), which we called simply ‚ÄúUmka‚Äù. <br><br><h4>  About CMD </h4><br>  So, if you do not go into details (if you go - then the links below), then <br>  "Umka" is a microcomputer based on microprocessor K580IK80A, produced in the 80s <br>  of the last century (I was also lucky to work with him in the not-quite-distant 2009) <br>  is a weighty such box.  More information about the story "Umok" <br>  and so on can be found on the second link below.  This is how it looks. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/files/f22/9be/872/f229be872be8422da9d77e280a93e9ba.jpg"><a name="habracut"></a><br>  (The photo is brazenly taken from the first link below; more photos are from the same <br>  link) <br><br>  What is there: indication of data buses and addresses, indication of the processor status register, <br>  display to display the contents of memory cells and input data, input buttons <br>  data.  The two columns of buttons to the left are the so-called directives sewn into ‚ÄúUmka‚Äù <br>  ‚ÄúMonitor‚Äù programs - they became the goal of my project (directives, not buttons). <br>  Briefly about directives.  There is nothing special. <br>  "P" - view the contents of the memory cell: enter the address of the cell, see what is there <br>  lies, if desired - write another value. <br>  "WG" - view the contents of the registers: similar to viewing the contents of the cells.  In my <br>  "Version" of this directive is missing: it is not particularly necessary, because in <br>  ATmega RAM, general registers and peripheral registers are located in <br>  address space, and it is assumed that they can be accessed through <br>  Directive "P". <br>  ‚ÄúCS‚Äù - calculation of the checksum of the data array: enter the address of the beginning of the array, <br>  the final address of the array, the sum of the contents of the cells of the array is displayed. <br>  ‚Äú‚Äù - filling the memory array with a constant: enter the starting address, enter the ending <br>  address of the array, enter the variable - the cells of the array are filled with this variable. <br>  ‚ÄúPM‚Äù - relocation of the memory array: enter the starting address of the array being moved <br>  memory, enter its final address, enter the starting address of the array - array <br>  moves to the memory area starting with the entered allocation address. <br>  The directive "ST" - the implementation of the user program - I missed, more on that below. <br>  The ‚ÄúVP‚Äù button is the execution of the directive, the "_" button separates the variables as they are entered, "SB" - the button <br>  reset.  Read more about entering and executing directives here. <br><br>  <a href="http://sfrolov.livejournal.com/136290.html">sfrolov.livejournal.com/136290.html</a> - photo CMD, memories, impressions. <br>  <a href="http://www.computer-museum.ru/histussr/umk_sorucom_2011.htm">www.computer-museum.ru/histussr/umk_sorucom_2011.htm</a> - a bit of history. <br><br><h4>  What was planned </h4><br>  The aim of my project was to create a device capable of fulfilling these directives and <br>  display information on the display, a kind of lite-version of "Umki" (well, very, very lite). <br>  What was used in the project: <br>  <b>1.</b> The ATmega16 microcontroller.  The program is written in assembly language in AVRStudio. <br>  <b>2.</b> Matrix keyboard for entering values.  I found the code for working with the keyboard <br>  <a href="http://eugenemcu.ru/publ/10-1-0-45">here</a> (thanks to the author), then just rewrote it in assembler.  Since RAM ATmega16 <br>  limited to the address $ 045F, then the last three digits are entered.  By the way, data / addresses <br>  are entered and displayed in hexadecimal format. <br>  <b>3.</b> LCD display 16x2 on the controller HD44780.  Understanding the display helped these <br>  Two articles - <a href="http://easyelectronics.ru/avr-uchebnyj-kurs-podklyuchenie-k-avr-lcd-displeya-hd44780.html">here</a> and <a href="http://makesystem.net/%3Fp%3D9">here</a> (thanks to the authors), the datasheet helped to initialize the display correctly. <br>  <b>4.</b> Simple buttons for directives.  Another button was also added - ‚ÄúEnter‚Äù (on <br>  photo it with an arrow): needed to confirm the input of each digit of the address or data <br>  - a kind of protection from the chatter of the contacts of the matrix keyboard (without which it is quite possible <br>  it was a cost, but a clever idea, as they say, comes afterwards). <br><br><h4>  What is the result </h4><br>  It was possible to achieve everything that was planned: you can view and change <br>  contents of RAM and MK registers, write a constant to an array of cells, count <br>  checksum of the array, move the array of cells (here is the entertainment * sarcastic *); <br>  writing / moving an array somewhere for $ 0440 (approximately) makes a regular <br>  chaos in the stack area.  You can perform as many as six items of the first laboratory work from <br>  Workshop on the link above. <br>  Judging by the information found, the ‚ÄúMonitor‚Äù program, wired into ‚ÄúUmka‚Äù, occupies 1 Kb. <br>  One of the tasks was to put the program in 1 KB, which was successfully (even with <br>  reserve), but because of the LCD-display and the desire to make the code more informative <br>  almost doubled. <br>  This ‚ÄúUmka‚Äù (professional edition) allowed you to write your program on <br>  microprocessor assembler K580IK80A, recording in memory the codes of the relevant commands, <br>  and then perform it either stepwise or cyclically.  I do not know how it was <br>  implemented in Umka, and the solution does not seem obvious to me, so this option in <br>  there is no project (for a start, however, the directives were enough for me), I will gladly accept <br>  proposals for the implementation of this.  For this, I affectionately nicknamed the resulting device "Wit." <br><br><img src="https://habrastorage.org/files/baa/9af/65c/baa9af65c48d4deaa00a3adb462ae402.jpg"><br><br><div class="spoiler">  <b class="spoiler_title">This is the code</b> <div class="spoiler_text"> .include "m16def.inc" <br>  .device ATmega16 <br>  .def count = r18;  r18 - counter <br>  .def mode = r19;  r19 - signs of modes <br>  .def buf = r25;  to enter values <br>  .def rLCD = r22;  for working with LCD <br>  .def rKey = r20;  keyboard and trivial values <br><br>  ;  LCD commands <br>  .equ off = 0b00001000; off <br>  .equ clrSc = 0b00000001; clear <br>  .equ config = 0b00111000;  8bit, 2 lines <br>  .equ incr = 0b00000110;  addr + (increase address, static screen) <br>  .equ on = 0b00001100; on <br>  .equ right = 0b00010100;  right shift <br>  .qu down = 0b11000000;  go to the second line <br>  .qu up = 0b10000000;  on the first line <br>  .equitor = 0b00001111;  flashing cursor <br>  .equ noCursor = 0b00001100 <br>  .equ left = 0b00010000;  to the left <br><br>  ;  LCD data (port D) <br>  .equ _dp = DDRD <br>  .equ _dpo = PORTD <br>  .equ _dpi = PIND <br><br>  ;  LCD control (port C) <br>  .equ _cp = DDRC <br>  .equ _cpo = PORTC <br>  .equ rs = 0 <br>  .equ rw = 1 <br>  .equ e = 7 <br><br>  ;  keyboard (port A) <br>  .equ _mp = DDRA <br>  .equ _mpi = PINA <br>  .equ _mpo = PORTA <br><br>  ;  directives (port B) <br>  .equ BUT = PINB <br>  .equ BUTddr = DDRB <br>  .equ BUTp = PORTB <br>  .equ P = 0;  button P (view / change the contents of memory) <br>  .equ quit = 1;  output <br>  . equ exe = 2;  VP button (execution) <br>  .equ enter = 3;  enter button <br>  .equ space = 4;  "_" button <br>  .ququ CF = 5;  button ZK (filling constant) <br>  .equ CS = 6;  COP button (checksum) <br>  .equ AM = 7;  PM button (array moving) <br>  ;  T flag - data entry mode <br><br>  ; ======================= Macro to poll the matrix keyboard ==================== <br>  .macro matrix <br>  rcall _exit <br>  ldi rKey, 0 <br>  ldi r16, 0xff;  load units in r16 <br>  cbi _mpo, @ 0;  clear the bit corresponding to the column <br>  out _mpo, r16;  units in portd <br>  in r16, _mpi;  read port D data register <br>  cpi r16, @ 1 <br>  breq ein <br>  cpi r16, @ 2 <br>  breq zwei <br>  cpi r16, @ 3 <br>  breq drei <br>  cpi r16, @ 4 <br>  breq vier <br>  sbi _mpo, @ 0;  set the bit corresponding to the column (return to the original state) <br>  rjmp @ 9;  if none of the buttons in the column were pressed, <br>  ;  then go to the label - the macro with the parameters of the next column or at the beginning of the survey <br><br>  ein: <br>  ldi rKey, @ 5;  loading the rKey value corresponding to the button pressed <br>  ldi rLCD, @ 5;  load the same value for display <br>  rcall _BF <br>  rcall _charInput <br>  sbi _mpo, @ 0;  set the bit corresponding to the column (return to the original state) <br>  rjmp _check;  go to view label <br><br>  zwei: <br>  ldi rKey @ 6 <br>  ldi rLCD, @ 6 <br>  rcall _BF <br>  rcall _charInput <br>  sbi _mpo, @ 0 <br>  rjmp _check <br><br>  drei: <br>  ldi rKey @ 7 <br>  ldi rLCD @ 7 <br>  rcall _BF <br>  rcall _charInput <br>  sbi _mpo, @ 0 <br>  rjmp _check <br><br>  vier: <br>  ldi rKey @ 8 <br>  ldi rLCD @ 8 <br>  rcall _BF <br>  rcall _charInput <br>  sbi _mpo, @ 0 <br>  rjmp _check <br>  .endmacro <br><br>  .cseg <br><br>  .org 0 <br><br>  ;  stack <br>  ldi r16, Low (RAMEND) <br>  out SPL, r16 <br>  ldi r16, High (RAMEND) <br>  out SPH, r16 <br><br>  sbi _cp, 0; rs <br>  sbi _cp, 1; rw <br>  sbi _cp, 7; e <br><br>  ;  port initialization <br>  ldi r16,0b00001111 <br>  out _mp, r16;  DDRA - input <br>  ldi r16, 0b11110000 <br>  out _mpo, r16;  with a suspender <br><br>  ldi r16, 0x00 <br>  out BUTddr, r16;  DDRB - input <br>  ldi r16, 0xff <br>  out BUTp, r16;  with a suspender <br><br>  ;  display initialization <br>  rcall altInit <br><br>  ; ================================= main loop ============== ================ <br>  go: <br>  rcall _resetLCD <br>  ldi xl, 0x00 <br>  ldi xh, 0x00 <br>  ldi yl, 0x00 <br>  ldi yh, 0x00 <br>  ldi zl, 0x00 <br>  ldi zh, 0x00 <br>  clt <br>  clc <br>  clh <br>  clr mode <br>  clr buf <br>  ldi count, 1 <br><br>  ;  ========================== operation mode check ==================== ======== <br>  modeCheck: <br>  sbis BUT, P;  P mode <br>  rjmp _P <br>  sbis BUT, CF;  ZK mode <br>  rjmp _setConst <br>  sbis BUT, CS;  COP mode <br>  rjmp _setSum <br>  sbis BUT, AM;  PM mode <br>  rjmp _setArray <br>  rjmp modeCheck <br><br>  _setConst: <br>  sbr mode, 1;  setting the sign of the LC mode <br>  ;  display mode information <br>  rcall _clear <br>  rcall _labelWrite;  write <br>  rcall _labelSpace;  _ <br>  rcall _labelConst;  const <br>  rcall _point ;. <br>  rcall _down <br>  rcall _labelAddr;  address <br>  rcall _labelOne;  one <br>  rcall _colon ;: <br>  rcall _labelZero;  0 <br>  rcall _cursor <br>  rjmp scan <br><br>  _setSum: <br>  sbr mode, 5;  setting the feature of the COP mode <br>  rcall _clear <br>  rcall _labelSum;  checksum <br>  rcall _down <br>  rcall _labelAddr;  address <br>  rcall _labelOne;  one <br>  rcall _colon ;: <br>  rcall _labelZero;  0 <br>  rcall _cursor <br>  rjmp scan <br><br>  _setArray: <br>  sbr mode, 9;  setting feature of PM mode <br>  rcall _clear <br>  rcall _mArray <br>  rcall _down <br>  rcall _labelAddr <br>  rcall _labelOne <br>  rcall _colon <br>  rcall _labelZero <br>  rcall _cursor <br>  rjmp scan <br><br>  _check :;  after entering the number - here <br>  sbrc mode, 0;  check mode <br>  rjmp _const;  if ZK, KS or PM, then here <br>  rjmp _view <br><br>  _P :;  P mode <br>  rcall _clear <br>  rcall _browse <br>  rcall _labelSpace <br>  rcall _labelZero <br>  rcall _cursor <br><br>  scan :;  poll matrix keyboard <br>  rcall _exit <br>  rcall _cursor <br>  matrix 0, 0b11101110, 0b11011110, 0b10111110, 0b01111110, 3, 7, 11, 15, next <br><br>  next: <br>  matrix 1, 0b11101101, 0b11011101, 0b10111101, 0b01111101, 2, 6, 10, 14, next1 <br><br>  next1: <br>  matrix 2, 0b11101011, 0b11011011, 0b10111011, 0b01111011, 1, 5, 9, 13, next2 <br><br>  next2: <br>  matrix 3, 0b11100111, 0b11010111, 0b10110111, 0b01110111, 0, 4, 8, 12, scan <br><br>  rjmp scan <br>  ;  ================================================= ======================== <br><br>  ; ========================== waiting to press the enter button =================== = <br>  _view: <br>  brts _input;  go to input if the T-flag is set (i.e. data entry mode) <br>  rcall _exit <br>  sbic BUT, enter;  if the enter button is not pressed, <br>  rjmp _view;  then we close the loop and wait for pressing the EXIT, reset or input buttons <br>  cpi count, 1;  comparison of the counter value: if 1, <br>  breq one;  the first digit is entered <br>  cpi count, 2;  if 2, <br>  breq two;  then the second is introduced <br>  cpi count, 3;  if 3, <br>  breq three;  then the last digit is entered <br>  rjmp _view <br><br>  ;  enter the first digit of the address <br>  one: <br>  mov xh, rKey <br>  inc count <br>  rjmp scan;  transition to survey mat.  clav <br><br>  ;  Enter the second digit of the address <br>  two: <br>  mov xl, rKey <br>  swap xl <br>  inc count <br>  rjmp scan <br><br>  ;  enter the third digit of the address <br>  three: <br>  rcall _noCursor;  the cursor is not needed <br>  add xl, rKey <br>  inc count <br>  rjmp finish;  after entering the third digit, go to finish <br>  ; ================================================ ================================= <br><br>  ; ================================== input mode ============= =================== <br>  _input: <br>  rcall _exit <br>  sbic BUT, enter;  if the input button is pressed, then jump over to compare the counter <br>  rjmp _input <br>  cpi count, 1;  if the counter is 1, then the first digit is entered <br>  breq first <br>  cpi count, 2;  if 2, then the second <br>  breq second <br>  rjmp _input <br><br>  first :;  input first digit <br>  mov buf, rKey <br>  swap buf <br>  inc count <br>  rjmp scan <br><br>  second :;  enter second digit <br>  rcall _noCursor <br>  add buf, rKey <br>  inc count <br>  rjmp _waitFor <br>  ; ================================================ ================================ <br><br>  ; ======================= waiting after entering the third digit ===================== = <br>  finish :;  go here after entering the third digit <br>  brts link;  if the T-flag is set, then this is the data entry mode, go to scan <br>  rcall _exit <br>  sbis BUT, exe;  EXIT button <br>  rjmp view;  go to view if exp. <br>  sbic BUT, space;  "_" button <br>  rjmp finish <br>  ldi count, 1;  reset the counter <br>  set;  set the T-flag in the status register <br>  ;  display ‚ÄúWRITE DATA‚Äù in the first line <br>  rcall _clear <br>  rcall _labelWrite <br>  rcall _labelSpace <br>  rcall _labelData <br>  ;  go to the second one <br>  rcall _down <br>  ;  set the cursor <br>  rcall _cursor <br>  rjmp finish <br>  link: <br>  rjmp scan <br>  ;  ================================================= ========================== <br><br>  ;  =============== viewing the contents of a cell (after clicking the EX button -&gt; here) <br>  view: <br>  ;  output of the inscription "BROWSE XXXX" <br>  rcall _clear <br>  rcall _browse;  Brose <br>  rcall _labelSpace;  _ <br>  mov rLCD, xh;  first XX <br>  rcall _charFromMemory <br>  mov rLCD, xl;  second XX <br>  rcall _charFromMemory <br>  ;  displaying the contents of a memory cell <br>  rcall _noCursor <br>  rcall _down <br>  ld rLCD, X + <br>  rcall _charFromMemory <br>  view1: <br>  rcall _exit <br>  ldi count, 1 <br>  sbic BUT, space;  if the "_" button is pressed, then go to the cell with the address 1 more <br>  rjmp view1 <br>  rcall _delay1 <br>  rjmp view <br>  ;  ================================================= =========================== <br><br>  ;  ========================= Writing a value to a memory cell ==================== === <br>  input: <br>  st X, buf <br>  clt;  clear T-flag after data entry mode is completed <br>  rjmp go <br>  ; ================================================ ================================= <br><br>  ;  ========== waiting for clicking EX.  or "_" to continue typing =============== <br>  _waitFor :;  after entering the second digit (data) - here <br>  sbrc mode, 0 <br>  rjmp _WC <br>  rcall _exit <br>  sbis BUT, exe;  if EXIT is pressed, then go to input <br>  rjmp input <br>  sbic BUT, space;  if "_" is pressed, <br>  rjmp _waitFor;  then jump over it, <br>  st X +, buf;  write the data entered into memory <br>  ldi count, 1;  reset the counter <br>  rcall _clear <br>  rcall _labelWrite <br>  rcall _labelSpace <br>  rcall _labelData <br>  rcall _down <br>  rjmp scan <br><br>  _WC: <br>  rcall _exit <br>  sbic BUT, exe <br>  rjmp _WC <br>  rjmp _execConst <br>  ;  ================================================= ============================ <br><br>  ;  =============================== LC mode (filling with a constant) ============= ===== <br>  _const: <br>  brts to_input <br>  rcall _exit <br>  sbic BUT, enter;  if the enter button is not pressed, <br>  rjmp _const;  then we close the loop and wait for pressing the EXIT, reset or input buttons <br>  cpi count, 1;  comparison of the counter value: if 1, <br>  breq _one;  the first digit is entered <br>  cpi count, 2;  if 2, <br>  breq _two;  then the second is introduced <br>  cpi count, 3;  if 3, <br>  breq _three;  then the last digit is entered <br>  rjmp _const;  in cycle <br>  to_input: <br>  rjmp _input <br><br>  ;  enter the first digit of the first address <br>  _one: <br>  sbrc mode, 4;  if the 2nd bit is set (sign of entering the third address), <br>  rjmp _ad31;  &lt;- move here <br>  sbrc mode, 1;  if the 1st bit in r19 is not set (sign of entering the second address), <br>  rjmp inpConst1;  then we skip it <br>  mov xh, rKey <br>  inc count <br>  rjmp scan <br>  ;  enter the first digit of the second address <br>  inpConst1: <br>  mov yh, rKey <br>  inc count <br>  rjmp scan <br><br>  ;  enter the second digit of the first address <br>  _two: <br>  sbrc mode, 4;  if the 2nd bit is set (sign of entering the third address), <br>  rjmp _ad32;  &lt;- move here <br>  sbrc mode, 1;  if the 1st bit is set in r19 (sign of entering the second address), <br>  rjmp inpConts2;  then go to inpConst1 <br>  mov xl, rKey <br>  swap xl <br>  inc count <br>  rjmp scan <br>  ;  enter the second digit of the second address <br>  inpConts2: <br>  mov yl, rKey <br>  swap yl <br>  inc count <br>  rjmp scan <br><br>  ;  enter the third digit of the first address <br>  _three: <br>  sbrc mode, 4;  if the 2nd bit is set (sign of entering the third address), <br>  rjmp _ad33;  &lt;- move here <br>  sbrc mode, 1 <br>  rjmp inpConst3 <br>  rcall _noCursor <br>  add xl, rKey;  rKey -&gt; to the junior tetra mla.  byte reg.  X pairs <br>  inc count <br>  rjmp constEnd;  after entering the third axis, go to constEnd <br>  ;  enter the third digit of the second address <br>  inpConst3: <br>  rcall _noCursor <br>  add yl, rKey <br>  inc count <br>  rjmp constEnd <br><br>  constEnd :;  go here after entering the third digit <br>  brts _link;  if the T-flag is set, then this is the data entry mode, go to scan <br>  sbrc mode, 1;  if the sign of entering the second address is set, <br>  rjmp _ad2;  then here <br>  sbrc mode, 2;  if the ‚ÄúCOP‚Äù feature is set, <br>  rjmp _ifCheckSum;  then here <br>  sbrc mode, 3;  if the sign of the PM mode is set, <br>  rjmp _ifArray;  then here <br>  rcall _exit <br>  sbic BUT, space;  if the "_" button is pressed, <br>  rjmp constEnd;  then jump over it, <br>  ldi count, 1;  reset the counter <br>  sbr mode, 3;  in r19 is now 0b00000011 (sign of entering the second address in the LC) <br>  ;  refining the screen content <br>  ; address2 <br>  rcall _down <br>  rcall _labelAddr <br>  rcall _labelTwo <br>  rcall _colon <br>  rcall _labelZero <br>  rcall _labelSpace <br>  rcall _labelSpace <br>  rcall _labelSpace <br>  rcall _left <br>  rcall _left <br>  rcall _left <br>  rjmp scan <br><br>  _ad2 :;  go here after entering the second address <br>  sbrc mode, 2;  if the sign of "COP" is set, then go <br>  rjmp _toCheckSum <br>  sbrc mode, 3;  if the sign "PM" is set, <br>  rjmp _toArray;  &lt;- here <br>  rcall _exit <br>  sbic BUT, space;  if the "_" button is pressed, <br>  rjmp _ad2;  then miss it <br>  ldi count, 1;  reset the counter <br>  set;  and set the sign of data entry <br>  ;  refining the screen content <br>  ;  const <br>  rcall _down <br>  rcall _labelConst <br>  rcall _colon <br>  rcall _labelSpace <br>  rcall _labelSpace <br>  rcall _labelSpace <br>  rcall _labelSpace <br>  rcall _labelSpace <br>  rcall _labelSpace <br>  rcall _labelSpace <br>  rcall _left <br>  rcall _left <br>  rcall _left <br>  rcall _left <br>  rcall _left <br>  rcall _left <br>  rcall _left <br>  rjmp constEnd;  -&gt; to cycle <br><br>  _link: <br>  rjmp scan <br><br>  _ifCheckSum :;  A branch from ‚Äú‚Äù to ‚Äú‚Äù, if the 2nd bit in mode is set <br>  sbic BUT, space <br>  rjmp _ifCheckSum <br>  ldi count, 1 <br>  ;  refining the screen contents: <br>  ;  address2 <br>  rcall _down <br>  rcall _labelAddr <br>  rcall _labelTwo <br>  rcall _colon <br>  rcall _labelZero <br>  rcall _labelSpace <br>  rcall _labelSpace <br>  rcall _labelSpace <br>  rcall _left <br>  rcall _left <br>  rcall _left <br>  sbr mode, 7;  sign of entering the second address "KS" <br>  rjmp scan <br><br>  _toCheckSum :;  on performance of "KS" <br>  rcall _exit <br>  sbic BUT, exe;  if ‚ÄúEX‚Äù is pressed, then go to ‚ÄúCOP‚Äù <br>  rjmp _toCheckSum <br>  ldi rKey, 0x00;  pre-zero the registers used <br>  ldi buf, 0x00 <br>  rjmp _SUM <br><br>  _ifArray :;  branch from "KS" to "PM" <br>  sbic BUT, space <br>  rjmp _ifArray <br>  ldi count, 1 <br>  ;  refining the screen content <br>  ; address2 <br>  rcall _down <br>  rcall _labelAddr <br>  rcall _labelTwo <br>  rcall _colon <br>  rcall _labelZero <br>  rcall _labelSpace <br>  rcall _labelSpace <br>  rcall _labelSpace <br>  rcall _left <br>  rcall _left <br>  rcall _left <br>  sbr mode, 11 <br>  rjmp scan <br><br>  _toArray :;  transition after entering the second address <br>  ldi count, 1 <br>  sbr mode, 27;  0b00011011 -&gt; r19 - sign of entering the third address <br>  rcall _exit <br>  sbic BUT, space <br>  rjmp _toArray <br>  ;  refining the screen content <br>  ;  address3 <br>  rcall _down <br>  rcall _labelAddr <br>  rcall _labelThree <br>  rcall _colon <br>  rcall _labelZero <br>  rcall _labelSpace <br>  rcall _labelSpace <br>  rcall _labelSpace <br>  rcall _left <br>  rcall _left <br>  rcall _left <br>  rjmp scan <br><br>  ;  first digit of the third address (PM) <br>  _ad31: <br>  mov zh, rKey <br>  inc count <br>  rjmp scan <br><br>  ;  second digit of the first address <br>  _ad32: <br>  mov zl, rKey <br>  swap zl <br>  inc count <br>  rjmp scan <br><br>  ;  third digit of the third address <br>  _ad33: <br>  rcall _noCursor <br>  add zl, rKey <br>  inc count <br>  rjmp _arrayEnd <br><br>  ;  waiting for pressing the VI after entering the third address <br>  _arrayEnd: <br>  rcall _exit <br>  sbic BUT, exe <br>  rjmp _arrayEnd <br>  ldi buf, 0x00;  pre-zeroing buf <br>  rjmp _execArray <br><br>  ;  ============================== ZK implementation ================= ================ <br>  _execConst: <br>  ;  first comparison <br>  _ccp1 :;  yh&gt; xh? <br>  cp yh, xh <br>  brlo _errConst;  if yh &lt;xh <br>  breq _eq1;  if yh = xh <br>  rjmp _ccp2 <br><br>  _eq1 :;  if yh = xh <br>  cp yl, xl;  yl&gt; xl? <br>  brlo _errConst;  if yl &lt;xl <br><br>  ;  if the first number is less than the second, <br>  ;  then go to the second comparison <br>  _ccp2 :;  if yh&gt; xh <br>  cp yh, xh;  yh&gt; xh? <br>  breq _ccp22;  if yh = xh <br>  st X +, buf <br>  rjmp _ccp2 <br><br>  _ccp22 :;  if yh = xh <br>  cp yl, xl;  yl&gt; xl? <br>  brlo _end;  if xl&gt; yl <br>  st X +, buf <br>  rjmp _ccp22 <br><br>  _errConst :;  ‚ÄúERROR‚Äù if the first number is more than the second <br>  rcall _clear <br>  rcall _labelWrite <br>  rcall _labelSpace <br>  rcall _labelConst <br>  rcall _point <br>  rcall _down <br>  rcall _noCursor <br>  rcall _labelErr <br>  rjmp _wait <br><br>  _end :;  output <br>  rjmp go <br><br>  ;  ============== calculation of the checksum of the array ======================= <br>  _SUM: <br>  ;  first comparison <br>  _scp1 :;  yh&gt; xh? <br>  cp yh, xh <br>  brlo _errSum;  if yh &lt;xh <br>  breq _eq2;  if yh = xh <br>  rjmp _scp2 <br><br>  _eq2 :;  if yh = xh <br>  cp yl, xl;  yl&gt; xl? <br>  brlo _errSum;  if yl &lt;xl <br><br>  ;  if the first number is less than the second, <br>  ;  then go to the second comparison <br>  _scp2 :;  if yh&gt; xh <br>  cp yh, xh;  yh&gt; xh? <br>  breq _scp22;  if yh = xh <br>  rcall _exCS <br>  brcs _overflow <br>  rjmp _scp2 <br><br>  _scp22 :;  if yh = xh <br>  cp yl, xl;  yl&gt; xl? <br>  brlo _showSum;  if xl&gt; yl <br>  rcall _exCS <br>  brcs _overflow <br>  rjmp _scp22 <br><br>  _showSum :;  display checksum <br>  rcall _clear <br>  rcall _labelSum <br>  rcall _down <br>  rcall _noCursor <br>  mov rLCD, rKey <br>  rcall _charFromMemory <br>  _wait: <br>  rcall _exit <br>  rjmp _wait <br><br>  _errSum :;  ‚ÄúERROR‚Äù if the first number is more than the second <br>  rcall _clear <br>  rcall _labelSum <br>  rcall _down <br>  rcall _noCursor <br>  rcall _labelErr <br>  rjmp _wait <br><br>  _overflow :;  when exceeding COP 255 - here <br>  ;  dumping of flags of transfer and half transfer (just in case) <br>  clh <br>  clc <br>  ldi rKey, 0xff;  if the COP is greater than 0xFF, then FF is displayed on the screen. <br>  rjmp _showSum <br><br>  _exCS :;  subroutine implementation of the COP <br>  ld buf, X + <br>  add rKey, buf <br>  ; rcall _cpixl <br>  ret <br><br>  ;  ============================ Array Motion ==================== =========== <br>  _execArray: <br>  ;  first comparison <br>  _acp1 :;  yh&gt; xh? <br>  cp yh, xh <br>  brlo _errArr;  if yh &lt;xh <br>  breq _eq3;  if yh = xh <br>  rjmp _acp2 <br><br>  _eq3 :;  if yh = xh <br>  cp yl, xl;  yl&gt; xl? <br>  brlo _errArr;  if yl &lt;xl <br><br>  ;  if the first number is less than the second, <br>  ;  then go to the second comparison <br>  _acp2 :;  if yh&gt; xh <br>  cp yh, xh;  yh&gt; xh? <br>  breq _acp22;  if yh = xh <br>  rcall _exMA <br>  rjmp _acp2 <br><br>  _acp22 :;  if yh = xh <br>  cp yl, xl;  yl&gt; xl? <br>  brlo _end;  if xl&gt; yl <br>  rcall _exMA <br>  rjmp _acp22 <br><br>  _errArr :;  ‚ÄúERROR‚Äù if the first number is more than the second <br>  rcall _clear <br>  rcall _mArray <br>  rcall _down <br>  rcall _noCursor <br>  rcall _labelErr <br>  rjmp _wait <br><br>  _exMA :;  subroutine execution PM <br>  ld rKey, X + <br>  st Z +, rKey <br>  ret <br>  ;  ================================================= ================= <br><br>  _exit: <br>  sbis BUT, quit;  if the exit button is pressed, <br>  rjmp go;  then exit from go mode <br>  ret <br>  ;  ================================================= ================== <br><br>  ;  work with the screen <br><br>  ;  LCD initialization <br>  altInit: <br>  rcall _delay1 <br>  ldi rLCD, config;  display setting: 8 bits, 2 lines, 5x8 <br>  rcall _cWrite <br><br>  rcall _delay1 <br>  ldi rLCD, on;  turn on the display <br>  rcall _cWrite <br><br>  rcall _delay1 <br>  ldi rLCD, clrSc;  screen cleaning <br>  rcall _cWrite <br><br>  rcall _delay1 <br>  ldi rLCD, incr;  increase of the address, the screen is static <br>  rcall _cWrite <br>  ret <br><br>  ;  busy bit check <br>  _BF: <br>  rcall _portIn;  input data port <br>  rcall _modeB;  command reading mode <br>  _loop: <br>  sbi _cpo, e <br>  rcall _delay <br>  cbi _cpo, e <br>  in r24, _dpi;  read data bus <br>  andi r24, 0x80;  check 7th bit <br>  brne _loop <br>  ret <br><br>  ;  delay <br>  _delay: <br>  ldi r23, 20 <br>  _del: <br>  dec r23 <br>  brne _del <br>  ret <br><br>  // more delay <br>  _delay1: <br>  ldi r24, 0xff; 255 <br>  _d: <br>  ldi r23, 0xff; 255 <br>  _cmp_d: <br>  dec r23 <br>  brne _cmp_d <br>  dec r24 <br>  brne _cmp_d <br>  ret <br><br>  ;  team record <br>  _cWrite: <br>  rcall _modeC <br>  rcall _portOut <br>  out _dpo, rLCD <br>  rcall _delay <br>  cbi _cpo, e <br>  ret <br><br>  ;  data record <br>  _dWrite: <br>  rcall _modeD <br>  rcall _portOut <br>  out _dpo, rLCD <br>  rcall _delay <br>  cbi _cpo, e <br>  ret <br><br>  ;  data output port <br>  _portOut: <br>  ldi r23, 0xff <br>  out _dp, r23 <br>  ret <br><br>  ;  data port input with a suspender <br>  _portIn: <br>  ldi r23, 0x00 <br>  out _dp, r23 <br>  ldi r23, 0xff <br>  out _dpo, r23 <br>  ret <br><br>  ;  command record mode <br>  _modeC: <br>  cbi _cpo, rw <br>  cbi _cpo, rs <br>  sbi _cpo, e <br>  ret <br><br>  ;  data recording mode <br>  _modeD: <br>  sbi _cpo, rs <br>  cbi _cpo, rw <br>  sbi _cpo, e <br>  ret <br><br>  ;  standby BF <br>  _modeB: <br>  sbi _cpo, rw;  reading <br>  cbi _cpo, rs;  teams <br>  ret <br><br>  ;  generation of character code when entering addresses and data <br>  _charInput: <br>  cpi rLCD, 0x0a;  compare with 10 <br>  brge _grt;  if more, then go to _grtA <br>  rcall _lstA <br>  rjmp _return <br>  _grt: <br>  rcall _grtA <br>  _return: <br>  ret <br><br>  _lstA: <br>  ldi r21, 0x30;  if less <br>  add rLCD, r21;  then add 48 <br>  rcall _dWrite;  write to LCD <br>  ret <br><br>  _grtA :;  if the number from A ... F <br>  ldi r21, 0x37;  55 - add to rLCD to get character code <br>  add rLCD, r21; <br>  rcall _dWrite;  write to LCD <br>  ret <br><br>  ;  character formation when reading from memory <br>  ;  works through rLCD <br>  _charFromMemory: <br>  push rLCD;  sent to the stack <br>  ;  high byte formation <br>  andi rLCD, 0xf0;  clear junior nibble <br>  swap rLCD;  swap nibbles <br>  rcall _BF <br>  rcall _charInput <br>  ;  high byte formation <br>  pop rLCD;  get out of the stack <br>  andi rLCD, 0x0f;  clear senior nibble <br>  rcall _BF <br>  rcall _charInput <br>  ret <br><br>  ;  ========================================== all sorts of inscriptions and screen settings === ============================ <br><br>  ;  "-" <br>  _none: <br>  ; rcall _up <br>  ldi rLCD, 0x2D <br>  rcall _BF <br>  rcall _dWrite <br>  ret <br><br>  ;  on the second line <br>  _down: <br>  ldi rLCD down <br>  rcall _BF <br>  rcall _cWrite <br>  ret <br><br>  ;  the inscription "BROWSE" <br>  _browse: <br>  ldi rLCD, 0x42;  B <br>  rcall _BF <br>  rcall _dWrite <br>  ldi rLCD, 0x52;  R <br>  rcall _BF <br>  rcall _dWrite <br>  ldi rLCD, 0x4f;  O <br>  rcall _BF <br>  rcall _dWrite <br>  ldi rLCD, 0x57;  W <br>  rcall _BF <br>  rcall _dWrite <br>  ldi rLCD, 0x53;  S <br>  rcall _BF <br>  rcall _dWrite <br>  ldi rLCD, 0x45;  E <br>  rcall _BF <br>  rcall _dWrite <br>  ret <br><br>  ;  the inscription "MOVE ARRAY" <br>  _mArray: <br>  ldi rLCD, 0x4d;  M <br>  rcall _BF <br>  rcall _dWrite <br>  ldi rLCD, 0x4f;  O <br>  rcall _BF <br>  rcall _dWrite <br>  ldi rLCD, 0x56;  V <br>  rcall _BF <br>  rcall _dWrite <br>  ldi rLCD, 0x45;  E <br>  rcall _BF <br>  rcall _dWrite <br>  rcall _labelSpace <br>  ldi rLCD, 0x41;  A <br>  rcall _BF <br>  rcall _dWrite <br>  ldi rLCD, 0x52;  R <br>  rcall _BF <br>  rcall _dWrite <br>  ldi rLCD, 0x52;  R <br>  rcall _BF <br>  rcall _dWrite <br>  ldi rLCD, 0x41;  A <br>  rcall _BF <br>  rcall _dWrite <br>  ldi rLCD, 0x59;  Y <br>  rcall _BF <br>  rcall _dWrite <br>  ret <br><br>  ;  the inscription "DATA" <br>  _labelData: <br>  ldi rLCD, 0x44;  D <br>  rcall _BF <br>  rcall _dWrite <br>  ldi rLCD, 0x41;  A <br>  rcall _BF <br>  rcall _dWrite <br>  ldi rLCD, 0x54;  T <br>  rcall _BF <br>  rcall _dWrite <br>  ldi rLCD, 0x41;  A <br>  rcall _BF <br>  rcall _dWrite <br>  ret <br><br>  ;  the inscription "WRITE" <br>  _labelWrite: <br>  ldi rLCD, 0x57;  W <br>  rcall _BF <br>  rcall _dWrite <br>  ldi rLCD, 0x52;  R <br>  rcall _BF <br>  rcall _dWrite <br>  ldi rLCD, 0x49;  I <br>  rcall _BF <br>  rcall _dWrite <br>  ldi rLCD, 0x54;  T <br>  rcall _BF <br>  rcall _dWrite <br>  ldi rLCD, 0x45;  E <br>  rcall _BF <br>  rcall _dWrite <br>  ret <br><br>  ;  the inscription "CONST" <br>  _labelConst: <br>  ldi rLCD, 0x43;  C <br>  rcall _BF <br>  rcall _dWrite <br>  ldi rLCD, 0x4f;  O <br>  rcall _BF <br>  rcall _dWrite <br>  ldi rLCD, 0x4e;  N <br>  rcall _BF <br>  rcall _dWrite <br>  ldi rLCD, 0x53;  S <br>  rcall _BF <br>  rcall _dWrite <br>  ldi rLCD, 0x54;  T <br>  rcall _BF <br>  rcall _dWrite <br>  ret <br><br>  ;  the inscription "ADDRESS" <br>  _labelAddr: <br>  ldi rLCD, 0x41;  A <br>  rcall _BF <br>  rcall _dWrite <br>  ldi rLCD, 0x44;  D <br>  rcall _BF <br>  rcall _dWrite <br>  ldi rLCD, 0x44;  D <br>  rcall _BF <br>  rcall _dWrite <br>  ldi rLCD, 0x52;  R <br>  rcall _BF <br>  rcall _dWrite <br>  ldi rLCD, 0x45;  E <br>  rcall _BF <br>  rcall _dWrite <br>  ldi rLCD, 0x53;  S <br>  rcall _BF <br>  rcall _dWrite <br>  ldi rLCD, 0x53;  S <br>  rcall _BF <br>  rcall _dWrite <br>  ret <br><br>  ;  the inscription "CHECKSUM" <br>  _labelSum: <br>  ldi rLCD, 0x43;  C <br>  rcall _BF <br>  rcall _dWrite <br>  ldi rLCD, 0x48;  H <br>  rcall _BF <br>  rcall _dWrite <br>  ldi rLCD, 0x45;  E <br>  rcall _BF <br>  rcall _dWrite <br>  ldi rLCD, 0x43;  C <br>  rcall _BF <br>  rcall _dWrite <br>  ldi rLCD, 0x4b;  K <br>  rcall _BF <br>  rcall _dWrite <br>  ldi rLCD, 0x53;  S <br>  rcall _BF <br>  rcall _dWrite <br>  ldi rLCD, 0x55;  U <br>  rcall _BF <br>  rcall _dWrite <br>  ldi rLCD, 0x4d;  M <br>  rcall _BF <br>  rcall _dWrite <br>  ret <br><br>  ;  the inscription "ERROR" <br>  _labelErr: <br>  ldi rLCD, 0x45;  E <br>  rcall _BF <br>  rcall _dWrite <br>  ldi rLCD, 0x52;  R <br>  rcall _BF <br>  rcall _dWrite <br>  ldi rLCD, 0x52;  R <br>  rcall _BF <br>  rcall _dWrite <br>  ldi rLCD, 0x4f;  O <br>  rcall _BF <br>  rcall _dWrite <br>  ldi rLCD, 0x52;  R <br>  rcall _BF <br>  rcall _dWrite <br>  ret <br><br>  ;  "0" <br>  _labelZero: <br>  ldi rLCD, 0x30 <br>  rcall _BF <br>  rcall _dWrite <br>  ret <br><br>  ;  "one" <br>  _labelOne: <br>  ldi rLCD, 0x31 <br>  rcall _BF <br>  rcall _dWrite <br>  ret <br><br>  ;  "2" <br>  _labelTwo: <br>  ldi rLCD, 0x32 <br>  rcall _BF <br>  rcall _dWrite <br>  ret <br><br>  ;  "3" <br>  _labelThree: <br>  ldi rLCD, 0x33 <br>  rcall _BF <br>  rcall _dWrite <br>  ret <br><br>  ;  space <br>  _labelSpace: <br>  ldi rLCD, 0x20 <br>  rcall _BF <br>  rcall _dWrite <br>  ret <br><br>  ;  clear both lines <br>  _clear: <br>  ldi rLCD, clrSc <br>  rcall _BF <br>  rcall _cWrite <br>  ret <br><br>  ;  cleaning the screen and displaying the "-" character <br>  _resetLCD: <br>  rcall _clear <br>  rcall _noCursor;  no cursor <br>  rcall _BF <br>  ; rcall _cWrite <br>  rcall _none <br>  ret <br><br>  ;  setting the flashing cursor <br>  _cursor: <br>  ldi rLCD, cursor <br>  rcall _BF <br>  rcall _cWrite <br>  ret <br><br>  ;  disable cursor <br>  _noCursor: <br>  ldi rLCD, noCursor <br>  rcall _BF <br>  rcall _cWrite <br>  ret <br><br>  ;  "." <br>  _point: <br>  ldi rLCD, 0x2e <br>  rcall _BF <br>  rcall _dWrite <br>  ret <br><br>  ;  ":" <br>  _colon: <br>  ldi rLCD, 0x3a <br>  rcall _BF <br>  rcall _dWrite <br>  ret <br><br>  ;  cursor right <br>  _right: <br>  ldi rLCD, right <br>  rcall _BF <br>  rcall _cWrite <br>  ret <br><br>  ;  left shift <br>  _left: <br>  ldi rLCD, left <br>  rcall _BF <br>  rcall _cWrite <br>  ret </div></div><br>  And this is a video that is used to modify and view the contents of a memory cell and the cells that follow it. <br><iframe width="560" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/MASR714qLJE%3Ffeature%3Doembed&amp;xid=17259,15700022,15700043,15700186,15700190,15700253,15700256,15700259&amp;usg=ALkJrhi7lvcugiZvBmgJ5WZsaOJUEI8eyw" frameborder="0" allowfullscreen=""></iframe></div><p>Source: <a href="https://habr.com/ru/post/262463/">https://habr.com/ru/post/262463/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../262455/index.html">Static analysis of the HPX library with PVS-Studio</a></li>
<li><a href="../262457/index.html">Programming Philosophy 7 - practicality</a></li>
<li><a href="../262459/index.html">Hackers got to the Patriot missiles?</a></li>
<li><a href="../26246/index.html">Facebook moves to open source platform</a></li>
<li><a href="../262461/index.html">Choice between C ++ and C #</a></li>
<li><a href="../262465/index.html">Integrating Jira and Slack for PHP</a></li>
<li><a href="../262467/index.html">Stop shot. Recorded and transmitted</a></li>
<li><a href="../262469/index.html">Do the opposite or portable channel for secure data transmission</a></li>
<li><a href="../26247/index.html">Error in the properties dialog</a></li>
<li><a href="../262471/index.html">High Level C or a couple of words about Cello</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>