<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Tuning Linux kernel parameters to optimize PostgreSQL</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="PostgreSQL‚Äôs optimal performance depends on well-defined operating system parameters. Poorly configured parameters of the OS kernel can lead to poor p...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Tuning Linux kernel parameters to optimize PostgreSQL</h1><div class="post__text post__text-html js-mediator-article"><img width="30%" align="left" src="https://habrastorage.org/webt/dy/qf/mh/dyqfmhq5wntmbisfsdahfiwc_-y.jpeg">  PostgreSQL‚Äôs optimal performance depends on well-defined operating system parameters.  Poorly configured parameters of the OS kernel can lead to poor performance of the database server.  Therefore, it is imperative that these parameters be configured in accordance with the database server and its workload.  In this post, we will discuss some important parameters of the Linux kernel that may affect the performance of the database server and how to tune them. <br><br><h2>  SHMMAX / SHMALL </h2><br>  <b>SHMMAX</b> is a kernel parameter used to determine the maximum size of a single shared memory segment that a Linux process can allocate.  Prior to version 9.2, PostgreSQL used System V (SysV), which requires SHMMAX configuration.  After 9.2, PostgreSQL switched to POSIX shared memory.  So now there are fewer bytes of System V shared memory. <br><br>  Prior to version 9.3, SHMMAX was the most important parameter of the kernel.  The SHMMAX value is specified in bytes. <br><a name="habracut"></a><br>  Similarly, <b>SHMALL</b> is another kernel parameter used to determine <br>  system-wide volume of shared memory pages.  To view the current SHMMAX, SHMALL, or SHMMIN values, use the <i>ipcs</i> command. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <sup><b>SHM * Details - Linux</b></sup> <br><br><pre><code class="bash hljs">$ ipcs -lm ------ Shared Memory Limits -------- max number of segments = 4096 max seg size (kbytes) = 1073741824 max total shared memory (kbytes) = 17179869184 min seg size (bytes) = 1</code> </pre> <br>  <sup><b>SHM * Details - MacOS X</b></sup> <br><br><pre> <code class="bash hljs">$ ipcs -M IPC status from as of Thu Aug 16 22:20:35 PKT 2018 shminfo: shmmax: 16777216 (max shared memory segment size) shmmin: 1 (min shared memory segment size) shmmni: 32 (max number of shared memory identifiers) shmseg: 8 (max shared memory segments per process) shmall: 1024 (max amount of shared memory <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> pages)</code> </pre><br>  PostgreSQL uses <b>System V IPC</b> to allocate shared memory.  This parameter is one of the most important kernel parameters.  Whenever you receive the following error messages, it means that you have an older version of PostgreSQL and you have a very low SHMMAX value.  Users are expected to adjust and increase the value according to the shared memory they are going to use. <br><br><h3>  Possible misconfiguration errors </h3><br>  If SHMMAX is configured incorrectly, you may get an error when trying to initialize a PostgreSQL cluster using the <i>initdb</i> command. <br><br>  <sup><b>initdb failure</b></sup> <br> <code>DETAIL: Failed system call was shmget(key=1, size=2072576, 03600). <br> <br> HINT: This error usually means that PostgreSQL's request for a shared memory segment exceeded your kernel's SHMMAX parameter. <br> You can either reduce the request size or reconfigure the kernel with larger SHMMAX. To reduce the request size (currently 2072576 bytes), <br> reduce PostgreSQL's shared memory usage, perhaps by reducing shared_buffers or max_connections. <br> <br> If the request size is already small, it's possible that it is less than your kernel's SHMMIN parameter, <br> in which case raising the request size or reconfiguring SHMMIN is called for. <br> <br> The PostgreSQL documentation contains more information about shared memory configuration. child process exited with exit code 1</code> <br> <br>  Similarly, you may get an error when starting the PostgreSQL server using the <i>pg_ctl</i> command. <br><br>  <sup><b>pg_ctl failure</b></sup> <br> <code>DETAIL: Failed system call was shmget(key=5432001, size=14385152, 03600). <br> <br> HINT: This error usually means that PostgreSQL's request for a shared memory segment exceeded your kernel's SHMMAX parameter. <br> <br> You can either reduce the request size or reconfigure the kernel with larger SHMMAX.; To reduce the request size (currently 14385152 bytes), reduce PostgreSQL's shared memory usage, perhaps by reducing shared_buffers or max_connections. <br> <br> If the request size is already small, it's possible that it is less than your kernel's SHMMIN parameter, <br> in which case raising the request size or reconfiguring SHMMIN is called for. <br> <br> The PostgreSQL documentation contains more information about shared memory configuration.</code> <br> <br><h3>  Understanding the Differences in Definitions </h3><br>  Defining SHMMAX / SHMALL parameters is slightly different in Linux and MacOS X: <br><br><ul><li>  Linux: kernel.shmmax, kernel.shmall </li><li>  MacOS X: kern.sysv.shmmax, kern.sysv.shmall </li></ul><br>  The <i>sysctl</i> command can be used to temporarily change a value.  To set constant values, add an entry to <i>/etc/sysctl.conf</i> .  Details are given below. <br><br>  <sup><b>Changing kernel options on MacOS X</b></sup> <br><br><pre> <code class="plaintext hljs"># Get the value of SHMMAX sudo sysctl kern.sysv.shmmax kern.sysv.shmmax: 4096 # Get the value of SHMALL sudo sysctl kern.sysv.shmall kern.sysv.shmall: 4096 # Set the value of SHMMAX sudo sysctl -w kern.sysv.shmmax=16777216 kern.sysv.shmmax: 4096 -&gt; 16777216 # Set the value of SHMALL sudo sysctl -w kern.sysv.shmall=16777216 kern.sysv.shmall: 4096 -&gt; 16777216</code> </pre> <br>  <sup><b>Changing kernel options on Linux</b></sup> <br><br><pre> <code class="plaintext hljs"># Get the value of SHMMAX sudo sysctl kernel.shmmax kernel.shmmax: 4096 # Get the value of SHMALL sudo sysctl kernel.shmall kernel.shmall: 4096 # Set the value of SHMMAX sudo sysctl -w kernel.shmmax=16777216 kernel.shmmax: 4096 -&gt; 16777216 # Set the value of SHMALL sudo sysctl -w kernel.shmall=16777216 kernel.shmall: 4096 -&gt; 16777216</code> </pre> <br>  <sub><b>Don't forget</b> : to make changes permanent, add these values ‚Äã‚Äãto <font color="blue">/etc/sysctl.conf</font></sub> <br><br><h2>  Huge Pages </h2><br>  Linux uses 4 KB of memory by default, BSD uses <i>Super Pages</i> , and Windows uses <i>Large Pages</i> .  A page is a part of RAM allocated to a process.  A process can have several pages depending on the memory requirements.  The more memory the process needs, the more pages are allocated to it.  The OS maintains a page allocation table for processes.  The smaller the page size, the larger the table, the longer it takes to search a page in this page table.  Therefore, large pages allow you to use a large amount of memory with reduced overhead costs;  fewer page views, fewer page errors, faster read / write operations through large buffers.  The result is improved performance. <br><br>  PostgreSQL only supports large Linux pages.  By default, Linux uses 4 KB of memory pages, so in cases where there are too many memory operations, you need to install larger pages.  There is a performance boost when using large pages of 2 MB and up to 1 GB.  Large page size can be set at load time.  You can easily check the parameters of a large page and their use on your Linux machine using the command <i>cat / proc / meminfo |</i>  <i>grep -i huge</i> . <br><br>  <sup><b>Getting information about large pages (only on Linux)</b></sup> <br><br><pre> <code class="bash hljs">Note: This is only <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> Linux, <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> other OS this operation is ignored$ cat /proc/meminfo | grep -i huge AnonHugePages:        0 kB ShmemHugePages:       0 kB HugePages_Total:      0 HugePages_Free:       0 HugePages_Rsvd:       0 HugePages_Surp:       0 Hugepagesize:      2048 kB</code> </pre> <br>  In this example, although the size of a large page is set to 2048 (2 MB), the total number of large pages is 0. This means that large pages are disabled. <br><br><h3>  The script determine the number of large pages </h3><br>  This simple script returns the required number of large pages.  Run the script on your Linux server while PostgreSQL is running.  Make sure that the PostgreSQL data directory is set for the <i>$ PGDATA</i> environment variable. <br><br>  <sup><b>Getting the numbers of the required large pages</b></sup> <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/bash pid=`head -1 $PGDATA/postmaster.pid` echo "Pid:           $pid" peak=`grep ^VmPeak /proc/$pid/status | awk '{ print $2 }'` echo "VmPeak:          $peak kB" hps=`grep ^Hugepagesize /proc/meminfo | awk '{ print $2 }'` echo "Hugepagesize:  $hps kB" hp=$((peak/hps)) echo Set Huge Pages:    $hp</span></span></code> </pre> <br>  The output of the script is as follows: <br><br>  <sup><b>Script output</b></sup> <br><br><pre> <code class="bash hljs">Pid:           12737 VmPeak:        180932 kB Hugepagesize:  2048 kB Set Huge Pages: 88</code> </pre> <br>  The recommended value for large pages is 88, so you should set the value to 88. <br><br>  <sup><b>Installing large pages</b></sup> <br><br><pre> <code class="bash hljs">sysctl -w vm.nr_hugepages=88</code> </pre> <br>  Check the big pages now, you will see that the big pages are not used (HugePages_Free = HugePages_Total). <br><br>  <sup><b>Big Pages Information again (on Linux only)</b></sup> <br><br><pre> <code class="bash hljs">$ cat /proc/meminfo | grep -i huge AnonHugePages:        0 kB ShmemHugePages:       0 kB HugePages_Total:     88 HugePages_Free:      88 HugePages_Rsvd:       0 HugePages_Surp:       0 Hugepagesize:      2048 kB</code> </pre> <br>  Now set the huge_pages "on" parameter in $ PGDATA / postgresql.conf and restart the server. <br><br>  <sup><b>And again the information on large pages (only on Linux)</b></sup> <br><br><pre> <code class="bash hljs">$ cat /proc/meminfo | grep -i huge AnonHugePages:        0 kB ShmemHugePages:       0 kB HugePages_Total:     88 HugePages_Free:      81 HugePages_Rsvd:       64 HugePages_Surp:       0 Hugepagesize:      2048 kB</code> </pre> <br>  Now you can see that very few large pages are used.  Let's now try to add some data to the database. <br><br>  <sup><b>Some database operations for large page utilization</b></sup> <br><br><pre> <code class="sql hljs">postgres=<span class="hljs-comment"><span class="hljs-comment"># CREATE TABLE foo(a INTEGER); CREATE TABLE postgres=# INSERT INTO foo VALUES(generate_Series(1,10000000)); INSERT 0 10000000</span></span></code> </pre> <br>  Let's see if we use more large pages now than before. <br><br>  <sup><b>Once again information about large pages (only on Linux)</b></sup> <br><br><pre> <code class="bash hljs">$ cat /proc/meminfo | grep -i huge AnonHugePages:        0 kB ShmemHugePages:       0 kB HugePages_Total:     88 HugePages_Free:      18 HugePages_Rsvd:       1 HugePages_Surp:       0 Hugepagesize:      2048 kB</code> </pre> <br>  Now you can see most of the big pages being used. <br><br>  <sub>Note: The approximate value for HugePages used here is very low, which is not a normal value for a machine in a grocery environment.</sub>  <sub>Please estimate the required number of pages for your system and set them accordingly depending on the load and resources.</sub> <br><br><h3>  vm.swappiness </h3><br>  <b>vm.swappiness</b> is another kernel parameter that can affect database performance.  This parameter is used to control swapiness (paging into and out of memory) in Linux.  The value ranges from 0 to 100. It determines how much memory will be unloaded or unloaded.  Zero means disabling the exchange, and 100 means aggressive exchange. <br><br>  You can get good performance by setting lower values. <br><br>  Setting the value to 0 in newer kernels may result in the OOM Killer (Linux memory cleaning process) killing the process.  Thus, it is safe to set the value to 1 if you want to minimize paging.  The default value in Linux is 60. A higher value causes the MMU (memory management unit) to use more paging space than RAM, while a lower value stores more data / code in memory. <br><br>  Smaller value is a good bet on performance improvements in PostgreSQL. <br><br><h3>  vm.overcommit_memory / vm.overcommit_ratio </h3><br>  Applications receive memory and free it when it is no longer needed.  But in some cases, the application gets too much memory and does not free it.  This may cause an OOM killer.  Here are the possible values ‚Äã‚Äãfor the <b>vm.overcommit_memory</b> parameter with a description for each: <br><br><ol><li>  Heuristic overcommit (default);  core based heuristics </li><li>  Allow overcommit anyway </li><li>  Do not overdo it, do not exceed the overcommit coefficient. </li></ol><br>  <i>Link: <a href="https://www.kernel.org/doc/Documentation/vm/overcommit-accounting">https://www.kernel.org/doc/Documentation/vm/overcommit-accounting</a></i> <br><br>  <b>vm.overcommit_ratio</b> - the percentage of RAM that is available for excessive loading.  A value of 50% in a system with 2 GB of RAM can allocate up to 3 GB of RAM. <br><br>  A value of 2 for vm.overcommit_memory provides better performance for PostgreSQL.  This value maximizes the use of RAM by the server process without any significant risk of being killed by the OOM killer process.  The application will be able to reboot, but only within the overrun, which reduces the risk that the OOM killer will kill the process.  Therefore, a value of 2 gives a better performance than the default value of 0. However, reliability can be improved due to the fact that the memory outside the acceptable range will not be overloaded.  This eliminates the risk that the process will be killed by the OOM-killer. <br><br>  On systems without swapping, there may be a problem with vm.overcommit_memory equal to 2. <br><br>  <a href="https://www.postgresql.org/docs/current/static/kernel-resources.html">https://www.postgresql.org/docs/current/static/kernel-resources.html#LINUX-MEMORY-OVERCOMMIT</a> <br><br><h3>  vm.dirty_background_ratio / vm.dirty_background_bytes </h3><br>  <b>vm.dirty_background_ratio</b> is the percentage of memory that is full of dirty pages that need to be written to disk.  The flush to disk is performed in the background.  The value of this parameter ranges from 0 to 100;  however, a value below 5 may be inefficient and some kernels do not support it.  10 is the default on most Linux systems.  You can improve performance for intensive write operations with a lower factor, which would mean that Linux will dump dirty pages in the background. <br><br>  You need to set the value of <b>vm.dirty_background_bytes</b> depending on the speed of your disk. <br><br>  There are no ‚Äúgood‚Äù values ‚Äã‚Äãfor these two parameters, since both depend on the hardware.  However, setting vm.dirty_background_ratio to 5 and vm.dirty_background_bytes at 25% of the disk speed improves performance up to ~ 25% in most cases. <br><br><h3>  vm.dirty_ratio / dirty_bytes </h3><br>  This is the same as <b>vm.dirty_background_ratio / dirty_background_bytes</b> , except that the reset is performed in a working session, blocking the application.  Therefore, vm.dirty_ratio should be higher than <b>vm.dirty_background_ratio</b> .  This ensures that background processes run earlier to avoid blocking the application as much as possible.  You can adjust the difference between these two ratios depending on the disk I / O load. <br><br><h2>  Total </h2><br>  You can adjust other parameters to increase performance, but the improvements will be minimal and you will not get much benefit.  We must remember that not all parameters apply to all types of applications.  Some applications work better when we configure some settings, and some do not.  You must find the right balance between the configurations of these parameters for the expected workload and type of application, as well as the configuration of the operating system.  Configuring kernel parameters is not as easy as setting database parameters: it‚Äôs more difficult to make recommendations here. </div><p>Source: <a href="https://habr.com/ru/post/458860/">https://habr.com/ru/post/458860/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../458848/index.html">Release Rust 1.36.0: Trey Future, stabilization alloc and MaybeUninit <T></a></li>
<li><a href="../45885/index.html">when will they collide?</a></li>
<li><a href="../458850/index.html">We learn English cheaply and effectively. Part 2</a></li>
<li><a href="../458854/index.html">MotionLayout: better animations, less code</a></li>
<li><a href="../458856/index.html">Cheap and expensive AAA batteries</a></li>
<li><a href="../458864/index.html">Competition developers bot for TamTam</a></li>
<li><a href="../458868/index.html">Noise in big data. Entropy-based analysis</a></li>
<li><a href="../458874/index.html">ASO Checklist: Text Optimization</a></li>
<li><a href="../458876/index.html">Friday Mini CTF</a></li>
<li><a href="../458878/index.html">What is GitOps?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>