<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Immersed boundary method for teapots</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The relationship between ‚Äúpure‚Äù and ‚Äúapplied mathematicians‚Äù is based on trust and understanding. ‚ÄúPure mathematicians‚Äù do not trust ‚Äúapplied mathemat...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Immersed boundary method for teapots</h1><div class="post__text post__text-html js-mediator-article"><blockquote>  The relationship between ‚Äúpure‚Äù and ‚Äúapplied mathematicians‚Äù is based on trust and understanding.  ‚ÄúPure mathematicians‚Äù do not trust ‚Äúapplied mathematicians,‚Äù and ‚Äúapplied mathematicians‚Äù do not understand pure mathematicians. <br></blockquote><br><br>  Some time ago I was faced with the fact that I could not find available materials in which the immersed boundary method would be described on a great and powerful one.  In short, this is a computational fluid dynamics method that allows calculating the flow around objects that are rather complex in shape and dynamics.  So, Russian-language publications on this topic were extremely insufficient.  "It does not matter, we will read the work of foreign colleagues" - I thought.  But even here a small trick was waiting - all the available materials and publications on this method were very theoretical, but for me (not sure, perhaps this is not only my feature) it is usually difficult to make the transition from theoretical calculations to a more or less working embodiment in code.  Therefore, for the same unfortunate as I (and with some hope of advice from experienced personalities), I decided to make a brief description of this method and offer the easiest way to implement it. <br><a name="habracut"></a><br>  I will consider only the original Peskin method, since  in my opinion, it is simpler than the method of fictitious cells (ghost-cells), the method of truncated cells (cut-cells) and all their other modifications. <br><br>  So, Wikipedia tells us that the immersed boundary method is an approach to modeling the interaction between a fluid and a streamlined object (as it is often used to model thin fibers in biological systems, sometimes the term fiber is used). ).  And that's damn true =) <br>  The main feature of this approach is that two separate grids are introduced for calculating fluid flow (in Eulerian coordinates) and for calculating the parameters of the submerged boundary (of the same fiber fibers in Lagrangian coordinates).  This makes it possible to use simple grids and fast computational methods for calculating fluids, transferring all the complexity of modeling to the stage of interaction with a submerged boundary. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      From a purely theoretical point of view, such a focus is done by adding to the Navier-Stokes equation the force of the action of the immersed boundary on the liquid (more precisely, the density of the force): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8db/0c0/0d0/8db0c00d0dadc420ae6fa3fd8785fef4.gif" title="\ rho (\ frac {\ partial u} {\ partial t} + (u \ cdot \ nabla) u) + \ nabla p = \ nu \ triangle u + f"><br><br>  This power is calculated in some way based on the location of the calculated points of the immersed boundary, and changes the flow.  The complete system of equations looks like this: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8db/0c0/0d0/8db0c00d0dadc420ae6fa3fd8785fef4.gif" title="\ rho (\ frac {\ partial u} {\ partial t} + (u \ cdot \ nabla) u) + \ nabla p = \ nu \ triangle u + f"><br><img src="https://habrastorage.org/getpro/habr/post_images/4c5/cfb/32f/4c5cfb32f2dc8b778dbbad192c4bbbb4.gif" title="\ nabla u = 0"><br><img src="https://habrastorage.org/getpro/habr/post_images/d70/948/059/d70948059d7a00675ffb54df9ed53840.gif" title="f (x, t) = \ int_ \ Omega F (q, r, s, t) \ delta (x-X (q, r, s, t)) \; dq \; dr \; ds"><br><img src="https://habrastorage.org/getpro/habr/post_images/e33/b90/e31/e33b90e31545b6dee574b668e75a3445.gif" title="\ frac {\ partial X} {\ partial t} (q, r, s, t) = \ int_U u (x, t) \ delta (x-X (q, r, s, t)) \; dx"><br><br>  with boundary conditions on the immersed boundary, for example, of this type (aka ‚Äúno-slip condition‚Äù sticking condition): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5d9/4c9/7e7/5d94c97e7e712550fa031bf7cbcd926e.gif" title="\ frac {\ partial X} {\ partial t} (q, r, s, t) = u (X (q, r, s, t), t)"><br><br>  In this system of equations <img src="https://habrastorage.org/getpro/habr/post_images/fd6/7f5/faf/fd67f5fafecc06d9919e249f77798b5b.gif" title="f, \; u, \; x">  - there are variables that describe the flow of a fluid in a region <img src="https://habrastorage.org/getpro/habr/post_images/d33/cd4/3ee/d33cd43ee0324d4dc099c1ba4272366f.gif" title="U">  with coordinates <img src="https://habrastorage.org/getpro/habr/post_images/ace/984/048/ace984048983300d3a450e3276a143c2.gif" title="(x, y, z) \ in U">  , but <img src="https://habrastorage.org/getpro/habr/post_images/f0a/9e2/e0c/f0a9e2e0c63aa351305ded4ab02558ef.gif" title="F, \; U">  - variables that describe the state of the immersed boundary in the region <img src="https://habrastorage.org/getpro/habr/post_images/4bf/9bd/de5/4bf9bdde5fb2149b08ff31ddac941a59.gif" title="\ Omega">  with coordinates <img src="https://habrastorage.org/getpro/habr/post_images/fe8/c30/62f/fe8c3062f578b9269fad7fc09475cb1a.gif" title="(q, r, s) \ in \ Omega">  . <br><br>  Actually, the interaction of fluid and boundaries is hidden in the last two equations. <br><br>  If we consider all this disgrace from the point of view of implementation, then the algorithm for each time step will be approximately as follows: <br><ul><li>  At each point of the immersed boundary, we calculate the stress force, based on its current state. </li><li>  According to some algorithm, we distribute the obtained force on liquid points. </li><li>  Calculate the parameters of fluid flow, taking into account the force </li><li>  We interpolate the velocity from the points of the fluid to the nodes of the immersed boundary (due to the boundary conditions, the velocity of the boundary must coincide with the velocity of the fluid) </li><li>  Change the position of the border nodes in accordance with the speed </li></ul><br>  As you can see, there are two uncertain points in the algorithm - nothing is said about how to determine the strength of the voltage, as well as how to calculate the parameters of fluid flow.  This is a serious plus of this approach - these methods can be practically any =) But to be closer to implementation, I will at least have to talk about how to calculate the voltage at the boundary (the second method can be chosen arbitrarily, if only was accurate enough). <br><br>  In fact, tough guys find the force that forms at the boundary using the energy functional and take into account the tensile force and the bending force.  But to my regret, I myself have not yet completely figured out this moment.  Therefore, you can cheat and use a less accurate, but sufficient for the calculation method of penalties (penalty method).  Its essence is simple - the further the border deviates from its original position, the more the emerging force.  As a result, it is only necessary to calculate the deviation and multiply it by a certain stiffness coefficient, with which it is possible to measure. <br><br>  The second fine point in the algorithm is the delta function, which figured in the system of equations.  We need to have its numerical version and, in an amicable way, this is a whole song, because  options for its discretization huge cloud.  But in this case, you can rely on the experience of colleagues who advise to use this (for the three-dimensional case is similar): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d9f/901/0fd/d9f9010fd5211312370d050d21de3404.gif" title="D_ {ij} (\ bm x) = d (x-ih) (y-jh)"><br><img src="https://habrastorage.org/getpro/habr/post_images/6b0/51d/cb6/6b051dcb64be9504418d36b309353134.gif" title="d (r) = \ frac {1} {4h} (1 + cos (\ frac {\ pi r} {2h})), \; \ | r \ | <2h"><br><img src="https://habrastorage.org/getpro/habr/post_images/11f/581/2f8/11f5812f894f38bdc3544f4c216e7aeb.gif" title="d (r) = 0, \; \ | r \ | \ geq 2h"><br><br>  Now, instead of a thousand words, you can describe the resulting algorithm as a code. <br><br>  The calculation of the voltage on the nodes may look like this: <br><br><pre><code class="hljs erlang-repl">for(int n = <span class="hljs-number"><span class="hljs-number">0</span></span>; n &lt; boundary-&gt;nodes_count; ++n) { Node *node = &amp;boundary-&gt;nodes[n]; // get_area   ,      node-&gt;x_force = -boundary-&gt;stiffness * (node-&gt;x - node-&gt;x_ref) * boundary-&gt;get_area(); node-&gt;y_force = -boundary-&gt;stiffness * (node-&gt;y - node-&gt;y_ref) * boundary-&gt;get_area(); node-&gt;z_force = -boundary-&gt;stiffness * (node-&gt;z - node-&gt;z_ref) * boundary-&gt;get_area(); }</code> </pre> <br>  The distribution of force on a fluid point: <br><br><pre> <code class="hljs markdown"> for(int n = 0; n <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">boundary-</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span>nodes<span class="hljs-emphasis"><span class="hljs-emphasis">_count; ++n) { //         int x_</span></span>int = index(boundary-&gt;nodes[<span class="hljs-string"><span class="hljs-string">n</span></span>].x, COORD<span class="hljs-emphasis"><span class="hljs-emphasis">_X); int y_</span></span>int = index(boundary-&gt;nodes[<span class="hljs-string"><span class="hljs-string">n</span></span>].y, COORD<span class="hljs-emphasis"><span class="hljs-emphasis">_Y); int z_</span></span>int = index(boundary-&gt;nodes[<span class="hljs-string"><span class="hljs-string">n</span></span>].z, COORD<span class="hljs-emphasis"><span class="hljs-emphasis">_Z); // ..    -    , //       ,     //   (    )   for(int i = x_</span></span>int-1; i <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">=</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">x_int</span></span></span></span><span class="xml"><span class="hljs-tag"> + </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">2</span></span></span></span><span class="xml"><span class="hljs-tag">; ++</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">i</span></span></span></span><span class="xml"><span class="hljs-tag">) { </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">for</span></span></span></span><span class="xml"><span class="hljs-tag">(</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">int</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">j</span></span></span></span><span class="xml"><span class="hljs-tag"> = </span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">y_int-1;</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">j</span></span></span></span><span class="xml"><span class="hljs-tag"> &lt;= </span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">y_int</span></span></span></span><span class="xml"><span class="hljs-tag"> + </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">2</span></span></span></span><span class="xml"><span class="hljs-tag">; ++</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">j</span></span></span></span><span class="xml"><span class="hljs-tag">) { </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">for</span></span></span></span><span class="xml"><span class="hljs-tag">(</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">int</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">k</span></span></span></span><span class="xml"><span class="hljs-tag"> = </span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">z_int-1;</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">k</span></span></span></span><span class="xml"><span class="hljs-tag"> &lt;= </span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">z_int</span></span></span></span><span class="xml"><span class="hljs-tag"> + </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">2</span></span></span></span><span class="xml"><span class="hljs-tag">; ++</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">k</span></span></span></span><span class="xml"><span class="hljs-tag">) { //          </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">long</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">double</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">dist_x</span></span></span></span><span class="xml"><span class="hljs-tag"> = </span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">fabs(boundary-</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span>nodes[<span class="hljs-string"><span class="hljs-string">n</span></span>].x - coord(i, COORD<span class="hljs-emphasis"><span class="hljs-emphasis">_X)); long double dist_</span></span>y = fabs(boundary-&gt;nodes[<span class="hljs-string"><span class="hljs-string">n</span></span>].y - coord(j, COORD<span class="hljs-emphasis"><span class="hljs-emphasis">_Y)); long double dist_</span></span>z = fabs(boundary-&gt;nodes[<span class="hljs-string"><span class="hljs-string">n</span></span>].z - coord(k, COORD<span class="hljs-emphasis"><span class="hljs-emphasis">_Z)); long double weight_</span></span>x = delta(dist<span class="hljs-emphasis"><span class="hljs-emphasis">_x, COORD_</span></span>X); long double weight<span class="hljs-emphasis"><span class="hljs-emphasis">_y = delta(dist_</span></span>y, COORD<span class="hljs-emphasis"><span class="hljs-emphasis">_Y); long double weight_</span></span>z = delta(dist<span class="hljs-emphasis"><span class="hljs-emphasis">_z, COORD_</span></span>Z); //        force<span class="hljs-emphasis"><span class="hljs-emphasis">_X[i][j][k] += (boundary-&gt;nodes[n].x_</span></span>force <span class="hljs-bullet"><span class="hljs-bullet">* weight_x *</span></span> weight<span class="hljs-emphasis"><span class="hljs-emphasis">_y * weight_</span></span>z) <span class="hljs-bullet"><span class="hljs-bullet">* boundary-&gt;get_area(); force_Y[i][j][k] += (boundary-&gt;nodes[n].y_force *</span></span> weight<span class="hljs-emphasis"><span class="hljs-emphasis">_x * weight_</span></span>y <span class="hljs-bullet"><span class="hljs-bullet">* weight_z) *</span></span> boundary-&gt;get<span class="hljs-emphasis"><span class="hljs-emphasis">_area(); force_</span></span>Z[<span class="hljs-string"><span class="hljs-string">i</span></span>][<span class="hljs-symbol"><span class="hljs-symbol">j</span></span>][<span class="hljs-string"><span class="hljs-string">k</span></span>] += (boundary-&gt;nodes[n].z<span class="hljs-emphasis"><span class="hljs-emphasis">_force * weight_</span></span>x <span class="hljs-bullet"><span class="hljs-bullet">* weight_y *</span></span> weight<span class="hljs-emphasis"><span class="hljs-emphasis">_z) * boundary-&gt;get_</span></span>area(); } } }</code> </pre><br>  By any suitable method, we calculate the flow.  Then we interpolate the speed on the fluid nodes: <br><br><pre> <code class="hljs markdown"> for(int n = 0; n <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">boundary-</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span>nodes<span class="hljs-emphasis"><span class="hljs-emphasis">_count; ++n) { //    ,    int x_</span></span>int = index(boundary-&gt;nodes[<span class="hljs-string"><span class="hljs-string">n</span></span>].x, COORD<span class="hljs-emphasis"><span class="hljs-emphasis">_X); int y_</span></span>int = index(boundary-&gt;nodes[<span class="hljs-string"><span class="hljs-string">n</span></span>].y, COORD<span class="hljs-emphasis"><span class="hljs-emphasis">_Y); int z_</span></span>int = index(boundary-&gt;nodes[<span class="hljs-string"><span class="hljs-string">n</span></span>].z, COORD<span class="hljs-emphasis"><span class="hljs-emphasis">_Z); //       for(int i = x_</span></span>int-1; i <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">=</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">x_int</span></span></span></span><span class="xml"><span class="hljs-tag"> + </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">2</span></span></span></span><span class="xml"><span class="hljs-tag">; ++</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">i</span></span></span></span><span class="xml"><span class="hljs-tag">) { </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">for</span></span></span></span><span class="xml"><span class="hljs-tag">(</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">int</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">j</span></span></span></span><span class="xml"><span class="hljs-tag"> = </span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">y_int-1;</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">j</span></span></span></span><span class="xml"><span class="hljs-tag"> &lt;= </span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">y_int</span></span></span></span><span class="xml"><span class="hljs-tag"> + </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">2</span></span></span></span><span class="xml"><span class="hljs-tag">; ++</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">j</span></span></span></span><span class="xml"><span class="hljs-tag">) { </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">for</span></span></span></span><span class="xml"><span class="hljs-tag">(</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">int</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">k</span></span></span></span><span class="xml"><span class="hljs-tag"> = </span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">z_int-1;</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">k</span></span></span></span><span class="xml"><span class="hljs-tag"> &lt;= </span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">z_int</span></span></span></span><span class="xml"><span class="hljs-tag"> + </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">2</span></span></span></span><span class="xml"><span class="hljs-tag">; ++</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">k</span></span></span></span><span class="xml"><span class="hljs-tag">) { </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">long</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">double</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">dist_x</span></span></span></span><span class="xml"><span class="hljs-tag"> = </span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">fabs(boundary-</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span>nodes[<span class="hljs-string"><span class="hljs-string">n</span></span>].x - coord(i, COORD<span class="hljs-emphasis"><span class="hljs-emphasis">_X)); long double dist_</span></span>y = fabs(boundary-&gt;nodes[<span class="hljs-string"><span class="hljs-string">n</span></span>].y - coord(j, COORD<span class="hljs-emphasis"><span class="hljs-emphasis">_Y)); long double dist_</span></span>z = fabs(boundary-&gt;nodes[<span class="hljs-string"><span class="hljs-string">n</span></span>].z - coord(k, COORD<span class="hljs-emphasis"><span class="hljs-emphasis">_Z)); long double weight_</span></span>x = delta(dist<span class="hljs-emphasis"><span class="hljs-emphasis">_x, COORD_</span></span>X); long double weight<span class="hljs-emphasis"><span class="hljs-emphasis">_y = delta(dist_</span></span>y, COORD<span class="hljs-emphasis"><span class="hljs-emphasis">_Y); long double weight_</span></span>z = delta(dist<span class="hljs-emphasis"><span class="hljs-emphasis">_z, COORD_</span></span>Z); boundary-&gt;nodes[<span class="hljs-string"><span class="hljs-string">n</span></span>].x<span class="hljs-emphasis"><span class="hljs-emphasis">_vel += (velocity_</span></span>U[<span class="hljs-string"><span class="hljs-string">i</span></span>][<span class="hljs-symbol"><span class="hljs-symbol">j</span></span>][<span class="hljs-string"><span class="hljs-string">k</span></span>] <span class="hljs-bullet"><span class="hljs-bullet">* weight_x *</span></span> weight<span class="hljs-emphasis"><span class="hljs-emphasis">_y * weight_</span></span>z) <span class="hljs-bullet"><span class="hljs-bullet">* CB(Hx[i]); boundary-&gt;nodes[n].y_vel += (velocity_V[i][j][k] *</span></span> weight<span class="hljs-emphasis"><span class="hljs-emphasis">_x * weight_</span></span>y <span class="hljs-bullet"><span class="hljs-bullet">* weight_z) *</span></span> CB(Hy[<span class="hljs-string"><span class="hljs-string">j</span></span>]); boundary-&gt;nodes[<span class="hljs-string"><span class="hljs-string">n</span></span>].z<span class="hljs-emphasis"><span class="hljs-emphasis">_vel += (velocity_</span></span>W[<span class="hljs-string"><span class="hljs-string">i</span></span>][<span class="hljs-symbol"><span class="hljs-symbol">j</span></span>][<span class="hljs-string"><span class="hljs-string">k</span></span>] <span class="hljs-bullet"><span class="hljs-bullet">* weight_x *</span></span> weight<span class="hljs-emphasis"><span class="hljs-emphasis">_y * weight_</span></span>z) * CB(Hz[k]); } } } }</code> </pre><br>  Update the coordinates of the nodes of the submerged boundary: <br><br><pre> <code class="hljs mel"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n = <span class="hljs-number"><span class="hljs-number">0</span></span>; n &lt; <span class="hljs-keyword"><span class="hljs-keyword">boundary</span></span>-&gt;nodes_count; ++n) { <span class="hljs-keyword"><span class="hljs-keyword">boundary</span></span>-&gt;nodes[n].x += <span class="hljs-keyword"><span class="hljs-keyword">boundary</span></span>-&gt;nodes[n].x_vel; <span class="hljs-keyword"><span class="hljs-keyword">boundary</span></span>-&gt;nodes[n].y += <span class="hljs-keyword"><span class="hljs-keyword">boundary</span></span>-&gt;nodes[n].y_vel; <span class="hljs-keyword"><span class="hljs-keyword">boundary</span></span>-&gt;nodes[n].z += <span class="hljs-keyword"><span class="hljs-keyword">boundary</span></span>-&gt;nodes[n].z_vel; }</code> </pre><br><br>  Actually, everything.  In this approach, it is assumed that the border is flexible, but with a sufficiently high rigidity (it really should be huge, consider in experiments), you can simulate the behavior of a solid border. <br>  I note that at the moment for the calculation of fluid flow, I use the method of incomplete approximation of the minimum residuals, as well as approaching the original non-stationary problem with a series of stationary calculations.  This, of course, is not the best option, and it is not worth doing so - but nevertheless it works. <br><br>  Everything, I give this text to be torn apart.  All rationalization notes and suggestions are accepted, because  work is still very far from ideal. <br>  For a snack, a few pictures with a wrap around a sphere with a fairly high viscosity (and on a rather coarse grid). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/152/e5f/b29/152e5fb29b9761cbbc0b21bd1715cfda.png"><br><img src="https://habrastorage.org/getpro/habr/post_images/d14/39c/ff6/d1439cff6d04154e26ab0a7dc719bfea.png"></div><p>Source: <a href="https://habr.com/ru/post/210276/">https://habr.com/ru/post/210276/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../210264/index.html">CMS development practice</a></li>
<li><a href="../210266/index.html">COOLRF: Pricing and Investments</a></li>
<li><a href="../210268/index.html">KolibriOS Digest # 1: getting up to date</a></li>
<li><a href="../210270/index.html">Optimization of processing complex selectors</a></li>
<li><a href="../210272/index.html">Cataloging and reserving personal photo archives</a></li>
<li><a href="../210278/index.html">$ 99,000 NES Cartridge on eBay</a></li>
<li><a href="../210280/index.html">Great Permutator - the experience of participating in bundles and not only</a></li>
<li><a href="../210282/index.html">Microsoft revenues hit record highs</a></li>
<li><a href="../210284/index.html">13 hacks for your Nokia Lumia</a></li>
<li><a href="../210286/index.html">Spatio-temporal image processing on GPU</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>