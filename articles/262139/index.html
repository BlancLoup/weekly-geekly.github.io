<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Stream API: universal intermediate operation</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I am developing the free library StreamEx , which extends the standard Java 8 Stream API, adding new operations, collectors and sources of streams the...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Stream API: universal intermediate operation</h1><div class="post__text post__text-html js-mediator-article">  I am developing the free library <a href="https://github.com/amaembo/streamex">StreamEx</a> , which extends the standard Java 8 Stream API, adding new operations, collectors and sources of streams there.  Usually I do not add everything, but comprehensively consider every potential feature.  For example, when adding a new intermediate ( <a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html">intermediate</a> ) operation, these questions arise: <br><br><ol><li>  Will it really be intermediate, that is, it will not touch the source until the terminal operation is performed? </li><li>  Will it be lazy and pull no more data from the source than is required? </li><li>  Does it work on an endless stream?  Does it require a limited amount of memory? </li><li>  Will it parallel well? </li></ol><br>  Minusik on any of these points makes you seriously think about whether to add such an operation.  Minusik on the first - it is not immediately.  For example, competitors in jOOŒª have the operation <a href="http://www.jooq.org/products/jOO%25CE%25BB/javadoc/0.9.7/org/jooq/lambda/Seq.html">shuffle ()</a> , which looks like an intermediate one, but in fact directly consumes the entire stream into the list right away, mixes it up and creates a new stream.  I don't respect that. <br><br>  Minusiki on the remaining items does not immediately mean no, because there are standard operations that violate them.  The second item breaks <code>flatMap()</code> , the third one - <code>sorted()</code> , the fourth - all sorts of <code>limit()</code> and <code>takeWhile()</code> (in JDK-9).  But still, I try to avoid it.  However, the other day I discovered an operation that is badly parallelized and, depending on its use, may not work on an endless stream, but is still too good.  Through it, it is possible to literally express in a few lines both practically any existing intermediate operation, and a bunch of nonexistent ones.  I called the operation <a href="http://amaembo.github.io/streamex/javadoc/one/util/streamex/StreamEx.html">headTail ()</a> . <br><a name="habracut"></a><br>  The operation method takes two function parameters (everywhere below I omit <a href="http://habrahabr.ru/post/207360/">PECS</a> for short): 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="java hljs">&lt;R&gt; <span class="hljs-function"><span class="hljs-function">StreamEx&lt;R&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">headTail</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(BiFunction&lt;T, StreamEx&lt;T&gt;, Stream&lt;R&gt;&gt; mapper, Supplier&lt;Stream&lt;R&gt;&gt; supplier)</span></span></span></span></code> </pre> <br>  The first function takes two arguments: the first element of the source stream and a stream containing all the other elements.  The function can do anything with this and return a new stream, which will be passed to the following operations.  The second argument is a function that takes no arguments, which returns a stream of the same type as the first function.  It is called if the source stream is empty.  In fact, only one of the functions is called and only once during the execution of the terminal operation of the entire stream. <br><br>  Often the second function should return just an empty stream (if the source stream is empty, then the result is empty), so it can be omitted: <br><br><pre> <code class="java hljs">&lt;R&gt; <span class="hljs-function"><span class="hljs-function">StreamEx&lt;R&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">headTail</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(BiFunction&lt;T, StreamEx&lt;T&gt;, Stream&lt;R&gt;&gt; mapper)</span></span></span></span></code> </pre> <br>  Let's see what can be done about it.  A simple use case might look like this: <br><br><pre> <code class="java hljs">StreamEx.of(<span class="hljs-string"><span class="hljs-string">"name"</span></span>, <span class="hljs-string"><span class="hljs-string">"John"</span></span>, <span class="hljs-string"><span class="hljs-string">"Mary"</span></span>, <span class="hljs-string"><span class="hljs-string">"Lucy"</span></span>) .headTail((head, tail) -&gt; tail.map(str -&gt; head+<span class="hljs-string"><span class="hljs-string">": "</span></span>+str)) .forEach(System.out::println);</code> </pre> <br>  Conclusion: <br><br><pre> <code class="java hljs">name: John name: Mary name: Lucy</code> </pre> <br>  Here we just bit off the first element of the stream and used it for concatenation with subsequent elements.  So you can parse a text file that has headers in the first line.  But it is pretty boring.  Playing with this method, I discovered that it is much more powerful.  Let's try to express through it the main intermediate operations from the JDK. <br><br><h4>  Stream.map </h4><br>  The map operation applies the specified function to all elements of the original stream.  This is how it will look through headTail (): <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;T, R&gt; <span class="hljs-function"><span class="hljs-function">StreamEx&lt;R&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">map</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(StreamEx&lt;T&gt; input, Function&lt;T, R&gt; mapper)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> input.headTail((head, tail) -&gt; map(tail, mapper).prepend(mapper.apply(head))); }</code> </pre> <br>  Here we use another simple operation <a href="http://amaembo.github.io/streamex/javadoc/one/util/streamex/StreamEx.html">prepend</a> , without which nothing would have happened.  This is a variation on the concatenation of two streams (in the standard API there is Stream.concat).  Here we call ourselves for the tail, and then add to the beginning of the stream the result of applying the function to the head element. <br><br>  This is similar to recursion, and everyone knows that recursion is eating a stack.  In functional programming languages, <a href="https://ru.wikipedia.org/wiki/%25D0%25A5%25D0%25B2%25D0%25BE%25D1%2581%25D1%2582%25D0%25BE%25D0%25B2%25D0%25B0%25D1%258F_%25D1%2580%25D0%25B5%25D0%25BA%25D1%2583%25D1%2580%25D1%2581%25D0%25B8%25D1%258F">tailing recursion optimization</a> sometimes saves, but in Java it is not and is not expected.  However, in this case, this is not exactly recursion: we do not call the map method within ourselves, but only create a function that will be called later.  It turned out that in this case it is possible to control the depth of calls if changes in each individual <code>headTail()</code> affect only the beginning of the stream, leaving the tail unchanged.  I was not very creative in calling this feature ‚Äútail stream optimization‚Äù.  It is compatible with intermediate <code>prepend</code> operations (add something to the beginning of the stream), <code>mapFirst</code> (change the first element of the stream, without touching the rest) and the <code>headTail</code> itself.  In principle, it could be extended to standard skip and dropWhile (from JDK-9), but my library promises that standard operations are fully compatible with the original Stream API, and there would be subtle differences. <br><br>  Anyway, the above map operation does not eat the stack or memory is larger than a constant size and is quite applicable for streams of any length.  Let's look at other operations. <br><br><h4>  Stream.limit </h4><br>  Restrict the stream to a given length.  If we restrict to one element, then we simply create a stream from the head, otherwise we call ourselves for the tail with a reduced restriction (process n &lt;= 0 - an exercise for the reader): <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;T&gt; <span class="hljs-function"><span class="hljs-function">StreamEx&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">limit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(StreamEx&lt;T&gt; input, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> input.headTail((head, tail) -&gt; n &gt; <span class="hljs-number"><span class="hljs-number">1</span></span> ? limit(tail, n - <span class="hljs-number"><span class="hljs-number">1</span></span>).prepend(head) : Stream.of(head)); }</code> </pre> <br>  At the beginning I wrote a little differently (like the flatMap argument, the headTail argument can return null instead of an empty stream): <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;T&gt; <span class="hljs-function"><span class="hljs-function">StreamEx&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">limit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(StreamEx&lt;T&gt; input, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> input.headTail((head, tail) -&gt; n &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> ? limit(tail, n - <span class="hljs-number"><span class="hljs-number">1</span></span>).prepend(head) : <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>); }</code> </pre> <br>  But this implementation has a flaw: it considers one element more from the source than necessary (for n = 0, the head argument is read but not used).  Sometimes it can be critical.  For example, such code should work: <br><br><pre> <code class="java hljs">limit(StreamEx.of(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Random().ints(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1000</span></span>).boxed().distinct()), <span class="hljs-number"><span class="hljs-number">1000</span></span>).forEach(System.out::println);</code> </pre> <br>  An endless stream of random numbers from 0 to 999, from which we select unique ones.  There are 1000 unique ones, but there is no 1001, so if you try to pull out the 1001th number from the source, everything will hang. <br><br><h4>  Stream.skip </h4><br>  Drop n first elements.  If n = 0, we simply return the tail with the head stuck, otherwise we call ourselves with a reduced argument: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;T&gt; <span class="hljs-function"><span class="hljs-function">StreamEx&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">skip</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(StreamEx&lt;T&gt; input, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> input.headTail((head, tail) -&gt; n &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> ? skip(tail, n - <span class="hljs-number"><span class="hljs-number">1</span></span>) : tail.prepend(head)); }</code> </pre> <br><br><h4>  Stream.flatMap </h4><br>  Display each element on the stream and make one common stream.  In our case, the implementation is the same as that of the map: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;T, R&gt; <span class="hljs-function"><span class="hljs-function">StreamEx&lt;R&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">flatMap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(StreamEx&lt;T&gt; input, Function&lt;T, Stream&lt;R&gt;&gt; mapper)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> input.headTail((head, tail) -&gt; flatMap(tail, mapper).prepend(mapper.apply(head))); }</code> </pre> <br>  Here, the only difference is that another <a href="http://amaembo.github.io/streamex/javadoc/one/util/streamex/StreamEx.html">prepend is used</a> , which receives the stream (actually, the first prepend is a special case of this). <br><br><h4>  Stream.peek </h4><br>  Perform an additional action for each element of the stream and return the stream as is.  Perform the action and glue the head to the tail: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;T&gt; <span class="hljs-function"><span class="hljs-function">StreamEx&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">peek</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(StreamEx&lt;T&gt; input, Consumer&lt;T&gt; consumer)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> input.headTail((head, tail) -&gt; { consumer.accept(head); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> peek(tail, consumer).prepend(head); }); }</code> </pre> <br><br><h4>  Stream.filter </h4><br>  Leave elements satisfying the predicate.  We glue the head only if the predicate is fulfilled: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;T&gt; <span class="hljs-function"><span class="hljs-function">StreamEx&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">filter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(StreamEx&lt;T&gt; input, Predicate&lt;T&gt; predicate)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> input.&lt;T&gt; headTail((head, tail) -&gt; predicate.test(head) ? filter(tail, predicate).prepend(head) : filter(tail, predicate)); }</code> </pre> <br><h4>  Stream.distinct </h4><br>  Leave unique items.  There will obviously need additional memory.  A naive implementation will use filter (standard or declared above can be): <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;T&gt; <span class="hljs-function"><span class="hljs-function">StreamEx&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">distinct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(StreamEx&lt;T&gt; input)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> input.headTail((head, tail) -&gt; distinct(tail.filter(n -&gt; !Objects.equals(head, n))).prepend(head)); }</code> </pre> <br>  But such code still eats the stack, there is no optimization of tail streams.  In addition, each element is checked linearly by a chain of filters, and I would like to optimize it.  To do this, we will keep in the parameters HashSet: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;T&gt; <span class="hljs-function"><span class="hljs-function">StreamEx&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">distinct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(StreamEx&lt;T&gt; input, Set&lt;T&gt; observed)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> input.headTail((head, tail) -&gt; observed.add(head) ? distinct(tail, observed).prepend(head) : distinct(tail, observed)); }</code> </pre> <br>  Do not forget that <code>Set.add</code> returns <code>false</code> if the element was already in the set.  In this case, do not glue the head.  Such an implementation stack no longer eats and is not inferior in memory from the standard.  Here it is worth adding a method for running (with recursive functions it often happens that you need a separate public method for running): <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;T&gt; <span class="hljs-function"><span class="hljs-function">StreamEx&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">distinct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(StreamEx&lt;T&gt; input)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> distinct(input, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashSet&lt;&gt;()); }</code> </pre> <br><h4>  Stream.sorted </h4><br>  Sort stream.  The operation is special: it is impossible to give anything as a result here until the source is fully read.  We'll have to buffer everything (for example, in an <code>ArrayList</code> ) and here, for the first time, we will need the second <code>headTail</code> argument: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;T&gt; <span class="hljs-function"><span class="hljs-function">StreamEx&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sorted</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(StreamEx&lt;T&gt; input)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sorted(input, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;()); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;T&gt; <span class="hljs-function"><span class="hljs-function">StreamEx&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sorted</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(StreamEx&lt;T&gt; input, List&lt;T&gt; buf)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> input.headTail((head, tail) -&gt; { buf.add(head); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sorted(tail, buf); }, () -&gt; { buf.sort(<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> buf.stream(); }); }</code> </pre> <br>  When the entire source stream is over, we sort the buffer and return the stream from it.  I note that this <code>sorted</code> works similar to the standard one and it is still better than the <code>shuffle</code> given above.  For example, if you concatenate two sorted streams, the second will not be sorted until you have completely read the first.  By the way, replacing <code>buf.sort(null)</code> with <code>Collections.shuffle(buf)</code> you and <code>shuffle</code> can do more or less normally.  And with <code>Collections.reverse(buf)</code> you can flip the stream. <br><br>  JDK-9 adds two new intermediate operations for now.  We also implement them: <br><br><h4>  Stream.takeWhile </h4><br>  Trim the stream as soon as the predicate returns false.  It looks like limit: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;T&gt; <span class="hljs-function"><span class="hljs-function">StreamEx&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">takeWhile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(StreamEx&lt;T&gt; input, Predicate&lt;T&gt; predicate)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> input.headTail((head, tail) -&gt; predicate.test(head) ? takeWhile(tail, predicate).prepend(head) : <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>); }</code> </pre> <br><h4>  Stream.dropwhile </h4><br>  Throw out elements from the stream until the predicate returns <code>false</code> .  Looks like a <code>skip</code> : <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;T&gt; <span class="hljs-function"><span class="hljs-function">StreamEx&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dropWhile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(StreamEx&lt;T&gt; input, Predicate&lt;T&gt; predicate)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> input.headTail((head, tail) -&gt; predicate.test(head) ? dropWhile(tail, predicate) : tail.prepend(head)); }</code> </pre> <br>  Well, reinventing the wheel is boring.  Let's try to implement new operations that are not in the Stream API. <br><br><h4>  mirror </h4><br>  Add to the end of the stream its contents in the reverse order (so that the stream from 1, 2, 3 turns into 1, 2, 3, 3, 2, 1).  You can do it easily, but without tail optimization: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;T&gt; <span class="hljs-function"><span class="hljs-function">StreamEx&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mirror</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(StreamEx&lt;T&gt; input)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> input.headTail((head, tail) -&gt; mirror(tail).append(head).prepend(head)); }</code> </pre> <br>  With a tail buffer is required: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;T&gt; <span class="hljs-function"><span class="hljs-function">StreamEx&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mirror</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(StreamEx&lt;T&gt; input)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mirror(input, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayDeque&lt;&gt;()); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;T&gt; <span class="hljs-function"><span class="hljs-function">StreamEx&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mirror</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(StreamEx&lt;T&gt; input, Deque&lt;T&gt; buf)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> input.headTail((head, tail) -&gt; { buf.addFirst(head); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mirror(tail, buf).prepend(head); }, buf::stream); }</code> </pre> <br>  Both implementations do not take more than necessary: <code>mirror(StreamEx.of(1,2,3,4,5)).limit(3)</code> does not reach the reflection point and subtracts only three elements from the source. <br><br><h4>  scanLeft </h4><br>  We consistently modify the stream by performing the specified operation.  For example, <code>scanLeft(StreamEx.of(1,2,3,4,5), Integer::sum)</code> should sequentially summarize the elements and create streams <code>1, 3, 6, 10, 15</code> . <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;T&gt; <span class="hljs-function"><span class="hljs-function">StreamEx&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">scanLeft</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(StreamEx&lt;T&gt; input, BinaryOperator&lt;T&gt; operator)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> input.headTail((head, tail) -&gt; scanLeft(tail.mapFirst(cur -&gt; operator.apply(head, cur)), operator).prepend(head)); }</code> </pre> <br>  Here we used the <a href="http://amaembo.github.io/streamex/javadoc/one/util/streamex/StreamEx.html">mapFirst</a> method, which already exists in StreamEx.  But if it were not, we would easily write it even without any recursion: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;T&gt; <span class="hljs-function"><span class="hljs-function">StreamEx&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mapFirst</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(StreamEx&lt;T&gt; input, UnaryOperator&lt;T&gt; operator)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> input.headTail((head, tail) -&gt; tail.prepend(operator.apply(head))); }</code> </pre> <br>  In any case, tails are optimized, both with our mapFirst, and with the existing one. <br><br><h4>  takeWhileClosed </h4><br>  The name may not be very good.  Sometimes you want to modify <code>takeWhile</code> , so that not only elements that satisfy the predicate but also the first element that violates it are included in the stream.  Through existing operations and through the usual <code>takeWhile</code> this is not normally expressed.  And through <code>headTail</code> , it's easy: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;T&gt; <span class="hljs-function"><span class="hljs-function">StreamEx&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">takeWhileClosed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(StreamEx&lt;T&gt; input, Predicate&lt;T&gt; predicate)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> input.headTail((head, tail) -&gt; predicate.test(head) ? takeWhileClosed(tail, predicate).prepend(head) : Stream.of(head)); }</code> </pre> <br><h4>  every </h4><br>  Take the elements from the stream at a specified interval (for example, every tenth), starting with the first.  Here it is convenient to combine with the <code>skip</code> operation, but the standard <code>skip</code> does not optimize tails, so we will use our redefined <code>skip</code> : <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;T&gt; <span class="hljs-function"><span class="hljs-function">StreamEx&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">every</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(StreamEx&lt;T&gt; input, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> input.headTail((head, tail) -&gt; every(skip(tail, n - <span class="hljs-number"><span class="hljs-number">1</span></span>), n).prepend(head)); }</code> </pre> <br><h4>  couples </h4><br>  Break the stream into disjoint pairs of elements, applying the specified function to them (if there are an odd number of elements, throw out the last one).  Here it is convenient to call <code>headTail</code> twice: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;T, R&gt; <span class="hljs-function"><span class="hljs-function">StreamEx&lt;R&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">couples</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(StreamEx&lt;T&gt; input, BiFunction&lt;T, T, R&gt; mapper)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> input.headTail((left, tail1) -&gt; tail1.headTail((right, tail2) -&gt; couples(tail2, mapper).prepend(mapper.apply(left, right)))); }</code> </pre> <br><h4>  pairMap </h4><br>  And if we want the same pair of intersecting pairs?  Easy, you just need to return the right element to the stream when recursively calling: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;T, R&gt; <span class="hljs-function"><span class="hljs-function">StreamEx&lt;R&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pairMap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(StreamEx&lt;T&gt; input, BiFunction&lt;T, T, R&gt; mapper)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> input.headTail((left, tail1) -&gt; tail1.headTail((right, tail2) -&gt; pairMap(tail2.prepend(right), mapper).prepend(mapper.apply(left, right)))); }</code> </pre> <br>  Such an operation is already in StreamEx, and I <a href="https://habrahabr.ru/post/256905/">wrote</a> about it.  <code>headTail()</code> course, it is normally parallelized, in contrast to the implementation via <code>headTail()</code> . <br><br><h4>  batches </h4><br>  Okay, with couples understandable.  And if we want to break the stream into pieces of a fixed length (in the form of lists) and not lose a whole piece at the end?  For example, <code>batches(StreamEx(1,2,3,4,5,6,7), 3)</code> should make a stream from the lists <code>[1,2,3], [4,5,6], [7]</code> .  An argument containing the intermediate buffer will help here: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;T&gt; StreamEx&lt;List&lt;T&gt;&gt; batches(StreamEx&lt;T&gt; input, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> size) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> batches(input, size, Collections.emptyList()); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;T&gt; StreamEx&lt;List&lt;T&gt;&gt; batches(StreamEx&lt;T&gt; input, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> size, List&lt;T&gt; cur) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> input.headTail((head, tail) -&gt; cur.size() &gt;= size ? batches(tail, size, Collections.singletonList(head)).prepend(cur) <span class="hljs-comment"><span class="hljs-comment">//         : batches(tail, size, StreamEx.of(cur).append(head).toList()), //     () -&gt; Stream.of(cur)); }</span></span></code> </pre> <br>  When the source is exhausted, we return the last accumulated buffer as a result with <code>() -&gt; Stream.of(cur)</code> , so as not to lose the tail.  Here, for the beauty of the implementation, I create a new list every time through <code>StreamEx.of(cur).append(head).toList()</code> , rather than changing the existing one.  But easy and changeable lists to insert, if performance is important. <br><br><h4>  withIndices </h4><br>  Did you need to know the indexes of the elements in the stream?  You can and this.  In order not to have a special type, like an index-element pair, <code>BiFunction&lt;Integer, T, R&gt;</code> take an abstract function of the type <code>BiFunction&lt;Integer, T, R&gt;</code> , which can do everything it wants with the index and the element: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;T, R&gt; <span class="hljs-function"><span class="hljs-function">StreamEx&lt;R&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">withIndices</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(StreamEx&lt;T&gt; input, BiFunction&lt;Integer, T, R&gt; mapper)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> withIndices(input, <span class="hljs-number"><span class="hljs-number">0</span></span>, mapper); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;T, R&gt; <span class="hljs-function"><span class="hljs-function">StreamEx&lt;R&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">withIndices</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(StreamEx&lt;T&gt; input, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> idx, BiFunction&lt;Integer, T, R&gt; mapper)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> input.headTail((head, tail) -&gt; withIndices(tail, idx + <span class="hljs-number"><span class="hljs-number">1</span></span>, mapper).prepend(mapper.apply(idx, head))); }</code> </pre> <br><br><h4>  dominators </h4><br>  A more exotic task: we will throw out the elements following this one, over which the given one ‚Äúdominates‚Äù.  Dominance defines a predicate from two elements.  For example, <code>dominators(numbers, (a, b) -&gt; a &gt;= b)</code> will leave an increasing subset of the original numbers.  The implementation is similar to every, but instead of skip our dropWhile is used: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;T&gt; <span class="hljs-function"><span class="hljs-function">StreamEx&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dominators</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(StreamEx&lt;T&gt; input, BiPredicate&lt;T, T&gt; isDominator)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> input.headTail((head, tail) -&gt; dominators(dropWhile(tail, e -&gt; isDominator.test(head, e)), isDominator) .prepend(head)); }</code> </pre> <br><br><h4>  appendReduction </h4><br>  Add one more element to the end of the stream - the result of its reduction with a given operation.  For example, <code>appendReduction(numbers, 0, Integer::sum)</code> add to the stream of numbers the sum of its elements. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;T&gt; <span class="hljs-function"><span class="hljs-function">StreamEx&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">appendReduction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(StreamEx&lt;T&gt; input, T identity, BinaryOperator&lt;T&gt; op)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> input.headTail((head, tail) -&gt; appendReduction(tail, op.apply(identity, head), op).prepend(head), () -&gt; Stream.of(identity)); }</code> </pre> <br>  As usual, everything is lazy and tails are optimized. <br><br><h4>  primes </h4><br>  Rather a learning task.  Make a sieve of Eratosthenes: a lazy stream of primes that throws out those that are divided into those already seen before: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> StreamEx&lt;Integer&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sieve</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(StreamEx&lt;Integer&gt; input)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sieve(StreamEx.iterate(<span class="hljs-number"><span class="hljs-number">2</span></span>, x -&gt; x+<span class="hljs-number"><span class="hljs-number">1</span></span>)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> StreamEx&lt;Integer&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sieve</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(StreamEx&lt;Integer&gt; input)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> input.headTail((head, tail) -&gt; sieve(tail.filter(n -&gt; n % head != <span class="hljs-number"><span class="hljs-number">0</span></span>)).prepend(head)); }</code> </pre> <br>  Here tail optimization does not work, although a similar thing in functional languages ‚Äã‚Äãis also, of course, not optimized.  But it looks simple.  With the default settings, the JVM has time to produce prime numbers up to 200,000 or more, until it drops with StackOverflowError. <br><br>  You can think of other useful operations.  For example, repeat the contents of a stream in a loop a specified number of times.  Or duplicate the stream by filtering it with two different filters (without storing in memory what the second filter did not pass).  You can make a running window (by analogy with batches, but overlap).  In fact, whatever I came up with, I managed to implement it with the help of headTail very briefly (my tests are <a href="">here</a> ).  Anyway, for me, headTail is definitely shorter and clearer than writing an <code>Iterator</code> or <code>Spliterator</code> .  As I understand it, in the world of functional programming, such things are common.  It's nice that this is possible in Java. <br><br>  Program with pleasure! </div><p>Source: <a href="https://habr.com/ru/post/262139/">https://habr.com/ru/post/262139/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../262127/index.html">Command line art</a></li>
<li><a href="../262129/index.html">The magic of tensor algebra: Part 6 - Kinematics of a free solid. Nature of angular velocity</a></li>
<li><a href="../262131/index.html">How to pay for training with VMware PSO credits</a></li>
<li><a href="../262133/index.html">STM32, C ++ and FreeRTOS. Development from scratch. Part 4 (Interrupts, UART and UnHART)</a></li>
<li><a href="../262137/index.html">Setting the syntax check "on the fly" HTML, CSS, JS, PHP in Sublime Text 3 on Windows 7</a></li>
<li><a href="../262141/index.html">Watson went to Wimbledon</a></li>
<li><a href="../262143/index.html">DevDay - open meetings for sociable IT people</a></li>
<li><a href="../262145/index.html">The rapid development of mobile advertising, Fallout Shelter for Android, CSR2 - and other news of the week for a mobile developer</a></li>
<li><a href="../262149/index.html">IT infrastructure of one state budget educational organization</a></li>
<li><a href="../262151/index.html">Compact installation of FreeBSD 10 for a certification authority</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>