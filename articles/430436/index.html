<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>On the way to QUIC: what is the basis of HTTP / 3</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A new milestone in Internet history begins before our eyes: we can assume that HTTP / 3 has already been announced. At the end of October, Mark Nottin...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>On the way to QUIC: what is the basis of HTTP / 3</h1><div class="post__text post__text-html js-mediator-article">  A new milestone in Internet history begins before our eyes: we can assume that HTTP / 3 has already been announced.  At the end of October, Mark Nottingham from the IETF <a href="https://mailarchive.ietf.org/arch/msg/quic/RLRs4nB1lwFCZ_7k0iuz0ZBa35s">proposed to decide on the name</a> for the new protocol, on which the IETF has been building since 2015.  So instead of QUIC-like names, a loud HTTP / 3 appeared.  Western publications have already <a href="http3/">written about this</a> and <a href="http3/">not even once</a> .  The history of QUIC began in the depths of the Corporation of Good in 2012, since then only Google servers supported HTTP-over-QUIC connections, but time passes and now Facebook began to introduce this technology (on November 7, <a href="https://twitter.com/__subodh/status/1059999398258630656">Facebook</a> and <a href="https://twitter.com/dmitri_tikhonov/status/1059998989557395457">LiteSpeed</a> made the first HTTP / 3 interaction );  at the moment, the share of websites supporting QUIC is 1.2%.  Finally, the WebRTC team <a href="https://twitter.com/agouaillard/status/1059545962031472640">also looks to QUIC</a> (plus see the <a href="https://w3c.github.io/webrtc-quic/">QUIC API</a> ), so in the foreseeable future, real-time video / audio will walk through QUIC instead of RTP / RTCP.  Therefore, we decided that it would be great to disclose the details of IETF QUIC: especially for Habr, we prepared a translation of the longrid, dotting i.  Enjoy! <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/r4/ee/3s/r4ee3svcbqzrlxwfzuajri7go04.png"></div><a name="habracut"></a><br>  QUIC (Quick UDP Internet Connections) is a new, encrypted, default transport layer protocol that has many HTTP enhancements, both to speed up traffic and to increase security.  QUIC also has a long-term goal - to eventually replace TCP and TLS.  In this article, we will look at both QUIC key chips and why the web will benefit from them, as well as the problems of supporting this completely new protocol. <br><br>  In fact, there are two protocols with this name: Google QUIC (gQUIC), the original protocol that Google engineers developed several years ago, which after a series of experiments was adopted by the Internet Engineering Task Force (IETF) for standardization purposes. <br><br>  IETF QUIC (hereinafter - simply QUIC) already has such strong discrepancies with gQUIC that it can be considered a separate protocol.  From packet format to handshake and HTTP mapping, QUIC improved the original gQUIC architecture through collaboration with many organizations and developers who have a common goal: to make the Internet faster and safer. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      So what improvements does QUIC offer? <br><br><h2>  Integrated security (and performance) </h2><br>  One of the most noticeable differences between QUIC and the venerable TCP is the initially stated goal of being a transport protocol that is <b>secure by default</b> .  QUIC does this with authentication and encryption, which usually occur at a higher level (for example, in TLS), and not in the transport protocol itself. <br><br>  The initial handshake at QUIC combines the usual three-way TCP communication with the TLS 1.3 handshake, which provides authentication of participants, as well as coordination of cryptographic parameters.  For those who are familiar with TLS: QUIC replaces the TLS recording level with its own frame format, but uses TLS handshakes. <br><br>  This not only allows the connection to always be encrypted and authenticated, but also make the initial connection faster: the ordinary QUIC handshake makes the exchange between the client and the server in one pass, while TCP + TLS 1.3 takes two passes. <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/h2/lq/o4/h2lqo4o2itthtb_h7qopgt7kbc4.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/g6/ne/vg/g6nevg964eqgvmzillfvnet3lus.png"></div><br>  However, QUIC goes further and also encrypts connection metadata that can be easily compromised by a third party.  For example, attackers can use packet numbers to direct users across multiple network paths when using connection migration (see below).  QUIC encrypts packet numbers, so they cannot be adjusted by anyone other than the actual participants in the connection. <br><br>  Encryption can also be effective against "stagnancy" - a phenomenon that does not allow using protocol flexibility in practice due to incorrect assumptions in implementations (ossification is that because of what <a href="https://blog.cloudflare.com/why-tls-1-3-isnt-in-browsers-yet/">TLS 1.3</a> display <a href="https://blog.cloudflare.com/why-tls-1-3-isnt-in-browsers-yet/">was delayed</a> for a <a href="https://blog.cloudflare.com/why-tls-1-3-isnt-in-browsers-yet/">long time</a> . prevent unwanted blocks for new TLS revisions). <br><br><h2>  Head-of-line blocking </h2><br>  One of the major improvements that <a href="http2/">HTTP / 2</a> brought us is the ability to combine different HTTP requests in a single TCP connection.  This allows HTTP / 2 applications to handle requests in parallel and make better use of the network channel. <br><br>  Of course, this was a significant step forward.  Because earlier, applications needed to initiate many TCP + TLS connections if they wanted to simultaneously process several HTTP requests (for example, when the browser needs to receive both CSS and JavaScript in order to render the page).  Creating new connections requires multiple handshakes, as well as initializing the overload window: this means slowing down the rendering of the page.  Combined HTTP requests avoid this. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/lj/rc/lb/ljrclbypotymwhoajopsze57jry.jpeg"></div><br><br>  However, there is a drawback: since multiple requests / responses are transmitted over the same TCP connection, they are all equally dependent on packet loss, even if the lost data only affects one of the requests.  This is called ‚Äúturn start blocking‚Äù. <br><br>  QUIC goes deeper and provides first-class support for combining requests, for example, different HTTP requests can be regarded as different QUIC transport requests, but they will all use the same QUIC connection - that is, no additional handshakes are needed, there is one congestion condition, QUIC requests are delivered independently - in the end, in most cases, packet loss affects only one request. <br><br>  Thus, it is possible to significantly reduce the time by, for example, full rendering of a web page (CSS, JavaScript, images and other resources), especially in the case of an overloaded network with high packet loss. <br><br><h2>  So simple, yes? </h2><br>  In order to fulfill its promises, the QUIC protocol must overcome some assumptions that many network applications take for granted.  This can make implementation and implementation of QUIC difficult. <br><br>  QUIC is designed to be delivered on top of UDP datagrams in order to facilitate development and avoid problems with network devices that drop packets of unknown protocols (because most devices support UDP).  It also allows QUIC to live in user-space, so, for example, browsers will be able to inject new protocol chips and communicate them to end users, without waiting for OS updates. <br><br>  However, the good goal ‚Äî to reduce network problems ‚Äî makes it more difficult to protect packets and properly route them. <br><br><h2>  One NAT to convene all together and forge a single black will </h2><br>  Typically, NAT routers work with TCP connections using a tuple of 4 values ‚Äã‚Äã(source IP and port plus IP and destination port), as well as tracking TCP SYN, ACK and FIN packets transmitted over the network;  routers can determine when a new connection was established and when it ended.  Therefore, it is possible to accurately manage NAT bindings (connections between internal and external IP and ports). <br><br>  In the case of QUIC, this is not yet possible.  Modern NAT routers are not yet aware of QUIC, so they usually downgrade to default and less accurate UDP processing, which means <a href="https://conferences.sigcomm.org/imc/2010/papers/p260.pdf">timeouts of arbitrary (sometimes small) duration</a> that can affect long-term connections. <br><br>  When a reassociation occurs (for example, due to a timeout), the device outside the perimeter of the NAT begins to receive packets from another source, which is why it is impossible to maintain the connection using only a tuple of 4 values. <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/xg/ze/kz/xgzekzn8kq0nhe9--wkbotrxxmq.png"></div><br><br>  And it's not just NAT!  One of the QUIC features is called connection migration and allows devices, at their discretion, to transfer connections to other IP addresses / paths.  For example, a mobile client will be able to transfer a QUIC connection from a mobile network to an already known WiFi network (the user has visited a favorite coffee shop, etc.). <br><br>  QUIC is trying to solve this problem with the concept of connection ID: a piece of information of arbitrary length, transmitted in QUIC packets and allowing identification of the connection.  End devices can use this ID to track their connections without matching the tuple.  In practice, there should be a set of IDs that point to the same connection, for example, to avoid connecting different paths when a connection is migrated - because the whole process is controlled only by end devices, not middle boxes. <br><br>  However, there may be a problem for telecom operators that use anycast and ECMP routing, where one IP can potentially identify hundreds or thousands of servers.  Since the border routers in these networks do not yet know how to handle QUIC traffic, it may happen that UDP packets from one QUIC connection, but with different tuples will be sent to different servers, which means that the connection is broken. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/d4/vq/us/d4vqusefrkw1ideoglo-_heq8py.png"></div><br><br>  To avoid this, operators may need to implement a smarter balancer at level 4.  This can be achieved programmatically without affecting the border routers themselves (for an example, see the <a href="https://github.com/facebookincubator/katran">Katran</a> project from Facebook). <br><br><h2>  QPACK </h2><br>  Another useful feature of HTTP / 2 was <a href="http-2/">header compression (HPACK)</a> , which allows end devices to reduce the size of the data being transferred by discarding unnecessary in requests and responses. <br><br>  In particular, among other techniques, HPACK uses dynamic tables with headers that have already been sent / received from past HTTP requests / responses, which allows devices to refer to new requests / responses to previously encountered headers (instead of sending them again) . <br><br>  The HPACK tables must be synchronized between the encoder (the side that sends the request / response) and the decoder (the receiving side), otherwise the decoder simply cannot decode what it receives. <br><br>  In the case of HTTP / 2 over TCP, this synchronization is transparent because the transport layer (TCP) delivers requests / responses in the same order in which they were sent.  That is, you can send the decoder instructions for updating the tables in a simple request / response.  But in the case of QUIC, everything is much more complicated. <br><br>  QUIC can deliver multiple HTTP requests / responses in different directions at the same time, which means that QUIC guarantees delivery in one direction, and there is no such guarantee in the case of multiple directions. <br><br>  For example, if a client sends HTTP request A in QUIC stream A, as well as request B in stream B, due to packet swapping or network losses, the server will receive request B before request A. And if request B was encoded as was specified in the request header A, then the server simply cannot decode request B, since it has not yet seen request A. <br><br>  In the gQUIC protocol, this problem was solved by simply making all the headers (but not the bodies) of HTTP requests / responses <b>consistent</b> within a single gQUIC stream.  This ensured that all headers would come in the right order, no matter what happened.  This is a very simple scheme; with its help, existing solutions can continue to use the code sharpened for HTTP / 2;  on the other hand, this increases the likelihood of blocking the turn of the queue, which QUIC is intended to reduce.  Therefore, the QUIC working group from the IETF has developed a new mapping between HTTP and QUIC (HTTP / QUIC), as well as a new header compression principle - QPACK. <br><br>  In the final draft of the HTTP / QUIC and QPACK specifications, each HTTP request / response exchange uses its own QUIC bidirectional stream, so blocking the start of the queue does not occur.  Also, in order to support QPACK, each participant creates two additional, unidirectional QUIC streams, one to send table updates, and the other to confirm that they have been received.  Thus, the QPACK encoder can use the link to the dynamic table only after its receipt has been confirmed by the decoder. <br><br><h2>  Refraction reflection </h2><br>  A common problem with UDP-based protocols is their susceptibility to reflection attacks, when an attacker causes a server to send a huge amount of data to the victim.  The attacker substitutes his IP so that the server thinks that the data request came from the victim's address. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/4e/ee/ov/4eeeovjfl-9or5j0uq-9he0btrg.png"></div><br>  This type of attack can be very effective when the response of the server is incomparably greater than the request.  In this case, talking about the "gain". <br><br>  TCP is usually not used for such attacks, because the packets in the original handshake (SYN, SYN + ACK, ...) are the same length, so they do not have the potential for "gain". <br><br>  On the other hand, the QUIC handshake is very asymmetric: as in TLS, the QUIC server first sends its certificate chain, which can be quite large, despite the fact that the client has to send only a few bytes (the message from the ClientHLS client's TLS client ).  For this reason, the initial QUIC package must be increased to a certain minimum length, even if the contents of the package are significantly smaller.  However, this measure is still not very effective, since a typical server response contains several packages and therefore may be larger than an increased client package. <br><br>  The QUIC protocol also defines an explicit source verification mechanism: instead of giving a large response, the server sends only a retry packet with a unique token, which the client then sends to the server in a new packet.  So the server has greater confidence that the client does not have a spoofed IP address and you can complete the handshake.  The minus of the solution is that the time of the hendzhaek increases, instead of one pass two are already required. <br><br>  An alternative solution is to reduce the server's response to a size in which the reflection attack becomes less effective ‚Äî for example, using <a href="https://blog.cloudflare.com/ecdsa-the-digital-signature-algorithm-of-a-better-internet/">ECDSA certificates</a> (usually they are much smaller than RSA).  We also experimented with the <a href="https://tools.ietf.org/html/draft-ietf-tls-certificate-compression">compression</a> mechanism of <a href="https://tools.ietf.org/html/draft-ietf-tls-certificate-compression">TLS certificates</a> using off-the-shelf compression algorithms like zlib and brotli;  This is a feature that first appeared in gQUIC, but is not currently supported in TLS. <br><br><h2>  UDP performance </h2><br>  One of the constant problems of QUIC is the existing hardware and software that is not able to work with QUIC.  We have already considered how QUIC is trying to cope with network mid-boxes like routers, but another potentially problematic area is the send / receive performance of data between QUIC devices via UDP.  Over the years, efforts have been made to optimize TCP implementations as much as possible, including built-in unloading capabilities in software (for example, operating systems) and hardware (network interfaces), but none of this concerns UDP. <br><br>  However, it is only a matter of time until QUIC‚Äôs implementation surpasses these improvements and benefits.  Take a look at recent efforts to introduce <a href="https://lwn.net/Articles/752184/">UDP offloading on Linux</a> , which would allow applications to combine and transfer multiple UDP segments between user-space and kernel-space to a network stack at a cost of about one segment;  Another example is <a href="https://lwn.net/Articles/655299/">zerocopy</a> support <a href="https://lwn.net/Articles/655299/">for sockets in Linux</a> , thanks to which applications could avoid the cost of copying user-space memory into kernel space. <br><br><h2>  Conclusion </h2><br>  Like HTTP / 2 and TLS 1.3, the QUIC protocol should bring a ton of new features that will enhance the performance and security of both websites and other participants in the Internet infrastructure.  The IETF working group intends to roll out the first version of the QUIC specifications by the end of the year, so it's time to think about how we can get the most out of the advantages of QUIC. </div><p>Source: <a href="https://habr.com/ru/post/430436/">https://habr.com/ru/post/430436/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../430426/index.html">Western Digital Product Rebranding: What Has Changed?</a></li>
<li><a href="../430428/index.html">Website "Escher II" in the nomination "People's Internet project" Runet Prize 2018</a></li>
<li><a href="../430430/index.html">Fullstack - why is it cool, or how to get pleasure from work</a></li>
<li><a href="../430432/index.html">The modal window that you were waiting for. Or how to call a "pop-up" from different buttons on a pure JS</a></li>
<li><a href="../430434/index.html">Running Image Viewer from Windows XP on Modern Windows</a></li>
<li><a href="../430438/index.html">Realistic shadow for roguelike</a></li>
<li><a href="../430446/index.html">Once again about the advantages of "mobile slavery"</a></li>
<li><a href="../430448/index.html">What gives retail machine learning: a project example</a></li>
<li><a href="../430450/index.html">Development model on the example of Stack-based CPU</a></li>
<li><a href="../430452/index.html">Fire, water and fine spray. How will the inhabitants and visitors of Lakhta Center be protected from fire?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>