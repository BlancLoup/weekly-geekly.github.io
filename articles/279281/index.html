<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Containerization mechanisms: namespaces</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The last few years have been marked by the growing popularity of ‚Äúcontainer‚Äù solutions for Linux OS. Today, they talk and write a lot about how and fo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Containerization mechanisms: namespaces</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/375/098/1be/3750981be6a67aa0e2ec4687455b81c6.png" alt="namespaces" width="100%" height="100%"><br><br>  The last few years have been marked by the growing popularity of ‚Äúcontainer‚Äù solutions for Linux OS.  Today, they talk and write a lot about how and for what purposes containers can be used.  But the mechanisms underlying containerization are given far less attention. <br><br>  All containerization tools ‚Äî be it Docker, LXC, or <a href="https://blog.selectel.ru/systemd-i-kontejnery-znakomstvo-s-systemd-nspawn/">systemd-nspawn</a> ‚Äî are based on two Linux kernel subsystems: namespaces and cgroups.  The mechanism of namespaces (namespaces), we would like to consider in detail in this article. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Let's start a few from afar.  The ideas underlying the namespace mechanism are not new.  Back in 1979, the chroot () system call was added to UNIX - just to provide isolation and provide developers with a separate platform for testing from the main system.  It will be useful to remember how it works.  Then we consider the features of the functioning of the namespace mechanism in modern Linux-based systems. <br><a name="habracut"></a><br><h2>  Chroot (): first isolation attempt </h2><br>  The name chroot is an abbreviation for change root, which literally translates as "change the root."  Using the <a href="http://linux.die.net/man/2/chroot" rel="nofollow">chroot ()</a> system call and the corresponding command, you can change the root directory.  A program running with a modified root directory will only have access to files in that directory. <br><br>  The UNIX file system is a tree hierarchy: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c7f/dc5/a3a/c7fdc5a3a414aa2932051fedb5451391.png" alt="chroot" width="100%" height="100%"><br><br>  The top of this hierarchy is the / directory, aka root.  All other directories - usr, local, bin and others - are associated with it. <br><br>  Using chroot, you can add a second root directory to the system, which from the user's point of view will not differ from the first.  The file system in which there is a modified root directory can be schematically represented as follows: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f2e/e2a/330/f2ee2a33067c5f589fc9c0a13d8c0f5d.png" alt="chroot" width="100%" height="100%"><br><br>  The file system is divided into two parts, and they do not affect each other.  How does chroot work?  First we turn to the source code.  As an example, consider the implementation of chroot in OC 4.4 BSD-Lite. <br><br>  The chroot system call is described in the <a href="" rel="nofollow">vfs_syscall.c</a> file: <br><br><pre><code class="hljs rust">hroot(p, uap, retval) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">proc</span></span></span></span> *p; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">chroot_args</span></span></span></span> *uap; int *retval; { register <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">filedesc</span></span></span></span> *fdp = p-&gt;p_fd; int error; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">nameidata</span></span></span></span> nd; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (error = suser(p-&gt;p_ucred, &amp;p-&gt;p_acflag)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (error); NDINIT(&amp;nd, LOOKUP, FOLLOW | LOCKLEAF, UIO_USERSPACE, uap-&gt;path, p); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (error = change_dir(&amp;nd, p)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (error); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fdp-&gt;fd_rdir != NULL) vrele(fdp-&gt;fd_rdir); fdp-&gt;fd_rdir = nd.ni_vp; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-number"><span class="hljs-number">0</span></span>); }</code> </pre> <br>  The most important thing happens in the penultimate line of the fragment we quoted: the current directory becomes the root. <br>  In the Linux kernel, the chroot system call is somewhat more complex (the code snippet is taken <a href="" rel="nofollow">from here</a> ): <br><br><pre> <code class="hljs lua">SYSCALL_DEFINE1(chroot, const <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> __user *, filename) { struct <span class="hljs-built_in"><span class="hljs-built_in">path</span></span> <span class="hljs-built_in"><span class="hljs-built_in">path</span></span>; int <span class="hljs-built_in"><span class="hljs-built_in">error</span></span>; unsigned int lookup_flags = LOOKUP_FOLLOW | LOOKUP_DIRECTORY; retry: <span class="hljs-built_in"><span class="hljs-built_in">error</span></span> = user_path_at(AT_FDCWD, filename, lookup_flags, &amp;<span class="hljs-built_in"><span class="hljs-built_in">path</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">error</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> out; <span class="hljs-built_in"><span class="hljs-built_in">error</span></span> = inode_permission(<span class="hljs-built_in"><span class="hljs-built_in">path</span></span>.dentry-&gt;d_inode, MAY_EXEC | MAY_CHDIR); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">error</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> dput_and_out; <span class="hljs-built_in"><span class="hljs-built_in">error</span></span> = -EPERM; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!ns_capable(current_user_ns(), CAP_SYS_CHROOT)) <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> dput_and_out; <span class="hljs-built_in"><span class="hljs-built_in">error</span></span> = security_path_chroot(&amp;<span class="hljs-built_in"><span class="hljs-built_in">path</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">error</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> dput_and_out; set_fs_root(current-&gt;fs, &amp;<span class="hljs-built_in"><span class="hljs-built_in">path</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">error</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; dput_and_out: path_put(&amp;<span class="hljs-built_in"><span class="hljs-built_in">path</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (retry_estale(<span class="hljs-built_in"><span class="hljs-built_in">error</span></span>, lookup_flags)) { lookup_flags |= LOOKUP_REVAL; <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> retry; } out: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">error</span></span>; }</code> </pre><br>  Consider the features of chroot in Linux on practical examples.  Run the following commands: <br><br><pre> <code class="bash hljs">$ mkdir <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> $ chroot <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> /bin/bash</code> </pre><br>  As a result of the second command, we get the error message: <br><br><pre> <code class="bash hljs">chroot: failed to run <span class="hljs-built_in"><span class="hljs-built_in">command</span></span> <span class="hljs-string"><span class="hljs-string">'/bin/bash'</span></span>: No such file or directory</code> </pre><br>  The error is as follows: the command shell was not found.  Pay attention to this important point: using chroot we create a new, isolated file system that has no access to the current one.  Let's try again: <br><br><pre> <code class="bash hljs">$ mkdir <span class="hljs-built_in"><span class="hljs-built_in">test</span></span>/bin $ cp /bin/bash <span class="hljs-built_in"><span class="hljs-built_in">test</span></span>/bin $ chroot <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> chroot: failed to run <span class="hljs-built_in"><span class="hljs-built_in">command</span></span> <span class="hljs-string"><span class="hljs-string">'/bin/bash'</span></span>: No such file or directory</code> </pre><br>  Again an error - despite the identical message, not at all the same as last time.  The last message was issued by the shell, because it did not find the desired executable file.  In the example above, a dynamic linker reported an error: he did not find the necessary libraries.  To access them, they also need to be copied to the chroot.  You can see exactly which dynamic libraries you want to copy, like this: <br><br><pre> <code class="bash hljs">$ ldd /bin/bash linux-vdso.so.1 =&gt; (0x00007fffd08fa000) libtinfo.so.5 =&gt; /lib/x86_64-linux-gnu/libtinfo.so.5 (0x00007f30289b2000) libdl.so.2 =&gt; /lib/x86_64-linux-gnu/libdl.so.2 (0x00007f30287ae000) libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f30283e8000) /lib64/ld-linux-x86-64.so.2 (0x00007f3028be6000)</code> </pre><br>  After that execute the following commands: <br><br><pre> <code class="bash hljs">$ mkdir <span class="hljs-built_in"><span class="hljs-built_in">test</span></span>/lib <span class="hljs-built_in"><span class="hljs-built_in">test</span></span>/lib64 $ cp /lib/x86_64-linux-gnu/libtinfo.so.5 <span class="hljs-built_in"><span class="hljs-built_in">test</span></span>/lib/ $ cp /lib/x86_64-linux-gnu/libdl.so.2 <span class="hljs-built_in"><span class="hljs-built_in">test</span></span>/lib/ $ cp /lib64/ld-linux-x86-64.so.2 <span class="hljs-built_in"><span class="hljs-built_in">test</span></span>/lib64/ $ cp /lib/x86_64-linux-gnu/libc.so.6 <span class="hljs-built_in"><span class="hljs-built_in">test</span></span>/lib $ chroot <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> bash-4.3<span class="hljs-comment"><span class="hljs-comment">#</span></span></code> </pre><br>  Now it happened!  Let's try to execute in the new file system, for example, the ls command: <br><br><pre> <code class="bash hljs">bash-4.3<span class="hljs-comment"><span class="hljs-comment"># ls</span></span></code> </pre><br>  In response, we will receive an error message: <br><br><pre> <code class="bash hljs">bash: ls: <span class="hljs-built_in"><span class="hljs-built_in">command</span></span> not found</code> </pre><br>  The reason is clear: the ls command is missing in the new file system.  You need to copy the executable file and dynamic libraries again, as it was shown above.  This is a serious shortcoming of chroot: all the necessary files need to be duplicated.  There are chroot and a number of shortcomings in terms of security. <br><br>  Attempts to improve the chroot mechanism and provide more reliable isolation have been made more than once: for example, such well-known technologies such as <a href="https://www.freebsd.org/doc/handbook/jails.html" rel="nofollow">FreeBSD Jail</a> and <a href="https://en.wikipedia.org/wiki/Solaris_Containers">Solaris Zones appeared</a> . <br>  In the Linux kernel, process isolation has been enhanced by the addition of new subsystems and new system calls.  Some of them we will analyze below. <br><br><h2>  Namespace mechanism </h2><br>  The namespace is the mechanism of the Linux kernel that isolates processes from each other.  Work on its implementation was started in kernel version 2.4.19.  Currently, Linux supports six types of namespaces: <br><table><tbody><tr><th>  Namespace </th><th>  What isolates </th></tr><tr><td>  PID </td><td>  PID processes </td></tr><tr><td>  NETWORK </td><td>  Network devices, stacks, ports, etc. </td></tr><tr><td>  USER </td><td>  User and group IDs </td></tr><tr><td>  MOUNT </td><td>  Mount points </td></tr><tr><td>  IPC </td><td>  SystemV IPC, POSIX Message Queuing </td></tr><tr><td>  UTS </td><td>  Hostname and domain name NIS </td></tr></tbody></table><br>  All of these types are used by modern containerization systems (Docker, LXC and others) when running programs. <br><br><h2>  PID: isolation of PID processes </h2><br>  Historically, only one process tree was supported in the Linux kernel.  The process tree is a hierarchical structure similar to the file system directory tree. <br><br>  With the advent of the namespaces mechanism, it became possible to support several process trees, completely isolated from each other. <br><br>  When booting into Linux, the process with the identification number (PID) 1 is first launched. It is the root in the process tree.  It starts other processes and services.  The namespaces mechanism allows you to create a separate branch of the process tree with its own PID 1. The process that creates such a branch is part of the main tree, but its child process will already be root in the new tree. <br><br>  Processes in the new tree do not interact with the parent process and do not even "see" it.  At the same time, processes in the main tree are accessible to all processes of the child tree.  This is graphically shown in the following diagram: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/852/7b2/45f/8527b245fa0293e7d6786bf1f4664342.png" alt="PID Namespace" width="100%" height="100%"><br><br>  You can create several nested PID namespaces: one process starts a child process in a new PID namespace, which in turn generates a new process in a new space, and so on. <br><br>  The same process can have multiple PIDs (a separate identifier for a separate namespace). <br><br>  To create new PID namespaces, use the <a href="http://linux.die.net/man/2/clone" rel="nofollow">clone ()</a> system call with the CLONE_NEWPID flag.  With this flag, you can run a new process in a new namespace and in a new tree.  Consider as an example a small program in the C language (hereinafter, code examples are taken <a href="https://www.toptal.com/linux/separation-anxiety-isolating-your-system-with-linux-namespaces" rel="nofollow">from here</a> and slightly changed by us): <br><br><pre> <code class="hljs objectivec"><span class="hljs-meta"><span class="hljs-meta">#define _GNU_SOURCE #include </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;sched.h&gt;</span></span></span><span class="hljs-meta"> #include </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span></span><span class="hljs-meta"> #include </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span></span><span class="hljs-meta"> #include </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;sys/wait.h&gt;</span></span></span><span class="hljs-meta"> #include </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;unistd.h&gt;</span></span></span><span class="hljs-meta"> static char child_stack[1048576]; static int child_fn() { printf(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"PID: %ld\n"</span></span></span><span class="hljs-meta">, (long)getpid()); return 0; } int main() { pid_t child_pid = clone(child_fn, child_stack+1048576, CLONE_NEWPID | SIGCHLD, NULL); printf(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"clone() = %ld\n"</span></span></span><span class="hljs-meta">, (long)child_pid); waitpid(child_pid, NULL, 0); return 0; }</span></span></code> </pre><br>  Compile and run this program.  Upon completion, we will see the following output: <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">clone</span></span>() = 9910 PID: 1</code> </pre><br>  During the execution of such a small program a lot of interesting things happened in the system.  The clone () function created a new process, cloning the current one, and starting its execution.  However, she separated the new process from the main tree and created for it a separate process tree. <br><br>  Let us now try to change the program code and find out the parent PID from the standpoint of an isolated process: <br><br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">child_fn</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">" PID: %ld\n"</span></span>, (<span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)getppid()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br>  The output of the modified program will look like this: <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">clone</span></span>() = 9985  PID: 0</code> </pre><br>  The line ‚ÄúParent PID: 0‚Äù means that the process we are considering does not have a parent process.  Make another change to the program and remove the CLONE_NEWPID flag from the clone () call: <br><br><pre> <code class="hljs lisp">pid_t child_pid = clone(<span class="hljs-name"><span class="hljs-name">child_fn</span></span>, child_stack+1048576, SIGCHLD, NULL)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre><br>  The clone system call in this case worked in much the same way as <a href="http://linux.die.net/man/2/fork" rel="nofollow">fork ()</a> and simply created a new process.  Between fork () and clone (), however, there is a significant difference that should be disassembled in detail. <br><br>  Fork () creates a child process that represents a copy of the parent.  The parent process is copied along with the entire execution context: allocated memory, open files, etc. <br><br>  Unlike fork (), the clone () call does not just create a copy, but allows you to separate the elements of the execution context between the child and parent processes.  In the above code example with the clone function, the child_stack argument is used, which specifies the stack position for the child process.  As soon as the child and parent processes can share memory, the child process cannot run on the same stack as the parent.  Therefore, the parent process must set the memory space for the child and pass a pointer to it in the clone () call.  Another argument used with the clone () function is flags that indicate what exactly needs to be divided between the parent and child processes.  In our example we used the CLONE_NEWPID flag, which indicates that a child process should be created in the new PID namespace.  Examples of using other flags will be given below. <br><br>  So, we considered isolation at the process level.  But this is just the first step.  Running in a separate namespace, the process will still have access to all system resources.  If such a process listens to, for example, port 80, this port will be blocked for all other processes.  Other namespaces help to avoid such situations. <br><br><h2>  NET: network isolation </h2><br>  Thanks to the NET namespace, we can allocate our own network interfaces for isolated processes.  Even the loopback interface for each namespace will be separate. <br><br>  Network namespaces can be created using the clone () system call with the CLONE_NEWNET flag.  This can also be done using iproute2: <br><br><pre> <code class="bash hljs">$ ip netns add netns1</code> </pre><br>  We will use strace and see what happened in the system during the following command: <br><br><pre> <code class="bash hljs">..... socket(PF_NETLINK, SOCK_RAW|SOCK_CLOEXEC, 0) = 3 setsockopt(3, SOL_SOCKET, SO_SNDBUF, [32768], 4) = 0 setsockopt(3, SOL_SOCKET, SO_RCVBUF, [1048576], 4) = 0 <span class="hljs-built_in"><span class="hljs-built_in">bind</span></span>(3, {sa_family=AF_NETLINK, pid=0, groups=00000000}, 12) = 0 getsockname(3, {sa_family=AF_NETLINK, pid=1270, groups=00000000}, [12]) = 0 mkdir(<span class="hljs-string"><span class="hljs-string">"/var/run/netns"</span></span>, 0755) = 0 mount(<span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">"/var/run/netns"</span></span>, <span class="hljs-string"><span class="hljs-string">"none"</span></span>, MS_REC|MS_SHARED, NULL) = -1 EINVAL (Invalid argument) mount(<span class="hljs-string"><span class="hljs-string">"/var/run/netns"</span></span>, <span class="hljs-string"><span class="hljs-string">"/var/run/netns"</span></span>, 0x4394fd, MS_BIND, NULL) = 0 mount(<span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">"/var/run/netns"</span></span>, <span class="hljs-string"><span class="hljs-string">"none"</span></span>, MS_REC|MS_SHARED, NULL) = 0 open(<span class="hljs-string"><span class="hljs-string">"/var/run/netns/netns1"</span></span>, O_RDONLY|O_CREAT|O_EXCL, 0) = 4 close(4) = 0 unshare(CLONE_NEWNET) = 0 mount(<span class="hljs-string"><span class="hljs-string">"/proc/self/ns/net"</span></span>, <span class="hljs-string"><span class="hljs-string">"/var/run/netns/netns1"</span></span>, 0x4394fd, MS_BIND, NULL) = 0 exit_group(0) = ? +++ exited with 0 +++</code> </pre><br>  Note: here the <a href="http://linux.die.net/man/2/unshare" rel="nofollow">unshare ()</a> system call is used to create a new namespace, and not a clone that is already familiar to us.  Unshare () allows a process or thread to separate portions of the execution context that are common to other processes (or threads). <br><br>  How can I put processes in a new network name space? <br><br>  First, the process that created the new namespace can spawn other processes, and each of these processes will inherit the network namespace of the parent. <br><br>  Secondly, the kernel has a special system call - <a href="http://linux.die.net/man/2/setns" rel="nofollow">setns ()</a> .  With it, you can put the calling process or thread in the desired namespace.  This requires a file descriptor that references this namespace.  It is stored in the / proc / &lt;PID of the process&gt; / ns / net file.  By opening this file, we can pass the file descriptor of the setns () function. <br><br>  You can go the other way.  When creating a new namespace using the ip command, a file is created in the / var / run / netns / directory (see the trace output above).  To get a file descriptor, simply open this file. <br><br>  Network Namespace cannot be deleted using any system call.  It will exist as long as at least one process uses it. <br><br><h2>  MOUNT: file system isolation </h2><br>  We mentioned the isolation at the file system level above when we parsed the chroot () system call.  We noted that the chroot () system call does not provide reliable isolation.  Using the MOUNT namespaces, you can create completely independent file systems associated with various processes: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/229/84d/87d/22984d87d3230585163aa511726d2654.png" alt="MOUNT namespace" width="100%" height="100%"><br><br>  To isolate the file system, use the clone () system call with the CLONE_NEWNS flag: <br><br><pre> <code class="hljs objectivec">clone(child_fn, child_stack+<span class="hljs-number"><span class="hljs-number">1048576</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">CLONE_NEWPID</span></span> | <span class="hljs-built_in"><span class="hljs-built_in">CLONE_NEWNET</span></span> | <span class="hljs-built_in"><span class="hljs-built_in">CLONE_NEWNS</span></span> | SIGCHLD, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>)</code> </pre><br>  First, the child process ‚Äúsees‚Äù the same mount points as the parent.  Once the child process has been moved to a separate namespace, you can mount any file system to it, and this will not affect either the parent process or other namespaces. <br><br><h2>  Other namespaces </h2><br>  An isolated process can also be placed in other namespaces: UID, IPC, and PTS.  A UID allows a process to gain root privileges within a specific namespace.  Using the IPC namespace, you can isolate resources for communication between processes. <br><br>  UTS is used to isolate system identifiers: the host name (nodename) and the domain name (domainame) returned by the <a href="http://man7.org/linux/man-pages/man2/uname.2.html" rel="nofollow">uname ()</a> system call.  Consider another small program: <br><br><pre> <code class="hljs rust">#define _GNU_SOURCE #include &lt;sched.h&gt; #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;sys/utsname.h&gt; #include &lt;sys/wait.h&gt; #include &lt;unistd.h&gt; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> child_stack[<span class="hljs-number"><span class="hljs-number">1048576</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> void print_nodename() { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">utsname</span></span></span></span> utsname; uname(&amp;utsname); printf(<span class="hljs-string"><span class="hljs-string">"%s\n"</span></span>, utsname.nodename); } <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> int child_fn() { printf(<span class="hljs-string"><span class="hljs-string">" : "</span></span>); print_nodename(); printf(<span class="hljs-string"><span class="hljs-string">"      !\n"</span></span>); sethostname(<span class="hljs-string"><span class="hljs-string">"NewOS"</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>); printf(<span class="hljs-string"><span class="hljs-string">"  : "</span></span>); print_nodename(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } int main() { printf(<span class="hljs-string"><span class="hljs-string">"  : "</span></span>); print_nodename(); pid_t child_pid = clone(child_fn, child_stack+<span class="hljs-number"><span class="hljs-number">1048576</span></span>, CLONE_NEWUTS | SIGCHLD, NULL); sleep(<span class="hljs-number"><span class="hljs-number">1</span></span>); printf(<span class="hljs-string"><span class="hljs-string">"  : "</span></span>); print_nodename(); waitpid(child_pid, NULL, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br>  The output of this program will look like this: <br><br><pre> <code class="bash hljs">  : lilah   : lilah       ! New UTS namespace nodename: NewOS</code> </pre><br>  As you can see, the child_fn () function prints the name of the node, changes it, and then displays the new name.  The change occurs only within the new namespace. <br><br><h2>  Conclusion </h2><br>  In this article, we outlined how the namespaces mechanism works.  Hopefully, it will help you to better understand the principles of operation of containers.  By tradition, here are links to interesting additional materials: <br><br><ul><li>  <a href="http://lwn.net/Articles/531114/" rel="nofollow">a series of articles about the namespace mechanism on the LWN.net portal;</a> </li><li>  <a href="http://man7.org/linux/man-pages/man7/namespaces.7.html" rel="nofollow">namespaces manual;</a> </li><li>  <a href="http://www.haifux.org/lectures/299/netLec7.pdf">abstract lecture on namespaces and cgroups</a> . </li></ul><br>  We will continue the consideration of containerization mechanisms.  In the next post we will talk about the cgroups mechanism. <br><br>  If for one reason or another you cannot leave comments here - we invite you <a href="https://blog.selectel.ru/mexanizmy-kontejnerizacii-namespaces/">to our blog</a> . </div><p>Source: <a href="https://habr.com/ru/post/279281/">https://habr.com/ru/post/279281/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../279267/index.html">Android client for rutracker: bypass the blocking using Google Compression proxy</a></li>
<li><a href="../279269/index.html">Custom floating point format on FPGA</a></li>
<li><a href="../279275/index.html">CLRium # 3. Announcement of speakers</a></li>
<li><a href="../279277/index.html">Connect to the Jump Start online event March 15: "Infrastructure as an Azure Resource Manager-based service"</a></li>
<li><a href="../279279/index.html">1.5 Compiling SFML with CMake</a></li>
<li><a href="../279283/index.html">What is Cisco ONE?</a></li>
<li><a href="../279285/index.html">Color Image Transfer using the Intel RealSense SDK</a></li>
<li><a href="../279287/index.html">How David Heinemeyer H√∂nsson organizes controllers</a></li>
<li><a href="../279289/index.html">The book "Android. Programming for professionals "</a></li>
<li><a href="../279291/index.html">Web applications offline. ServiceWorker and CacheStorage</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>