<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Failover Evolution in PostgreSQL: Replication Phase</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="We continue to publish a series of translations of Gulcin Yildirim , the developer of the company 2ndQuadrant, on the resiliency of PostgreSQL and tod...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Failover Evolution in PostgreSQL: Replication Phase</h1><div class="post__text post__text-html js-mediator-article">  We continue to publish a series of translations of <b><a href="https://pgday.ru/ru/2017/speakers/148">Gulcin Yildirim</a></b> , the developer of the company 2ndQuadrant, on the <b>resiliency of PostgreSQL</b> and today we bring to your attention the second post of the series. <br><br>  Gulcin will arrive at <a href="http://pgday.ru/ru/2017/request/registration%3Futm_source%3Dhabr%26utm_medium%3Dpost%26utm_campaign%3Dgulcin2"><b>PG Day'17</b></a> and personally answer the participants' questions, and also tell in more detail not only about replication in PG, but also about <a href="https://pgday.ru/ru/2017/papers/184"><b>automating Postgres upgrades in the cloud</b></a> and not only.  Prepare your questions! <br><br><img src="https://habrastorage.org/files/373/775/e37/373775e37412403296c9330c83bbdaa9.jpg">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      PostgreSQL is a terrific project that is evolving with amazing speed.  In this series of articles, we will focus on the evolution of fault tolerance capabilities in PostgreSQL throughout its versions.  This is the second article in the series, in which we will talk about replication and its significance for the resiliency and reliability of Postgres. <br><a name="habracut"></a><br>  If you want to follow the evolution process from the very beginning, I recommend that you read the first article in the series: The <a href="https://habrahabr.ru/post/317132/">Evolution of Failover in PostgreSQL</a> . <br><br><h3>  Replication in PostgreSQL </h3><br>  <b>Database replication</b> is a concept that we use to describe the technology for creating a <b>copy</b> of a dataset on a <b>remote</b> system.  Storing a reliable copy of the existing system is one of the most important backup tasks, because we all want our copies to be easy to maintain and use, as well as stable. <br><br>  Let's look at the basic architecture.  As a rule, separate database servers are called <b>nodes</b> .  The entire group of database servers involved in replication is known as a <b>cluster</b> .  The database server that allows the user to make changes is called <b>main (master)</b> or <b>primary (primary)</b> , or can be described as a source of changes.  The database server that allows access only in read mode is called <b>Hot Standby</b> or <b>Hot</b> <b>Standby</b> (the <i>term Hot Standby is explained in detail in the Standby Modes section</i> ). <br><br>  A key aspect of replication is that changes to the data are committed to the main server, and then transferred to other nodes.  In some cases, a node may send data changes to other nodes, and this process is known as <b>cascading</b> or <b>relay</b> .  Thus, the primary server is the sender node, but the sender node is not necessarily the primary server.  Replication is often divided into categories, based on whether it is allowed to have more than one primary node.  In this case, <b>multimaster replication</b> takes place. <br><br>  Let's take a look at how PostgreSQL handled replication throughout its existence and what the current state of fault tolerance is in terms of replication. <br><br><h3>  Replication history in PostgreSQL </h3><br>  Once (about 2000‚Äì2005). Postgres only supported fault tolerance / recovery of a single node, which was achieved mainly with the help of WAL - transaction log.  Partially, fault tolerance is provided by the MVCC (multi-version control parallel access control system), but this is mostly optimization. <br><br>  WAL (write ahead logging) was and remains the main fault tolerance method in PostgreSQL.  Its essence is that you have WAL files in which you write everything, and in the event of a system failure, you can play them and restore everything.  This was enough for single-site architectures, and replication is considered the best solution for achieving the fault tolerance of multiple nodes. <br><br>  The Postgres community has long been convinced that replication inside Postgres is useless and can be done with external tools, so tools like Slony and Londiste have appeared.  ( <i>We‚Äôll talk about triggering replication solutions in the next articles in this series</i> .) <br><br>  In the end, it became clear that the stability of a single server was not enough, and more and more people began to demand full hardware fault tolerance, as well as the switching method built into Postgres.  Then physical replication appeared, at the time known as physical streaming. <br><br>  We will go through all the replication methods in this article, but first let us follow the main releases in the chronology of replication history events in PostgreSQL: <br><br><ul><li>  <b>PostgreSQL 7.x (~ 2000)</b> <ul><li>  Replication should not be part of the Postgres kernel </li><li>  Londiste - Slony (trigger logical replication) </li></ul></li><li>  <b>PostgreSQL 8.0 (2005)</b> <ul><li>  Recovery at time, (Point-In-Time recovery, WAL) </li></ul></li><li>  <b>PostgreSQL 9.0 (2010)</b> <ul><li>  Streaming replication (physical) </li></ul></li><li>  <b>PostgreSQL 9.4 (2014)</b> <ul><li>  Logical decoding (extracting the changeset [changsets]) </li></ul></li></ul><br><h3>  Physical replication </h3><br>  PostgreSQL solved the key problem with the need to replicate in the same way as most relational databases: it took WAL and made it possible to send it over the network.  These WAL files are then loaded into a separate Postgres instance, which works in read mode. <br><br>  The backup instance in read mode simply applies the changes (from WAL), and the only <b><i>write operations</i></b> come from the same WAL journal.  In general, this is how <b>streaming replication</b> works.  Initially, replication was considered the original sending of all files ( <b>log shipping</b> ), but later it became streaming. <br><br>  In log shipping, we sent entire files using the <b>archive_command</b> command.  The logic there was quite simple: you simply <b>send the</b> archive and <b>register</b> it somewhere - for example, a whole WAL file for 16MB - and then <b>apply</b> it somewhere, <b>request the</b> next one, <b>apply</b> it and so on.  It was later put on stream via the network, thanks to the use of the libpq protocol in PostgreSQL 9.0. <br><br>  Current replication is more commonly known as <b>physical stream replication</b> , since we are transferring a series of physical changes from one node to another.  This means that when we <b><i>insert a</i></b> row into a table, we generate <b><i>change records</i></b> for the <b><i>insert</i></b> and all <i><b>index entries</b></i> . <br><br>  When we apply to the VACUUM table, change records are also generated. <br><br>  In addition, physical streaming replication records all changes at the <b>byte / block</b> level, so it is almost impossible to do anything other than replay them on a replica. <br><br><img src="https://habrastorage.org/files/a40/f4a/3bf/a40f4a3bf6474219a389e4803f0fe0a2.png"><br><br>  Figure 1 shows how physical replication works with just two nodes.  The client performs requests at the primary site, the changes are written to the transaction log (WAL), and copied over the network to the WAL at the backup site.  The recovery process on the node in standby mode reads changes from WAL and applies them to data files, just like in case of disaster recovery.  If the backup node is in <i><b>hot standby</b></i> mode, clients can perform read requests while this happens. <br><br>  <b>Note</b> : Physical replication is simply sending WAL files across the network from the primary node to the backup.  Files can be sent by different protocols, for example, scp, rsync, ftp ... <b><i>The difference</i></b> between <b>physical</b> and <b>physical stream replication</b> is that stream replication uses an internal protocol to send WAL files ( <b>sender</b> and <b>receiver</b> <b>processes</b> ). <br><br><h3>  Standby Modes </h3><br>  Multiple nodes provide high availability.  For this reason, modern architectures usually have backup nodes.  There are different backup node modes (‚Äúwarm‚Äù and ‚Äúhot‚Äù reserve, warm &amp; hot standby).  Next, we explain the main differences between the backup node modes and consider the case of multimaster architecture. <br><br>  <i>Warm standby</i> <br><br>  It can be activated immediately, but cannot perform useful work until the moment of activation.  If we continuously transfer the sequence of WAL files to another machine onto which the basic backup copy of the same database was loaded, then we have the warm standby system: at any time we can activate the second machine, and it will have an almost up-to-date copy of the database.  Warm standby does not allow making requests in read mode, which is clearly demonstrated in Fig.2. <br><img src="https://habrastorage.org/files/6ba/ca7/589/6baca7589504462fb14f1ee871584893.png"><br>  Recovery in warm stanby mode is so fast that the backup server usually becomes fully available a few moments after activation.  That is why this mode is called a ‚Äúwarm‚Äù (backup) configuration with high availability. <br><br>  <i>Hot standby</i> <br><br>  Hot standby is a term to describe the ability to access the server and perform read requests while the server is in recovery or standby mode.  This is useful both for replication purposes and for restoring a backup to the desired state with great accuracy. <br><br><img src="https://habrastorage.org/files/b90/78b/a83/b9078ba83fde46689f517091728201fd.png"><br><br>  The concept of ‚Äúhot standby‚Äù also refers to the ability of the server to go from recovery to normal operation, while users continue to perform requests and / or keep their connections open.  In Figure 3, you can see that this backup mode allows read requests. <br><br>  <i>Multimaster</i> <br><br>  All nodes can perform read / write tasks.  ( <i>We will look at multi-master architecture in the next articles in this series.</i> ) <br><br>  <i>Parameter WAL Level</i> <br><br>  There is a link between setting the wal_level parameter in the postgresql.conf file and what this setting is suitable for.  The table below shows this connection in PostgreSQL version 9.6. <br><table><tbody><tr><td>  <b>WAL Level</b> </td><td>  <b>Suitable for</b> </td></tr><tr><td>  Minimal </td><td>  Disaster recovery </td></tr><tr><td>  Replica </td><td>  Physical replication <br>  File-based archiving </td></tr><tr><td>  Logical </td><td>  Logical replication </td></tr></tbody></table><br>  A quick note: the wal_level parameter determines how much information is written to WAL.  The default value is minimal, which records only the information necessary for disaster recovery or sudden shutdown.  replica adds the logging required for archiving WAL, as well as the information needed to execute read requests on the standby server.  Finally, logical adds the information needed to support logical decoding.  Each level includes information recorded at all low levels. <br><br>  In versions prior to 9.6, this parameter also allowed the archive and hot_standby values.  They are still accepted, but displayed at the replica level. <br><br><h3>  Failover and Switchover </h3><br>  When replicating with one primary node, if this node dies, one of the backup ones should take its place (promotion).  Otherwise, we will not be able to accept new write operations.  Thus, the names ‚Äúprimary‚Äù and ‚Äúreserve‚Äù are simply roles that can be assigned to any node at a specific point in time.  To transfer the main role to another node, we perform a procedure called <b>Switchover</b> . <br><br>  If the primary node dies and does not recover, a more serious role change occurs, known as <b>failover</b> .  These two procedures are similar in many respects, but it is more convenient to use different terms for each event.  ( <i>Knowledge of the concepts of failover and switchover will help us deal with chronology questions in the next article.</i> ) <br><br><h3>  Conclusion </h3><br>  In this article, we discussed replication in PostgreSQL and its importance for fault tolerance and reliability.  We looked at physical streaming replication and talked about standby modes in PostgreSQL.  Failover and Switchover were also mentioned.  We will continue the topic of talking about timelines in PostgreSQL in the next article. <br><br>  In addition to the <a href="https://pgday.ru/ru/2017/papers/184"><b>Gulcin speech</b></a> , we are preparing for you a series of reports on <a href="https://pgday.ru/ru/2017/papers/149"><b>replication</b></a> and the <a href="https://pgday.ru/ru/2017/papers/155"><b>problems of organization of the resiliency of various data storage systems</b></a> from speakers such as <a href="https://pgday.ru/ru/2017/speakers/111"><b>Sveta Smirnova</b></a> , <a href="https://pgday.ru/ru/2017/speakers/125"><b>Colin Charles</b></a> , <a href="https://pgday.ru/ru/2017/speakers/146"><b>Nikolai Macievsky</b></a> and many others.  <b>Vote</b> for the most relevant topics for you, we will surely take into account all wishes when drawing up the final program of the conference! </div><p>Source: <a href="https://habr.com/ru/post/326440/">https://habr.com/ru/post/326440/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../326430/index.html">Two vacancies for the price of one in April on My Circle</a></li>
<li><a href="../326432/index.html">Windows 10 Creators Update: What's new in Bash / WSL and Windows Console</a></li>
<li><a href="../326434/index.html">PHDays Online Contests: Yes CTF</a></li>
<li><a href="../326436/index.html">Why large databases do not work as you want, or about the unfulfilled dreams of SQL queries</a></li>
<li><a href="../326438/index.html">Moscow Workshops ACM ICPC: how Fiztech created an international camp</a></li>
<li><a href="../326442/index.html">Asynchronous functions 101</a></li>
<li><a href="../326444/index.html">Customer service: people are better than robots</a></li>
<li><a href="../326446/index.html">Recruitment marketing guide for dummies (and not only)</a></li>
<li><a href="../326448/index.html">UX strategy. Part 5 - Exhaust Design</a></li>
<li><a href="../326450/index.html">Icinga2 simple option</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>