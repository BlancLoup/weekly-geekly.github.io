<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Your bike to sync MariaDB and Sphinx</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="On February 28, I gave a talk at the SphinxSearch-meetup , which took place in our office. I talked about how we came from regular rebuilding of index...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Your bike to sync MariaDB and Sphinx</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/webt/t0/1g/vk/t01gvkcn0zx47xuioqcvfz5bqoc.png"></p><br><p>  On February 28, I gave a talk at the <a href="https://habr.com/company/superjob/blog/437978/">SphinxSearch-meetup</a> , which took place in our office.  I talked about how we came from regular rebuilding of indexes for full-text search and sending updates ‚Äúin place‚Äù in the code to Railtime indexes and automatic synchronization of the state of the index and the MariaDB database.  The <a href="https://youtu.be/fjmMgFblBGQ">link</a> is available video of my report, and for those who prefer reading video viewing, I wrote this article. </p><a name="habracut"></a><br><p>  To begin with, we had a search, and why we started all this. </p><br><p>  Our search was organized in a completely standard way. </p><br><p>  From the frontend come user requests to the application server, written in PHP, and he in turn communicates with the database (we have MariaDB).  If we need to do a search, the application server refers to the balancer (we have haproxy), which connects it to one of the servers where searchd is running, and that one already performs the search and returns the result. </p><br><p>  The data from the database to the index fall in a quite traditional way: according to the schedule, every few minutes we rebuild the index with those documents that were updated relatively recently, and once a day we rebuild the index with the so-called ‚Äúarchival‚Äù documents (i.e. for a long time nothing happened).  There are a couple of machines selected for indexing, a script is launched there, which first builds the index, then renames the index files in a special way, and then adds it into a separate folder.  And on each of the servers with searchd, rsync is run once a minute, which copies files from this folder to the searchd index folder, and then, if something has been copied, executes the RELOAD INDEX request. </p><br><p>  However, for some changes in resumes and vacancies it was required that they ‚Äúreach‚Äù the index as soon as possible.  For example, if a vacancy that was posted in the public domain is removed from publication, then it is reasonable to expect from the user's point of view that it will disappear from the issue within a few seconds, not more.  Therefore, such changes are sent using UPDATE requests directly to searchd.  And so that these changes are applied to all copies of the indexes on all of our servers, a distributed index is added to each searchd, which sends attribute updates to all searchd instances.  The application server still connects to the balancer and sends one request to update the distributed index;  thus, he does not need to know in advance any list of servers with searchd, nor on any particular server with searchd he will get. </p><br><p>  It all worked pretty well, but there were problems. </p><br><ol><li>  The average delay between the creation of a document (we have a resume or a job) and its entry into the index was directly proportional to their number in our database. </li><li>  Since we used a distributed index to distribute attribute updates, we had no guarantee that these updates were applied to all copies of the index. </li><li> The ‚Äúurgent‚Äù changes that occurred during the index rebuilding were lost when the <code>RELOAD INDEX</code> command was executed (simply because they were not yet in the newly built index), and were only indexed after the next reindexing. <img src="https://habrastorage.org/webt/rz/t6/v3/rzt6v3lfrnyayc3-texs56vlh48.png"></li><li>  Index update scripts on servers with searchd were run independently of each other, there was no synchronization between them.  Because of this, the delay between updating the index on different servers could reach several minutes. </li><li>  If it was necessary to test something related to the search, it was necessary to rebuild the index after each change. </li></ol><br><p>  Each of these problems separately did not cost the cardinal processing of the search infrastructure, but together they rather perceptibly ruined life. </p><br><p>  We decided to deal with the problems listed above with the help of real-time Sphinx indices.  And we had only one transition to RT-indices.  In order to finally get rid of any data-races, it was necessary to ensure that all updates from the application to the index went through the same channel.  In addition, it was necessary to save somewhere the changes made to the database during the time the index was rebuilt (because, nevertheless, sometimes it has to be rebuilt, and the procedure is not instantaneous). </p><br><p>  We decided to make this connection through the MySQL replication protocol, and binlog MySQL as the place where changes are saved for the time the index is rebuilt.  This solution allowed us to get rid of writing to Sphinx from the application code.  And since by that time we had already used row-based replication with a global transaction id, switching between database replicas could be made quite simple. </p><br><p>  The idea of ‚Äã‚Äãconnecting directly to the database in order to receive changes from there to be sent to the index is, of course, not new: in 2016, colleagues from Avito <a href="https://youtu.be/XAKvmIYeT2c">gave a report</a> where they described in detail how they solved the problem of synchronizing data in Sphinx with the main database.  We decided to use their experience and make a similar system, with the difference that we do not have PostgreSQL, but MariaDB, and the old Sphinx branch (namely, version 2.3.2). </p><br><p>  We made a service that subscribes to changes in MariaDB and updates the index in Sphinx.  His duties are as follows: </p><br><ul><li>  connection to the MariaDB server via the replication protocol and receiving events from the binlog; </li><li>  tracking the current binlog position and the number of the last completed transaction; </li><li>  binlog filtering; </li><li>  finding out which documents need to be added, deleted or updated in the index, and for updatable documents - which fields need to be updated; </li><li>  request missing data from MariaDB; </li><li>  creating and executing index update requests; </li><li>  rebuild the index if necessary. </li></ul><br><p>  We made the replication protocol connection using <a href="https://github.com/siddontang/go-mysql">go-mysql</a> library.  She is responsible for establishing a connection with MariaDB, reading replication events and passing them to a handler.  This handler is started in the mountain, which is controlled by the library, but we write the handler code ourselves.  In the handler code, events are reconciled with a list of tables that interest us and are sent for processing changes to these tables.  Our handler also stores the status of the transaction.  This is due to the fact that in the replication protocol the events go in the following order: GTID (start of transaction) -&gt; ROW (change of data) -&gt; XID (completion of transaction), and information about the transaction number is only in the first of them.  It is more convenient for us to transfer the transaction number along with its completion in order to save information about the position to which the changes were made in the binlog, and for this you need to remember the number of the current transaction between its beginning and completion. </p><br><pre> <code class="plaintext hljs">MySQL [(none)]&gt; describe sync_state; +-----------------+--------+ | Field | Type | +-----------------+--------+ | id | bigint | | dummy_field | field | | binlog_position | uint | | binlog_name | string | | gtid | string | | flavor | string | +-----------------+--------+</code> </pre> <br><p>  We save the number of the last completed transaction to a special index from one document on each server with searchd.  At the start of the service, we check that the indexes are initialized and have the expected structure, as well as that the saved position on all servers is present and the same on all servers.  Then, if these checks were completed successfully and we managed to start reading the binlog from a saved position, we begin the synchronization procedure.  If the checks did not pass, or it was not possible to start reading the binlog from the saved position, then reset the saved position to the current position of the MariaDB server and rebuild the index. </p><br><p>  Replication event handling begins by determining which documents are affected by a change in the database.  To do this, in the configuration of our service, we did something like routing for row change events in the tables of interest, that is, a set of rules to determine how changes in the database should be indexed. </p><br><pre> <code class="plaintext hljs">[[ingest]] table = "vacancy" id_field = "id" index = "vacancy" [ingest.column_map] user_id = ["user_id"] edited_at = ["date_edited"] profession = ["profession"] latitude = ["latitude_deg", "latitude_rad"] longitude = ["longitude_deg", "longitude_rad"] [[ingest]] table = "vacancy_language" id_field = "vacancy_id" index = "vacancy" [ingest.column_map] language_id = ["languages"] level = ["languages"] [[ingest]] table = "vacancy_metro_station" id_field = "vacancy_id" index = "vacancy" [ingest.column_map] metro_station_id = ["metro"]</code> </pre> <br><p>  For example, for such a set of rules, changes in the <code>vacancy</code> , <code>vacancy_language</code> and <code>vacancy_metro_station</code> should fall in the <code>vacancy</code> index.  The document number can be taken in the <code>id</code> field for the <code>vacancy</code> table, and in the <code>vacancy_id</code> field for the other two tables.  The <code>column_map</code> field is a table of the dependence of the index fields on the fields of different database tables. </p><br><p>  Further, when we received a list of documents affected by changes, we need to update them in the index, but we are not doing this right away.  First, we accumulate changes for each document, and send the changes to the index as soon as a short time passes (we have 100 milliseconds) since the last change to this document. </p><br><p>  We decided to do this to avoid a lot of unnecessary updates to the index, because in many cases one logical change of a document occurs with the help of several SQL queries that affect different tables, and sometimes they are executed in different transactions. </p><br><p>  I will give a simple example.  Suppose a user edited a job.  The code responsible for saving changes is often written for simplicity in the following way: </p><br><pre> <code class="plaintext hljs">BEGIN; UPDATE vacancy SET edited_at = NOW() WHERE id = 123; DELETE FROM vacancy_language WHERE vacancy_id = 123; INSERT INTO vacancy_language (vacancy_id, language_id, level) VALUES (123, 1, "fluent"), (123, 2, "technical"); DELETE FROM vacancy_metro_station WHERE vacancy_id = 123; INSERT INTO vacancy_metro_station (vacancy_id, metro_station_id) VALUES (123, 55); ... COMMIT;</code> </pre> <br><p>  In other words, all old records are deleted from the linked tables first, and then new ones are inserted.  At the same time there will still be entries in the binlog about these deletions and inserts, even if nothing has changed in fact in the document. </p><br><p>  To update only what we need, we did the following: sort the modified lines so that for each pair of the index document you can get all the changes in chronological order.  Then we can then apply them in turn to determine which fields in which tables eventually changed and which did not, and then use the <code>column_map</code> table <code>column_map</code> get a list of fields and index attributes that need to be updated for each affected document.  Moreover, events related to one document may not come one after the other, but, as it were, ‚Äúout of joint‚Äù, if they are executed in different transactions.  But, our ability to determine what has changed in which documents will not affect it. </p><br><p>  At the same time, this approach allowed us to update only the attributes of the index, if there were no changes in the text fields, and also to merge the submission of changes to Sphinx. </p><br><p>  So now we can figure out which documents need to be updated in the index. </p><br><p>  In many cases, the data from the binlog is not enough to build a request to update the index, so we get the missing data from the same server from which we are reading the binlog.  To do this, in the configuration of our service there is a request template for receiving data. </p><br><pre> <code class="plaintext hljs">[data_source.vacancy] #               #   -      id     parts = 4 query = """ SELECT vacancy.id AS `:id`, vacancy.profession AS `profession_text:field`, GROUP_CONCAT(DISTINCT vacancy_language.language_id) AS `languages:attr_multi`, GROUP_CONCAT(DISTINCT vacancy_metro_station.metro_station_id) AS `metro:attr_multi` FROM vacancy LEFT JOIN vacancy_language ON vacancy_language.vacancy_id = vacancy.id LEFT JOIN vacancy_metro_station ON vacancy_metro_station.vacancy_id = vacancy.id GROUP BY vacancy.id """</code> </pre> <br><p>  In this template, all fields are marked with special aliases: <code>[___]:___</code> . <br>  It is used both when forming a request for obtaining missing data, and when building an index (more on that later). </p><br><p>  We form a request of this type: </p><br><pre> <code class="plaintext hljs">SELECT vacancy.id AS `id`, vacancy.profession AS `profession_text`, GROUP_CONCAT(DISTINCT vacancy_language.language_id) AS `languages`, GROUP_CONCAT(DISTINCT vacancy_metro_station.metro_station_id) AS `metro` FROM vacancy LEFT JOIN vacancy_language ON vacancy_language.vacancy_id = vacancy.id LEFT JOIN vacancy_metro_station ON vacancy_metro_station.vacancy_id = vacancy.id WHERE vacancy.id IN (&lt; id ,   &gt;) GROUP BY vacancy.id</code> </pre> <br><p>  Then for each document we check if it is as a result of this query.  If not, it means that it was deleted from the main table, and therefore it can also be deleted from the index (execute a <code>DELETE</code> query for this document).  If it is, then we are looking at whether it is necessary to update the text fields for this document.  If the text fields do not need to be updated, then we make an <code>UPDATE</code> request for this document, otherwise - <code>REPLACE</code> . </p><br><p>  It is worth noting here that the logic of maintaining the position from which one can begin reading binlog in case of failures had to be complicated, because now it is possible that we do not apply all changes read from binlog. </p><br><p>  In order for the resumption of binlog reading to work correctly, we did the following: for each event of changing rows in the database, we remember the id of the last completed transaction at the time this event occurred.  After sending changes to Sphinx, we update the transaction number from which it is safe to start reading, as follows.  If we have not processed all the accumulated changes (because some documents are not ‚Äúlying down‚Äù in the queue), then we take the number of the earliest transaction among those that relate to changes that we have not yet had time to apply.  And if it so happened that we applied all the accumulated changes, then we simply take the number of the last completed transaction. </p><br><p>  What we got as a result suited us, but there was still one rather important point: in order for the realtime index performance to remain at an acceptable level over time, it was necessary that the size and number of chunks of this index remained small.  To do this, Sphinx has a <code>FLUSH RAMCHUNK</code> request, which makes a new disk chunk, and an <code>OPTIMIZE INDEX</code> request, which merges all disk chunks into one.  Initially, we thought that we would just periodically carry it out and that‚Äôs it.  But, unfortunately, it turned out that in version 2.3.2 <code>OPTIMIZE INDEX</code> does not work (namely, with a rather high probability leads to a drop of searchd).  Therefore, we decided to just completely rebuild the index once a day, especially since from time to time you still have to do it (for example, if the index scheme or the tokenizer settings are changed). </p><br><p>  The procedure for rebuilding the index takes place in several stages. </p><br><ol><li><p>  We generate config for indexer </p><br><p>  As mentioned above, there is a SQL query template in the service config.  It is also used to form the indexer config. <br>  Also in the config there are other settings needed to build the index (tokenizer settings, dictionaries, various restrictions on resource consumption). </p><br></li><li><p>  Save current position MariaDB </p><br><p>  From this position, we will start reading binlog after the new index is available on all servers with searchd. </p><br></li><li><p>  Run indexer </p><br><p>  <code>indexer --config tmp.vacancy.indexer.0.conf --all</code> commands like <code>indexer --config tmp.vacancy.indexer.0.conf --all</code> and wait for them to complete.  Moreover, if the index is divided into parts, then run the construction of all parts in parallel. </p><br></li><li><p>  Load index files by servers </p><br><p>  Uploading to each server also happens in parallel, but we naturally wait until all files are uploaded to all servers.  To download files in the service configuration there is a section with a command template for downloading files. </p><br><pre> <code class="plaintext hljs">[index_uploader] executable = "rsync" arguments = [ "--files-from=-", "--log-file=&lt;&lt;.DataDir&gt;&gt;/rsync.&lt;&lt;.Host&gt;&gt;.log", "--no-relative", "--times", "--delay-updates", ".", "rsync://&lt;&lt;.Host&gt;&gt;/index/vacancy/", ]</code> </pre> <br><p>  For each server, we simply substitute its name in the Host variable and execute the resulting command.  We use rsync for downloading, but in principle any program or script that accepts a list of files in stdin and uploads these files to the folder where searchd expects to see the index files will do. </p><br></li><li><p>  Stop sync </p><br><p>  We stop reading binlog, stop the gorutin responsible for the accumulation of changes. </p><br></li><li><p>  Replace the old index with a new one. </p><br><p>  For each server with searchd, make successive queries <code>RELOAD INDEX vacancy_plain</code> , <code>TRUNCATE INDEX vacancy_plain</code> , <code>ATTACH INDEX vacancy_plain TO vacancy</code> .  If the index is divided into parts, then we perform these requests for each part sequentially.  At the same time, if we are in a production environment, before performing these queries on any server, we remove the load from the balancer (so that no one makes SELECT queries to the indexes between <code>TRUNCATE</code> and <code>ATTACH</code> ), and as soon as the last <code>ATTACH</code> request is executed, we return the load to this server. </p><br></li><li><p>  Resume sync from saved position </p><br><p>  As soon as we replace all realtime indices with newly built ones, we resume reading from the binlog and synchronization of events from the binlog, starting from the position we saved before starting the indexing. </p><br></li></ol><br><p>  Here is an example of the index lag graph from the MariaDB server. </p><br><p><img src="https://habrastorage.org/webt/xs/pq/56/xspq56osyygn1fxx6h5x_oczgpy.png" alt="Backlog schedule after reindexing"></p><br><p>  Here you can see that although the state of the index after rebuilding and comes back in time, this happens quite a bit. </p><br><p>  Now that everything is more or less ready, it's time to release.  We did it gradually.  First, we poured a realtime index on a couple of servers, and the rest at that time worked as before.  At the same time, the structure of the indexes on the ‚Äúnew‚Äù servers did not differ from the old ones, so our PHP application could still connect to the balancer, without worrying about whether the request would be processed on a realtime index or on a plain index. </p><br><p><img src="https://habrastorage.org/webt/sy/xz/lx/syxzlx_tfmg0-mze5vr1ngt3_tg.png" alt="The update distribution scheme during the transition"></p><br><p>  Attribute updates, which I mentioned earlier, were also sent out using the old scheme, with the difference that the distributed index on all servers was configured to send UPDATE requests only to servers with plain indexes.  Moreover, if an UPDATE request from an application is sent to a server with realtime indexes, then it does not execute the request itself, but sends it to servers configured in the old way. </p><br><p>  After the release, as we had hoped, it turned out to significantly reduce the delay between how a resume or vacancy changes in the database and how relevant changes fall into the index. </p><br><p>  After switching to the realtime index, there is no need to rebuild the index after each change on the test servers.  And therefore it became possible to write end-to-end auto-tests with relatively low cost with the participation of search.  However, since we process the changes from binlog asynchronously (from the point of view of the clients who write to the database), we had to make it possible to wait until the changes concerning the document participating in the autotest will be processed by our service and sent to searchd . </p><br><p>  To do this, we made an endpoint in our service, which is exactly what it does, that is, it waits until all changes are applied to the specified transaction number.  To do this, immediately after we have made the necessary changes in the database, we request MariaDB <code>@@gtid_current_pos</code> and transfer it to the endpoint of our service.  If we have already applied all transactions to this position by this time, the service immediately responds that it can be continued.  If not, then in the gorutine, which is responsible for applying the changes, we create a subscription to this GTID, and as soon as he (or any one following him) is applied, we also allow the client to continue with the autotest. </p><br><p>  In PHP code, it looks something like this: </p><br><pre> <code class="plaintext hljs">&lt;?php declare(strict_types=1); use GuzzleHttp\ClientInterface; use GuzzleHttp\RequestOptions; use PDO; class RiverClient { private const REQUEST_METHOD = 'post'; /** * @var ClientInterface */ private $httpClient; public function __construct(ClientInterface $httpClient) { $this-&gt;httpClient = $httpClient; } public function waitForSync(PDO $mysqlConnection, PDO $sphinxConnection, string $riverAddr): void { $masterGTID = $mysqlConnection-&gt;query('SELECT @@gtid_current_pos')-&gt;fetchColumn(); $this-&gt;httpClient-&gt;request( self::REQUEST_METHOD, "http://{$riverAddr}/wait", [RequestOptions::FORM_PARAMS =&gt; ['gtid' =&gt; $masterGTID]] ); } }</code> </pre> <br><h2 id="rezultaty">  results </h2><br><p>  As a result, we were able to significantly reduce the delay between updating MariaDB and Sphinx. </p><br><p><img src="https://habrastorage.org/webt/lc/rs/rl/lcrsrlzpcw8bzhuptg5s42p6wou.png" alt="Graph of lag of a plain-index from a database"></p><br><p><img src="https://habrastorage.org/webt/7h/ik/ic/7hikichzuaqyszagbenen-9drhk.png" alt="Rt-index from the database"></p><br><p>  We also became much more confident that all updates reach all our Sphinx servers on time. </p><br><p>  In addition, search testing (both manual and automatic) has become much more enjoyable. </p><br><p>  Unfortunately, this was not free for us: the realtime index performance was slightly worse compared to the plain index. </p><br><p>  The following shows the distribution of the processing time of search queries depending on the time for a plain index. </p><br><p><img src="https://habrastorage.org/webt/op/ro/gm/oprogmvvdykt244nlbmzeldufhu.png" alt="Query execution timeline - plain"></p><br><p>  But the same schedule for the realtime index. </p><br><p><img src="https://habrastorage.org/webt/07/ii/ce/07iicewkxbb0qvsrrob6dbwoa2i.png" alt="Query execution timeline - realtime"></p><br><p>  It can be seen that the share of ‚Äúfast‚Äù requests has slightly decreased, while the share of ‚Äúslow‚Äù requests has increased. </p><br><h2 id="vmesto-zaklyucheniya">  Instead of conclusion </h2><br><p>  It remains to say that the code of the service described in this article, we have laid out <a href="https://github.com/superjobru/go-mysql-sphinx">in the public domain</a> .  Unfortunately, there is no detailed documentation yet, but if you wish, you can run an example of using this service through <code>docker-compose</code> . </p><br><h2 id="ssylki">  Links </h2><br><ol><li>  <a href="https://youtu.be/fjmMgFblBGQ">Video</a> and <a href="https://speakerdeck.com/narkq/kak-my-pieriekhodili-na-riealtaim-indieks">slides of the</a> report </li><li>  <a href="https://youtu.be/XAKvmIYeT2c">Video of the report of Andrey Smirnov and Vyacheslav Kryukov on Highload ++</a> </li><li>  <a href="https://github.com/siddontang/go-mysql">Go-mysql library</a> </li><li>  <a href="https://github.com/superjobru/go-mysql-sphinx">Service code with usage example</a> </li></ol></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/447526/">https://habr.com/ru/post/447526/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../447508/index.html">Sergey Zonov: ‚ÄúI did the first Spectrum because I was interested‚Äù</a></li>
<li><a href="../447510/index.html">GeekUniversity opens a set of design faculty</a></li>
<li><a href="../447512/index.html">And who did this? We automate the audit of information security</a></li>
<li><a href="../447516/index.html">How we dispersed CAD KOMPAS-3D ‚Üí Part 2</a></li>
<li><a href="../447522/index.html">What is useful you can get out of the logs of the workstation based on Windows</a></li>
<li><a href="../447528/index.html">Who is responsible for the quality?</a></li>
<li><a href="../447530/index.html">OceanLotus: Malvari update for macOS</a></li>
<li><a href="../447536/index.html">IdM implementation. Preparation for implementation by the customer</a></li>
<li><a href="../447538/index.html">CUBA 7: what's new?</a></li>
<li><a href="../447540/index.html">RHEL 8 Beta Workshop: We build working web applications</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>