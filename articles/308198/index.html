<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Code organization in Go</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dependencies Generics. They often appear on the list of problems in the Go community, but there is one problem that is rarely remembered - the organiz...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Code organization in Go</h1><div class="post__text post__text-html js-mediator-article"><p>  Dependencies  Generics.  They often appear on the list of problems in the Go community, but there is one problem that is rarely remembered - the organization of the code for your package. </p><br><p>  Each Go application I worked with seems to have its own answer to the question "How should I organize the code?".  Some applications put everything in one package, while others group logic by type or module.  Without a good strategy that all team members adhere to, you will sooner or later see that the code is heavily scattered across numerous packages.  We need a standard for the design of code in Go applications. </p><br><p>  I suggest a better approach.  By following a set of simple rules, we can ensure that the code is unbound, easily testable and the project structure is complete.  But before we dive into the details, let's look at the most commonly used approaches to structuring Go code. </p><a name="habracut"></a><br><h1>  The most frequent wrong approaches </h1><br><p>  There are a few of the most common approaches to organizing Go code, and each has its drawbacks. </p><br><h2>  Approach # 1: Monolith </h2><br><p>  Placing all the code in one package actually works very well for small applications.  This ensures that you are not faced with the problem of circular dependencies, because, inside your application, you generally have no dependencies. </p><br><p>  According to experience, this approach works great for applications up to 10 thousand lines of code.  Then it becomes very difficult to understand and isolate parts of the monolith code. </p><br><h1>  Approach # 2: Rails style </h1><br><p>  The second approach is to group the code according to its functionality.  For example, all handlers go to one package, controllers to another, and models to third.  I have seen this approach many times with former <a href="http://rubyonrails.org/">Rails</a> developers (including myself). </p><br><p> But with this approach there are two problems.  First, you get monstrous names.  You will have names like <code>controller.UserController</code> , in which you duplicate the package name in the type name.  In general, I consider myself an ardent supporter of a careful approach to names.  I am sure that good names are your best documentation, especially when you make your way through the code.  Names are also often an indicator of the quality of a code ‚Äî this is the first thing that another programmer will see when he first encounters your code. </p><br><p>  But the biggest problem, in fact, is circular dependencies.  Your functional types, separated by packages, may need each other.  And this will only work if these dependencies are one-sided, but in most cases your application will be more complicated. </p><br><h1>  Approach # 3: Grouping by module </h1><br><p>  This approach is similar to the previous one, with the exception that we group the code by module, not by function.  For example, you can split the code so that you have <code>user</code> and <code>accounts</code> packages. </p><br><p>  Here we have the same problems.  Again, horrible names like <code>users.User</code> and the same problem with circular dependencies, when our <code>accounts.Controller</code> <code>users.Controller</code> should interact with <code>users.Controller</code> . <code>users.Controller</code> and vice versa. </p><br><h1>  Best approach </h1><br><p>  The code organization strategy that I use in my projects includes 4 principles: </p><br><ol><li>  Root (main) package for domain types </li><li>  Package grouping by dependencies </li><li>  Use common <code>mock</code> package </li><li>  The <code>main</code> package brings together dependencies </li></ol><br><p>  These rules help isolate packages and establish a clear language within the application.  Let's see how each of these points works in practice. </p><br><h1>  1. Root package for domain types </h1><br><p>  Your application has a logical high-level language that describes the interaction of data and processes.  This is your domain.  If you are writing an e-commerce application, then your domain will include concepts such as customers, accounts, credit card debit and inventory.  If you are Facebook, then your domain is users, likes and interactions.  In other words, this is something that does not depend on the chosen technology. </p><br><p>  I have domain types in the main, root package.  This package contains only simple data types like User, in which there is only data about the user or the UserService interface for saving and querying user data. </p><br><p>  It might look something like this: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> myapp <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> User <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { ID <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Name <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Address Address } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> UserService <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { User(id <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) (*User, error) Users() ([]*User, error) CreateUser(u *User) error DeleteUser(id <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) error }</code> </pre> <br><p>  This makes your root package extremely simple.  It can also include types that perform some actions, but only if they depend entirely on other domain types.  For example, you can add a type that periodically polls your UserService.  But he should not make calls to external services or save to the database.  These are implementation details. </p><br><p>  <em>The root package should not depend on other packages inside your application!</em> </p><br><h1>  2. Package grouping by dependencies </h1><br><p>  Since it is not allowed to have external dependencies in the root package, we must move these dependencies to other subpackages.  In this approach, nested packages exist as an adapter between your domain and your implementation. </p><br><p>  For example, your UserService may be implemented as a PostgreSQL database.  You can add the postgres package to the application, which provides the postgres.UserService implementation: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> postgres <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"database/sql"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/benbjohnson/myapp"</span></span> _ <span class="hljs-string"><span class="hljs-string">"github.com/lib/pq"</span></span> ) <span class="hljs-comment"><span class="hljs-comment">// UserService represents a PostgreSQL implementation of myapp.UserService. type UserService struct { DB *sql.DB } // User returns a user for a given id. func (s *UserService) User(id int) (*myapp.User, error) { var u myapp.User row := db.QueryRow(`SELECT id, name FROM users WHERE id = $1`, id) if row.Scan(&amp;u.ID, &amp;u.Name); err != nil { return nil, err } return &amp;u, nil } // implement remaining myapp.UserService interface...</span></span></code> </pre> <br><p>  This completely isolates the dependency on PostgreSQL, which greatly simplifies testing and opens up a simple way to migrate to another database in the future.  It also allows you to create a dynamically changing architecture, if in the future you want to support other implementations, for example, on <a href="https://github.com/boltdb/bolt">BoltDB</a> . </p><br><p>  It also makes it possible to create implementation layers.  For example, you want to add an LRU cache in memory before your PostgreSQL implementation.  Then you simply add a UserCache that implements the UserService, and in which you wrap your PostgreSQL implementation: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> myapp <span class="hljs-comment"><span class="hljs-comment">// UserCache wraps a UserService to provide an in-memory cache. type UserCache struct { cache map[int]*User service UserService } // NewUserCache returns a new read-through cache for service. func NewUserCache(service UserService) *UserCache { return &amp;UserCache{ cache: make(map[int]*User), service: service, } } // User returns a user for a given id. // Returns the cached instance if available. func (c *UserCache) User(id int) (*User, error) { // Check the local cache first. if u := c.cache[id]]; u != nil { return u, nil } // Otherwise fetch from the underlying service. u, err := c.service.User(id) if err != nil { return nil, err } else if u != nil { c.cache[id] = u } return u, err }</span></span></code> </pre> <br><p>  We can see this approach also in the standard library.  <a href="https://golang.org/pkg/io/">io.Reader</a> is a domain type for reading bytes, and its implementations are grouped by dependencies - <a href="https://golang.org/pkg/archive/tar/">tar.Reader,</a> <a href="https://golang.org/pkg/compress/gzip/">gzip.Reader</a> , <a href="https://golang.org/pkg/mime/multipart/">multipart.Reader</a> .  And they can also be used in several layers.  You can often see <a href="https://golang.org/pkg/os/">os.File</a> wrapped in <a href="https://golang.org/pkg/bufio/">bufio.Reader</a> , which is wrapped in <a href="https://golang.org/pkg/compress/gzip/">gzip.Reader</a> , which, in turn, is wrapped in <a href="https://golang.org/pkg/archive/tar/">tar.Reader</a> . </p><br><h2>  Dependencies between dependencies </h2><br><p>  Your dependencies usually do not live by themselves.  You may want to store user data in PostgreSQL, but financial transaction data may be in an external service like <a href="https://stripe.com/">Stripe</a> .  In this case, we wrap our dependence on Stripe in a logical domain type - let's call it <code>TransactionService</code> . </p><br><p>  By adding our <code>TransactionService</code> to the <code>UserService</code> we unleash (decouple) our two dependencies: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> UserService <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { DB *sql.DB TransactionService myapp.TransactionService }</code> </pre> <br><p>  Now our dependencies communicate exclusively with the help of our domain language.  This means that we can switch from PostgreSQL to MySQL or switch from Stripe to another payment processor and do not have to change anything in dependencies. </p><br><h2>  Do not be limited to external dependencies. </h2><br><p>  This may sound strange, but I also isolate the dependencies on the standard library using the same method.  For example, the <code>net/http</code> package is just another dependency.  We can isolate it by adding an attached <code>http</code> package to the application. </p><br><p>  It may seem strange to have a package with the same name as the standard library, but this is intentional.  You will not have name conflicts if you do not use net / http elsewhere in your application.  The benefit of duplicating the name will be that you isolate all the HTTP code inside your http package: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> http <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"net/http"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/benbjohnson/myapp"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Handler <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { UserService myapp.UserService } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(h *Handler)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ServeHTTP</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">// handle request }</span></span></code> </pre> <br><p>  Now your http.Handler works as an adapter between your domain and the HTTP protocol. </p><br><h1>  3. Using a common <code>mock</code> package </h1><br><p>  Because our dependencies are isolated from others through domain types and interfaces, we can use these points of contact to introduce caps (mock). </p><br><p>  There are several stub libraries like <a href="https://github.com/golang/mock">GoMock</a> that will generate code for you, but I personally prefer to write them personally.  It seems to me that most of the tools for plugs are unnecessarily complicated. </p><br><p>  The plugs I use are usually very simple.  For example, the stub for the UserService looks like this: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> mock <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/benbjohnson/myapp"</span></span> <span class="hljs-comment"><span class="hljs-comment">// UserService represents a mock implementation of myapp.UserService. type UserService struct { UserFn func(id int) (*myapp.User, error) UserInvoked bool UsersFn func() ([]*myapp.User, error) UserInvoked bool // additional function implementations... } // User invokes the mock implementation and marks the function as invoked. func (s *UserService) User(id int) (*myapp.User, error) { s.UserInvoked = true return s.UserFn(id) } // additional functions: Users(), CreateUser(), DeleteUser()</span></span></code> </pre> <br><p>  Such a stub allows me to embed functions in all places where the <code>myapp.UserService</code> interface is used to validate arguments.  return the expected values ‚Äã‚Äãor embed erroneous data. </p><br><p>  Suppose we want to test our http.Handler, which we added just above: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> http_test <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"testing"</span></span> <span class="hljs-string"><span class="hljs-string">"net/http"</span></span> <span class="hljs-string"><span class="hljs-string">"net/http/httptest"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/benbjohnson/myapp/mock"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TestHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(t *testing.T)</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">// Inject our mock into our handler. var us mock.UserService var h Handler h.UserService = &amp;us // Mock our User() call. us.UserFn = func(id int) (*myapp.User, error) { if id != 100 { t.Fatalf("unexpected id: %d", id) } return &amp;myapp.User{ID: 100, Name: "susy"}, nil } // Invoke the handler. w := httptest.NewRecorder() r, _ := http.NewRequest("GET", "/users/100", nil) h.ServeHTTP(w, r) // Validate mock. if !us.UserInvoked { t.Fatal("expected User() to be invoked") } }</span></span></code> </pre> <br><p>  Our stub allowed to completely isolate this unit-test and test only part of the HTTP protocol. </p><br><h1>  4. The <code>main</code> package combines dependencies together </h1><br><p>  With all these addiction packages, you can ask how they all come together.  And this is exactly the job for the <code>main</code> package. </p><br><h2>  <code>main</code> package organization </h2><br><p>  An application can consist of several binary executables, so we will use the standard Go agreement on the location of the main package in the cmd / subdirectory.  For example, our project may have an executable file <code>myappctl</code> server, plus an additional <code>myappctl</code> binary to manage the server from the terminal.  We place the file as follows: </p><br><pre> <code class="hljs go">myapp/ cmd/ myapp/ main.<span class="hljs-keyword"><span class="hljs-keyword">go</span></span> myappctl/ main.<span class="hljs-keyword"><span class="hljs-keyword">go</span></span></code> </pre> <br><h2>  Dependency injection at compile time </h2><br><p>  The term ‚Äúdependency injection‚Äù has received a bad reputation.  Usually, people immediately start thinking about <a href="https://projects.spring.io/spring-framework/">Spring's</a> XML files.  But in fact, this term means that we are passing dependencies to an object, and not an object looking for them ourselves. </p><br><p>  The <code>main</code> package is the place where the choice of which dependencies to embed in which objects occurs.  Since this package usually simply interconnects various pieces of the application, it is usually quite small and simple code: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"log"</span></span> <span class="hljs-string"><span class="hljs-string">"os"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/benbjohnson/myapp"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/benbjohnson/myapp/postgres"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/benbjohnson/myapp/http"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">// Connect to database. db, err := postgres.Open(os.Getenv("DB")) if err != nil { log.Fatal(err) } defer db.Close() // Create services. us := &amp;postgres.UserService{DB: db} // Attach to HTTP handler. var h http.Handler h.UserService = us // start http server... }</span></span></code> </pre> <br><p>  It is also important to understand that the main package is also an adapter.  It connects the terminal with your domain. </p><br><h1>  Conclusion </h1><br><p>  Application design is a complex issue.  It is necessary to take a lot of decisions and without a good set of principles, the problem becomes even worse.  We looked at several approaches to structuring Go applications and looked at their shortcomings. </p><br><p>  I‚Äôm sure that dependency-based code organization simplifies the design and makes the code more understandable.  First we define the language of our domain.  Then, isolate the dependencies.  Next, create stubs for tests.  And at the end, we glue it all together using the main package. </p><br><p>  Look at this approach in your next application.  If you have questions or want to discuss application design, I am available on Twitter at <a href="https://twitter.com/benbjohnson">@benbjohnson</a> or as benbjohnson on the <a href="https://gophersinvite.herokuapp.com/">Slack Go channel</a> . </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/308198/">https://habr.com/ru/post/308198/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../308186/index.html">"Front End Developer" or who I am by profession</a></li>
<li><a href="../308188/index.html">DIY DI in Ruby</a></li>
<li><a href="../308190/index.html">The digest of fresh materials from the world of the frontend for the last week No. 224 (August 15 - 21, 2016)</a></li>
<li><a href="../308192/index.html">As I increased my productivity or magic kick for smart and lazy</a></li>
<li><a href="../308196/index.html">Pechkin-mail "wiki": Checklist for email newsletters</a></li>
<li><a href="../308200/index.html">What is executable business processes. Introduction to the subject area</a></li>
<li><a href="../308204/index.html">Working with DB in CleverStyle Framework</a></li>
<li><a href="../308206/index.html">Open Day at Kaspersky Lab</a></li>
<li><a href="../308208/index.html">Container Management with LXD</a></li>
<li><a href="../308212/index.html">At the request of readers, check the LDAP server code ReOpenLDAP</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>