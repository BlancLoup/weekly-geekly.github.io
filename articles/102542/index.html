<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Thread-safe queue without locks</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Task 
 During the development of an interactive application, I needed to transfer data from one stream to another while avoiding any delays in both th...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Thread-safe queue without locks</h1><div class="post__text post__text-html js-mediator-article"><h4>  Task </h4><br>  During the development of an interactive application, I needed to transfer data from one stream to another while avoiding any delays in both the transmitting and receiving streams.  Data must be transmitted one by one, i.e.  in the form of a queue. <br><br><a name="habracut"></a><br>  I found two existing solutions used to securely transfer data from one thread to another - the use of mutually exclusive objects (MUTually EXclusive objects) and the lock pattern: Read-Write Lock Pattern.  However, these solutions were not suitable for solving my problem.  MUTEX objects at a time can only be used by one stream, so if one stream uses a MUTEX object, another thread must wait.  The second option has a similar disadvantage - if reading is in progress, then the stream producing the record must wait for the lock to be released, and vice versa - if there is a recording, then the stream producing the read waits for the end of the recording. <br><br>  Since the existing solutions did not fit, we had to develop a solution that would help in this case.  Based on the task, the solution requirements were as follows: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  The data structure used is a queue. </li><li>  The solution must support one stream that writes data and one stream that reads data. </li><li>  The solution should allow to write and read data simultaneously. </li></ul><br><br><h4>  Decision </h4><br>  The decision was based on a queue built on the basis of a unidirectional linked list, to which another element was added, which is always present in it, i.e.  the queue never became empty.  The criterion that there are no elements in the queue was the fact that the pointers to the head and to the tail of the queue showed the same element, i.e.  were equal: <br><br><img src="https://habrastorage.org/getpro/geektimes/post_images/66c/f3f/343/66cf3f3435fc4dfbc7708cb51461fea5.png" alt="empty queue"><br><br>  When recording, a new element is first created and only then the pointer to the tail of the queue is transferred.  Due to the fact that the pointer to the tail is transferred at the last moment, when the data in the queue already is avoided the possibility of a conflict of writing and reading: <br><br><img src="https://habrastorage.org/getpro/geektimes/post_images/c13/b1a/34d/c13b1a34dc50eee563b3064cf741a7dc.png" alt="writing"><br><br>  When reading, the pointer to the head of the queue is first transferred, then the empty queue element is removed, and finally the data from the queue is read.  At the same time, the read data is deleted, only the ‚Äúpackage‚Äù remains, which becomes a new empty element: <br><br><img src="https://habrastorage.org/getpro/geektimes/post_images/569/362/623/569362623d0d3037c326c045264ccd1f.png" alt="image"><br><br>  As a result, reading and writing are completely isolated from each other, i.e.  Two streams can read and write simultaneously, without interfering with each other.  Conflicts can be avoided due to the constant presence of at least one element in the queue. <br><br><h4>  Implementation </h4><br>  The queue element was implemented as a template as follows: <br><br> <code>template &lt;class E&gt; <br> class QueueItem <br> { <br> public: <br> E* data; <br> QueueItem* next; <br> <br> QueueItem(E* data); <br> }; <br> <br> template &lt;class E&gt; <br> QueueItem&lt;E&gt;::QueueItem(E* data) <br> { <br> this-&gt;data = data; <br> next = NULL; <br> } <br></code> <br><br>  When creating a queue, an empty element is immediately created: <br><br> <code>template &lt;class T&gt; <br> Queue&lt;T&gt;::Queue() <br> { <br> QueueItem&lt;T&gt;* stub = new QueueItem&lt;T&gt;(NULL); <br> <br> head = stub; <br> tail = stub; <br> } <br></code> <br><br>  Checking for a void queue is done by simply comparing pointers to the head and tail of the queue: <br><br> <code>template &lt;class T&gt; <br> bool Queue&lt;T&gt;::empty() <br> { <br> return head == tail; <br> } <br></code> <br><br>  When writing a new element, the element is first written to the list and only then the pointer to the tail of the queue is transferred: <br><br> <code>template &lt;class T&gt; <br> void Queue&lt;T&gt;::enqueue(T* value) <br> { <br> QueueItem&lt;T&gt;* item = new QueueItem&lt;T&gt;(value); <br> <br> item-&gt;data = value; <br> item-&gt;next = NULL; <br> <br> tail-&gt;next = item; <br> <br> tail = item; <br> }</code> <br> <br>  Reading is made as standard: <br><br> <code>template &lt;class T&gt; <br> T* Queue&lt;T&gt;::dequeue() <br> { <br> if (head == tail) <br> return NULL; // queue is empty <br> <br> QueueItem&lt;T&gt;* tmp = head; <br> head = head-&gt;next; <br> delete tmp; <br> <br> return head-&gt;data; <br> } <br></code> <br><br>  It is important to note that the responsibility for returning the memory used for data transfer lies with the consumer thread. <br><br><h4>  Total </h4><br><br>  This solution is an example of a thread-safe queue implementation that can be applied in some particular cases, namely when: <br><ul><li>  The essence of the task involves the use of the queue. </li><li>  It is necessary to avoid delays in writing and reading from the queue (for example, in computer games or other interactive programs). </li><li>  There is only one stream transmitting data and only one stream receiving data.  This restriction can be extended to the case of several transmitting and one receiving stream will create a separate queue for each transmitting stream. </li></ul></div><p>Source: <a href="https://habr.com/ru/post/102542/">https://habr.com/ru/post/102542/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../102536/index.html">Sixteen of thirty relatively new and free fonts</a></li>
<li><a href="../102537/index.html">Opera Widget - OpenBoobs Reader</a></li>
<li><a href="../102539/index.html">Draganflyer X8 - the dream of any spy</a></li>
<li><a href="../102540/index.html">Live Migration in geographically separated data centers</a></li>
<li><a href="../102541/index.html">Pin-mix - freedom of movement for all</a></li>
<li><a href="../102545/index.html">Sequel Pro - MySQL Manager for Macs - Overview</a></li>
<li><a href="../102546/index.html">Results of the grant competition</a></li>
<li><a href="../102548/index.html">Error in Windows 7</a></li>
<li><a href="../102549/index.html">Conceptual vulnerability in the DLL loading mechanism (MSA2269637)</a></li>
<li><a href="../102550/index.html">Mafia II - hurry to see</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>