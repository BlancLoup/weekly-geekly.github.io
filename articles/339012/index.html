<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Scheduling tasks in Android using JobScheduler and IntentService</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Sometimes, when developing for the Android OS, it is necessary to perform resource-intensive operations periodically, regularly or on demand, and for ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Scheduling tasks in Android using JobScheduler and IntentService</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/webt/59/db/92/59db92090a43c813371365.png"></p><br><p>  Sometimes, when developing for the Android OS, it is necessary to perform resource-intensive operations periodically, regularly or on demand, and for these operations it is important, for example, that the Internet is available or that the device ‚Äúdoes not sleep‚Äù.  Most often, when solving such problems, AlarmManager, WakefulBroadcastReceiver are used, or else WakeLock is controlled manually.  All this is not recommended in the documentation for developers for Android, and WakefulBroadcastReceiver is already marked as <em>deprecated</em> with API level 26.0.0. </p><br><p>  So, what can we do to follow Google‚Äôs recommendations and create more flexible applications on Android 5.0+, in which more attention is paid to energy conservation?  If you are ready to set the minimum API level 21.0.0 for your application, I suggest using an example of using JobScheduler in conjunction with IntentService for consistently performing laborious tasks under the cat. </p><a name="habracut"></a><br><h2 id="sut-voprosa-i-podnyatyh-problem">  The crux of the issue and raised issues </h2><br><p>  It is enough to open the documentation on the <a href="https://developer.android.com/reference/android/support/v4/content/WakefulBroadcastReceiver.html">WakefulBroadcastReceiver</a> class to see an interesting situation: the class is added in version 22.0.0 of the API, and marked as <em>deprecated</em> in version 26.0.0.  We can <u>assume</u> that, at first, Android developers decided to add a convenient class for performing tasks with <em>WakeLock</em> retention, but then it turned out that no one guarantees that the application will work in the foreground, and indeed when every "smart" application tries to keep <em>WakeLock</em> , when device save energy?  And the principle of work of <em>WakefulBroadcastReceiver</em> began to go against the urge to extend the battery charge life, because, among other things, an unclosed receiver could lead to <em>WakeLock</em> 's leaks. </p><br><p>  On the other hand, ordinary developers may wonder how it is safe to perform periodic tasks with all the limitations, for example, when <em>Doze mode is</em> active?  In order to balance the balance of limitations and opportunities, <a href="https://developer.android.com/reference/android/app/job/JobScheduler.html">JobScheduler</a> was created, which takes upon itself the question of when the task can be completed, how appropriately it can be done, if it is really needed, and how not to violate the energy saving policy and not lose where Anyone not let <em>go of WakeLock</em> . </p><br><p>  While this article was being prepared, an <a href="https://habrahabr.ru/post/336120/">article by another author</a> appeared on Habr√© in which a little more theory was revealed and a little less attention was paid to practice.  It will be useful for a quick start and a deeper understanding of <em>JobScheduler</em> ‚Äôs existing alternatives. </p><br><h2 id="primer-sozdaniya-proekta-s-jobscheduler-i-intentservice">  An example of creating a project with JobScheduler and IntentService </h2><br><p>  For the sake of simplicity, let us imagine that we have the task of recording the word "Exercise" to a file, while we need the Internet, and preferably not mobile, because our task is not worth wasting mobile user traffic.  At the same time, we want each new task to record a word to be performed one after another.  Since we can‚Äôt block the main thread (here, work with files and, possibly, some network requests), and our tasks can line up, <a href="https://developer.android.com/reference/android/app/IntentService.html">IntentService</a> comes to <a href="https://developer.android.com/reference/android/app/IntentService.html">help</a> . </p><br><p>  To fully reproduce the steps described in this article, you need to create a new project without activation, with a minimum version of SDK 21. Also, all actions can be performed in an existing project with a minimum version of SDK no lower than 21. </p><br><h3 id="dobavlenie-intentservice-dlya-obrabotki-zadach-v-fone">  Adding an IntentService to handle tasks in the background </h3><br><p>  Add a new <em>IntentService</em> to the project, call it <em>ExerciseIntentService</em> , use the standard approach based on automatically generated methods, clean up the excess and rename the methods and constants under our conditions. </p><br><p>  As a result of simple manipulations, we obtain the following body for <em>ExerciseIntentService</em> : </p><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String ACTION_WRITE_EXERCISE = <span class="hljs-string"><span class="hljs-string">"com.github.ihandy.jobschedulerdemo.action.ACTION_WRITE_EXERCISE"</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ExerciseIntentService</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(<span class="hljs-string"><span class="hljs-string">"ExerciseIntentService"</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">startActionWriteExercise</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Context context)</span></span></span><span class="hljs-function"> </span></span>{ Intent intent = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Intent(context, ExerciseIntentService.class); intent.setAction(ACTION_WRITE_EXERCISE); context.startService(intent); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onHandleIntent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Intent intent)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (intent != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String action = intent.getAction(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ACTION_WRITE_EXERCISE.equals(action)) { handleActionWriteExercise(); } } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handleActionWriteExercise</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { FileWriter fileWriter = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FileWriter(getFilesDir().getPath() + <span class="hljs-string"><span class="hljs-string">"exercise.txt"</span></span>); fileWriter.write(<span class="hljs-string"><span class="hljs-string">"Exercise"</span></span>); fileWriter.close(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (IOException e) { e.printStackTrace(); } }</code> </pre> <br><p>  And so, the service that will directly perform our similarly conditionally-laborious tasks in order is ready.  In order to create and schedule tasks, you need an entry point, which you can use as a <a href="https://developer.android.com/reference/android/content/BroadcastReceiver.html">BroadcastReceiver</a> . </p><br><h3 id="dobavlenie-broadcastreceiver-dlya-inicializacii-zadach">  Add BroadcastReceiver to initialize tasks </h3><br><p>  Add the standard means <em>BroadcastReciever</em> and call it <em>ExerciseRequestsReceiver</em> .  In the future, we will be able to send Broadcasts to our application from anywhere, so that it schedules tasks (for example, this can be done with the help of instrumental tests, which will be shown closer to the end of the article). </p><br><p>  The minimum required <em>ExerciseRequestsReceiver</em> code looks like this: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String ACTION_PERFORM_EXERCISE = <span class="hljs-string"><span class="hljs-string">"ACTION_PERFORM_EXERCISE"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> sJobId = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onReceive</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Context context, Intent intent)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (intent.getAction()) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ACTION_PERFORM_EXERCISE: scheduleJob(context); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IllegalArgumentException(<span class="hljs-string"><span class="hljs-string">"Unknown action."</span></span>); } }</code> </pre> <br><p>  <code>String ACTION_PERFORM_EXERCISE</code> - action to identify the need to start the task scheduling process. <br>  <code>int sJobId</code> is the variable for the task identifier that will be used when scheduling tasks. <br>  <code>scheduleJob(context)</code> - a method call that will contain all the necessary logic for scheduling a task. </p><br><p>  Now, when we received Broadcast, we could send an intent to our <em>ExerciseIntentService</em> , and everything would be fine, only in our case <em>WakeLock is</em> needed, and since we agreed to no longer use <em>WakefulBroadcastReceiver</em> , we need to create and schedule a new task for <em>JobScheduler</em> , and then he will do everything for us (almost). </p><br><p>  By the way, when using <em>JobScheduler, you</em> do not need permission to <a href="https://developer.android.com/reference/android/os/PowerManager.WakeLock.html">WakeLock</a> , unlike other ways to solve this problem. </p><br><h3 id="realizaciya-naslednika-jobservice-dlya-obrabotki-sobytiy-ot-jobscheduler">  Implementing a JobService inheritor to handle events from JobScheduler </h3><br><p>  <em>JobScheduler</em> requires a separate service inherited from the <em>JobService</em> .  Let's call it <em>ExerciseJobService</em> and add it as a regular service, replacing the parent class and adding permission to the module manifest: </p><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">service</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">".ExerciseJobService"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:enabled</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"true"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:exported</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"true"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:permission</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"android.permission.BIND_JOB_SERVICE"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">service</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  Allowing <code>android.permission.BIND_JOB_SERVICE</code> requires that this service be able to interact with <em>JobSchedule</em> r. </p><br><p>  In addition, two <code>onStartJob()</code> and <code>onStopJob()</code> methods are required for implementation. </p><br><ul><li>  <code>onStartJob()</code> is called when the time (condition) for the scheduled task comes.  This method is called in the main thread and the developer must independently carry out any heavy operations into separate threads (in our case, this is already provided for - we use the <em>IntentService</em> ).  When delegating the task to other threads from <code>onStartJob()</code> you must return <strong>true</strong> , and if all the necessary actions have already been performed in the body of this method, you need to return <strong>false</strong> . </li><li>  <code>onStopJob()</code> is called when the required conditions for the task have ceased to be performed or the time allotted for the task has been exhausted.  Calling this method informs the service that all background tasks should immediately stop running.  It is best to provide secure stop execution logic to ensure data integrity. </li></ul><br><p>  To correctly handle the situation with <code>onStopJob()</code> you can implement static flags, any additional broadcasts, and you can also use other means of service interaction.  In the current article this will be omitted and the assumption introduced that if our <em>IntentService</em> failed to complete the task, then nothing terrible for the application logic and data integrity will not occur. </p><br><p>  <code>onStopJob</code> also has a return value, if this is <strong>true</strong> - then <em>JobScheduler</em> will place the interrupted task in the execution queue again, <strong>false</strong> - the task will be considered completed and will be removed from the queue if it was not periodic. </p><br><p>  Since the processing of emergency situations is omitted, we will return <em>true</em> from this method so that the task is re-planned, at the same time it will allow us to consider the use of the repeat criterion. </p><br><p>  Thus, by setting the return values ‚Äã‚Äãfrom the two main methods and adding the launch of our <em>ExerciseIntentService</em> in <code>onStartJob()</code> , we get the following sufficiently large service: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ExerciseJobService</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JobService</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ExerciseJobService</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onStartJob</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(JobParameters params)</span></span></span><span class="hljs-function"> </span></span>{ ExerciseIntentService.startActionWriteExercise(getApplicationContext()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onStopJob</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(JobParameters params)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; } }</code> </pre> <br><p>  At the moment, a minimal set of classes has been prepared for implementing the task through <em>JobScheduler</em> in the <em>IntentService</em> , namely: <em>ExerciseIntentService</em> - performs the operations directly required for the task in separate streams, <em>ExerciseJobService</em> - catches events from <em>JobScheduler</em> 'a and runs <em>ExerciseIntentService</em> , and <em>ExerciseRequestsReceiver</em> - catches events the work of our complex, where we catch broadcasts from the outside and have to initialize the task for <em>JobScheduler</em> , than we go ahead. </p><br><h3 id="sozdanie-novoy-zadachi-dlya-jobscheduler">  Create a new task for JobScheduler </h3><br><p>  To create a task for <em>JobScheduler, you</em> need <a href="https://developer.android.com/reference/android/app/job/JobInfo.Builder.html">JobInfo.Builder</a> .  Its constructor takes two parameters: <em>the task ID</em> and the <em>ComponentName of</em> our <em>ExerciseJobService</em> . </p><br><h4 id="identifikator-zadachi-i-componentname">  Task ID and ComponentName </h4><br><p>  With an identifier, everything is simple (but not without nuances) - any integer value: </p><br><ul><li>  permanent, if we want to update an already scheduled task or control the uniqueness of a periodic task; </li><li>  unique value if we want to create a queue of individual tasks. </li></ul><br><div class="spoiler">  <b class="spoiler_title">Note about using UID</b> <div class="spoiler_text"><p>  If suddenly your application is systemic, or you have several applications with one <em>sharedUserId</em> , then you need to take into account an additional condition: id should not intersect among all applications with one uid.  Thus, if the application uses <em>android.uid.system</em> , then you need to take into account that some system tasks also use <em>JobScheduler</em> , and the uniqueness of id must be maintained independently. </p><br><p>  By the way, when using such methods in <em>JobScheduler</em> as <code>removeAll()</code> we can delete other people's tasks with the same uid. </p><br><p>  <a href="https://android-developers.googleblog.com/2017/10/working-with-multiple-jobservices.html">An article in English</a> about how to control this situation. </p></div></div><br><p>  In this example, you do not need to bother about the UID and the incremental value <em>sJobId is</em> used as an identifier. </p><br><p>  sJobId is defined as follows: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> sJobId = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br><p>  With ComponentName, everything is much simpler, this is the object in the constructor of which <em>ExerciseJobService.class</em> is passed. </p><br><pre> <code class="java hljs">ComponentName jobService = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ComponentName(context, ExerciseJobService.class); JobInfo.Builder exerciseJobBuilder = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> JobInfo.Builder(sJobId++, jobService);</code> </pre> <br><h4 id="inicializaciya-parametrov-s-pomoschyu-jobinfobuilder">  Parameter initialization using JobInfo.Builder </h4><br><p>  Below we consider the main set of methods JobInfo.Builder. </p><br><ul><li><pre> <code class="java hljs">exerciseJobBuilder.setMinimumLatency(TimeUnit.SECONDS.toMillis(<span class="hljs-number"><span class="hljs-number">1</span></span>));</code> </pre> <br><p>  the minimum time that will pass before the task is completed, in other words, the delayed start time. </p><br></li><li><pre> <code class="java hljs">exerciseJobBuilder.setOverrideDeadline(TimeUnit.SECONDS.toMillis(<span class="hljs-number"><span class="hljs-number">5</span></span>));</code> </pre> <br><p>  maximum time during which the task can be in the queue / scheduled state.  If after 5 seconds (in our case) the favorable conditions have not come, the task will begin to be executed no matter what (if this does not contradict other <em>JobScheduler</em> policies).  If not used, then the task will be performed only when the necessary conditions occur. </p><br></li><li><pre> <code class="java hljs">exerciseJobBuilder.setRequiredNetworkType(JobInfo.NETWORK_TYPE_UNMETERED);</code> </pre> <br><p>  connection type is set, for example, we need internet, but for it to be free WIFi (not hotspot) or Ethernet, then we choose <code>NETWORK_TYPE_UNMETERED</code> . </p><br></li><li><pre> <code class="java hljs">exerciseJobBuilder.setRequiresDeviceIdle(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>);</code> </pre> <br><p>  Determines the state when the user does not interact with the device, in our case it does not matter. </p><br></li><li><pre> <code class="java hljs">exerciseJobBuilder.setRequiresCharging(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>);</code> </pre> <br><p>  In our example, we assume that it makes no difference to us whether the device is charging or not. </p><br></li></ul><br><p>  You can set a retry criterion for the task (more on this below): </p><br><ul><li><pre> <code class="java hljs">exerciseJobBuilder.setBackoffCriteria(TimeUnit.SECONDS.toMillis(<span class="hljs-number"><span class="hljs-number">10</span></span>), JobInfo.BACKOFF_POLICY_LINEAR);</code> </pre> <br></li></ul><br><p>  In addition, it is possible to make the task periodic: </p><br><ul><li><pre> <code class="java hljs">exerciseJobBuilder.setPeriodic();</code> </pre> <br></li></ul><br><h4 id="periodicheskie-zadachi">  Periodic Tasks </h4><br><p>  When we set the task periodicity, we are faced with logical constraints: </p><br><ol><li>  <code>setMinimumLatency()</code> and <code>setOverrideDeadline()</code> cannot be used, since it does not make sense - the task should somehow be executed once during a given interval, and no additional restrictions from above or below are allowed.  On the other hand, sometimes we need to wait for something, and then start a periodic task - here we cannot add such a condition, if you need to wait, it means you need to wait before adding a task for execution. </li><li>  in <em>JobService</em> in <code>onStopJob()</code> we can not return <code>true</code> - the interrupted periodic task will not be removed from the queue; next time it will be executed according to the schedule. </li><li>  No one guarantees that the task will be performed smoothly through the specified interval, it will simply be executed no more than 1 time during this interval. </li></ol><br><p>  These are the main differences of the periodic task from the usual one.  In the current example, we will not make the task periodic. </p><br><h4 id="kriteriy-povtora-vypolneniya-zadachi">  Repeat task criterion </h4><br><p>  <code>setBackoffCriteria()</code> allows you to specify a rule that will be used to <code>onStopJob()</code> task execution if necessary (for example, in <code>onStopJob()</code> we returned <em>true</em> ). </p><br><p>  <em>JobScheduler</em> offers us two policies: linear and exponential. </p><br><p>  The formula for linear politics is as follows: </p><br><pre> <code class="java hljs">retry_time(current_time, num_failures) = current_time + initial_backoff_millis * num_failures, num_failures &gt;= <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br><p>  those.  from the current time, the next attempt will be made after a specified amount of time multiplied by the number of failures. </p><br><p>  Formula exponential policy: </p><br><pre> <code class="java hljs">retry_time(current_time, num_failures) = current_time + initial_backoff_millis * <span class="hljs-number"><span class="hljs-number">2</span></span> ^ (num_failures - <span class="hljs-number"><span class="hljs-number">1</span></span>), num_failures &gt;= <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br><p>  Here the time of the next attempt grows in much larger steps. </p><br><p>  Everything is quite simple and transparent, but what will happen if our task cannot be executed successfully many times, 10, 20 ...?  With a given initial retry time of 1 minute to 10 attempts, it will take almost an hour.  It is not easy enough to catch such situations, because we cannot predict what will happen in an hour.  <em>JobScheduler</em> limits such repetitions to five hours. </p><br><p>  Thus, the <code>setBackoffCriteria()</code> parameter should be handled very carefully, carefully considering the initial time and type of policy in accordance with the tasks.  You may also have to perform additional processing, for example, the number of retries and delete the task from <em>JobScheduler</em> . </p><br><h3 id="otpravka-zadachi-na-vypolnenie">  Submitting task for execution </h3><br><p>  Thus, we have <em>JobBuilder</em> ready with all the parameters we need.  To add a task to the execution queue, you need to get a <em>JobScheduler</em> instance from the system: </p><br><pre> <code class="java hljs">JobScheduler jobScheduler = (JobScheduler) context.getSystemService(Context.JOB_SCHEDULER_SERVICE);</code> </pre> <br><p>  And call the method to add <em>JobInfo</em> from the builder: </p><br><pre> <code class="java hljs">jobScheduler.schedule(exerciseJobBuilder.build());</code> </pre> <br><p>  For reliability, you can check the return value of the last method, which tells us about the successful or not successful addition of the task to the queue. </p><br><p>  Further, when <em>JobScheduler</em> finds that the conditions for performing the task are optimal, the <code>onStartJob()</code> method is <code>onStartJob()</code> in <em>ExerciseJobService</em> , which has already been parsed above. </p><br><h3 id="proverka-i-otladka">  Check and debug </h3><br><p>  To sum up, as a result, we got a test application that allows you to plan one-time tasks that perform a conditionally heavy operation in the <em>IntentService</em> . </p><br><p>  To test the performance, I propose to add a small tool test that looks like this: </p><br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sendDemoBroadcast</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ Context appContext = InstrumentationRegistry.getTargetContext(); Intent demoIntentForBroadcast = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Intent(appContext, ExerciseRequestsReceiver.class); demoIntentForBroadcast .setAction(ExerciseRequestsReceiver.ACTION_PERFORM_EXERCISE); appContext.sendBroadcast(demoIntentForBroadcast); }</code> </pre> <br><p>  Also, to check the work of the example, some logs were added to the source code, which are not listed above in the excerpts. </p><br><p>  If we run the test, we will see that our task with "id: 1" starts and ends, starts and ends ... More precisely, it is forcibly completed by <em>JobScheduler</em> . </p><br><h4 id="vypolnenie-zadachi-v-otdelnyh-potokah-i-opoveschenie-servisa-o-zavershenii">  Executing a task in separate threads and notifying the service of completion </h4><br><p>  In this example, from the <code>onStartJob()</code> method, we returned <em>true</em> , which means that we told <em>JobScheduler</em> that the task continues somewhere in the sidestream.  Since we are not notified of the completion of the task, <em>JobScheduler</em> terminates it forcibly, and since we also return <em>true</em> <code>onStopJob()</code> , the retry policy is triggered, and the task is rescheduled and restarted. </p><br><p>  To prevent this from happening, you need to call the <code>jobFinished()</code> method in the <em>ExerciseJobService</em> service class, I will try to explain its use and the various options for transferring information about the completion of the task from the <em>IntentService</em> in the following articles. </p><br><p>  This completes the creation of a test case, it is ready for use and application in work projects for scheduling tasks.  <em>IntentService</em> was used here to perform tasks in the background, but other methods are possible, for example, using <a href="https://developer.android.com/reference/java/util/concurrent/ThreadPoolExecutor.html">ThreadPoolExecutor</a> or <a href="https://developer.android.com/reference/android/os/HandlerThread.html">HandlerThread</a> .  And in the case of development exclusively for Android O and above, I recommend also to pay attention to the <a href="https://developer.android.com/reference/android/support/v4/app/JobIntentService.html">JobIntentService</a> . </p><br><p>  The full code for the example in question is provided on <a href="https://github.com/iHandy/JobSchedulerDemo">GitHub</a> . </p><br><p>  You can also read the official <a href="https://developer.android.com/samples/JobScheduler/index.html">JobScheduler</a> implementation <a href="https://developer.android.com/samples/JobScheduler/index.html">example from the Activity on developer.android.com</a> . </p><br><hr><br><p>  Illustration: <a href="https://vk.com/welcome_to_my_personal_space">Anni ART</a> (copying and reproduction only with the consent of the author). </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/339012/">https://habr.com/ru/post/339012/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../338996/index.html">‚ÄúWe have a normal UX. Ux? Not before us, we have deadlines here! ‚ÄùRemoving the mantle is my interpretation</a></li>
<li><a href="../338998/index.html">Learn OpenGL. Lesson 3.3 - 3D model class</a></li>
<li><a href="../339000/index.html">On the issue of strangeness and systematic approach</a></li>
<li><a href="../339004/index.html">Useful lifehacks: answering the most popular questions (Part 2)</a></li>
<li><a href="../339008/index.html">Simple Scada in Python</a></li>
<li><a href="../339014/index.html">PostgreSQL load testing using JMeter, Yandex.Tank and Overload</a></li>
<li><a href="../339016/index.html">Five things to know about the Spring Framework 5</a></li>
<li><a href="../339018/index.html">"Tulipmania": the stock bubble, which was not</a></li>
<li><a href="../339020/index.html">Security Week 39: An Evening of Delightful Stories on How Business Can't Care About Security</a></li>
<li><a href="../339022/index.html">Uneducated youth</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>