<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>The whole truth about RTOS. Article # 29. Interrupts in the Nucleus SE</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="All modern microprocessors and microcontrollers contain any interrupt mechanisms. These mechanisms are necessary to ensure the ‚Äúresponsiveness‚Äù requir...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>The whole truth about RTOS. Article # 29. Interrupts in the Nucleus SE</h1><div class="post__text post__text-html js-mediator-article">  All modern microprocessors and microcontrollers contain any interrupt mechanisms.  These mechanisms are necessary to ensure the ‚Äúresponsiveness‚Äù required by many applications.  Of course, responsiveness and predictability are the main goal when using RTOS, but they also oppose each other.  Using interrupts can disrupt the integrity of the real-time OS.  This problem and its solution were addressed in a previous article (# 4 and # 6).  In this article, we will look at the interrupt handling strategy used in Nucleus SE.  In all cases, interrupts are NOT controlled by Nucleus SE: they are processed when they occur according to priority and vectors in the usual way.  The execution time is simply ‚Äústolen‚Äù from the available time in the code of the main application and the scheduler.  Obviously, it follows from this that all interrupt handlers should be simple, short and fast. <br><br><img src="https://habrastorage.org/webt/xf/fd/p4/xffdp4n9qbgy9yoqppflrg0a6as.jpeg"><br><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Previous articles in the series:</b> <div class="spoiler_text">  <a href="https://habr.com/ru/post/455072/">Article # 28.</a>  <a href="https://habr.com/ru/post/455072/">Software Timers</a> <br>  <a href="https://habr.com/ru/post/454272/">Article # 27.</a>  <a href="https://habr.com/ru/post/454272/">System time</a> <br>  <a href="https://habr.com/ru/post/433374/">Article # 26.</a>  <a href="https://habr.com/ru/post/433374/">Channels: Auxiliary Services and Data Structures</a> <br>  <a href="https://habr.com/ru/post/433046/">Article # 25.</a>  <a href="https://habr.com/ru/post/433046/">Data Channels: Introduction and Basic Services</a> <br>  <a href="https://habr.com/ru/post/432804/">Article # 24.</a>  <a href="https://habr.com/ru/post/432804/">Queues: helper services and data structures</a> <br>  <a href="https://habr.com/post/431378/">Article # 23.</a>  <a href="https://habr.com/post/431378/">Queues: introduction and basic services</a> <br>  <a href="https://habr.com/post/431118/">Article # 22.</a>  <a href="https://habr.com/post/431118/">Mailboxes: ancillary services and data structures</a> <br>  <a href="https://habr.com/post/430856/">Article # 21.</a>  <a href="https://habr.com/post/430856/">Mailboxes: Introduction and Basic Services</a> <br>  <a href="https://habr.com/post/429588/">Article # 20.</a>  <a href="https://habr.com/post/429588/">Semaphores: helper services and data structures</a> <br>  <a href="https://habr.com/post/429156/">Article # 19.</a>  <a href="https://habr.com/post/429156/">Semaphores: introduction and basic services</a> <br>  <a href="https://habr.com/post/428890/">Article # 18.</a>  <a href="https://habr.com/post/428890/">Event flag groups: helper services and data structures</a> <br>  <a href="https://habr.com/post/428131/">Article # 17.</a>  <a href="https://habr.com/post/428131/">Event flag groups: introduction and basic services</a> <br>  <a href="https://habr.com/post/427439/">Article # 16.</a>  <a href="https://habr.com/post/427439/">Signals</a> <br>  <a href="https://habr.com/post/426477/">Article # 15.</a>  <a href="https://habr.com/post/426477/">Memory sections: services and data structures</a> <br>  <a href="https://habr.com/post/426425/">Article # 14.</a>  <a href="https://habr.com/post/426425/">Memory sections: introduction and basic services</a> <br>  <a href="https://habr.com/post/425353/">Article # 13.</a>  <a href="https://habr.com/post/425353/">Task data structures and unsupported API calls</a> <br>  <a href="https://habr.com/post/424713/">Article # 12.</a>  <a href="https://habr.com/post/424713/">Task Services</a> <br>  <a href="https://habr.com/post/424481/">Article # 11.</a>  <a href="https://habr.com/post/424481/">Tasks: configuration and introduction to the API</a> <br>  <a href="https://habr.com/post/423967/">Article # 10.</a>  <a href="https://habr.com/post/423967/">Scheduler: additional features and context preservation</a> <br>  <a href="https://habr.com/post/422615/">Article # 9.</a>  <a href="https://habr.com/post/422615/">Scheduler: implementation</a> <br>  <a href="https://habr.com/post/422617/">Article # 8.</a>  <a href="https://habr.com/post/422617/">Nucleus SE: Inside and Deployment</a> <br>  <a href="https://habr.com/post/418601/">Article # 7.</a>  <a href="https://habr.com/post/418601/">Nucleus SE: introduction</a> <br>  <a href="https://habr.com/post/418677/">Article # 6.</a>  <a href="https://habr.com/post/418677/">Other RTOS services</a> <br>  <a href="https://habr.com/post/415429/">Article # 5.</a>  <a href="https://habr.com/post/415429/">Interaction between tasks and synchronization</a> <br>  <a href="https://habr.com/post/415427/">Article # 4.</a>  <a href="https://habr.com/post/415427/">Tasks, context switching and interrupts</a> <br>  <a href="https://habr.com/post/415329/">Article # 3.</a>  <a href="https://habr.com/post/415329/">Tasks and planning</a> <br>  <a href="https://habr.com/post/414093/">Article # 2.</a>  <a href="https://habr.com/post/414093/">RTOS: Structure and Real Time</a> <a href="https://habr.com/post/414093/"><br></a>  <a href="https://habr.com/post/414093/">Article # 1.</a>  <a href="https://habr.com/post/414093/">RTOS: introduction.</a> <br></div></div><br><h2>  Regular and managed interrupts </h2><br>  Nucleus SE offers two ways to handle interrupts: ‚Äúnative‚Äù or ‚Äúregular‚Äù (Native), in which interrupts do not represent anything special and to some extent have limited interaction with the OS (at least when using the priority scheduler), and Managed ‚Äù, in which you can access a much larger number of available API calls from an interrupt handler. <br><br>  With the help of input / output macros, the interrupt handler in Nucleus SE can be used both in the standard and in the controlled version. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h3>  Regular interrupts </h3><br>  Nucleus SE regular interrupts are the standard interrupt handler; they can be considered ‚Äúunmanaged‚Äù.  They are usually used when an interrupt can occur with a high frequency and requires processing with a low utilization of computing resources.  Such a handler is most likely written in C, since many modern embedded compilers support the development of interrupt handlers using the interrupt keyword.  Only the context information that the compiler deems necessary is saved.  This leads to significant limitations in what standard interrupt handlers can do, as we will see soon. <br><br>  To form a regular interrupt handler in Nucleus SE, you simply write a normal interrupt handler, including calling the <b>NUSE_NISR_Enter ()</b> macro at the beginning and calling <b>NUSE_NISR_Exit ()</b> at the end.  These macros are defined in the <b>nuse_types</b> file <b>.</b>  h and set the global variable <b>NUSE_Task_State</b> to <b>NUSE_NISR_CONTEXT</b> . <br><br><h3>  Managed Interrupts </h3><br>  If you need greater flexibility in the operations performed by the interrupt handler, Nucleus SE controlled interrupts may be the appropriate solution.  The key difference from the standard interrupt is the preservation of the context.  Instead of allowing the compiler to keep several registers on the stack, the managed interrupt saves the entire task context (in its own context block) as an input.  Then the context of the current task is restored from the context block at the output.  This provides the ability to change the current task with the interrupt handler code, which is possible using the priority scheduler.  A full description of the preservation and restoration of the context in Nucleus SE was given in a previous article ( <a href="https://habr.com/ru/post/423967/"># 10</a> ). <br><br>  Obviously, the complete preservation of the context entails an increase in the use of computational resources as compared to the preservation of several registers on the stack, which occurs with a standard interrupt.  Such a price must be paid for additional flexibility, and it is this that is the reason why the choice of interrupt handling approach is provided. <br><br>  A managed interrupt is built using the <b>NUSE_MANAGED_ISR ()</b> macro, described in <b>nuse_types.h</b> .  This macro creates a function that contains the following actions: <br><br><ul><li>  preserving task context; </li><li>  <b>NUSE_Task_State</b> assignment to <b>NUSE_MISR_CONTEXT</b> ; </li><li>  user-supplied interrupt handler function code; </li><li>  restoring <b>NUSE_Task_State</b> to its previous state; </li><li>  restore task context. </li></ul><br>  The macro takes two parameters: the name of the interrupt, used as the name of the function for the handler being created, and the name of the function that contains the user logic of the interrupt handler. <br><br><h3>  API calls from interrupt handler </h3><br>  The set of API functions that can be called from a standard or managed interrupt handler depends on which scheduler is used.  In general terms, the use of the priority scheduler provides many possibilities for accessing the scheduler by calling an API function, which is difficult when using a standard interrupt handler. <br><br>  <b><i>API calls to the standard interrupt handler when using the priority scheduler</i></b> <br><br>  When using the priority scheduler, a limited number of API function calls are allowed from the standard interrupt handler.  This restriction is a result of the flexibility of the Nucleus SE API: many calls can cause the task to be ready and the scheduler can not be called by the standard interrupt handler (because the task context is not saved).  Disabling task blocking will provide even more flexibility. <br><br>  The following API calls are always allowed: <br><br><pre><code class="plaintext hljs">NUSE_Task_Current() NUSE_Task_Check_Stack() NUSE_Task_Information() NUSE_Task_Count() NUSE_Partition_Pool_Information() NUSE_Partition_Pool_Count() NUSE_Mailbox_Information() NUSE_Mailbox_Count() NUSE_Queue_Information() NUSE_Queue_Count() NUSE_Pipe_Information() NUSE_Pipe_Count() NUSE_Semaphore_Information() NUSE_Semaphore_Count() NUSE_Event_Group_Information() NUSE_Event_Group_Count() NUSE_Signals_Send() NUSE_Timer_Control() NUSE_Timer_Get_Remaining() NUSE_Timer_Reset() NUSE_Timer_Information() NUSE_Timer_Count() NUSE_Clock_Set() NUSE_Clock_Retrieve() NUSE_Release_Information()</code> </pre> <br>  However, the only useful one is <b>NUSE_Signals_Send ()</b> , since it provides a convenient way to <b>tell a</b> task to perform an action. <br><br>  If blocking is disabled, that is, tasks cannot be transferred to a ready state by many API calls, additional API calls become available: <br><br><pre> <code class="plaintext hljs">NUSE_Partition_Allocate() NUSE_Partition_Deallocate() NUSE_Mailbox_Send() NUSE_Mailbox_Receive() NUSE_Mailbox_Reset() NUSE_Queue_Send() NUSE_Queue_Receive() NUSE_Queue_Jam() NUSE_Queue_Reset() NUSE_Pipe_Send() NUSE_Pipe_Receive() NUSE_Pipe_Jam() NUSE_Pipe_Reset() NUSE_Semaphore_Obtain() NUSE_Semaphore_Release() NUSE_Semaphore_Reset() NUSE_Event_Group_Set() NUSE_Event_Group_Retrieve()</code> </pre> <br>  Some API calls are always unavailable to standard interrupt handlers, since they will inevitably require the work of the scheduler: <br><pre> <code class="plaintext hljs">NUSE_Task_Suspend() NUSE_Task_Resume() NUSE_Task_Sleep() NUSE_Task_Relinquish() NUSE_Task_Reset() NUSE_Signals_Receive()</code> </pre> <br>  <b><i>Calls to the API of the managed interrupt handler or standard interrupt handler when using any scheduler other than the priority scheduler</i></b> <br><br>  Much more API functions can be called from the interrupt handler when using the Run to Completion, Round Robin or Time Slice schedulers.  If a priority scheduler is used, managed interrupt handlers have a similar set of functions.  This is because calls are allowed that can lead to scheduling another task.  This feature is provided by the <b>NUSE_Reschedule ()</b> code, which detects the call context in the interrupt handler and suppresses the context change (allowing it to occur at the end of the interrupt handler).  A full analysis of the work scheduler was given in one of the previous articles ( <a href="https://habr.com/ru/post/422615/"># 9</a> ). <br><br>  The key requirement is that API calls inside an interrupt handler should not suspend the current task, for example, waiting for a resource to be released. <br><br>  In other words, such calls should be made with the <b>NUSE_NO_SUSPEND</b> pause <b>parameter</b> . <br><br>  With this in mind, the following API calls can be used: <br><br><pre> <code class="plaintext hljs">NUSE_Task_Current() NUSE_Task_Check_Stack() NUSE_Task_Information() NUSE_Task_Count() NUSE_Task_Suspend() NUSE_Task_Resume() NUSE_Task_Reset() NUSE_Partition_Allocate() NUSE_Partition_Deallocate() NUSE_Partition_Pool_Information() NUSE_Partition_Pool_Count() NUSE_Mailbox_Send() NUSE_Mailbox_Receive() NUSE_Mailbox_Reset() NUSE_Mailbox_Information() NUSE_Mailbox_Count() NUSE_Queue_Send() NUSE_Queue_Receive() NUSE_Queue_Jam() NUSE_Queue_Reset() NUSE_Queue_Information() NUSE_Queue_Count() NUSE_Pipe_Send() NUSE_Pipe_Receive() NUSE_Pipe_Jam() NUSE_Pipe_Reset() NUSE_Pipe_Information() NUSE_Pipe_Count() NUSE_Semaphore_Obtain() NUSE_Semaphore_Release() NUSE_Semaphore_Reset() NUSE_Semaphore_Information() NUSE_Semaphore_Count() NUSE_Event_Group_Set() NUSE_Event_Group_Retrieve() NUSE_Event_Group_Information() NUSE_Event_Group_Count() NUSE_Signals_Send() NUSE_Timer_Control() NUSE_Timer_Get_Remaining() NUSE_Timer_Reset() NUSE_Timer_Information() NUSE_Timer_Count() NUSE_Clock_Set() NUSE_Clock_Retrieve() NUSE_Release_Information()</code> </pre> <br>  Some calls are always barred, as they directly relate to the current task: <br><pre> <code class="plaintext hljs">NUSE_Task_Relinquish() NUSE_Signals_Receive() NUSE_Task_Sleep()</code> </pre> <br><h2>  Interrupt Handler Real Time Clock </h2><br>  The Real Time Clock Interrupt Handler (RTC) is the only complete interrupt handler in Nucleus SE.  In addition to providing all the necessary time management functionality in Nucleus SE, it also serves as an example of writing a managed interrupt handler. <br><br><h3>  RTC Interrupt Handler Operations </h3><br>  The functions provided by the RTC interrupt handler were listed in a previous article that dealt with the broad topic of system time in Nucleus SE ( <a href="https://habr.com/ru/post/454272/"># 27</a> ).  The described functionality is optional depending on the application configuration. <br><br><div class="spoiler">  <b class="spoiler_title">Below is the complete code for the RTC interrupt handler.</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">#if NUSE_TIMER_NUMBER != 0 { U8 timer; for (timer=0; timer&lt;NUSE_TIMER_NUMBER; timer++) { if (NUSE_Timer_Status[timer]) { if (--NUSE_Timer_Value[timer] == 0) { NUSE_Timer_Expirations_Counter[timer]++; #if NUSE_TIMER_EXPIRATION_ROUTINE_SUPPORT || NUSE_INCLUDE_EVERYTHING if (NUSE_Timer_Expiration_Routine_Address[timer] != NULL) { ((PF1)NUSE_Timer_Expiration_Routine_Address[timer]) NUSE_Timer_Expiration_Routine_Parameter[timer]); } #endif /* reschedule? */ if (NUSE_Timer_Reschedule_Time[timer] != 0) { /* yes: set up time */ NUSE_Timer_Value[timer] = NUSE_Timer_Reschedule_Time[timer]; } else { /* no: disable */ NUSE_Timer_Status[timer] = FALSE; } } } } } #endif #if NUSE_SYSTEM_TIME_SUPPORT || NUSE_INCLUDE_EVERYTHING NUSE_Tick_Clock++; #endif #if NUSE_TASK_SLEEP || NUSE_INCLUDE_EVERYTHING { U8 task; for (task=0; task&lt;NUSE_TASK_NUMBER; task++) { if (NUSE_Task_Timeout_Counter[task] != 0) { NUSE_Task_Timeout_Counter[task]--; if (NUSE_Task_Timeout_Counter[task] == 0) { NUSE_Wake_Task(task); } } } } #endif #if NUSE_SCHEDULER_TYPE == NUSE_TIME_SLICE_SCHEDULER if (--NUSE_Time_Slice_Ticks == 0) { NUSE_Reschedule(); } #endif</code> </pre><br></div></div><br>  Next, we look at the four main areas of functionality for the RTC interrupt handler. <br><br>  <b><i>Timers</i></b> <br>  If application timers are configured, the interrupt handler goes into a loop to process each timer by decreasing its counter value by 1. If the timer ends the count (i.e., the counter reaches 0), two actions are possible: <br><br><ul><li>  if the timer completion handler is configured and the timer has a valid (not <b>NULL</b> ) function pointer (in <b>NUSE_Timer_Expiration_Routine_Address []</b> ), the handler is executed, taking the parameter from <b>NUSE_Timer_Expiration_Routine_Parameter []</b> ; </li><li>  if the timer is configured to initialize after completion (i.e. <b>NUSE_Timer_Reschedule_Time []</b> has a non-zero value), the timer is reset with this value. </li></ul><br>  Application timers have been described in detail in a previous article (# 28). <br><br>  <b><i>System Timer (System Clock)</i></b> <br>  If a system timer is configured, the <b>NUSE_Tick_Cloc</b> k value is simply incremented by 1. For more information, see article # 28. <br><br>  <b><i>Task Sleep</i></b> <br>  If support for suspending tasks is enabled (i.e. the <b>NUSE_Task_Sleep ()</b> API call is configured), the timeout counter for each task (the value in <b>NUSE_Task_Timeout_Counter []</b> ) is checked, and if it is not zero, it is reduced by 1. If it reaches zero, the corresponding task is resumed . <br><br>  <b><i>Time Slice Scheduling Planning</i></b> <br>  If the time slice scheduler (Time Slice) is used, the scheduler counter ( <b>NUSE_Time_Slice_Ticks</b> ) is decremented.  If it reaches zero, the scheduler is called.  The call <b>NUSE_Reschedule ()</b> is responsible for resetting the counter. <br><br><h3>  Managed Interrupt </h3><br>  It is necessary to explain why the RTC interrupt handler is manageable, since under certain circumstances the user may decide to rewrite it as a standard interrupt in order to reduce the use of computing resources.  For example, if only one system time function is used (i.e., there are no application timers, there is no task suspension, and there is no Time Slice scheduler), the staff interrupt is completely appropriate.  A managed interrupt is required in the following cases: <br><br><ul><li>  if timers are used and handlers are configured to complete them, since these handlers can execute API calls (from the interrupt context), which will trigger new scheduling.  They have the same restrictions as API calls made from interrupt handlers (see earlier in this article); </li><li>  if a priority scheduler is used, the completion of a task pause may require awakening a task with a higher priority; </li><li>  if the Time Slice scheduler is used, it will necessarily be called from the RTC interrupt handler, therefore, a managed interrupt is mandatory. </li></ul><br><h2>  Nucleus RTOS Compatibility </h2><br>  Since the implementation of the Nucleus SE interrupts is very different from the Nucleus RTOS, you should not expect compatibility in this regard.  Nucleus RTOS has a standard / low-level / high-level interrupt scheme, which is a bit like the standard / managed interrupt scheme in Nucleus SE. <br><br><h3>  Low Level and High Level Interrupt Handlers </h3><br>  <b><i>Low Level Interrupt Handlers</i></b> <br>  The Low Level Interrupt Service Routin (LISR) low level interrupt handler is executed in the same way as a regular interrupt handler, including using the current stack.  Nucleus RTOS saves the context until the low-level interrupt handler is called and restores the context after the handler completes.  Therefore, a low-level interrupt handler can be written in C and can call other handlers in C. However, only a few Nucleus RTOS services are available to a low-level handler.  If interrupt handling requires additional Nucleus RTOS services, you need to activate a high-level interrupt handler.  Nucleus RTOS supports the use of several low-level interrupt handlers. <br><br>  <b><i>High level interrupt handler</i></b> <br>  High-level Interrupt Service Routin (HISR) handlers are created and deleted dynamically.  Each high-level handler has its own stack space and its own control unit.  Memory is allocated by the application.  And, of course, a high-level interrupt handler must be created before a low-level interrupt handler can activate it. <br><br>  Since the high-level interrupt handler has its own stack and control unit, it can be temporarily blocked if it tries to access the Nucleus RTOS data structure that is currently in use. <br><br>  There are three priority levels available to the high-level interrupt handler.  If a higher-level handler with a higher priority is activated while the handler with a lower priority is running, a low-priority handler will be executed as the task runs.  High-level interrupt handlers with the same priority are executed in the order they are activated.  All activated high-level interrupt handlers must be completed before continuing to schedule tasks in normal mode. <br><br><h3>  Nucleus RTOS API service calls to interrupt </h3><br>  Nucleus RTOS has several API calls to support interrupts.  None of these are implemented in the Nucleus SE. <br><br>  For standard interrupts, API calls provide the following functions: <br><br><ul><li>  control (enable / disable) interrupt (locally and globally); </li><li>  set interrupt vector. </li></ul><br>  For low-level interrupts: <br><br><ul><li>  registering a low-level kernel interrupt handler. </li></ul><br>  For high-level interrupts: <br><br><ul><li>  create / delete high-level interrupts; </li><li>  high-level interrupt activation; </li><li>  getting the number of high-level interrupts in the application (at the moment); </li><li>  receiving pointers to control blocks of all high-level interrupts; </li><li>  receiving pointers to current high-level interrupt control units; </li><li>  receiving information about high-level interruption. </li></ul><br>  <b><i>Global interrupt control</i></b> <br><br>  This call activates or deactivates interrupts regardless of the task.  Consequently, an interrupt deactivated by this call will remain so until it is activated by reusing this call. <br><br>  Service Call Prototype: <br><br><pre> <code class="plaintext hljs">INT NU_Control_Interrupts (INT new_level);</code> </pre> <br>  Options: <br><br>  <b>new_level</b> - new interrupt level for the system.  It can always be <b>NU_DISABLE_INTERRUPTS</b> (deactivates all interrupts) and <b>NU_ENABLE_INTERRUPTS</b> (activates all interrupts).  Depending on the architecture, other values ‚Äã‚Äãmay be available. <br><br>  Return value: <br><br>  This service call returns the previous level of activated interrupts. <br><br>  <b><i>Local Interrupt Control</i></b> <br><br>  This service call allows you to activate or deactivate interrupts depending on the task.  This call changes the status register to the specified value.  The status register will be returned to the value specified by the last call to <b>NU_Control_Interrupts () the</b> next time the context changes. <br><br>  Service Call Prototype: <br><br><pre> <code class="plaintext hljs">INT NU_Local_Control_Interrupts (INT new_level);</code> </pre> <br>  Options: <br><br>  <b>new_level</b> - new interrupt level for the current task.  It can always be <b>NU_DISABLE_INTERRUPTS</b> (deactivates all interrupts) and <b>NU_ENABLE_INTERRUPTS</b> (activates all interrupts).  Depending on the architecture, other values ‚Äã‚Äãmay be available. <br><br>  Return value: <br>  This service call returns the previous level of activated interrupts. <br><br>  <b><i>Set interrupt vector</i></b> <br><br>  This service call replaces the interrupt vector indicated by the vector controlled by the interrupt handler. <br><br>  Service Call Prototype: <br><br><pre> <code class="plaintext hljs">VOID *NU_Setup_Vector (INT vector, VOID *new);</code> </pre> <br>  Options: <br><br>  <b>vector</b> - interrupt vector for which the interrupt will be registered; <br>  <b>new</b> is an interrupt handler written to the vector. <br><br>  Return value: <br><br>  This service call returns a pointer to the interrupt handler previously registered for the interrupt vector. <br><br>  <b><i>Register low-level interrupt</i></b> <br><br>  This service call links the function of the low-level interrupt handler to the interrupt vector.  The system context is automatically saved before calling the specified low-level interrupt handler and is restored when the interrupt handler completes. <br><br>  Service Call Prototype: <br><br><pre> <code class="plaintext hljs">STATUS NU_Register_LISR (INT vector, VOID (*lisr_entry) (INT), VOID (**old_lisr) (INT);</code> </pre> <br>  Options: <br><br>  <b>vector</b> - interrupt vector for which the interrupt will be registered; <br>  <b>lisr_entry</b> - the function that will be registered for the vector; the <b>NU_NULL</b> value will clear the vector; <br>  <b>old_lisr</b> is a function previously registered for the specified vector. <br><br>  Return value: <br><br>  <b>NU_SUCCESS</b> - the call was successfully completed; <br>  <b>NU_INVALID_VECTOR</b> - incorrect vector; <br>  <b>NU_NOT_R video</b> - at the moment the vector is not registered, since de-registration was specified in l <b>isr_entry</b> ; <br>  <b>NO_MORE_LISRS</b> - the maximum number of registered low-level interrupt handlers has been reached. <br><br>  <b><i>Creating a high-level interrupt handler</i></b> <br>  This service call creates a high-level interrupt handler. <br><br>  Service Call Prototype: <br><br><pre> <code class="plaintext hljs">STATUS NU_Create_HISR (NU_HISR *hisr, CHAR *name, VOID (*hisr_entry) (VOID), OPTION priority, VOID *stack_pointer, UNSIGNED stack_size);</code> </pre> <br>  Options: <br><br>  <b>hisr</b> is a pointer to a user-provided control block for a high-level interrupt handler; <br>  <b>name</b> - pointer to the 7-character name for the high-level interrupt handler with terminating zero; <br>  <b>hisr_entry</b> - entry point of the function of the high-level interrupt handler; <br>  <b>priority</b> - there are three priorities for high-level interrupt handlers (0-2);  priority 0 - the highest; <br>  <b>stack_pointer</b> - pointer to the stack area of ‚Äã‚Äãthe high-level interrupt handler; <br>  <b>stack_size</b> - the number of bytes in the stack of the high-level interrupt handler. <br><br>  Return value: <br><br>  <b>NU_SUCCESS</b> - the call was successfully completed; <br>  <b>NU_INVALID_HISR</b> - a null pointer to a high level interrupt handler control unit ( <b>NULL</b> ) or a control block is already in use; <br>  <b>NU_INVALID_ENTRY</b> - null pointer to the entry point of the high-level interrupt handler ( <b>NULL</b> ); <br>  <b>NU_INVALID_PRIORITY</b> - incorrect priority of high-level interrupt handler; <br>  <b>NU_INVALID_MEMORY</b> - invalid pointer to the stack; <br>  <b>NU_INVALID_SIZE</b> - stack size too small. <br><br>  <b><i>Removing high-level interrupt handler</i></b> <br>  This service call removes the previously created high-level interrupt handler. <br><br>  Service Call Prototype: <br><br><pre> <code class="plaintext hljs">STATUS NU_Delete_HISR (NU_HISR *hisr);</code> </pre> <br>  Options: <br><br>  <b>hisr</b> is a pointer to the control unit of the high-level interrupt handler provided by the user. <br><br>  Return value: <br><br>  <b>NU_SUCCESS</b> - the call was successfully completed; <br>  <b>NU_INVALID_HISR</b> - invalid pointer to high-level interrupt handler. <br><br>  <b><i>Activate high-level interrupt handler</i></b> <br><br>  This service call activates a high-level interrupt handler.  If the specified high-level interrupt handler is currently in progress, the activation request is not executed until the handler stops working.  The high-level interrupt handler is executed once for each activation request. <br><br>  Service Call Prototype: <br><br><pre> <code class="plaintext hljs">STATUS NU_Activate_HISR (NU_HISR *hisr);</code> </pre> <br>  Options: <br><br>  <b>hisr</b> is a pointer to the control block of a high-level interrupt handler. <br>  Return value: <br>  <b>NU_SUCCESS</b> - the call was successfully completed; <br>  <b>NU_INVALID_HISR</b> - incorrect pointer to the control block of the high-level interrupt handler. <br><br>  <b><i>Getting the number of high-level interrupt handlers in the system</i></b> <br>  This service call returns the number of installed high-level interrupt handlers.  All created high-level interrupt handlers are considered set.  Remote high-level interrupt handlers are not considered installed. <br><br>  Service Call Prototype: <br><br><pre> <code class="plaintext hljs">UNSIGNED NU_Established_HISRs(VOID);</code> </pre> <br>  Options: <br>  None. <br><br>  Return value: <br>  This service call returns the number of installed high-level interrupt handlers in the system. <br><br>  <b><i>Getting pointers to control blocks for high-level interrupt handlers</i></b> <br><br>  This service call creates a sequential list of pointers to all high-level interrupt handlers installed in the system. <br><br>  Service Call Prototype: <br><br><pre> <code class="plaintext hljs">UNSIGNED NU_HISR_Pointers(NU_HISR **pointer_list, UNSIGNED maximum_pointers);</code> </pre> <br>  Options: <br><br>  <b>pointer_list</b> - pointer to array of pointers <b>NU_HISR</b> ;  this array will be filled with pointers to the high-level interrupt handlers installed in the system; <br>  <b>maximum_pointers</b> - the maximum number of <b>NU_HISR</b> pointers that can be placed in an array;  it is usually equal to the size of the <b>pointer_list</b> array. <br><br>  Return value: <br>  This service call returns the number of active high-level interrupt handlers in the system. <br><br>  <b><i>Getting a pointer to the current high-level interrupt handler</i></b> <br>  This service call returns a pointer to the currently executing high-level interrupt handler. <br><br>  Service Call Prototype: <br><br><pre> <code class="plaintext hljs">NU_HISR *NU_Current_HISR_Pointer(VOID);</code> </pre> <br>  Options: <br>  None. <br><br>  Return value: <br>  This service call returns a pointer to the control block of the currently executing high-level interrupt handler.  If a non-high level interrupt handler calls this function, <b>NU_NULL is</b> returned. <br><br>  <b><i>Getting information about the high-level interrupt handler</i></b> <br>  This service call returns various information about the specified high-level interrupt handler. <br><br>  Service Call Prototype: <br><br><pre> <code class="plaintext hljs">STATUS NU_HISR_Information(NU_HISR *hisr, char *name, UNSIGNED *scheduled_count, DATA_ELEMENT *priority, VOID **stack_base, UNSIGNED *stack_size, UNSIGNED *minimum_stack);</code> </pre> <br>  Options: <br><br>  <b>hisr</b> is a pointer to a high-level interrupt handler; <br>  <b>name</b> - pointer to the 8-character field for the name of the high-level interrupt handler, including the terminating zero; <br>  <b>scheduled_count</b> - pointer to the variable for the total number of times this high-level interrupt handler was scheduled; <br>  <b>priority</b> - a pointer to a variable to store the priority of the high-level interrupt handler; <br>  <b>stack_base</b> - pointer to the pointer to store the original pointer to the stack;  this is the same pointer that was passed when creating the high-level interrupt handler; <br>  <b>stack_size</b> - a pointer to a variable to hold the total stack size of the high-level interrupt handler; <br>  <b>minimum_stack</b> - a pointer to a variable to store the minimum amount of available stack space detected by the high-level interrupt handler. <br><br>  Return value: <br><br>  <b>NU_SUCCESS</b> - the call was successfully completed; <br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NU_INVALID_HISR</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - invalid pointer to high-level interrupt handler.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> API calls from interrupt handlers </font></font></h3><br> <b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Utility API calls from low-level interrupt handlers A low-level interrupt</font></font></i></b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> handler can use only the following Nucleus RTOS functions:</font></font><br><br><pre> <code class="plaintext hljs">NU_Activate_HISR() NU_Local_Control_Interrupts() NU_Current_HISR_Pointer() NU_Current_Task_Pointer() NU_Retrieve_Clock()</code> </pre> <br> <b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">API service calls from high-level interrupt handlers</font></font></i></b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> High-level</font><b><i><font style="vertical-align: inherit;"> interrupt</font></i></b><font style="vertical-align: inherit;"> handlers have access to most Nucleus RTOS functions, with the exception of self-suspending functions, since the high-level interrupt handler cannot suspend Nucleus RTOS, the parameter must always be</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> NU_NO_SUSPEND</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The next article in the series will look at initialization and startup procedures for the Nucleus SE. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">About the author:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Colin Walls has been working in the electronics industry for over thirty years, devoting much of his time to embedded software. </font><font style="vertical-align: inherit;">He is now an embedded software engineer in Mentor Embedded (a division of Mentor Graphics). </font><font style="vertical-align: inherit;">Colin Walls often speaks at conferences and seminars, author of numerous technical articles and two books on embedded software. </font><font style="vertical-align: inherit;">Lives in the UK. </font></font><a href="http://blogs.mentor.com/colinwalls"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Colin's</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> professional </font><a href="http://blogs.mentor.com/colinwalls"><font style="vertical-align: inherit;">blog</font></a><font style="vertical-align: inherit;"> , e-mail: colin_walls@mentor.com.</font></font></div><p>Source: <a href="https://habr.com/ru/post/458770/">https://habr.com/ru/post/458770/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../45876/index.html">Javascript: Visual Event</a></li>
<li><a href="../458760/index.html">The Las Vegas trade show is for electronics developers, not consumers. A report from Design Automation Conference</a></li>
<li><a href="../458766/index.html">IronPython on the side of evil: how we opened a cyber attack on civil services in a European country</a></li>
<li><a href="../458768/index.html">5-6 reasons to come to GolangConf</a></li>
<li><a href="../45877/index.html">Opera_Cache: update of the plug-in for viewing the Opera cache</a></li>
<li><a href="../458774/index.html">Functional DBMS</a></li>
<li><a href="../458778/index.html">Satellite Reporting Engine 6.5: What It Is And Why</a></li>
<li><a href="../458782/index.html">Adaptation programs for the ZX Spectrum to TR-DOS with modern tools. Part 3</a></li>
<li><a href="../458784/index.html">Broadcasting projects and libraries from Altium Designer to PADS Professional</a></li>
<li><a href="../458786/index.html">The "keepers" of video games, step by step, preserve the gaming culture</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>