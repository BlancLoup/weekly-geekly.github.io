<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Use Marionette.Region to create boot views</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In client applications, it is often necessary to somehow visualize the process of downloading data from the server. In this article, I will describe a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Use Marionette.Region to create boot views</h1><div class="post__text post__text-html js-mediator-article"><img align="left" src="https://habrastorage.org/files/01f/acd/eed/01facdeed02844a180da876f282bd533.png">  In client applications, it is often necessary to somehow visualize the process of downloading data from the server.  In this article, I will describe a way to achieve this behavior by reusing the Marionette.Region area in MarionetteJS. <br><br>  I‚Äôll say <a href="http://www.backbonerails.com/">right away</a> that my approach is largely based on the screencast author‚Äôs approach on <a href="http://www.backbonerails.com/">www.backbonerails.com</a> .  This is a very good and useful series of screencasts, not only (and not so much) from the point of view of what is discussed here, but also in general for studying MarionetteJS. <br><a name="habracut"></a><br><h3>  purpose </h3><br>  So our goal is to develop a reusable component for MarionetteJS, which deals with the visualization of the loading process.  As will be shown later, in the case of Backbone / Marionette, the start and end loading events can be considered a special case of a change in the model state, therefore the purpose of this component can be formulated more abstractly as a visualization of the change in the model state. <br><br><h3>  Getting Started with BackboneJS </h3><br>  As everyone is well aware, MarionetteJS is a superstructure over BackboneJS.  And I would like to start with how Backbone can help with this task.  Suppose we have a model (or collection) and a representation that displays it.  At the BackboneJS level, we could solve the task as follows: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <div style="text-align:center;"><img src="https://habrastorage.org/files/1fe/159/89a/1fe15989a4224e7f96b1b5e679d433e2.png"></div><br>  <i>Figure 1 - Model events when loading data</i> <br><br>  That is, a simple idea is that the view surveys the model and uses the request and sync events generated by Backbone.Model to go to the ‚Äúboot‚Äù (for example, draws some kind of boot animation) or to the ‚Äúsynchronized‚Äù state (removes the boot animation ).  For the sake of brevity, I will call the ability to respond to model state change events such as request, sync, error, etc.  <b>responsiveness</b> .  By state change, I mean any events that are not related to a change in model data. <br><br>  In general, Backbone allows us to easily achieve the desired behavior, due to events generated by Backbone.Model (or Backbone.Collection), but there are problems with reusing code that needs to subscribe to model events and process them.  Actually, the question of <b>how to</b> implement responsiveness does not arise; the main question is <b>where</b> this can be done so that the use of this implementation is the most unobtrusive and convenient.  I will not dwell on further reasoning, as it would be possible to implement our component on the basis of Backbone, because in any case it will not work out better than on the basis of MarionetteJS. <br><br><h3>  We use representations MarionetteJS </h3><br>  When I first encountered the task of loading visualization, I did not think that there would be so few ready-made solutions on this issue.  Googling found several discussions about the implementation of the Marionette.View.loadingView attribute in the same way as Marionette.CollectionView.emptyView.  Later, a ready- <a href="https://github.com/gogiel/marionette.loading">made solution appeared</a> .  But to be honest, I believe that visualizing the loading of a model at the presentation level that directly reflects this model is not a good idea.  In general, the way of visualization of loading depends not on the model representation, but on who displays it.  Those.  if we display different models in the same place in the document, then the loading visualization should look uniform for all of them.  In short, this option does not suit us. <br><br><h3>  We use MarionetteJS controllers </h3><br>  Now it's time to talk about the approach on which my idea originated.  It is described in <a href="http://www.backbonerails.com/screencasts/loading-views">this issue of the</a> already mentioned series of screencasts.  In a nutshell, this approach uses the model as a source of events and a basic abstract controller that determines how views are displayed.  Here is an outline of this approach: <br><ol><li>  Directly responsiveness is implemented by a pair of LoadingControler + LoadingView. </li><li>  To work with LoadingView, the base class class of the controller (show, region, options) is used.  Derived controllers should use this method to display views.  This method in turn creates an instance of LoadingController and passes it the original view and the area to display.  Further, LoadingController immediately in its constructor (and not on the request event) substitutes LoadingView into the specified area. </li><li>  LoadingController reviews the model.  And, conveniently, the model can not be specified explicitly, by default, RealView.collection and RealView.model will be viewed.  More specifically, LoadingController does not view the model, but the xhr objects associated with requesting this model's data.  Upon completion of these requests, instead of LoadingView, RealView is inserted in the same area. </li></ol><br><div style="text-align:center;"><img src="https://habrastorage.org/files/3c0/520/645/3c0520645da84922b816a634b2a7c16e.png"></div><br>  <i>Figure 2 - Sequence Diagram with LoadingView + LoadingController</i> <br><br><div class="spoiler">  <b class="spoiler_title">Remarks</b> <div class="spoiler_text">  LoadingController works with LoadingView and RealView not directly, but through Marionette.Region, but this is not important for a general understanding of the work. <br></div></div><br>  Here is the class diagram that participates in this interaction: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/a79/65d/407/a7965d407f0d4021a47914858033f677.png"></div><br>  <i>Figure 3 - Class diagram when using LoadingView + LoadingController</i> <br><br>  This is the first approach that has already been mentioned.  But it did not suit me for the reason that it imposes some requirements on the overall architecture of the application: <br><ol><li>  All controllers must inherit from the same base class and use only its method to display the views. </li><li>  To display the boot view, you must follow the sequence: start loading the model, create a new view, show it. </li></ol><br>  At the same time, there are very good solutions that I borrowed: <br><ol><li>  The ability to determine the model you want to review, without explicit reference to it. </li><li>  Responsibility for the visualization of the load is beyond the scope of the model presentation. </li></ol><br><br><h3>  Use Marionette.Region </h3><br>  Marionette.Region personifies some area of ‚Äã‚Äãthe screen in which views are placed, and allows you to control the lifetime of the view and separate from the view the way it appears on the screen.  If you want to show a presentation in the field, you do not need to think about what will happen to the presentation that is already placed in the area - it will be deleted automatically.  If you need to change the way a view appears on the screen, you can simply inherit from Marionette.Region and implement your logic.  For example, you can change the way you appear by adding animation, or you can change the way you insert a view into a document, wrapping it with some of your own elements.  For example, <a href="http://www.backbonerails.com/screencasts/building-dialogs-with-custom-regions">this release</a> describes the implementation of a private area that wraps an arbitrary view into a dialog box. <br><br>  In my implementation, the main work takes place in the abstract class ResponsiveRegion, which is the successor of Marionette.Region.  Specific classes need only define handlers that change the appearance of the area depending on the model events and, possibly, list the events themselves.  For example, you can change the transparency, the visibility of the elements of the region, insert some kind of overlay with animation, in general, do anything.  I will not pay much attention to the decoration part, but focus on the abstract class.  Here's how I implemented responsiveness at the domain level using the ResponsiveRegion: <br><br><ol><li>  ResponsiveRegion initialization is not different from Marionette.Region.  Suppose a Layout view (derived from LayoutView) that defines an area indicates (declaratively) that our implementation of the ResponsiveRegion area should be used, not the standard Marionette.Region. <br><br><pre><code class="javascript hljs">List.Layout = Marionette.LayoutView.extend({ ... regions : { <span class="hljs-attr"><span class="hljs-attr">someRegion</span></span> : { <span class="hljs-attr"><span class="hljs-attr">selector</span></span> : <span class="hljs-string"><span class="hljs-string">'#region'</span></span>, <span class="hljs-attr"><span class="hljs-attr">regionClass</span></span> : Marionette.ResponsiveVisiblityRegion } } ... });</code> </pre> <br></li><li>  To show the view in this area, you can use region.show (view) (as with the usual Marionette.Region), then the default parameters will be used, or you can use region.show (view, options) and specify the advanced responsiveness settings. </li><li>  The area puts the submitted view into the document.  She can do it not directly, but through a wrapper. <br><div class="spoiler">  <b class="spoiler_title">Example</b> <div class="spoiler_text"><pre> <code class="html hljs xml"> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">‚Äùjs-model-state-sync‚Äù</span></span></span><span class="hljs-tag">&gt;</span></span>     <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">‚Äùjs-model-state-request‚Äù</span></span></span><span class="hljs-tag">&gt;</span></span>     <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">‚Äùjs-model-state-error‚Äù</span></span></span><span class="hljs-tag">&gt;</span></span>      <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br></div></div><br></li><li>  The region reviews the model of the view in it (the model is indicated either explicitly in region.show (view, options), or RealView.collection and RealView.model are implicitly used).  Depending on the request / sync / error event, an area changes the appearance of its content.  For example, toggles the visibility of wrapper elements. </li></ol><br>  The sequence diagram looks like this: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/f75/01f/6f6/f7501f6f66e349588f258f1115355b0b.png"></div><br>  <i>Figure 4 - Sequence Diagram with ResponsiveRegion</i> <br><br>  A classes like this: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/ca6/300/295/ca63002953964c9ca813f424af563b42.png"></div><br>  <i>Figure 5 - Class diagram when using ResponsiveRegion</i> <br><br><div class="spoiler">  <b class="spoiler_title">Remarks</b> <div class="spoiler_text">  In reality, there are also dependencies between Layout and Controller on ResponsiveRegion.  The first link is omitted due to the fact that, despite the fact that the Layout view is actually dependent on the ResponsiveRegion, it actually works with it as usual Marionette.Region.  It is just more convenient to declare the type of the area in the layout declaration.  The second link is omitted because it is optional and only occurs if the controller needs to specify responsiveness options. <br></div></div><br>  What have we achieved by applying this approach? <br><ol><li>  We fully complied with the structure of the objects of MarionetteJS, without creating a single entity, but only expanding Marionette.Region.  ResponsiveRegion in most cases is also used as its ancestor, and does not make any additional assumptions about the components with which it is used.  Compared to the previous approach based on an abstract controller, there is no basis for how your application is organized: if you use Marionette, you can use ResponsiveRegion. </li><li>  We review the model all the time while its presentation is in the ResponsiveRegion.  ResponsiveRegion, as the successor to Marionette.Region, is naturally aware of the cessation of the existence of the view, which allows it to unsubscribe from the events of the model at the right moment and not to leave trash behind. </li><li>  We consider the event of the beginning and end of the model loading as a special case of a change in its state, which can occur any number of times during the model's lifetime.  This allows you to freely react to other model events, such as a loading error or validation of model data. </li></ol><br><br><h3>  Conclusion </h3><br>  All of the approaches considered can be successfully applied depending on the situation.  But I believe that to visualize the change in the state of a model in general and to load its data in particular, the variant with Marionette.Region is best suited.  Firstly, this is the component that in Marionette is responsible for displaying the views on the screen.  And secondly, the necessary logic is simple enough so that it can be implemented within one component.  That's all.  The source code of what was said here and a small example are available <a href="https://github.com/DriverEntry/responsive-region">here</a> . <br><br><h3>  Links </h3><br><ol><li>  <a href="http://www.backbonerails.com/">backbonerails.com - screencast series by MarionetteJS</a> </li><li>  <a href="http://marionettejs.com/docs/current/">Documentation MarionetteJS</a> </li><li>  <a href="http://backbonejs.org/">BackboneJS Event List</a> </li></ol></div><p>Source: <a href="https://habr.com/ru/post/252909/">https://habr.com/ru/post/252909/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../252895/index.html">Material Design. Was there a boy?</a></li>
<li><a href="../252897/index.html">Creating games without Canvas</a></li>
<li><a href="../252903/index.html">Android A few words about MVP + rxJava</a></li>
<li><a href="../252905/index.html">Results of Radare Summer of Code 2014 and the organization of the new RSoC / GSoC 2015</a></li>
<li><a href="../252907/index.html">Looking for perfect monitoring</a></li>
<li><a href="../252911/index.html">Telegram attack for 2 ^ 64 operations, and why the supervillain doesn't need it</a></li>
<li><a href="../252915/index.html">Convenient monitoring of Syslog messages from network glands in Zabbix</a></li>
<li><a href="../252917/index.html">Mikrotik: configuring IPsec to automatically update the VPN server address</a></li>
<li><a href="../252919/index.html">Connect to Intel Edison via Android with Bluetooth LE (BLE)</a></li>
<li><a href="../252921/index.html">How it works: the architecture of the tile backing of Sputnik maps</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>