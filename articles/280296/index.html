<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How to clean up the mailbox using a neural network. Part 2</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In our blog, we write a lot about creating emails and working with e-mail. In the modern world, people get a lot of letters, and in full growth there ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How to clean up the mailbox using a neural network. Part 2</h1><div class="post__text post__text-html js-mediator-article"> <a href="https://habrahabr.ru/company/pechkin/blog/280296/"><img src="https://habrastorage.org/getpro/habr/post_images/ca0/85c/415/ca085c4150507cd793375dacb25f4e49.png" alt="image"></a> <br><br>  In our blog, we write a lot about creating emails and working with e-mail.  In the modern world, people get a lot of letters, and in full growth there is a problem with their classification and ordering of the mailbox.  An engineer from the USA, Andrei Kurenkov, in his blog <a href="http://www.andreykurenkov.com/writing/organizing-my-emails-with-a-neural-net/">told</a> about how he solved this task using a neural network.  We decided to highlight the course of this project - a few days ago we published the <a href="https://habrahabr.ru/company/pechkin/blog/280198/">first part of the story</a> , and today we present to you its continuation. <a name="habracut"></a><br><br><h4>  Deep learning is not suitable here. </h4><br>  When Kurenkov first began to study the Keras code, he thought (erroneously) that he would use a sequence reflecting the actual word order in the texts.  It turned out that this is not the case, but this does not mean that such an option is impossible.  What is really worth noting in the field of machine learning is recurrent neural networks that are great for working with large data sequences, the author writes.  This approach implies that when working with words, a ‚Äúpreparatory‚Äù step is performed, in which each word is converted into a numerical vector, so that similar words are transformed into similar vectors. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Thanks to this, instead of converting letters into matrices of binary features, you can simply replace words with numbers, using the frequencies of their appearance in letters, and the numbers themselves with vectors reflecting the ‚Äúmeaning‚Äù of each word.  Then it becomes possible to use the resulting sequence to train a recurrent neural network such as Long Short Term Memory or Gated Recurrent.  And this approach has already been <a href="https://github.com/fchollet/keras/blob/master/examples/imdb_lstm.py">implemented</a> : you can simply run an example and see what happens: <br><br><pre>  Epoch 1/15
 7264/7264 [===========================] - 1330s - loss: 2.3454 - acc: 0.2411 - val_loss: 2.0348 - val_acc: 0.3594
 Epoch 2/15
 7264/7264 [===========================] - 1333s - loss: 1.9242 - acc: 0.4062 - val_loss: 1.5605 - val_acc: 0.5502
 Epoch 3/15
 7264/7264 [===========================] - 1337s - loss: 1.3903 - acc: 0.6039 - val_loss: 1.1995 - val_acc: 0.6568
 ...
 Epoch 14/15
 7264/7264 [===========================] - 1350s - loss: 0.3547 - acc: 0.9031 - val_loss: 0.8497 - val_acc: 0.7980
 Epoch 15/15
 7264/7264 [===========================] - 1352s - loss: 0.3190 - acc: 0.9126 - val_loss: 0.8617 - val_acc: 0.7869
 Test score: 0.861739277323 </pre><br>  <b>Accuracy: 0.786864931846</b> <br><br>  Training took forever, and the result was far from being so good.  Presumably, the reason may be that there was little data, and the sequences are generally not sufficiently effective to categorize them.  This means that the increased complexity of learning in sequences does not pay off with the advantage of processing words of the text in the correct order (after all, the sender and certain words in the letter show well what category it belongs to). <br><br>  But the additional ‚Äúpreparatory‚Äù step still seemed useful to the engineer because it created a wider idea of ‚Äã‚Äãthe word.  Therefore, he considered it worthwhile to try to use it by connecting the convolution to search for important local features.  And again there was <a href="https://github.com/fchollet/keras/blob/master/examples/imdb_cnn.py">an example of</a> Keras, which performs the preparatory step and at the same time transfers the obtained vectors to the layers of convolution and subsampling instead of the LSTM layers.  But the results are not impressive again: <br><br><pre>  Epoch 1/3
 5849/5849 [===========================] - 127s - loss: 1.3299 - acc: 0.5403 - val_loss: 0.8268 - val_acc: 0.7492
 Epoch 2/3
 5849/5849 [===========================] - 127s - loss: 0.4977 - acc: 0.8470 - val_loss: 0.6076 - val_acc: 0.8415
 Epoch 3/3
 5849/5849 [===========================] - 127s - loss: 0.1520 - acc: 0.9571 - val_loss: 0.6473 - val_acc: 0.8554
 Test score: 0.556200767488 </pre><br>  <b>Accuracy: 0.858725761773</b> <br><br>  The engineer really hoped that learning using sequences and preparatory steps would prove better than the N-gram model, since in theory the sequences contain more information about the letters themselves.  But the widespread belief that in-depth training is not very effective for small data sets turned out to be fair. <br><br><h4>  All because of the signs, you fool </h4><br>  So, the tests carried out did not give the desired accuracy of 90% ... As you can see, the current approach to determining signs of 2500 most frequently encountered words is not suitable, since it includes such common words as ‚ÄúI‚Äù or ‚Äúwhat‚Äù along with useful category-specific words like "home".  But it‚Äôs risky to just remove popular words or reject any sets of words ‚Äî you never know what will be useful for identifying signs, because perhaps I sometimes use this or that ‚Äúsimple‚Äù word in one of the categories more often than in others (for example in the section "Personal"). <br><br>  Here we should move from guessing to using the method of selecting signs to select words that are really good, and filter words that do not work.  For this, it is easiest to use scikit and its <a href="http://scikit-learn.org/stable/modules/generated/sklearn.feature_selection.SelectKBest.html">SelectKBest</a> class, which is so fast that selection takes minimal time compared to the operation of a neural network.  So does this help? <br><br>  Dependence of test accuracy on the number of words processed: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ca0/85c/415/ca085c4150507cd793375dacb25f4e49.png" alt="image"><br><br>  <i>Works - 90%!</i> <br><br>  Fine!  Despite the slight differences in the final performance, it is clearly better to start with a larger set of words.  However, this set can be quite reduced with the help of feature selection and without losing performance.  Apparently, this neural network has no problems with retraining.  Consideration of the ‚Äúbest and worst‚Äù words according to the version of the program confirms that it defines them well enough: <br><br><img src="https://habrastorage.org/files/288/02f/f3d/28802ff3d0f34b69a9d920a30e94f476.png"><br><br>  <i>‚ÄúBest‚Äù and ‚Äúworst‚Äù words: feature selection using chi-square test (based on the code from the scikit <a href="http://scikit-learn.org/stable/auto_examples/ensemble/plot_forest_importances.html">example</a> )</i> <br><br>  Many ‚Äúgood‚Äù words, as one would expect, are names or specific terms (for example, ‚Äúcontroller‚Äù), although Kurenkov says that some words like ‚Äúremember‚Äù or ‚Äútotal‚Äù would not have chosen.  ‚ÄúWorst‚Äù words, on the other hand, are quite predictable, as they are either too general or too rare. <br><br>  To summarize: the more words, the better, and the selection of signs can help to make work faster.  It helps, but perhaps there is a way to further improve the test results.  To find out, the engineer decided to take a look at what mistakes the neural network makes using the error matrix, also taken from <a href="http://scikit-learn.org/stable/auto_examples/model_selection/plot_confusion_matrix.html">scikit learn</a> : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/966/209/ae0/966209ae05e1a7cd380daa4938f99f8a.png" alt="image"><br><br>  <i>Error Matrix for Neural Network Performance</i> <br><br>  Great, most of the color blocks are located diagonally, however there are several other ‚Äúannoying spots‚Äù.  In particular, on the visualization, the categories ‚ÄúUnread‚Äù and ‚ÄúImportant‚Äù are marked as problematic.  But wait!  I did not create these categories, and I don‚Äôt care how well the system handles them as well as the Sent category.  Sure, I have to remove them and see how well the neural network works with the categories I created. <br><br>  Therefore, let's conduct the last experiment, in which all inappropriate categories are missing, and where the most signs will be used - 10,000 words with a selection of 4,000 best: <br><br><pre>  Epoch 1/5
 5850/5850 [==============================] - 2s - loss: 0.8013 - acc: 0.7879 - val_loss: 0.2976 - val_acc: 0.9369
 Epoch 2/5
 5850/5850 [==============================] - 1s - loss: 0.1953 - acc: 0.9557 - val_loss: 0.2322 - val_acc: 0.9508
 Epoch 3/5
 5850/5850 [==============================] - 1s - loss: 0.0988 - acc: 0.9795 - val_loss: 0.2418 - val_acc: 0.9338
 Epoch 4/5
 5850/5850 [==============================] - 1s - loss: 0.0609 - acc: 0.9865 - val_loss: 0.2275 - val_acc: 0.9462
 Epoch 5/5
 5850/5850 [==============================] - 1s - loss: 0.0406 - acc: 0.9925 - val_loss: 0.2326 - val_acc: 0.9462
 722/722 [==============================] - 0s     
 Test score: 0.243211859068 </pre><br><br>  <b>Accuracy: 0.940443213296</b> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/dd5/dd0/b26/dd5dd0b268fa4e8707af6c0cb80830e4.png" alt="image"><br><br>  <i>Error Matrix for New Neural Network Results</i> <br><br>  That's it!  The neural network can guess categories with 94% accuracy.  Although the effect is primarily due to a large set of features, a good classifier (the scikit learn <a href="http://scikit-learn.org/stable/modules/generated/sklearn.linear_model.PassiveAggressiveClassifier.html">Passive Agressive</a> classifier) ‚Äã‚Äãand by itself gives 91% accuracy on the same input data.  In fact, there are <a href="https://www.reddit.com/r/MachineLearning/comments/41posw/organizing_my_emails_with_a_neural_net/cz45hdg">ideas</a> that, in this case, the support vector machine (LinearSVC) method can also be effective; using it, one can also obtain approximately 94% accuracy. <br><br>  So, the conclusion is quite simple - ‚Äútrendy‚Äù machine learning methods are not particularly effective on small data sets, and the old N-gram + TF-IFD + SVM approaches can work as well as modern neural networks.  In short, the use of the Bag of Words method will work quite well, provided that there are few letters and they are sorted as clearly as in the example above. <br><br>  Perhaps few people use categories in gmail, but if you really create a good classifier so simply, it would be nice if gmail had a machine-learning system that defines the category of each letter for organizing mail in one click.  At this stage, Kurenkov was very pleased that he improved his own results by 20% and met Keras in the process. <br><br><h4>  Epilogue: Additional Experiments </h4><br>  While working on his experiment, the engineer did something else.  He ran into a problem: all the calculations were carried out for a long time, mostly because the author of the material did not use the now common trick of running machine learning using the GPU.  Following excellent <a href="http://deeplearning.net/software/theano/install_ubuntu.html">leadership</a> , he did it and got great results: <br><br><img src="https://habrastorage.org/files/47f/d25/955/47fd259552e44e45a69add3236c1f023.png"><br><br>  <i>The time spent on achieving the above 90% with or without a graphics processor;</i>  <i>great acceleration!</i> <br><br>  It should be noted that the Keras neural network, which demonstrates 94% accuracy, was much faster to train (and work with it) than the network, which is trained on the basis of the support vector machine;  The first was the best solution of all that I tried. <br><br>  The engineer wanted to visualize something else besides the error matrices.  In this respect, little has been achieved with Keras, although the author came across a <a href="https://github.com/fchollet/keras/issues/254">discussion of visualization issues</a> .  This led me to Keras fork with a good option to display the learning process.  He is not very effective, but curious.  After a small change, he generated excellent learning schedules: <br><br><img src="https://habrastorage.org/files/94d/733/1fc/94d7331fce3f430f935a14a680e7c123.png"><br><br>  <i>The neural network learning progress on a slightly modified example (with a large number of words being processed)</i> <br><br>  It clearly shows how the accuracy of training tends to unity and is aligned. <br><br>  Not bad, but the engineer was more worried about the increase in accuracy.  As before, the first thing he asked was: ‚ÄúIs it possible to quickly change the presentation of features to help the neural network?‚Äù The Keras module, which transforms text into matrices, has several options besides creating binary matrices: matrices with word counters, frequencies, or TF values -Idf. <br><br>  It was also easy to change the number of words stored in the matrices in the form of features, so Kurenkov wrote several cycles evaluating how the type of features and the number of words affect the accuracy of the tests.  The result was an interesting schedule: <br><br><img src="https://habrastorage.org/files/889/5a3/da4/8895a3da457b428cb69e801842493cc0.png"><br><br>  <i>Accuracy of the test depending on the type of features and how many words are taken as features (the basic accuracy takes into account the k nearest ‚Äúneighbors‚Äù)</i> <br><br>  Here, for the first time, it became clear that we need to increase the number of words to a value in excess of 1,000. It was also interesting to see that the type of features, which is characterized by simplicity and lowest information density (binary), turned out to be no worse and even better than other types that convey more information about data . <br><br>  Although it is quite predictable - most likely, more interesting words like ‚Äúcode‚Äù or ‚Äúgrade‚Äù are useful for categorizing letters, and their single appearance in the letter is just as important as the greater number of mentions.  Without a doubt, the presence of informative features may be useful, but it may also lower test results due to the increased likelihood of retraining. <br><br>  In general, we see that binary signs showed themselves better than others and that increasing the number of words perfectly helps to achieve 87% -88% accuracy. <br><br>  Inzener also reviewed the basic algorithms to make sure that something like the k-nearest-neighbor method ( <a href="http://scikit-learn.org/stable/modules/neighbors.html">scikit</a> ) is not (in terms of efficiency) equivalent to neural networks - this turned out to be true.  Linear regression worked even worse, so the choice of neural networks is quite reasonable. <br><br>  An increase in the number of words, by the way, is not in vain.  Even with the cached version of the data, when it was not necessary to parse mail every time and extract the signs, the launch of all these tests took a lot of time: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/552/9e3/e35/5529e3e35fea1b7b77d34667b6220633.png" alt="image"><br><br>  <i>Linear dependence of the growth of time on the number of words.</i>  <i>Actually not bad, linear regression was much worse.</i> <br><br>  The increase in the number of words helped, but the experimenter still could not reach the desired threshold of 90%.  Therefore, the next thought was to stick to 2,500 words and try to change the size of the neural network.  In addition, as it turned out, the model from the example of Keras has a 50% dropout regularization on a hidden layer: the engineer was interested to see if this really increases the efficiency of the network.  He launched another set of cycles and got another great schedule: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/980/d9f/d73/980d9fd73b33cb115a92cd6167e7b8b4.png" alt="image"><br><br>  <i>Graph of accuracy changes for different variants of dropout regularization and sizes of the hidden layer</i> <br><br>  It turns out that the size of the hidden layer does not have to be large enough for everything to work as it should!  64 or 124 neurons in the hidden layer can perform the task as well as the standard 512. These results, by the way, are averaged over five runs, so that the small scatter in the output data is not related to the capabilities of the small hidden layers. <br><br>  From this it follows that a large number of words are needed only to identify useful signs, but there are not so many useful signs themselves - otherwise more neurons would be required for a better result.  This is good, because we can save a lot of time using smaller hidden layers: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/74e/836/167/74e836167501a7ed98dab74b12ef00a2.png" alt="image"><br><br>  <i>And again, the computation time grows linearly with increasing neurons in the hidden layer</i> <br><br>  But this is not entirely accurate.  Having performed more launches with more signs, the engineer found that the standard size of the hidden layer (512 neurons) works much better than the smaller hidden layers: <br><br><img src="https://habrastorage.org/files/4e4/974/fd5/4e4974fd584144d6be5fe0ad6d7a5175.png"><br><br>  <i>Comparison of the performance of layers with 512 and 32 neurons, respectively</i> <br><br>  It remains only to state what was already known: the more words, the better. </div><p>Source: <a href="https://habr.com/ru/post/280296/">https://habr.com/ru/post/280296/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../280280/index.html">Once again, the benefits of traffic analyzers</a></li>
<li><a href="../280284/index.html">Teigha for Architecture: First project</a></li>
<li><a href="../280286/index.html">MSLibrary. Creating and compiling cross-platform (universal) libraries in Xcode</a></li>
<li><a href="../280292/index.html">Linux for beginners or what can a girl teach?</a></li>
<li><a href="../280294/index.html">Not IoT, but raspberry! We build the IoT-project on Raspberry Pi with Windows 10 and DeviceHive</a></li>
<li><a href="../280298/index.html">Pitfalls .load () and .get ()</a></li>
<li><a href="../280300/index.html">Beeline Data School: Spring, Knowledge, New Course</a></li>
<li><a href="../280302/index.html">RSA encryption through the OpenSSL library in Delphi</a></li>
<li><a href="../280304/index.html">Implement a try macro for gcc under win32</a></li>
<li><a href="../280306/index.html">Learn to command</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>