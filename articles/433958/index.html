<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>TDD applications on Spring Boot: working with a database</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The second article from the series "Test-Driven Development Applications for Spring Boot" and this time I will talk about testing database access, an ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>TDD applications on Spring Boot: working with a database</h1><div class="post__text post__text-html js-mediator-article"><p>  The second article from the series "Test-Driven Development Applications for Spring Boot" and this time I will talk about testing database access, an important aspect of integration testing.  I will tell you how to determine the future service interface for data access through tests, how to use embedded in-memory databases for testing, work with transactions and load test data into the database. </p><a name="habracut"></a><br><p>  I will not talk much about TDD and testing in general, I invite everyone to read the first article - <a href="https://habr.com/post/431306/">How to build a pyramid in the trunk or Test-Driven Development applications for Spring Boot / Habr</a> . </p><br><p>  I will begin, as last time, with a small theoretical part, and proceed to the end-to-end test. </p><br><h1 id="piramida-testirovaniya">  Pyramid testing </h1><br><p>  For a start, a small, but necessary, description of such an important entity in testing, like <a href="https://martinfowler.com/articles/practical-test-pyramid.html">The Test Pyramid</a> or <em>the testing pyramid</em> . </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/f6c/930/f2d/f6c930f2d4ae8a6068696ace34e9566e.png" alt="image"></p><br><p>  (taken from <a href="https://martinfowler.com/articles/practical-test-pyramid.html">The Practical Test Pyramid</a> website) </p><br><p>  A testing pyramid is an approach where tests are organized in several levels. </p><br><ul><li>  <strong>The UI</strong> (or end-to-end, <strong>E2E</strong> ) tests are few and slow, but they test the real application ‚Äî no mocks or test doubles.  At this level, business often thinks and all BDD frameworks reside here (see Cucumber in the previous article). </li><li>  They are followed by <strong>integration tests</strong> (service, component - each has its own terminology), which are already focused on a specific component (service) of the system, isolating it from other components through mocks / doubles, but still checking integration with real external systems - these tests are connected to the database, send REST requests, work with the message queue.  In fact, these are tests that check the integration of business logic with the outside world. </li><li>  At the very bottom are fast <strong>unit tests</strong> that test minimal blocks of code (classes, methods) in complete isolation. </li></ul><br><p>  Spring helps with writing tests for each level - <em>even for unit tests</em> , although this may sound strange, because in the world of unit tests, no knowledge about the framework should exist at all.  After writing the E2E test, I will show you how Spring allows even such purely ‚Äúintegration‚Äù things as controllers to test in isolation. </p><br><p>  But I will start from the very top of the pyramid - the slow UI test, which starts and tests a full-fledged application. </p><br><h1 id="end-to-end-test">  End-to-end test </h1><br><p>  So, a new feature: </p><br><pre><code class="plaintext hljs">Feature: A list of available cakes Background: catalogue is updated Given the following items are promoted | Title | Price | | Red Velvet | 3.95 | | Victoria Sponge | 5.50 | Scenario: a user visiting the web-site sees the list of items Given a new user, Alice When she visits Cake Factory web-site Then she sees that "Red Velvet" is available with price ¬£3.95 And she sees that "Victoria Sponge" is available with price ¬£5.50</code> </pre> <br><blockquote>  And here immediately an interesting aspect - what to do with the previous test, about the greeting on the main page?  It seems to be no longer relevant, after the launch of the site, the main one will already have a directory, not a greeting.  There is no definite answer, I would say - it depends on the situation.  But the main advice - do not get attached to the tests!  Delete when they lose relevance, rewrite to make it easier to read.  Especially E2E tests - it should be, in fact, a <strong>live and relevant specification</strong> .  In my case, I simply deleted the old tests, and replaced them with new ones, using some previous steps and adding nonexistent ones. </blockquote><p>  Now I came to the important point - the choice of technology for data storage.  In accordance with the <em>lean</em> approach, I would like to postpone the choice until the very last moment - when I will know for sure whether the relational model or not, what the requirement for consistency, transaction.  In general, there are solutions for this - for example, the creation of <strong>test twins</strong> and various <strong>in-memory</strong> repositories, but for now I don‚Äôt want to complicate the article and immediately select the technology - relational databases.  But in order to save at least some possibility of choosing a database, I will add an abstraction - <a href="https://spring.io/projects/spring-data-jpa">Spring Data JPA</a> .  JPA itself is a fairly abstract specification for accessing relational databases, and Spring Data makes it even easier to use. </p><br><blockquote>  Spring Data JPA uses Hibernate by default as a provider, but also supports other technologies, such as EclipseLink and MyBatis.  For people who are not very familiar with the Java Persistence API, JPA is like an interface, and Hibernate is the class that implements it. </blockquote><p>  So, to add support for JPA, I added a couple of dependencies: </p><br><pre> <code class="plaintext hljs">implementation('org.springframework.boot:spring-boot-starter-data-jpa') runtime('com.h2database:h2')</code> </pre> <br><p>  As a database, I will use <a href="http://h2database.com/">H2</a> - an embedded database written in Java, with the ability to work in in-memory mode. </p><br><p>  Using Spring Data JPA, I immediately define the interface for accessing data: </p><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CakeRepository</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CrudRepository</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CakeEntity</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">String</span></span></span><span class="hljs-class">&gt; </span></span>{ }</code> </pre> <br><p>  And the essence: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Entity</span></span> <span class="hljs-meta"><span class="hljs-meta">@Builder</span></span> <span class="hljs-meta"><span class="hljs-meta">@AllArgsConstructor</span></span> <span class="hljs-meta"><span class="hljs-meta">@Table</span></span>(name = <span class="hljs-string"><span class="hljs-string">"cakes"</span></span>) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CakeEntity</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CakeEntity</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ } <span class="hljs-meta"><span class="hljs-meta">@Id</span></span> <span class="hljs-meta"><span class="hljs-meta">@GeneratedValue</span></span>(strategy = GenerationType.IDENTITY) Long id; <span class="hljs-meta"><span class="hljs-meta">@NotBlank</span></span> String title; <span class="hljs-meta"><span class="hljs-meta">@Positive</span></span> BigDecimal price; <span class="hljs-meta"><span class="hljs-meta">@NotBlank</span></span> <span class="hljs-meta"><span class="hljs-meta">@NaturalId</span></span> String sku; <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> promoted; <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">equals</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object o)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> == o) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (o == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> || getClass() != o.getClass()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; CakeEntity cakeEntity = (CakeEntity) o; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Objects.equals(title, cakeEntity.title); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hashCode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Objects.hash(title); } }</code> </pre> <br><p>  In the description of the essence there are a couple of not the most obvious things. </p><br><ul><li>  <code>@NaturalId</code> for the <code>sku</code> field.  This field is used as a ‚Äúnatural identifier‚Äù to verify equality of entities ‚Äî the use of all fields or the <code>@Id</code> field in the <code>equals</code> / <code>hashCode</code> methods are rather an anti-pattern.  How correctly to check equality of entities is well written, for example, <a href="https://vladmihalcea.com/how-to-implement-equals-and-hashcode-using-the-jpa-entity-identifier/">here</a> . </li><li>  To reduce the amount of boilerplate code a little bit, I use the <a href="https://projectlombok.org/">Project Lombok</a> -annotation processor for Java.  It allows you to add different useful things, like <code>@Builder</code> - to automatically generate the builder for the class and <code>@AllArgsConstructor</code> to create a constructor for all the fields. </li></ul><br><p>  The interface implementation will be provided automatically by Spring Data. </p><br><h1 id="vniz-po-piramide">  Down the pyramid </h1><br><p>  Now is the time to go down to the next level of the pyramid.  As a rule of thumb, I would recommend <strong>always starting with the e2e test</strong> , because it will allow you to define the ‚Äúend goal‚Äù and the limits of the new feature, but there are no more strict rules.  It is not necessary to write an integration test first, before moving to the unit level.  It just happens that it‚Äôs more convenient and easier - and it‚Äôs quite natural to go ‚Äúdown‚Äù. </p><br><p>  But specifically now, I would like to immediately break this rule and write a unit test that will help determine the interface and contract of a new component that does not exist yet.  The controller must return a model that it fills out of some component X, and I wrote this test: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@ExtendWith</span></span>(MockitoExtension.class) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IndexControllerTest</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Mock</span></span> CakeFinder cakeFinder; <span class="hljs-meta"><span class="hljs-meta">@InjectMocks</span></span> IndexController indexController; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Set&lt;Cake&gt; cakes = Set.of(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Cake(<span class="hljs-string"><span class="hljs-string">"Test 1"</span></span>, <span class="hljs-string"><span class="hljs-string">"¬£10"</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Cake(<span class="hljs-string"><span class="hljs-string">"Test 2"</span></span>, <span class="hljs-string"><span class="hljs-string">"¬£10"</span></span>)); <span class="hljs-meta"><span class="hljs-meta">@BeforeEach</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setUp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ when(cakeFinder.findPromotedCakes()).thenReturn(cakes); } <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">shouldReturnAListOfFoundPromotedCakes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ ModelAndView index = indexController.index(); assertThat(index.getModel()).extracting(<span class="hljs-string"><span class="hljs-string">"cakes"</span></span>).contains(cakes); } }</code> </pre> <br><p>  This is a pure unit test - no contexts, no databases here, only <a href="https://site.mockito.org/">Mockito</a> for mocks.  And this test is just a good demonstration of how Spring helps a unit with tests - the <em>controller in Spring MVC is just a class whose methods take parameters of normal types and return POJO objects - View Models</em> .  There are no HTTP requests, no responses, heders, JSON, XML - all this will be automatically applied below the stack, in the form of converters and serializers.  Yes, there is a small ‚Äúhint‚Äù on Spring in the form of a <code>ModelAndView</code> , but this is a regular POJO and you can even get rid of it if you wish, it is necessary for UI controllers. </p><br><blockquote>  I will not talk much about the Mockito, you can read everything in the official documentation.  Specifically, in this test there are only interesting points - I use <code>MockitoExtension.class</code> as a test performer, and it automatically generates mocks for fields annotated with <code>@Mock</code> and then injects these moks as dependencies into the constructor for an object in a field marked <code>@InjectMocks</code> .  You can do all this manually using the <code>Mockito.mock()</code> method and then creating a class. </blockquote><p>  And this test helps to determine the method of the new component - <code>findPromotedCakes</code> , the list of cakes that we want to show on the main page.  It does not define what it is, or how it should work with the base.  The sole responsibility of the controller is to take what was transferred to it and return it in a certain field of the model ("cakes").  Nevertheless, in my interface <code>CakeFinder</code> already has the first method, which means you can write an integration test for it. </p><br><blockquote>  I deliberately made all the classes inside the package <code>cakes</code> <strong>package private</strong> so that no one outside the package could use them.  The only way to get data from the database is the CakeFinder interface, which is my ‚Äúcomponent X‚Äù for accessing the database.  It becomes a natural ‚Äúconnector‚Äù, which I can easily lock further, if I need to test something in isolation and not touch the base.  And its only implementation is JpaCakeFinder.  And if, for example, in the future, the database type or data source changes, then you will need to add the implementation of the <code>CakeFinder</code> interface, without changing the code that uses it. </blockquote><br><h1 id="integracionnyy-test-dlya-jpa-ispolzuya-datajpatest">  Integration test for JPA using @DataJpaTest </h1><br><p>  Integration tests are Spring bread and butter.  In it, in general, everything is so great done for integration testing, that developers sometimes do not want to go to a unit-level or neglect the UI level.  This is not bad and not good - I repeat that the main goal of the tests is confidence.  And a set of quick and effective integration tests can be enough to provide this confidence.  However, there is a danger that over time these tests will either be slower and slower, or simply start testing the components in isolation, instead of integration. </p><br><p>  Integration tests can run the application as is ( <code>@SpringBootTest</code> ), or its separate component (JPA, Web).  In my case, I want to write a focused test for JPA - so I don‚Äôt need to configure controllers or any other components.  In Spring Boot Test, the <code>@DataJpaTest</code> annotation is responsible for <code>@DataJpaTest</code> .  This is a <em>meta-</em> abstract, i.e.  it combines several different annotations at once, configuring different aspects of the test. </p><br><ul><li>  @AutoConfigureDataJpa </li><li>  @AutoConfigureTestDatabase </li><li>  @AutoConfigureCache </li><li>  @AutoConfigureTestEntityManager </li><li>  @Transactional </li></ul><br><p>  First, I will tell about each separately, and then I will show the finished test. </p><br><p>  <strong>@AutoConfigureDataJpa</strong> <br>  Loads a whole set of configurations and configures - repositories (automatic generation of implementations for <code>CrudRepositories</code> ), FlyWay and Liquibase database migration tools, connection to a database using DataSource, a transaction manager, and, finally, Hibernate.  In essence, this is just a set of configurations relevant to data access ‚Äî neither the <code>DispatcherServlet</code> from the Web MVC nor the other components are included. </p><br><p>  <strong>@AutoConfigureTestDatabase</strong> <br>  This is one of the most interesting aspects of the JPA test.  This configuration <em>searches the classpath for one of the supported embedded databases and reconfigures the context so that the DataSource points to a randomly created in-memory database</em> .  Since I added a dependency on the H2 base, I don‚Äôt need to do anything else, just having this annotation automatically for each test run will provide an empty base, and this is incredibly convenient. </p><br><p>  It is worth remembering that this database will be completely empty, without a schema.  To generate a circuit, there are a couple of options. </p><br><ol><li>  Use the <strong>Auto DDL</strong> feature from Hibernate.  Spring Boot Test will automatically set this value to <code>create-drop</code> , so that Hibernate will generate a schema from the entity description and delete it at the end of the session.  This is an incredibly powerful feature of Hibernate, which is very useful for tests. </li><li>  Use migrations created by <a href="https://flywaydb.org/">Flyway</a> or <a href="https://www.liquibase.org/">Liquibase</a> . </li></ol><br><p>  More information about the different approaches to initializing the database can be found in the <a href="https://docs.spring.io/spring-boot/docs/current/reference/html/howto-database-initialization.html">documentation</a> . </p><br><p>  <strong>@AutoConfigureCache</strong> <br>  Simply configures the cache to use NoOpCacheManager - i.e.  do not cache anything.  This is useful to avoid surprises in tests. </p><br><p>  <strong>@AutoConfigureTestEntityManager</strong> <br>  Adds a special object <code>TestEntityManager</code> to the context, which itself is an interesting beast.  <code>EntityManager</code> is the main JPA class that is responsible for adding entities to the session, deleting, and similar things.  But when, for example, Hibernate comes into operation, adding an entity to a session does not mean that the request will be executed into the database, and loading from the session does not mean that the select request will be executed.  Due to the internal mechanisms of Hibernate, real operations with the base will be executed at the right time, which will be determined by the framework itself.  But in the tests it may be necessary to force something to send to the database, because the goal of the tests is to test the integration.  And <code>TestEntityManager</code> is just a helper that will help some operations with the database enforced - for example, <code>persistAndFlush()</code> will force Hibernate to perform all requests. </p><br><p>  <strong>@Transactional</strong> <br>  This annotation makes all the tests in the class transactional, with automatic rollback of the transaction upon completion of the test.  This is simply a ‚Äúcleanup‚Äù mechanism for the database before each test, because otherwise it would be necessary to manually delete the data from each table. </p><br><blockquote>  Whether a test should manage a transaction is not as simple and obvious a question as it may seem.  Despite the convenience of the ‚Äúclean‚Äù state of the base, the presence of <code>@Transactional</code> in tests can be an unpleasant surprise if the ‚Äúcombat‚Äù code does not start the transaction itself, but requires an existing one.  This may lead to the integration test passing, but when executing the real code from the controller, and not from the test, the service will not have an active transaction and the method will throw an exception.  Although it looks dangerous, in the presence of high-level tests of UI tests, the transactivity of tests is not so terrible.  In my experience, I saw only once, when, with a passing integration test, production dropped, which clearly required an existing transaction.  But if you still need to check that the services and components manage the transactions themselves, you can ‚Äúblock‚Äù the <code>@Transactional</code> annotation on the test with the desired mode (for example, do not start the transaction). </blockquote><br><h1 id="integracionnyy-test-so-springboottest">  Integration test with @SpringBootTest </h1><br><p>  I also want to note that <code>@DataJpaTest</code> is not a unique example of a focal integration test, there is still <code>@WebMvcTest</code> , <code>@DataMongoTest</code> and many others.  But one of the most important test annotations remains <code>@SpringBootTest</code> , which runs the application <em>‚Äúas is‚Äù</em> for tests - with all the configured components and integrations.  There is a logical question - if you can run the entire application, why make focal DataJpa tests, for example?  I would say that there are no strict rules again. </p><br><p>  If <em>it is possible</em> to run applications every time, isolate crashes in tests, do not overload and do not over-complicate the Setup test - then of course you can and should use @SpringBootTest. </p><br><p>  However, in real life, applications may require a lot of different settings, connect to different systems, but I would not want my database access tests to fail, because  Connection to the message queue is not configured.  Therefore, it is important to use common sense, and if in order to make the test with the @SpringBootTest annotation work, you need to lock half of the system - does it make any sense at all in the @SpringBootTest? </p><br><h1 id="podgotovka-dannyh-dlya-testa">  Data preparation for the test </h1><br><p>  One of the key points for tests is data preparation.  Each test should be performed in isolation, and prepare the environment before starting, bringing the system to its original desired state.  The easiest way to do this is to use <code>@BeforeEach</code> / <code>@BeforeAll</code> annotations and add entries to the database there using the repository, <code>EntityManager</code> or <code>TestEntityManager</code> .  But there is another option that allows you to run a prepared script or execute the necessary SQL query, this is the <code>@Sql</code> annotation.  Spring Boot Test before running the test will automatically run the specified script, eliminating the need to add the <code>@BeforeAll</code> block, and take care of the <code>@Transactional</code> about cleaning the data. </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@DataJpaTest</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JpaCakeFinderTest</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String PROMOTED_CAKE = <span class="hljs-string"><span class="hljs-string">"Red Velvet"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String NON_PROMOTED_CAKE = <span class="hljs-string"><span class="hljs-string">"Victoria Sponge"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> CakeFinder finder; <span class="hljs-meta"><span class="hljs-meta">@Autowired</span></span> CakeRepository cakeRepository; <span class="hljs-meta"><span class="hljs-meta">@Autowired</span></span> TestEntityManager testEntityManager; <span class="hljs-meta"><span class="hljs-meta">@BeforeEach</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setUp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.testEntityManager.persistAndFlush(CakeEntity.builder().title(PROMOTED_CAKE) .sku(<span class="hljs-string"><span class="hljs-string">"SKU1"</span></span>).price(BigDecimal.TEN).promoted(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>).build()); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.testEntityManager.persistAndFlush(CakeEntity.builder().sku(<span class="hljs-string"><span class="hljs-string">"SKU2"</span></span>) .title(NON_PROMOTED_CAKE).price(BigDecimal.ONE).promoted(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>).build()); finder = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> JpaCakeFinder(cakeRepository); } ... }</code> </pre> <br><h1 id="red-green-refactor-cikl">  Red-green-refactor cycle </h1><br><p>  Despite this amount of text, for the developer, the test still looks like a simple class annotated with @DataJpaTest, but I hope that I could show how much useful is happening under the hood, which the developer can not think about.  Now you can go to the TDD loop and this time I will show a couple of TDD iterations, with examples of refactoring and the minimum code.  To make it clearer, I highly recommend viewing the history in Git, where each commit is a separate and significant step describing what and how it does. </p><br><h2 id="podgotovka-dannyh">  Data preparation </h2><br><p>  I use the <code>@BeforeAll</code> / <code>@BeforeEach</code> and manually create all the records in the database.  The example with the <code>@Sql</code> annotation is placed in a separate <code>JpaCakeFinderTestWithScriptSetup</code> class, it duplicates tests, which of course should not be, and exists with the sole purpose of demonstrating the approach. </p><br><p>  The initial state of the system - there are two entries in the system, one cake participates in the promotion and should be included in the result returned by the method, the second one does not. </p><br><h2 id="pervyy-test-integracionnyy-test">  First test integration test </h2><br><p>  The first test is the easiest - <code>findPromotedCakes</code> should include a description and price of the cake involved in the promotion. </p><br><h3 id="red">  Red </h3><br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">shouldReturnPromotedCakes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Iterable&lt;Cake&gt; promotedCakes = finder.findPromotedCakes(); assertThat(promotedCakes).extracting(Cake::getTitle).contains(PROMOTED_CAKE); assertThat(promotedCakes).extracting(Cake::getPrice).contains(<span class="hljs-string"><span class="hljs-string">"¬£10.00"</span></span>); }</code> </pre> <br><p>  The test, of course, fails - the default implementation returns an empty Set. </p><br><h3 id="green">  Green </h3><br><p>  We naturally want to write the filter immediately, make a request to the database with <code>where</code> and so on.  But following TDD practice, I have to write a <em>minimal code for the test to pass</em> .  And this minimum code is to return all records in the database.  Yes, so simple and trite. </p><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Set&lt;Cake&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findPromotedCakes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Spliterator&lt;CakeEntity&gt; cakes = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.cakeRepository.findAll() .spliterator(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> StreamSupport.stream(cakes, <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>).map( cakeEntity -&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Cake(cakeEntity.title, formatPrice(cakeEntity.price))) .collect(Collectors.toSet()); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">formatPrice</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(BigDecimal price)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"¬£"</span></span> + price.setScale(<span class="hljs-number"><span class="hljs-number">2</span></span>, RoundingMode.DOWN).toPlainString(); }</code> </pre> <br><blockquote>  Probably some people will argue that here you can make the test green even without a base - just hard-code the result expected by the test.  I occasionally hear such an argument, but I think everyone understands that TDD is not a dogma or a religion, it makes no sense to bring this to the point of absurdity.  But if you really really want to - you can, for example, randomize the data on the installation, so that they are not hardcoded. </blockquote><br><h3 id="refactor">  Refactor </h3><br><p>  I don‚Äôt see much refactoring here, so this phase can be skipped for this particular test.  But I would not recommend to ignore this phase anyway, it is better to stop and think every time in the ‚Äúgreen‚Äù state of the system - is it possible to change something to make it better and easier? </p><br><h2 id="vtoroy-test">  Second test </h2><br><p>  But the second test will already verify that not promoted cake will not fall into the result returned by <code>findPromotedCakes</code> . </p><br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">shouldNotReturnNonPromotedCakes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Iterable&lt;Cake&gt; promotedCakes = finder.findPromotedCakes(); assertThat(promotedCakes).extracting(Cake::getTitle) .doesNotContain(NON_PROMOTED_CAKE); }</code> </pre> <br><h3 id="red-1">  Red </h3><br><p>  The test, as expected, falls - there are two entries in the database and the code simply returns them all. </p><br><h3 id="green-1">  Green </h3><br><p>  And again, you can think - and what is the minimum code you can write to pass the test?  Since there is already a stream and its assembly, you can simply add a <code>filter</code> block there. </p><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Set&lt;Cake&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findPromotedCakes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Spliterator&lt;CakeEntity&gt; cakes = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.cakeRepository.findAll() .spliterator(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> StreamSupport.stream(cakes, <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) .filter(cakeEntity -&gt; cakeEntity.promoted) .map(cakeEntity -&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Cake(cakeEntity.title, formatPrice(cakeEntity.price))) .collect(Collectors.toSet()); }</code> </pre> <br><p>  Restart tests - integration tests are now green.  An important point has come - due to the combination of the controller unit-test and integration test for working with the database, my feature is ready - and now the UI test passes! </p><br><h3 id="refactor-1">  Refactor </h3><br><p>  And once all the tests are green, it‚Äôs time to refactor.  I think it is not necessary to clarify that filtering in memory is not the best idea, it is better to do this in the database.  To do this, I added a new method in <code>CakesRepository</code> - <code>findByPromotedIsTrue</code> : </p><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CakeRepository</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CrudRepository</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CakeEntity</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">String</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-function"><span class="hljs-function">Iterable&lt;CakeEntity&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findByPromotedIsTrue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; }</code> </pre> <br><p>  For this method, Spring Data automatically generated a method that will execute a query of the form <code>select from cakes where promoted = true</code> .  You can read more about query generation in the <a href="https://docs.spring.io/spring-data/jpa/docs/current/reference/html/">documentation</a> for Spring Data. </p><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Set&lt;Cake&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findPromotedCakes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Spliterator&lt;CakeEntity&gt; cakes = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.cakeRepository.findByPromotedIsTrue() .spliterator(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> StreamSupport.stream(cakes, <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>).map( cakeEntity -&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Cake(cakeEntity.title, formatPrice(cakeEntity.price))) .collect(Collectors.toSet()); }</code> </pre> <br><p>  This is a good example of the flexibility that integration testing and the black box approach provide.  If the repository was locked, then adding a new method there without changing the tests was not impossible. </p><br><h1 id="podklyuchenie-k-production-baze">  Connection to production base </h1><br><p>  To add a bit of ‚Äúrealism‚Äù and show how you can separate the configuration for the tests and the main application, I will add the data access configuration for the ‚Äúproduction‚Äù application. </p><br><p>  Everything is traditionally added to the section in <code>application.yml</code> : </p><br><pre> <code class="plaintext hljs">datasource: url: jdbc:h2:./data/cake-factory</code> </pre><br><p>  This automatically saves the data in the file system in the <code>./data</code> folder.  I note that this folder will not be created in tests - <code>@DataJpaTest</code> will automatically replace the connection to the file base with a random base in memory due to the presence of the <code>@AutoConfigureTestDatabase</code> annotation. </p><br><blockquote>  Two useful things that may come in handy are the <code>data.sql</code> and <code>schema.sql</code> .   , Spring Boot             .          ,   , ,    . </blockquote><br><h1 id="zaklyuchenie">  Conclusion </h1><br><p> ,               ,    ,       TDD . </p><br><p>      Spring Security ‚Äî                Spring,       . </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/433958/">https://habr.com/ru/post/433958/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../433946/index.html">Crib for artificial intelligence - throw away too much, teach the main thing. Technique processing training sequences</a></li>
<li><a href="../433948/index.html">How to make payment for services more convenient: the experience of an IaaS provider</a></li>
<li><a href="../433952/index.html">10 reasons to choose a solution for SAP HANA from HPE. Part 2</a></li>
<li><a href="../433954/index.html">Eight audio technologies and audio gadgets that will get into the TECnology hall of fame in 2019</a></li>
<li><a href="../433956/index.html">Modders have attracted AI to improve textures in games</a></li>
<li><a href="../433964/index.html">ECMAScript Modules in Node.js: New Plan</a></li>
<li><a href="../433966/index.html">Christmas card from Mars. The ESA showed a large accumulation of ice on the surface of the red planet.</a></li>
<li><a href="../433968/index.html">Maximum degenerate game of communication</a></li>
<li><a href="../433972/index.html">HolyJS 2018 Moscow through the eyes of the participant</a></li>
<li><a href="../433974/index.html">Chat bot gains hearing, or suffering amateur</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>