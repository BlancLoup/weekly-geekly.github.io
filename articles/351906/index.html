<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>JavaScript compiler using ANTLR</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Earlier this year, I joined the team working on MongoDB Compass , a GUI for MongoDB. Compass users through Intercom have requested a tool that allows ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>JavaScript compiler using ANTLR</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/cz/z2/rd/czz2rdgu2rihmxmrnqielvrkmai.png" width="740"><br><br><br>  Earlier this year, I joined the team working on <a href="https://www.mongodb.com/download-center%3Ffilter%3Denterprise%26utm_source%3Dgoogle%26utm_campaign%3DEMEA_Germany_CorpEntOnly_Brand_Alpha_FM%26utm_keyword%3Dcompass%2520mongodb%26utm_device%3Dc%26utm_network%3Dg%26utm_medium%3Dcpc%26utm_creative%3D205021191501%26utm_matchtype%3De%26_bt%3D205021191501%26_bk%3Dcompass%2520mongodb%26_bm%3De%26_bn%3Dg%26jmp%3Dsearch%26gclid%3DCjwKCAiAlfnUBRBQEiwAWpPA6bnTmjsACHh5SoScg2vUy__vqBH541jZuwbPo3al7JlYbp3PAUjiARoCW4kQAvD_BwE">MongoDB Compass</a> , a GUI for MongoDB.  Compass users through Intercom have requested a tool that allows them to write database queries using any convenient programming language supported <a href="https://docs.mongodb.com/ecosystem/drivers/">by the MongoDB driver</a> .  That is, we needed the ability to transform (compile) <a href="https://docs.mongodb.com/manual/mongo/">the Mongo Shell</a> language into other languages ‚Äã‚Äãand vice versa. <br><br>  <i>This article can be a practical guide to help when writing a compiler in JavaScript, as well as a theoretical resource that includes the basic concepts and principles of compiler creation.</i>  <i>At the end is not only a complete list of all materials used in writing, but also links to additional literature aimed at a deeper study of the issue.</i>  <i>Information in the article is submitted sequentially, starting with the study of the subject area and then gradually complicating the functionality of the application being developed as an example.</i>  <i>If during the reading it seems to you that you do not catch the transition from one step to another, you can refer to the <a href="https://github.com/alenakhineika/js-runtime">full version of this program</a> and perhaps this will help to eliminate the gap.</i> <br><a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  Content </h2><br><ol><li>  <a href="https://habr.com/ru/post/351906/">Terminology</a> </li><li>  <a href="https://habr.com/ru/post/351906/">Study</a> </li><li>  <a href="https://habr.com/ru/post/351906/">Compiler building</a> <br><ul><li>  <a href="https://habr.com/ru/post/351906/">Install ANTLR</a> </li><li>  <a href="https://habr.com/ru/post/351906/">Creating a project on Node.js using ANTLR</a> </li><li>  <a href="https://habr.com/ru/post/351906/">Source code analysis and syntax tree construction</a> </li><li>  <a href="https://habr.com/ru/post/351906/">Code generation</a> </li><li>  <a href="https://habr.com/ru/post/351906/">Error processing</a> </li></ul><br></li><li>  <a href="https://habr.com/ru/post/351906/">Conclusion</a> </li></ol><br><h2><a name="Terminology"></a>  Terminology </h2><br>  <b>The compiler</b> converts the source program in a high-level programming language into an equivalent program in another language that can be executed without the compiler. <br><br>  Lexer - A compiler element that performs lexical analysis. <br><br>  Tokenizing - The process of analyzing the input sequence of characters into recognized groups (tokens, tokens). <br><br>  Parser (Parser) - The element of the compiler that performs parsing, the result of which is the parse tree. <br><br>  Parsing - The process of comparing a linear sequence of lexemes of a natural or formal language with its formal grammar. <br><br>  <b>Lexeme</b> or Token - A sequence of valid characters in a programming language that makes sense to the compiler. <br><br>  <b>Visitor</b> (Visitor) - The pattern of working with a tree, in which, to continue processing of descendants, you must manually call a workaround. <br><br>  <b>Listener</b> (Walker or Walker) - Pattern of working with a tree, when the methods of visiting all descendants are called automatically.  In the Listener, there is a method called at the beginning of a site visit (enterNode) and a method called after a site visit (exitNode). <br><br>  Parse Tree <b>or</b> Parse Tree - A structure representing the result of the work of the parser.  It reflects the syntax of the structures of the input language and clearly contains the complete interrelation of operations. <br><br>  <b>The abstract syntax tree</b> (AST - Abstract Syntax Tree) differs from the parse tree in that there are no nodes and edges for those syntax rules that do not affect the semantics of the program. <br><br>  <b>Universal Abstract Syntax Tree</b> (UAST - Universal Abstract Syntax Tree) is a normalized form of AST with language independent annotations. <br><br>  <b>Traversing a tree in depth</b> (DFS - Depth-first search) - One of the methods of traversing the graph.  The strategy of searching in depth, as the name implies, is to go "in depth" of the graph as far as possible. <br><br>  <b>Grammar</b> (Grammar) - A set of instructions for constructing lexical and syntactic analyzers. <br><br>  <b>Root</b> - The topmost node of the tree from which to start the walk.  This is the only tree node that does not have an ancestor, but is itself an ancestor for all other tree nodes. <br><br>  <b>Leaf, leaf or terminal node</b> (Leaf) - A node that has no descendants. <br><br>  <b>Parent</b> - A node that has a child.  Each tree node has zero or more descendant nodes. <br><br>  Literal - Representation of some fixed value or data type. <br><br>  <b>The code</b> generator receives as input the intermediate representation of the source program and transforms it into the target language. <br><br><br><h2><a name="Research"></a>  Study </h2><br>  You can consider three ways to solve the problem of transforming one programming language into another (Source-to-source transformation): <br><br><ul><li>  Use existing parsers for specific programming languages. </li><li>  Create your own parser. </li><li>  Use a tool or library to generate parsers. </li></ul><br>  The first option is good, but covers only the most famous and supported languages.  For JavaScript, there are such parsers as <a href="https://github.com/jquery/esprima">Esprima</a> , <a href="https://github.com/substack/node-falafel">Falafel</a> , <a href="https://github.com/mishoo/UglifyJS2">UglifyJS</a> , <a href="http://zaa.ch/jison/">Jison</a> and others.  Before you write something yourself, it is worth exploring the existing tools, perhaps they completely cover the functionality you need. <br><br>  If you are unlucky and have not found a parser for your language or the found parser does not satisfy all your needs, you can resort to the second option and write it yourself. <br><br>  A good start for understanding compiler writing from scratch can be <a href="https://github.com/jamiebuilds/the-super-tiny-compiler">Super Tiny Compiler</a> .  If you remove comments from the file, then only 200 lines of code remain, which contain all the basic principles of a modern compiler. <br><br>  The author of the article <a href="http://blog.mgechev.com/2017/09/16/developing-simple-interpreter-transpiler-compiler-tutorial/">Implementing a Simple Compiler on 25 Lines of JavaScript</a> shares its experience of creating a JavaScript compiler.  And covers concepts such as lexical analysis, parsing, and code generation. <br><br>  <a href="https://www.codeproject.com/Articles/345888/How-to-write-a-simple-interpreter-in-JavaScript">How to write a simple interpreter in JavaScript</a> is another resource that considers the process of creating an interpreter using the example of a simple calculator. <br><br>  Writing a compiler from scratch is a time-consuming process that requires a thorough preliminary study of the syntactic features of the languages ‚Äã‚Äãbeing compiled.  In this case, it is necessary to recognize not only keywords, but also their position relative to each other.  The rules for analyzing the source code should be unambiguous and give an identical result at the output, under the same initial conditions. <br><br>  With this, tools and libraries for parser generation can help.  They take the raw source code, break it into tokens (lexical analysis), then match the linear sequences of tokens to their formal grammar (syntactic analysis) and put them into a tree-like organized structure, according to which a new code can be built.  Some of these are covered in the article <a href="https://tomassetti.me/parsing-in-javascript/">Parsing in JavaScript: Tools and Libraries</a> . <br><br><img src="https://habrastorage.org/webt/ib/el/vw/ibelvw6fn2ex2egpa9lfjh0osfq.png" width="600"><br><br><br>  At first glance it may seem that the solution to the problem is in our pocket, however, in order to teach the parser to recognize the source code, we will have to spend many more man-hours on writing instructions (grammar).  And if the compiler has to support several programming languages, this task becomes much more complicated. <br><br>  It is clear that we are not the first developers who are faced with a similar task.  The work of any IDE is related to code analysis, Babel transforms modern JavaScript into a standard supported by all browsers.  This means that there must be grammars that we could reuse and thus not only facilitate our task, but also avoid a number of potentially serious errors and inaccuracies. <br><br>  Thus, our choice fell on ANTLR, which is best suited to our requirements, since it contains grammars for almost all programming languages. <br><br>  As an alternative, you can consider <a href="http://doc.bblf.sh/">Babelfish</a> , which analyzes any file in any supported language, extracts AST from it, and converts it to UAST, in which nodes are not tied to the syntax of the source language.  At the entrance we can have javascript or c #, but at the level of UAST we will not see any differences.  In the terminology of compilers, the transformation process is responsible for the process of converting AST to a universal type. <br><br><img src="https://habrastorage.org/webt/o5/df/qb/o5dfqbbs8nx1szgbkablez67-fg.png" width="398"><br><br><br>  The novice compiler author may also be interested in <a href="https://astexplorer.net/">Astexplorer</a> , an interface that allows you to see what the syntax tree for a given code fragment and corresponding to the chosen language of the parser can be.  It can be useful for debagging or forming a general idea of ‚Äã‚Äãthe structure of AST. <br><br><br><h2><a name="ANTLR"></a>  Compiler building </h2><br>  <a href="http://www.antlr.org/">ANTLR</a> (Another Tool For Language Recognition - another language recognition tool) is a parser generator written in Java.  At the entrance, it takes a piece of text, then analyzes it on the basis of <a href="https://github.com/antlr/grammars-v4">grammars</a> and converts it into an organized structure, which in turn can be used to create an abstract syntax tree.  ANTLR 3 took on this task too - generated AST.  However, ANTLR 4 eliminated this functionality in favor of using <a href="https://github.com/antlr/stringtemplate4">StringTemplates</a> and operates only with such a concept as ‚ÄúParse Tree‚Äù. <br><br>  For more information, you can refer to the <a href="">documentation</a> , or read the excellent article <a href="https://tomassetti.me/antlr-mega-tutorial/">The ANTLR Mega Tutorial</a> , which explains what a parser is, why you need it, how to configure ANTLR, useful ANTLR functions and much more with a ton of examples. <br><br>  In more detail about the creation of grammars can be read here: <br><br><ul><li>  <a href="https://habrahabr.ru/company/pt/blog/339336/">MySQL grammar on ANTLR 4</a> </li><li>  <a href="https://habrahabr.ru/company/pt/blog/210060/">Treating tree structures and unified AST</a> </li></ul><br>  To transform one programming language into another, we decided to use ANTLR 4 and one of its grammars, namely ECMAScript.g4.  We chose JavaScript because its syntax corresponds to the Mongo Shell language and is also the development language of the Compass application.  Interesting fact: we can build a parse tree using Lexer and Parser C #, but bypassing it using ECMAScript grammar nodes. <br><br>  This question requires more detailed research.  It‚Äôs safe to say that not every code structure will be correctly recognized by default.  It will be necessary to expand the workaround functionality with new methods and checks.  However, it is already clear that ANTLR is an excellent tool when it comes to supporting multiple parsers within a single application. <br><br>  ANTLR creates for us a list of auxiliary files for working with trees.  The content of these files is directly dependent on the rules specified in the grammar.  Therefore, with any grammar changes, these files must be regenerated.  This means that we should not use them directly for writing code, otherwise we will lose our changes during the next iteration.  We must create our classes and inherit them from the classes produced by ANTLR. <br><br>  The code generated as a result of ANTLR helps to create a parse tree, which in turn is the fundamental tool for generating new code.  The bottom line is to call the child nodes from left to right (assuming that this is the order of the source text) to return the formatted text that they represent. <br><br>  If the node is a literal, we need to return its actual value.  It's harder than it looks if you want the result to be accurate.  In this case, you should consider the possibility of displaying floating-point numbers without loss of accuracy, as well as numbers in different number systems.  For string literals, you should consider which type of quotes you support, and also not forget about the escape sequences of characters that should be escaped.  Do you support code comments?  Do you want to save the format of user input (spaces, blank lines), or do you want to bring the text to a more standard easier to read form.  On the one hand, the second option will look more professional, on the other - the user of your compiler may not be satisfied in the end, since he probably wants to get the output format identical to his input.  For these problems there is no universal solution, and they require a more detailed study of the scope of your compiler. <br><br>  We will consider a more simplified example to concentrate on the basics of writing a compiler using ANTLR. <br><br><br><h3><a name="Installation"></a>  Install ANTLR </h3><br><pre><code class="bash hljs">$ brew cask install java $ <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> /usr/<span class="hljs-built_in"><span class="hljs-built_in">local</span></span>/lib $ curl -O http://www.antlr.org/download/antlr-4.7.1-complete.jar $ <span class="hljs-built_in"><span class="hljs-built_in">export</span></span> CLASSPATH=<span class="hljs-string"><span class="hljs-string">".:/usr/local/lib/antlr-4.7.1-complete.jar:</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$CLASSPATH</span></span></span><span class="hljs-string">"</span></span> $ <span class="hljs-built_in"><span class="hljs-built_in">alias</span></span> antlr4=<span class="hljs-string"><span class="hljs-string">'java -Xmx500M -cp "/usr/local/lib/antlr-4.7.1-complete.jar:$CLASSPATH" org.antlr.v4.Tool'</span></span> $ <span class="hljs-built_in"><span class="hljs-built_in">alias</span></span> grun=<span class="hljs-string"><span class="hljs-string">'java org.antlr.v4.gui.TestRig'</span></span></code> </pre> <br>  To make sure that all of your settings were successful, type in the terminal: <br><br><pre> <code class="bash hljs">$ java org.antlr.v4.Tool</code> </pre> <br>  You should see information about the version of ANTLR, as well as help on commands. <br><br><img src="https://habrastorage.org/webt/p7/la/n3/p7lan3cfuduw4kz2chewi3zdshq.png" width="637"><br><br><br><h3><a name="Project"></a>  Creating a project on Node.js using ANTLR </h3><br><pre> <code class="bash hljs">$ mkdir js-runtime $ <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> js-runtime $ npm init</code> </pre><br>  Install <a href="">JavaScript runtime</a> , for this we need npm package antlr4 - <a href="https://www.npmjs.com/package/antlr4">JavaScript target for ANTLR 4</a> . <br><br><pre> <code class="bash hljs">$ npm i antlr4 --save</code> </pre> <br>  Download the <a href="">ECMAScript.g4</a> grammar, which we will further feed to our ANTLR. <br><br><pre> <code class="bash hljs">$ mkdir grammars $ curl --http1.1 https://github.com/antlr/grammars-v4/blob/master/ecmascript/ECMAScript.g4 --output grammars/ECMAScript.g4</code> </pre><br>  <i>By the way, <a href="http://www.antlr.org/tools.html">on the ANTLR site in the Development Tools section,</a> you can find links to plugins for IDEs such as Intellij, NetBeans, Eclipse, Visual Studio Code, and jEdit.</i>  <i>Color themes, semantic error checking, and visualization with diagrams make it easier to write and test grammars.</i> <br><br>  Finally, run ANTLR. <br><br><pre> <code class="bash hljs">$ java -Xmx500M -cp <span class="hljs-string"><span class="hljs-string">'/usr/local/lib/antlr-4.7.1-complete.jar:$CLASSPATH'</span></span> org.antlr.v4.Tool -Dlanguage=JavaScript -lib grammars -o lib -visitor -Xexact-output-dir grammars/ECMAScript.g4</code> </pre><br>  Add this script to package.json to always have access to it.  With any change to the grammar file, we need to restart ANTLR to apply the changes. <br><br><img src="https://habrastorage.org/webt/an/k3/kr/ank3kraw0ibich8qkb7nnuynori.png" width="740"><br><br><br>  Go to the lib folder and see that ANTLR has created a list of files for us.  Let's look at three of these in more detail: <br><br><ul><li>  <b>ECMAScriptLexer.js</b> splits the stream of source code symbols into a stream of tokens in accordance with the rules specified in the grammar. </li><li>  <b>ECMAScriptParser.js</b> from a stream of tokens builds an abstract connected tree structure called a parse tree. </li><li>  <b>ECMAScriptVisitor.js</b> is responsible for traversing the constructed tree.  Theoretically, we could independently process this tree using recursive traversal of descendants in depth.  However, with a large number of types of nodes and complex logic of their processing, it is better to visit each type of node with its unique method, as does the visitor. </li></ul><br>  Note that the default ANTLR does not create * Visitor.js.  The ANTLR deals with the listener in the standard way to traverse trees.  If you want to generate and then use Visitor instead of Listener, you need to explicitly specify this using the ' <code>-visitor</code> ' flag, as we did in our script: <br><br><pre> <code class="bash hljs">$ java -Xmx500M -cp <span class="hljs-string"><span class="hljs-string">'/usr/local/lib/antlr-4.7.1-complete.jar:$CLASSPATH'</span></span> org.antlr.v4.Tool -Dlanguage=JavaScript -lib grammars -o lib -visitor -Xexact-output-dir grammars/ECMAScript.g4</code> </pre><br>  The essence of the work of both methods, as well as the result, is very similar, however with Visitor your code looks cleaner and you have more control over the transformation process.  You can set in what order to visit the nodes of the tree and visit them at all.  You can also modify existing nodes during a crawl and you do not need to store information about visited nodes.  In the article <a href="http://saumitra.me/blog/antlr4-visitor-vs-listener-pattern/">Antlr4 - Visitor vs Listener Pattern,</a> this topic is discussed in more detail and by examples. <br><br><br><h3><a name="Tree"></a>  Source code analysis and syntax tree construction </h3><br>  Let's finally get started on programming.  You will find an example of similar code literally everywhere if you search by a combination of ANTLR and JavaScript. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> antlr4 = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'antlr4'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ECMAScriptLexer = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'./lib/ECMAScriptLexer.js'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ECMAScriptParser = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'./lib/ECMAScriptParser.js'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> input = <span class="hljs-string"><span class="hljs-string">'{x: 1}'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> chars = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> antlr4.InputStream(input); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> lexer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ECMAScriptLexer.ECMAScriptLexer(chars); lexer.strictMode = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   JavaScript strictMode const tokens = new antlr4.CommonTokenStream(lexer); const parser = new ECMAScriptParser.ECMAScriptParser(tokens); const tree = parser.program(); console.log(tree.toStringTree(parser.ruleNames));</span></span></code> </pre><br>  What we have done now: using the lexer and parser that ANTLR generated for us, we brought our source line to a tree view in LISP format (this is the standard tree output format in ANTLR 4).  According to the grammar, the root of the ECMAScript tree is the ` <code>program</code> rule, so we chose it as the starting point of the detour in our example.  However, this does not mean that this node should always be the first.  For the original string ` <code>{x: 1}</code> ` it would be perfectly fair to start a crawl with ` <code>expressionSequence</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> tree = parser.expressionSequence();</code> </pre> <br><img src="https://habrastorage.org/webt/fd/d3/to/fdd3to-l4uqw0a2q7khipevigl0.png" width="740"><br><br><br>  If you remove the formatting ` <code>.toStringTree()</code> `, then you can see the internal structure of the tree object. <br><br>  Conventionally, the whole process of transforming one programming language into another can be divided into three stages: <br><br><ul><li>  Source code analysis. </li><li>  Building a syntax tree. </li><li>  Generate new code. </li></ul><br>  As we can see, thanks to ANTLR, we have significantly simplified our work and in a few lines of code covered two whole steps.  Of course, we will come back to them, update the grammar, transform the tree, but nevertheless a good foundation has already been laid.  Grammars that are downloaded from the repository may also be incomplete or even with errors.  But perhaps they have already corrected the mistakes that you would have made if you started writing grammar from scratch yourself.  The meaning of this is, do not blindly believe code written by other developers, but you can save time writing identical rules for the improvement of existing ones.  Perhaps the next generation of young ANTLR students will already download your more perfect version of the grammar. <br><br><br><h3><a name="Codegeneration"></a>  Code generation </h3><br>  Create a new directory ` <code>codegeneration</code> and a new file PythonGenerator.js in the project. <br><br><pre> <code class="bash hljs">$ mkdir codegeneration $ <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> codegeneration $ touch PythonGenerator.js</code> </pre><br>  As you have already guessed, as an example, we are transforming something from JavaScript into Python. <br><br>  The generated ECMAScriptVisitor.js file contains a huge list of methods, each of which is automatically called during a tree traversal if the corresponding node is visited.  And at this very moment we can change the current node.  To do this, create a class that will inherit from ECMAScriptVisitor and override the methods we need. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ECMAScriptVisitor = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'../lib/ECMAScriptVisitor'</span></span>).ECMAScriptVisitor; <span class="hljs-comment"><span class="hljs-comment">/** * Visitor   ,  ANTLR *    JavaScript   Python  * * @returns {object} */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Visitor</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ECMAScriptVisitor</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/** *     * * @param {object} ctx * @returns {string} */</span></span> start(ctx) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.visitExpressionSequence(ctx); } } <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = Visitor;</code> </pre><br>  In addition to methods that conform to the syntax rules of grammar, ANTLR also supports <a href="http://www.antlr.org/api/Java/org/antlr/v4/runtime/tree/AbstractParseTreeVisitor.html">four special public methods</a> : <br><br><ul><li>  <b>visit ()</b> is responsible for traversing the tree. </li><li>  <b>visitChildren ()</b> is responsible for crawling sites. </li><li>  <b>visitTerminal ()</b> is responsible for bypassing tokens. </li><li>  <b>visitErrorNode ()</b> is responsible for bypassing invalid tokens. </li></ul><br>  We implement in our class the methods ` <code>visitChildren()</code> `, ` <code>visitTerminal()</code> ` and also ` <code>visitPropertyExpressionAssignment()</code> `. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/* *     * * @param {object} ctx * @returns {string} */</span></span> visitChildren(ctx) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> code = <span class="hljs-string"><span class="hljs-string">''</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; ctx.getChildCount(); i++) { code += <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.visit(ctx.getChild(i)); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> code.trim(); } <span class="hljs-comment"><span class="hljs-comment">/** *    (  )    * * @param {object} ctx * @returns {string} */</span></span> visitTerminal(ctx) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ctx.getText(); } <span class="hljs-comment"><span class="hljs-comment">/** *  ,      * * @param {object} ctx * @returns {string} */</span></span> visitPropertyExpressionAssignment(ctx) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> key = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.visit(ctx.propertyName()); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> value = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.visit(ctx.singleExpression()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">`'</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${key}</span></span></span><span class="hljs-string">': </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${value}</span></span></span><span class="hljs-string">`</span></span>; }</code> </pre><br>  The ` <code>visitPropertyExpressionAssignment</code> function visits the node responsible for assigning the value ` <code>visitPropertyExpressionAssignment</code> ` <code>visitPropertyExpressionAssignment</code> .  In Python, the string parameters of an object must be enclosed in quotes, as opposed to JavaScript, where they are optional.  In this case, this is the only modification that is required to transform a fragment of JavaScript code into Python code. <br><br><img src="https://habrastorage.org/webt/zp/0c/uq/zp0cuqgitso9ebb5gj2hij_6vlo.png" width="740"><br><br><br>  Add to index.js a call to our PythonGenerator. <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'JavaScript input:'</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(input); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Python output:'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> output = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PythonGenerator().start(tree); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(output);</code> </pre><br>  As a result of the program execution, we see that our compiler has successfully coped with its task and converted a JavaScript object into a Python object. <br><br><img src="https://habrastorage.org/webt/dc/ln/5y/dcln5y4kccccgaimr6gm-pwkdw0.png" width="422"><br><br><br>  We begin bypassing the tree from parent to child, gradually descending to its sheets.  And then we go in the reverse order and substitute the formatted values ‚Äã‚Äãfor a higher level, thus replacing the entire chain of tree nodes with their textual representation corresponding to the syntax of a new programming language. <br><br><img src="https://habrastorage.org/webt/yn/6p/t4/yn6pt4qtqbzy9bcmmw3jlwbshdc.png"><br><br><br>  Add some debugging to our ` <code>visitPropertyExpressionAssignment</code> function. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//    console.log(ctx.getText()); // -   console.log(ctx.getChildCount()); // console.log(ctx.propertyName().getText())  x console.log(ctx.getChild(0).getText()); // : console.log(ctx.getChild(1).getText()); // console.log(ctx.singleExpression().getText())  1 console.log(ctx.getChild(2).getText());</span></span></code> </pre><br>  The descendants can be accessed both by name and by sequence number.  The descendants are also nodes, so we used the ` <code>.getText()</code> ` method to get their text value, rather than the object representation. <br><br>  Let's add ECMAScript.g4 and teach our compiler to recognize the ` <code>Number</code> keyword. <br><br><img src="https://habrastorage.org/webt/qj/u6/sd/qju6sdfomdvi6ngzv83-f3c6nnw.png" width="740"><br><br><img src="https://habrastorage.org/webt/oj/dp/i4/ojdpi4iiaz8aws6yi6zpzwux6lq.png" width="570"><br><br><br>  Re-generate the visitor to tighten the changes made in the grammar. <br><br><pre> <code class="bash hljs">$ npm run compile</code> </pre> <br>  Now back to our PythonGenerator.js file and add a list of new methods to it. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** *    `new` * * @param {object} ctx * @returns {string} */</span></span> visitNewExpression(ctx) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.visit(ctx.singleExpression()); } <span class="hljs-comment"><span class="hljs-comment">/** *      `Number` * * @param {object} ctx * @returns {string} */</span></span> visitNumberExpression(ctx) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> argumentList = ctx.arguments().argumentList(); <span class="hljs-comment"><span class="hljs-comment">// JavaScript Number   , //         if (argumentList === null || argumentList.getChildCount() !== 1) { return 'Error: Number   '; } const arg = argumentList.singleExpression()[0]; const number = this.removeQuotes(this.visit(arg)); return `int(${number})`; } /** *          * * @param {String} str * @returns {String} */ removeQuotes(str) { let newStr = str; if ( (str.charAt(0) === '"' &amp;&amp; str.charAt(str.length - 1) === '"') || (str.charAt(0) === '\'' &amp;&amp; str.charAt(str.length - 1) === '\'') ) { newStr = str.substr(1, str.length - 2); } return newStr; }</span></span></code> </pre><br>  Python does not use the keyword ` <code>visitNewExpression</code> when invoking the constructor, so we remove it, or rather, in the ` <code>visitNewExpression</code> node, <code>visitNewExpression</code> continue to traverse the tree by excluding the first descendant.  Then we replace the `Number` keyword with ` <code>int</code> , which is its equivalent in Python.  Since ` <code>Number</code> is an Expression, we have access to its arguments through the ` <code>.arguments()</code> ` method. <br><br><img src="https://habrastorage.org/webt/id/a0/q_/ida0q_bjpjz-0wgmzmur2-ze-fq.png" width="417"><br><br><br>  Similarly, we can go through all the methods listed in ECMAScriptVisitor.js and transform all the JavaScript literals, symbols, rules, etc. into their equivalents for Python (or any other programming language). <br><br><br><h2><a name="Errors"></a>  Error processing </h2><br>  ANTLR by default validates the input to match the syntax specified in the grammar.  In the event of a discrepancy, the console will display information about the problem that has occurred, and ANTLR will also return the string as it was able to recognize it.  If you remove the `{x: 2}` colon from the source line, ANTLR will replace the unrecognized nodes with `undefined`. <br><br><img src="https://habrastorage.org/webt/bw/st/pj/bwstpjor3cjlqxshx9umd8gakjo.png" width="480"><br><br><br>  We can influence this behavior and output detailed error information instead of a broken line.  To begin with, we will create a new module in the root of our application, which is responsible for generating custom error types. <br><br><pre> <code class="bash hljs">$ mkdir error $ <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> error $ touch helper.js $ touch config.json</code> </pre><br>  I will not dwell on the specifics of the implementation of this module, since this is beyond the scope of the topic about compilers.  You can copy the finished version below, or write your own version, more suitable for the infrastructure of your application. <br><br>  All types of errors that you want to use in your application are listed in config.json. <br><br><pre> <code class="hljs json">{ <span class="hljs-attr"><span class="hljs-attr">"syntax"</span></span>: {<span class="hljs-attr"><span class="hljs-attr">"generic"</span></span>: {<span class="hljs-attr"><span class="hljs-attr">"message"</span></span>: <span class="hljs-string"><span class="hljs-string">"Something went wrong"</span></span>}}, <span class="hljs-attr"><span class="hljs-attr">"semantic"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"argumentCountMismatch"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"message"</span></span>: <span class="hljs-string"><span class="hljs-string">"Argument count mismatch"</span></span> } } }</code> </pre><br>  Then error.js cycles through the list from the config and for each entry in it creates a separate class inherited from Error. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> config = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'./config.json'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> errors = {}; <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.keys(config).forEach(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">group</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.keys(config[group]).forEach(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">definition</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">//        const name = [ group[0].toUpperCase(), group.slice(1), definition[0].toUpperCase(), definition.slice(1), 'Error' ].join(''); const code = `E_${group.toUpperCase()}_${definition.toUpperCase()}`; const message = config[group][definition].message; errors[name] = class extends Error { constructor(payload) { super(payload); this.code = code; this.message = message; if (typeof payload !== 'undefined') { this.message = payload.message || message; this.payload = payload; } Error.captureStackTrace(this, errors[name]); } }; }); }); module.exports = errors;</span></span></code> </pre><br>  Update the ` <code>visitNumberExpression</code> method and now instead of a text message marked <code>visitNumberExpression</code> we will throw out the error ` <code>SemanticArgumentCountMismatchError</code> , which is easier to catch and thus begin to distinguish between successful and problematic results of our application. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> path = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'path'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { SemanticArgumentCountMismatchError } = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(path.resolve(<span class="hljs-string"><span class="hljs-string">'error'</span></span>, <span class="hljs-string"><span class="hljs-string">'helper'</span></span>)); <span class="hljs-comment"><span class="hljs-comment">/** *      `Number` * * @param {object} ctx * @returns {string} */</span></span> visitNumberExpression(ctx) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> argumentList = ctx.arguments().argumentList(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (argumentList === <span class="hljs-literal"><span class="hljs-literal">null</span></span> || argumentList.getChildCount() !== <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SemanticArgumentCountMismatchError(); } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> arg = argumentList.singleExpression()[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> number = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.removeQuotes(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.visit(arg)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">`int(</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${number}</span></span></span><span class="hljs-string">)`</span></span>; }</code> </pre><br>  Now we will deal with errors directly related to the work of ANTLR, namely those that occur during the parsing of the code.  In the codegeneration directory we will create a new ErrorListener.js file and in it a class inherited from `antlr4.error.ErrorListener`. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> antlr4 = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'antlr4'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> path = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'path'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> {SyntaxGenericError} = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(path.resolve(<span class="hljs-string"><span class="hljs-string">'error'</span></span>, <span class="hljs-string"><span class="hljs-string">'helper'</span></span>)); <span class="hljs-comment"><span class="hljs-comment">/** *        * * @returns {object} */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ErrorListener</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">antlr4</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">error</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ErrorListener</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/** *     * * @param {object} recognizer ,     * @param {object} symbol ,   * @param {int} line    * @param {int} column    * @param {string} message   * @param {string} payload   */</span></span> syntaxError(recognizer, symbol, line, column, message, payload) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SyntaxGenericError({line, column, message}); } } <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = ErrorListener;</code> </pre><br>  To override the standard error output method, we use two methods available to the ANTLR parser: <br><br><ul><li>  <b>parser.removeErrorListeners ()</b> removes the standard ConsoleErrorListener. </li><li>  <b>parser.addErrorListener ()</b> adds a custom ErrorListener. </li></ul><br>  This should be done after creating the parser, but before calling it.  The full code of the updated index.js will look like this: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> antlr4 = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'antlr4'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ECMAScriptLexer = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'./lib/ECMAScriptLexer.js'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ECMAScriptParser = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'./lib/ECMAScriptParser.js'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> PythonGenerator = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'./codegeneration/PythonGenerator.js'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ErrorListener = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'./codegeneration/ErrorListener.js'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> input = <span class="hljs-string"><span class="hljs-string">'{x 2}'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> chars = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> antlr4.InputStream(input); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> lexer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ECMAScriptLexer.ECMAScriptLexer(chars); lexer.strictMode = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   JavaScript strictMode const tokens = new antlr4.CommonTokenStream(lexer); const parser = new ECMAScriptParser.ECMAScriptParser(tokens); const listener = new ErrorListener(); parser.removeErrorListeners(); parser.addErrorListener(listener); console.log('JavaScript input:'); console.log(input); console.log('Python output:'); try { const tree = parser.expressionSequence(); const output = new PythonGenerator().start(tree); console.log(output); // console.log(tree.toStringTree(parser.ruleNames)); } catch (error) { console.log(error); }</span></span></code> </pre><br>  Thanks to the information that is now contained in the error object, we can decide how to correctly handle the exception, interrupt or continue program execution, create an informative log or, last but not least, write tests that support correct and incorrect source data for the compiler. <br><br><img src="https://habrastorage.org/webt/r5/pz/_r/r5pz_rrkvjcau1t7xe4xdxorv2k.png" width="740"><br><br><br><h2><a name="Conclusion"></a>  Conclusion </h2><br>  If someone offers you to write a compiler, immediately agree!  This is very interesting and most likely significantly different from your usual programming tasks.  We have considered only the simplest nodes in order to form an overview of the process of writing a JavaScript compiler using ANTLR.  You can extend the functionality by validating the types of arguments passed, add Extended JSON or BSON support to the grammar, apply an identifier table to recognize such methods as toJSON (), toString (), getTimestamp () and so on.  In fact, the possibilities are endless. <br><br>  At the time of this writing, work on the MongoDB compiler is in its initial stages.  It is likely that this code transformation approach will change over time, or more optimal solutions will appear, and then I may write a new article with more relevant information. <br><br>  Today I am very passionate about writing a compiler and I want to preserve the knowledge gained in the process, which may be useful to someone else. <br><br>  If you want to go deeper into the topic, I can recommend the following resources for reading: <br><br><ul><li>  <a href="http://matt.might.net/articles/grammars-bnf-ebnf/">The language of languages</a> by Matt Might </li><li>  <a href="http://www.ethoberon.ethz.ch/WirthPubl/CBEAll.pdf">Compiler Construction</a> by Niklaus Wirth </li><li>  <a href="http://linux-doc.ru/programming/assembler/book/compilers.pdf">Compilers</a>  <a href="http://linux-doc.ru/programming/assembler/book/compilers.pdf">Principles, technologies and tools of</a> authors Alfred V. Aho, Monica S. Lam, Ravi Seti, Jeffrey D. Ulman </li><li>  <a href="http://blog.ptsecurity.com/2016/07/tree-structures-processing-and-unified.html">Tree structures processing and unified AST</a> by Ivan Kochurkin, Positive Technologies </li><li>  <a href="http://ict.edu.ru/ft/005128//ch3.pdf">Lecture "Fundamentals of Compilers"</a> by A. Aho, R. Seti, J. Ullman </li></ul><br>  And links to resources used in the article: <br><br><ul><li>  <a href="https://github.com/jamiebuilds/the-super-tiny-compiler">Super Tiny Compiler</a> by James Kyle </li><li>  <a href="http://blog.mgechev.com/2017/09/16/developing-simple-interpreter-transpiler-compiler-tutorial/">Implementing a Simple Compiler on 25 Lines of JavaScript</a> by Minko Gechev </li><li>  <a href="https://www.codeproject.com/Articles/345888/How-to-write-a-simple-interpreter-in-JavaScript">How to write a simple interpreter in JavaScript</a> by Peter Olson </li><li>  <a href="https://tomassetti.me/parsing-in-javascript/">Parsing in JavaScript: Tools and Libraries</a> by Gabriele Tomassetti </li><li>  <a href="https://tomassetti.me/antlr-mega-tutorial/">The ANTLR Mega Tutorial</a> by Gabriele Tomassetti </li><li>  <a href="https://habrahabr.ru/company/pt/blog/339336/">MySQL grammar on ANTLR 4</a> by Ivan Khudyashov </li><li>  <a href="https://habrahabr.ru/company/pt/blog/210060/">Treating tree structures and unified AST</a> by Ivan Kochurkin </li><li>  <a href="https://habrahabr.ru/company/pt/blog/210772/">Theory and practice of source code parsing using ANTLR and Roslyn</a> by Ivan Kochurkin </li><li>  <a href="http://saumitra.me/blog/antlr4-visitor-vs-listener-pattern/">Antlr4 - Visitor vs Listener Pattern</a> by Saumitra Srivastav </li></ul><br>  Thanks to my Compass team and, in particular, <a href="https://github.com/aherlihy">Anna Herlihy</a> for mentoring and contributing to compiler writing, to reviewers <a href="https://github.com/adkomyagin">Alex Komigin</a> , <a href="https://github.com/mikety">Misha Tyulenev</a> for recommendations on the structure of the article, and for lettering to the title illustration of <a href="https://www.instagram.com/nalivaiko_calligraphy">Oksana Nalyvaiko</a> . <br><br>  The English version of the article on Medium: <a href="https://medium.com/dailyjs/compiler-in-javascript-using-antlr-9ec53fd2780f">Compiler in JavaScript using ANTLR</a> </div><p>Source: <a href="https://habr.com/ru/post/351906/">https://habr.com/ru/post/351906/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../351894/index.html">Spread S3 Buckets across different pools in Ceph Luminous</a></li>
<li><a href="../351896/index.html">Issue # 15: IT training - current issues and challenges from leading companies</a></li>
<li><a href="../351898/index.html">Hackathon and game jam in Yekaterinburg</a></li>
<li><a href="../351900/index.html">Flask Mega-Tutorial, Part XVI: Full-Text Search</a></li>
<li><a href="../351904/index.html">Simple authentication on NGINX using LUA</a></li>
<li><a href="../351908/index.html">Cisco ASA: Patched Firewall Critical Vulnerability</a></li>
<li><a href="../351910/index.html">Monster of advanced threats and targeted attacks.</a></li>
<li><a href="../351912/index.html">Gartner Data & Analytics Summit 2018</a></li>
<li><a href="../351914/index.html">Marvin Minsky "The Emotion Machine": Chapter 2 "Impressors"</a></li>
<li><a href="../351916/index.html">Application architecture on the Akili framework</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>