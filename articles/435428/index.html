<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Remote control of Fceux emulator using Python</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the article I will describe how to make the NES emulator managed remotely, and the server for remote sending commands to it. 



 Why do you need i...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Remote control of Fceux emulator using Python</h1><div class="post__text post__text-html js-mediator-article">  In the article I will describe how to make the NES emulator managed remotely, and the server for remote sending commands to it. <br><br><img src="https://habrastorage.org/webt/fb/4n/te/fb4ntevb-6j5knunjyr3jq0wec0.png"><br><br><h2>  Why do you need it? </h2><br>  Some emulators of various gaming consoles, including <a href="http://www.fceux.com/web/home.html">Fceux</a> , allow you to write and run custom scripts on Lua.  But Lua is a bad language for writing serious programs.  It is rather a language for calling functions written in C.  Emulator authors use it only because of the lightness and ease of embedding.  Accurate emulation requires a lot of processor resources, and previously the emulation speed was one of the main goals of the authors, and the possibility of scripting actions, if remembered, is far from being the first. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Now the average processor power is enough to emulate NES, why not use powerful scripting languages ‚Äã‚Äãlike emulator or javascript in emulators? <br><br>  Unfortunately, none of the popular NES emulators have the ability to use these or other languages.  I found only a little-known <a href="https://nintaco.com/api.html">Nintaco</a> project, which is also based on the Fceux core, which is for some reason rewritten in Java.  Then I decided to add the ability to write scripts in Python to control the emulator myself. <br><br>  My result is Proof-of-Concept emulator control capabilities, it does not pretend to speed or reliability, but it works.  I did it for myself, but since the question of how to manage the emulator using scripts <a href="https://github.com/TASVideos/fceux/issues/22">is</a> <a href="https://forums.nesdev.com/viewtopic.php%3Ff%3D3%26t%3D14109">quite</a> <a href="https://www.reddit.com/r/Python/comments/6n1j94/nes_emulator_with_python_scripting_support/">common</a> , I put the source code on the <a href="https://github.com/spiiin/fceux_luaserver">github</a> . <br><a name="habracut"></a><br><h2>  How does it work </h2><br><h3>  On the emulator side </h3><br>  The Fceux emulator <a href="http://www.fceux.com/web/help/fceux.html%3FLuaPerks.html">already includes</a> several Lua libraries included in it <a href="">as compiled code</a> .  One of them is <a href="http://w3.impa.br/~diego/software/luasocket/">LuaSocket</a> .  It is poorly documented, but I managed to find an example of working code among the <a href="https://github.com/Xkeeper0/emu-lua/tree/master/nes-fceux/irc%2520game%2520genie%2520engine">collection of</a> <i><b>Xkeeper0</b></i> <a href="https://github.com/Xkeeper0/emu-lua/tree/master/nes-fceux/irc%2520game%2520genie%2520engine">scripts</a> .  He used sockets to control the emulator via Mirc.  Actually, the code that opens the tcp-socket: <br><br><pre><code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">connect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(address, port, laddress, lport)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> sock, err = socket.tcp() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> sock <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, err <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> laddress <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> res, err = sock:bind(laddress, lport, <span class="hljs-number"><span class="hljs-number">-1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> res <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, err <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> res, err = sock:connect(address, port) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> res <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, err <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sock <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> sock2, err2 = connect(<span class="hljs-string"><span class="hljs-string">"127.0.0.1"</span></span>, <span class="hljs-number"><span class="hljs-number">81</span></span>) sock2:settimeout(<span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-comment"><span class="hljs-comment">--it's our socket object print("Connected", sock2, err2)</span></span></code> </pre> <br>  This is a low-level socket that receives and sends data by 1 byte. <br><br>  In the Fceux emulator, the main loop of the Lua script looks like this: <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-comment"><span class="hljs-comment">--  passiveUpdate() --,        emu.frameadvance() --       end end</span></span></code> </pre><br>  And check data from the socket: <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">passiveUpdate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> message, err, part = sock2:receive(<span class="hljs-string"><span class="hljs-string">"*all"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> message <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> message = part <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> message <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(message)&gt;<span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-comment"><span class="hljs-comment">--print(message) local recCommand = json.decode(message) table.insert(commandsQueue, recCommand) coroutine.resume(parseCommandCoroutine) end end</span></span></code> </pre><br>  The code is quite simple - reading data from the socket is done, and if the next command was found, then it is parsed and executed.  Parsing and execution are organized using <a href="https://www.lua.org/pil/contents.html">Coroutine</a> (coroutines) - this is a powerful concept of the Lua language for suspending and continuing code execution. <br><br>  And one more important thing about Lua-scripting in Fceux - emulation can be temporarily stopped from the script.  How to organize the continuation of the execution of Lua-code and re-launch it with a command obtained from the socket?  That would be impossible, but there is a poorly documented opportunity to call the Lua code even when emulation is stopped (thanks to <b><i>feos</i></b> for bringing it): <br><br><pre> <code class="lua hljs">gui.register(passiveUpdate) <span class="hljs-comment"><span class="hljs-comment">--undocumented. this function will call even if emulator paused</span></span></code> </pre><br>  Using it, you can stop and continue emulation inside <b>passiveUpdate</b> - this is how you can organize installation of the emulator breakpoint via a socket. <br><br><h3>  Server side commands </h3><br>  I use a very simple text based RPC protocol based on JSON.  The server serializes the function name and arguments into a JSON string and sends it via a socket.  Further, the code execution stops until the emulator responds with the command completion line.  The response will contain the fields " <b>FUNCTIONNAME_finished</b> " and the result of the function. <br><br>  The idea is implemented in the <b>syncCall</b> class: <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">syncCall</span></span></span><span class="hljs-class">:</span></span> @classmethod <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">waitUntil</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(cls, messageName)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""cycle for reading data from socket until needed message was read from it. All other messages will added in message queue"""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: cmd = messages.parseMessages(asyncCall.waitAnswer(), [messageName]) <span class="hljs-comment"><span class="hljs-comment">#print(cmd) if cmd != None: if len(cmd)&gt;1: return cmd[1] return @classmethod def call(cls, *params): """wrapper for sending [functionName, [param1, param2, ...]] to socket and wait until client return [functionName_finished, [result1,...]] answer""" sender.send(*params) funcName = params[0] return syncCall.waitUntil(funcName + "_finished")</span></span></code> </pre><br>  Using this class, the Fceux emulator Lua methods can be wrapped in Python classes: <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">emu</span></span></span><span class="hljs-class">:</span></span> @classmethod <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">poweron</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(cls)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> syncCall.call(<span class="hljs-string"><span class="hljs-string">"emu.poweron"</span></span>) @classmethod <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pause</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(cls)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> syncCall.call(<span class="hljs-string"><span class="hljs-string">"emu.pause"</span></span>) @classmethod <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unpause</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(cls)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> syncCall.call(<span class="hljs-string"><span class="hljs-string">"emu.unpause"</span></span>) @classmethod <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">message</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(cls, str)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> syncCall.call(<span class="hljs-string"><span class="hljs-string">"emu.message"</span></span>, str) @classmethod <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">softreset</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(cls)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> syncCall.call(<span class="hljs-string"><span class="hljs-string">"emu.softreset"</span></span>) @classmethod <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">speedmode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(cls, str)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> syncCall.call(<span class="hljs-string"><span class="hljs-string">"emu.speedmode"</span></span>, str)</code> </pre><br>  And then called verbatim the same way as from Lua: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># : emu.poweron()</span></span></code> </pre><br><h3>  Callback methods </h3><br>  You can register callbacks in Lua - functions that will be called when a certain condition is met.  We can transfer this behavior to the server in Python using the following trick.  First, we save the identifier of a function callback written in Python, and pass it to the Lua code: <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">callbacks</span></span></span><span class="hljs-class">:</span></span> functions = {} callbackList = [ <span class="hljs-string"><span class="hljs-string">"emu.registerbefore_callback"</span></span>, <span class="hljs-string"><span class="hljs-string">"emu.registerafter_callback"</span></span>, <span class="hljs-string"><span class="hljs-string">"memory.registerexecute_callback"</span></span>, <span class="hljs-string"><span class="hljs-string">"memory.registerwrite_callback"</span></span>, ] @classmethod <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">registerfunction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(cls, func)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> func == <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> hfunc = hash(func) callbacks.functions[hfunc] = func <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hfunc @classmethod <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(cls, e)</span></span></span><span class="hljs-function">:</span></span> emu.message(<span class="hljs-string"><span class="hljs-string">"Python error: "</span></span> + str(e)) @classmethod <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">checkAllCallbacks</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(cls, cmd)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment">#print("check:", cmd) for callbackName in callbacks.callbackList: if cmd[0] == callbackName: hfunc = cmd[1] #print("hfunc:", hfunc) func = callbacks.functions.get(hfunc) #print("func:", func) if func: try: func(*cmd[2:]) #skip function name and function hash and save others arguments except Exception as e: callbacks.error(e) pass #</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> thread locking sender.send(callbackName + "_finished")</span></span></code> </pre><br>  The Lua code also saves this identifier and registers the usual Lua-Kolbek, which will transfer control to the Python code.  Next, a separate thread is created in the Python code, which deals only with checking whether the call command from Lua was accepted: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">callbacksThread</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> cycle = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: cycle += <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: cmd = messages.parseMessages(asyncCall.waitAnswer(), callbacks.callbackList) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> cmd: <span class="hljs-comment"><span class="hljs-comment">#print("Callback received:", cmd) callbacks.checkAllCallbacks(cmd) pass except socket.timeout: pass time.sleep(0.001)</span></span></code> </pre><br>  The last step is that after the Python-kabek is executed, control returns to Lua using the " <b>CALLBACKNAME_finished</b> " <b>command</b> to inform the emulator that the callback is complete. <br><br><h2>  How to run an example </h2><br><ul><li>  You must have working <b>Python 3</b> and <b>Jupyter Notebook</b> in the system.  You need to run jupyter with the command <br><br><pre> <code class="plaintext hljs">jupyter notebook</code> </pre><br></li><li>  Open the <b>FceuxPythonServer.py.ipynb</b> laptop and run the first line <br><img src="https://habrastorage.org/webt/ns/7k/_i/ns7k_i60y_7kscct2pmyqz1_fi8.png"><br></li><li>  Now you have to run the Fceux emulator, open the ROM file in it (I use the game <b>Castlevania (U) (PRG0) [!]. Nes</b> in my example) and run a Lua script called <i>fceux_listener.lua</i> .  It should connect to the server running on the Jupyter laptop. <br><br>  These actions can be performed using the command line: <br><br><pre> <code class="plaintext hljs">fceux.exe -lua fceux_listener.lua "Castlevania (U) (PRG0) [!].nes"</code> </pre><br></li><li>  Now switch back to Jupyter Notebook.  You should see a message about successful connection with the emulator: <br><br><img src="https://habrastorage.org/webt/41/on/es/41onesw9o66jmtyfexid7wpipbq.png"><br></li></ul><br>  Everything, you can send commands from the Jupyter laptop in the browser directly to the Fceux emulator. <br><br>  You can execute all the lines of the example notebook in sequence and observe the result of execution in the emulator. <br><br>  Full example: <br>  <a href="https://github.com/spiiin/fceux_luaserver/blob/master/FceuxPythonServer.py.ipynb">https://github.com/spiiin/fceux_luaserver/blob/master/FceuxPythonServer.py.ipynb</a> <br><br>  It contains simple functions like reading memory: <br><br><img src="https://habrastorage.org/webt/sg/ut/du/sgutduhqvx6wqzgczn9seozyl08.png"><br><br>  More complex examples with creating callbacks: <br><br><img src="https://habrastorage.org/webt/ul/qq/1q/ulqq1qufdcbol1zbw_6za2mtfdi.png"><br><br>  And a script for a particular game that allows you to move enemies from <b>Super Mario Bros.</b>  using the mouse: <br><br><img src="https://habrastorage.org/webt/ie/iw/fa/ieiwfa__-dg4sck64cmekmbcy7y.png"><br><br>  Laptop runtime video: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/c3D5gljbkO0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h3>  Limitations and Applications </h3><br>  The script is not foolproof and is not optimized for execution speed - it would be better to use the binary RPC protocol instead of the text one and group the messages together, but my implementation does not need to be compiled.  The script can switch execution contexts from Lua to Python and back 500-1000 times per second on my laptop.  This is enough for almost any application, except for specific cases of pixel-by-pixel or line-by-line debugging of a video processor, but Fceux still does not allow performing such operations from Lua, so it does not matter. <br><br>  Possible application ideas: <br><br><ul><li>  As an example of the implementation of similar control for other emulators and languages </li><li>  Study games </li><li>  Adding cheats or features to organize TAS passages </li><li>  Insert or retrieve data and code into games </li><li>  Empowering emulators - writing debuggers, writing scripts and viewing passages, script libraries, game editors </li><li>  Network game, game control using mobile devices, remote services, joypad or other control devices, saving and patches in cloud services </li><li>  Cross emulation features </li><li>  Using libraries of Python or other languages ‚Äã‚Äãfor data analysis and game management (creating bots) </li></ul><br><h3>  Technology stack </h3><br>  I used: <br><br>  <b>Fceux</b> - <a href="http://www.fceux.com/web/home.html">www.fceux.com/web/home.html</a> <br>  This is a classic NES emulator, and most people use it.  It has not been updated for a long time, and is not the best in features, but it remains the default emulator for many romhackers.  Also, I chose it because the support for Lua sockets is integrated into it, and there is no need to connect it myself. <br><br>  <b>Json.lua</b> - <a href="">github.com/spiiin/json.lua</a> <br>  This is JSON implementation on pure Lua.  I chose it because I wanted to make an example that does not require compiling code.  But I still had to fork the library, because some of the libraries built into Fceux overloaded the library function <i><b>tostring</b></i> and broke serialization (my rejected <a href="https://github.com/rxi/json.lua/pull/10">pull request</a> to the author of the original library). <br><br>  <b>Python 3</b> - <a href="https://www.python.org/">www.python.org</a> <br>  Fceux Lua server opens a tcp socket and listens to commands received from it.  The server that sends commands to the emulator can be implemented in any language.  I chose Python for its ‚ÄúBattery included‚Äù philosophy - most modules are included in the standard library (work with sockets and JSON as well).  Python also has a library of working with neural networks, and I want to try using them to create bots in NES games. <br><br>  <b>Jupyter Notebook</b> - <a href="https://jupyter.org/">jupyter.org</a> <br>  Jupyter Notebook is a very cool environment for interactively executing Python code.  With it, you can write and execute commands in a table editor inside the browser.  It is also good for creating presentable examples. <br><br>  <b>Dexpot</b> - <a href="https://www.dexpot.de/">www.dexpot.de</a> <br>  I used this virtual desktop manager to pin the emulator window on top of others.  This is very useful when deploying a server in full screen for instantly tracking changes in the emulator window.  Regular Windows tools do not allow to organize the fastening of the window on top of others. <br><br><h2>  Links </h2><br>  Actually, <a href="https://github.com/spiiin/fceux_luaserver">the project repository</a> . <br><br>  <a href="https://nintaco.com/api.html">Nintaco</a> - NES emulator in Java with remote control <br>  <a href="https://github.com/Xkeeper0/emu-lua">Xkeeper0 emu-lua collection</a> - a collection of various Lua scripts <br>  <a href="https://www.mesen.ca/docs/apireference.html">Mesen</a> is a modern C # NES emulator with powerful scripting capabilities for Lua.  So far, without the support of sockets and remote control. <br>  <a href="https://github.com/spiiin/cadeditor">CadEditor</a> is my universal level editor project for NES and other platforms, as well as powerful tools for researching games.  I use the script and server described in the post in order to explore the games and add them to the editor. <br><br>  I would appreciate feedback, testing and attempts to use the script. </div><p>Source: <a href="https://habr.com/ru/post/435428/">https://habr.com/ru/post/435428/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../435418/index.html">Using SQLite in Flutter</a></li>
<li><a href="../435420/index.html">The future of the fight against crime is the study of tree genealogies</a></li>
<li><a href="../435422/index.html">How in Silicon Valley relate to experienced people</a></li>
<li><a href="../435424/index.html">Parse & Android: recommendations for novice developers</a></li>
<li><a href="../435426/index.html">How Microsoft Excel works with row heights</a></li>
<li><a href="../435430/index.html">The coolest new CES 2019</a></li>
<li><a href="../435432/index.html">New Year, New GitHub: Unlimited Free Private Repositories</a></li>
<li><a href="../435434/index.html">We use annotations in PHP to the maximum</a></li>
<li><a href="../435436/index.html">5 IT infrastructure trends: forecast for 2019</a></li>
<li><a href="../435442/index.html">Funnel change</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>