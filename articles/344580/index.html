<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Mailboxes that are not mailboxes at all ...</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="When in the summer of 2016, the first article about the SObjectizer was created, we said that over time we would talk about the details of its impleme...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Mailboxes that are not mailboxes at all ...</h1><div class="post__text post__text-html js-mediator-article">  When in the summer of 2016, the <a href="https://habrahabr.ru/post/304386/">first article about the SObjectizer was created,</a> we said that over time we would talk about the details of its implementation, so that interested readers could look under the hood.  Today's article will be about the SObjectizer giblets.  About the mechanism of mboxes ("mailboxes"), which is used to organize the interaction of actors (agents in our terminology). <br><br><h1>  Why are we talking about mboxes? </h1><br>  Because we ourselves are surprised at how many very similar questions this mechanism causes to those who undertake to study SObjectizer.  It turned out that the thing that is well known, understandable and familiar to us, the developers of SObjectizer, is by no means the same for beginners.  Well, if so, then let's try to figure out what mboxes are and how they work.  And at the same time and try to make your own mbox. <br><br><h1>  Why do we need mboxes? </h1><br>  SObjectizer mailboxes are needed in order to organize interaction between agents.  Communication between agents is built through asynchronous messages and these same messages need to be sent somewhere.  The question arises: "Where exactly?" <br><a name="habracut"></a><br>  In the classical Model of Actors, the recipient of the message is the recipient actor itself.  Those.  in order for actor A to send a message to actor B, actor A should have a link to actor B. There is no reference to the recipient actor - there is no way to send him a message.  If you want to perform a 1: N distribution, then the sender must have links to all recipients.  This is if we talk about the classic Model Actors. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      However, we had another specificity (as usual, the bitie determines consciousness and we were repelled by the needs of the tasks that we had to solve and the tools that we had at our disposal). <br><br>  First, we have C ++.  Just because the link to Agent B is not transmitted to Agent A.  If this is a normal link (or a regular bare pointer), then when Agent B is destroyed, Agent A will have a ‚Äúdangling‚Äù link to B. Accordingly, instead of the usual links / pointers, you should use smart links / pointers.  But a simple smart pointer is not good, because  Agent B will not be deleted (and therefore the resources it owns will not be released) as long as Agent A has a smart pointer to Agent B. <br><br>  Therefore, in C ++ we would have to use not just smart pointers, but some special smart proxy links.  Agent A may have a proxy link to B, but at the same time B can be safely removed even though the proxy link for A continues.  Moreover, A may try to send a message to an already non-existent agent B and this attempt should not lead to catastrophic consequences (such as damage to the ‚Äúalien‚Äù memory or the collapse of the entire application, as is the case when accessing ‚Äúdangling‚Äù links in C ++). <br><br>  Secondly, our 1: N interaction was very common.  Moreover, at the beginning it was generally the only way agents could interact.  Therefore, we really didn‚Äôt want agents B and C, who needed to receive information from agent A, to be forced to first send links to themselves to agent A. And so that agent A had to maintain lists of agents who want to receive messages from A in 1: n. <br><br>  As a result, we had the concept of a ‚Äúmailbox‚Äù, which was created just to (a) be the cleverest proxy link that agents can use to communicate with each other, and (b) be a mechanism that simplifies the interaction in mode 1 : N. <br><br>  In the presence of mboxes, agents send messages not directly to each other, but to mailboxes (mboxes).  A message sent to mbox is delivered to those agents who have subscribed to messages from this mbox. <br><br>  Thus, in order for Agent A to send a message to Agent B, you need to have an mbox that both agents know about.  Agent A sends a message to this mbox, and Agent B subscribes to messages from this mbox.  As can be seen in this small example: <br><br><pre><code class="hljs rust">#include &lt;so_5/all.hpp&gt; class A final : public so_5::agent_t { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> so_5::mbox_t to_; public: A(context_t ctx, so_5::mbox_t to) : so_5::agent_t{std::<span class="hljs-keyword"><span class="hljs-keyword">move</span></span>(ctx)}, to_{std::<span class="hljs-keyword"><span class="hljs-keyword">move</span></span>(to)} {} <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> void so_evt_start() override { <span class="hljs-comment"><span class="hljs-comment">//    B. so_5::send&lt;std::string&gt;(to_, "Hello!"); } }; class B final : public so_5::agent_t { public: B(context_t ctx, const so_5::mbox_t &amp; from) : so_5::agent_t{std::move(ctx)} { //       from. so_subscribe(from).event(&amp;B::on_string); } private: void on_string(mhood_t&lt;std::string&gt; cmd) { std::cout &lt;&lt; "Message: " &lt;&lt; *cmd &lt;&lt; std::endl; //   . so_deregister_agent_coop_normally(); } }; int main() { so_5::launch([](so_5::environment_t &amp; env) { //      ,   //  mbox  . env.introduce_coop([&amp;](so_5::coop_t &amp; coop) { //  mbox,     //  A  B. const auto mbox = env.create_mbox(); //    ,    //  mbox  . coop.make_agent&lt;A&gt;(mbox); coop.make_agent&lt;B&gt;(mbox); }); }); return 0; }</span></span></code> </pre> <br>  At the same time, that sending, that receiving messages in 1: N mode is no different from sending / receiving messages in 1: 1 mode.  Here's how the example above will look like when agent A sends a message to agents B and C simultaneously: <br><br><pre> <code class="hljs rust">#include &lt;so_5/all.hpp&gt; class A final : public so_5::agent_t { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> so_5::mbox_t to_; public: A(context_t ctx, so_5::mbox_t to) : so_5::agent_t{std::<span class="hljs-keyword"><span class="hljs-keyword">move</span></span>(ctx)}, to_{std::<span class="hljs-keyword"><span class="hljs-keyword">move</span></span>(to)} {} <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> void so_evt_start() override { <span class="hljs-comment"><span class="hljs-comment">//    B. so_5::send&lt;std::string&gt;(to_, "Hello!"); } }; class B final : public so_5::agent_t { public: B(context_t ctx, const so_5::mbox_t &amp; from) : so_5::agent_t{std::move(ctx)} { //       from. so_subscribe(from).event(&amp;B::on_string); } private: void on_string(mhood_t&lt;std::string&gt; cmd) { std::cout &lt;&lt; "(B) Message: " &lt;&lt; *cmd &lt;&lt; std::endl; //   . so_deregister_agent_coop_normally(); } }; class C final : public so_5::agent_t { public: C(context_t ctx, const so_5::mbox_t &amp; from) : so_5::agent_t{std::move(ctx)} { //       from. so_subscribe(from).event([](mhood_t&lt;std::string&gt; cmd) { //   ,    , //      B. std::cout &lt;&lt; "(C) Message: " &lt;&lt; *cmd &lt;&lt; std::endl; }); } }; int main() { so_5::launch([](so_5::environment_t &amp; env) { //      ,   //  mbox  . env.introduce_coop([&amp;](so_5::coop_t &amp; coop) { //  mbox,     //  A, B, C. const auto mbox = env.create_mbox(); //   ,    //  mbox  . coop.make_agent&lt;A&gt;(mbox); coop.make_agent&lt;B&gt;(mbox); coop.make_agent&lt;C&gt;(mbox); }); }); return 0; }</span></span></code> </pre> <br><h1>  How do mboxes work? </h1><br>  Different mboxes work differently :) Therefore, in order to tell how the most widely used types of mboxes work, you first need to talk about what mboxes are in general. <br><br><h2>  What are mboxes? </h2><br><h3>  Multi-Producer / Multi-Consumer </h3><br>  Historically, this is the first type of mbox, which appeared in SObjectizer-5.  Anyone can send a message to this mbox.  Anyone can subscribe to messages from this mbox. <br><br><h3>  Multi-Producer / Single-Consumer </h3><br>  For a 1: 1 interaction case, MPSC-mbox can be used, to which anyone can send a message, but only one agent who owns an MPSC-mbox can subscribe to messages from an MPSC-mbox. <br><br>  MPSC mboxes appeared in SObjectizer-5 some time after the start of active use of SObjectizer-5.  When experience has shown that in cases where messages are addressed to one specific agent, using MPMC-mbox is ineffective.  So we can say that MPSC-mbox is more a way to optimize the code, rather than some fundamentally different approach to the organization of interaction.  In addition, the user cannot create MPSC-mboxes.  The MPSC-mbox for each agent is automatically created by the SObjectizer. <br><br><h3>  Additional mboxes from the so_5_extra library </h3><br>  Over SObjectizer, an additional <a href="https://sourceforge.net/p/sobjectizer/wiki/so5extra%2520Documentation/">library so_5_extra was built</a> containing components that we thought it would be unwise to add to the SObjectizer core.  It includes several additional types of mboxes.  For example: <br><br><ul><li>  <a href="https://sourceforge.net/p/sobjectizer/wiki/so5extra%25201.0%2520Round-Robin%2520Mbox/">round_robin mbox</a> , whose task is to send messages to recipients in turn; </li><li>  <a href="https://sourceforge.net/p/sobjectizer/wiki/so5extra%25201.0%2520Retained%2520Message%2520Mbox">retained_msg mbox</a> , which stores a copy of the last message sent and immediately sends this copy to each new subscriber (thereby the subscriber automatically receives the last value sent to mbox). </li></ul><br>  Another interesting example of using mboxes is <a href="https://sourceforge.net/p/sobjectizer/wiki/so5extra%25201.0%2520Shutdowner/">the shutdowner component</a> from so_5_extra, in which mbox is used to determine when it is possible to shut down a large SObjectizer application correctly. <br><br>  However, we will not consider in detail the mboxes from so_5_extra in this article. <br><br><h2>  How does the Multi-Producer / Single-Consumer mbox work? </h2><br>  So, mboxes are different, so they work in different ways.  And we will begin to consider the details of the work with the simplest of them - MPSC-mbox. <br><br>  If you do not take into account such specific things as <a href="https://sourceforge.net/p/sobjectizer/wiki/so-5.5%2520In-depth%2520-%2520Message%2520Limits/">message_limits</a> (this is the mechanism for protecting agents from overloading) and <a href="https://sourceforge.net/p/sobjectizer/wiki/so-5.5%2520In-depth%2520-%2520Message%2520Delivery%2520Tracing/">msg_tracing</a> (this is a way to look at how the message is delivered to the recipient), then MPSC-mbox works as a simple ‚Äúsemiconductor‚Äù: the message is sent and gives it to the receiving agent so that the recipient places the message in his / her queue of messages waiting to be processed. <br><br>  Well, that is  everything is very stupid here: I took the message from the sender and gave it to the recipient.  Nothing more. <br><br><h2>  How does Multi-Producer / Multi-Consumer mbox work? </h2><br>  But with MPMC-mbox-ohm, the situation is somewhat more complicated (again, we do not take into account such things as message_limits and msg_tracing).  Since there can be multiple recipients of messages, MPMC-mbox stores an associative container with subscribers.  The key in this container is the message type identifier, and the element is the actual list of subscribers for messages of this type. <br><br>  When someone sends a message of type M, MPMC-mbox searches in its associative container for a list of subscribers for messages of type M. If there is such a list, then MPMC-mbox follows this list and tries to send a message to each of the subscribers. <br><br>  It was specifically said "trying to give", because  there is still such a thing as <a href="https://sourceforge.net/p/sobjectizer/wiki/so-5.5%2520In-depth%2520-%2520Message%2520Delivery%2520Filters/">delivery_filters</a> (i.e. filters that allow or prohibit the delivery of a message to a subscriber depending on the content of the message).  Before delivering a message to a subscriber agent, MPMC-mbox checks if the subscriber has delivery_filter.  If so, the message is first given to the filter.  And only if the filter allows delivery of the message to the agent, this message will be given to the agent. <br><br>  In general, MPMC-mbox follows the list of subscribers for a specific type of message and, if delivery of a specific instance of a message to a subscriber is allowed, the message is given to the subscriber agent in order for the subscriber to put his turn on messages waiting to be processed. <br><br><h2>  What is common between regular MPMC and MPSC mboxes? </h2><br>  The regular MPMC and MPSC mboxes have one important unifying feature: mboxes do not have their own repository of messages sent to mboxes.  Those.  mboxes, at least, regular ones do not store messages.  At all. <br><br>  Therefore, questions such as " <i>How many messages can the mbox store until it overflows and what will happen when it overflows?</i> " Or " <i>Will agent B receive message M if he subscribes to message M after message M has been sent?</i> " MPMC- and MPSC-mboxes do not make sense.  For these mboxes stupidly do not store messages inside themselves: messages are immediately transferred to those agents who are interested in messages.  Alternatively, messages are ignored if there are currently no recipients for this type of message. <br><br>  And for other types of mboxes, internal storage for sent messages is rather an exception to the rules than the norm.  The fact is that work with mboxes is based on the push-principle: the sent message is ‚Äúpushed‚Äù in mbox.  And this is probably the only way for mbox to deliver a message to someone.  Since no one jerks periodically mbox in order to check whether something new has appeared in the mbox.  Those.  no one, well, no one at all, does not work with the mbox in pull mode. <br><br>  So, the dry residue: in general, mboxes do not store messages within themselves. <br><br><h2>  Complicate the world: agents do not have their own message queues </h2><br>  Faced with SObjectizer, developers quickly begin to understand that mboxes do not store messages, so there is no point in asking questions about the capacity of mboxes.  But since the messages are not stored in mbox, but with agents, then questions about the capacity of the agent's message queue begin ... <br><br>  And then the newcomers will have another revelation and, possibly, disappointment: in SObjectizer, agents, in general, do not have their own message queues. <br><br>  Like this.  Just not all :) <br><br>  The fact is that <a href="https://sourceforge.net/p/sobjectizer/wiki/so-5.5%2520In-depth%2520-%2520Dispatchers/">dispatchers</a> manage message queues for agents in SObjectizer.  It is the dispatcher that provides the agent with a working context in which the agent will process its messages.  And, as a result, it is the dispatcher who organizes the storage of messages waiting to be processed. <br><br>  For example, there is a dispatcher of type one_thread (one of the most frequently used).  In it, all agents attached to this dispatcher work on one single common working thread.  And all messages for all agents are stored in one common message queue.  The working thread gets the following message from this queue, gives it to the receiving agent, then takes the following, and so on. <br><br>  Similarly, an active_group type dispatcher operates, in which a group of agents can be tied to one common working thread.  And all agents on this working thread will use a common message queue. <br><br>  The situation with thread_pool and adv_thread_pool dispatchers is more cunning.  There you can set parameters for FIFO queues for agents.  One of them is exactly which queue the agent will use.  You can make the agent have its own queue, in which there will only be messages that are addressed to this agent.  And it can be done in such a way that agents from one collaboration will share a common message queue. <br><br>  Even more fun with dispatchers who support agent priorities.  For example, the dispatcher prio_one_thread :: strictly_ordered.  There, all agents with the same priority will have one common message queue.  But for agents with different priorities, the message queues will be different. <br><br>  In short, in the dry balance: in general, mboxes send messages to agents, and agents send messages to dispatchers, who already save messages in the appropriate queues.  Therefore, again, in general, there are no repositories for messages for mboxes or agents. <br><br><h1>  And how difficult is it to make your own mbox? </h1><br>  If you do "according to all the rules", with the support of message_limits, delivery_filters, msg_tracing and other nuances, then it is quite difficult.  <a href="">Those</a> who are interested can look, for example, <a href="">in the implementation gals of the retained_msg mbox from so_5_extra</a> , in order to see how scary it all may look :) <br><br>  However, if your own mbox is done for a specific task, then everything may not be so scary.  Let's make MPSC-mbox as a small example, which will prevent the agent from receiving too many messages.  Well, let's say, if the message M2 arrives less than 250ms after the message M1, then it is thrown out.  If 250ms or more has passed after M1, then M2 is delivered to the recipient. <br><br><h2>  Necessary explanations </h2><br>  So, let's try to make your own mbox under the conditional name anti-jitter-mbox.  This will be an MPSC-mbox, which should be associated with some specific agent. <br><br>  In order to simplify our life, we will not create a full own implementation of the MPSC-mbox.  Instead, we will use a ready-made MPSC-mbox, which is already available for each agent.  We simply demand that the anti-jitter-mbox constructor of ours should send the MPSC-mbox of the agent to which the anti-jitter-mbox should belong. <br><br>  We need to define our own anti_jitter_mbox class, which should be the heir of the special class <a href="">so_5 :: absctract_message_mbox_t</a> .  In our class we will have to override the pure virtual methods present in absctract_message_mbox_t.  In SObjectizer versions 5.5. * These are the following methods: <br><br>  <i>id ()</i> .  It must return a unique mbox ID.  Since the delivery of the message will actually be performed by the MPSC-mbox agent, which will be passed to us in the constructor, we will return the ID of this particular MPSC-mbox.  Those.  here we will simply delegate work to the current MPSC-mbox. <br><br>  <i>subscribe_event_handler ()</i> .  This method is called when the agent wants to subscribe to messages of type T. We will register type T in this method. We need this so that when a message of some type M arrives in the mbox we can check if the agent is subscribed to it.  If signed, you can try to deliver the message (and, accordingly, you need to record the time of the last delivery).  And if not signed - then the message must be ignored. <br><br>  <i>unsubscribe_event_handlers ()</i> .  This method, in contrast to subscribe_event_handler (), is called when the agent wants to unsubscribe from T-type messages. In this method, we will cancel the T-type registration. <br><br>  <i>query_name ()</i> .  This method should return the string name of the mbox.  This method serves for debugging and diagnostic purposes.  For example, a SObjectizer may tug this method when generating error messages. <br><br>  <i>type ()</i> .  This method should return the mbox type: is mbox Multi-Producer / Multi-Consumer or is it Multi-Producer / Single-Consumer.  This method is called by the SObjectizer to check whether these or other actions can be performed.  For example, <a href="https://sourceforge.net/p/sobjectizer/wiki/so-5.5%2520In-depth%2520-%2520Mutable%2520Messages/">mutable messages</a> can only be sent to MPSC-mboxes. <br><br>  <i>do_deliver_message ()</i> .  This method is responsible for sending the message to the receiving agent.  In this method we have to check if the type of the message being sent is registered with us.  If not, the message is ignored.  If it is registered and enough time has passed since the last delivery of the message, the message should be delivered to the recipient (and we fix the delivery time).  The delivery itself is delegated to the current MPSC-mbox agent. <br><br>  <i>do_deliver_service_request ()</i> .  This method is similar to do_deliver_message (), but it is called when agent A makes a synchronous request to agent B (that is, request_future or request_value is used instead of send_message).  For simplicity, we will not support the functionality of synchronous requests for our anti-jitter-mbox. <br><br>  <i>set_delivery_filter ()</i> and <i>drop_delivery_filter ()</i> .  These methods are used to set and clear message delivery filters.  Since delivery filters for MPSC-mboxes are not intended, we will not support this functionality in our example. <br><br><h3>  Explanation of the constancy of some methods abstract_message_mbox_t </h3><br>  In the example implementation, you will see that the do_deliver_message () and do_deliver_service_request () methods are declared as constant.  But, since  in do_deliver_message () we have to modify the internal state of our anti-jitter-mbox, then we have to mark this same state as mutable in the description of the mbox class. <br><br>  This is a consequence of the ancient architectural miscalculation when forming the interface of the class abstract_message_mbox_t.  When this class was formed many years ago, we did not think that someone would ever need to create their own types of mboxes. <br><br>  When it turned out a year and a half or two ago that it was not only necessary, but sometimes very necessary, we were faced with a choice: break compatibility within the SObjectizer-5.5 branch or leave everything as it is and change the abstract_message_mbox_t interface in some future major release (like SObjectizer-5.6).  Since we have a quirk about maintaining compatibility between releases within the same branch, we in SObjectizer-5.5 decided to leave everything as it is.  Therefore, now when implementing your own mboxes, you need to reckon with the constancy of a number of abstract_message_mbox_t methods and use the mutable keyword. <br><br><h2>  Implementing your own anti-jitter-mbox </h2><br>  Well, now we can already look at what our own mbox will be. <br><br>  Let's start with the data that our mbox will handle: <br><br><pre> <code class="hljs ruby">using namespace std::chrono; using clock_type = steady_clock; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">anti_jitter_mbox</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">public</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">so_5::abstract_message_box_t</span></span></span><span class="hljs-class"> { //        ,   //           // . </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">data</span></span></span><span class="hljs-class"> { //      . </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">item</span></span></span><span class="hljs-class"> { //      .  0 , //          . </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std::size_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">subscribers_</span></span></span><span class="hljs-class">{0};</span></span> /<span class="hljs-regexp"><span class="hljs-regexp">/    . /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   ,       . std::optional&lt;clock_type::time_point&gt; last_received_{}; }; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   ,     /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   . using message_table = std::map&lt;std::type_index, item&gt;; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   mutex    mbox-   /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ . std::mutex lock_; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  ,    . message_table messages_; }; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  mbox-. /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  mbox,       . const so_5::mbox_t mbox_; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/     "" . const clock_type::duration timeout_; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   mbox-.  SObjectizer-5.5    /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  mutable, ..         /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ const-. mutable data data_;</span></span></code> </pre> <br>  We need an up-to-date mbox, through which the delivery of messages to the recipient agent, the time threshold for cutting off the ‚Äúextra‚Äù messages and the actual information about the types of messages and the time of their last receipt.  Plus, we need mutex, since the mbox methods can be called on different working threads and we will have to provide thread-safety for our mbox. <br><br>  By the way, just because of the provision of thread-safety in most methods we will have to capture the internal mutex of our mbox.  In order to simplify your life, let's make an auxiliary template method, which will be responsible for capturing mutex and performing the actions we need under the captured mutex: <br><br><pre> <code class="hljs cpp"> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Lambda&gt; <span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>) lock_and_perform(Lambda l) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::lock_guard&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::mutex&gt; lock{data_.lock_}; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> l(); }</code> </pre> <br>  In principle, its presence is not necessary.  But I decided to use it for another reason: for ease of implementation, we will not bother with such a thing as exception safety.  If during the execution of some actions we have an exception, then we just need to stop the work of the entire application.  Just that lock_and_perform is marked as noexcept and provides us with this behavior - if lambda throws an exception, the C ++ run-time itself will call std :: terminate. <br><br>  Well, now you can look at the actual implementation of mbox itself: <br><br><pre> <code class="hljs ruby"><span class="hljs-symbol"><span class="hljs-symbol">public:</span></span> /<span class="hljs-regexp"><span class="hljs-regexp">/ .    MPSC-mbox,  /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/      . anti_jitter_mbox( so_5::mbox_t actual_mbox, clock_type::duration timeout) : mbox_{std::move(actual_mbox)} , timeout_{timeout} {} /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  ID mbox-.     ID  mbox-. so_5::mbox_id_t id() const override { return mbox_-&gt;id(); } /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    . void subscribe_event_handler( const std::type_index &amp; msg_type, const so_5::message_limit::control_block_t * limit, so_5::agent_t * subscriber ) override { lock_and_perform([&amp;]{ /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/      .    /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   ,     . auto &amp; msg_data = data_.messages_[msg_type]; msg_data.subscribers_ += 1; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/     mbox-. mbox_-&gt;subscribe_event_handler(msg_type, limit, subscriber); }); } /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   . void unsubscribe_event_handlers( const std::type_index &amp; msg_type, so_5::agent_t * subscriber ) override { lock_and_perform([&amp;]{ /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/      . /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    ,     . auto it = data_.messages_.find(msg_type); if(it != data_.messages_.end()) { auto &amp; msg_data = it-&gt;second; --msg_data.subscribers_; if(!msg_data.subscribers_) /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    ,    /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/       . data_.messages_.erase(it); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  mbox      . mbox_-&gt;unsubscribe_event_handlers(msg_type, subscriber); } }); } /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   mbox-. std::string query_name() const override { return "&lt;mbox:type=anti-jitter-mpsc:id=" + std::to_string(id()) + "&gt;"; } /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   mbox-.  ,    . so_5::mbox_type_t type() const override { return mbox_-&gt;type(); } /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/     . void do_deliver_message( const std::type_index &amp; msg_type, const so_5::message_ref_t &amp; message, unsigned int overlimit_reaction_deep ) const override { lock_and_perform([&amp;]{ /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/       . /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    ,      /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    . auto it = data_.messages_.find(msg_type); if(it != data_.messages_.end()) { auto &amp; msg_data = it-&gt;second; const auto now = clock_type::now(); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ ,    . /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/      (..  last_received_ /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  ),   . bool should_be_delivered = true; if(msg_data.last_received_) { should_be_delivered = (now - *(msg_data.last_received_)) &gt;= timeout_; } /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  - ,     mbox  /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/        /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ . if(should_be_delivered) { msg_data.last_received_ = now; mbox_-&gt;do_deliver_message(msg_type, message, overlimit_reaction_deep); } } }); } /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    . void do_deliver_service_request( const std::type_index &amp; /</span></span>*msg_type*<span class="hljs-regexp"><span class="hljs-regexp">/, const so_5::message_ref_t &amp; /</span></span>*message*<span class="hljs-regexp"><span class="hljs-regexp">/, unsigned int /</span></span>*overlimit_reaction_deep*<span class="hljs-regexp"><span class="hljs-regexp">/ ) const override { /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  ,    so_5::exception_t   /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  ,     SObjectizer-. SO_5_THROW_EXCEPTION(so_5::rc_not_implemented, "anti-jitter-mbox doesn't support service requests"); } /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    MPSC-mbox-  .   /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   . void set_delivery_filter( const std::type_index &amp; /</span></span>*msg_type*<span class="hljs-regexp"><span class="hljs-regexp">/, const so_5::delivery_filter_t &amp; /</span></span>*filter*<span class="hljs-regexp"><span class="hljs-regexp">/, so_5::agent_t &amp; /</span></span>*subscriber*<span class="hljs-regexp"><span class="hljs-regexp">/ ) override { SO_5_THROW_EXCEPTION(so_5::rc_not_implemented, "anti-jitter-mbox doesn't support delivery filters"); } void drop_delivery_filter( const std::type_index &amp; /</span></span>*msg_type*<span class="hljs-regexp"><span class="hljs-regexp">/, so_5::agent_t &amp; /</span></span>*subscriber*<span class="hljs-regexp"><span class="hljs-regexp">/ ) noexcept override { SO_5_THROW_EXCEPTION(so_5::rc_not_implemented, "anti-jitter-mbox doesn't support delivery filters"); } };</span></span></code> </pre> <br>    ,     mbox-,           .           MPSC-mbox-: <br><br><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ordinary_subscriber</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> name_; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: ordinary_subscriber(<span class="hljs-keyword"><span class="hljs-keyword">context_t</span></span> ctx, <span class="hljs-comment"><span class="hljs-comment">//  ,    . std::string name) : so_5::agent_t{std::move(ctx)} , name_{std::move(name)} { so_subscribe_self().event([&amp;](mhood_t&lt;std::string&gt; cmd) { std::cout &lt;&lt; name_ &lt;&lt; ": signal received -&gt; " &lt;&lt; *cmd &lt;&lt; std::endl; }); } // Mbox,      . auto target_mbox() const { return so_direct_mbox(); } };</span></span></code> </pre> <br>          anti-jitter-mbox: <br><br><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">anti_jitter_subscriber</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> name_; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> anti_jitter_mbox_; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: anti_jitter_subscriber(<span class="hljs-keyword"><span class="hljs-keyword">context_t</span></span> ctx, <span class="hljs-comment"><span class="hljs-comment">//  ,    . std::string name, //  ,     //  "" . clock_type::duration jitter_threshold) : so_5::agent_t{std::move(ctx)} , name_{std::move(name)} , anti_jitter_mbox_{ new anti_jitter_mbox{so_direct_mbox(), jitter_threshold}} { //     mbox. so_subscribe(anti_jitter_mbox_).event([&amp;](mhood_t&lt;std::string&gt; cmd) { std::cout &lt;&lt; name_ &lt;&lt; ": signal received -&gt; " &lt;&lt; *cmd &lt;&lt; std::endl; }); } // Mbox,      . auto target_mbox() const { return anti_jitter_mbox_; } };</span></span></code> </pre> <br>           : <br><br><pre> <code class="hljs markdown">//       . void generate<span class="hljs-emphasis"><span class="hljs-emphasis">_msg_</span></span>sequence( so<span class="hljs-emphasis"><span class="hljs-emphasis">_5::environment_</span></span>t &amp; env, const so<span class="hljs-emphasis"><span class="hljs-emphasis">_5::mbox_</span></span>t &amp; ordinary<span class="hljs-emphasis"><span class="hljs-emphasis">_mbox, const so_</span></span>5::mbox<span class="hljs-emphasis"><span class="hljs-emphasis">_t &amp; anti_</span></span>jitter<span class="hljs-emphasis"><span class="hljs-emphasis">_mbox) { std::vector&lt;milliseconds&gt; delays{ 125ms, 250ms, 400ms, 500ms, 700ms, 750ms, 800ms }; for(const auto d : delays) { const std::string msg = std::to_</span></span>string(d.count()) + "ms"; so<span class="hljs-emphasis"><span class="hljs-emphasis">_5::send_</span></span>delayed<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">std::string</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span>(env, ordinary<span class="hljs-emphasis"><span class="hljs-emphasis">_mbox, d, msg); so_</span></span>5::send<span class="hljs-emphasis"><span class="hljs-emphasis">_delayed&lt;std::string&gt;(env, anti_</span></span>jitter<span class="hljs-emphasis"><span class="hljs-emphasis">_mbox, d, msg); } } int main() { //  SObjectizer    . so_</span></span>5::launch([<span class="hljs-string"></span><span class="hljs-string"></span>](<span class="hljs-link"><span class="hljs-link">so_5::environment_t &amp; env</span></span>) { //    mbox-.      //     . so<span class="hljs-emphasis"><span class="hljs-emphasis">_5::mbox_</span></span>t ordinary, anti<span class="hljs-emphasis"><span class="hljs-emphasis">_jitter; //    ,      //  mbox. env.introduce_</span></span>coop([<span class="hljs-string"><span class="hljs-string">&amp;</span></span>](<span class="hljs-link"><span class="hljs-link">so_5::coop_t &amp; coop</span></span>) { ordinary = coop.make<span class="hljs-emphasis"><span class="hljs-emphasis">_agent&lt;ordinary_</span></span>subscriber&gt;( "ordinary-mbox")-&gt;target<span class="hljs-emphasis"><span class="hljs-emphasis">_mbox(); anti_</span></span>jitter = coop.make<span class="hljs-emphasis"><span class="hljs-emphasis">_agent&lt;anti_</span></span>jitter<span class="hljs-emphasis"><span class="hljs-emphasis">_subscriber&gt;( "anti-jitter-mbox", 250ms)-&gt;target_</span></span>mbox(); }); //     . generate<span class="hljs-emphasis"><span class="hljs-emphasis">_msg_</span></span>sequence(env, ordinary, anti<span class="hljs-emphasis"><span class="hljs-emphasis">_jitter); //       . std::this_</span></span>thread::sleep_for(1250ms); //    . env.stop(); }); return 0; }</code> </pre> <br>      ,    anti-jitter-mbox-   ,     mbox-: <br><br><pre> ordinary-mbox: signal received -&gt; 125ms<font></font>
anti-jitter-mbox: signal received -&gt; 125ms<font></font>
ordinary-mbox: signal received -&gt; 250ms<font></font>
ordinary-mbox: signal received -&gt; 400ms<font></font>
anti-jitter-mbox: signal received -&gt; 400ms<font></font>
ordinary-mbox: signal received -&gt; 500ms<font></font>
ordinary-mbox: signal received -&gt; 700ms<font></font>
anti-jitter-mbox: signal received -&gt; 700ms<font></font>
ordinary-mbox: signal received -&gt; 750ms<font></font>
ordinary-mbox: signal received -&gt; 800ms </pre><br><h1>    </h1><br>          <a href="https://bitbucket.org/sobjectizerteam/so5_mboxes_demo">  </a> . <br><br><h1>  Epilogue </h1><br>      ,       .   , ,    :) <br><br>       : <a href="https://sourceforge.net/p/sobjectizer/news/2017/12/sobjectizer-5520-and-so5extra-103/">SObjectizer  so_5_extra </a> . SObjectizer   5.5.20, so_5_extra   1.0.3.   SObjectizer       <a href="https://github.com/Microsoft/vcpkg">vcpkg</a> .     SObjectizer   <i>vcpkg install sobjectizer</i> . <br><br>              SObjectizer:  5.6,       ,     , , ,     5.5.     SObjectizer-5.6  <a href="http://eao197.blogspot.com/2017/11/progc-sobjectizer-56.html"></a> .      ,   SObjectizer-  ,        SObjectizer     SObjectizer     . <br><br>    -     -   SObjectizer,     .  .       ,       . </div><p>Source: <a href="https://habr.com/ru/post/344580/">https://habr.com/ru/post/344580/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../344570/index.html">Virtual nuclear installations: full development cycle for Oculus Rift in one person (UPD 12/18/2017)</a></li>
<li><a href="../344572/index.html">Vulnerability from 1998 again in the ranks - meet ROBOT</a></li>
<li><a href="../344574/index.html">Butthur Develop: How to win?</a></li>
<li><a href="../344576/index.html">The results of a survey on the use of javascript-technology "The state of JavaScript 2017"</a></li>
<li><a href="../344578/index.html">Experiments with Solidity contracts on the Rinkeby test network of the Ethereum blockchain</a></li>
<li><a href="../344582/index.html">New Year dataset: open semantics of the Russian language</a></li>
<li><a href="../344584/index.html">When Bitcoin stops growing: tokens are a real alternative to Coin</a></li>
<li><a href="../344586/index.html">The two biggest CRMs are Salesforce and Zoho ‚Äî a comparison of telephone integrations</a></li>
<li><a href="../344588/index.html">Development through acceptance tests (ATDD). What it is and what it is eaten with</a></li>
<li><a href="../344590/index.html">AI systems in 2018: six predictions</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>