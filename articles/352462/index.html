<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Creating a game on Lua and L√ñVE - 5</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Table of contents 


- Article 1 Part 1. Game cycle Part 2. Libraries Part 3. Rooms and areas Part 4. Exercises 
- Part 1. Game cycle 
- Part 2. Libra...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Creating a game on Lua and L√ñVE - 5</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/277/af4/cfe/277af4cfea1312469abb5cc1806a6a44.jpg" alt="image"></div><br><h2>  Table of contents </h2><br><ul><li>  <a href="https://habrahabr.ru/post/349276/">Article 1</a> <ul><li>  Part 1. Game cycle </li><li>  Part 2. Libraries </li><li>  Part 3. Rooms and areas </li><li>  Part 4. Exercises </li></ul></li><li>  <a href="https://habrahabr.ru/post/349440/">Article 2</a> <ul><li>  Part 5. Basics of the game </li><li>  Part 6. Basics of the Player Class </li></ul></li><li>  <a href="https://habrahabr.ru/post/349718/">Article 3</a> <ul><li>  Part 7. Player Parameters and Attacks </li><li>  Part 8. Enemies </li></ul></li><li>  <a href="https://habrahabr.ru/post/350316/">Article 4</a> <ul><li>  Part 9. Director and game cycle </li><li>  Part 10. Code Writing Practices </li><li>  Part 11. Passive skills </li></ul></li><li>  <a href="https://habrahabr.ru/post/350316/">Article 5</a> <ul><li>  Part 12. Other Passive Skills </li></ul></li></ul><br>  13. Skill Tree <br><br>  14. Console <br><br>  15. Final 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  Part 12: Other Passive Skills </h2><br><h3>  Volley </h3><br>  We will start with the implementation of the remaining attacks.  The first is the Blast attack, which looks like this: <br><br><div class="spoiler">  <b class="spoiler_title">Gif</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/20d/979/7d2/20d9797d2ea3214914874ef570029876.gif"></div></div></div><br>  Several shells are shot at different speeds, like a shotgun, which then quickly disappear.  All colors are taken from the table of <code>negative_colors</code> and each shell deals less damage than usual. <a name="habracut"></a>  This is how the attack table will look like: <br><cut></cut><br><pre> <code class="lua hljs">attacks[<span class="hljs-string"><span class="hljs-string">'Blast'</span></span>] = {cooldown = <span class="hljs-number"><span class="hljs-number">0.64</span></span>, ammo = <span class="hljs-number"><span class="hljs-number">6</span></span>, abbreviation = <span class="hljs-string"><span class="hljs-string">'W'</span></span>, color = default_color}</code> </pre> <br>  And here is the process of creating shells: <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Player:shoot</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">elseif</span></span> self.attack == <span class="hljs-string"><span class="hljs-string">'Blast'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> self.ammo = self.ammo - attacks[self.attack].ammo <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">12</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> random_angle = <span class="hljs-built_in"><span class="hljs-built_in">random</span></span>(-<span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">pi</span></span>/<span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">pi</span></span>/<span class="hljs-number"><span class="hljs-number">6</span></span>) self.area:addGameObject(<span class="hljs-string"><span class="hljs-string">'Projectile'</span></span>, self.x + <span class="hljs-number"><span class="hljs-number">1.5</span></span>*d*<span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">cos</span></span>(self.r + random_angle), self.y + <span class="hljs-number"><span class="hljs-number">1.5</span></span>*d*<span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(self.r + random_angle), <span class="hljs-built_in"><span class="hljs-built_in">table</span></span>.merge({r = self.r + random_angle, attack = self.attack, v = <span class="hljs-built_in"><span class="hljs-built_in">random</span></span>(<span class="hljs-number"><span class="hljs-number">500</span></span>, <span class="hljs-number"><span class="hljs-number">600</span></span>)}, mods)) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> camera:shake(<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">60</span></span>, <span class="hljs-number"><span class="hljs-number">0.4</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  Here we simply create 12 rounds with a random angle in the range from -30 to +30 degrees from the direction in which the player moves.  We also randomize the speed in the range of 500 and 600 (usually its value is 200), that is, the projectile will be about three times faster than usual. <br><br>  However, this will not give us the desired behavior, because we want the shells to disappear quickly enough.  This can be implemented as follows: <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Projectile:new</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self.attack == <span class="hljs-string"><span class="hljs-string">'Blast'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> self.damage = <span class="hljs-number"><span class="hljs-number">75</span></span> self.color = <span class="hljs-built_in"><span class="hljs-built_in">table</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">random</span></span>(negative_colors) self.timer:tween(<span class="hljs-built_in"><span class="hljs-built_in">random</span></span>(<span class="hljs-number"><span class="hljs-number">0.4</span></span>, <span class="hljs-number"><span class="hljs-number">0.6</span></span>), self, {v = <span class="hljs-number"><span class="hljs-number">0</span></span>}, <span class="hljs-string"><span class="hljs-string">'linear'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> self:die() <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  Here are three actions.  First, we set a value less than 100 for damage. This means that in order to kill an ordinary enemy with 100 HP, we need not one, but two projectiles.  This is logical, because during this attack, 12 shells are fired simultaneously.  Secondly, we set the color of the projectile by randomly selecting it from the <code>negative_colors</code> table.  This is the place where the code is convenient for us to do this.  Finally, we report that after a random interval of time from 0.4 to 0.6 seconds, this projectile should be destroyed, which will give us the desired effect.  In addition, we do not just destroy the projectile, but reduce its speed to 0, because it looks a little better. <br><br>  All this creates the behavior we need and it seems that we have already finished.  However, after adding a heap of passive skills in the previous part of the article, we need to be careful and make sure that everything added after will normally be combined with these passive skills.  For example, the last in the previous part, we added the effect of a shell shield.  The problem with the Blast attack is that it is completely incompatible with the effect of a shield projectile, because Blast projectiles die in 0.4-0.6 seconds, which makes them very bad projectiles for a shield. <br><br>  One way to solve this problem is to separate the interfering passive skills (in our case, the shield) and apply our own logic to each situation.  In a situation where the <code>shield</code> value for the projectile is true, then the projectile, independently of the rest, must exist for 6 seconds.  And in all other situations the duration specified by the attack will be preserved.  Here is what it will look like: <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Projectile:new</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self.attack == <span class="hljs-string"><span class="hljs-string">'Blast'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> self.damage = <span class="hljs-number"><span class="hljs-number">75</span></span> self.color = <span class="hljs-built_in"><span class="hljs-built_in">table</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">random</span></span>(negative_colors) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> self.shield <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> self.timer:tween(<span class="hljs-built_in"><span class="hljs-built_in">random</span></span>(<span class="hljs-number"><span class="hljs-number">0.4</span></span>, <span class="hljs-number"><span class="hljs-number">0.6</span></span>), self, {v = <span class="hljs-number"><span class="hljs-number">0</span></span>}, <span class="hljs-string"><span class="hljs-string">'linear'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> self:die() <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self.shield <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> ... self.timer:after(<span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> self:die() <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  This solution seems like a hack, and you can easily imagine that it will gradually become more complex with the addition of new passive skills, and we will have to add more and more conditions.  But based on my experience, this method is the simplest and least error prone than all the others.  You can try to solve this problem in a different, more general way, and this will usually have unintended consequences.  Perhaps there is a better general solution to this problem, which I personally did not think of, but if I did not find it, then the next best solution would be the simplest one, namely the set of conditional structures that determine what can and cannot be done.  Be that as it may, now every new added attack that changes the duration of the projectile's life, we will precede the condition <code>if not self.shield</code> . <br><br>  <strong>172. (CONTENT)</strong> Implement the passive skill <code>projectile_duration_multiplier</code> .  Remember to use it for all duration-related behaviors of the Projectile class. <br><br><h3>  Rotation </h3><br>  The next realizable attack will be Spin.  It looks like this: <br><br><div class="spoiler">  <b class="spoiler_title">Gif</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/962/442/8d3/9624428d34edb9a94e661474c02a4dd2.gif"></div></div></div><br>  These shells constantly change the angle to a constant value.  We can do this by adding the variable <code>rv</code> , which will designate the rate of change of the angle, and then add in each frame this value to <code>r</code> : <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Projectile:new</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span></span> ... self.rv = <span class="hljs-built_in"><span class="hljs-built_in">table</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">random</span></span>({<span class="hljs-built_in"><span class="hljs-built_in">random</span></span>(<span class="hljs-number"><span class="hljs-number">-2</span></span>*<span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">pi</span></span>, -<span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">pi</span></span>), <span class="hljs-built_in"><span class="hljs-built_in">random</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">pi</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>*<span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">pi</span></span>)}) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Projectile:update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dt)</span></span></span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self.attack == <span class="hljs-string"><span class="hljs-string">'Spin'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> self.r = self.r + self.rv*dt <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  We choose between intervals from -2 * math.pi to -math.pi OR between intervals from math.pi to 2 * math.pi because we do not want absolute values ‚Äã‚Äãto be less than math.pi or greater than 2 * math.pi .  Low absolute values ‚Äã‚Äãmean that the circle performed by the projectile becomes larger, and large absolute values ‚Äã‚Äãmean that the circle becomes smaller.  We want to limit the size of the circle with the values ‚Äã‚Äãwe need to make it look right.  It should also be understood that the difference between negative and positive values ‚Äã‚Äãlies in the direction in which the circle rotates. <br><br>  In addition, we can add spins to the shells for a long life, because we do not want them to exist forever: <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Projectile:new</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self.attack == <span class="hljs-string"><span class="hljs-string">'Spin'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> self.timer:after(<span class="hljs-built_in"><span class="hljs-built_in">random</span></span>(<span class="hljs-number"><span class="hljs-number">2.4</span></span>, <span class="hljs-number"><span class="hljs-number">3.2</span></span>), <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> self:die() <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  This is how the <code>shoot</code> function will look like: <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Player:shoot</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">elseif</span></span> self.attack == <span class="hljs-string"><span class="hljs-string">'Spin'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> self.ammo = self.ammo - attacks[self.attack].ammo self.area:addGameObject(<span class="hljs-string"><span class="hljs-string">'Projectile'</span></span>, self.x + <span class="hljs-number"><span class="hljs-number">1.5</span></span>*d*<span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">cos</span></span>(self.r), self.y + <span class="hljs-number"><span class="hljs-number">1.5</span></span>*d*<span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(self.r), <span class="hljs-built_in"><span class="hljs-built_in">table</span></span>.merge({r = self.r, attack = self.attack}, mods)) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  And here is the attack table: <br><br><pre> <code class="lua hljs">attacks[<span class="hljs-string"><span class="hljs-string">'Spin'</span></span>] = {cooldown = <span class="hljs-number"><span class="hljs-number">0.32</span></span>, ammo = <span class="hljs-number"><span class="hljs-number">2</span></span>, abbreviation = <span class="hljs-string"><span class="hljs-string">'Sp'</span></span>, color = hp_color}</code> </pre> <br>  This way we get the behavior we need.  However, we need one more thing - the trail of the projectile.  Unlike the self-guided projectile, which uses the same trail used for the player‚Äôs ships, this projectile trail will follow the shape and color of the projectile, but will also slowly become invisible until it completely disappears.  We can do this in the same way as we did for another object of the track, but taking into account these differences: <br><br><pre> <code class="lua hljs">ProjectileTrail = GameObject:extend() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ProjectileTrail:new</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(area, x, y, opts)</span></span></span></span> ProjectileTrail.super.new(self, area, x, y, opts) self.alpha = <span class="hljs-number"><span class="hljs-number">128</span></span> self.timer:tween(<span class="hljs-built_in"><span class="hljs-built_in">random</span></span>(<span class="hljs-number"><span class="hljs-number">0.1</span></span>, <span class="hljs-number"><span class="hljs-number">0.3</span></span>), self, {alpha = <span class="hljs-number"><span class="hljs-number">0</span></span>}, <span class="hljs-string"><span class="hljs-string">'in-out-cubic'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> self.dead = <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ProjectileTrail:update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dt)</span></span></span></span> ProjectileTrail.super.update(self, dt) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ProjectileTrail:draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> pushRotate(self.x, self.y, self.r) <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> r, g, b = <span class="hljs-built_in"><span class="hljs-built_in">unpack</span></span>(self.color) love.graphics.setColor(r, g, b, self.alpha) love.graphics.setLineWidth(<span class="hljs-number"><span class="hljs-number">2</span></span>) love.graphics.line(self.x - <span class="hljs-number"><span class="hljs-number">2</span></span>*self.s, self.y, self.x + <span class="hljs-number"><span class="hljs-number">2</span></span>*self.s, self.y) love.graphics.setLineWidth(<span class="hljs-number"><span class="hljs-number">1</span></span>) love.graphics.setColor(<span class="hljs-number"><span class="hljs-number">255</span></span>, <span class="hljs-number"><span class="hljs-number">255</span></span>, <span class="hljs-number"><span class="hljs-number">255</span></span>, <span class="hljs-number"><span class="hljs-number">255</span></span>) love.graphics.pop() <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ProjectileTrail:destroy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> ProjectileTrail.super.destroy(self) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  And it looks quite standard, the only noticeable aspect is that we have the <code>alpha</code> variable, which we change through tween to 0, so that the projectile slowly disappears after a random period of time from 0.1 to 0.3 seconds, and then we draw the trace in the same way how to draw a shell.  It is important that we use the variables <code>r</code> , <code>s</code> and <code>color</code> parent projectile, that is, when creating it, we need to transfer them all: <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Projectile:new</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self.attack == <span class="hljs-string"><span class="hljs-string">'Spin'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> self.rv = <span class="hljs-built_in"><span class="hljs-built_in">table</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">random</span></span>({<span class="hljs-built_in"><span class="hljs-built_in">random</span></span>(<span class="hljs-number"><span class="hljs-number">-2</span></span>*<span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">pi</span></span>, -<span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">pi</span></span>), <span class="hljs-built_in"><span class="hljs-built_in">random</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">pi</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>*<span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">pi</span></span>)}) self.timer:after(<span class="hljs-built_in"><span class="hljs-built_in">random</span></span>(<span class="hljs-number"><span class="hljs-number">2.4</span></span>, <span class="hljs-number"><span class="hljs-number">3.2</span></span>), <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> self:die() <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>) self.timer:every(<span class="hljs-number"><span class="hljs-number">0.05</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> self.area:addGameObject(<span class="hljs-string"><span class="hljs-string">'ProjectileTrail'</span></span>, self.x, self.y, {r = Vector(self.collider:getLinearVelocity()):angle(), color = self.color, s = self.s}) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  In this way we will achieve the results we need. <br><br>  <strong>173. (CONTENT)</strong> Implement the <code>Flame</code> attack.  Here's what the attack table should look like: <br><br><pre> <code class="lua hljs">attacks[<span class="hljs-string"><span class="hljs-string">'Flame'</span></span>] = {cooldown = <span class="hljs-number"><span class="hljs-number">0.048</span></span>, ammo = <span class="hljs-number"><span class="hljs-number">0.4</span></span>, abbreviation = <span class="hljs-string"><span class="hljs-string">'F'</span></span>, color = skill_point_color}</code> </pre> <br>  And here is the attack itself: <br><br><div class="spoiler">  <b class="spoiler_title">Gif</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/99c/5f1/ac2/99c5f1ac2e0f8524a035bc1f1769b962.gif"></div></div></div><br>  Projectiles must remain alive for a random interval of time from 0.6 to 1 second and resemble Blast projectiles, and their speed must be changed during this time using tween to 0. These projectiles also use the ProjectileTrail object in the same way as Spin projectiles do.  Each of the Flame shells also deals reduced damage by 50 units. <br><br><h3>  Bouncing shells </h3><br>  Bounce projectiles should bounce off the walls, not collapse them.  By default, the Bounce projectile can bounce off the walls 4 times before being destroyed on another blow to the wall.  We can set this using the <code>opts</code> table in the <code>shoot</code> function: <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Player:shoot</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">elseif</span></span> self.attack == <span class="hljs-string"><span class="hljs-string">'Bounce'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> self.ammo = self.ammo - attacks[self.attack].ammo self.area:addGameObject(<span class="hljs-string"><span class="hljs-string">'Projectile'</span></span>, self.x + <span class="hljs-number"><span class="hljs-number">1.5</span></span>*d*<span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">cos</span></span>(self.r), self.y + <span class="hljs-number"><span class="hljs-number">1.5</span></span>*d*<span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(self.r), <span class="hljs-built_in"><span class="hljs-built_in">table</span></span>.merge({r = self.r, attack = self.attack, bounce = <span class="hljs-number"><span class="hljs-number">4</span></span>}, mods)) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  Thus, the <code>bounce</code> variable will contain the number of bounces left by the projectile.  We can use it by decreasing by 1 with each blow to the wall: <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Projectile:update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dt)</span></span></span></span> ... <span class="hljs-comment"><span class="hljs-comment">-- Collision if self.bounce and self.bounce &gt; 0 then if self.x &lt; 0 then self.r = math.pi - self.r self.bounce = self.bounce - 1 end if self.y &lt; 0 then self.r = 2*math.pi - self.r self.bounce = self.bounce - 1 end if self.x &gt; gw then self.r = math.pi - self.r self.bounce = self.bounce - 1 end if self.y &gt; gh then self.r = 2*math.pi - self.r self.bounce = self.bounce - 1 end else if self.x &lt; 0 then self:die() end if self.y &lt; 0 then self:die() end if self.x &gt; gw then self:die() end if self.y &gt; gh then self:die() end end ... end</span></span></code> </pre> <br>  Here, in addition to reducing the number of remaining rebounds, we also change the direction of the projectile, taking into account the wall that it hit.  Perhaps there is a more general way to do this, but I could only come up with a solution that takes into account the collision with each wall separately, after which the necessary calculations are performed to correctly reflect / reflect the angle of the projectile.  Note that when <code>bounce</code> is 0, the first conditional construction is skipped and we go to the usual path, which leads to the destruction of the projectile. <br><br>  It is also important to arrange all this collision code before calling <code>setLinearVelocity</code> , otherwise bounces will not work, because we will turn the projectile with a delay of one frame, but simply reversing its angle will not cause it to go back.  For the sake of security, besides turning the angle of the projectile, we can also use <code>setPosition</code> to force it to be positioned, but I do not think this is necessary. <br><br>  The colors of the bouncing projectile will be random, as is the case with the Spread projectile, except that they are taken from the <code>default_colors</code> table.  This means that we need to take care of them in the <code>Projectile:draw</code> function <code>Projectile:draw</code> separately: <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Projectile:draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self.attack == <span class="hljs-string"><span class="hljs-string">'Bounce'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> love.graphics.setColor(<span class="hljs-built_in"><span class="hljs-built_in">table</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">random</span></span>(default_colors)) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  The attack table looks like this: <br><br><pre> <code class="lua hljs">attacks[<span class="hljs-string"><span class="hljs-string">'Bounce'</span></span>] = {cooldown = <span class="hljs-number"><span class="hljs-number">0.32</span></span>, ammo = <span class="hljs-number"><span class="hljs-number">4</span></span>, abbreviation = <span class="hljs-string"><span class="hljs-string">'Bn'</span></span>, color = default_color}</code> </pre> <br>  And all this should look like this: <br><br><div class="spoiler">  <b class="spoiler_title">Gif</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8a2/fc1/fd9/8a2fc1fd9484698f9c938080b036a333.gif"></div></div></div><br>  <strong>174. (CONTENT)</strong> Implement the 2Split attack.  Here is what it looks like: <br><br><div class="spoiler">  <b class="spoiler_title">Gif</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://github.com/SSYGEN/blog/raw/master/images/bytepath123.gif"></div></div></div><br>  It looks exactly like the Homing shell, only using the color <code>ammo_color</code> . <br><br>  When the projectile hits the enemy, it is divided into two (two projectiles are created) at angles of + -45 degrees from the direction of the original projectile.  If the projectile hits the wall, then two projectiles are created or with a reflection angle from the wall (that is, if the projectile hits the upper wall, then two projectiles are created aimed at math.pi / 4 and 3 * math.pi / 4) or the opposite angle reflections of the projectile, you can choose yourself.  Here is the table of this attack: <br><br><pre> <code class="lua hljs">attacks[<span class="hljs-string"><span class="hljs-string">'2Split'</span></span>] = {cooldown = <span class="hljs-number"><span class="hljs-number">0.32</span></span>, ammo = <span class="hljs-number"><span class="hljs-number">3</span></span>, abbreviation = <span class="hljs-string"><span class="hljs-string">'2S'</span></span>, color = ammo_color}</code> </pre> <br>  <strong>175. (CONTENT)</strong> Implement the 4Split attack.  Here is what it looks like: <br><br><div class="spoiler">  <b class="spoiler_title">Gif</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://github.com/SSYGEN/blog/raw/master/images/bytepath121.gif"></div></div></div><br>  It behaves in the same way as the attack of 2Split, only creates not 2, but 4 projectiles.  The shells are sent at all angles of 45 degrees from the center, that is, math.pi / 4, 3 * math.pi / 4, -math.pi / 4 and -3 * math.pi / 4.  This is how the attack table looks like: <br><br><pre> <code class="lua hljs">attacks[<span class="hljs-string"><span class="hljs-string">'4Split'</span></span>] = {cooldown = <span class="hljs-number"><span class="hljs-number">0.4</span></span>, ammo = <span class="hljs-number"><span class="hljs-number">4</span></span>, abbreviation = <span class="hljs-string"><span class="hljs-string">'4S'</span></span>, color = boost_color}</code> </pre> <br><h3>  Lightning </h3><br>  Here's what the Lightning attack looks like: <br><br><div class="spoiler">  <b class="spoiler_title">Gif</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0c3/926/4f7/0c39264f7450491afe2b812edc1c35e7.gif"></div></div></div><br>  When a player reaches a certain distance to the enemy, a lightning bolt is created, causing damage to the enemy.  Most of the work here is to create a lightning bolt, so we‚Äôll look at it first.  We implement it by creating a <code>LightningLine</code> object, which will be a visual representation of the lightning charge: <br><br><pre> <code class="lua hljs">LightningLine = GameObject:extend() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LightningLine:new</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(area, x, y, opts)</span></span></span></span> LightningLine.super.new(self, area, x, y, opts) ... self:generate() <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LightningLine:update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dt)</span></span></span></span> LightningLine.super.update(self, dt) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-comment"><span class="hljs-comment">-- Generates lines and populates the self.lines table with them function LightningLine:generate() end function LightningLine:draw() end function LightningLine:destroy() LightningLine.super.destroy(self) end</span></span></code> </pre> <br>  I will focus on the rendering function and leave the creation of lightning lines for you!  <a href="http://drilian.com/2009/02/25/lightning-bolts/" rel="nofollow">This tutorial</a> describes the generation method in great detail, so I will not repeat it here.  We assume that all the lines that make up the lightning bolt are in the <code>self.lines</code> table, and that each line is a table containing the keys <code>x1, y1, x2, y2</code> .  With this in mind, we can in the simplest way draw a lightning bolt like this: <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LightningLine:draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i, line <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-built_in"><span class="hljs-built_in">ipairs</span></span>(self.<span class="hljs-built_in"><span class="hljs-built_in">lines</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> love.graphics.line(line.x1, line.y1, line.x2, line.y2) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  However, it looks too easy.  Therefore, we need to first draw these lines with the color <code>boost_color</code> and with a line thickness of 2.5, and then on top of them we will draw the same lines again, but with the color <code>default_color</code> and line thickness 1.5.  This will make the lightning bolt a little thicker and more like a zipper. <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LightningLine:draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i, line <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-built_in"><span class="hljs-built_in">ipairs</span></span>(self.<span class="hljs-built_in"><span class="hljs-built_in">lines</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> r, g, b = <span class="hljs-built_in"><span class="hljs-built_in">unpack</span></span>(boost_color) love.graphics.setColor(r, g, b, self.alpha) love.graphics.setLineWidth(<span class="hljs-number"><span class="hljs-number">2.5</span></span>) love.graphics.line(line.x1, line.y1, line.x2, line.y2) <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> r, g, b = <span class="hljs-built_in"><span class="hljs-built_in">unpack</span></span>(default_color) love.graphics.setColor(r, g, b, self.alpha) love.graphics.setLineWidth(<span class="hljs-number"><span class="hljs-number">1.5</span></span>) love.graphics.line(line.x1, line.y1, line.x2, line.y2) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> love.graphics.setLineWidth(<span class="hljs-number"><span class="hljs-number">1</span></span>) love.graphics.setColor(<span class="hljs-number"><span class="hljs-number">255</span></span>, <span class="hljs-number"><span class="hljs-number">255</span></span>, <span class="hljs-number"><span class="hljs-number">255</span></span>, <span class="hljs-number"><span class="hljs-number">255</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  In addition, I use the <code>alpha</code> attribute here, which is initially equal to 255 and is reduced by tween to 0 over the lifetime of the line, that is, approximately 0.15 seconds. <br><br>  We now turn to the creation of this object LightningLine.  We want this attack to work like this: when a player gets close enough to the enemy within his immediate visibility, the attack is triggered and we do damage to the enemy.  So let's start by getting all the enemies close to the player.  We can do it in the same way as in the case of the homing projectile, which picked up the target in a certain radius.  However, we want the radius not to be centered on the player, because the player should not be able to inflict damage on the enemies behind him, so we will shift the center of this circle forward a little, in the direction of the player‚Äôs movement, after which we will perform actions. <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Player:shoot</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">elseif</span></span> self.attack == <span class="hljs-string"><span class="hljs-string">'Lightning'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> x1, y1 = self.x + d*<span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">cos</span></span>(self.r), self.y + d*<span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(self.r) <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> cx, cy = x1 + <span class="hljs-number"><span class="hljs-number">24</span></span>*<span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">cos</span></span>(self.r), y1 + <span class="hljs-number"><span class="hljs-number">24</span></span>*<span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(self.r) ... <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  Here we define <code>x1, y1</code> , that is, the position from which we generally fire projectiles (at the very nose of the ship), and then we also determine <code>cx, cy</code> , that is, the center of the radius, which we will use to search for the nearest enemy.  We shift the circle by 24 units, which is quite a lot so that he cannot choose the enemies behind the player. <br><br>  The next thing we can do is just copy the code we used in the Projectile object, when we wanted the self-guided shells to find their goals, but change it to fit our needs, replacing the position of the circle with our <code>cx, cy</code> center of the circle: <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Player:shoot</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">elseif</span></span> self.attack == <span class="hljs-string"><span class="hljs-string">'Lightning'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> ... <span class="hljs-comment"><span class="hljs-comment">-- Find closest enemy local nearby_enemies = self.area:getAllGameObjectsThat(function(e) for _, enemy in ipairs(enemies) do if e:is(_G[enemy]) and (distance(ex, ey, cx, cy) &lt; 64) then return true end end end) ... end</span></span></code> </pre> <br>  After that we will get a list of enemies within a radius of 64 units of a circle, located 24 units ahead of the player.  Here we can either choose the enemy at random, or take the nearest one.  We will focus on the last option, that is, for this we need to sort the table based on the distance from each of the enemies to the circle: <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Player:shoot</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">elseif</span></span> self.attack == <span class="hljs-string"><span class="hljs-string">'Lightning'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> ... <span class="hljs-built_in"><span class="hljs-built_in">table</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">sort</span></span>(nearby_enemies, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a, b)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> distance(ax, ay, cx, cy) &lt; distance(bx, by, cx, cy) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> closest_enemy = nearby_enemies[<span class="hljs-number"><span class="hljs-number">1</span></span>] ... <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  For this purpose, you can use <code>table.sort</code> .  Then we just need to take the first element of the sorted table and attack it: <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Player:shoot</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">elseif</span></span> self.attack == <span class="hljs-string"><span class="hljs-string">'Lightning'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> ... <span class="hljs-comment"><span class="hljs-comment">-- Attack closest enemy if closest_enemy then self.ammo = self.ammo - attacks[self.attack].ammo closest_enemy:hit() local x2, y2 = closest_enemy.x, closest_enemy.y self.area:addGameObject('LightningLine', 0, 0, {x1 = x1, y1 = y1, x2 = x2, y2 = y2}) for i = 1, love.math.random(4, 8) do self.area:addGameObject('ExplodeParticle', x1, y1, {color = table.random({default_color, boost_color})}) end for i = 1, love.math.random(4, 8) do self.area:addGameObject('ExplodeParticle', x2, y2, {color = table.random({default_color, boost_color})}) end end end end</span></span></code> </pre> <br>  First we need to make sure that <code>closest_enemy</code> does not equal nil, because if this is the case, then we should not do anything.  Most of the time it will be equal to nil, since there are no enemies nearby.  If this is not the case, then we reduce the ammunition, as we did for all other attacks, and then call the <code>hit</code> function for the enemy that is being damaged.  After that, we create a LightningLine object with variables <code>x1, y1, x2, y2</code> , representing the position directly in front of the ship from which the charge will be released, as well as the center of the enemy.  Finally, we create a bunch of ExplodeParticle particles to make the attack more interesting. <br><br>  The last thing we need for an attack to work is its table: <br><br><pre> <code class="lua hljs">attacks[<span class="hljs-string"><span class="hljs-string">'Lightning'</span></span>] = {cooldown = <span class="hljs-number"><span class="hljs-number">0.2</span></span>, ammo = <span class="hljs-number"><span class="hljs-number">8</span></span>, abbreviation = <span class="hljs-string"><span class="hljs-string">'Li'</span></span>, color = default_color}</code> </pre> <br>  And all this should look like this: <br><br><div class="spoiler">  <b class="spoiler_title">Gif</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3c2/742/96c/3c274296c775533e7d8e8538621cd92a.gif"></div></div></div><br>  <strong>176. (CONTENT)</strong> Implement the <code>Explode</code> attack.  Here is what it looks like: <br><br><div class="spoiler">  <b class="spoiler_title">Gif</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://github.com/SSYGEN/blog/raw/master/images/bytepath122.gif"></div></div></div><br>  An explosion is created, destroying all enemies within a certain radius.  The projectile itself looks like homing, except that <code>hp_color</code> slightly larger.  The attack table looks like this: <br><br><pre> <code class="lua hljs">attacks[<span class="hljs-string"><span class="hljs-string">'Explode'</span></span>] = {cooldown = <span class="hljs-number"><span class="hljs-number">0.6</span></span>, ammo = <span class="hljs-number"><span class="hljs-number">4</span></span>, abbreviation = <span class="hljs-string"><span class="hljs-string">'E'</span></span>, color = hp_color}</code> </pre> <br>  <strong>177. (CONTENT)</strong> Implement an attack <code>Laser</code> .  Here is what it looks like: <br><br><div class="spoiler">  <b class="spoiler_title">Gif</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c09/857/e2c/c09857e2c7d1315c4365077712b3948b.gif"></div></div></div><br>  It creates a huge line, destroying all the enemies that cross it.  It can be programmed either as a line or as a rotated rectangle for collision detection.  If you decide to use the line, it is better to use 3 or 5 lines that are slightly separated from each other, otherwise the player will sometimes miss the enemies, which seems unfair. <br><br>  The effect of the attack itself is different from everyone else, but there should be no problems with it.  One huge white line in the middle, whose thickness changes over time with the help of tween, and two red lines on the sides, which are initially close to the white lines, but then expand and disappear when the effect is complete.  The shooting effect is an enlarged version of the original ShootEffect object and also has a red color.  The attack table looks like this: <br><br><pre> <code class="lua hljs">attacks[<span class="hljs-string"><span class="hljs-string">'Laser'</span></span>] = {cooldown = <span class="hljs-number"><span class="hljs-number">0.8</span></span>, ammo = <span class="hljs-number"><span class="hljs-number">6</span></span>, abbreviation = <span class="hljs-string"><span class="hljs-string">'La'</span></span>, color = hp_color}</code> </pre> <br>  <strong>178. (CONTENT)</strong> Implement the passive skill <code>additional_lightning_bolt</code> .  If it is true, then the player can attack with two charges of lightning at the same time.  From a programming point of view, this means that instead of searching for one nearest enemy, we will look for two and attack both if they exist.  You can also try to separate each attack in a small interval, for example 0.5 seconds, because it looks better. <br><br>  <strong>179. (CONTENT)</strong> Implement the passive skill <code>increased_lightning_angle</code> .  This skill increases the angle at which a lightning attack can be triggered, that is, it will also attack enemies on the sides, and sometimes behind the player.  From a programming point of view, this means that when the <code>increased_lightning_angle</code> is true, then we do not offset the lightning circle by 24 units and use the player‚Äôs center in our calculations. <br><br>  <strong>180. (CONTENT)</strong> Implement the area_multiplier passive skill.  This skill increases the range of all attacks and effects associated with squares.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The most recent examples include the Lightning lightning attack circle, as well as the Explode attack area. But this will also apply to explosions in general, as well as to everything related to areas (when a circle is used to obtain information or to apply effects). </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">181. (CONTENT)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Implement a passive skill </font></font><code>laser_width_multiplier</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. This skill increases or decreases the thickness of the Laser attack. </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">182. (CONTENT)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Implement a passive skill </font></font><code>additional_bounce_projectiles</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. This skill increases or decreases the number of bounce projectile bounces. By default, bounce attack projectiles can bounce 4 times. If </font></font><code>additional_bounce_projectiles</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">equal to 4, then the bounce attack projectiles can bounce 8 times. </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">183. (CONTENT)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Implement a passive skill</font></font><code>fixed_spin_attack_direction</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. This type of boolean skill makes it so that all Spin attack projectiles rotate in a constant direction, that is, they all rotate either just to the left or just to the right. </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">184. (CONTENT)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Implement a passive skill </font></font><code>split_projectiles_split_chance</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. This is a projectile, adding to the already divided attack 2Split or 4Split shells the probability to split again. For example, if this probability becomes equal to 100, then separated shells will be recursively separated constantly (however, we will not allow this in the skill tree). </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">185. (CONTENT)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Implement passive skills </font></font><code>[attack]_spawn_chance_multiplier</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">where</font></font><code>[attack]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- this is the name of each attack. </font><font style="vertical-align: inherit;">These skills increase the likelihood of creating a certain attack. </font><font style="vertical-align: inherit;">Now, when we create the Attack resource, the attack is chosen randomly. </font><font style="vertical-align: inherit;">However, now we want them to be selected from the chanceList, which initially has equal probabilities for all attacks, but is modified using passive skills </font></font><code>[attack]_spawn_chance_multiplier</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">186. (CONTENT)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Implement passive skills </font></font><code>start_with_[attack]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, where </font></font><code>[attack]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is the name of each attack. </font><font style="vertical-align: inherit;">These passive skills make the player start the game with an appropriate attack. </font><font style="vertical-align: inherit;">For example, if </font></font><code>start_with_bounce</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">true, the player will begin each round with a bounce attack. </font><font style="vertical-align: inherit;">If true have multiple passive skills </font></font><code>start_with_[attack]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, then one of them is randomly selected.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Additional homing projectiles </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Passive skill </font></font><code>additional_homing_projectiles</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">adds extra projectiles to passive Homing Projectile Launch skills. </font><font style="vertical-align: inherit;">Usually launched self-guided shells look like this:</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Player:onAmmoPickup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self.chances.launch_homing_projectile_on_ammo_pickup_chance:<span class="hljs-built_in"><span class="hljs-built_in">next</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> d = <span class="hljs-number"><span class="hljs-number">1.2</span></span>*self.w self.area:addGameObject(<span class="hljs-string"><span class="hljs-string">'Projectile'</span></span>, self.x + d*<span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">cos</span></span>(self.r), self.y + d*<span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(self.r), {r = self.r, attack = <span class="hljs-string"><span class="hljs-string">'Homing'</span></span>}) self.area:addGameObject(<span class="hljs-string"><span class="hljs-string">'InfoText'</span></span>, self.x, self.y, {text = <span class="hljs-string"><span class="hljs-string">'Homing Projectile!'</span></span>}) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br> <code>additional_homing_projectiles</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- This is the number that tells us how many extra shells to use. </font><font style="vertical-align: inherit;">For this to work, we can do something like this:</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Player:onAmmoPickup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self.chances.launch_homing_projectile_on_ammo_pickup_chance:<span class="hljs-built_in"><span class="hljs-built_in">next</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> d = <span class="hljs-number"><span class="hljs-number">1.2</span></span>*self.w <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>+self.additional_homing_projectiles <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> self.area:addGameObject(<span class="hljs-string"><span class="hljs-string">'Projectile'</span></span>, self.x + d*<span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">cos</span></span>(self.r), self.y + d*<span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(self.r), {r = self.r, attack = <span class="hljs-string"><span class="hljs-string">'Homing'</span></span>}) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> self.area:addGameObject(<span class="hljs-string"><span class="hljs-string">'InfoText'</span></span>, self.x, self.y, {text = <span class="hljs-string"><span class="hljs-string">'Homing Projectile!'</span></span>}) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And then we will only have to apply it to each instance in which the passive skill of </font></font><code>launch_homing_projectile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">any type </font><font style="vertical-align: inherit;">appears </font><font style="vertical-align: inherit;">. </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">187. (CONTENT)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Implement a passive skill </font></font><code>additional_barrage_projectiles</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">188. (CONTENT)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Implement a passive skill </font></font><code>barrage_nova</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">This is a boolean variable, which, when set, causes the projectiles of the queue to be released in a circle, and not in the direction of the player‚Äôs movement. </font><font style="vertical-align: inherit;">Here is what it looks like:</font></font><br><br><div class="spoiler">  <b class="spoiler_title">Gif</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0a4/0e2/2ae/0a40e22ae46d4253d71e12f13297c2fe.gif"></div></div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Projectile mine </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mina projectile is a projectile that remains in its place of creation and explodes over time. </font><font style="vertical-align: inherit;">Here is what it looks like:</font></font><br><br><div class="spoiler">  <b class="spoiler_title">Gif</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fe4/220/9eb/fe42209eb626930743af8bdc7ab5070a.gif"></div></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As you can see, it simply rotates like a spin attack projectile, but much faster. </font><font style="vertical-align: inherit;">To implement this, we say that if the attribute </font></font><code>mine</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is true for the projectile, then it will behave like Spin shells, but with an increased rotation speed.</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Projectile:new</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self.mine <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> self.rv = <span class="hljs-built_in"><span class="hljs-built_in">table</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">random</span></span>({<span class="hljs-built_in"><span class="hljs-built_in">random</span></span>(<span class="hljs-number"><span class="hljs-number">-12</span></span>*<span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">pi</span></span>, <span class="hljs-number"><span class="hljs-number">-10</span></span>*<span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">pi</span></span>), <span class="hljs-built_in"><span class="hljs-built_in">random</span></span>(<span class="hljs-number"><span class="hljs-number">10</span></span>*<span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">pi</span></span>, <span class="hljs-number"><span class="hljs-number">12</span></span>*<span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">pi</span></span>)}) self.timer:after(<span class="hljs-built_in"><span class="hljs-built_in">random</span></span>(<span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">12</span></span>), <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-comment"><span class="hljs-comment">-- Explosion end) end ... end function Projectile:update(dt) ... -- Spin or Mine if self.attack == 'Spin' or self.mine then self.r = self.r + self.rv*dt end ... end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here, instead of limiting the rotation speeds in the interval of absolute values ‚Äã‚Äãfrom math.pi to 2 * math.pi, we take absolute values ‚Äã‚Äãfrom 10 * math.pi to 12 * math.pi. As a result, the projectile rotates much faster and covers a smaller area, which is ideally suited to this type of behavior. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In addition, after a random interval of 8 to 12 seconds, the projectile explodes. This explosion does not need to be processed in the same way as explosions processed for an Explode projectile. In my case, I created an object </font></font><code>Explosion</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, but there are many ways to implement this action. I will leave it as an exercise, because the Explode attack was also an exercise. </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">189. (CONTENT)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Implement a passive skill</font></font><code>drop_mines_chance</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, which adds to the player the likelihood of a projectile mine every 0.5 seconds. From the point of view of programming, this is implemented through a timer that starts every 0.5 seconds. In each of these launches, we roll function cubes </font></font><code>drop_mines_chance:next()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">190. (CONTENT)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Implement a passive skill </font></font><code>projectiles_explode_on_expiration</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that makes it so that when destroying projectiles, because of the end of their lifespan, they also explode. This should apply only to the time of completion of their lives. If a projectile collides with an enemy or a wall, then it should not explode when this skill is true. </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">191. (CONTENT)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Implement a passive skill </font></font><code>self_explode_on_cycle_chance</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. This skill adds the player the chance to create explosions around each cycle. It will look like this:</font></font><br><br><div class="spoiler">  <b class="spoiler_title">Gif</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c3e/d09/146/c3ed091462cc7238766ae22e5f0062c6.gif"></div></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here the same explosions are used as in the Explode attack. </font><font style="vertical-align: inherit;">The number, location and size of the created explosions can be chosen independently. </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">192. (CONTENT)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Implement a passive skill </font></font><code>projectiles_explosions</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">If it is true, then all explosions caused by the projectile created by the player will create multiple projectiles resembling the action of a passive skill </font></font><code>barrage_nova</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">The number of shells created is initially equal to 5 and this number is influenced by the passive skill </font></font><code>additional_barrage_projectiles</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Energy shield </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When the passive skill </font></font><code>energy_shield</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is true, the player's HP turns into an energy shield (from this moment called ES). </font><font style="vertical-align: inherit;">ES work differs from HP's work as follows:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Player takes double damage </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> A player's ES is recharged after a certain period of time if he does not take damage. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Player‚Äôs invulnerability time is half the time. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We can implement all this mainly in the function </font></font><code>hit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Player:new</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span></span> ... <span class="hljs-comment"><span class="hljs-comment">-- ES self.energy_shield_recharge_cooldown = 2 self.energy_shield_recharge_amount = 1 -- Booleans self.energy_shield = true ... end function Player:hit(damage) ... if self.energy_shield then damage = damage*2 self.timer:after('es_cooldown', self.energy_shield_recharge_cooldown, function() self.timer:every('es_amount', 0.25, function() self:addHP(self.energy_shield_recharge_amount) end) end) end ... end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We declare that the pause before the start of ES reloading after hitting is 2 seconds, and that the reloading rate is 4 ES per second (1 per 0.25 seconds in a call </font></font><code>every</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). </font><font style="vertical-align: inherit;">We also have a conditional structure at the top of the hit function and double the damage variable, which will be used below to cause damage to the player. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The only thing left for us here is halving the time of invulnerability. </font><font style="vertical-align: inherit;">We can do this either in the hit function, or in the function </font></font><code>setStats</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">We will choose the second option, because we have not been involved in this function for a long time.</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Player:setStats</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self.energy_shield <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> self.invulnerability_time_multiplier = self.invulnerability_time_multiplier/<span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Since it </font></font><code>setStats</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is called at the end of the constructor and after the function is called </font></font><code>treeToPlayer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(that is, it is called after loading all passive skills from the tree), we can be sure that the value </font></font><code>energy_shield</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">reflects all the skills selected by the player in the tree. In addition, we can be sure that we reduce the invulnerability timer after applying all the increases / decreases of this multiplier from the tree. This is actually not necessary for this passive skill, since order is not important here, but for other skills it may be important and in that case applying changes to </font></font><code>setStats</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">it makes sense. Usually, if the probability of a parameter is obtained from the variable boolean and this change is constantly in the game, then it is more logical to put it in </font></font><code>setStats</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">193. (CONTENT)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Change the HP parameter UI so that when</font></font><code>energy_shield</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is true, it looked like this: </font></font><br><br><div class="spoiler">  <b class="spoiler_title">Gif</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fae/97e/0f9/fae97e0f9a093e79cbe2738874d18bdd.gif"></div></div></div><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">194. (CONTENT)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Implement a passive skill </font></font><code>energy_shield_recharge_amount_multiplier</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that increases or decreases the number of recovered per second ES. </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">195. (CONTENT)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Implement a passive skill </font></font><code>energy_shield_recharge_cooldown_multiplier</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that increases or decreases the pause time after causing the player damage, after which the ES begins to recharge.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Adding probabilities to all ‚Äúkill‚Äù events </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For example, if it </font></font><code>added_chance_to_all_on_kill_events</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is equal to 5, then all the probabilities of all passive skills like ‚Äúduring a murder‚Äù increase by 5%. This means that if the player initially acquired skills that add </font></font><code>launch_homing_projectile_on_kill_chance</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">up to 8, then the final probability instead of 8% will be 13%. This is too powerful a passive skill, but it is interesting to consider it from the point of view of implementation. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We can implement it by changing the way the function generates </font></font><code>generateChances</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">chanceList lists. Since this function bypasses all passive skills whose name ends with </font></font><code>_chance</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, it is obvious that we can also parsit all passive skills containing in the name </font></font><code>_on_kill</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. That is, after we do this, it will be enough for us to add </font></font><code>added_chance_to_all_on_kill_events</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to the appropriate place in the process of generating the chanceList.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To begin, we will separate the usual passive skills from those that have in the title </font></font><code>on_kill</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Player:generateChances</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> self.chances = {} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> k, v <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-built_in"><span class="hljs-built_in">pairs</span></span>(self) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> k:<span class="hljs-built_in"><span class="hljs-built_in">find</span></span>(<span class="hljs-string"><span class="hljs-string">'_chance'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-built_in"><span class="hljs-built_in">type</span></span>(v) == <span class="hljs-string"><span class="hljs-string">'number'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> k:<span class="hljs-built_in"><span class="hljs-built_in">find</span></span>(<span class="hljs-string"><span class="hljs-string">'_on_kill'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> v &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> self.chances[k] = chanceList({<span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">ceil</span></span>(v)}, {<span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-number"><span class="hljs-number">100</span></span>-<span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">ceil</span></span>(v)}) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We use the same method that we used to search for passive skills with </font></font><code>_chance</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, just replace this line with </font></font><code>_on_kill</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">In addition, we also need to verify that this passive skill has a probability of generating an event greater than 0%. </font><font style="vertical-align: inherit;">We do not want the new passive skill to add its probability to all events like ‚Äúwhen killing‚Äù, when the player did not spend points on this event, so we do this only for events in which the player has already invested some probability. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now we can simply create a chanceList, but instead of using the most </font></font><code>v</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">we will use </font></font><code>v+added_chance_to_all_on_kill_events</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Player:generateChances</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> self.chances = {} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> k, v <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-built_in"><span class="hljs-built_in">pairs</span></span>(self) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> k:<span class="hljs-built_in"><span class="hljs-built_in">find</span></span>(<span class="hljs-string"><span class="hljs-string">'_chance'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-built_in"><span class="hljs-built_in">type</span></span>(v) == <span class="hljs-string"><span class="hljs-string">'number'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> k:<span class="hljs-built_in"><span class="hljs-built_in">find</span></span>(<span class="hljs-string"><span class="hljs-string">'_on_kill'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> v &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> self.chances[k] = chanceList( {<span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">ceil</span></span>(v+self.added_chance_to_all_on_kill_events)}, {<span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-number"><span class="hljs-number">100</span></span>-<span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">ceil</span></span>(v+self.added_chance_to_all_on_kill_events)}) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> self.chances[k] = chanceList({<span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">ceil</span></span>(v)}, {<span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-number"><span class="hljs-number">100</span></span>-<span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">ceil</span></span>(v)}) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Increased ASPD due to added ammunition </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This skill is the conversion of a part of one parameter to another. </font><font style="vertical-align: inherit;">In this case, we take all the increases of the Ammo resource and add them as an additional attack speed. </font><font style="vertical-align: inherit;">We can do this with this formula:</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-keyword"><span class="hljs-keyword">local</span></span> ammo_increases = self.max_ammo - <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> ammo_to_aspd = <span class="hljs-number"><span class="hljs-number">30</span></span> aspd_multiplier:increase((ammo_to_aspd/<span class="hljs-number"><span class="hljs-number">100</span></span>)*ammo_increases)</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It means that if, say, the maximum stock is 130 ammunition, and </font></font><code>ammo_to_aspd</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">has a conversion ratio of 30%, then as a result we will increase the attack speed by 0.3 * 30 = 9%. </font><font style="vertical-align: inherit;">If the maximum is 250 ammunition, then with the same conversion percentage we will get 1.5 * 30 = 45%. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To accomplish this, we first define an attribute:</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Player:new</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span></span> ... <span class="hljs-comment"><span class="hljs-comment">-- Conversions self.ammo_to_aspd = 0 end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And then we can apply the transform to the variable </font></font><code>aspd_multiplier</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Since this variable is </font></font><code>Stat</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, we need to do this in a function </font></font><code>update</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">If this variable were ordinary, we would do it in a function </font></font><code>setStats</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Player:update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dt)</span></span></span></span> ... <span class="hljs-comment"><span class="hljs-comment">-- Conversions if self.ammo_to_aspd &gt; 0 then self.aspd_multiplier:increase((self.ammo_to_aspd/100)*(self.max_ammo - 100)) end self.aspd_multiplier:update(dt) ... end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> And this should work exactly as we intended. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Recent passive skills </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We need to realize only about 20 passive skills. </font><font style="vertical-align: inherit;">Most of them are quite trivial, so I will leave them for the exercises. </font><font style="vertical-align: inherit;">In fact, they have almost nothing to do with most of the skills that we have implemented before, so although they may be trivial, you can consider them as tasks with which you can check if you really understand what is happening and how in the code base. </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">196. (CONTENT)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Implement a passive skill </font></font><code>change_attack_periodically</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that changes a player's attack every 10 seconds. </font><font style="vertical-align: inherit;">New attack is chosen randomly. </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">197. (CONTENT)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Implement a passive skill </font></font><code>gain_sp_on_death</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that gives the player after death 20 SP. </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">198. (CONTENT)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Implement a passive skill</font></font><code>convert_hp_to_sp_if_hp_full</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">which gives the player 3 SP every time he picks up a HP resource, and his HP is already at its maximum. </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">199. (CONTENT)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Implement a passive skill </font></font><code>mvspd_to_aspd</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that adds an increase in movement speed to attack speed. This increase should be added using the same formula that is used for </font></font><code>ammo_to_aspd</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. That is, if a player has an increase in MVSPD by 30%, and </font></font><code>mvspd_to_aspd</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is equal to 30 (that is, the conversion rate is 30%), then his ASPD should be increased by 9%. </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">200. (CONTENT)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Implement a passive skill </font></font><code>mvspd_to_hp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that adds a decrease in movement speed to the player's HP. For example, if the MVSPD is reduced by 30%, and </font></font><code>mvspd_to_hp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">equal to 30 (that is, the conversion coefficient is equal to 30%), then it should add 21 HP. </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">201. (CONTENT)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Implement a passive skill </font></font><code>mvspd_to_pspd</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that adds an increase in movement speed to the speed of projectiles. It works exactly the same as </font></font><code>mvspd_to_aspd</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">202. (CONTENT)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Implement a passive skill </font></font><code>no_boost</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that disables the acceleration of the player Boost (max_boost = 0). </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">203. (CONTENT)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Implement a passive skill </font></font><code>half_ammo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that halves a player‚Äôs ammunition. </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">204. (CONTENT)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Implement a passive skill </font></font><code>half_hp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that halves a player's HP. </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">205. (CONTENT)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Implement a passive skill </font></font><code>deals_damage_while_invulnerable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that allows the player to inflict damage on enemies when they are invulnerable (for example, when the attribute </font></font><code>invincible</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is true </font><font style="vertical-align: inherit;">after it hits </font><font style="vertical-align: inherit;">). </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">206. (CONTENT)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Implement a passive skill </font></font><code>refill_ammo_if_hp_full</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that fully restores a player‚Äôs ammunition if he selects a HP resource at full scale HP. </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">207. (CONTENT)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Implement a passive skill </font></font><code>refill_boost_if_hp_full</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that fully restores the player's Boost when he selects a HP resource at HP full scale. </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">208. (CONTENT)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Implement a passive skill </font></font><code>only_spawn_boost</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that makes so that the only resources created are Boost. </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">209. (CONTENT)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Implement a passive skill </font></font><code>only_spawn_attack</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that makes it so that for a given period of time does not create any resources other than attacks. This means that all attacks are created after a pause in resources, as well as an attack's own pause (that is, every 16 seconds, as well as every 30 seconds). </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">210. (CONTENT)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Implement a passive skill </font></font><code>no_ammo_drop</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, in which the enemies never drop ammunition. </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">211. (CONTENT)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Implement a passive skill </font></font><code>infinite_ammo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in which no player‚Äôs attacks consume ammunition. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And on this we will end up with passive skills. In total, we considered about 150 different passive skills, which in the skill tree will stretch by about 900 knots, since many of these skills are simply parameter changes, and can be scattered throughout the tree, rather than concentrated in one place.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But before we proceed to the tree (which we will look at in the next part of the article), we can slightly expand the content and implement all the player‚Äôs ships and all enemies. </font><font style="vertical-align: inherit;">You can not fully follow my examples, which I will give in the exercises, and create your own ships / enemies.</font></font><br><br><h3>  The enemies </h3><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">212. (CONTENT)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Implement the enemy </font></font><code>BigRock</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">This enemy behaves in the same way as </font></font><code>Rock</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, only he more and after death is divided into 4 objects </font></font><code>Rock</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">By default, it has 300 HP.</font></font><br><br><div class="spoiler">  <b class="spoiler_title">Gif</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a98/93c/45e/a9893c45ebcc76c51794edb1669b773e.gif"></div></div></div><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">213. (CONTENT)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Realize the enemy </font></font><code>Waver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">This enemy behaves like a wave projectile and occasionally shoots projectiles from the front and rear (like the Back attack). </font><font style="vertical-align: inherit;">By default, it has 70 HP.</font></font><br><br><div class="spoiler">  <b class="spoiler_title">Gif</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0ae/70f/f0c/0ae70ff0cc5274957df83ff2e996e4c6.gif"></div></div></div><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">214. (CONTENT)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Realize the enemy </font></font><code>Seeker</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">This enemy behaves like an Ammo object and moves slowly in the direction of the player. </font><font style="vertical-align: inherit;">With constant time intervals, this enemy also lays mines just like mine shells. </font><font style="vertical-align: inherit;">By default, it has 200 HP.</font></font><br><br><div class="spoiler">  <b class="spoiler_title">Gif</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/298/9ba/0ad/2989ba0ad9d1ed8eb4c1c1c1317b0609.gif"></div></div></div><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">215. (CONTENT)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Realize the enemy </font></font><code>Orbitter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">This enemy behaves like Rock or BigRock, but around it there is a shield of shells. </font><font style="vertical-align: inherit;">These shells behave like shells-shields, which we implemented in the previous part of the article. </font><font style="vertical-align: inherit;">If the Orbitter dies before the death of its projectiles, then the remaining projectiles homing at the player for a short period of time. </font><font style="vertical-align: inherit;">By default, it has 450 HP.</font></font><br><br><div class="spoiler">  <b class="spoiler_title">Gif</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/315/070/2cd/3150702cd73211737d44e5c74823f0b4.gif"></div></div></div><br><h3>  Ships </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We have already considered the graphics of all the ships in one of the previous parts of the tutorial, which was also implemented in the exercises. </font><font style="vertical-align: inherit;">So we will assume that you have already done them, and also that they have names and everything else. </font><font style="vertical-align: inherit;">In the following exercises we will use those created by me, but since we have implemented most of the used passive skills in the previous and current parts of the article, you can create your own ships to your taste. </font><font style="vertical-align: inherit;">I will give an example of those who came up with himself. </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">216. (CONTENT)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Implement the ship </font></font><code>Crusader</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><div class="spoiler">  <b class="spoiler_title">Gif</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/597/31a/dca/59731adca8565230c70581f32db69266.gif"></div></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> It has the following parameters: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Boost = 80 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Boost efficiency factor = 2 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Motion speed multiplier = 0.6 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Turn speed factor = 0.5 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Attack speed multiplier = 0.66 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Projectile speed multiplier = 1.5 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> HP = 150 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Size multiplier = 1.5 </font></font></li></ul><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">217. (CONTENT)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Implement the ship </font></font><code>Rogue</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><div class="spoiler">  <b class="spoiler_title">Gif</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/887/508/342/88750834257e8924d1202c64efacd9ab.gif"></div></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> It has the following parameters: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Boost = 120 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Recharge factor Boost = 1.5 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Speed ‚Äã‚Äãmultiplier = 1.3 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ammo = 120 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Attack speed multiplier = 1.25 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> HP = 80 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Invulnerability multiplier = 0.5 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Size multiplier = 0.9 </font></font></li></ul><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">218. (CONTENT)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Implement the ship </font></font><code>Bit Hunter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><div class="spoiler">  <b class="spoiler_title">Gif</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4ff/414/7c8/4ff4147c87e44223bab0dfb5bbf80ba2.gif"></div></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> It has the following parameters: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Speed ‚Äã‚Äãmultiplier = 0.9 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Turn speed multiplier = 0.9 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ammo = 80 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Attack speed multiplier = 0.8 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Projectile speed multiplier = 0.9 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Invulnerability multiplier = 1.5 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Size multiplier = 1.1 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Luck multiplier = 1.5 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Resource creation frequency multiplier = 1.5 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The frequency of the creation of enemies = 1.5 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cycle speed multiplier = 1.25 </font></font></li></ul><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">219. (CONTENT)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Implement the ship </font></font><code>Sentinel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><div class="spoiler">  <b class="spoiler_title">Gif</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4ae/d17/25f/4aed1725fa57c8b63f9bd42d4b93b674.gif"></div></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> It has the following parameters: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Energy shield = true </font></font></li></ul><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">220. (CONTENT)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Implement the ship </font></font><code>Striker</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><div class="spoiler">  <b class="spoiler_title">Gif</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7f7/eaf/8e0/7f7eaf8e0467c016ff16b70e8ec611ce.gif"></div></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> It has the following parameters: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ammo = 120 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Attack speed multiplier = 2 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Projectile speed multiplier = 1.25 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> HP = 50 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Extra line rounds = 8 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The probability of firing a shot at a kill = 10% </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The probability of a shot by the queue at a cycle = 10% </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Barrage Nova = true </font></font></li></ul><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">221. (CONTENT)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Implement the ship </font></font><code>Nuclear</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><div class="spoiler">  <b class="spoiler_title">Gif</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e64/e23/5e2/e64e235e2bf28c9f54ba4e99da8cff3c.gif"></div></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> It has the following parameters: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Boost = 80 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Turn speed multiplier = 0.8 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ammo = 80 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Attack speed multiplier = 0.85 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> HP = 80 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Invulnerability multiplier = 2 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Luck multiplier = 1.5 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Resource creation frequency multiplier = 1.5 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The frequency of the creation of enemies = 1.5 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cycle speed multiplier = 1.5 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The probability of a player exploding during a cycle = 10% </font></font></li></ul><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">222. (CONTENT)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Implement the ship </font></font><code>Cycler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><div class="spoiler">  <b class="spoiler_title">Gif</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e70/72d/15f/e7072d15f1db5b259cabad5a77d8e631.gif"></div></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> It has the following parameters: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cycle speed multiplier = 2 </font></font></li></ul><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">223. (CONTENT)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Implement the ship </font></font><code>Wisp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><div class="spoiler">  <b class="spoiler_title">Gif</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/261/f44/9dd/261f449dd883dac4e709ad7879c0571e.gif"></div></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> It has the following parameters: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Boost = 50 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Speed ‚Äã‚Äãmultiplier = 0.5 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Turn speed factor = 0.5 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Attack speed multiplier = 0.66 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Projectile speed multiplier = 0.5 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> HP = 50 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Size multiplier = 0.75 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Resource creation frequency multiplier = 1.5 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The frequency of the creation of enemies = 1.5 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Shield probability = 100% </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Projectiles lifespan multiplier = 1.5 </font></font></li></ul><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> END </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And on this we finished the implementation of all the content of the game. In the last two parts of the article there were a lot of exercises, mainly related to adding content manually. To some it may seem very boring, so this work is a good indicator of whether you like the implementation of such content. Most of the development of the game is to simply add such elements, so if you don‚Äôt like it at all, then it‚Äôs better to know about it sooner than later.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the next section, we will look at a skill tree, in which the player will display all these passive skills. </font><font style="vertical-align: inherit;">We will focus on creating all the skills necessary for the work of the tree, but creating the tree itself (for example, placing and connecting nodes) will remain entirely your task. </font><font style="vertical-align: inherit;">This is another one of those moments when we simply manually add content to the game and do not do anything particularly complicated.</font></font><br><br><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> If you like this series of tutorials, then you can stimulate me to write something similar in the future: </font></font><br><br><ul><li> <a href="http://store.steampowered.com/app/760330/BYTEPATH/" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BYTEPATH game on Steam</font></font></a> </li><li> <a href="https://ssygen.itch.io/bytepath-tutorial" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BYTEPATH tutorial on itch.io</font></font></a> </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> By purchasing a tutorial on itch.io, you will have access to the complete source code of the game, answers to the exercises from parts 1-9, the code broken into parts of the tutorial (the code will look like it should look at the end of each part) and the key games on Steam. </font></font></div><p>Source: <a href="https://habr.com/ru/post/352462/">https://habr.com/ru/post/352462/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../352450/index.html">The history of the mobile Internet: 1991 - our days</a></li>
<li><a href="../352452/index.html">How to become a frontend developer in 2018</a></li>
<li><a href="../352454/index.html">Issue # 16: IT training - current issues and challenges from leading companies</a></li>
<li><a href="../352456/index.html">Belarus: blockchain and crypt regulation</a></li>
<li><a href="../352460/index.html">Decreasing Confidence in Symantec PKI: Recommendations to Site Owners</a></li>
<li><a href="../352464/index.html">19 corporations that use blockchain technology and distributed registries</a></li>
<li><a href="../352466/index.html">On the application of reflection in testing and not only</a></li>
<li><a href="../352468/index.html">What if you need to create an innovative product in a traditional company?</a></li>
<li><a href="../352478/index.html">The patient is more alive than dead or Rumors of the death of Windows sluices are somewhat exaggerated.</a></li>
<li><a href="../352480/index.html">3 common design mistakes that are easy to fix</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>