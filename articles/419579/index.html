<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>The implementation of the in operator in C ++</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello! Today I hope to show you some magic. My hobby is inventing all sorts of seemingly impossible pieces in C ++, which helps me in learning all sor...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>The implementation of the in operator in C ++</h1><div class="post__text post__text-html js-mediator-article">  Hello!  Today I hope to show you some magic.  My hobby is inventing all sorts of seemingly impossible pieces in C ++, which helps me in learning all sorts of subtleties of the language or just have fun.  The in operator is available in several languages, for example, Python, JS.  But in C ++ it was not delivered, but sometimes you want it to be, so why not implement it. <br><br><pre><code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unordered_map</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; some_map = { { <span class="hljs-string"><span class="hljs-string">"black"</span></span>, <span class="hljs-string"><span class="hljs-string">"white"</span></span> }, { <span class="hljs-string"><span class="hljs-string">"cat"</span></span>, <span class="hljs-string"><span class="hljs-string">"dog"</span></span> }, { <span class="hljs-string"><span class="hljs-string">"day"</span></span>, <span class="hljs-string"><span class="hljs-string">"night"</span></span> } }; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> res = <span class="hljs-string"><span class="hljs-string">"cat"</span></span> in some_map) { res-&gt;second = <span class="hljs-string"><span class="hljs-string">"fish"</span></span>; }</code> </pre> <br><a name="habracut"></a><br>  How should the operator work, I suppose obviously.  It takes the left object and checks whether there is an occurrence of this object in the object specified on the right, which does not have to be a collection.  It goes without saying that there is no universal solution, just as there is no universal solution for other operators, and therefore it was possible to overload them.  Consequently, the in operator also needs to implement a similar mechanism. <br><br>  Overload will look like this. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator_in</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; key, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">unordered_map</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;&amp; data)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> data.find(key) != data.end(); }</code> </pre><br>  I think the idea is clear, the expression of the form. <br><br><pre> <code class="cpp hljs"> <span class="hljs-string"><span class="hljs-string">"some string"</span></span> in some_map</code> </pre><br>  It should turn into a function call. <br><br><pre> <code class="cpp hljs"> operator_in(<span class="hljs-string"><span class="hljs-string">"some string"</span></span>, some_map)</code> </pre><br>  Implementing this mechanism is quite simple, using existing opportunities for operator overloading.  The in operator itself is essentially a macro that does multiplication. <br><br><pre> <code class="cpp hljs"> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> in *OP_IN_HELP{}*</span></span></code> </pre><br>  In this case, <b>OP_IN_HELP</b> is an empty class and only serves us to select the correct overload. <br><br><pre> <code class="cpp hljs"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OP_IN_HELP</span></span></span><span class="hljs-class"> {</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TIn</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OP_IN_LVAL</span></span></span><span class="hljs-class">&lt;TIn&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">operator</span></span></span><span class="hljs-class">*(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TIn</span></span></span><span class="hljs-class">&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">data</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OP_IN_HELP</span></span></span><span class="hljs-class">&amp;) {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> OP_IN_LVAL&lt;TIn&gt;(data); }</code> </pre><br>  The operator is a template that allows you to take any type as the first argument.  Now we need to somehow get the right object, without losing the left.  To do this, we will implement the class <b>OP_IN_LVAL</b> which will store our left object. <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TIn</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OP_IN_LVAL</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> TIn&amp; m_in; OP_IN_LVAL(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> TIn&amp; val) : m_in(val) {}; };</code> </pre><br>  Since the object itself will be alive while the expression is executed, there is nothing to worry about if we keep a constant reference to this object.  Now we just have to implement the internal multiplication operator, which will return the result of the overloaded operator in, it will by itself be a template. <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TIn</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OP_IN_LVAL</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> TIn&amp; m_in; OP_IN_LVAL(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> TIn&amp; val) : m_in(val) {}; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TWhat</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bool</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">operator</span></span></span><span class="hljs-class">*(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TWhat</span></span></span><span class="hljs-class">&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">what</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> operator_in(m_in, what); } };</code> </pre><br>  Actually this decision will already work, but it is limited and will not allow us to write like that. <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> res = <span class="hljs-string"><span class="hljs-string">"true"</span></span> in some_map) { res-&gt;second = <span class="hljs-string"><span class="hljs-string">"false"</span></span>; }</code> </pre><br>  In order for us to have such an opportunity, we need to return the return value of the overloaded operator.  There are two versions of how to do this, one uses the capabilities of c ++ 14, a friend works within the framework of c ++ 11. <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TIn</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OP_IN_LVAL</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> TIn&amp; m_in; OP_IN_LVAL(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> TIn&amp; val) :m_in(val) {}; <span class="hljs-comment"><span class="hljs-comment">//   C++14 template&lt;class TWhat&gt; auto operator*(const TWhat&amp; what) const { return operator_in(m_in, what); } //   C++11 template&lt;class TWhat&gt; auto operator*(const TWhat&amp; what) const -&gt; decltype(operator_in(m_in, what)) { return operator_in(m_in, what); } //       //       template&lt;class TWhat&gt; auto operator*(TWhat&amp; what) const -&gt; decltype(operator_in(m_in, what)) { return operator_in(m_in, what); } };</span></span></code> </pre><br>  Since I mainly work in Visual Studio 2013, I am limited to C ++ 11, and the C ++ 11 solution will also work successfully in C ++ 14, so I advise you to choose it. <br><br>  An example implementation of a generic in operator for unordered_map. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TIterator</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OpInResult</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> m_result; TIterator m_iter; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: OpInResult(<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> result, TIterator&amp; iter) : m_result(result), m_iter(iter) {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">operator</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bool</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_result; } TIterator&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>-&gt;() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_iter; } <span class="hljs-function"><span class="hljs-function">TIterator&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">data</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_iter; } }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TKey</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TVal</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">auto</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">operator_in</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TKey</span></span></span><span class="hljs-class">&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">key</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:<span class="hljs-built_in"><span class="hljs-built_in">unordered_map</span></span>&lt;TKey, TVal&gt;&amp; data) -&gt; OpInResult&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unordered_map</span></span>&lt;TKey, TVal&gt;::iterator&gt; { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> iter = data.find(key); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> OpInResult&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unordered_map</span></span>&lt;TKey, TVal&gt;::iterator&gt;(iter != data.end(), iter); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TKey</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TVal</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">auto</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">operator_in</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">char</span></span></span><span class="hljs-class">* </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">key</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:<span class="hljs-built_in"><span class="hljs-built_in">unordered_map</span></span>&lt;TKey, TVal&gt;&amp; data) -&gt; OpInResult&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unordered_map</span></span>&lt;TKey, TVal&gt;::iterator&gt; { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> iter = data.find(key); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> OpInResult&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unordered_map</span></span>&lt;TKey, TVal&gt;::iterator&gt;(iter != data.end(), iter); }</code> </pre><br>  The <b>OpInResult</b> class allows <b>you</b> to override the cast operator, which allows us to use it in if.  It also overrides the switch operator, which allows you to mask yourself as an iterator that returns unordered_map.find (). <br><br>  An example can be found here <a href="http://cpp.sh/7rfdw">cpp.sh/7rfdw</a> <br><br>  I would also like to say about some features of this solution. <br>  Visual Studio instantiates the template at the place of use, which means that the overload function itself must be declared before the place where the operator is used, but can be declared after the <b>OP_IN_LVAL</b> class <b>declaration</b> .  GCC, in turn, instantiates the template at the declaration location (when it encounters usage itself), which means that the overloaded statement must be declared before the <b>OP_IN_LVAL</b> class is <b>declared</b> .  If it is not quite clear what this is about, then here is an example.  <a href="http://cpp.sh/5jxcq">cpp.sh/5jxcq</a> In this code, I just transferred the overload of the operator in below the declaration of the class <b>OP_IN_LVAL</b> and it stopped compiling in GCC (unless compiled with the -fpermissive flag), but successfully compiled in Visual Studio. <br><br>  In C ++ 17, it was possible to write like this. <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> res = some_map.find(<span class="hljs-string"><span class="hljs-string">"true"</span></span>); res != some_map.end()) { res-&gt;second = <span class="hljs-string"><span class="hljs-string">"false"</span></span>; }</code> </pre><br>  But it seems to me the construction of the form <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> res = <span class="hljs-string"><span class="hljs-string">"true"</span></span> in some_map) { res-&gt;second = <span class="hljs-string"><span class="hljs-string">"false"</span></span>; }</code> </pre><br>  Looks nicer. <br><br>  More examples of overloads can be seen here <a href="https://github.com/ChaosOptima/operator_in">github.com/ChaosOptima/operator_in</a> <br><br>  On the basis of the implementation principle of this operator, it‚Äôs also easy <br>  and other operators and expressions, for example. <br><br><pre> <code class="cpp hljs"> negative = FROM some_vector WHERE [](<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x){<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>;};</code> </pre><br><div class="spoiler">  <b class="spoiler_title">PS</b> <div class="spoiler_text">  I would like to know if you are interested in such topics, does it make sense to write about it here?  And would you like to know how to implement other interesting things? <br><br>  null-conditional operator <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> result = $<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> some_ptr $-&gt;func1()$-&gt;func2()$-&gt;func3(<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">11</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>)$endif;</code> </pre><br>  patern matching <br><br><pre> <code class="cpp hljs"> succes = patern_match val with_type(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x) { <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"some int "</span></span> &lt;&lt; x &lt;&lt; <span class="hljs-string"><span class="hljs-string">'\n'</span></span>; } with_cast(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;&amp; items) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp;&amp; val : items) <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; val &lt;&lt; <span class="hljs-string"><span class="hljs-string">' '</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">'\n'</span></span>; } with(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>()) [&amp;](<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&amp;) { <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"empty string\n"</span></span>; } with(oneof&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt;(<span class="hljs-string"><span class="hljs-string">"one"</span></span>, <span class="hljs-string"><span class="hljs-string">"two"</span></span>, <span class="hljs-string"><span class="hljs-string">"three"</span></span>)) [&amp;](<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&amp; value) { <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; value &lt;&lt; <span class="hljs-string"><span class="hljs-string">"\n"</span></span>; } with_cast(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&amp; str) { <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"some str "</span></span> &lt;&lt; str &lt;&lt; <span class="hljs-string"><span class="hljs-string">'\n'</span></span>; } at_default { <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"no match"</span></span>; };</code> </pre><br>  string enum <br><br><pre> <code class="cpp hljs"> StringEnum Power $def ( POW0, POW1, POW2 = POW1 * <span class="hljs-number"><span class="hljs-number">2</span></span>, POW3, POW4 = POW3 + <span class="hljs-number"><span class="hljs-number">1</span></span>, POW8 = POW4 * <span class="hljs-number"><span class="hljs-number">2</span></span>, POW9, POW10 ); to_string(Power::POW0) from_string&lt;Power&gt;(<span class="hljs-string"><span class="hljs-string">"POW0"</span></span>)</code> </pre><br></div></div></div><p>Source: <a href="https://habr.com/ru/post/419579/">https://habr.com/ru/post/419579/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../419569/index.html">Slurm: activity videos and organizational packs</a></li>
<li><a href="../419571/index.html">Position is great, but they keep planting for reposts</a></li>
<li><a href="../419573/index.html">Space Tourism Experience</a></li>
<li><a href="../419575/index.html">After the requirement to specify the exact connection speed, UK providers reduced advertising figures by an average of 41%</a></li>
<li><a href="../419577/index.html">Design of familiar things: how to improve the interface on the example of YouTube</a></li>
<li><a href="../419581/index.html">What non-commercial projects are interesting Y Combinator</a></li>
<li><a href="../419583/index.html">1998‚Äì2008: ten years that Russia has been stepping out of step with the West all the time, until broadband Internet equates everyone</a></li>
<li><a href="../419585/index.html">PWA is easy. Hello Habr</a></li>
<li><a href="../419587/index.html">Contests that change the world. 1567 - 2035</a></li>
<li><a href="../419589/index.html">Use AMP as a general purpose library for creating fast dynamic sites.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>