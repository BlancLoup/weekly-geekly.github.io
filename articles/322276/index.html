<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Myths about the CAP theorem</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 





 I have long wanted to write about the myths about the CAP theorem, but somehow everyone did not reach out. However, after reading ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Myths about the CAP theorem</h1><div class="post__text post__text-html js-mediator-article"><h2 id="vvedenie">  Introduction </h2><br><p><img src="https://habrastorage.org/files/45b/9a6/7ec/45b9a67ece014586a89eaf5dc3e1b6c5.png" alt="cap"></p><br><p>  I have long wanted to write about the myths about the CAP theorem, but somehow everyone did not reach out.  However, after reading <a href="https://cloud.google.com/spanner/docs/whitepapers/SpannerAndCap.pdf">another opus</a> , I grabbed my head and decided to sort it all out so that a slender picture appeared in my brain. </p><br><p>  An event when an article causes a storm of emotions is extremely rare.  The first time this happened when I read about chained replication.  They tried to convince me that this is a powerful approach and that this is the best thing that could happen with consistent replication.  I‚Äôll not argue now why this is not working well, but I‚Äôll just give a talking quotation from the article <a href="https://github.com/basho/machi/blob/master/doc/high-level-chain-mgr.pdf">Chain Replication metadata management</a> : </p><br><blockquote>  Split brain management is a thorny problem.  The method presented here is one based on pragmatics.  If it doesn‚Äôt work, it‚Äôs not a serious worry.  If you end up falling back then ‚Äúuse Riak Ensemble‚Äù or ‚Äúuse ZooKeeper‚Äù, then perhaps that's fine enough. </blockquote><p>  In my free retelling, this means something like the following: "We have a certain algorithm here. We do not know whether it will work correctly or not. Yes, it doesn‚Äôt matter to us."  At least honestly, saved a lot of time, thanks to the authors. </p><br><p>  And here, then, comes across an article: <a href="https://cloud.google.com/spanner/docs/whitepapers/SpannerAndCap.pdf">Spanner, TrueTime &amp; The CAP Theorem</a> .  We will sort it out towards the end, armed with concepts and knowledge.  And before that we analyze the most common myths associated with the CAP theorem. </p><br><a name="habracut"></a><br><h2 id="mif-1-a-oznachaet-dostupnost">  Myth 1: A means accessibility. </h2><br><p>  A, of course, comes from the word Availability, which means accessibility.  But what is accessibility?  What kind of? </p><br><p>  Accessibility in different contexts means different.  And here we must distinguish at least 2 different contexts in which it is used: </p><br><ol><li>  Availability of real service.  This availability is expressed as a percentage: the total downtime during the year is measured and a ratio is compiled, expressed as a percentage, indicating the probability of availability over a long time. </li><li>  Accessibility as part of the CAP theorem model. </li></ol><br><p>  <a href="http://www.glassbeam.com/sites/all/themes/glassbeam/images/blog/10.1.1.67.6951.pdf">The CAP theorem</a> uses the concept that is closest in meaning to the term total availability: </p><br><blockquote>  The system should be followed up. </blockquote><p>  Which means something like the following: "any non-fallen node in the system must respond to the request."  There are several points in this definition that I would like to emphasize: </p><br><ol><li>  "Neupavshaya".  It is clear that the fallen node can not answer.  However, the catch is that if all the nodes have fallen, then from the point of view of the definition such service is available.  In principle, the definition can be corrected by adding to the fact that the client should receive an answer. </li><li>  "Must answer."  The theorem does not say exactly when.  She is not interested in time parameters at all.  It is clear that the node can not respond instantly.  And if it cannot, then it is enough that it once answered. </li></ol><br><p>  From the user's point of view, if we had 100 nodes and 99 fell, and the remaining one continues to respond at a rate of one request per hour, then such a service can hardly be called accessible (this is context 1).  However, from the point of view of the CAP theorem, everything is normal here and such a system will be accessible (context 2). </p><br><p>  Therefore, A is not accessibility in the generally accepted sense, but the so-called <em>full accessibility</em> , which the user may be completely uninteresting. </p><br><h2 id="mif-2-p-oznachaet-ustoychivost-k-setevomu-razdeleniyu">  Myth 2: P stands for network separation resistance. </h2><br><p>  Such a definition can be found in almost all articles.  To understand what is wrong here, you need to look at the problem from a different angle. </p><br><p>  Take any system that exchanges messages.  Consider how messages are transmitted between the actors - the objects of the system.  These messages can either reach another actor or not.  And here it is necessary to distinguish 2 cases: </p><br><ol><li>  In the system, the situation when messages are lost is impossible. </li><li>  In the system, it is possible that messages are lost. </li></ol><br><p>  It is not difficult to guess that this list is exhaustive.  In this place it is worth paying attention that each item describes the properties of the system.  Those.  we haven't even gotten to the algorithm yet.  This will have far-reaching consequences. </p><br><p>  If we consider the first case, when messages are never lost, it means that in such a situation network split is simply impossible.  Indeed, since each message from each actor can reach without loss, there is no point in talking about <em>network sharing</em> .  In the second case, the opposite is true: due to losses, a situation is possible when a whole segment is separated from another, i.e.  there was a loss of connectivity between the group of actors.  In this case, it is said that <em>network sharing has</em> happened. </p><br><p>  It should be noted that the property of the possibility of isolation of groups of actors from each other is a direct consequence of the implementation of paragraph 2. </p><br><p>  If we work with a real network, then, as it is not difficult to guess, falls under the 2nd item.  At the same time, we have not yet begun to think about the algorithm, and we already have the ability to separate and lose connectivity between groups of actors.  P - about this, that splitting is possible in the system.  And this is not a property of the algorithm, but a property of the system in which the algorithm operates. </p><br><p>  Why, in general, in the case of the loss of messages is it important to consider the <em>network division</em> ?  Because the rest of the problems do not cause so much trouble and problems as the splitting of the system into independent parts. </p><br><p>  To conclude this myth, I will quote from the blog <a href="https://aphyr.com/posts/328-jepsen-percona-xtradb-cluster">Aphyr: Percona XtraDB Cluster</a> : </p><br><blockquote>  Partition tolerance doesn‚Äôt require available to handle requests.  It just means that partitions may occur.  If you deploy on a typical IP network, partitions will occur;  partition tolerance in these environments is not optional. </blockquote><p>  Thus, if we consider a system that works with a real unreliable network, then network connectivity violations are not an exceptional situation, but something to deal with.  And the letter P in this context only means that the system may have a network connectivity violation. </p><br><h2 id="mif-3-sistem-ac-ne-suschestvuet">  Myth 3: AC systems do not exist </h2><br><p>  From the previous myth, there may be a feeling that AC systems do not exist, because  there are no reliable networks capable of transmitting data.  You can immediately try to offer a scheme with redundancy components.  However, if the probability of packet loss in a line is&gt; 0, then no matter how we add channels, the probability cannot become = 0 purely from mathematical considerations.  And if so, then, as described above, there may be <em>network split</em> (network split). </p><br><p>  But who said that CAP only describes network-connected systems?  CAP is a theoretical model that can be applied to a very wide class of problems.  For example, you can take a multi-core processor: </p><br><ol><li>  Each core is a separate actor. </li><li>  Actors (kernels) exchange messages (information). </li></ol><br><p>  This is enough to talk about the CAP theorem. </p><br><p>  Let's first discuss A. Are there kernels available?  Of course, yes, at any point in time, you can access any kernel and retrieve any data we want from memory. </p><br><p>  What about P?  The processor ensures that the data will be transferred without problems to another kernel if necessary.  If this for some reason does not happen, then this processor is considered defective.  Thus, the letter P is absent. </p><br><p>  The issue with consistency is also solved as follows.  The memory model is defined by <em>sequential consistency</em> , which is the highest level of consistency in such a system.  At the same time, inside the processor, as a rule, cache coherence protocols like MESI or MOESI are implemented, thus ensuring a given level of consistency. </p><br><p>  Thus, a modern processor is an AC system with guaranteed message delivery between cores. </p><br><h2 id="mif-4-c-oznachaet-konsistentnost">  Myth 4: C stands for consistency. </h2><br><p>  C no doubt means consistency.  However, what consistency?  After all, eventual consistency is also consistency, only extremely weak.  So what is meant here?  There are a lot of consistency models, just look at the diagram from the article <a href="https://arxiv.org/pdf/1512.00168.pdf">Consistency in Non-Transactional Distributed Storage Systems</a> : </p><br><p><img src="https://habrastorage.org/files/977/b31/c5c/977b31c5c6d04fc6a3911c0bb27dd5cc.png" alt="Distributed Consistencies"></p><br><p>  And this is only about distributed non-transactional systems!  If we add <a href="https://www.ics.forth.gr/tech-reports/2013/2013.TR439_Survey_on_Consistency_Conditions.pdf">transactionality to our consideration</a> , we can immediately bury the idea of ‚Äã‚Äãsorting this out without ever starting. </p><br><p>  In the original article about the CAP theorem, we talked everywhere about linearizability.  The essence of linearizability, in short, is as follows.  If an action has taken place (not important, reading, writing, or a mixed action or actions), the result of this action is available immediately after we receive the answer. </p><br><p> A natural question arises: what about other consistency models?  Do they fall under the CAP theorem? </p><br><p>  And here begins a complete mess in their heads.  Some people think that since the model is proven to be linearizable, then it should be applied strictly and exclusively to linearizability.  Others think that any weaker consistency model no longer falls under this theorem.  Still others do not understand the essence of the discussion. </p><br><p>  To answer this question, consider a wonderful picture taken from the article <a href="https://arxiv.org/pdf/1302.0309.pdf">Highly Available Transactions</a> : </p><br><p><img src="https://habrastorage.org/files/f25/193/764/f25193764c84409193572cd0596982dd.png" alt="Consistencies"></p><br><p>  What is she talking about?  Red marks the so-called unavailability models that work within the framework of the CAP theorem.  Those.  simultaneously with it it is impossible to reach A and P simultaneously.  However, there are other models that have a sufficient level of consistency for a number of tasks that can nevertheless be executed simultaneously with the AP, receiving the CAP system without any discounts.  A typical example: <em>Read Committed</em> (RC) and <em>Monotonic Atomic View</em> (MAV) admit that all three letters in the CAP are respected at the same time, and it is difficult to call such models inconsistent.  Such consistency models for which the CAP-theorem is violated are called highly available models. </p><br><p>  Thus, speaking of consistency, we mean a wide group of consistency models, called <em>unavailable models</em> . </p><br><h2 id="mif-5-sistemy-cp-ne-yavlyayutsya-vysokodostupnymi">  Myth 5: CP systems are not highly available. </h2><br><p>  After the previous paragraph, this statement seems quite logical, but fundamentally wrong.  Let me remind you that A means complete accessibility, not accessibility within nines.  Is it possible to make a CP system highly available? </p><br><p>  Here it is necessary to separate the model and iron, i.e.  theory and reality. </p><br><p>  Let's reason first in the framework of the model.  Accessibility within the framework of the CAP theorem means complete availability, i.e.  Any live node must respond.  But why do you need this at all?  After all, the logic of the client, we can write a completely different way.  Suppose that we have 3 nodes located in different data centers.  We write on a quorum of 2 nodes, while 1 node can lie down without losing the vitality and consistency of the entire system.  And we always read from 2 any nodes.  Moreover, if one node is lying down, the other node will give the correct answer.  If 2 different answers come, we can choose the most recent one.  Thus, if in this system it is guaranteed that only one node can be inoperative at any time, then from the client‚Äôs point of view, the system will be fully 100% available for both reading and writing.  And consistently. </p><br><p>  In reality, there is always a non-zero probability that two or more nodes will lie down not one.  This is easy to see, because  if there is a non-zero probability of falling one node, then there will be a non-zero probability of falling another node or node.  Moreover, a fall is not the worst thing that can happen.  In addition to equipment failures, there may still be a loss of connectivity, i.e.  breakdown of various network equipment, including trunk equipment.  I think it is not worth reminding that all this has a non-zero probability.  All these probabilities add up, giving only a certain, sometimes very small number of nines.  It is clear that the greater the redundancy of nodes, the greater the number of nines can be obtained.  And this I have not yet taken into consideration the program itself, which programmers write with a non-zero probability of introducing an error ... </p><br><p>  Those.  in theory, we have that a correctly written client can achieve 100% availability, but in practice we always have a smaller number.  All science is to achieve as many nines as possible.  And in this aspect, the CAP theorem is completely useless.  Because it is generally about something else. </p><br><p>  Therefore, the idea of ‚Äã‚Äãhigh availability does not in the least contradict the fact that it is not A, which means that CP can be highly accessible. </p><br><h2 id="mif-6-sistemy-cp-obladayut-nizkoy-proizvoditelnostyu-vysokoy-latentnostyu-i-ploho-masshtabiruyutsya">  Myth 6: CP systems have low performance, high latency, and poorly scaled. </h2><br><p>  Obviously, the higher the consistency, the less productive the system.  The question arises in how much will be a drawdown in performance and whether it will be critical for our processes. </p><br><p>  It turns out that even <em>strict consistency</em> or <em>Strong-1SR</em> (the highest level of consistency) can be used in real-time systems.  I have experimental evidence of this fact, but here I will give a number of some practical arguments in favor of it. </p><br><p>  The idea is to use multiple independent fault tolerant entities.  They can be run anywhere, they work in parallel, and their number is actually limited by the size of the cluster.  A transactional layer is created on top of these entities, which binds the work of these entities together.  This is how <a href="https://static.googleusercontent.com/media/research.google.com/ru//archive/spanner-osdi2012.pdf">Spanner</a> and many other systems work.  Thus, scalability and speed are achieved. </p><br><h2 id="mif-7-sistemy-ap-legko-ispolzovat-za-schet-togo-chto-oni-horosho-masshtabiruyutsya">  Myth 7: AP systems are easy to use because they scale well. </h2><br><p>  Systems with AP allow simpler scaling, but only in theory.  In reality, all the same, one way or another, one has to solve issues of consistency.  Practice shows that to write client code based on such a system is an extremely nontrivial task, and sometimes even unattainable.  The reason is that if the system does not provide any basic guarantees for consistent data storage, then the subsequent processing turns into a very exciting charade: did the operation apply?  Will users see it?  and what will they see?  Is it possible to get a consistent data slice?  will different clients see the same data set?  etc. </p><br><p>  Those.  in spite of the relative simplicity of creating such systems, the complexity of its use increases many times. </p><br><h2 id="razbor-stati">  Parsing the article </h2><br><p>  Well, now let's proceed to the analysis of the article <a href="https://cloud.google.com/spanner/docs/whitepapers/SpannerAndCap.pdf">Spanner, TrueTime &amp; The CAP Theorem</a> .  Let's start from the beginning: </p><br><blockquote>  The CAP theorem [Bre12] says: <br><ul><li>  C: Consistency, serializability for this discussion; </li><li>  A: 100% availability, for both reads and updates; </li><li>  P: tolerance to network partitions. </li></ul><br></blockquote><p>  The first thing you should pay attention to is the link [Bre12] called <a href="https://www.infoq.com/articles/cap-twelve-years-later-how-the-rules-have-changed">CAP Twelve Years Later</a> , dated May 2012.  Why did you choose a link not to the <a href="http://www.glassbeam.com/sites/all/themes/glassbeam/images/blog/10.1.1.67.6951.pdf">original article</a> - I do not know.  Moreover, this is an article about the discussion of the CAP theorem, and not about the derivation of the theorem itself. </p><br><p>  About the letters C, A and P, we have already discussed, I will not stop.  Further: </p><br><blockquote>  Once you‚Äôre not sure, you‚Äôre willing to use it. </blockquote><p>  The first part sounds quite reasonable in our discussions, however, after AP &amp; CP is strange, because  suddenly it turns out we don‚Äôt want to make that choice.  Why we do not want to make such a choice, the article is not written.  But then the correct words were written: </p><br><blockquote>  This is a 100% availability. </blockquote><p>  It would seem that one could stop at that and say that Spanner is a CP system with an availability of 99.9 ...%, putting an end to this.  But no, the author continues to carry and he writes the subtitle: </p><br><blockquote><h2 id="spanner-claims-to-be-consistent-and-available">  Spanner claims to be consistent and available. </h2><br><br>  There are no partitions and are skeptical. </blockquote><p>  As I showed above, the so-called <em>high availability</em> (highly available) does not mean A at all, much less the absence of P. After this, the verbal balancing act begins, since  From an erroneous message, you can derive a lot of funny judgments.  The author really wants the system to be both C and A at the same time, because the user doesn‚Äôt need a word at all from P.  This introduces a new concept: <em>effectively CA.</em>  It seems that the author began to play with the concepts and began to invent new ones without any definition, since  old ones poorly described such a wonderful system. </p><br><p>  We read further: </p><br><blockquote>  This is a large number of internal users. </blockquote><p>  The phrase itself is wonderful.  It turns out that if internal users say: "we assume that it is highly accessible", then something immediately follows from here about the system itself.  Well, if users had said: "Yes, it is highly accessible," then there is generally something that they only suggest. </p><br><p>  This is followed by the enchanting: </p><br><blockquote>  If you are not a part of a spanner, then it is more accurate. </blockquote><p>  Those.  if we have a failure that is not related to the violation of network connectivity, then such a system is more precisely in a certain sense (!) should be called as CA.  Those.  if the probability of other failures is greater than a violation of connectivity, then P is not.  In this sense, should understand this phrase? </p><br><p>  The following are the marketing speculations that we have built a super-reliable system, supported by graphs.  Just below is the definition that finally reveals the meaning of the totality of the word <em>effectively CA</em> : </p><br><blockquote>  ... to claim this condition of relative probabilities: <br><ol><li>  It can be </li><li>  It is also a small fraction of those outages due to partitions. </li></ol><br><br>  Spanner meets both. </blockquote><p>  Those.  the system should: </p><br><ol><li>  to have high availability in practice, and users can ignore exceptions, and </li><li>  the probability of network separation should be less than other problems. </li></ol><br><p>  The question immediately arises: what level of high availability is sufficient in practice?  5 nines?  6 nines?  Or maybe all 9?  Here we see some arbitrariness, which does not allow one to judge unequivocally about belonging to this property.  Well, the "user ignoring exceptions" completes all the ambiguity and ambiguity of this, scary to say, definition. </p><br><p>  As can be seen, such a definition does not fall under the model, which is used directly in the CAP theorem.  There is generally not clear to which model this applies.  It is rather about experimental observations, and not about a theoretical model.  And the relationship between experiment and theory in the article can not be traced. </p><br><p>  I will not be long to paint other aspects of the article.  Let me just say that a number of paragraphs deserve to read them, for example, "What happens during a Partition". </p><br><p>  Authors finish with the following magnificent passage: </p><br><blockquote>  Spanner‚Äôs claim is that it‚Äôs always consistent and achieves greater than 5 9s availability. </blockquote><p>  Well, yes, if we determine that our system is X, then our system will have the properties of X. Great, right?  Only this definition has nothing to do with the CAP theorem.  This must be clearly understood.  The authors, apparently, really wanted to avoid P, but there were 2 other letters, since  the user pays for them.  Why they did not suit the CP with high availability - I do not know. </p><br><blockquote>  Even then outages will occur, in which case Spanner chooses consistency over availability. </blockquote><p>  What clearly contradicts the CA system: no choice is made in such a system, since  both properties are selected, as we saw above in the CA example.  The presence of such a statement says just that it is definitely not a CA.  I did not expect to see mutually exclusive paragraphs in such an article. </p><br><h2 id="mif-posledniy-cap-teorema-ustarela">  Myth of the last: CAP theorem is outdated </h2><br><p>  The popularity of this topic led to the fact that many people no longer understand the meaning of the terms, they began to blur, emasculated to a completely vulgar understanding.  Speculation on terms, redefinition and misunderstanding - this is an incomplete list of generic spots of this long-suffering theorem. </p><br><p>  In the wake of its popularity, the pendulum swung to the other side, and they began to forget a little about this theorem.  Articles began to appear about the fact that, say, the <a href="https://habrahabr.ru/post/258145/">CAP theorem is outdated</a> and <a href="https://martin.kleppmann.com/2015/05/11/please-stop-calling-databases-cp-or-ap.html">asked to stop its use</a> .  Others tried to <a href="https://www.cl.cam.ac.uk/research/dtg/www/files/publications/public/mk428/cap-critique.pdf">criticize and contribute</a> to the instillation and alteration of meanings.  Even <a href="https://cloud.google.com/spanner/docs/whitepapers/SpannerAndCap.pdf">the author of the theorem</a> begins to replace concepts and distort the original idea. </p><br><p>  Such attacks in the direction of the theorem again and again only emphasize its relevance, exposing new, hitherto unknown, faces. </p><br><h2 id="zaklyuchenie">  Conclusion </h2><br><p>  At one time, familiarity with the CAP theorem sober enough brains.  After all, the theoretical impossibility of creating a certain type of system provided grounds for not practicing the solution of unsolvable tasks in practice and concentrating on solving problems of a particular class.  In the context of distributed systems, it makes sense to talk only about the tasks of an AP or CP. </p><br><p>  Such theorems do not become obsolete, as classical mechanics cannot become obsolete, despite the presence of relativistic effects or quantum mechanics.  She just needs to find her worthy place, we must remember about her and move on.  And the whole point is that this theorem is only a special case of a more general <a href="https://dspace.mit.edu/openaccess-disseminate/1721.1/79112">fundamental property</a> : </p><br><blockquote>  It is a simple fact that you can achieve a system of unreliable distributed system. </blockquote><p>  Those.  The CAP theorem is simply one example of the fundamental fact that it is impossible to achieve both security and survivability in an unreliable distributed system. </p><br><ul><li>  C: <strong>Security</strong> </li><li>  A: <strong>Vitality</strong> </li><li>  P: <strong>Unreliable Distributed System</strong> </li></ul><br><p>  <em>Grigory Demchenko, developer of <a href="https://habrahabr.ru/company/yandex/blog/311104/">YT</a></em> </p><br><hr><br><div class="spoiler">  <b class="spoiler_title">Literature</b> <div class="spoiler_text"><p>  <a href="https://github.com/basho/machi/blob/master/doc/high-level-chain-mgr.pdf">Chain Replication metadata management in Machi, an immutable file store</a> </p><br><p>  <a href="https://cloud.google.com/spanner/docs/whitepapers/SpannerAndCap.pdf">Spanner, TrueTime &amp; The CAP Theorem</a> </p><br><p>  <a href="http://www.glassbeam.com/sites/all/themes/glassbeam/images/blog/10.1.1.67.6951.pdf">Brewer's Conjecture and the Feasibility of Consistent, Partition-Tolerant Web</a> </p><br><p>  <a href="https://aphyr.com/posts/328-jepsen-percona-xtradb-cluster">Jepsen: Percona XtraDB Cluster</a> </p><br><p>  <a href="https://arxiv.org/pdf/1512.00168.pdf">Consistency in Non-Transactional Distributed Storage Systems</a> </p><br><p>  <a href="https://www.ics.forth.gr/tech-reports/2013/2013.TR439_Survey_on_Consistency_Conditions.pdf">Survey on consistency conditions</a> </p><br><p>  <a href="https://arxiv.org/pdf/1302.0309.pdf">Highly Available Transactions: Virtues and Limitations (Extended Version)</a> </p><br><p>  <a href="https://static.googleusercontent.com/media/research.google.com/ru//archive/spanner-osdi2012.pdf">Spanner: Google's Globally-Distributed Database</a> </p><br><p>  <a href="https://www.infoq.com/articles/cap-twelve-years-later-how-the-rules-have-changed">CAP Twelve Years Later</a> </p><br><p>  <a href="https://habrahabr.ru/post/258145/">Forget the SAR theorem as no longer relevant.</a> </p><br><p>  <a href="https://martin.kleppmann.com/2015/05/11/please-stop-calling-databases-cp-or-ap.html">Please stop calling databases CP or AP</a> </p><br><p>  <a href="https://www.cl.cam.ac.uk/research/dtg/www/files/publications/public/mk428/cap-critique.pdf">A Critique of the CAP Theorem</a> </p><br><p>  <a href="https://dspace.mit.edu/openaccess-disseminate/1721.1/79112">Perspectives on the CAP Theorem</a> </p><br><p>  <a href="https://habrahabr.ru/company/yandex/blog/311104/">YT: why does Yandex need its own MapReduce-system and how it works</a> </p></div></div></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/322276/">https://habr.com/ru/post/322276/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../322266/index.html">Tarantool: load testing</a></li>
<li><a href="../322268/index.html">We write game logic in C #. Part 2/2</a></li>
<li><a href="../322270/index.html">In defense, Zuckerberg takes Evan Spiegel "by the throat"</a></li>
<li><a href="../322272/index.html">How to wind 40k views on Habrahabr. Bug or feature?</a></li>
<li><a href="../322274/index.html">Business rule repositories and corresponding code blocks that are embedded in production</a></li>
<li><a href="../322278/index.html">Web interface for your Asterisk. Statistics for call-centers, sales departments, listening to calls and much more</a></li>
<li><a href="../322280/index.html">Optimization of animations in Unity3D</a></li>
<li><a href="../322282/index.html">‚ÄúOther blogs‚Äù: Lecturers, graduates and students of the ITMO University on Habr√©</a></li>
<li><a href="../322284/index.html">5 hobbies of a real developer</a></li>
<li><a href="../322286/index.html">Advantages of the Interval Memory Method</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>