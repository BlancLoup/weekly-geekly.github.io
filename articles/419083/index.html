<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Cursor API as an alternative to standard paging</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Disadvantages of the standard paging API 
 Initially, we need to understand why the offset pagination approach is not suitable for large datasets usin...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Cursor API as an alternative to standard paging</h1><div class="post__text post__text-html js-mediator-article"><h4>  Disadvantages of the standard paging API </h4><br>  Initially, we need to understand why the offset pagination approach is not suitable for large datasets using the following example: <br><br>  The client provides two parameters - LIMIT for the expected maximum number of results and OFFSET for the page offset.  For example, with OFFSET = 400, LIMIT = 20, we return 20 items from the database, throwing out the first 400. <br><br>  Using LIMIT and OFFSET does not work well on large datasets.  As the OFFSET grows, the database still has to read the data up to OFFSET + of the required number of records from the disk, before it drops OFFSET and returns only the expected number of records. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      If the records arrive in the database at a high speed, the current window becomes unreliable for page access, potentially leading to data loss or the return of duplicates. <br><br>  The solution to this problem can be the Cursor API, after each request returning a cursor that can be used by the client when requesting the next / previous piece of data. <br><a name="habracut"></a><br><h4>  Cursor API </h4><br>  The Cursor API works by returning a certain marker in the response that refers to a dataset defined by the item.  In a subsequent request, this token is used to request results starting with the entries following the marker. <br><br>  Suppose we have the following GET REST service operation: <br><br><pre><code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">GET</span></span> /api/v1/items/<span class="hljs-keyword"><span class="hljs-keyword">in</span></span></code> </pre> <br>  For each of the returned records, we need to have a unique sequential ID, which for newly added records will matter more than all existing ones.  In some databases, this may be an existing field, for example, a numeric primary key.  In the case of using an alphanumeric primary key, an additional field, such as serial / bigserial in PostgreSQL, can act as such a sequential ID. <br><br>  The value of this ID for the last record found will be used to form the forward cursor, the ID value of the first record found will be used to form the backward cursor. <br><br><h4>  Request of the first portion of data by the client </h4><br>  When a client makes a request for the first portion of data, it uses a request of the form: <br><br><pre> <code class="hljs swift"><span class="hljs-type"><span class="hljs-type">GET</span></span> /api/v1/items/<span class="hljs-keyword"><span class="hljs-keyword">in</span></span>?someParam=...&amp;sortBy={sortingFieldName}&amp;size={<span class="hljs-built_in"><span class="hljs-built_in">count</span></span>}</code> </pre> <br>  Here, to complicate things, we added another sorting by a specific field named sortingFieldName. <br><br>  In this case, the query is executed to the database: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> items <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> ... <span class="hljs-comment"><span class="hljs-comment">-- apply search params ORDER BY :sortingFieldName, :sequentialId LIMIT :count</span></span></code> </pre> <br>  The client returns the following response: <br><br><pre> <code class="hljs objectivec">{ <span class="hljs-string"><span class="hljs-string">"elements"</span></span> : [ { <span class="hljs-string"><span class="hljs-string">"sortingFieldName"</span></span> : <span class="hljs-string"><span class="hljs-string">"John"</span></span>, <span class="hljs-string"><span class="hljs-string">"sequentialId"</span></span> : <span class="hljs-number"><span class="hljs-number">37</span></span>, ... }, { <span class="hljs-string"><span class="hljs-string">"sortingFieldName"</span></span> : <span class="hljs-string"><span class="hljs-string">"John"</span></span>, <span class="hljs-string"><span class="hljs-string">"sequentialId"</span></span> : <span class="hljs-number"><span class="hljs-number">38</span></span>, ... } ], <span class="hljs-string"><span class="hljs-string">"nextCursor"</span></span> : <span class="hljs-string"><span class="hljs-string">"eyJmaWVsZE5hbWUiOiJuYW1lIiwiZmllbGRWYWx1ZSI6IkX0="</span></span> }</code> </pre> <br>  where in nextCursor Base64 is encoded with the following content: <br><br><pre> <code class="hljs json">{ <span class="hljs-attr"><span class="hljs-attr">"fieldName"</span></span> : <span class="hljs-string"><span class="hljs-string">"sortingFieldName"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"fieldValue"</span></span> : <span class="hljs-string"><span class="hljs-string">"John"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"sequentialId"</span></span> : <span class="hljs-number"><span class="hljs-number">38</span></span>, <span class="hljs-attr"><span class="hljs-attr">"forward"</span></span> : <span class="hljs-literal"><span class="hljs-literal">true</span></span> }</code> </pre> <br>  It is easy to specify that we stopped at the sortingFieldName = John value in the previous page to form the next one - not enough, because  several subsequent entries may also have the same value of this field.  For this we need a sequential ID. <br><br>  The nextCursor field is absent in response if we have found fewer than the requested count records (so they are sure that there is no next page). <br>  (UPD: either nextCursor can be returned in any case, if the last query found any non-zero number of records, storing the information about the last record of the set found in the cursor) <br><br>  The prevCursor field is absent in response after the first request (the cursor was absent in the request) <br><br><h4>  Request for the next client data </h4><br>  When a client makes a subsequent request, it needs to use the cursor (forward or reverse) from the previous response. <br><br>  <b>Direct cursor:</b> <br><br><pre> <code class="hljs swift"><span class="hljs-type"><span class="hljs-type">GET</span></span> /api/v1/items/<span class="hljs-keyword"><span class="hljs-keyword">in</span></span>?someParam=...&amp;sortBy={sortingFieldName}&amp;size={<span class="hljs-built_in"><span class="hljs-built_in">count</span></span>}&amp; cursor=eyJmaWVsZE5hbWUiOiJuYW1lIiwiZmllbGRWYWx1ZSI6IkX0=</code> </pre> <br>  In this case, the query is executed to the database: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> items <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> ... <span class="hljs-comment"><span class="hljs-comment">-- apply search params AND ((fieldName = :nextCursor.fieldName AND sequentialId &gt; :nextCursor.sequentialId) OR fieldName &gt; :nextCursor.fieldName) ORDER BY :sortingFieldName, :sequentialId LIMIT :count</span></span></code> </pre> <br>  And the client returns the response: <br><br><pre> <code class="hljs objectivec">{ <span class="hljs-string"><span class="hljs-string">"elements"</span></span> : [ { <span class="hljs-string"><span class="hljs-string">"sortingFieldName"</span></span> : <span class="hljs-string"><span class="hljs-string">"Zeppelin"</span></span>, <span class="hljs-string"><span class="hljs-string">"sequentialId"</span></span> : <span class="hljs-number"><span class="hljs-number">39</span></span>, ... } ], <span class="hljs-string"><span class="hljs-string">"nextCursor"</span></span> : <span class="hljs-string"><span class="hljs-string">"eyJmaWVsZE5JuYW1lIiwiZmllbGRWYhbWUiOiWx1ZSI6IkFUR3Jvd"</span></span>, <span class="hljs-string"><span class="hljs-string">"prevCursor"</span></span> : <span class="hljs-string"><span class="hljs-string">"eyJmaWVsZE5hbWUiOiJuYW1lIiwiZmllbGRWYWx1ZSI6IkFUR3Jvd"</span></span> }</code> </pre> <br>  Here prevCursor is also Base64-encoded object: <br><br><pre> <code class="hljs json">{ <span class="hljs-attr"><span class="hljs-attr">"fieldName"</span></span> : <span class="hljs-string"><span class="hljs-string">"sortingFieldName"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"fieldValue"</span></span> : <span class="hljs-string"><span class="hljs-string">"Zeppelin"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"sequentialId"</span></span> : <span class="hljs-number"><span class="hljs-number">39</span></span>, <span class="hljs-attr"><span class="hljs-attr">"forward"</span></span> : <span class="hljs-literal"><span class="hljs-literal">false</span></span> }</code> </pre> <br>  <b>Reverse cursor:</b> <br><br><pre> <code class="hljs swift"><span class="hljs-type"><span class="hljs-type">GET</span></span> /api/v1/items/<span class="hljs-keyword"><span class="hljs-keyword">in</span></span>?someParam=...&amp;sortBy={sortingFieldName}&amp;size={<span class="hljs-built_in"><span class="hljs-built_in">count</span></span>}&amp; cursor=eyJmaWVsZE5hbWUiOiJuYW1lIiwiZmllbGRWYWx1ZSI6IkFUR3Jvd</code> </pre> <br>  In this case, the query is executed to the database: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> items <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> ... <span class="hljs-comment"><span class="hljs-comment">-- apply search params AND ((fieldName = :prevCursor.fieldName AND seq_id &lt; :prevCursor.sequentialId) OR fieldName &lt; :prevCursor.fieldName) ORDER BY :sortingFieldName DESC, :sequentialId DESC LIMIT :count</span></span></code> </pre> <br>  After that, we need to reverse the order of the entries as a result, in order to give them to the client with the expected order.  Respons has a similar look: <br><br><pre> <code class="hljs json">{ <span class="hljs-attr"><span class="hljs-attr">"elements"</span></span>: [...], <span class="hljs-attr"><span class="hljs-attr">"nextCursor"</span></span> : <span class="hljs-string"><span class="hljs-string">"eyJmaWVsZE5hbWUiOiJuYW1lIiwiZmllbGRWYWx1ZSI6IkFUR3JvdXAtd0ZQ"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"prevCursor"</span></span> : <span class="hljs-string"><span class="hljs-string">"eyJmaWVsZE5h4YW1lIiwiZmllbGRWYWx1ZSI6IkFUR3JvdXAtTGFtN0B1aR1l"</span></span> }</code> </pre> <br>  <b>Packing request parameters in the cursor itself</b> <br><br>  In principle, we can pack query parameters (someParam and sortBy fields) into the cursor itself, and then subsequent client requests will have a similar look for forward and backward cursors: <br><br><pre> <code class="hljs swift"><span class="hljs-type"><span class="hljs-type">GET</span></span> /api/v1/items/<span class="hljs-keyword"><span class="hljs-keyword">in</span></span>?size={<span class="hljs-built_in"><span class="hljs-built_in">count</span></span>}&amp;cursor={...}</code> </pre> <br>  And the cursor itself has the form: <br><br><pre> <code class="hljs json">{ <span class="hljs-attr"><span class="hljs-attr">"someParam"</span></span> : ..., <span class="hljs-attr"><span class="hljs-attr">"sortBy"</span></span> : ..., <span class="hljs-attr"><span class="hljs-attr">"fieldName"</span></span> : <span class="hljs-string"><span class="hljs-string">"sortingFieldName"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"fieldValue"</span></span> : <span class="hljs-string"><span class="hljs-string">"Zeppelin"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"sequentialId"</span></span> : <span class="hljs-number"><span class="hljs-number">39</span></span>, <span class="hljs-attr"><span class="hljs-attr">"forward"</span></span> : <span class="hljs-literal"><span class="hljs-literal">true</span></span>/<span class="hljs-literal"><span class="hljs-literal">false</span></span> }</code> </pre> <br><h4>  Results </h4><br>  We designed the Cursor API, representing an alternative to the standard Paging, devoid of some of its shortcomings. <br>  UPD: according to advice in comments - I add the link to <a href="https://hackernoon.com/guys-were-doing-pagination-wrong-f6c18a91b232">article</a> where the similar problem is considered. <br>  UPD2: in order not to embarrass the user by returning next / prev elements in response in cases where the next / previous page is empty in essence - the idea arose to get 2 more elements from the database - in this case, the extreme elements serve only to determine the need to return to next / prev fields (their visibility is essentially).  In this case, the user in any case receives no more than the expected size elements. </div><p>Source: <a href="https://habr.com/ru/post/419083/">https://habr.com/ru/post/419083/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../419065/index.html">Intel Virtual World. Practice</a></li>
<li><a href="../419069/index.html">Global warming will make our world more green, but you shouldn't rejoice</a></li>
<li><a href="../419071/index.html">In the wake of tp-link hacking</a></li>
<li><a href="../419075/index.html">On the formation of sequences in the Collatz hypothesis (3n + 1)</a></li>
<li><a href="../419077/index.html">Localization of applications in iOS. Part 1. What do we have?</a></li>
<li><a href="../419085/index.html">The idea of ‚Äã‚Äãa singularity before the Big Bang is outdated</a></li>
<li><a href="../419087/index.html">Understanding someone else's consciousness is a myth</a></li>
<li><a href="../419089/index.html">How to cheat when playing dice - tips game expert</a></li>
<li><a href="../419091/index.html">Radioactive items among us</a></li>
<li><a href="../419095/index.html">We write CSS better and more beautiful</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>