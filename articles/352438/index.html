<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Java Puzzlers NG S02: Wonderful and Wonderful</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Tagir Valeev ( lany ) and Baruch Sadogursky ( jbaruch ) have assembled a new collection of Java-puzzlers and are in a hurry to share them. 


 The art...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Java Puzzlers NG S02: Wonderful and Wonderful</h1><div class="post__text post__text-html js-mediator-article">  Tagir Valeev ( <a href="https://habrahabr.ru/users/lany/" class="user_link">lany</a> ) and Baruch Sadogursky ( <a href="https://habrahabr.ru/users/jbaruch/" class="user_link">jbaruch</a> ) have assembled a new collection of Java-puzzlers and are in a hurry to share them. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/hCsh60x8ZoU" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  The article is based on the decoding of their performance at the JPoint 2017 autumn conference. It shows how many riddles are hidden in Java 8 and Java 9 that barely loomed on the horizon. All of these streams, lambdas, monads, Optionals and Completable Future were added there exclusively in order to confuse us. <br><br>  Everything they talk about should work on the latest version of Java 8 and 9, respectively.  We checked - everything seems to be fair: as it is written, this is how it behaves. <br><a name="habracut"></a><br>  Just in case, a couple of words about the authors, although we think you already know them well: Baruch deals with Developer Relations at JFrog, Tagir is the developer of IntelliJ IDEA and the author of the StreamEx library. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  Java puzzle # 1: how to bank a bank </h2><br>  To warm up we ask the first puzzler: unknown American hackers are trying to bank the bank. <br><br><img src="https://habrastorage.org/webt/go/i0/wv/goi0wvruyyrywu9whmoofrgwlma.png"><br><br>  We here, in general, map banking logic to the Java Semaphore.  In the Semaphore constructor, we will have an initial balance.  We start at -42 overdraft and then we map some of Semaphore's methods to banking methods.  That is, <code>drainPermits</code> - this will ‚Äútake all the money from the bank‚Äù from us, while <code>availablePermits</code> will ‚Äúcheck the balance‚Äù. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PerfectRobbery</span></span></span><span class="hljs-class"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Semaphore bankAccount = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Semaphore(-<span class="hljs-number"><span class="hljs-number">42</span></span>);   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span></span>{           PerfectRobbery perfectRobbery = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PerfectRobbery();           perfectRobbery.takeAllMoney();           perfectRobbery.checkBalance();  }  <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">takeAllMoney</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{       bankAccount.drainPermits(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">checkBalance</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{        System.out.println(bankAccount.availablePermits()); } }</code> </pre><br>  And then we will have some logic.  We create the <code>PerfectRobbery</code> object in the <code>PerfectRobbery</code> class and call two methods: take all the money from the bank and check that we really took all the money. <br><br>  How can I create a Semaphore with a negative initial value?  This is an excellent question, because this is the first answer.  And besides him, I have three more. <br><br>  A. <code>IllegalArgumentException</code> - no negative balance semaphore can be created; <br>  B. <code>UnsupportedOperationException</code> - you can create a negative balance semaphore, but you cannot call drainPermits on it; <br>  C. 0 - <code>drainPermits</code> with a negative balance will leave zero permits; <br>  D. -42 - <code>drainPermits</code> with a negative balance will leave as much as it was, because there is nothing to drain. <br><br>  Voting in the audience showed that the majority - for option D, and the correct answer - C. <br><br>  You can find in Java documentation that the semaphore can be negative.  In addition, it says there that <code>drainPermits</code> returns all available permits. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/735/a8d/daa/735a8ddaa0290b5d403e82f587278dc2.png"><br><br>  How much do we have when we have -42 permits?  We have 0 available, so Sergey Kurenko opened the bug and said: guys, you have something nonsense.  Drain available permits at -42 should leave -42, because available permits 0. When we merge 0 out of -42, it will be -42. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a6a/301/67c/a6a30167c0cbccaaa9aa2df65fe72b95.png"><br><br>  But this was not the case, because Doug Lee came to the comments and said: ‚ÄúI want it so much!  And so I will ‚Äúfix this by adding a line to Javadoc.‚Äù <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3aa/54b/3f6/3aa54b3f65cefa414e2baa478fba306b.png"><br><br><h2>  Java puzzle # 2: Singletons </h2><br>  Let's go further.  A little advice from us: do not create singletons, drink singletons better. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/990/e64/002/990e64002275eadfeb6cb66e1921b4f1.png"><br><br>  Let's take a look at Java 7. You can create empty lists there using <code>emptyList</code> and empty iterators using <code>emptyIterator</code> . <br><br><pre> <code class="java hljs">Collections.emptyList() == Collections.emptyList(); Collections.emptyIterator() == Collections.emptyIterator();</code> </pre><br>  And here is the question: are they singltons?  Does the same object always return to us?  We have four possible answers: <br><br>  A. true / true - always returns; <br>  B. true / false - singleton is just a list, and the iterator is different each time; <br>  C. false / true - the iterator is a singleton, and a list is created each time; <br>  D. false / false is not a singleton at all. <br><br>  Voting in the audience showed that the majority is for option B, and the correct answer is A. Here the question arises: where is the puzzle?  Puzzler will be next. <br><br>  Let us turn to Java 8. In it, new methods have appeared that are returned to us by empty pieces: splitter and stream. <br><br><pre> <code class="java hljs">Spliterators.emptySpliterator() == Spliterators.emptySpliterator(); Stream.empty() == Stream.empty();</code> </pre><br>  And let's repeat the question for them: <br><br>  A. true / true <br>  B. true / false <br>  C. false / true <br>  D. false / false <br><br>  Voting in the audience showed that the majority is for option D, and the correct answer is B. The splitter can be a singleton because it has no state: you can try to get around the empty splitter many times, it will say that there is nothing to get around.  However, the stream has a state, and it consists of at least two things: firstly, you can hang <code>closeHandler</code> on the stream.  Imagine that if it were a singleton, you would have one handler hung on it in one place and another handler in another, and you won‚Äôt know what happens after that.  Of course, every empty stream should be free, independent.  Secondly, the stream should be used only once.  If the stream is reused, it detects it and throws an <code>IllegalStateException</code> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/87d/a7e/510/87da7e510af8e47b472cd27914083a85.png"><br><br><h2>  Java-puzzler number 3: the same lists </h2><br>  In the next puzzle we use the word ‚Äúidentical‚Äù in a somewhat strange sense.  The same - this is the same as the internal structure.  This does not mean that they are equal in <code>equals</code> or their hashcode is the same, and does not mean that they are related to the verification of references. <br><br>  We create an array of two lists.  In Java 8, the <code>setAll</code> method <code>setAll</code> , which allows you to fill it all at once.  We fill it with the <code>ArrayList</code> constructor.  We get an array consisting of two lists: <br><br><pre> <code class="java hljs">List[] twins = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List[<span class="hljs-number"><span class="hljs-number">2</span></span>]; Arrays.setAll(twins, ArrayList::<span class="hljs-keyword"><span class="hljs-keyword">new</span></span>);</code> </pre> <br>  Question: what lists will be there?  Answer options: <br><br>  A. Same empty lists <br>  B. Same non-empty lists. <br>  C. Not identical empty lists. <br>  D. Not the same non-empty lists. <br><br>  Voting in the audience showed that the majority - for option A, and the correct answer - C. <br><br>  First, <code>setAll</code> accepts not a <code>supplier</code> , but <code>inputInt Function</code> , which is passed to the array index and, accordingly, this array index as an input.  It automatically maps to the <code>ArrayList</code> constructor not from an empty argument, but from <code>initialCapacity</code> .  That is, this index, which is transmitted there, is not registered anywhere and is not visible.  And this is just some kind of Groovy: we are writing something, and we are doing something, and we do not know what. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fcf/a15/630/fcfa156303d8cd43e2d6c5917312ed95.png"><br><br>  By the way, we can fly to <code>OutOfMemory</code> thanks to this.  If we created an array of 100 thousand, we would have lists in which there would be predefined arrays inside also of 100 thousand. <br><br><h2>  Java puzzle number 4: Single Abstract Method </h2><br>  Let's try to create a functional interface.  At first we will create a simple interface, but we will stick four methods into it, three of them will be abstract.  And then we inherit from it another interface and make it functional.  Does it compile? <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> &lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span></span>{      <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> (String ) {                 System.out.println(); }  <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> (T songName);  <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> (T );  <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> (String ); } <span class="hljs-meta"><span class="hljs-meta">@FunctionalInterface</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class">  </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> &lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">String</span></span></span><span class="hljs-class">&gt; </span></span>{ }</code> </pre><br>  Here are the answers: <br><br>  A. What kind of nonsense ?!  'Single' means one method, not three! <br>  B. The problem with the method is <code>(T)</code> , if you remove it, everything is OK <br>  C. The problem with the methods of <code></code> , if you remove one, then all <br>  will be ok. <br>  D. All the way!  Duplicates collapse, and we stay with one to <code></code> . <br><br>  Voting in the audience showed that the majority is for option D, and the correct answer is B. The fact is that the method that is not implemented ( <code></code> ) does not overlap with the default implementation, and the compiler cannot decide what to use.  This is written in the documentation: you can inherit from the interface several abstract methods with override-equivalent signatures.  When we determined that T is a string, two methods collapsed, which is good.  But if the interface inherits the default method, and its signature is override-equivalent to the abstract method, this is a compilation error because ambiguity arises: whether we want to use the default implementation or not. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5e9/134/512/5e91345122a03acbfccae044f94101e3.png"><br>  <i>Screenshot from Java Language Specification</i> <br><br><h2>  Java Puzzle 5: How to hack a bank.  Second version </h2><br>  All banking software is written in Java.  Alpha Bank is Java, Deutsche Bank is Java, Sberbank is Java.  All banks write in Java, which means an attack on Java, there are many holes in it, it is easy to hack it, then find the largest accounts and withdraw money from them. <br><br><pre> <code class="java hljs">Set&lt;String&gt; accounts =      <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashSet&lt;&gt;(Arrays.asList(<span class="hljs-string"><span class="hljs-string">"Gates"</span></span>, <span class="hljs-string"><span class="hljs-string">"Buffett"</span></span>, <span class="hljs-string"><span class="hljs-string">"Bezos"</span></span>, <span class="hljs-string"><span class="hljs-string">"Zuckerberg"</span></span>)); System.out.println(<span class="hljs-string"><span class="hljs-string">"accounts= "</span></span> + accounts);</code> </pre><br>  Let's collect them in a set and print them.  Interestingly, we will see them in the same order in which we brought them? <br><br>  A. The order of ad is preserved <br>  B. Order unknown, but persists between runs. <br>  C. Order is unknown and changes each time JVM is restarted. <br>  D. Order is unknown and changes with each printout. <br><br>  Voting in the audience showed that the majority is for option B, and this is the correct answer.  Everyone knows that inside a hashset is a hashmep, and in a hashmep there are keys. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ff9/3a6/5ea/ff93a65ea542794bd9a7539d758676fc.png"><br><br>  We need to do something about it!  Therefore, we turn to Early Access Release Java 9 (banks always do this, they use all the freshest).  And here everything becomes more interesting, since the <code>Set.of</code> method appeared <code>Set.of</code> , so that instead of all this long one can write shortly. <br><br><pre> <code class="java hljs">Set&lt;String&gt; accounts = Set.of(<span class="hljs-string"><span class="hljs-string">"Gates"</span></span>, <span class="hljs-string"><span class="hljs-string">"Buffett"</span></span>, <span class="hljs-string"><span class="hljs-string">"Bezos"</span></span>, <span class="hljs-string"><span class="hljs-string">"Zuckerberg"</span></span>); System.out.println(<span class="hljs-string"><span class="hljs-string">"accounts= "</span></span> + accounts);</code> </pre><br>  The question remains the same: if you put in a set and print, we will see invoices in the same order in which we brought them? <br><br>  A. The order of the advertisement <br>  B. Order unknown, but persists between runs. <br>  C. Order is unknown and changes each time JVM is restarted. <br>  D. Order is unknown and changes with each printout. <br><br>  Voting in the audience showed that the majority - for option C, and this is the correct answer.  We have proof.  We can take advantage of the great new thing that appeared in the ninth Java and is called <code>JShell</code> .  We thrust this code, we get some order, we repeat, we get another order, we repeat, we get the third order.  How it works? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fad/fa1/c1f/fadfa1c1fca4999b3028a82320da03f4.png"><br><br>  This is done on purpose.  This is how the table element is calculated by the hash code in this <code>Set.of</code> itself: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">probe</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object pe)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> idx = Math.floorMod(pe.hashCode() ^ SALT, elements.length); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) {      E ee = elements[idx];      <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ee == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) {               <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -idx - <span class="hljs-number"><span class="hljs-number">1</span></span>;      } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pe.equals(ee)) {               <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> idx;      } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (++idx == elements.length) {               idx = <span class="hljs-number"><span class="hljs-number">0</span></span>;     } } }</code> </pre><br>  You see that there is a hash code <code>^ SALT</code> , and SALT is a static field that is initialized with a random number when the JVM is started.  This was done on purpose, because too many people were laid on the order of the hash set, when it was not defined and when the documentation read in black and white: ‚Äúdo not pledge on it‚Äù.  Therefore, it was done in such a way that when you try to log in, you simply restart the JVM, and this will no longer work.  You just can't do it.  Although there is a danger: some may assume that this thing works randomly. <br><br><h2>  Java Puzzleplayer # 6: Jigsaw </h2><br>  There are several statements about <code>Jigsaw</code> .  Try to guess which one is correct: <br><br>  A. If you make a jigsaw application a module, the dependencies in the <code>classpath</code> will be loaded correctly <br>  B. If one of the dependencies is a jigsaw module, then it is necessary to register the <code>module-info</code> file <br>  C. If you have registered the module-info file, then all dependencies will have to be written twice, in the <code>classpath</code> and in <code>module-info</code> <br>  D. None is not true <br><br>  The correct answer is C. Of course, you will have to prescribe everything twice.  The good news is that <code>Gradle</code> and <code>Maven</code> will generate both of these components for you: the correct <code>classpath</code> and the correct <code>module-info</code> , so you don‚Äôt have to handle it.  But if you do not work with these tools, you will have to do it twice, although there is a nuance.  You can use the <code>module-path</code> checkbox, and it has its own puzzler, but about it next time. <br><br><h1>  Java Puzzle Number 7: The Expendables 2 </h1><br>  We have a collection of Expendables, and we want to destroy them all.  We will destroy it this way: take an iterator and call its <code>forEachRemaining</code> method.  And for each element we will do such a thing: if there is the next record, then we move and destroy (and this is all inside <code>forEachRemaining</code> ). <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">killThemAll</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Collection&lt;Hero&gt; expendables)</span></span></span><span class="hljs-function"> </span></span>{  Iterator&lt;Hero&gt; heroes = expendables.iterator();  heroes.forEachRemaining(e -&gt; {           <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (heroes.hasNext()) {                heroes.next();                heroes.remove();       }  });  System.out.println(expendables); }</code> </pre><br>  What are the options? <br><br>  A. Everyone died <br>  B. Only even died <br>  C. All survived <br>  D. Only the odd died <br>  E. All answers are correct. <br><br>  The correct answer is E. This is an undefined behavior.  Here you can try to submit different collections, and if you try to do this, we get different results. <br><br>  If we submit an <code>ArrayList</code> here, we will get everyone dead. <br><br><pre> <code class="java hljs">killThemAll(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;String&gt;(Arrays.asList(<span class="hljs-string"><span class="hljs-string">"N"</span></span>,<span class="hljs-string"><span class="hljs-string">"S"</span></span>,<span class="hljs-string"><span class="hljs-string">"W"</span></span>,<span class="hljs-string"><span class="hljs-string">"S"</span></span>,<span class="hljs-string"><span class="hljs-string">"L"</span></span>,<span class="hljs-string"><span class="hljs-string">"S"</span></span>,<span class="hljs-string"><span class="hljs-string">"L"</span></span>,<span class="hljs-string"><span class="hljs-string">"V"</span></span>))); []&lt; /source&gt;     &lt;code&gt;LinkedList&lt;/code&gt;,   ,    &lt;source lang=<span class="hljs-string"><span class="hljs-string">"java"</span></span>&gt;killThemAll(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> LinkedList&lt;String&gt;(Arrays.asList(<span class="hljs-string"><span class="hljs-string">"N"</span></span>,<span class="hljs-string"><span class="hljs-string">"S"</span></span>,<span class="hljs-string"><span class="hljs-string">"W"</span></span>,<span class="hljs-string"><span class="hljs-string">"S"</span></span>,<span class="hljs-string"><span class="hljs-string">"L"</span></span>,<span class="hljs-string"><span class="hljs-string">"S"</span></span>,<span class="hljs-string"><span class="hljs-string">"L"</span></span>,<span class="hljs-string"><span class="hljs-string">"V"</span></span>))); [S,S,S,V]</code> </pre><br>  If we submit <code>ArrayDeque</code> here, then everyone will stay alive, and no exceptions. <br><br><pre> <code class="java hljs">killThemAll(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayDeque&lt;String&gt;(Arrays.asList(<span class="hljs-string"><span class="hljs-string">"N"</span></span>,<span class="hljs-string"><span class="hljs-string">"S"</span></span>,<span class="hljs-string"><span class="hljs-string">"W"</span></span>,<span class="hljs-string"><span class="hljs-string">"S"</span></span>,<span class="hljs-string"><span class="hljs-string">"L"</span></span>,<span class="hljs-string"><span class="hljs-string">"S"</span></span>,<span class="hljs-string"><span class="hljs-string">"L"</span></span>,<span class="hljs-string"><span class="hljs-string">"V"</span></span>))); [N,S,W,S,L,S,L,V]</code> </pre><br>  And if we give the <code>TreeSet</code> here, then, on the contrary, the odd ones will die. <br><br><pre> <code class="java hljs">killThemAll(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TreeSet&lt;String&gt;(Arrays.asList(<span class="hljs-string"><span class="hljs-string">"N"</span></span>,<span class="hljs-string"><span class="hljs-string">"S"</span></span>,<span class="hljs-string"><span class="hljs-string">"W"</span></span>,<span class="hljs-string"><span class="hljs-string">"S"</span></span>,<span class="hljs-string"><span class="hljs-string">"L"</span></span>,<span class="hljs-string"><span class="hljs-string">"S"</span></span>,<span class="hljs-string"><span class="hljs-string">"L"</span></span>,<span class="hljs-string"><span class="hljs-string">"V"</span></span>))); [N,W,L,L]</code> </pre><br>  Therefore, never!  Never do that!  In fact, it happened by chance - simply because no one thought that someone would do that.  When we reported this to Oracle, they did what?  That's right, ‚Äúfixed this problem‚Äù by writing about it in the documentation: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0e5/c98/1a9/0e5c981a95b6bc138e5c511e9ad82514.png"><br><br><h2>  Java Puzzle 8: An Imperceptible Difference </h2><br>  We want to create an original, real Adidas in the form of a predicate that will verify that this is really Adidas.  We create a functional interface, parameterize it with some type T and, accordingly, implement it as Lambda or as <code>methodRef</code> : <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@FunctionalInterface</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OriginalPredicate</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span></span>{   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T t)</span></span></span></span>; } OriginalPredicate&lt;Object&gt; lambda = (Object obj) -&gt; <span class="hljs-string"><span class="hljs-string">"adidas"</span></span>.equals(obj); OriginalPredicate&lt;Object&gt; methodRef = <span class="hljs-string"><span class="hljs-string">"adidas"</span></span>::equals;</code> </pre><br>  Question: will this all be compiled or not? <br><br>  A. Both compiled <br>  B. Lambda will compile, reference to method is not. <br>  C. Method reference compiles, lambda does not <br>  D. Non-functional interface! <br><br>  The correct answer is A, there is actually no puzzler at all.  But let's make a functional interface made in china. <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@FunctionalInterface</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CopyCatPredicate</span></span></span><span class="hljs-class"> </span></span>{  &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T t)</span></span></span></span>; } CopyCatPredicate lambda = (Object obj) -&gt; <span class="hljs-string"><span class="hljs-string">"adadas"</span></span>.equals(obj); CopyCatPredicate methodRef = <span class="hljs-string"><span class="hljs-string">"adadas"</span></span>::equals;</code> </pre><br>  What is the difference from the previous code?  In addition to adadas, we moved generic from the interface itself to the method, and now we don‚Äôt have a generic class, but a generic method.  Can we create a functional interface with a generic method? <br><br>  A. Both compiled <br>  B. Lambda will compile, reference to method ‚Äìno <br>  C. Method reference compiled, lambda ‚Äìno <br>  D. Non-functional interface! <br><br>  The correct answer is C. You have been warned - the method is better.  Lambda cannot implement the generic method.  In Lambda, we pass a parameter; we have to specify a type for it.  Even if we do not specify, it must be some sort of output, but in order for it to be derived, we must have a generic variable.  That is, there you need to make a generic-lambda, somewhere in the corner brackets write T or not T (we can use another letter).  But there is no such syntax, they did not come up and then decided that, well, let's, okay, but for Lambda it will not work. <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@FunctionalInterface</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CopyCatPredicate</span></span></span><span class="hljs-class"> </span></span>{  &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T t)</span></span></span></span>; } CopyCatPredicate lambda = (Object obj) -&gt; <span class="hljs-string"><span class="hljs-string">"adadas"</span></span>.equals(obj);</code> </pre><br>  And with the reference method, everything is fine, there is no such problem.  Therefore, again, if something goes wrong with us, you need to add documentation. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/605/a5b/243/605a5b2437ff8fd46e3ee3ad0315275c.png"><br><br><h2>  Java Puzzle Number 9: what conference to attend? </h2><br>  You want to go to a conference, there are many conferences.  You want to filter them, <code>TreeSet</code> them into the <code>TreeSet</code> and, accordingly, print the result. <br><br><pre> <code class="java hljs">List&lt;String&gt; list = Stream.of(<span class="hljs-string"><span class="hljs-string">"Joker"</span></span>, <span class="hljs-string"><span class="hljs-string">"DotNext"</span></span>, <span class="hljs-string"><span class="hljs-string">"HolyJS"</span></span>, <span class="hljs-string"><span class="hljs-string">"HolyJS"</span></span>, <span class="hljs-string"><span class="hljs-string">"DotNext"</span></span>, <span class="hljs-string"><span class="hljs-string">"Joker"</span></span>).sequential()            .filter(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TreeSet&lt;&gt;()::add).collect(Collectors.toList()); System.out.println(list);</code> </pre><br><br>  What will you get? <br><br>  A. Sorted and filtered [DotNext, HolyJS, Joker] <br>  B. Exactly what was at the beginning [Joker, DotNext, HolyJS, HolyJS, DotNext, Joker] <br>  C. Initially, but filtered [Joker, DotNext, HolyJS] <br>  D. Sorted but not filtered [DotNext, DotNext, HolyJS, HolyJS, Joker, Joker] <br><br>  The correct answer is C. The filtering will work because this is the <code>reference</code> method, and there will be one <code>TreeSet</code> object.  Newbies think that the <code>reference</code> and Lambda methods are almost the same, but they are not exactly the same.  If we had written Lambda, the new <code>TreeSet</code> would be created every time, and since this is the reference method, it is created once before we do all of this filtering, and the reference method is attached to it.  And nothing is sorted because we do not use what in the TreeSet as a result, we just use the <code>add</code> method as a filter that answers us with true or false (need to throw out duplicates or not).  In fact, you could write just distinct, and it would be the same.  The result of this triset will be <code>GarbageCollector</code> GarbageCollector then, and no one knows what will be there. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a02/63c/a37/a0263ca37eb84b7762351d18b3c14aec.png"><br><br><h2>  findings </h2><br>  Java is getting better, and there are more ways to shoot yourself in the foot.  Therefore, here are a couple of tips: <br><br><ul><li>  Write readable code. <br></li><li>  Comment on all the tricks if you can not resist. <br></li><li>  Sometimes even in Java there are bugs that put you in a dead end. <br></li><li>  Static code analyzers rule!  Use IntelliJ IDEA. <br></li><li>  Since all the bugs are fixed by adding lines to the documentation, you need to know the documentation. <br></li><li>  Do not get sick with streamer.  By the way, in the newest IDEA you can turn the stream into a loop if you are tired of it. <br></li></ul><br>  If you come across a puzzler, send it to puzzlers@jfrog.com, we will be happy to spend the third season at one of the following conferences.  In exchange for a valuable copy, we will send you a branded T-shirt. <br><br><hr><br>  If you like to savor all the details of Java development in the same way as we do, you probably will be interested in these reports at our April <a href="https://jpoint.ru/">JPoint 2018</a> conference: <br><br><ul><li>  <a href="https://jpoint.ru/talks/1bvhc9jbruimqwks4uqaeu/">Linux container performance tools for JVM applications</a> (Sasha Goldshtein, Sela Group) <br></li><li>  <a href="https://jpoint.ru/talks/1qghn5o70siuweuqeesuoa/">Program analysis: how to understand that you are a good programmer</a> (Alexey Kudryavtsev, JetBrains) <br></li><li>  <a href="https://jpoint.ru/talks/4cofbdo22ic4m2ao02kyaa/">Typical problems of software development in large projects</a> (Rustam Mehmandarov, Computas AS) <br></li></ul></div><p>Source: <a href="https://habr.com/ru/post/352438/">https://habr.com/ru/post/352438/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../352428/index.html">Friday JS: minus without minus</a></li>
<li><a href="../352430/index.html">Tarantool application: stored procedures</a></li>
<li><a href="../352432/index.html">Linux distribution from scratch to build Docker images - our experience with dappdeps</a></li>
<li><a href="../352434/index.html">Ransomware is gaining strength</a></li>
<li><a href="../352436/index.html">Blondes, monsters and artificial intelligence addictions</a></li>
<li><a href="../352440/index.html">The book "Security in PHP" (part 2). Code injection attacks</a></li>
<li><a href="../352442/index.html">The book "Security in PHP" (part 3). Cross-site scripting (XSS)</a></li>
<li><a href="../352444/index.html">The book Security in PHP (part 4). The lack of security at the transport level (HTTPS, TLS and SSL)</a></li>
<li><a href="../352446/index.html">The book "Security in PHP" (Part 5). Lack of entropy for random values</a></li>
<li><a href="../352448/index.html">Manual cipher LS47</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>