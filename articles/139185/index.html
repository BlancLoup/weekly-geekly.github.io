<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How we got rid of GC pauses using our own java off-heap storage solution</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hi, Habr! 

 Some systems simply cannot provide adequate response without data caching. And sooner or later they may stumble upon the problem that the...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How we got rid of GC pauses using our own java off-heap storage solution</h1><div class="post__text post__text-html js-mediator-article">  Hi, Habr! <br><br>  Some systems simply cannot provide adequate response without data caching.  And sooner or later they may stumble upon the problem that the data that I would like to cache will become more and more.  If your system is written in java, then this leads to the inevitable pauses of the GC.  <nobr>Once</nobr> Odnoklassniki also encountered this problem.  We did not want to limit ourselves to the size of the data being cached, but at the same time we understood that the GC simply would not allow us to have the Heap we needed.  On the other hand, we wanted to continue writing in java.  In this topic, we describe how we solved this problem for ourselves with all the advantages and disadvantages of our approach, as well as experience of using.  We hope that our approach will interest those who have to deal with the pauses of GC. <br><a name="habracut"></a><br><img src="https://habrastorage.org/storage2/dc5/ba9/4bc/dc5ba94bc2923325f1df55ed91435ba0.jpg"><br><br><h4>  Justification of the chosen solution </h4><br>  <a href="http://habrahabr.ru/company/odnoklassniki/blog/115881/">In the review article about the architecture of the project,</a> we already mentioned that we use our own development framework for caching, as well as storing some data.  It is written entirely in Java, but the data is stored <nobr>off-heap</nobr> .  You probably have a question: why did we need such a non-standard approach with <nobr>off-heap</nobr> , and why we did not use a ready-made solution? 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Obviously, the most efficient storage (in particular, cache) is that which is always in RAM and is accessible to the application process without <nobr>any</nobr> network interaction.  For applications written in java, the storage implementation is also reasonable in the java programming language, since the integration problem disappears.  In addition, any programmer working on the system can easily understand the intricacies of his work by looking at the source code.  But since with a large heap, almost any java program begins to suffer from GC pauses, with a total data size of several gigabytes and higher, the system becomes incapable (unless the entire Heap is not just one big array of bytes).  Configuring GC is not a trivial task.  If your heap already contains dozens of gigabytes, then it‚Äôs almost impossible to configure the GC so that the pauses are adequate for the application with which the user interacts.  And as a large RAM becomes more and more accessible, the approach with the java <nobr>off-heap</nobr> cache becomes more and more popular. <br><br>  <nobr>Once upon a</nobr> time this approach could really be considered non-standard.  But, look, now more and more products appear and develop in this direction.  About one and a half years ago, the first solution of this kind appeared on the market: <a href="http://www.ehcache.org/documentation/user-guide/bigmemory">BigMemory</a> from Terracota.  Half a year ago, Hazelcast announced that they had put a product called <a href="http://www.hazelcast.com/products.jsp">Elastic Memory</a> on <nobr>alpha testing</nobr> .  But, unfortunately, it is still in the beta stage, and besides, like BigMemory, it will be paid.  About half a year ago, <a href="http://cassandra.apache.org/">Cassandra</a> began to use <nobr>off-heap</nobr> row cache.  But this is a cache for internal purposes, which is not so easy to pick out to use at home.  There is no strong <nobr>open-source</nobr> product in this area.  However, it is worth noting that in the fall the <a href="http://incubator.apache.org/directmemory/directmemory-cache/index.html">DirectMemory</a> project got into the apache incubator.  However, when to wait for the finished product and when it will recommend itself in large projects, the question is open.  We began to use our solution more than four years ago, nothing ready, as you see, at that time was simply not there. <br><br><h4>  Implementation </h4><br>  Communicating java applications with off-heap memory can be implemented in <a href="http://www.javaspecialist.ru/2011/10/java-off-heap-cache.html">several ways</a> .  Classmates at one time chose an approach based on the use of the <a href="http://www.docjar.com/docs/api/sun/misc/Unsafe.html">sun.misc.Unsafe</a> class, which is included in the private HotSpot package, and now OpenJDK.  This class allows you to work directly with memory, without using JNI explicitly, which leaves our solution cross-platform, and we can run the same binaries as on the main system, as well as on the developer‚Äôs computer, and it doesn‚Äôt matter if the developer is running Windows, Ubuntu or Mac.  In order not to write a complicated memory management algorithm, such as, for example, we decided to do it in DirectMemory, we allocate or free memory for each object that we want to put in storage or remove from it.  Let the operating system deal with memory management, it is very good at it.  Because of the fact that we often need to allocate and free memory, we do not use the standard <a href="http://docs.oracle.com/javase/1.4.2/docs/api/java/nio/ByteBuffer.html">java.nio.ByteBuffer</a> class, which is part of the JDK, has an open API and allows you to work with memory off-heap.  The problem with ByteBuffer in our case is that it creates additional garbage and does not allow you to directly release the memory, but does it on the basis of phantom links.  The latter leads to the fact that, allocating a lot of memory outside the heap, it cannot be freed until the GC works, even if the ByteBuffer objects that allocated this memory are no longer in use.  Although there is the -XX: MaxDirectMemorySize = flag to solve this problem, which initiates garbage collection when the allocated memory reaches the specified value heap, still, a large number of phantom links can negatively affect the GC.  This behavior of ByteBuffer is most likely due to the fact that it was designed to allocate large amounts of memory and reuse them.  We use the opposite pattern of work.  Of course, the rejection of ByteBuffer made us do some things on our own, such as, for example, taking care of a <a href="http://en.wikipedia.org/wiki/Endianness">byte order</a> . <br><br>  An inquisitive reader may ask: are we not ashamed to use the HotSpot (sun.misc.Unsafe) private mechanisms for our functionality, because they can change or disappear at one point?  No, not at all.  After all, this very HotSpot of the new version will not appear in our working versions unexpectedly, <nobr>i.e.</nobr>  we will be ready for this.  Everything we use from Unsafe uses the already mentioned ByteBuffer.  <nobr>Those.</nobr>  if <nobr>something</nobr> changes in the next version, it will be enough for us to look at the source code and make the same changes in our framework, or rather, in the same class responsible for allocating / freeing memory and saving data. <br><br><h4>  Opportunities of our framework </h4><br>  There is nothing difficult to serialize an object into an array of bytes and place it outside the heap.  What else does the framework help us in Odnoklassniki? <br><br>  <b>Granularity updates.</b>  In order to put an object in our storage, it is necessary to describe its structure, specifying how to save each field.  Our framework allows you to save the structure of an object consisting of any primitives, arrays, collections and composite objects.  Each field of the object must be matched with our library algorithm for the description of saving and updating.  It is possible to create a new or expand an existing one if such a need suddenly appears.  This declarative approach allows you to do point updates of the fields, and not to read the entire object, deserialize it, do an update, serialize and save it back.  You can also make different views of objects in the repository.  So, if <nobr>some</nobr> service does not need all the data of the stored object, it can query and read only a part of this object.  This also helps a lot with filtering.  For example, when you want to pull objects according to a list of identifiers, but only those that meet <nobr>some</nobr> criterion. <br><br>  <b><nobr>Read-through</nobr> .</b>  Some of our storages help to remove the load from the base, <nobr>i.e.</nobr>  used as caches.  For such a case, we have a <nobr>read-through</nobr> option.  If there is no data in the cache that the client requests, then we go to the database and read them.  Here we still have some tricks, for example, if two identical requests come at the same time, then we will go to the database only once, and the second request will simply wait for the result of the first.  This is very helpful in the case of a cold start.  Or if the client constantly requests data that is not in the cache, then after <nobr>a certain</nobr> number of attempts, we stop accessing the database for this data. <br><br>  <b>Synchronization with the database.</b>  In the case when the storage is running on top of the database, we run a background process that will load all changes to the database that got there to bypass the cache for <nobr>some</nobr> reason. <br><br>  <b>Snepshoting.</b>  Our framework also allows you to reset all storage to disk.  Thus, when restarting the server, all stored data is restored.  In the case when the storage is used as a cache to relieve the load from the database, then snapshoting allows you to avoid a cold start when the cache is empty and all requests go directly to the database.  And the synchronization mechanism described above allows us to roll onto the last snapshot data that came to the database during the restart of the repository. <br><br>  <b>Client library.</b>  If the storage becomes very large and does not fit completely on our commodity iron, then we distribute it across several machines and use sharding on the key.  And we do this not <nobr>because of the</nobr> increasing pauses of the GC, but precisely <nobr>because of the</nobr> limitation of iron.  Of course, all the charm of the <nobr>in-process</nobr> cache is lost here and network interaction appears, but there's nothing you can do.  But our old familiar code, written entirely in our beloved Java, remains.  In addition, <nobr>some</nobr> logic can also be easily transferred to these separate boxes, since the CPU still stands idle there.  Our client library also allows you to update or receive only the required fields of objects from the storage, which significantly reduces traffic.  For fault tolerance and scalability, we use duplication in such a way that we have at least two hosts responsible for each shard.  Requests for reading go on a <nobr>round-robin</nobr> algorithm, updates go to all nodes. <br><br><h4>  Disadvantages and forced compromises </h4><br>  Of course, there are drawbacks in our framework.  For example, due to the fact that the keys are still stored in the heap, at <nobr>some</nobr> point the GC may begin to affect the performance of the application.  We try not to use keys more than Long, so even on our data volumes we are quite satisfied with the current characteristics. <br><br>  As already mentioned, unlike some existing solutions, we allocate memory for each object separately.  Although it can not affect the defragmentation of memory, but we did without a complicated memory management algorithm. <br><br>  To effectively be able to make granular updates, we have to allocate memory separately for each variable-length field (such as a string or collection).  Thus, to create a single object, sometimes we make several low-level calls. <br><br><h4>  Use inside classmates </h4><br>  Using the above framework, we store user profiles, group profiles, meta information on photos, information on classes (like), statistics of user actions in relation to their friends and groups, pieces of tape and <nobr>something</nobr> else.  For example, a distributed statistics repository, based on which users' weights are counted for getting into the tape, contains about 300GB of data.  The maximum size of the data in the storage memory in one box reaches 90 GB.  The average load on a 2 processor piece of hardware with 4 cores on each peak is about 20K requests per second. <br><br>  It is worth noting that our storage does not in any way serve as a substitute for RDBMS or <nobr>something</nobr> like NoSQL solution.  More often we use it simply as a cache for the database.  Perhaps in some places of use we could switch to NoSQL instead of the existing cache bundle plus RDBMS, but this requires a strong revision of the <nobr>business logic</nobr> , which may be based on the transactionality provided by the RDBMS. <br><br>  Thus, the described framework allows us to write all the code in java, store in a heap such amount of data that a task requires, not have a headache with GC settings, quickly implement storage or caching of new data. <br><br>  It will also be very interesting for us to learn about your experience in solving problems of GC pauses on large volumes of heap. </div><p>Source: <a href="https://habr.com/ru/post/139185/">https://habr.com/ru/post/139185/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../139178/index.html">Redirection for Asterisk</a></li>
<li><a href="../139180/index.html">Programming Siemens PLC on Simatic Step7</a></li>
<li><a href="../139181/index.html">Demonstration of Boot to Gecko</a></li>
<li><a href="../139183/index.html">Rutoken EDS and Open Source</a></li>
<li><a href="../139184/index.html">Datacenter in Yaroslavl: engineering solutions for smooth operation</a></li>
<li><a href="../139187/index.html">Information Visualization Patterns</a></li>
<li><a href="../139188/index.html">Skitch update for Android: maps and save to memory card</a></li>
<li><a href="../139189/index.html">Spring, Cebit 2012</a></li>
<li><a href="../139190/index.html">Facebook translates public pages into a new format.</a></li>
<li><a href="../139191/index.html">KupiKupon became the 19th in the rating of Forbes</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>