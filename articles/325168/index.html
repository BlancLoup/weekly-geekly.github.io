<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>MIPSfpga and UART</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="It has been a little over a month since I ported the open source module UART16550 to the AHB-Lite bus. Writing about it at that time was somewhat not ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>MIPSfpga and UART</h1><div class="post__text post__text-html js-mediator-article"><p>  It has been a little over a month since I ported the open source module UART16550 to the AHB-Lite bus.  Writing about it at that time was somewhat not logical, since the article about the MIPSfpga interrupts has not yet been published. </p><br><p>  If you are an experienced developer, then only one useful news for you: UART16550 added to the MIPSfpga-plus system, you can not read further.  And those who are interested in the disassembled example of using this module are welcome under cat. </p><br><p><img src="https://habrastorage.org/files/7c5/699/9aa/7c56999aaba2465f8074e370bf2e3407.gif" alt="image"></p><a name="habracut"></a><br><h2 id="vvedenie">  Introduction </h2><br><p>  It is assumed that the reader: </p><br><ul><li>  familiar with the subject area in the Harris-Harris volume [ <a href="https://habrahabr.ru/post/259505/">L1</a> ]; </li><li>  has access to the source codes MIPSfpga [ <a href="https://habrahabr.ru/post/275215/">L2</a> ] and mipsfpga-plus [ <a href="https://github.com/MIPSfpga/mipsfpga-plus">L3</a> ]; </li><li>  has some programming experience in microcontrollers (of any architecture), including the use of a UART.  Refresh what the UART is like here [ <a href="https://ru.wikipedia.org/wiki/%25D0%25A3%25D0%25BD%25D0%25B8%25D0%25B2%25D0%25B5%25D1%2580%25D1%2581%25D0%25B0%25D0%25BB%25D1%258C%25D0%25BD%25D1%258B%25D0%25B9_%25D0%25B0%25D1%2581%25D0%25B8%25D0%25BD%25D1%2585%25D1%2580%25D0%25BE%25D0%25BD%25D0%25BD%25D1%258B%25D0%25B9_%25D0%25BF%25D1%2580%25D0%25B8%25D1%2591%25D0%25BC%25D0%25BE%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B5%25D0%25B4%25D0%25B0%25D1%2582%25D1%2587%25D0%25B8%25D0%25BA">L4</a> ]; </li></ul><br><h2 id="chto-takoe-uart16550">  What is UART16550 </h2><br><p>  The history of the appearance of this chip is well described in [ <a href="https://ru.wikipedia.org/wiki/16550_UART">L5</a> ], you can find documentation on it in google [ <a href="https://www.google.ru/search%3Fq%3Duart%2B16550%2Bdatasheet%2Bfile%253Apdf">L6</a> ], something else is important for us: </p><br><ul><li>  it has become extremely widespread; </li><li>  working with it is supported by the Linux kernel; </li><li>  for it has long been an open source implementation on verilog [ <a href="https://github.com/freecores/uart16550">L7</a> , <a href="https://github.com/olofk/uart16550">L8</a> , <a href="http://opencores.org/project,uart16550">L9</a> ], but for the Wishbone bus; </li><li>  The price of porting this implementation to the AHB-Lite bus used in MIPSfpga is about 100 lines of code [ <a href="">S1</a> ]: </li></ul><br><div class="spoiler">  <b class="spoiler_title">mfp_ahb_lite_uart16550</b> <div class="spoiler_text"><pre><code class="hljs lua">module mfp_ahb_lite_uart16550( //ABB-Lite side <span class="hljs-built_in"><span class="hljs-built_in">input</span></span> HCLK, <span class="hljs-built_in"><span class="hljs-built_in">input</span></span> HRESETn, <span class="hljs-built_in"><span class="hljs-built_in">input</span></span> [ <span class="hljs-number"><span class="hljs-number">31</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span> ] HADDR, <span class="hljs-built_in"><span class="hljs-built_in">input</span></span> [ <span class="hljs-number"><span class="hljs-number">2</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span> ] HBURST, <span class="hljs-built_in"><span class="hljs-built_in">input</span></span> HMASTLOCK, // ignored <span class="hljs-built_in"><span class="hljs-built_in">input</span></span> [ <span class="hljs-number"><span class="hljs-number">3</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span> ] HPROT, // ignored <span class="hljs-built_in"><span class="hljs-built_in">input</span></span> HSEL, <span class="hljs-built_in"><span class="hljs-built_in">input</span></span> [ <span class="hljs-number"><span class="hljs-number">2</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span> ] HSIZE, <span class="hljs-built_in"><span class="hljs-built_in">input</span></span> [ <span class="hljs-number"><span class="hljs-number">1</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span> ] HTRANS, <span class="hljs-built_in"><span class="hljs-built_in">input</span></span> [ <span class="hljs-number"><span class="hljs-number">31</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span> ] HWDATA, <span class="hljs-built_in"><span class="hljs-built_in">input</span></span> HWRITE, <span class="hljs-built_in"><span class="hljs-built_in">output</span></span> reg [ <span class="hljs-number"><span class="hljs-number">31</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span> ] HRDATA, <span class="hljs-built_in"><span class="hljs-built_in">output</span></span> HREADY, <span class="hljs-built_in"><span class="hljs-built_in">output</span></span> HRESP, <span class="hljs-built_in"><span class="hljs-built_in">input</span></span> SI_Endian, // ignored //UART side <span class="hljs-built_in"><span class="hljs-built_in">input</span></span> UART_SRX, // UART serial <span class="hljs-built_in"><span class="hljs-built_in">input</span></span> signal <span class="hljs-built_in"><span class="hljs-built_in">output</span></span> UART_STX, // UART serial <span class="hljs-built_in"><span class="hljs-built_in">output</span></span> signal <span class="hljs-built_in"><span class="hljs-built_in">output</span></span> UART_RTS, // UART MODEM Request To Send <span class="hljs-built_in"><span class="hljs-built_in">input</span></span> UART_CTS, // UART MODEM Clear To Send <span class="hljs-built_in"><span class="hljs-built_in">output</span></span> UART_DTR, // UART MODEM Data Terminal Ready <span class="hljs-built_in"><span class="hljs-built_in">input</span></span> UART_DSR, // UART MODEM Data Set Ready <span class="hljs-built_in"><span class="hljs-built_in">input</span></span> UART_RI, // UART MODEM Ring Indicator <span class="hljs-built_in"><span class="hljs-built_in">input</span></span> UART_DCD, // UART MODEM Data Carrier Detect //UART internal <span class="hljs-built_in"><span class="hljs-built_in">output</span></span> UART_BAUD, // UART baudrate <span class="hljs-built_in"><span class="hljs-built_in">output</span></span> <span class="hljs-built_in"><span class="hljs-built_in">output</span></span> UART_INT // UART interrupt ); parameter S_INIT = <span class="hljs-number"><span class="hljs-number">0</span></span>, S_IDLE = <span class="hljs-number"><span class="hljs-number">1</span></span>, S_READ = <span class="hljs-number"><span class="hljs-number">2</span></span>, S_WRITE = <span class="hljs-number"><span class="hljs-number">3</span></span>; reg [ <span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span> ] State, Next; assign HRESP = <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-string"><span class="hljs-string">'b0; assign HREADY = (State == S_IDLE); always @ (posedge HCLK) begin if (~HRESETn) State &lt;= S_INIT; else State &lt;= Next; end reg [ 2:0 ] ADDR_old; wire [ 2:0 ] ADDR = HADDR [ 4:2 ]; wire [ 7:0 ] ReadData; parameter HTRANS_IDLE = 2'</span></span>b0; wire NeedAction = HTRANS != HTRANS_IDLE &amp;&amp; HSEL; always @ (*) begin //State change decision case(State) default : Next = S_IDLE; S_IDLE : Next = ~NeedAction ? S_IDLE : ( HWRITE ? S_WRITE : S_READ ); endcase <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> always @ (posedge HCLK) begin case(State) S_INIT : ; S_IDLE : <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(HSEL) ADDR_old &lt;= ADDR; S_READ : HRDATA &lt;= { <span class="hljs-number"><span class="hljs-number">24</span></span><span class="hljs-string"><span class="hljs-string">'b0, ReadData}; S_WRITE : ; endcase end wire [ 7:0 ] WriteData = HWDATA [ 7:0 ]; wire [ 2:0 ] ActionAddr; wire WriteAction; wire ReadAction; reg [ 10:0 ] conf; assign { ReadAction, WriteAction, ActionAddr } = conf; always @ (*) begin //io case(State) default : conf = { 2'</span></span>b00, <span class="hljs-number"><span class="hljs-number">8</span></span><span class="hljs-string"><span class="hljs-string">'b0 }; S_READ : conf = { 2'</span></span>b10, ADDR }; S_WRITE : conf = { <span class="hljs-number"><span class="hljs-number">2</span></span><span class="hljs-string"><span class="hljs-string">'b01, ADDR_old }; endcase end // Registers uart_regs regs( .clk ( HCLK ), .wb_rst_i ( ~HRESETn ), .wb_addr_i ( ActionAddr ), .wb_dat_i ( WriteData ), .wb_dat_o ( ReadData ), .wb_we_i ( WriteAction ), .wb_re_i ( ReadAction ), .modem_inputs ( { UART_CTS, UART_DSR, UART_RI, UART_DCD } ), .stx_pad_o ( UART_STX ), .srx_pad_i ( UART_SRX ), .rts_pad_o ( UART_RTS ), .dtr_pad_o ( UART_DTR ), .int_o ( UART_INT ), .baud_o ( UART_BAUD ) ); endmodule</span></span></code> </pre> </div></div><br><h2 id="osnovnye-osobennosti-realizacii">  Main features of the implementation </h2><br><ul><li>  The project [ <a href="https://github.com/olofk/uart16550">L8</a> ], which, in turn, is based on [ <a href="https://github.com/freecores/uart16550">L7</a> , <a href="http://opencores.org/project,uart16550">L9</a> ], was taken as the base solution; </li><li>  compared to the basic solution, the code associated with the Wishbone bus is excluded from the project.  It is replaced by the corresponding interface module for AHB-Lite (mfp_ahb_lite_uart16550) [ <a href="">S1</a> ]; </li><li>  All code borrowed from the base project is located in the uart16550 [ <a href="https://github.com/MIPSfpga/mipsfpga-plus/tree/5169e133ea2de692e8f9564896f46844ec5bb398/uart16550">S2</a> ] directory; </li><li>  The mfp_ahb_lite_uart16550 module is permanently included in the system; the MFP_USE_DUPLEX_UART [ <a href="">S3</a> ] option in the mfp_ahb_lite_matrix_config.vh file determines the availability of the <em>UART_SRX</em> and <em>UART_STX signals</em> ; </li><li>  For the already existing <em>UART_RX</em> and <em>UART_TX signals</em> , the following order of use is provided: <br>  <em>UART_RX</em> - regardless of the mode, it is used only to load the firmware into the system memory, as it was before (the mfp_uart_receiver module, not applicable to the UART16550).  If the MFP_USE_DUPLEX_UART option is not active, then the <em>UART_TX is</em> used to transfer data from the UART16550 to the outside; reception in this case is not available.  If the option MFP_USE_DUPLEX_UART is active, then <em>UART_TX</em> is not used; <em>UART_SRX</em> and <em>UART_STX</em> [ <a href="">S4</a> ] are used to transfer data from / to mfp_ahb_lite_uart16550; </li><li>  output of the modem control interface to the top level of the module was not made.  Corresponding lines are available in the interface ahb_lite_uart16550 and can be used if necessary ( <em>UART_RTS, UART_CTS, UART_DTR, UART_DSR, UART_RI, UART_DCD</em> ) [ <a href="">S5</a> ]; </li><li>  the interrupt signal ( <em>UART_INT</em> ) is connected to the hw3 input (SI_Int signal <em>[3]</em> ) for backward and vector compatibility modes.  And to eic5 (signal <em>EIC_input [5]</em> ) for an external interrupt controller [ <a href="">S6</a> ]; </li><li>  when started in simulation mode, the <em>UART_STX</em> line <em>is</em> closed to <em>UART_SRX</em> [ <a href="">S7</a> ]; </li><li>  The performance of the solution obtained in the simulation mode was tested using Modelsim; </li><li>  performance on the hardware tested on the board Terasic DE10-Lite [ <a href="http://de10-lite.terasic.com/">L10</a> ]; </li><li>  As an example of working with the UART16550, two programs were written: 05_uart [ <a href="https://github.com/MIPSfpga/mipsfpga-plus/tree/5169e133ea2de692e8f9564896f46844ec5bb398/programs/05_uart">S8</a> ] and 08_uart_irq [ <a href="https://github.com/MIPSfpga/mipsfpga-plus/tree/5169e133ea2de692e8f9564896f46844ec5bb398/programs/08_uart_irq">S9</a> ]: after resetting, the uart (8n1, 115200) setting is performed, the greeting is sent, and the code of each received symbol is displayed on the LED and 7-segment indicators.  When launched on the board, each character received by uart is sent back; </li><li>  debugging of the developed module is available "in isolation" from the mipsfpga + code within the project [ <a href="https://github.com/zhelnio/ahb_lite_uart16550">L11</a> ]; </li><li>  For software configuration of the module, use the base project documentation, [ <a href="https://github.com/MIPSfpga/mipsfpga-plus/blob/5169e133ea2de692e8f9564896f46844ec5bb398/documentation/peripherals/UART_spec.pdf">D1</a> ].  I recommend to familiarize with it fluently to better understand the example given below; </li><li>  AHB-Lite bus operation is described in detail in [ <a href="https://github.com/zhelnio/memos/blob/master/public/02_mips_uart/doc/D2_MicroAptiv_UP_AHB_Lite_Interface_MD01082.pdf">D2</a> ]; </li></ul><br><h3 id="primer">  Example </h3><br><h4 id="poryadok-zapuska">  Start order </h4><br><ul><li><p>  check that the following setting [ <a href="">S3</a> ] is set in the file mfp_ahb_lite_matrix_config.vh: </p><br><pre> <code class="hljs">`define MFP_USE_DUPLEX_UART</code> </pre> <br></li><li>  go to the directory with the program: mipsfpga-plus / programs / 05_uart [ <a href="https://github.com/MIPSfpga/mipsfpga-plus/tree/5169e133ea2de692e8f9564896f46844ec5bb398/programs/05_uart">S8</a> ], or 08_uart_irq [ <a href="https://github.com/MIPSfpga/mipsfpga-plus/tree/5169e133ea2de692e8f9564896f46844ec5bb398/programs/08_uart_irq">S9</a> ]; </li><li><p>  in the main.c file install [ <a href="">S10</a> ]: </p><br><pre> <code class="hljs cs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> RUNTYPE SIMULATION</span></span></code> </pre> <br></li><li><p>  build the program and run it in the simulator: </p><br><pre> <code class="hljs css">02_<span class="hljs-selector-tag"><span class="hljs-selector-tag">compile_and_link</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.bat</span></span> 05_<span class="hljs-selector-tag"><span class="hljs-selector-tag">generate_verilog_readmemh_file</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.bat</span></span> 06_<span class="hljs-selector-tag"><span class="hljs-selector-tag">simulate_with_modelsim</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.bat</span></span></code> </pre> <br></li><li>  after the completion of the simulation script, press "no" to prevent the simulator from closing; </li><li>  how this code works "on hardware" can be seen on the capital gif-ke. </li></ul><br><h4 id="opisanie-programmy-i-konfiguracii-sistemy">  Program Description and System Configuration </h4><br><ul><li>  Since the example 08_uart_irq provides, in addition to setting up the UART16550 itself, the use of the interrupts generated by it, this configuration is discussed below; </li><li>  The directives for working with the registers of the controller are in the header file uart16550.h [ <a href="">S11</a> ]; </li><li><p>  At startup, the UART16550 setup [ <a href="">S12</a> ]: </p><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">void</span></span> uartInit(uint16_t divisor) { // <span class="hljs-number"><span class="hljs-number">8</span></span>n1 uart mode MFP_UART_LCR = MFP_UART_LCR_8N1; // Divisor Latches <span class="hljs-keyword"><span class="hljs-keyword">access</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enable</span></span> MFP_UART_LCR |= MFP_UART_LCR_LATCH; // Divisor LSB MFP_UART_DLL = divisor &amp; <span class="hljs-number"><span class="hljs-number">0xFF</span></span>; // Divisor MSB MFP_UART_DLH = (divisor &gt;&gt; <span class="hljs-number"><span class="hljs-number">8</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0xff</span></span>; // Divisor Latches <span class="hljs-keyword"><span class="hljs-keyword">access</span></span> <span class="hljs-keyword"><span class="hljs-keyword">disable</span></span> MFP_UART_LCR &amp;= ~MFP_UART_LCR_LATCH; //<span class="hljs-keyword"><span class="hljs-keyword">enable</span></span> Received Data available interrupt MFP_UART_IER = MFP_UART_IER_RDA; //<span class="hljs-keyword"><span class="hljs-keyword">set</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> byte Receiver FIFO Interrupt <span class="hljs-keyword"><span class="hljs-keyword">trigger</span></span> <span class="hljs-keyword"><span class="hljs-keyword">level</span></span> MFP_UART_FCR = MFP_UART_FCR_ITL4; }</code> </pre> <br></li><li><p>  setting interrupts [ <a href="">S13</a> ] (detailed in [ <a href="https://habrahabr.ru/post/324900/">L12</a> ]): </p><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">void</span></span> mipsInterruptInit(<span class="hljs-type"><span class="hljs-type">void</span></span>) { // Status.BEV <span class="hljs-number"><span class="hljs-number">0</span></span> - vector interrupt mode mips32_bicsr (SR_BEV); // Cause.IV, <span class="hljs-number"><span class="hljs-number">1</span></span> - special <span class="hljs-type"><span class="hljs-type">int</span></span> vector (<span class="hljs-number"><span class="hljs-number">0x200</span></span>) // <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-number"><span class="hljs-number">0x200</span></span> - base <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> others interrupts; mips32_biscr (CR_IV); // <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> IntCtl reg <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> uint32_t intCtl = mips32_getintctl(); // <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> interrupt <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> vector spacing (<span class="hljs-number"><span class="hljs-number">0x20</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> our <span class="hljs-keyword"><span class="hljs-keyword">case</span></span>) // see exceptions.S <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> details mips32_setintctl(intCtl | INTCTL_VS_32); // interrupt <span class="hljs-keyword"><span class="hljs-keyword">enable</span></span>, HW3 unmasked mips32_bissr (SR_IE | SR_HINT3); }</code> </pre> <br></li><li><p>  Interrupt processing involves checking that it is caused precisely by the presence of data in the incoming FIFO [ <a href="">S14</a> ]: </p><br><pre> <code class="hljs pgsql">// uart interrupt <span class="hljs-keyword"><span class="hljs-keyword">handler</span></span> <span class="hljs-type"><span class="hljs-type">void</span></span> __attribute__ ((interrupt, keep_interrupts_masked)) __mips_isr_hw3 () { // Receiver Data available interrupt <span class="hljs-keyword"><span class="hljs-keyword">handler</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(MFP_UART_IIR &amp; MFP_UART_IIR_RDA) uartReceive(); }</code> </pre> <br></li><li><p>  followed by their reading (until the FIFO is empty) and the output [ <a href="">S15</a> ]: </p><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">void</span></span> uartReceive(<span class="hljs-type"><span class="hljs-type">void</span></span>) { // <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> there something <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> receiver fifo? <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (MFP_UART_LSR &amp; MFP_UART_LSR_DR) { // data receive uint8_t data = MFP_UART_RXR; receivedDataOutput(data); #<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> RUNTYPE == HARDWARE uartTransmit(data); #endif } }</code> </pre> <br></li><li>  if the work goes on "hardware", then all the data is sent back [ <a href="">S16</a> ]: <br><pre> <code class="hljs haskell"><span class="hljs-title"><span class="hljs-title">void</span></span> uartTransmit(uint8_t <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class">) { // </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">waiting</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">for</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">transmitter</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fifo</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">empty</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">while</span></span></span><span class="hljs-class"> (!(</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MFP_UART_LSR</span></span></span><span class="hljs-class"> &amp; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MFP_UART_LSR_TFE</span></span></span><span class="hljs-class">)); // </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">data</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">transmit</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MFP_UART_TXR</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">data</span></span></span><span class="hljs-class">; }</span></span></code> </pre> </li><li><p>  Below is the result of the program.  Since when setting up the module we set the interrupt triggering mode after receiving 4 characters, the transmission is temporarily interrupted for reception.  The remaining characters were received by us after another similar interruption, but which was already caused not by the presence of 4 characters in the queue, and not by an empty queue and timeout (the controller realized that there would be no more characters and informed that the queue was not empty); </p><br><p><img src="https://habrastorage.org/files/ec5/9c7/a0f/ec59c7a0f8a24f74ba55ba2a5ef4f943.png" alt="image"></p><br></li><li><p>  for program 05_uart, reception is performed after the transfer is completed, all this time the received data is waiting in the receiver's FIFO: </p><br><p><img src="https://habrastorage.org/files/d2a/314/78f/d2a31478fb6241aa88cdb79617b48841.png" alt="image"></p><br></li></ul><br><h2 id="blagodarnosti">  Thanks </h2><br><p>  The author is grateful to the <a href="https://habrahabr.ru/post/259505/">team of translators of the</a> textbook by David Harris and Sarah Harris ‚ÄúDigital Circuit Design and Computer Architecture‚Äù, by <a href="https://www.imgtec.com/">Imagination Technologies</a> for the academic license for a modern processor core and personally for Yuri Panchul <a href="https://habrahabr.ru/users/yuripanchul/" class="user_link">YuriPanchul</a> for his work on promoting MIPSfpga. </p><br><h2 id="ssylki">  Links </h2><br><p>  [L1] - <a href="https://habrahabr.ru/post/259505/">Digital circuit design and computer architecture</a> ; <br>  [L2] - <a href="https://habrahabr.ru/post/275215/">How to start working with MIPSfpga</a> ; <br>  [L3] - <a href="https://github.com/MIPSfpga/mipsfpga-plus">MIPSfpga-plus project on github</a> ; <br>  [L4] - <a href="https://ru.wikipedia.org/wiki/%25D0%25A3%25D0%25BD%25D0%25B8%25D0%25B2%25D0%25B5%25D1%2580%25D1%2581%25D0%25B0%25D0%25BB%25D1%258C%25D0%25BD%25D1%258B%25D0%25B9_%25D0%25B0%25D1%2581%25D0%25B8%25D0%25BD%25D1%2585%25D1%2580%25D0%25BE%25D0%25BD%25D0%25BD%25D1%258B%25D0%25B9_%25D0%25BF%25D1%2580%25D0%25B8%25D1%2591%25D0%25BC%25D0%25BE%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B5%25D0%25B4%25D0%25B0%25D1%2582%25D1%2587%25D0%25B8%25D0%25BA">Wikipedia: UART</a> ; <br>  [L5] - <a href="https://ru.wikipedia.org/wiki/16550_UART">Wikipedia: UART16550</a> ; <br>  [L6] - <a href="https://www.google.ru/search%3Fq%3Duart%2B16550%2Bdatasheet%2Bfile%253Apdf">Google: UART16550</a> ; <br>  [L7] - <a href="https://github.com/freecores/uart16550">Project freecores / uart16550</a> ; <br>  [L8] - <a href="https://github.com/olofk/uart16550">Project olofk / uart16550</a> ; <br>  [L9] - <a href="http://opencores.org/project,uart16550">Opencores / UART 16550 core project</a> ; <br>  [L10] - <a href="http://de10-lite.terasic.com/">Terasic DE10-Lite FPGA board</a> ; <br>  [L11] - <a href="https://github.com/zhelnio/ahb_lite_uart16550">Project ahb_lite_uart16550</a> ; <br>  [L12] - <a href="https://habrahabr.ru/post/324900/">MIPSfpga and interrupts</a> ; </p><br><h2 id="dokumentaciya">  Documentation </h2><br><p>  [D1] - <a href="https://github.com/MIPSfpga/mipsfpga-plus/blob/5169e133ea2de692e8f9564896f46844ec5bb398/documentation/peripherals/UART_spec.pdf">UART IP Core Specification</a> ; <br>  [D2] - <a href="https://github.com/zhelnio/memos/blob/master/public/02_mips_uart/doc/D2_MicroAptiv_UP_AHB_Lite_Interface_MD01082.pdf">MIPS32 microAptiv UP Processor Core AHB-Lite Interface</a> ; </p><br><h2 id="izobrazheniya-i-tablicy">  Images and tables </h2><br><p>  [P1] - <a href="">Example operation on the debug board</a> ; <br>  [P2] - <a href="">Work in UART interrupt handling mode</a> ; <br>  [P3] - <a href="">Work by periodically polling the register</a> ; </p><br><h2 id="ssylki-na-ishodnyy-kod">  References to source code </h2><br><p>  [S1] - <a href="">Module mfp_ahb_lite_uart16550</a> ; <br>  [S2] - <a href="https://github.com/MIPSfpga/mipsfpga-plus/tree/5169e133ea2de692e8f9564896f46844ec5bb398/uart16550">Catalog mipsfpga-plus / uart16550</a> ; <br>  [S3] - <a href="">Option MFP_USE_DUPLEX_UART</a> ; <br>  [S4] - <a href="">Signals UART_SRX and UART_STX</a> ; <br>  [S5] - <a href="">Modem control interface</a> ; <br>  [S6] - <a href="">Interrupt signal connection</a> ; <br>  [S7] - <a href="">UART signals in simulation mode</a> ; <br>  [S8] - <a href="https://github.com/MIPSfpga/mipsfpga-plus/tree/5169e133ea2de692e8f9564896f46844ec5bb398/programs/05_uart">An example of the use of '05_uart'</a> ; <br>  [S9] - <a href="https://github.com/MIPSfpga/mipsfpga-plus/tree/5169e133ea2de692e8f9564896f46844ec5bb398/programs/08_uart_irq">An example of the use of '08_uart_irq'</a> ; <br>  [S10] - <a href="">Setting the mode of the example program</a> ; <br>  [S11] - <a href="">Header file uart16550.h</a> ; <br>  [S12] - <a href="">Software setting UART16550</a> ; <br>  [S13] - <a href="">Setting interrupts</a> ; <br>  [S14] - <a href="">UART interrupt handling</a> ; <br>  [S15] - <a href="">Reading received UART data</a> ; <br>  [S16] - <a href="">Return sending of received data</a> ; </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/325168/">https://habr.com/ru/post/325168/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../325140/index.html">The Institute of Software Engineering has opened access to the C ++ code design standard.</a></li>
<li><a href="../325144/index.html">Technical program PHDays: analysis of the HummingBad trojan, which is malware for macOS and attacks on the Java Card</a></li>
<li><a href="../325148/index.html">DUMP Developer Conference: Latest News and Final Program</a></li>
<li><a href="../325154/index.html">Frontera: crawl web framework architecture and current issues</a></li>
<li><a href="../325162/index.html">‚ÄúRuby is a great tool for me‚Äù</a></li>
<li><a href="../325170/index.html">Splunk + Check Point, an example of analyzing your firewall logs</a></li>
<li><a href="../325174/index.html">How I struggle with procrastination - and usually win</a></li>
<li><a href="../325176/index.html">We host a site in the interplanetary IPFS file system under Windows</a></li>
<li><a href="../325178/index.html">Memory optimization: difficult, but sometimes necessary</a></li>
<li><a href="../325184/index.html">DevOps in the service of man</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>