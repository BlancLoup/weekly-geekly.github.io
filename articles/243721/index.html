<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Using anonymous methods in Delphi</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The reason for writing this article was the interest in the possibilities of anonymous functions in Delphi. In various sources you can find their theo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Using anonymous methods in Delphi</h1><div class="post__text post__text-html js-mediator-article">  The reason for writing this article was the interest in the possibilities of anonymous functions in Delphi.  In various sources you can find their theoretical foundations, information about the internal structure, but here are some examples of the use of some trivial.  And many people ask questions: why do we need these <i>references</i> , what could be the use of their use?  Therefore, I propose some variants of using anonymous methods used in other languages, perhaps more oriented to a functional programming style. <br><a name="habracut"></a><br>  For simplicity and clarity, we consider operations on a numeric array, although the approach itself is applicable to any ordered containers (for example, TList &lt;T&gt;).  A dynamic array is not an object type, so we use a helper to extend its functionality.  The item type is Double: <br><br><pre><code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">uses</span></span> SysUtils, Math; <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> TArrayHelper = <span class="hljs-keyword"><span class="hljs-keyword">record</span></span> <span class="hljs-keyword"><span class="hljs-keyword">helper</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> TArray&lt;Double&gt; <span class="hljs-keyword"><span class="hljs-keyword">strict</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> TForEachRef = reference <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(X: Double; I: Integer; </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">var</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Done: Boolean)</span></span></span><span class="hljs-function">;</span></span> TMapRef = reference <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(X: Double)</span></span></span><span class="hljs-function">:</span></span> Double; TFilterRef = reference <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(X: Double; I: Integer)</span></span></span><span class="hljs-function">:</span></span> Boolean; TPredicateRef = reference <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(X: Double)</span></span></span><span class="hljs-function">:</span></span> Boolean; TReduceRef = reference <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Accumulator, X: Double)</span></span></span><span class="hljs-function">:</span></span> Double; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToString</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ForEach</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Lambda: TForEachRef)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Map</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Lambda: TMapRef)</span></span></span><span class="hljs-function">:</span></span> TArray&lt;Double&gt;; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Filter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Lambda: TFilterRef)</span></span></span><span class="hljs-function">:</span></span> TArray&lt;Double&gt;; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Every</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Lambda: TPredicateRef)</span></span></span><span class="hljs-function">:</span></span> Boolean; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Some</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Lambda: TPredicateRef)</span></span></span><span class="hljs-function">:</span></span> Boolean; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Reduce</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Lambda: TReduceRef)</span></span></span><span class="hljs-function">:</span></span> Double; <span class="hljs-keyword"><span class="hljs-keyword">overload</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Reduce</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Init: Double; Lambda: TReduceRef)</span></span></span><span class="hljs-function">:</span></span> Double; <span class="hljs-keyword"><span class="hljs-keyword">overload</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReduceRight</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Lambda: TReduceRef)</span></span></span><span class="hljs-function">:</span></span> Double; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br>  Most of the methods described below take a function as an argument and call it for each element (or several elements) of an array.  In most cases, a single argument is passed to the specified function: the value of the element in the array.  More advanced implementations are possible in which not only the value is transferred, but also the element index and the link to the array itself.  None of the methods change the original array, but the function passed to these methods can do this. <br><br><h5>  <b>ForEach method</b> </h5><br>  The ForEach method performs a traversal of array elements and calls the specified function for each of them.  As mentioned above, the function is passed to the ForEach method in the argument.  When calling this function, the ForEach method will pass to it the value of the array element, its index, as well as the Boolean variable Done, the assignment of which True will allow to interrupt the iterations and exit the method (analogous to the Break instruction for a normal for loop).  For example: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> A: TArray&lt;Double&gt;; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> A := [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>]; <span class="hljs-comment"><span class="hljs-comment">//       XE7 //      2 A.ForEach(procedure(X: Double; I: Integer; var Done: Boolean) begin A[I] := X * 2; if I = 1 then Done := True; //    ForEach end); WriteLn(A.ToString); // =&gt; [2, 4, 3] end;</span></span></code> </pre><br>  <i>Implementation of the ForEach method:</i> <br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TArrayHelper</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ForEach</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Lambda: TForEachRef)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> I: Integer; Done: Boolean; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Done := False; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> I := <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> High(Self) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Lambda(Self[I], I, Done); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Done <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  :     function TArrayHelper.ToString: string; var Res: TArray&lt;string&gt;; begin if Length(Self) = 0 then Exit('[]'); ForEach(procedure(X: Double; I: Integer; var Done: Boolean) begin Res := Res + [FloatToStr(X)]; end); Result := '[' + string.Join(', ', Res) + ']'; end;</span></span></code> </pre> <br><br><h5>  <b>Map method</b> </h5><br>  The Map method passes each element of the array for which it is called to the specified function, and returns an array of values ‚Äã‚Äãreturned by this function.  For example: <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> A, R: TArray&lt;Double&gt;; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> A := [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>]; <span class="hljs-comment"><span class="hljs-comment">//     R := A.Map(function(X: Double): Double begin Result := X * X; end); WriteLn(R.ToString); // =&gt; [1, 4, 9] end;</span></span></code> </pre><br>  The Map method calls the function in the same way as the ForEach method.  However, the function passed to the Map method must return a value.  Notice that Map returns a new array: it does not modify the original array. <br><br>  <i>Implementation of the Map method:</i> <br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TArrayHelper</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Map</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Lambda: TMapRef)</span></span></span><span class="hljs-function">:</span></span> TArray&lt;Double&gt;; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> X: Double; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> X <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Self <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> Result := Result + [Lambda(X)]; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br><h5>  <b>Filter Method</b> </h5><br>  The Filter method returns an array containing a subset of the elements of the original array.  The function passed to it must be a predicate function, since  must return true or false.  The Filter method calls the function in the same way as the ForEach and Map methods.  If True is returned, the element passed to the function is considered a member of the subset and added to the array returned by the method.  For example: <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Data: TArray&lt;Double&gt;; MidValues: TArray&lt;Double&gt;; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Data := [<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-comment"><span class="hljs-comment">//  ,  1,   5 MidValues := Data.Filter(function(X: Double; I: Integer): Boolean begin Result := (1 &lt; X) and (X &lt; 5); end); WriteLn(MidValues.ToString); // =&gt; [4, 3, 2] //  Data .Map(function(X: Double): Double begin Result := X + 5; //     5. end) .Filter(function(X: Double; I: Integer): Boolean begin Result := (I mod 2 = 0); //      end) .ForEach(procedure(X: Double; I: Integer; var Done: Boolean) begin Write(X:2:0) // =&gt; 10 8 6 end); end;</span></span></code> </pre><br>  <i>Implementing the Filter method:</i> <br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TArrayHelper</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Filter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Lambda: TFilterRef)</span></span></span><span class="hljs-function">:</span></span> TArray&lt;Double&gt;; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> I: Integer; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> I := <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> High(Self) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Lambda(Self[I], I) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> Result := Result + [Self[I]]; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br><h5>  <b>Every and Some methods</b> </h5><br>  The Every and Some methods are array predicates: they apply the specified predicate function to the elements of the array and return True or False.  The Every method resembles a mathematical quantifier of universality ‚àÄ: it returns True only if the predicate function you returned returned True for all elements of the array: <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> A: TArray&lt;Double&gt;; B: Boolean; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> A := [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2.7</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>]; B := A.Every(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(X: Double)</span></span></span><span class="hljs-function">:</span></span> Boolean <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Result := (X &lt; <span class="hljs-number"><span class="hljs-number">10</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>); WriteLn(B); <span class="hljs-comment"><span class="hljs-comment">// =&gt; True:   &lt; 10. B := A.Every(function(X: Double): Boolean begin Result := (Frac(X) = 0); end); WriteLn(B); // =&gt; False:     . end;</span></span></code> </pre><br>  The Some method resembles a mathematical existence quantifier ‚àÉ: it returns True if there is at least one element in the array for which the predicate function returns True, and the False value is returned by the method only if the predicate function returns False for all array elements: <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> A: TArray&lt;Double&gt;; B: Boolean; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> A := [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2.7</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>]; B := A.Some(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(X: Double)</span></span></span><span class="hljs-function">:</span></span> Boolean <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Result := (Frac(X) = <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>); WriteLn(B); <span class="hljs-comment"><span class="hljs-comment">// =&gt; True:     . end;</span></span></code> </pre><br>  <i>Implementing the Every and Some methods:</i> <br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TArrayHelper</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Every</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Lambda: TPredicateRef)</span></span></span><span class="hljs-function">:</span></span> Boolean; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> X: Double; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Result := True; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> X <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Self <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> Lambda(X) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Exit</span></span>(False); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TArrayHelper</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Some</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Lambda: TPredicateRef)</span></span></span><span class="hljs-function">:</span></span> Boolean; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> X: Double; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Result := False; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> X <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Self <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Lambda(X) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Exit</span></span>(True); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br>  Note that both methods, Every and Some, stop traversing the elements of the array as soon as the result becomes known.  The Some method returns True as soon as the predicate function returns True, and performs a crawl of all array elements only if the predicate function always returns False.  The Every method is the exact opposite: it returns False as soon as the predicate function returns False, and performs a traversal of all array elements only if the predicate function always returns True.  In addition, note that in accordance with the rules of mathematics for an empty array, the Every method returns True, and the Some method returns False. <br><br><h5>  <b>Reduce and ReduceRight methods</b> </h5><br>  The Reduce and ReduceRight methods combine the elements of an array using the function you specify, and return a single value.  This is a typical operation in functional programming, where it is also known as convolution.  The examples below will help to understand the essence of this operation: <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> A: TArray&lt;Double&gt;; Total, Product, Max: Double; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> A := [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>]; <span class="hljs-comment"><span class="hljs-comment">//   Total := A.Reduce(0, function(X, Y: Double): Double begin Result := X + Y; end); WriteLn(Total); // =&gt; 15.0 //   Product := A.Reduce(1, function(X, Y: Double): Double begin Result := X * Y; end); WriteLn(Product); // =&gt; 120.0 //   (   Reduce) Max := A.Reduce(function(X, Y: Double): Double begin if X &gt; Y then Exit(X) else Exit(Y); end); WriteLn(Max); // =&gt; 5.0 end;</span></span></code> </pre><br>  The Reduce method takes two arguments.  In the second, a function is passed that performs the convolution operation.  The task of this function is to combine in some way or collapse two values ‚Äã‚Äãinto one to return the collapsed value.  In the examples above, the functions are performed by combining two values, adding them, multiplying and choosing the largest.  The first argument is the initial value for the function. <br><br>  The functions passed to the Reduce method are different from the functions passed to the ForEach and Map methods.  The value of the array element is passed to them in the second argument, and in the first argument the accumulated result of the convolution is passed.  The first call in the first argument of the function is passed the initial value passed to the Reduce method in the first argument.  In all subsequent calls, the value resulting from the previous function call is transmitted.  In the first example, from the above, the convolution function will first be called with arguments 0 and 1. It adds these numbers and returns 1. Then it is called with arguments 1 and 2 and returns 3. Then it will calculate 3 + 3 = 6, then 6 + 4 = 10 and, finally, 10 + 5 = 15. This last value 15 will be returned by the Reduce method. <br><br>  In the third call, in the example above, a single argument is passed to the Reduce method: the initial value is not specified here.  This alternative implementation of the Reduce method uses the first element of the array as the initial value.  This means that when the convolution function is first called, the first and second arguments of the array will be passed.  In the examples of calculating the sum and product, in the same way one could apply this alternative implementation of Reduce and omit the argument with the initial value. <br><br>  Calling the Reduce method with an empty array without an initial value will cause an exception.  If you call a method with a single value ‚Äî with an array containing a single element, and without an initial value or with an empty array and an initial value ‚Äî it simply returns that single value without calling the convolution function. <br><br>  <i>Implementing Reduce methods:</i> <br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TArrayHelper</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Reduce</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Init: Double; Lambda: TReduceRef)</span></span></span><span class="hljs-function">:</span></span> Double; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> I: Integer; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Result := Init; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Length(Self) = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Exit</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> I := <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> High(Self) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> Result := Lambda(Result, Self[I]); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   Reduce ‚Äì    function TArrayHelper.Reduce(Lambda: TReduceRef): Double; var I: Integer; begin Result := Self[0]; if Length(Self) = 1 then Exit; for I := 1 to High(Self) do Result := Lambda(Result, Self[I]); end;</span></span></code> </pre><br>  The ReduceRight method works in the same way as the Reduce method, except that the array is processed in the reverse order, from large indices to smaller ones (from right to left).  This may be necessary if the convolution operation is associative from right to left, for example: <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> A: TArray&lt;Double&gt;; Big: Double; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> A := [<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>]; <span class="hljs-comment"><span class="hljs-comment">//  2^(3^4). //         Big := A.ReduceRight(function(Accumulator, Value: Double): Double begin Result := Math.Power(Value, Accumulator); end); Writeln(Big); // =&gt; 2.41785163922926E+0024 end;</span></span></code> </pre><br>  <i>Implementation of the ReduceRight method:</i> <br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TArrayHelper</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReduceRight</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Lambda: TReduceRef)</span></span></span><span class="hljs-function">:</span></span> Double; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> I: Integer; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Result := Self[High(Self)]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Length(Self) = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Exit</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> I := High(Self) - <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">downto</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> Result := Lambda(Result, Self[I]); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br>  It should be noted that the Every and Some methods described above are a peculiar kind of array convolution operation.  However, they differ in that they seek to complete the traversal of the array as early as possible and do not always check the values ‚Äã‚Äãof all its elements. <br><br><h5>  <b>Instead of conclusion</b> </h5><br>  Consider another example of using anonymous methods.  Suppose we have an array of numbers and we need to find the mean and standard deviation for these values: <br><br><pre> <code class="delphi hljs"><span class="hljs-comment"><span class="hljs-comment">//  :   . //   (   )   //     ,  reference- function Sum(X, Y: Double): Double; begin Result := X + Y; end; //    (Mean)   (StdDev). procedure MeanAndStdDev; var Data: TArray&lt;Double&gt;; Mean, StdDev: Double; begin Data := [1, 1, 3, 5, 5]; Mean := Data.Reduce(Sum) / Length(Data); StdDev := Sqrt(Data .Map(function(V: Double): Double begin Result := Sqr(V - Mean); //   end) .Reduce(Sum) / Pred(Length(Data))); WriteLn('Mean: ', Mean, ' StdDev: ', StdDev); // =&gt; Mean: 3.0 StdDev: 2.0 end;</span></span></code> </pre><br>  <a href="https://yadi.sk/d/EAoVP2dmcw433">Sources</a> <br><br>  The article has been improved thanks to your comments. <br><br>  And here is the <a href="http://habrahabr.ru/post/244945/">continuation</a> , which is devoted to closures and higher order functions. </div><p>Source: <a href="https://habr.com/ru/post/243721/">https://habr.com/ru/post/243721/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../243707/index.html">What I learned from C # /. Net developers at the Go conference #</a></li>
<li><a href="../243711/index.html">"English Lessons": Habrahabr vs Geektimes</a></li>
<li><a href="../243713/index.html">Flow - static type analysis in JS from Facebook</a></li>
<li><a href="../243715/index.html">Tomorrow at 10:00 (MSK), watch the Russian App Day conference broadcast</a></li>
<li><a href="../243719/index.html">Step-by-step modification of the preset Bacula setting</a></li>
<li><a href="../243723/index.html">Gov.uk: basic aspects of the agile methodology</a></li>
<li><a href="../243725/index.html">Cooling server. Divide and rule</a></li>
<li><a href="../243727/index.html">Just backup btrfs</a></li>
<li><a href="../243731/index.html">Update on Android 5 Lolipop kills self-signed applications without the possibility of recovery</a></li>
<li><a href="../243733/index.html">The Seven Laws of the Jedi Freelancer</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>