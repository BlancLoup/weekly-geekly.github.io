<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Description of Google AI challenge (Ants)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="At Habr√© there is already a lot of information on this contest, but all of it covers specific points of implementation, but not the picture as a whole...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Description of Google AI challenge (Ants)</h1><div class="post__text post__text-html js-mediator-article"><img src="http://xmages.net/storage/10/1/0/4/9/upload/125c242d.png" alt="image"><br>  At Habr√© there is already a lot of information on this contest, but all of it covers specific points of implementation, but not the picture as a whole.  I will try to correct this situation as briefly as possible, but in general. <br>  This description is intended for those who have heard something about this event, but all the desire to do something has repelled the need to understand the intricacies of the implementation.  The post consists partly of the translation of materials from the official site, partly of an analysis of the strategies of other bots and pure logic.  Also at the end of the post will be a link to the PHP bot (slightly more complicated than from the starter-pack), which will allow you to try your own strength by adding the existing code.  Official site of the contest: <a href="http://aichallenge.org/">aichallenge.org</a> <br><a name="habracut"></a><br><br><h4>  The main components of the ant colony strategy are: </h4><br><h5>  1. Passive </h5><br><h6>  1.1.  Collecting food (food) and replenishing the colony (spawn) </h6><br><ul><li>  Food appears symmetrically and at the same time for each colony, so that the conditions for all bots are always equivalent (maps are also generated symmetrical). </li><li>  Each collected food is added to the colony's ‚Äúvault‚Äù and, at the earliest opportunity, becomes a new ant. </li><li>  There is a parameter spawnradius, which is always equal to 1, that is, the ant appears in the cell where the anthill is located. </li><li>  To collect food, you need to bring the ant to the next orthogonal cell with it (not diagonal). </li><li>  The cage itself with food is not passable, that is, if the ant is standing still and food appears next to it, it cannot go to this cage.  You just need to leave it on this cage for one move, and then the food will be collected. </li><li>  Only 1 ant per 1 move in 1 anthill can appear.  If more food was collected for the previous move than there are free anthills, then a new ant will appear with a delay. </li><li>  If an ant has remained on the anthill's cage from the previous turn, then it is considered blocked and new ants do not appear. </li><li>  If two warring ants try to take food at the same time, then it disappears (no one gets it). </li><li>  If there are several anthills and enough food has been collected, then one ant appears in each anthill.  If there is not enough food, the priority is to appear in anthills where the ants did not appear the longest, then not blocked anthills, and then randomly. </li><li>  At the beginning of each game, 2‚Äì5 meals always appear near the anthills within sight. </li><li>  The number of appearing food is gradually increasing (this parameter is not available to the bot) and depends on the number of remaining bots (respectively, it also appears symmetrically). </li></ul><br><br><h6>  1.2.  Protection of the nest (hill) </h6><br><ul><li>  The exit from the anthill for a new ant can always be only in 4 directions, respectively, the ants protecting the anthill are best located in diagonal cells. </li><li>  An anthill is considered destroyed if one of the enemy ants successfully descends on its cage. </li><li>  One of the main elements of the strategy (see below) is the destruction of enemy anthills, so the factor of protection of the anthill is very important.  He is absent in almost all bots (even top ones). </li></ul>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h6>  1.3.  Intelligence and territory control </h6><br>  Since under the conditions the mechanism of scope is implemented (see below), the bot does not know which card is in front of it, and receives information only about the objects that fall within the scope of its ants.  In most cases, control of the territory is not required, with the exception of approaching enemies to anthills.  The ideal location of ants is the algorithm in which they open the maximum field of view, and all unused ants are sent to the "task" to destroy enemy anthills (push).  Accordingly, the maintenance of an open map has the main purpose in the collection by scouts of all food that comes across in the field of visibility. <br><br><h5>  2. Active </h5><br><h6>  2.1.  Extermination of enemy ants </h6><br>  The calculation of the "attack" occurs in general according to a simple rule: <br>  It is considered the difference between the forces of enemies and their own; if they are equal, everyone dies, otherwise someone dies weaker and the strong survive. <br>  By ‚Äúpower‚Äù is meant how many ants have this cage (where the ant is located) in the radius of their attack.  Simply put, if one ant is in the attack range of two, then it dies, but they do not.  2x2 - all die, and so on.  It is understood that the ant attacks all the ants in all the cells within the attack radius at once. <br><br>  Warning: although water is not a passable cage, an attack through it is also considered, that is, two ants from different sides of the water cage will kill each other. <br>  Technical side: <br>  Information about the enemy ants is transmitted to the bot every turn, but the disappearance of the enemy ant from the input data can mean a situation of death as well as a situation of disappearance from the field of visibility.  The first situation is sometimes monitored by analyzing data about the dead (dead), however, the ant could die from another ant and at the boundary of the field of view.  This complicates the implementation of tracking the actions of each individual enemy ant, and although it may provide some benefit in calculating the enemy‚Äôs approximate actions, its implementation is not so important. <br><br><h6>  2.2.  Extermination of enemy anthills </h6><br>  It is one of the main ways to achieve victory.  Without an anthill, a colony does not produce new ants, but those who are still alive continue to fight. <br>  Technical side: <br>  As well as information about enemy ants, information about all (including yours) anthills is transmitted every turn.  That is, you can also not get information about an anthill if it disappeared from view or was erased.  However, anthills can not move and are not reflected in the dead logs.  So it makes sense to store information about the detected anthills, however, if they were not found in the next log, but are in view, then mark them as destroyed. <br>  Accordingly, it allows you to direct ants to an enemy anthill, even if it has disappeared from scope. <br>  Most bots do not implement anthill protection; therefore, it is not uncommon for a ‚Äústray‚Äù ant to essentially defeat simply by destroying a defenseless anthill and thus leaving the bot without reinforcement. <br><br><h6>  Phase of the move (step) </h6><br>  All calculations are made in the following order: <br><ol><li>  Move </li><li>  Attack </li><li>  Anthill destruction (raze) </li><li>  Gather food </li><li>  The emergence of new ants and food (spawn) </li></ol><br><br>  Small comments based on this logic: <br><ul><li>  Food and ants always appear last, that is, you cannot collect food that has just appeared (only on the next move). </li><li>  The calculation of the attack always takes place after the movements of the current turn, and not on the basis of the position in the last move. </li><li>  New ants appear only if the anthill was not destroyed this turn. </li></ul><br>  With each move, the following information is transmitted to the bot (water, ants, anthills, dead ants, food, turn number).  All this you can find in the bot's input logs. <br><br><h6>  Scope and situation tracking </h6><br>  The anthill itself has no scope, that is, if there is not one ant next to it, the appearance of the enemy over your anthill will be an unpleasant surprise for you. <br>  At the start of the bot, the configuration of the current map is transferred, which also shows the scope, attack and spawn.  It is the square of hippotenuse between two cells (the square was chosen in order to preserve the whole value). <br>  Standard options: <br>  visibility - 55 (radius about 7 cells), <br>  attack - 5 (radius of about 2 cells). <br>  spawn - 1 (current cell). <br>  Since the incoming data reflects only the situation (changes) on a given move, the following approach is taken for practice: <br><ul><li>  Initially, the entire map is filled with earth, and when ‚Äúwater‚Äù appears in the logs, the map is corrected. </li><li>  All other data are considered dynamic, however, and they can be controlled.  The approach to controlling anthills and enemy ants was described above. </li><li>  Tracking your ants is much easier: </li><li>  Ensure that the ant does not go in with the same ant in the same cell (this leads to the death of both). </li><li>  With each move update the list of their ants based on the log of "dead ants". </li><li>  Updating of ants' objects (their coordinates) is easily realized on the basis of storage in the object of the cell coordinates, where the ant was ordered, respectively, he died there, or moved into this cell. </li><li>  Take into account that the move to a blocked cell (with food or water) is not given. </li><li> The map is cyclically closed on the sides, which is important to consider when calculating coordinates and areas of visibility. </li><li>  If the one who was not ‚Äúupdated‚Äù from the previous move is found in the input list of his ants, then this is a new ant. </li></ul><br><br><h6>  Defeat conditions </h6><br><ol><li>  All bot ants are dead. </li><li>  The bot crashed. </li><li>  The bot is frozen (timeout). </li><li>  The bot is trying to execute code that is prohibited by the rules of the contest. </li></ol><br>  Once again, I note that the loss of all anthills is not a defeat, the bot continues to fight until the loss of all ants. <br>  Important point: <br>  If the enemy bot has flown or frozen, its ants remain on the battlefield, but do not receive commands.  This is not reported in any way to other players who continue to receive information in its previous form.  In this regard, it is even possible to implement an algorithm that monitors ‚Äúcollapsed‚Äù players (this is rare, but it happens), so as not to waste their own army on them or ‚Äúcarry out‚Äù them given that they are immobilized, which is very easy to do. <br><br><h6>  Calculation of points per game </h6><br>  Each bot starts with 1 point for each anthill. <br>  Destroy the enemy anthill +2 points. <br>  The loss of the anthill -1 points. <br>  If there is only one bot left and not all enemy anthills are destroyed (but all enemy ants or other bots are killed, ‚Äústuck‚Äù or ‚Äúfell‚Äù), then for each remaining enemy anthill, the bot gets points, as if he had destroyed it, that is, +2 and -1 owners anthills. <br><br><h5>  Constituent elements of strategies </h5><br><h6>  1. Movement, finding the way to the point, choosing goals </h6><br>  The usual priority goals: first food, then the enemy anthills, then the enemies. <br>  The simplest pathfinding algorithm is <a href="http://ru.wikipedia.org/wiki/%25D0%259F%25D0%25BE%25D0%25B8%25D1%2581%25D0%25BA_%25D0%25B2_%25D1%2588%25D0%25B8%25D1%2580%25D0%25B8%25D0%25BD%25D1%2583">a wider search</a> , or a bit more complicated than <a href="http://ru.wikipedia.org/wiki/%25D0%2590%25D0%25BB%25D0%25B3%25D0%25BE%25D1%2580%25D0%25B8%25D1%2582%25D0%25BC_%25D0%25BF%25D0%25BE%25D0%25B8%25D1%2581%25D0%25BA%25D0%25B0_A*">A *</a> .  The most primitive and fast way can be considered the choice of direction for movement based on reducing the difference in coordinates (such a mechanism is implemented in starter-packs), but of course it gives many failures (for example, if the target is on the other side). <br>  Finding paths is one of the most resource-intensive operations in calculating the course (even analyzing actions on average is easier), so the choice and implementation of the algorithm greatly influences the final result of the bot's work.  Accordingly, there are more opportunities for those bots whose performance is higher (you understood correctly, the entire top is written in C, C ++ and Java). <br>  The main priority in the absence of targets nearby is best to consider the area out of sight, it is best to cause the ants to ‚Äúcrawl‚Äù around the map.  As soon as an enemy anthill is discovered, all new ants (or their percentage) can be sent by chain to storm it, and then again to reconnoiter.  Control over the scope and movement to the undiscovered areas will allow ants to be evenly distributed over the space of the map without arranging gatherings that are needed only when pushing the enemy. <br>  Of the useful techniques, blocking is for cells that have water from 3 sides (there is almost no practical sense in such cells), which can be done while analyzing the map and storing such cells in memory. <br>  The same applies to dead-end "single-celled" tunnels, but for them to make an exception if there is a goal (for example, food). <br>  A useful element is sometimes the preservation of the ‚Äúlast priority direction‚Äù when he prefers to move to one of the parties at the first opportunity so that the bot does not unfold every obstacle, then he will maintain the course. <br><br><h6>  3. Defense and attack </h6><br>  In general, the mechanism of attack is quite obvious.  Approximate moves of the enemy are calculated (for example, taking into account the fact that its priority goals are the same as yours: food, other anthills, enemies), the "force map" of the enemy is then calculated, and after that, the moves of your ants are calculated taking into account the enemy's card and priority goals, that is, which move provides your ant as close as possible to the target with a margin of ‚Äúforces‚Äù in the cage in your direction.  This is a rather complicated algorithm, since it is necessary to calculate various combinations of movements of several ants at the same time, but it is quite realizable, since large ‚Äúfronts‚Äù are quite rare, most often these are separate collisions. <br>  As a result, the ants will move to the goal (an ant-hill or an enemy) as if ‚Äúas carefully as possible‚Äù, thereby destroying the enemy as much as they can. <br>  There is no perfect solution, because most cases are ambiguous and even ‚Äúrandom‚Äù, but this is already enough to minimize your losses. <br>  Also, as already mentioned, you should not forget about the protection of your own anthill, where you can leave 2-4 "guards" in the diagonal cells, which will also collect food next to you. <br><br><h5>  Examples of these strategies can be found in the competition top. </h5><br>  <a href="http://aichallenge.org/profile.php%3Fuser%3D398">Greentea</a> <br>  <a href="http://aichallenge.org/profile.php%3Fuser%3D765">Momobot</a> <br>  <a href="http://aichallenge.org/profile.php%3Fuser%3D31">Flagcapper</a> <br>  Some games are interesting enough to see, especially knowing that these are bots. <br><br><h5>  PHP bot for priming </h5><br>  The bot is almost rewritten from scratch in OOP format.  It is much more convenient to try different behavioral strategies (for example, each ant is stored in a separate object), so you can just do $ ant-&gt; stay () or $ ant-&gt; doMove ().  There are few comments in the code, there are pieces of unused test functions, but quite readable. <br>  The overall strategy of the bot: just wander around the map, collect food, avoid enemies, and at the first opportunity cowardly destroy enemy anthills.  Enough to stay in the ranking of approximately 50-60 positions (max skill 49).  Accordingly, the bots from the starter-pack, he beats easily.  Further already at your discretion.  Just for fun. <br>  <a href="http://narod.ru/disk/29185754001/MyBot.zip.html">Download bot from Yandex</a> <br><br><h5>  Debug bot </h5><br>  The official site does not describe how exactly it is best to debug the bot. <br>  In the standard pack'e (tools), the <b>play_one_game_live.sh</b> file is used to view bot games. <br>  in which you must specify the address to your bot.  This is spelled out in detail in the topic of <a href="http://habrahabr.ru/blogs/sport_programming/130582/">writing a bot for the Google AI Challenge.</a>  <a href="http://habrahabr.ru/blogs/sport_programming/130582/">Fast start.</a>  .  To this it is worth adding that no messages will be displayed in the console and logs about the reasons for the bot's failure (crushed).  To do this, you need to slightly change the <b>play_one_game_live.sh</b> file by adding keys to run the script (replacing <b>So</b> with <b>SoeEIO</b> ): <br> <code>./playgame.py -SoeEIO --player_seed 42 --end_wait=0.25 --verbose --log_dir game_logs ..... <br></code> <br>  Now, all information about what happens during the game will be output to the console, and to the logs in the <b>game_logs</b> directory (including errors of bot actions, like a double move for one ant).  This information should be enough to analyze the bot. <br>  In order to better understand the technical side (specifications), it is best to ‚Äúdig‚Äù start-packs for an interesting language.  In general, for the beginning they are quite enough. <br><br><h5>  As a conclusion </h5><br>  The proposed "battlefield" bots turned out very interesting for those who like to practice algorithms.  Of course, I would like to see more of our players in the top of this contest, which is why this article was written.  Good luck in creating your own artificial anthill. </div><p>Source: <a href="https://habr.com/ru/post/131262/">https://habr.com/ru/post/131262/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../131254/index.html">Nokia N9 production process</a></li>
<li><a href="../131255/index.html">Steve Jobs, the fundamentals of success</a></li>
<li><a href="../131256/index.html">Hubot: a universal CoffeeScript bot from Github developers</a></li>
<li><a href="../131257/index.html">Social and corporate network for the education system. History of creation and development</a></li>
<li><a href="../131259/index.html">Java developers will gather in Odessa at Ciklum Java Subbotnik!</a></li>
<li><a href="../131263/index.html">Is there any benefit from custom kernels?</a></li>
<li><a href="../131264/index.html">The tale of Box2D, Canvas, Twitter, and how the hell is connected</a></li>
<li><a href="../131265/index.html">Integration of Russian words stemming algorithm in fts3 SQLite</a></li>
<li><a href="../131267/index.html">Final Opera Startup Awards</a></li>
<li><a href="../131268/index.html">Chatting with Juha Ruohonen - the main coach at the Aalto Venture Garage</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>