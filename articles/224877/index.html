<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Scale Elasticsearch using a cluster with indexes of several terabytes</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Low search engine speed 
 Working on the social information search engine ( ark.com ), we opted for Elasticsearch, since it was very easy to configure...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Scale Elasticsearch using a cluster with indexes of several terabytes</h1><div class="post__text post__text-html js-mediator-article"><h3>  Low search engine speed </h3><br>  Working on the social information search engine ( <a href="https://ark.com/">ark.com</a> ), we opted for Elasticsearch, since it was very easy to configure and use, it had excellent search capabilities and, in general, looked like manna from heaven.  And so it was, until our index grew to more or less decent size of ~ 1 billion documents, the size with the replicas already exceeded 1.5 TB. <br><br>  Even a banal <code>Term query</code> could take tens of seconds.  Documentation on ES is not as much as we would like, and googling of this issue gave out the results of 2 years ago on completely irrelevant versions of our search engine (we work from 0.90.13 - which is also not quite an old thing, but we cannot afford omit the entire cluster, update it, and restart it at the current moment - only rolling restarts). <br><br><h3>  Low indexing speed </h3>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The second problem is that we index more documents per second (about 100k) than Elasticsearch can handle.  Timeouts, huge load on Write IO, queues from processes of 400 units.  Everything looks very scary when you look at it in Marvel. <br><br>  How to solve these problems - under the cut <br><a name="habracut"></a><br><h4>  Scale Elasticsearch Cluster </h4><br><br>  <b>Initial situation:</b> <br><br><ul><li>  5 data nodes, http enabled: <br><ul><li>  100 GB RAM </li><li>  16 cores </li><li>  4 TB HDD (7200 RPM, seagate) </li></ul><br></li><li>  Indices: <br><ul><li>  from 500 to 1 billion documents, only 5 pieces </li><li>  the number of primary shards is from 50 to 400 (here we tested different indexing strategies - this setting is very important) </li><li>  replicas - from 2 to 5 </li><li>  index size up to 1.5 terabytes </li></ul><br></li></ul><br><br>  <b>Increase indexing speed in Elasticsearch</b> <br><br>  This problem was not so complicated, and there is a little more information on the Internet about it. <br><br>  Checklist to check: <br><ul><li>  <code>refresh_interval</code> - how often the search data is updated, the more often, the more Write IO you need </li><li>  <code>index.translog.flush_threshold_ops</code> - after how many operations to dump data to disk </li><li>  <code>index.translog.flush_threshold_size</code> - how much data should be added to the index before dumping to disk </li></ul><br><br>  Detailed documentation here: <a href="http://www.elasticsearch.org/guide/en/elasticsearch/reference/current/indices-update-settings.html">www.elasticsearch.org/guide/en/elasticsearch/reference/current/indices-update-settings.html</a> <br><br>  First of all, we increased the refresh_interval to 30 seconds, and actually increased the bandwidth to almost 5,000 documents per second.  Later they set flush_threshold_ops in 5000 operations, and the size is up to 500 mb.  If you want, you can play around with the number of replicas, shards, and so on, but this will not make so much difference.  Also pay attention to the threadpool, if you need to increase the number of parallel requests to the database, although most often this is not required. <br><br>  <b>Increasing the speed of requests in Elasticsearch</b> <br><br>  Now go to the difficult part.  Knowing the size of our index and the constant needs to restart the cluster (version updates, maintenans machines), and also taking into account posts like this: <a href="http://gibrown.wordpress.com/2014/02/06/scaling-elasticsearch-part-2-indexing/">gibrown.wordpress.com/2014/02/06/scaling-elasticsearch-part-2-indexing</a> we decided that the size of the shard in our index will not exceed 1-2 GB.  With RF3, our index (we count on 1.5 billion documents), considering that 0.5 billion of our documents occupy about 300 GB excluding replicas, we created <b>400</b> shards in the index and decided that everything will be fine - the reboot speed will be enough high: we will not need to read data blocks of 50-60 GB, as well as replicate them, thus blocking the recovery of small shards, and the search speed for small shards is higher. <br><br>  At first, the number of documents in the index was small (100‚Äì200 million) and the query speed was only 100‚Äì200 ms.  But as soon as almost all shards were filled with at least a small number of documents, we began to lose significantly in query performance.  Combining all this with a high load on IO due to constant indexing, we could not do it at all. <br><br>  In this case, we made 2 mistakes: <br><br>  1. Created a lot of shards (ideal situation 1 core - 1 shard) <br>  2. Our date nodes were also balancers with http enabled - serialization and deserialization of data takes a lot of time <br><br>  Therefore, we began to experiment. <br><br>  <b>Add balancers to Elaticsearch</b> <br><br>  The first and obvious step for us was the addition of the so-called <code>balancer nodes</code> in Elasticsearch.  They can aggregate the results of queries on other shards, they will never be overloaded with IO, since they do not read and write to the disk, and we will unload our data nodes. <br><br>  For deployment we use chef and the corresponding elasticsearch cookbook, therefore creating only a couple of additional roles with the following settings: <br><br><pre> <code class="ruby hljs">name <span class="hljs-string"><span class="hljs-string">"elasticsearch-balancer"</span></span> description <span class="hljs-string"><span class="hljs-string">"Installs and launches elasticsearch"</span></span> default_attributes( <span class="hljs-string"><span class="hljs-string">"elasticsearch"</span></span> =&gt; { <span class="hljs-string"><span class="hljs-string">"node"</span></span> =&gt; { <span class="hljs-string"><span class="hljs-string">"master"</span></span> =&gt; <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-string"><span class="hljs-string">"data"</span></span> =&gt; <span class="hljs-literal"><span class="hljs-literal">false</span></span> } } ) run_list(<span class="hljs-string"><span class="hljs-string">"services::elasticsearch"</span></span>)</code> </pre><br><br>  We safely launched 4 balancers.  The picture improved a little - we no longer observed overloaded nodes with steaming hard drives, but the query speed was still low. <br><br>  <b>Increasing the number of data nodes in Elasticsearch</b> <br><br>  Now we remembered that the number of shards that we had (400) does not in any way affect the performance improvement, but only aggravates it, since too many shards are on one machine.  After simple calculations, we get that 5 machines will adequately support only 80 shards.  Given the number of replicas, then we have them in general 1200. <br><br>  Since our total fleet of cars (80 nodes) allows the addition of a sufficiently large number of nodes and the main problem in them is the size of the HDD (128GB in total), we decided to add about 15 machines at once.  This will allow you to work with another 240 shards more efficiently. <br><br>  In addition, we stumbled upon a few interesting settings: <br><br>  * <code>index.store.type</code> - by default it is set to niofs, and on benchmarks performance is lower than that of mmapfs - we switched it to mmapfs (default value is 1.x) <br>  * <code>indices.memory.index_buffer_size</code> - increased to 30%, and the amount of RAM for Java Heap, on the contrary, was reduced to 30 GB (it was 50%), since with mmapfs we need much more RAM for the operating system cache <br><br>  And of course, in our case it was necessary to enable the setting of control over the location of shards on the basis of free space: <br><br><pre> <code class="hljs swift">curl -<span class="hljs-type"><span class="hljs-type">XPUT</span></span> localhost:<span class="hljs-number"><span class="hljs-number">9200</span></span>/_cluster/settings -d '{ <span class="hljs-string"><span class="hljs-string">"transient"</span></span> : { <span class="hljs-string"><span class="hljs-string">"cluster.routing.allocation.disk.threshold_enabled"</span></span> : <span class="hljs-literal"><span class="hljs-literal">true</span></span> } }'</code> </pre><br><br>  After a couple of days of transferring the shards and restarting the old servers with the new settings, we conducted tests and <b>not cached</b> queries (Term Query, not filters) were performed for no more than 500 ms.  This situation is still not perfect, but we see that adding a date node and adjusting the number of cores to the number of shards corrects the situation. <br><br>  <b>What else should be considered when scaling a cluster</b> <br><br>  When rolling cluster restarting, be sure to turn off the ability to transfer shards: <code>cluster.routing.allocation.enable = none</code> , in older versions there is a slightly different setting. <br><br>  If you have any questions during the reading - I will be glad to discuss. </div><p>Source: <a href="https://habr.com/ru/post/224877/">https://habr.com/ru/post/224877/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../224867/index.html">Why did we choose Bitbucket for code review, not GitHub?</a></li>
<li><a href="../224869/index.html">The future of Ethernet & FC</a></li>
<li><a href="../22487/index.html">What is missing is Flash video and audio players</a></li>
<li><a href="../224871/index.html">The electronic cigarette will count every puff</a></li>
<li><a href="../224875/index.html">Feature # 2 - Podcast on entrepreneurs and current trends in the IT ecosystem</a></li>
<li><a href="../224879/index.html">Anemic Domain Model [Translation]</a></li>
<li><a href="../22488/index.html">Zemanta - service for bloggers</a></li>
<li><a href="../224881/index.html">Case for increasing online store conversion by 14% with product reviews</a></li>
<li><a href="../224883/index.html">Kerio Control for Windows to Kerio Control Appliance Migration Guide</a></li>
<li><a href="../224889/index.html">Google maps clustering</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>