<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We write a simple interpreter in C ++ using TDD, part 1</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 

 Many C ++ programmers have heard about development through testing. But almost all materials on this topic are related to higher-level...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We write a simple interpreter in C ++ using TDD, part 1</h1><div class="post__text post__text-html js-mediator-article"><h4>  Introduction </h4><br><img src="https://habrastorage.org/files/892/629/ee9/892629ee922945d1b75be0703d604e7a.png"><br>  Many C ++ programmers have heard about development through testing.  But almost all materials on this topic are related to higher-level languages ‚Äã‚Äãand focus more on the general theory than in practice.  So, in this article I will try to give an example of step-by-step development through testing a small C ++ project.  Namely, as the name suggests, a simple interpreter of mathematical expressions.  Such a project is also a good code kata, since it takes no more than an hour to complete it (if you don‚Äôt write an article about it in parallel). <br><br><h4>  Architecture </h4><br>  Despite the fact that when using TDD, the application architecture gradually manifests itself, its initial development is still necessary.  Due to this, the total time spent on implementation can be significantly reduced.  This is especially effective when there are ready-made examples of similar systems that can be taken as a model.  In this case, there is a well-established view of how <a href="http://ru.wikipedia.org/wiki/%25D0%259A%25D0%25BE%25D0%25BC%25D0%25BF%25D0%25B8%25D0%25BB%25D1%258F%25D1%2582%25D0%25BE%25D1%2580">compilers and interpreters</a> should be arranged, and this can be used. <br><br>  There are many libraries and tools that can facilitate the development of interpreters and compilers.  Starting from Boost.Spirit and ending with ANTLR and Bison.  You can even run the command line interpreter channel through <code>popen</code> and evaluate the expression through it.  The goal of this article is to step-by-step develop a fairly complex system using TDD, so only the standard C ++ library and the test framework built into the IDE will be used. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      First, let's make a list of what our simple interpreter should be able to do, in order of decreasing priority: <br><br><ul><li>  Calculate the value of a mathematical expression consisting of numbers with a floating point and mathematical operators (- + / *). </li><li>  Accounting for the priority of operators. </li><li>  Accounting brackets. </li><li>  Unary plus and minus. </li><li>  Calculating multiple expressions separated by a semicolon (;). </li><li>  Built-in constants (pi, e). </li><li>  Creating your own constants using the assignment operator (=). </li><li>  Built-in functions with a variable number of arguments. </li><li>  Setting new features. </li></ul><br>  This article will be the implementation of only the first three points.  The project itself will conceptually consist of four parts: <br><br><ul><li>  Lexical analyzer.  Converts an input string to a sequence of tokens. </li><li>  Syntactical analyzer.  Builds tokens syntactic representation in the form of <a href="http://ru.wikipedia.org/wiki/%25D0%259F%25D0%25BE%25D1%2581%25D1%2582%25D1%2584%25D0%25B8%25D0%25BA%25D1%2581%25D0%25BD%25D0%25B0%25D1%258F_%25D0%25BD%25D0%25BE%25D1%2582%25D0%25B0%25D1%2586%25D0%25B8%25D1%258F">postfix notation</a> .  We will do this without recursion and tables, using <a href="http://ru.wikipedia.org/wiki/%25D0%2590%25D0%25BB%25D0%25B3%25D0%25BE%25D1%2580%25D0%25B8%25D1%2582%25D0%25BC_%25D1%2581%25D0%25BE%25D1%2580%25D1%2582%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25BE%25D1%2587%25D0%25BD%25D0%25BE%25D0%25B9_%25D1%2581%25D1%2582%25D0%25B0%25D0%25BD%25D1%2586%25D0%25B8%25D0%25B8">the sorting station algorithm</a> . </li><li>  Calculator.  Calculates the result of an expression on a stack machine. </li><li>  Actually, the interpreter.  It serves as a facade for the above parts. </li></ul><br><h4>  Tools </h4><br>  The program will be written in Visual Studio 2013 with the <a href="http://www.microsoft.com/en-us/download/details.aspx%3Fid%3D41151">Visual C ++ Compiler Nov 2013 CTP</a> installed.  The tests will be based on the <a href="http://msdn.microsoft.com/library/hh694604.aspx">CppUnitTestFramework</a> C ++ test framework built into the studio.  It provides minimal support for writing unit tests (compared to Boost.Test, or CppUTest), but, on the other hand, is well integrated into the development environment.  An alternative could be Eclipse with the C / C ++ Unit plugin installed and configured Boost.Test, GTest, or QtTest.  In this configuration, I recommend using clang, as it provides several powerful compile- and runtime analyzers, as a result of which, in conjunction with TDD, the code becomes completely immune to errors. <br><br>  So, create a new project like ‚ÄúNative Unit Test Project‚Äù and make sure that everything compiles. <br><a name="habracut"></a><br><h4>  Lexer </h4><br>  Let's start with the development of lexer.  We will follow the usual Red-Green-Refactor TDD cycle: <br><br><ol><li>  Write a test and make it fall (Red). </li><li>  Make it go (Green). </li><li>  Improve the design (Refactor). </li></ol><br>  We write the first test, placing it in the class <code>LexerTests</code> .  I will use this technique, such as a list of tests, in which those tests that I plan to write as follows will be recorded.  It also contains thoughts about upcoming tests, which often arise during the writing of the current test and cannot be implemented immediately: <br><br><ul><li>  In response to an empty expression, an empty token list should be returned. </li></ul><br>  I used to write the names of tests in the BDD style.  Each test begins with the word <code>Should</code> , as the subject is meant that which is mentioned in the name of the class.  That is, Lexer ... should ... do A in response to B. This focuses the test on a small aspect of behavior and prevents it from growing in volume. <br><br><pre> <code class="cpp hljs">TEST_CLASS(LexerTests) { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: TEST_METHOD(Should_return_empty_token_list_when_put_empty_expression) { Tokens tokens = Lexer::Tokenize(<span class="hljs-string"><span class="hljs-string">""</span></span>); Assert::IsTrue(tokens.empty()); } };</code> </pre><br>  In CppUnitTestFramework, the TEST_CLASS macro generates a class in which test methods will be placed.  The macro <code>TEST_METHOD</code> , respectively, creates the test method itself.  It is necessary to take into account that an instance of a class is created only once before the launch of all tests in it.  In Boost.Test, for example, an instance of a class is created anew each time before running each test.  Therefore, the code that must be executed before each test will be placed in the method declared using the macro <code>TEST_METHOD_INITIALIZE</code> , and the one that is later, in <code>TEST_METHOD_CLEANUP</code> .  All assertion methods are static and are located in the <code>Assert</code> class.  They are few, but they cover the main functionality. <br><br>  Let's return to our test.  It is not that it does not pass, it does not even compile.  Create a <code>Tokenize</code> function in the <code>Lexer</code> namespace, taking a string and returning <code><code>std::vector,      Tokens</code> .            . <br> <br> <code class="cpp">#pragma once; #include &lt;vector&gt; namespace Interpreter { struct Token {}; typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { inline Tokens Tokenize(std::string expr) { throw std::exception(); } } // namespace Lexer } // namespace Interpreter</code> <br>   ,  ,   , .   ,    ,    <a href="http://cleancoder.posterous.com/the-transformation-priority-premise">The Transformation Priority Premise (TPP)</a>   .    , ,    ,     ,        .            .     ,     ,      ,           .  ,  ,   (   )    ,  ,  .     ,  ,         .     ,   TPP          . <br> <br>   : <br> <br> ({} ‚Üí nil)     ,   . (nil ‚Üí constant)    . (constant ‚Üí constant+)      (        ,  ). (constant ‚Üí scalar)    ,  . (statement ‚Üí statements)    (break, continue, return  ). (unconditional ‚Üí if)       . (scalar ‚Üí array)  / . (array ‚Üí container)     . (statement ‚Üí recursion)   . (if ‚Üí while)    . (expression ‚Üí function)   . (variable ‚Üí assignment)   . <br>        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::string expr) { return{}; }</code> <br> ,         .     . <br> <br> <s>         </s> .           .           .               .            .       . <br>  ,  <code>std::string</code>  <code>std::wstring</code> .         ,      Unicode.     . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); }</code> <br>  <code>AssertRange</code> -   ,       <code>AreEqual</code> ,   ,  ,    . <br> <br> <b class="spoiler_title">AssertRange</b> <code class="cpp">namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange</code> <br> <br>         <code>Operator</code>    .          <code>wchar_t</code>   ,         ,      . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', }; typedef Operator Token;</code> <br>    ,   ,        <code>Assert</code> ,    <code>ToString</code> ,    . <br> <br> <b class="spoiler_title">std::wstring ToString(const Token &amp;)</b> <code class="cpp">inline std::wstring ToString(const Token &amp;token) { return{ static_cast&lt;wchar_t&gt;(token) }; }</code> <br> <br>    ,   ,        .  ,   (unconditional ‚Üí if). <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { if(expr.empty()) { return{}; } return{ static_cast&lt;Operator&gt;(expr[0]) }; }</code> <br> <s>         </s> . <s>          .</s>           . ‚Ä¶ <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); }</code> <br>     .   ,     ,   - .    , : <br> <br>        ,      <code>Token</code> .       <code>dynamic_cast</code>    ,   .  ,    ,      .      <code>std::function</code>        .        .  Boost.Any,  - .            . <br>   ,   .      -  .  ,      ,      . <br> <br> ‚Ä¶        .        .        .        . <br>             . <br> <br> <code class="cpp">enum class TokenType { Operator, Number }; class Token { public: Token(Operator) {} TokenType Type() const { return TokenType::Operator; } }; ‚Ä¶ TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } };</code> <br>   <code>ToString</code>   <code>TokenType</code>       ,   ,   .     . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); }</code> <br>   .   (constant ‚Üí scalar)   . <br> <br> <code class="cpp">class Token { public: Token(Operator) :m_type(TokenType::Operator) {} Token(double) :m_type(TokenType::Number) {} TokenType Type() const { return m_type; } private: TokenType m_type; };</code> <br> ‚Ä¶ <s>       </s> . <s>       </s> .        .        . <br>    . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); }</code> <br>            . <br> <br> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} operator Operator() const { return m_operator; } ‚Ä¶ Operator m_operator; };</code> <br>      . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); }</code> <br>          ,  ,       <code>union</code> .         . <br> <br> <b class="spoiler_title">Token</b> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: return "Unknown token."; } }</code> <br> <br>  ,    ,      ,    .       .    . <br> <br> <i>          .</i>               .            .       . <br>        : <br> <br> <code class="cpp"> if(expr[0] &gt;= '0' &amp;&amp; expr[0] &lt;= '9') { return{ (double) expr[0] - '0' }; } return{ static_cast&lt;Operator&gt;(expr[0]) };</code> <br>      ,   . <br> <br> ‚Ä¶ <s>          .</s> <i>              .</i> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); }</code> <br> ,     <code>C</code>   ,  <code>isdigit</code> , ,       <code>atof</code> ,    ,      <code>wchar_t</code> .  (expression ‚Üí function).         . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { const wchar_t *current = expr.c_str(); if(!*current) return{}; if(iswdigit(*current)) return{ _wtof(current) }; return{ static_cast&lt;Operator&gt;(*current) }; }</code> <br>         .      . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>   ,        .  ,     .     .   <code>result</code> ,     . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); if(!*current) return result; if(iswdigit(*current)) { result.push_back(_wtof(current)); } else { result.push_back(static_cast&lt;Operator&gt;(*current)); } return result; }</code> <br>      :   (if ‚Üí while).     ,        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } } return result; }</code> <br>  <code>wcstod</code>    ,   <code>_wtof</code> ,           .           ,              .  ,    . <br> <br> <s>           .</s>       . <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>  (unconditional ‚Üí if)    ,    . <br> <br> <code class="cpp"> while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else if(*current == static_cast&lt;wchar_t&gt;(Operator::Plus)) { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } else { ++current; } }</code> <br>       .          .       <code>Detail</code>      .   <code>Tokenize</code>       . <br> <br> <code class="cpp">inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); }</code> <br> <b class="spoiler_title"> Detail::Tokenizer</b> <code class="cpp">namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { return *m_current == static_cast&lt;wchar_t&gt;(Operator::Plus); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail</code> <br> <br>  ,      .      ,  , .       . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); }</code> <br>      <code>Operator</code> ,    . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', };</code> <br>   .         <code>IsOperator</code>  <code>Tokenizer</code> . <br> <br> <code class="cpp"> bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); }</code> <br>         .        . <br> <br> <b class="spoiler_title">Interpreter.h</b> <code class="cpp">#pragma once; #include &lt;vector&gt; #include &lt;wchar.h&gt; #include &lt;algorithm&gt; namespace Interpreter { enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', }; inline std::wstring ToString(const Operator &amp;op) { return{ static_cast&lt;wchar_t&gt;(op) }; } enum class TokenType { Operator, Number }; inline std::wstring ToString(const TokenType &amp;type) { switch(type) { case TokenType::Operator: return L"Operator"; case TokenType::Number: return L"Number"; default: throw std::out_of_range("TokenType"); } } class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } friend inline bool operator==(const Token &amp;left, const Token &amp;right) { if(left.m_type == right.m_type) { switch(left.m_type) { case Interpreter::TokenType::Operator: return left.m_operator == right.m_operator; case Interpreter::TokenType::Number: return left.m_number == right.m_number; default: throw std::out_of_range("TokenType"); } } return false; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: throw std::out_of_range("TokenType"); } } typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); } } // namespace Lexer } // namespace Interpreter</code> <br> <br> <b class="spoiler_title">InterpreterTests.cpp</b> <code class="cpp">#include "stdafx.h" #include "CppUnitTest.h" #include "Interpreter.h" namespace InterpreterTests { using namespace Microsoft::VisualStudio::CppUnitTestFramework; using namespace Interpreter; using namespace std; namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual&lt;T&gt;(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange TEST_CLASS(LexerTests) { public: TEST_METHOD(Should_return_empty_token_list_when_put_empty_expression) { Tokens tokens = Lexer::Tokenize(L""); Assert::IsTrue(tokens.empty()); } TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); } TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); } TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); } TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); } }; TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); } TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); } TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); } }; }</code> <br> <br> <a href="https://github.com/Unril/InterpreterTDD/releases/tag/%25D0%259A%25D0%25BE%25D0%25BD%25D0%25B5%25D1%2586_%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B2%25D0%25BE%25D0%25B9_%25D1%2587%25D0%25B0%25D1%2581%25D1%2582%25D0%25B8">    GitHub</a> .         ,  .      "__". <br> <br>   <a href="http://habrahabr.ru/post/232081/">    </a> .      ,      <a href="http://habrahabr.ru/post/232097/">    </a> .</code> <code><code>std::vector,      Tokens</code> .            . <br> <br> <code class="cpp">#pragma once; #include &lt;vector&gt; namespace Interpreter { struct Token {}; typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { inline Tokens Tokenize(std::string expr) { throw std::exception(); } } // namespace Lexer } // namespace Interpreter</code> <br>   ,  ,   , .   ,    ,    <a href="http://cleancoder.posterous.com/the-transformation-priority-premise">The Transformation Priority Premise (TPP)</a>   .    , ,    ,     ,        .            .     ,     ,      ,           .  ,  ,   (   )    ,  ,  .     ,  ,         .     ,   TPP          . <br> <br>   : <br> <br> ({} ‚Üí nil)     ,   . (nil ‚Üí constant)    . (constant ‚Üí constant+)      (        ,  ). (constant ‚Üí scalar)    ,  . (statement ‚Üí statements)    (break, continue, return  ). (unconditional ‚Üí if)       . (scalar ‚Üí array)  / . (array ‚Üí container)     . (statement ‚Üí recursion)   . (if ‚Üí while)    . (expression ‚Üí function)   . (variable ‚Üí assignment)   . <br>        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::string expr) { return{}; }</code> <br> ,         .     . <br> <br> <s>         </s> .           .           .               .            .       . <br>  ,  <code>std::string</code>  <code>std::wstring</code> .         ,      Unicode.     . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); }</code> <br>  <code>AssertRange</code> -   ,       <code>AreEqual</code> ,   ,  ,    . <br> <br> <b class="spoiler_title">AssertRange</b> <code class="cpp">namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange</code> <br> <br>         <code>Operator</code>    .          <code>wchar_t</code>   ,         ,      . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', }; typedef Operator Token;</code> <br>    ,   ,        <code>Assert</code> ,    <code>ToString</code> ,    . <br> <br> <b class="spoiler_title">std::wstring ToString(const Token &amp;)</b> <code class="cpp">inline std::wstring ToString(const Token &amp;token) { return{ static_cast&lt;wchar_t&gt;(token) }; }</code> <br> <br>    ,   ,        .  ,   (unconditional ‚Üí if). <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { if(expr.empty()) { return{}; } return{ static_cast&lt;Operator&gt;(expr[0]) }; }</code> <br> <s>         </s> . <s>          .</s>           . ‚Ä¶ <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); }</code> <br>     .   ,     ,   - .    , : <br> <br>        ,      <code>Token</code> .       <code>dynamic_cast</code>    ,   .  ,    ,      .      <code>std::function</code>        .        .  Boost.Any,  - .            . <br>   ,   .      -  .  ,      ,      . <br> <br> ‚Ä¶        .        .        .        . <br>             . <br> <br> <code class="cpp">enum class TokenType { Operator, Number }; class Token { public: Token(Operator) {} TokenType Type() const { return TokenType::Operator; } }; ‚Ä¶ TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } };</code> <br>   <code>ToString</code>   <code>TokenType</code>       ,   ,   .     . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); }</code> <br>   .   (constant ‚Üí scalar)   . <br> <br> <code class="cpp">class Token { public: Token(Operator) :m_type(TokenType::Operator) {} Token(double) :m_type(TokenType::Number) {} TokenType Type() const { return m_type; } private: TokenType m_type; };</code> <br> ‚Ä¶ <s>       </s> . <s>       </s> .        .        . <br>    . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); }</code> <br>            . <br> <br> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} operator Operator() const { return m_operator; } ‚Ä¶ Operator m_operator; };</code> <br>      . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); }</code> <br>          ,  ,       <code>union</code> .         . <br> <br> <b class="spoiler_title">Token</b> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: return "Unknown token."; } }</code> <br> <br>  ,    ,      ,    .       .    . <br> <br> <i>          .</i>               .            .       . <br>        : <br> <br> <code class="cpp"> if(expr[0] &gt;= '0' &amp;&amp; expr[0] &lt;= '9') { return{ (double) expr[0] - '0' }; } return{ static_cast&lt;Operator&gt;(expr[0]) };</code> <br>      ,   . <br> <br> ‚Ä¶ <s>          .</s> <i>              .</i> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); }</code> <br> ,     <code>C</code>   ,  <code>isdigit</code> , ,       <code>atof</code> ,    ,      <code>wchar_t</code> .  (expression ‚Üí function).         . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { const wchar_t *current = expr.c_str(); if(!*current) return{}; if(iswdigit(*current)) return{ _wtof(current) }; return{ static_cast&lt;Operator&gt;(*current) }; }</code> <br>         .      . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>   ,        .  ,     .     .   <code>result</code> ,     . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); if(!*current) return result; if(iswdigit(*current)) { result.push_back(_wtof(current)); } else { result.push_back(static_cast&lt;Operator&gt;(*current)); } return result; }</code> <br>      :   (if ‚Üí while).     ,        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } } return result; }</code> <br>  <code>wcstod</code>    ,   <code>_wtof</code> ,           .           ,              .  ,    . <br> <br> <s>           .</s>       . <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>  (unconditional ‚Üí if)    ,    . <br> <br> <code class="cpp"> while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else if(*current == static_cast&lt;wchar_t&gt;(Operator::Plus)) { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } else { ++current; } }</code> <br>       .          .       <code>Detail</code>      .   <code>Tokenize</code>       . <br> <br> <code class="cpp">inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); }</code> <br> <b class="spoiler_title"> Detail::Tokenizer</b> <code class="cpp">namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { return *m_current == static_cast&lt;wchar_t&gt;(Operator::Plus); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail</code> <br> <br>  ,      .      ,  , .       . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); }</code> <br>      <code>Operator</code> ,    . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', };</code> <br>   .         <code>IsOperator</code>  <code>Tokenizer</code> . <br> <br> <code class="cpp"> bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); }</code> <br>         .        . <br> <br> <b class="spoiler_title">Interpreter.h</b> <code class="cpp">#pragma once; #include &lt;vector&gt; #include &lt;wchar.h&gt; #include &lt;algorithm&gt; namespace Interpreter { enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', }; inline std::wstring ToString(const Operator &amp;op) { return{ static_cast&lt;wchar_t&gt;(op) }; } enum class TokenType { Operator, Number }; inline std::wstring ToString(const TokenType &amp;type) { switch(type) { case TokenType::Operator: return L"Operator"; case TokenType::Number: return L"Number"; default: throw std::out_of_range("TokenType"); } } class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } friend inline bool operator==(const Token &amp;left, const Token &amp;right) { if(left.m_type == right.m_type) { switch(left.m_type) { case Interpreter::TokenType::Operator: return left.m_operator == right.m_operator; case Interpreter::TokenType::Number: return left.m_number == right.m_number; default: throw std::out_of_range("TokenType"); } } return false; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: throw std::out_of_range("TokenType"); } } typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); } } // namespace Lexer } // namespace Interpreter</code> <br> <br> <b class="spoiler_title">InterpreterTests.cpp</b> <code class="cpp">#include "stdafx.h" #include "CppUnitTest.h" #include "Interpreter.h" namespace InterpreterTests { using namespace Microsoft::VisualStudio::CppUnitTestFramework; using namespace Interpreter; using namespace std; namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual&lt;T&gt;(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange TEST_CLASS(LexerTests) { public: TEST_METHOD(Should_return_empty_token_list_when_put_empty_expression) { Tokens tokens = Lexer::Tokenize(L""); Assert::IsTrue(tokens.empty()); } TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); } TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); } TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); } TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); } }; TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); } TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); } TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); } }; }</code> <br> <br> <a href="https://github.com/Unril/InterpreterTDD/releases/tag/%25D0%259A%25D0%25BE%25D0%25BD%25D0%25B5%25D1%2586_%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B2%25D0%25BE%25D0%25B9_%25D1%2587%25D0%25B0%25D1%2581%25D1%2582%25D0%25B8">    GitHub</a> .         ,  .      "__". <br> <br>   <a href="http://habrahabr.ru/post/232081/">    </a> .      ,      <a href="http://habrahabr.ru/post/232097/">    </a> .</code> <pre> <code class="hljs lua"><code>std::vector,      Tokens</code> .            . <br> <br> <code class="cpp">#pragma once; #include &lt;vector&gt; namespace Interpreter { struct Token {}; typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { inline Tokens Tokenize(std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> expr) { throw std::exception(); } } // namespace Lexer } // namespace Interpreter</code> <br>   ,  ,   , .   ,    ,    <a href="http://cleancoder.posterous.com/the-transformation-priority-premise">The Transformation Priority Premise (TPP)</a>   .    , ,    ,     ,        .            .     ,     ,      ,           .  ,  ,   (   )    ,  ,  .     ,  ,         .     ,   TPP          . <br> <br>   : <br> <br> ({} ‚Üí <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)     ,   . (<span class="hljs-literal"><span class="hljs-literal">nil</span></span> ‚Üí constant)    . (constant ‚Üí constant+)      (        ,  ). (constant ‚Üí scalar)    ,  . (statement ‚Üí statements)    (<span class="hljs-keyword"><span class="hljs-keyword">break</span></span>, continue, <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>  ). (unconditional ‚Üí <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>)       . (scalar ‚Üí array)  / . (array ‚Üí container)     . (statement ‚Üí recursion)   . (<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ‚Üí <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>)    . (expression ‚Üí <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">)</span></span>   . (variable ‚Üí assignment)   . <br>        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> expr) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{}; }</code> <br> ,         .     . <br> <br> <s>         </s> .           .           .               .            .       . <br>  ,  <code>std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span></code>  <code>std::wstring</code> .         ,      Unicode.     . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"+"</span></span>); AssertRange::AreEqual({ Operator::Plus }, tokens); }</code> <br>  <code>AssertRange</code> -   ,       <code>AreEqual</code> ,   ,  ,    . <br> <br> <b class="spoiler_title">AssertRange</b> <code class="cpp">namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(expect)), distance(actualIter, <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(actual)), L<span class="hljs-string"><span class="hljs-string">"Size differs."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(; expectIter != <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(expect) &amp;&amp; actualIter != <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(actual); ++expectIter, ++actualIter) { auto message = L<span class="hljs-string"><span class="hljs-string">"Mismatch in position "</span></span> + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange</code> <br> <br>         <code>Operator</code>    .          <code>wchar_t</code>   ,         ,      . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L<span class="hljs-string"><span class="hljs-string">'+'</span></span>, }; typedef Operator Token;</code> <br>    ,   ,        <code>Assert</code> ,    <code>ToString</code> ,    . <br> <br> <b class="spoiler_title">std::wstring ToString(const Token &amp;)</b> <code class="cpp">inline std::wstring ToString(const Token &amp;token) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ static_cast&lt;wchar_t&gt;(token) }; }</code> <br> <br>    ,   ,        .  ,   (unconditional ‚Üí <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>). <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(expr.empty()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{}; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ static_cast&lt;Operator&gt;(expr[<span class="hljs-number"><span class="hljs-number">0</span></span>]) }; }</code> <br> <s>         </s> . <s>          .</s>           . ‚Ä¶ <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"1"</span></span>); AssertRange::AreEqual({ <span class="hljs-number"><span class="hljs-number">1.0</span></span> }, tokens); }</code> <br>     .   ,     ,   - .    , : <br> <br>        ,      <code>Token</code> .       <code>dynamic_cast</code>    ,   .  ,    ,      .      <code>std::<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span></span></code><span class="hljs-function"><span class="hljs-function">        .        .  </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Boost.Any</span></span></span><span class="hljs-function">,  - .            . </span></span><br><span class="hljs-function"><span class="hljs-function">   ,   .      -  .  ,      ,      . </span></span><br><span class="hljs-function"><span class="hljs-function"> </span></span><br><span class="hljs-function"><span class="hljs-function"> ‚Ä¶        .        .        .        . </span></span><br><span class="hljs-function"><span class="hljs-function">             . </span></span><br><span class="hljs-function"><span class="hljs-function"> </span></span><br><span class="hljs-function"><span class="hljs-function"> </span></span><code class="cpp"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">enum</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">class</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TokenType</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Operator</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Number</span></span></span><span class="hljs-function"> }; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">class</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Token</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">public</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Token</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Operator)</span></span></span></span> {} TokenType Type() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TokenType::Operator; } }; ‚Ä¶ TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } };</code> <br>   <code>ToString</code>   <code>TokenType</code>       ,   ,   .     . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_type_for_number_token) { Token numToken(<span class="hljs-number"><span class="hljs-number">1.2</span></span>); Assert::AreEqual(TokenType::Number, numToken.Type()); }</code> <br>   .   (constant ‚Üí scalar)   . <br> <br> <code class="cpp">class Token { public: Token(Operator) :m_type(TokenType::Operator) {} Token(double) :m_type(TokenType::Number) {} TokenType Type() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_type; } private: TokenType m_type; };</code> <br> ‚Ä¶ <s>       </s> . <s>       </s> .        .        . <br>    . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); }</code> <br>            . <br> <br> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} operator Operator() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_operator; } ‚Ä¶ Operator m_operator; };</code> <br>      . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_number_value_from_number_token) { Token token(<span class="hljs-number"><span class="hljs-number">1.23</span></span>); Assert::AreEqual&lt;double&gt;(<span class="hljs-number"><span class="hljs-number">1.23</span></span>, token); }</code> <br>          ,  ,       <code>union</code> .         . <br> <br> <b class="spoiler_title">Token</b> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_type; } operator Operator() const { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(m_type != TokenType::Operator) throw std::logic_error(<span class="hljs-string"><span class="hljs-string">"Should be operator token."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_operator; } operator double() const { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(m_type != TokenType::Number) throw std::logic_error(<span class="hljs-string"><span class="hljs-string">"Should be number token."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_number; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ToString(static_cast&lt;Operator&gt;(token)); default: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Unknown token."</span></span>; } }</code> <br> <br>  ,    ,      ,    .       .    . <br> <br> <i>          .</i>               .            .       . <br>        : <br> <br> <code class="cpp"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(expr[<span class="hljs-number"><span class="hljs-number">0</span></span>] &gt;= <span class="hljs-string"><span class="hljs-string">'0'</span></span> &amp;&amp; expr[<span class="hljs-number"><span class="hljs-number">0</span></span>] &lt;= <span class="hljs-string"><span class="hljs-string">'9'</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ (double) expr[<span class="hljs-number"><span class="hljs-number">0</span></span>] - <span class="hljs-string"><span class="hljs-string">'0'</span></span> }; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ static_cast&lt;Operator&gt;(expr[<span class="hljs-number"><span class="hljs-number">0</span></span>]) };</code> <br>      ,   . <br> <br> ‚Ä¶ <s>          .</s> <i>              .</i> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"12.34"</span></span>); AssertRange::AreEqual({ <span class="hljs-number"><span class="hljs-number">12.34</span></span> }, tokens); }</code> <br> ,     <code>C</code>   ,  <code>isdigit</code> , ,       <code>atof</code> ,    ,      <code>wchar_t</code> .  (expression ‚Üí <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">)</span></span>.         . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { const wchar_t *current = expr.c_str(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!*current) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{}; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(iswdigit(*current)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ _wtof(current) }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ static_cast&lt;Operator&gt;(*current) }; }</code> <br>         .      . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"+12.34"</span></span>); AssertRange::AreEqual({ Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">12.34</span></span>) }, tokens); }</code> <br>   ,        .  ,     .     .   <code>result</code> ,     . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!*current) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(iswdigit(*current)) { result.push_back(_wtof(current)); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { result.push_back(static_cast&lt;Operator&gt;(*current)); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> <br>      :   (<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ‚Üí <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>).     ,        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(*current) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(iswdigit(*current)) { wchar_t *<span class="hljs-keyword"><span class="hljs-keyword">end</span></span> = nullptr; result.push_back(wcstod(current, &amp;<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>)); current = <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> <br>  <code>wcstod</code>    ,   <code>_wtof</code> ,           .           ,              .  ,    . <br> <br> <s>           .</s>       . <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">" 1 + 12.34 "</span></span>); AssertRange::AreEqual({ Token(<span class="hljs-number"><span class="hljs-number">1.0</span></span>), Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">12.34</span></span>) }, tokens); }</code> <br>  (unconditional ‚Üí <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>)    ,    . <br> <br> <code class="cpp"> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(*current) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(iswdigit(*current)) { wchar_t *<span class="hljs-keyword"><span class="hljs-keyword">end</span></span> = nullptr; result.push_back(wcstod(current, &amp;<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>)); current = <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(*current == static_cast&lt;wchar_t&gt;(Operator::Plus)) { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { ++current; } }</code> <br>       .          .       <code>Detail</code>      .   <code>Tokenize</code>       . <br> <br> <code class="cpp">inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tokenizer.Result(); }</code> <br> <b class="spoiler_title"> Detail::Tokenizer</b> <code class="cpp">namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!EndOfExperssion()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(IsNumber()) { ScanNumber(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(IsOperator()) { ScanOperator(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { MoveNext(); } } } const Tokens &amp;Result() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_result; } private: bool EndOfExperssion() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_current == L<span class="hljs-string"><span class="hljs-string">'\0'</span></span>; } bool IsNumber() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> iswdigit(*m_current) != <span class="hljs-number"><span class="hljs-number">0</span></span>; } void ScanNumber() { wchar_t *<span class="hljs-keyword"><span class="hljs-keyword">end</span></span> = nullptr; m_result.push_back(wcstod(m_current, &amp;<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>)); m_current = <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; } bool IsOperator() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_current == static_cast&lt;wchar_t&gt;(Operator::Plus); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail</code> <br> <br>  ,      .      ,  , .       . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"1+2*3/(4-5)"</span></span>); AssertRange::AreEqual({ Token(<span class="hljs-number"><span class="hljs-number">1</span></span>), Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">2</span></span>), Token(Operator::Mul), Token(<span class="hljs-number"><span class="hljs-number">3</span></span>), Token(Operator::Div), Token(Operator::LParen), Token(<span class="hljs-number"><span class="hljs-number">4</span></span>), Token(Operator::Minus), Token(<span class="hljs-number"><span class="hljs-number">5</span></span>), Token(Operator::RParen) }, tokens); }</code> <br>      <code>Operator</code> ,    . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L<span class="hljs-string"><span class="hljs-string">'+'</span></span>, Minus = L<span class="hljs-string"><span class="hljs-string">'-'</span></span>, Mul = L<span class="hljs-string"><span class="hljs-string">'*'</span></span>, Div = L<span class="hljs-string"><span class="hljs-string">'/'</span></span>, LParen = L<span class="hljs-string"><span class="hljs-string">'('</span></span>, RParen = L<span class="hljs-string"><span class="hljs-string">')'</span></span>, };</code> <br>   .         <code>IsOperator</code>  <code>Tokenizer</code> . <br> <br> <code class="cpp"> bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> std::any_of(all.begin(), all.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(), [this](Operator o) {<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_current == static_cast&lt;wchar_t&gt;(o); }); }</code> <br>         .        . <br> <br> <b class="spoiler_title">Interpreter.h</b> <code class="cpp">#pragma once; #include &lt;vector&gt; #include &lt;wchar.h&gt; #include &lt;algorithm&gt; namespace Interpreter { enum class Operator : wchar_t { Plus = L<span class="hljs-string"><span class="hljs-string">'+'</span></span>, Minus = L<span class="hljs-string"><span class="hljs-string">'-'</span></span>, Mul = L<span class="hljs-string"><span class="hljs-string">'*'</span></span>, Div = L<span class="hljs-string"><span class="hljs-string">'/'</span></span>, LParen = L<span class="hljs-string"><span class="hljs-string">'('</span></span>, RParen = L<span class="hljs-string"><span class="hljs-string">')'</span></span>, }; inline std::wstring ToString(const Operator &amp;op) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ static_cast&lt;wchar_t&gt;(op) }; } enum class TokenType { Operator, Number }; inline std::wstring ToString(const TokenType &amp;<span class="hljs-built_in"><span class="hljs-built_in">type</span></span>) { switch(<span class="hljs-built_in"><span class="hljs-built_in">type</span></span>) { case TokenType::Operator: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> L<span class="hljs-string"><span class="hljs-string">"Operator"</span></span>; case TokenType::Number: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> L<span class="hljs-string"><span class="hljs-string">"Number"</span></span>; default: throw std::out_of_range(<span class="hljs-string"><span class="hljs-string">"TokenType"</span></span>); } } class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_type; } operator Operator() const { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(m_type != TokenType::Operator) throw std::logic_error(<span class="hljs-string"><span class="hljs-string">"Should be operator token."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_operator; } operator double() const { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(m_type != TokenType::Number) throw std::logic_error(<span class="hljs-string"><span class="hljs-string">"Should be number token."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_number; } friend inline bool operator==(const Token &amp;left, const Token &amp;right) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(left.m_type == right.m_type) { switch(left.m_type) { case Interpreter::TokenType::Operator: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> left.m_operator == right.m_operator; case Interpreter::TokenType::Number: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> left.m_number == right.m_number; default: throw std::out_of_range(<span class="hljs-string"><span class="hljs-string">"TokenType"</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ToString(static_cast&lt;Operator&gt;(token)); default: throw std::out_of_range(<span class="hljs-string"><span class="hljs-string">"TokenType"</span></span>); } } typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!EndOfExperssion()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(IsNumber()) { ScanNumber(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(IsOperator()) { ScanOperator(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { MoveNext(); } } } const Tokens &amp;Result() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_result; } private: bool EndOfExperssion() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_current == L<span class="hljs-string"><span class="hljs-string">'\0'</span></span>; } bool IsNumber() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> iswdigit(*m_current) != <span class="hljs-number"><span class="hljs-number">0</span></span>; } void ScanNumber() { wchar_t *<span class="hljs-keyword"><span class="hljs-keyword">end</span></span> = nullptr; m_result.push_back(wcstod(m_current, &amp;<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>)); m_current = <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; } bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> std::any_of(all.begin(), all.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(), [this](Operator o) {<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_current == static_cast&lt;wchar_t&gt;(o); }); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tokenizer.Result(); } } // namespace Lexer } // namespace Interpreter</code> <br> <br> <b class="spoiler_title">InterpreterTests.cpp</b> <code class="cpp">#include <span class="hljs-string"><span class="hljs-string">"stdafx.h"</span></span> #include <span class="hljs-string"><span class="hljs-string">"CppUnitTest.h"</span></span> #include <span class="hljs-string"><span class="hljs-string">"Interpreter.h"</span></span> namespace InterpreterTests { using namespace Microsoft::VisualStudio::CppUnitTestFramework; using namespace Interpreter; using namespace std; namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(expect)), distance(actualIter, <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(actual)), L<span class="hljs-string"><span class="hljs-string">"Size differs."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(; expectIter != <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(expect) &amp;&amp; actualIter != <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(actual); ++expectIter, ++actualIter) { auto message = L<span class="hljs-string"><span class="hljs-string">"Mismatch in position "</span></span> + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual&lt;T&gt;(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange TEST_CLASS(LexerTests) { public: TEST_METHOD(Should_return_empty_token_list_when_put_empty_expression) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">""</span></span>); Assert::IsTrue(tokens.empty()); } TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"+"</span></span>); AssertRange::AreEqual({ Operator::Plus }, tokens); } TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"1"</span></span>); AssertRange::AreEqual({ <span class="hljs-number"><span class="hljs-number">1.0</span></span> }, tokens); } TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"12.34"</span></span>); AssertRange::AreEqual({ <span class="hljs-number"><span class="hljs-number">12.34</span></span> }, tokens); } TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"+12.34"</span></span>); AssertRange::AreEqual({ Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">12.34</span></span>) }, tokens); } TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">" 1 + 12.34 "</span></span>); AssertRange::AreEqual({ Token(<span class="hljs-number"><span class="hljs-number">1.0</span></span>), Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">12.34</span></span>) }, tokens); } TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"1+2*3/(4-5)"</span></span>); AssertRange::AreEqual({ Token(<span class="hljs-number"><span class="hljs-number">1</span></span>), Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">2</span></span>), Token(Operator::Mul), Token(<span class="hljs-number"><span class="hljs-number">3</span></span>), Token(Operator::Div), Token(Operator::LParen), Token(<span class="hljs-number"><span class="hljs-number">4</span></span>), Token(Operator::Minus), Token(<span class="hljs-number"><span class="hljs-number">5</span></span>), Token(Operator::RParen) }, tokens); } }; TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } TEST_METHOD(Should_get_type_for_number_token) { Token numToken(<span class="hljs-number"><span class="hljs-number">1.2</span></span>); Assert::AreEqual(TokenType::Number, numToken.Type()); } TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); } TEST_METHOD(Should_get_number_value_from_number_token) { Token token(<span class="hljs-number"><span class="hljs-number">1.23</span></span>); Assert::AreEqual&lt;double&gt;(<span class="hljs-number"><span class="hljs-number">1.23</span></span>, token); } }; }</code> <br> <br> <a href="https://github.com/Unril/InterpreterTDD/releases/tag/%25D0%259A%25D0%25BE%25D0%25BD%25D0%25B5%25D1%2586_%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B2%25D0%25BE%25D0%25B9_%25D1%2587%25D0%25B0%25D1%2581%25D1%2582%25D0%25B8">    GitHub</a> .         ,  .      <span class="hljs-string"><span class="hljs-string">"__"</span></span>. <br> <br>   <a href="http://habrahabr.ru/post/232081/">    </a> .      ,      <a href="http://habrahabr.ru/post/232097/">    </a> .</code> </pre> <code><code>std::vector,      Tokens</code> .            . <br> <br> <code class="cpp">#pragma once; #include &lt;vector&gt; namespace Interpreter { struct Token {}; typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { inline Tokens Tokenize(std::string expr) { throw std::exception(); } } // namespace Lexer } // namespace Interpreter</code> <br>   ,  ,   , .   ,    ,    <a href="http://cleancoder.posterous.com/the-transformation-priority-premise">The Transformation Priority Premise (TPP)</a>   .    , ,    ,     ,        .            .     ,     ,      ,           .  ,  ,   (   )    ,  ,  .     ,  ,         .     ,   TPP          . <br> <br>   : <br> <br> ({} ‚Üí nil)     ,   . (nil ‚Üí constant)    . (constant ‚Üí constant+)      (        ,  ). (constant ‚Üí scalar)    ,  . (statement ‚Üí statements)    (break, continue, return  ). (unconditional ‚Üí if)       . (scalar ‚Üí array)  / . (array ‚Üí container)     . (statement ‚Üí recursion)   . (if ‚Üí while)    . (expression ‚Üí function)   . (variable ‚Üí assignment)   . <br>        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::string expr) { return{}; }</code> <br> ,         .     . <br> <br> <s>         </s> .           .           .               .            .       . <br>  ,  <code>std::string</code>  <code>std::wstring</code> .         ,      Unicode.     . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); }</code> <br>  <code>AssertRange</code> -   ,       <code>AreEqual</code> ,   ,  ,    . <br> <br> <b class="spoiler_title">AssertRange</b> <code class="cpp">namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange</code> <br> <br>         <code>Operator</code>    .          <code>wchar_t</code>   ,         ,      . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', }; typedef Operator Token;</code> <br>    ,   ,        <code>Assert</code> ,    <code>ToString</code> ,    . <br> <br> <b class="spoiler_title">std::wstring ToString(const Token &amp;)</b> <code class="cpp">inline std::wstring ToString(const Token &amp;token) { return{ static_cast&lt;wchar_t&gt;(token) }; }</code> <br> <br>    ,   ,        .  ,   (unconditional ‚Üí if). <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { if(expr.empty()) { return{}; } return{ static_cast&lt;Operator&gt;(expr[0]) }; }</code> <br> <s>         </s> . <s>          .</s>           . ‚Ä¶ <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); }</code> <br>     .   ,     ,   - .    , : <br> <br>        ,      <code>Token</code> .       <code>dynamic_cast</code>    ,   .  ,    ,      .      <code>std::function</code>        .        .  Boost.Any,  - .            . <br>   ,   .      -  .  ,      ,      . <br> <br> ‚Ä¶        .        .        .        . <br>             . <br> <br> <code class="cpp">enum class TokenType { Operator, Number }; class Token { public: Token(Operator) {} TokenType Type() const { return TokenType::Operator; } }; ‚Ä¶ TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } };</code> <br>   <code>ToString</code>   <code>TokenType</code>       ,   ,   .     . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); }</code> <br>   .   (constant ‚Üí scalar)   . <br> <br> <code class="cpp">class Token { public: Token(Operator) :m_type(TokenType::Operator) {} Token(double) :m_type(TokenType::Number) {} TokenType Type() const { return m_type; } private: TokenType m_type; };</code> <br> ‚Ä¶ <s>       </s> . <s>       </s> .        .        . <br>    . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); }</code> <br>            . <br> <br> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} operator Operator() const { return m_operator; } ‚Ä¶ Operator m_operator; };</code> <br>      . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); }</code> <br>          ,  ,       <code>union</code> .         . <br> <br> <b class="spoiler_title">Token</b> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: return "Unknown token."; } }</code> <br> <br>  ,    ,      ,    .       .    . <br> <br> <i>          .</i>               .            .       . <br>        : <br> <br> <code class="cpp"> if(expr[0] &gt;= '0' &amp;&amp; expr[0] &lt;= '9') { return{ (double) expr[0] - '0' }; } return{ static_cast&lt;Operator&gt;(expr[0]) };</code> <br>      ,   . <br> <br> ‚Ä¶ <s>          .</s> <i>              .</i> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); }</code> <br> ,     <code>C</code>   ,  <code>isdigit</code> , ,       <code>atof</code> ,    ,      <code>wchar_t</code> .  (expression ‚Üí function).         . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { const wchar_t *current = expr.c_str(); if(!*current) return{}; if(iswdigit(*current)) return{ _wtof(current) }; return{ static_cast&lt;Operator&gt;(*current) }; }</code> <br>         .      . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>   ,        .  ,     .     .   <code>result</code> ,     . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); if(!*current) return result; if(iswdigit(*current)) { result.push_back(_wtof(current)); } else { result.push_back(static_cast&lt;Operator&gt;(*current)); } return result; }</code> <br>      :   (if ‚Üí while).     ,        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } } return result; }</code> <br>  <code>wcstod</code>    ,   <code>_wtof</code> ,           .           ,              .  ,    . <br> <br> <s>           .</s>       . <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>  (unconditional ‚Üí if)    ,    . <br> <br> <code class="cpp"> while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else if(*current == static_cast&lt;wchar_t&gt;(Operator::Plus)) { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } else { ++current; } }</code> <br>       .          .       <code>Detail</code>      .   <code>Tokenize</code>       . <br> <br> <code class="cpp">inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); }</code> <br> <b class="spoiler_title"> Detail::Tokenizer</b> <code class="cpp">namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { return *m_current == static_cast&lt;wchar_t&gt;(Operator::Plus); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail</code> <br> <br>  ,      .      ,  , .       . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); }</code> <br>      <code>Operator</code> ,    . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', };</code> <br>   .         <code>IsOperator</code>  <code>Tokenizer</code> . <br> <br> <code class="cpp"> bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); }</code> <br>         .        . <br> <br> <b class="spoiler_title">Interpreter.h</b> <code class="cpp">#pragma once; #include &lt;vector&gt; #include &lt;wchar.h&gt; #include &lt;algorithm&gt; namespace Interpreter { enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', }; inline std::wstring ToString(const Operator &amp;op) { return{ static_cast&lt;wchar_t&gt;(op) }; } enum class TokenType { Operator, Number }; inline std::wstring ToString(const TokenType &amp;type) { switch(type) { case TokenType::Operator: return L"Operator"; case TokenType::Number: return L"Number"; default: throw std::out_of_range("TokenType"); } } class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } friend inline bool operator==(const Token &amp;left, const Token &amp;right) { if(left.m_type == right.m_type) { switch(left.m_type) { case Interpreter::TokenType::Operator: return left.m_operator == right.m_operator; case Interpreter::TokenType::Number: return left.m_number == right.m_number; default: throw std::out_of_range("TokenType"); } } return false; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: throw std::out_of_range("TokenType"); } } typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); } } // namespace Lexer } // namespace Interpreter</code> <br> <br> <b class="spoiler_title">InterpreterTests.cpp</b> <code class="cpp">#include "stdafx.h" #include "CppUnitTest.h" #include "Interpreter.h" namespace InterpreterTests { using namespace Microsoft::VisualStudio::CppUnitTestFramework; using namespace Interpreter; using namespace std; namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual&lt;T&gt;(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange TEST_CLASS(LexerTests) { public: TEST_METHOD(Should_return_empty_token_list_when_put_empty_expression) { Tokens tokens = Lexer::Tokenize(L""); Assert::IsTrue(tokens.empty()); } TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); } TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); } TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); } TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); } }; TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); } TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); } TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); } }; }</code> <br> <br> <a href="https://github.com/Unril/InterpreterTDD/releases/tag/%25D0%259A%25D0%25BE%25D0%25BD%25D0%25B5%25D1%2586_%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B2%25D0%25BE%25D0%25B9_%25D1%2587%25D0%25B0%25D1%2581%25D1%2582%25D0%25B8">    GitHub</a> .         ,  .      "__". <br> <br>   <a href="http://habrahabr.ru/post/232081/">    </a> .      ,      <a href="http://habrahabr.ru/post/232097/">    </a> .</code> <ol><li> <code><code>std::vector,      Tokens</code> .            . <br> <br> <code class="cpp">#pragma once; #include &lt;vector&gt; namespace Interpreter { struct Token {}; typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { inline Tokens Tokenize(std::string expr) { throw std::exception(); } } // namespace Lexer } // namespace Interpreter</code> <br>   ,  ,   , .   ,    ,    <a href="http://cleancoder.posterous.com/the-transformation-priority-premise">The Transformation Priority Premise (TPP)</a>   .    , ,    ,     ,        .            .     ,     ,      ,           .  ,  ,   (   )    ,  ,  .     ,  ,         .     ,   TPP          . <br> <br>   : <br> <br> ({} ‚Üí nil)     ,   . (nil ‚Üí constant)    . (constant ‚Üí constant+)      (        ,  ). (constant ‚Üí scalar)    ,  . (statement ‚Üí statements)    (break, continue, return  ). (unconditional ‚Üí if)       . (scalar ‚Üí array)  / . (array ‚Üí container)     . (statement ‚Üí recursion)   . (if ‚Üí while)    . (expression ‚Üí function)   . (variable ‚Üí assignment)   . <br>        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::string expr) { return{}; }</code> <br> ,         .     . <br> <br> <s>         </s> .           .           .               .            .       . <br>  ,  <code>std::string</code>  <code>std::wstring</code> .         ,      Unicode.     . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); }</code> <br>  <code>AssertRange</code> -   ,       <code>AreEqual</code> ,   ,  ,    . <br> <br> <b class="spoiler_title">AssertRange</b> <code class="cpp">namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange</code> <br> <br>         <code>Operator</code>    .          <code>wchar_t</code>   ,         ,      . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', }; typedef Operator Token;</code> <br>    ,   ,        <code>Assert</code> ,    <code>ToString</code> ,    . <br> <br> <b class="spoiler_title">std::wstring ToString(const Token &amp;)</b> <code class="cpp">inline std::wstring ToString(const Token &amp;token) { return{ static_cast&lt;wchar_t&gt;(token) }; }</code> <br> <br>    ,   ,        .  ,   (unconditional ‚Üí if). <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { if(expr.empty()) { return{}; } return{ static_cast&lt;Operator&gt;(expr[0]) }; }</code> <br> <s>         </s> . <s>          .</s>           . ‚Ä¶ <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); }</code> <br>     .   ,     ,   - .    , : <br> <br>        ,      <code>Token</code> .       <code>dynamic_cast</code>    ,   .  ,    ,      .      <code>std::function</code>        .        .  Boost.Any,  - .            . <br>   ,   .      -  .  ,      ,      . <br> <br> ‚Ä¶        .        .        .        . <br>             . <br> <br> <code class="cpp">enum class TokenType { Operator, Number }; class Token { public: Token(Operator) {} TokenType Type() const { return TokenType::Operator; } }; ‚Ä¶ TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } };</code> <br>   <code>ToString</code>   <code>TokenType</code>       ,   ,   .     . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); }</code> <br>   .   (constant ‚Üí scalar)   . <br> <br> <code class="cpp">class Token { public: Token(Operator) :m_type(TokenType::Operator) {} Token(double) :m_type(TokenType::Number) {} TokenType Type() const { return m_type; } private: TokenType m_type; };</code> <br> ‚Ä¶ <s>       </s> . <s>       </s> .        .        . <br>    . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); }</code> <br>            . <br> <br> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} operator Operator() const { return m_operator; } ‚Ä¶ Operator m_operator; };</code> <br>      . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); }</code> <br>          ,  ,       <code>union</code> .         . <br> <br> <b class="spoiler_title">Token</b> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: return "Unknown token."; } }</code> <br> <br>  ,    ,      ,    .       .    . <br> <br> <i>          .</i>               .            .       . <br>        : <br> <br> <code class="cpp"> if(expr[0] &gt;= '0' &amp;&amp; expr[0] &lt;= '9') { return{ (double) expr[0] - '0' }; } return{ static_cast&lt;Operator&gt;(expr[0]) };</code> <br>      ,   . <br> <br> ‚Ä¶ <s>          .</s> <i>              .</i> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); }</code> <br> ,     <code>C</code>   ,  <code>isdigit</code> , ,       <code>atof</code> ,    ,      <code>wchar_t</code> .  (expression ‚Üí function).         . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { const wchar_t *current = expr.c_str(); if(!*current) return{}; if(iswdigit(*current)) return{ _wtof(current) }; return{ static_cast&lt;Operator&gt;(*current) }; }</code> <br>         .      . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>   ,        .  ,     .     .   <code>result</code> ,     . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); if(!*current) return result; if(iswdigit(*current)) { result.push_back(_wtof(current)); } else { result.push_back(static_cast&lt;Operator&gt;(*current)); } return result; }</code> <br>      :   (if ‚Üí while).     ,        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } } return result; }</code> <br>  <code>wcstod</code>    ,   <code>_wtof</code> ,           .           ,              .  ,    . <br> <br> <s>           .</s>       . <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>  (unconditional ‚Üí if)    ,    . <br> <br> <code class="cpp"> while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else if(*current == static_cast&lt;wchar_t&gt;(Operator::Plus)) { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } else { ++current; } }</code> <br>       .          .       <code>Detail</code>      .   <code>Tokenize</code>       . <br> <br> <code class="cpp">inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); }</code> <br> <b class="spoiler_title"> Detail::Tokenizer</b> <code class="cpp">namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { return *m_current == static_cast&lt;wchar_t&gt;(Operator::Plus); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail</code> <br> <br>  ,      .      ,  , .       . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); }</code> <br>      <code>Operator</code> ,    . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', };</code> <br>   .         <code>IsOperator</code>  <code>Tokenizer</code> . <br> <br> <code class="cpp"> bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); }</code> <br>         .        . <br> <br> <b class="spoiler_title">Interpreter.h</b> <code class="cpp">#pragma once; #include &lt;vector&gt; #include &lt;wchar.h&gt; #include &lt;algorithm&gt; namespace Interpreter { enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', }; inline std::wstring ToString(const Operator &amp;op) { return{ static_cast&lt;wchar_t&gt;(op) }; } enum class TokenType { Operator, Number }; inline std::wstring ToString(const TokenType &amp;type) { switch(type) { case TokenType::Operator: return L"Operator"; case TokenType::Number: return L"Number"; default: throw std::out_of_range("TokenType"); } } class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } friend inline bool operator==(const Token &amp;left, const Token &amp;right) { if(left.m_type == right.m_type) { switch(left.m_type) { case Interpreter::TokenType::Operator: return left.m_operator == right.m_operator; case Interpreter::TokenType::Number: return left.m_number == right.m_number; default: throw std::out_of_range("TokenType"); } } return false; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: throw std::out_of_range("TokenType"); } } typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); } } // namespace Lexer } // namespace Interpreter</code> <br> <br> <b class="spoiler_title">InterpreterTests.cpp</b> <code class="cpp">#include "stdafx.h" #include "CppUnitTest.h" #include "Interpreter.h" namespace InterpreterTests { using namespace Microsoft::VisualStudio::CppUnitTestFramework; using namespace Interpreter; using namespace std; namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual&lt;T&gt;(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange TEST_CLASS(LexerTests) { public: TEST_METHOD(Should_return_empty_token_list_when_put_empty_expression) { Tokens tokens = Lexer::Tokenize(L""); Assert::IsTrue(tokens.empty()); } TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); } TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); } TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); } TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); } }; TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); } TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); } TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); } }; }</code> <br> <br> <a href="https://github.com/Unril/InterpreterTDD/releases/tag/%25D0%259A%25D0%25BE%25D0%25BD%25D0%25B5%25D1%2586_%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B2%25D0%25BE%25D0%25B9_%25D1%2587%25D0%25B0%25D1%2581%25D1%2582%25D0%25B8">    GitHub</a> .         ,  .      "__". <br> <br>   <a href="http://habrahabr.ru/post/232081/">    </a> .      ,      <a href="http://habrahabr.ru/post/232097/">    </a> .</code> </li> <li> <code><code>std::vector,      Tokens</code> .            . <br> <br> <code class="cpp">#pragma once; #include &lt;vector&gt; namespace Interpreter { struct Token {}; typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { inline Tokens Tokenize(std::string expr) { throw std::exception(); } } // namespace Lexer } // namespace Interpreter</code> <br>   ,  ,   , .   ,    ,    <a href="http://cleancoder.posterous.com/the-transformation-priority-premise">The Transformation Priority Premise (TPP)</a>   .    , ,    ,     ,        .            .     ,     ,      ,           .  ,  ,   (   )    ,  ,  .     ,  ,         .     ,   TPP          . <br> <br>   : <br> <br> ({} ‚Üí nil)     ,   . (nil ‚Üí constant)    . (constant ‚Üí constant+)      (        ,  ). (constant ‚Üí scalar)    ,  . (statement ‚Üí statements)    (break, continue, return  ). (unconditional ‚Üí if)       . (scalar ‚Üí array)  / . (array ‚Üí container)     . (statement ‚Üí recursion)   . (if ‚Üí while)    . (expression ‚Üí function)   . (variable ‚Üí assignment)   . <br>        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::string expr) { return{}; }</code> <br> ,         .     . <br> <br> <s>         </s> .           .           .               .            .       . <br>  ,  <code>std::string</code>  <code>std::wstring</code> .         ,      Unicode.     . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); }</code> <br>  <code>AssertRange</code> -   ,       <code>AreEqual</code> ,   ,  ,    . <br> <br> <b class="spoiler_title">AssertRange</b> <code class="cpp">namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange</code> <br> <br>         <code>Operator</code>    .          <code>wchar_t</code>   ,         ,      . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', }; typedef Operator Token;</code> <br>    ,   ,        <code>Assert</code> ,    <code>ToString</code> ,    . <br> <br> <b class="spoiler_title">std::wstring ToString(const Token &amp;)</b> <code class="cpp">inline std::wstring ToString(const Token &amp;token) { return{ static_cast&lt;wchar_t&gt;(token) }; }</code> <br> <br>    ,   ,        .  ,   (unconditional ‚Üí if). <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { if(expr.empty()) { return{}; } return{ static_cast&lt;Operator&gt;(expr[0]) }; }</code> <br> <s>         </s> . <s>          .</s>           . ‚Ä¶ <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); }</code> <br>     .   ,     ,   - .    , : <br> <br>        ,      <code>Token</code> .       <code>dynamic_cast</code>    ,   .  ,    ,      .      <code>std::function</code>        .        .  Boost.Any,  - .            . <br>   ,   .      -  .  ,      ,      . <br> <br> ‚Ä¶        .        .        .        . <br>             . <br> <br> <code class="cpp">enum class TokenType { Operator, Number }; class Token { public: Token(Operator) {} TokenType Type() const { return TokenType::Operator; } }; ‚Ä¶ TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } };</code> <br>   <code>ToString</code>   <code>TokenType</code>       ,   ,   .     . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); }</code> <br>   .   (constant ‚Üí scalar)   . <br> <br> <code class="cpp">class Token { public: Token(Operator) :m_type(TokenType::Operator) {} Token(double) :m_type(TokenType::Number) {} TokenType Type() const { return m_type; } private: TokenType m_type; };</code> <br> ‚Ä¶ <s>       </s> . <s>       </s> .        .        . <br>    . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); }</code> <br>            . <br> <br> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} operator Operator() const { return m_operator; } ‚Ä¶ Operator m_operator; };</code> <br>      . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); }</code> <br>          ,  ,       <code>union</code> .         . <br> <br> <b class="spoiler_title">Token</b> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: return "Unknown token."; } }</code> <br> <br>  ,    ,      ,    .       .    . <br> <br> <i>          .</i>               .            .       . <br>        : <br> <br> <code class="cpp"> if(expr[0] &gt;= '0' &amp;&amp; expr[0] &lt;= '9') { return{ (double) expr[0] - '0' }; } return{ static_cast&lt;Operator&gt;(expr[0]) };</code> <br>      ,   . <br> <br> ‚Ä¶ <s>          .</s> <i>              .</i> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); }</code> <br> ,     <code>C</code>   ,  <code>isdigit</code> , ,       <code>atof</code> ,    ,      <code>wchar_t</code> .  (expression ‚Üí function).         . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { const wchar_t *current = expr.c_str(); if(!*current) return{}; if(iswdigit(*current)) return{ _wtof(current) }; return{ static_cast&lt;Operator&gt;(*current) }; }</code> <br>         .      . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>   ,        .  ,     .     .   <code>result</code> ,     . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); if(!*current) return result; if(iswdigit(*current)) { result.push_back(_wtof(current)); } else { result.push_back(static_cast&lt;Operator&gt;(*current)); } return result; }</code> <br>      :   (if ‚Üí while).     ,        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } } return result; }</code> <br>  <code>wcstod</code>    ,   <code>_wtof</code> ,           .           ,              .  ,    . <br> <br> <s>           .</s>       . <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>  (unconditional ‚Üí if)    ,    . <br> <br> <code class="cpp"> while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else if(*current == static_cast&lt;wchar_t&gt;(Operator::Plus)) { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } else { ++current; } }</code> <br>       .          .       <code>Detail</code>      .   <code>Tokenize</code>       . <br> <br> <code class="cpp">inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); }</code> <br> <b class="spoiler_title"> Detail::Tokenizer</b> <code class="cpp">namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { return *m_current == static_cast&lt;wchar_t&gt;(Operator::Plus); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail</code> <br> <br>  ,      .      ,  , .       . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); }</code> <br>      <code>Operator</code> ,    . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', };</code> <br>   .         <code>IsOperator</code>  <code>Tokenizer</code> . <br> <br> <code class="cpp"> bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); }</code> <br>         .        . <br> <br> <b class="spoiler_title">Interpreter.h</b> <code class="cpp">#pragma once; #include &lt;vector&gt; #include &lt;wchar.h&gt; #include &lt;algorithm&gt; namespace Interpreter { enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', }; inline std::wstring ToString(const Operator &amp;op) { return{ static_cast&lt;wchar_t&gt;(op) }; } enum class TokenType { Operator, Number }; inline std::wstring ToString(const TokenType &amp;type) { switch(type) { case TokenType::Operator: return L"Operator"; case TokenType::Number: return L"Number"; default: throw std::out_of_range("TokenType"); } } class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } friend inline bool operator==(const Token &amp;left, const Token &amp;right) { if(left.m_type == right.m_type) { switch(left.m_type) { case Interpreter::TokenType::Operator: return left.m_operator == right.m_operator; case Interpreter::TokenType::Number: return left.m_number == right.m_number; default: throw std::out_of_range("TokenType"); } } return false; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: throw std::out_of_range("TokenType"); } } typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); } } // namespace Lexer } // namespace Interpreter</code> <br> <br> <b class="spoiler_title">InterpreterTests.cpp</b> <code class="cpp">#include "stdafx.h" #include "CppUnitTest.h" #include "Interpreter.h" namespace InterpreterTests { using namespace Microsoft::VisualStudio::CppUnitTestFramework; using namespace Interpreter; using namespace std; namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual&lt;T&gt;(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange TEST_CLASS(LexerTests) { public: TEST_METHOD(Should_return_empty_token_list_when_put_empty_expression) { Tokens tokens = Lexer::Tokenize(L""); Assert::IsTrue(tokens.empty()); } TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); } TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); } TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); } TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); } }; TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); } TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); } TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); } }; }</code> <br> <br> <a href="https://github.com/Unril/InterpreterTDD/releases/tag/%25D0%259A%25D0%25BE%25D0%25BD%25D0%25B5%25D1%2586_%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B2%25D0%25BE%25D0%25B9_%25D1%2587%25D0%25B0%25D1%2581%25D1%2582%25D0%25B8">    GitHub</a> .         ,  .      "__". <br> <br>   <a href="http://habrahabr.ru/post/232081/">    </a> .      ,      <a href="http://habrahabr.ru/post/232097/">    </a> .</code> </li> <li> <code><code>std::vector,      Tokens</code> .            . <br> <br> <code class="cpp">#pragma once; #include &lt;vector&gt; namespace Interpreter { struct Token {}; typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { inline Tokens Tokenize(std::string expr) { throw std::exception(); } } // namespace Lexer } // namespace Interpreter</code> <br>   ,  ,   , .   ,    ,    <a href="http://cleancoder.posterous.com/the-transformation-priority-premise">The Transformation Priority Premise (TPP)</a>   .    , ,    ,     ,        .            .     ,     ,      ,           .  ,  ,   (   )    ,  ,  .     ,  ,         .     ,   TPP          . <br> <br>   : <br> <br> ({} ‚Üí nil)     ,   . (nil ‚Üí constant)    . (constant ‚Üí constant+)      (        ,  ). (constant ‚Üí scalar)    ,  . (statement ‚Üí statements)    (break, continue, return  ). (unconditional ‚Üí if)       . (scalar ‚Üí array)  / . (array ‚Üí container)     . (statement ‚Üí recursion)   . (if ‚Üí while)    . (expression ‚Üí function)   . (variable ‚Üí assignment)   . <br>        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::string expr) { return{}; }</code> <br> ,         .     . <br> <br> <s>         </s> .           .           .               .            .       . <br>  ,  <code>std::string</code>  <code>std::wstring</code> .         ,      Unicode.     . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); }</code> <br>  <code>AssertRange</code> -   ,       <code>AreEqual</code> ,   ,  ,    . <br> <br> <b class="spoiler_title">AssertRange</b> <code class="cpp">namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange</code> <br> <br>         <code>Operator</code>    .          <code>wchar_t</code>   ,         ,      . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', }; typedef Operator Token;</code> <br>    ,   ,        <code>Assert</code> ,    <code>ToString</code> ,    . <br> <br> <b class="spoiler_title">std::wstring ToString(const Token &amp;)</b> <code class="cpp">inline std::wstring ToString(const Token &amp;token) { return{ static_cast&lt;wchar_t&gt;(token) }; }</code> <br> <br>    ,   ,        .  ,   (unconditional ‚Üí if). <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { if(expr.empty()) { return{}; } return{ static_cast&lt;Operator&gt;(expr[0]) }; }</code> <br> <s>         </s> . <s>          .</s>           . ‚Ä¶ <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); }</code> <br>     .   ,     ,   - .    , : <br> <br>        ,      <code>Token</code> .       <code>dynamic_cast</code>    ,   .  ,    ,      .      <code>std::function</code>        .        .  Boost.Any,  - .            . <br>   ,   .      -  .  ,      ,      . <br> <br> ‚Ä¶        .        .        .        . <br>             . <br> <br> <code class="cpp">enum class TokenType { Operator, Number }; class Token { public: Token(Operator) {} TokenType Type() const { return TokenType::Operator; } }; ‚Ä¶ TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } };</code> <br>   <code>ToString</code>   <code>TokenType</code>       ,   ,   .     . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); }</code> <br>   .   (constant ‚Üí scalar)   . <br> <br> <code class="cpp">class Token { public: Token(Operator) :m_type(TokenType::Operator) {} Token(double) :m_type(TokenType::Number) {} TokenType Type() const { return m_type; } private: TokenType m_type; };</code> <br> ‚Ä¶ <s>       </s> . <s>       </s> .        .        . <br>    . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); }</code> <br>            . <br> <br> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} operator Operator() const { return m_operator; } ‚Ä¶ Operator m_operator; };</code> <br>      . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); }</code> <br>          ,  ,       <code>union</code> .         . <br> <br> <b class="spoiler_title">Token</b> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: return "Unknown token."; } }</code> <br> <br>  ,    ,      ,    .       .    . <br> <br> <i>          .</i>               .            .       . <br>        : <br> <br> <code class="cpp"> if(expr[0] &gt;= '0' &amp;&amp; expr[0] &lt;= '9') { return{ (double) expr[0] - '0' }; } return{ static_cast&lt;Operator&gt;(expr[0]) };</code> <br>      ,   . <br> <br> ‚Ä¶ <s>          .</s> <i>              .</i> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); }</code> <br> ,     <code>C</code>   ,  <code>isdigit</code> , ,       <code>atof</code> ,    ,      <code>wchar_t</code> .  (expression ‚Üí function).         . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { const wchar_t *current = expr.c_str(); if(!*current) return{}; if(iswdigit(*current)) return{ _wtof(current) }; return{ static_cast&lt;Operator&gt;(*current) }; }</code> <br>         .      . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>   ,        .  ,     .     .   <code>result</code> ,     . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); if(!*current) return result; if(iswdigit(*current)) { result.push_back(_wtof(current)); } else { result.push_back(static_cast&lt;Operator&gt;(*current)); } return result; }</code> <br>      :   (if ‚Üí while).     ,        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } } return result; }</code> <br>  <code>wcstod</code>    ,   <code>_wtof</code> ,           .           ,              .  ,    . <br> <br> <s>           .</s>       . <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>  (unconditional ‚Üí if)    ,    . <br> <br> <code class="cpp"> while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else if(*current == static_cast&lt;wchar_t&gt;(Operator::Plus)) { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } else { ++current; } }</code> <br>       .          .       <code>Detail</code>      .   <code>Tokenize</code>       . <br> <br> <code class="cpp">inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); }</code> <br> <b class="spoiler_title"> Detail::Tokenizer</b> <code class="cpp">namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { return *m_current == static_cast&lt;wchar_t&gt;(Operator::Plus); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail</code> <br> <br>  ,      .      ,  , .       . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); }</code> <br>      <code>Operator</code> ,    . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', };</code> <br>   .         <code>IsOperator</code>  <code>Tokenizer</code> . <br> <br> <code class="cpp"> bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); }</code> <br>         .        . <br> <br> <b class="spoiler_title">Interpreter.h</b> <code class="cpp">#pragma once; #include &lt;vector&gt; #include &lt;wchar.h&gt; #include &lt;algorithm&gt; namespace Interpreter { enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', }; inline std::wstring ToString(const Operator &amp;op) { return{ static_cast&lt;wchar_t&gt;(op) }; } enum class TokenType { Operator, Number }; inline std::wstring ToString(const TokenType &amp;type) { switch(type) { case TokenType::Operator: return L"Operator"; case TokenType::Number: return L"Number"; default: throw std::out_of_range("TokenType"); } } class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } friend inline bool operator==(const Token &amp;left, const Token &amp;right) { if(left.m_type == right.m_type) { switch(left.m_type) { case Interpreter::TokenType::Operator: return left.m_operator == right.m_operator; case Interpreter::TokenType::Number: return left.m_number == right.m_number; default: throw std::out_of_range("TokenType"); } } return false; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: throw std::out_of_range("TokenType"); } } typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); } } // namespace Lexer } // namespace Interpreter</code> <br> <br> <b class="spoiler_title">InterpreterTests.cpp</b> <code class="cpp">#include "stdafx.h" #include "CppUnitTest.h" #include "Interpreter.h" namespace InterpreterTests { using namespace Microsoft::VisualStudio::CppUnitTestFramework; using namespace Interpreter; using namespace std; namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual&lt;T&gt;(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange TEST_CLASS(LexerTests) { public: TEST_METHOD(Should_return_empty_token_list_when_put_empty_expression) { Tokens tokens = Lexer::Tokenize(L""); Assert::IsTrue(tokens.empty()); } TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); } TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); } TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); } TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); } }; TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); } TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); } TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); } }; }</code> <br> <br> <a href="https://github.com/Unril/InterpreterTDD/releases/tag/%25D0%259A%25D0%25BE%25D0%25BD%25D0%25B5%25D1%2586_%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B2%25D0%25BE%25D0%25B9_%25D1%2587%25D0%25B0%25D1%2581%25D1%2582%25D0%25B8">    GitHub</a> .         ,  .      "__". <br> <br>   <a href="http://habrahabr.ru/post/232081/">    </a> .      ,      <a href="http://habrahabr.ru/post/232097/">    </a> .</code> </li> <li> <code><code>std::vector,      Tokens</code> .            . <br> <br> <code class="cpp">#pragma once; #include &lt;vector&gt; namespace Interpreter { struct Token {}; typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { inline Tokens Tokenize(std::string expr) { throw std::exception(); } } // namespace Lexer } // namespace Interpreter</code> <br>   ,  ,   , .   ,    ,    <a href="http://cleancoder.posterous.com/the-transformation-priority-premise">The Transformation Priority Premise (TPP)</a>   .    , ,    ,     ,        .            .     ,     ,      ,           .  ,  ,   (   )    ,  ,  .     ,  ,         .     ,   TPP          . <br> <br>   : <br> <br> ({} ‚Üí nil)     ,   . (nil ‚Üí constant)    . (constant ‚Üí constant+)      (        ,  ). (constant ‚Üí scalar)    ,  . (statement ‚Üí statements)    (break, continue, return  ). (unconditional ‚Üí if)       . (scalar ‚Üí array)  / . (array ‚Üí container)     . (statement ‚Üí recursion)   . (if ‚Üí while)    . (expression ‚Üí function)   . (variable ‚Üí assignment)   . <br>        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::string expr) { return{}; }</code> <br> ,         .     . <br> <br> <s>         </s> .           .           .               .            .       . <br>  ,  <code>std::string</code>  <code>std::wstring</code> .         ,      Unicode.     . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); }</code> <br>  <code>AssertRange</code> -   ,       <code>AreEqual</code> ,   ,  ,    . <br> <br> <b class="spoiler_title">AssertRange</b> <code class="cpp">namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange</code> <br> <br>         <code>Operator</code>    .          <code>wchar_t</code>   ,         ,      . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', }; typedef Operator Token;</code> <br>    ,   ,        <code>Assert</code> ,    <code>ToString</code> ,    . <br> <br> <b class="spoiler_title">std::wstring ToString(const Token &amp;)</b> <code class="cpp">inline std::wstring ToString(const Token &amp;token) { return{ static_cast&lt;wchar_t&gt;(token) }; }</code> <br> <br>    ,   ,        .  ,   (unconditional ‚Üí if). <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { if(expr.empty()) { return{}; } return{ static_cast&lt;Operator&gt;(expr[0]) }; }</code> <br> <s>         </s> . <s>          .</s>           . ‚Ä¶ <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); }</code> <br>     .   ,     ,   - .    , : <br> <br>        ,      <code>Token</code> .       <code>dynamic_cast</code>    ,   .  ,    ,      .      <code>std::function</code>        .        .  Boost.Any,  - .            . <br>   ,   .      -  .  ,      ,      . <br> <br> ‚Ä¶        .        .        .        . <br>             . <br> <br> <code class="cpp">enum class TokenType { Operator, Number }; class Token { public: Token(Operator) {} TokenType Type() const { return TokenType::Operator; } }; ‚Ä¶ TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } };</code> <br>   <code>ToString</code>   <code>TokenType</code>       ,   ,   .     . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); }</code> <br>   .   (constant ‚Üí scalar)   . <br> <br> <code class="cpp">class Token { public: Token(Operator) :m_type(TokenType::Operator) {} Token(double) :m_type(TokenType::Number) {} TokenType Type() const { return m_type; } private: TokenType m_type; };</code> <br> ‚Ä¶ <s>       </s> . <s>       </s> .        .        . <br>    . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); }</code> <br>            . <br> <br> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} operator Operator() const { return m_operator; } ‚Ä¶ Operator m_operator; };</code> <br>      . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); }</code> <br>          ,  ,       <code>union</code> .         . <br> <br> <b class="spoiler_title">Token</b> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: return "Unknown token."; } }</code> <br> <br>  ,    ,      ,    .       .    . <br> <br> <i>          .</i>               .            .       . <br>        : <br> <br> <code class="cpp"> if(expr[0] &gt;= '0' &amp;&amp; expr[0] &lt;= '9') { return{ (double) expr[0] - '0' }; } return{ static_cast&lt;Operator&gt;(expr[0]) };</code> <br>      ,   . <br> <br> ‚Ä¶ <s>          .</s> <i>              .</i> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); }</code> <br> ,     <code>C</code>   ,  <code>isdigit</code> , ,       <code>atof</code> ,    ,      <code>wchar_t</code> .  (expression ‚Üí function).         . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { const wchar_t *current = expr.c_str(); if(!*current) return{}; if(iswdigit(*current)) return{ _wtof(current) }; return{ static_cast&lt;Operator&gt;(*current) }; }</code> <br>         .      . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>   ,        .  ,     .     .   <code>result</code> ,     . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); if(!*current) return result; if(iswdigit(*current)) { result.push_back(_wtof(current)); } else { result.push_back(static_cast&lt;Operator&gt;(*current)); } return result; }</code> <br>      :   (if ‚Üí while).     ,        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } } return result; }</code> <br>  <code>wcstod</code>    ,   <code>_wtof</code> ,           .           ,              .  ,    . <br> <br> <s>           .</s>       . <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>  (unconditional ‚Üí if)    ,    . <br> <br> <code class="cpp"> while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else if(*current == static_cast&lt;wchar_t&gt;(Operator::Plus)) { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } else { ++current; } }</code> <br>       .          .       <code>Detail</code>      .   <code>Tokenize</code>       . <br> <br> <code class="cpp">inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); }</code> <br> <b class="spoiler_title"> Detail::Tokenizer</b> <code class="cpp">namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { return *m_current == static_cast&lt;wchar_t&gt;(Operator::Plus); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail</code> <br> <br>  ,      .      ,  , .       . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); }</code> <br>      <code>Operator</code> ,    . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', };</code> <br>   .         <code>IsOperator</code>  <code>Tokenizer</code> . <br> <br> <code class="cpp"> bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); }</code> <br>         .        . <br> <br> <b class="spoiler_title">Interpreter.h</b> <code class="cpp">#pragma once; #include &lt;vector&gt; #include &lt;wchar.h&gt; #include &lt;algorithm&gt; namespace Interpreter { enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', }; inline std::wstring ToString(const Operator &amp;op) { return{ static_cast&lt;wchar_t&gt;(op) }; } enum class TokenType { Operator, Number }; inline std::wstring ToString(const TokenType &amp;type) { switch(type) { case TokenType::Operator: return L"Operator"; case TokenType::Number: return L"Number"; default: throw std::out_of_range("TokenType"); } } class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } friend inline bool operator==(const Token &amp;left, const Token &amp;right) { if(left.m_type == right.m_type) { switch(left.m_type) { case Interpreter::TokenType::Operator: return left.m_operator == right.m_operator; case Interpreter::TokenType::Number: return left.m_number == right.m_number; default: throw std::out_of_range("TokenType"); } } return false; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: throw std::out_of_range("TokenType"); } } typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); } } // namespace Lexer } // namespace Interpreter</code> <br> <br> <b class="spoiler_title">InterpreterTests.cpp</b> <code class="cpp">#include "stdafx.h" #include "CppUnitTest.h" #include "Interpreter.h" namespace InterpreterTests { using namespace Microsoft::VisualStudio::CppUnitTestFramework; using namespace Interpreter; using namespace std; namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual&lt;T&gt;(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange TEST_CLASS(LexerTests) { public: TEST_METHOD(Should_return_empty_token_list_when_put_empty_expression) { Tokens tokens = Lexer::Tokenize(L""); Assert::IsTrue(tokens.empty()); } TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); } TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); } TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); } TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); } }; TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); } TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); } TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); } }; }</code> <br> <br> <a href="https://github.com/Unril/InterpreterTDD/releases/tag/%25D0%259A%25D0%25BE%25D0%25BD%25D0%25B5%25D1%2586_%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B2%25D0%25BE%25D0%25B9_%25D1%2587%25D0%25B0%25D1%2581%25D1%2582%25D0%25B8">    GitHub</a> .         ,  .      "__". <br> <br>   <a href="http://habrahabr.ru/post/232081/">    </a> .      ,      <a href="http://habrahabr.ru/post/232097/">    </a> .</code> </li> <li> <code><code>std::vector,      Tokens</code> .            . <br> <br> <code class="cpp">#pragma once; #include &lt;vector&gt; namespace Interpreter { struct Token {}; typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { inline Tokens Tokenize(std::string expr) { throw std::exception(); } } // namespace Lexer } // namespace Interpreter</code> <br>   ,  ,   , .   ,    ,    <a href="http://cleancoder.posterous.com/the-transformation-priority-premise">The Transformation Priority Premise (TPP)</a>   .    , ,    ,     ,        .            .     ,     ,      ,           .  ,  ,   (   )    ,  ,  .     ,  ,         .     ,   TPP          . <br> <br>   : <br> <br> ({} ‚Üí nil)     ,   . (nil ‚Üí constant)    . (constant ‚Üí constant+)      (        ,  ). (constant ‚Üí scalar)    ,  . (statement ‚Üí statements)    (break, continue, return  ). (unconditional ‚Üí if)       . (scalar ‚Üí array)  / . (array ‚Üí container)     . (statement ‚Üí recursion)   . (if ‚Üí while)    . (expression ‚Üí function)   . (variable ‚Üí assignment)   . <br>        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::string expr) { return{}; }</code> <br> ,         .     . <br> <br> <s>         </s> .           .           .               .            .       . <br>  ,  <code>std::string</code>  <code>std::wstring</code> .         ,      Unicode.     . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); }</code> <br>  <code>AssertRange</code> -   ,       <code>AreEqual</code> ,   ,  ,    . <br> <br> <b class="spoiler_title">AssertRange</b> <code class="cpp">namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange</code> <br> <br>         <code>Operator</code>    .          <code>wchar_t</code>   ,         ,      . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', }; typedef Operator Token;</code> <br>    ,   ,        <code>Assert</code> ,    <code>ToString</code> ,    . <br> <br> <b class="spoiler_title">std::wstring ToString(const Token &amp;)</b> <code class="cpp">inline std::wstring ToString(const Token &amp;token) { return{ static_cast&lt;wchar_t&gt;(token) }; }</code> <br> <br>    ,   ,        .  ,   (unconditional ‚Üí if). <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { if(expr.empty()) { return{}; } return{ static_cast&lt;Operator&gt;(expr[0]) }; }</code> <br> <s>         </s> . <s>          .</s>           . ‚Ä¶ <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); }</code> <br>     .   ,     ,   - .    , : <br> <br>        ,      <code>Token</code> .       <code>dynamic_cast</code>    ,   .  ,    ,      .      <code>std::function</code>        .        .  Boost.Any,  - .            . <br>   ,   .      -  .  ,      ,      . <br> <br> ‚Ä¶        .        .        .        . <br>             . <br> <br> <code class="cpp">enum class TokenType { Operator, Number }; class Token { public: Token(Operator) {} TokenType Type() const { return TokenType::Operator; } }; ‚Ä¶ TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } };</code> <br>   <code>ToString</code>   <code>TokenType</code>       ,   ,   .     . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); }</code> <br>   .   (constant ‚Üí scalar)   . <br> <br> <code class="cpp">class Token { public: Token(Operator) :m_type(TokenType::Operator) {} Token(double) :m_type(TokenType::Number) {} TokenType Type() const { return m_type; } private: TokenType m_type; };</code> <br> ‚Ä¶ <s>       </s> . <s>       </s> .        .        . <br>    . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); }</code> <br>            . <br> <br> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} operator Operator() const { return m_operator; } ‚Ä¶ Operator m_operator; };</code> <br>      . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); }</code> <br>          ,  ,       <code>union</code> .         . <br> <br> <b class="spoiler_title">Token</b> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: return "Unknown token."; } }</code> <br> <br>  ,    ,      ,    .       .    . <br> <br> <i>          .</i>               .            .       . <br>        : <br> <br> <code class="cpp"> if(expr[0] &gt;= '0' &amp;&amp; expr[0] &lt;= '9') { return{ (double) expr[0] - '0' }; } return{ static_cast&lt;Operator&gt;(expr[0]) };</code> <br>      ,   . <br> <br> ‚Ä¶ <s>          .</s> <i>              .</i> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); }</code> <br> ,     <code>C</code>   ,  <code>isdigit</code> , ,       <code>atof</code> ,    ,      <code>wchar_t</code> .  (expression ‚Üí function).         . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { const wchar_t *current = expr.c_str(); if(!*current) return{}; if(iswdigit(*current)) return{ _wtof(current) }; return{ static_cast&lt;Operator&gt;(*current) }; }</code> <br>         .      . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>   ,        .  ,     .     .   <code>result</code> ,     . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); if(!*current) return result; if(iswdigit(*current)) { result.push_back(_wtof(current)); } else { result.push_back(static_cast&lt;Operator&gt;(*current)); } return result; }</code> <br>      :   (if ‚Üí while).     ,        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } } return result; }</code> <br>  <code>wcstod</code>    ,   <code>_wtof</code> ,           .           ,              .  ,    . <br> <br> <s>           .</s>       . <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>  (unconditional ‚Üí if)    ,    . <br> <br> <code class="cpp"> while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else if(*current == static_cast&lt;wchar_t&gt;(Operator::Plus)) { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } else { ++current; } }</code> <br>       .          .       <code>Detail</code>      .   <code>Tokenize</code>       . <br> <br> <code class="cpp">inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); }</code> <br> <b class="spoiler_title"> Detail::Tokenizer</b> <code class="cpp">namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { return *m_current == static_cast&lt;wchar_t&gt;(Operator::Plus); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail</code> <br> <br>  ,      .      ,  , .       . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); }</code> <br>      <code>Operator</code> ,    . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', };</code> <br>   .         <code>IsOperator</code>  <code>Tokenizer</code> . <br> <br> <code class="cpp"> bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); }</code> <br>         .        . <br> <br> <b class="spoiler_title">Interpreter.h</b> <code class="cpp">#pragma once; #include &lt;vector&gt; #include &lt;wchar.h&gt; #include &lt;algorithm&gt; namespace Interpreter { enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', }; inline std::wstring ToString(const Operator &amp;op) { return{ static_cast&lt;wchar_t&gt;(op) }; } enum class TokenType { Operator, Number }; inline std::wstring ToString(const TokenType &amp;type) { switch(type) { case TokenType::Operator: return L"Operator"; case TokenType::Number: return L"Number"; default: throw std::out_of_range("TokenType"); } } class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } friend inline bool operator==(const Token &amp;left, const Token &amp;right) { if(left.m_type == right.m_type) { switch(left.m_type) { case Interpreter::TokenType::Operator: return left.m_operator == right.m_operator; case Interpreter::TokenType::Number: return left.m_number == right.m_number; default: throw std::out_of_range("TokenType"); } } return false; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: throw std::out_of_range("TokenType"); } } typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); } } // namespace Lexer } // namespace Interpreter</code> <br> <br> <b class="spoiler_title">InterpreterTests.cpp</b> <code class="cpp">#include "stdafx.h" #include "CppUnitTest.h" #include "Interpreter.h" namespace InterpreterTests { using namespace Microsoft::VisualStudio::CppUnitTestFramework; using namespace Interpreter; using namespace std; namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual&lt;T&gt;(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange TEST_CLASS(LexerTests) { public: TEST_METHOD(Should_return_empty_token_list_when_put_empty_expression) { Tokens tokens = Lexer::Tokenize(L""); Assert::IsTrue(tokens.empty()); } TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); } TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); } TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); } TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); } }; TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); } TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); } TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); } }; }</code> <br> <br> <a href="https://github.com/Unril/InterpreterTDD/releases/tag/%25D0%259A%25D0%25BE%25D0%25BD%25D0%25B5%25D1%2586_%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B2%25D0%25BE%25D0%25B9_%25D1%2587%25D0%25B0%25D1%2581%25D1%2582%25D0%25B8">    GitHub</a> .         ,  .      "__". <br> <br>   <a href="http://habrahabr.ru/post/232081/">    </a> .      ,      <a href="http://habrahabr.ru/post/232097/">    </a> .</code> </li> <li> <code><code>std::vector,      Tokens</code> .            . <br> <br> <code class="cpp">#pragma once; #include &lt;vector&gt; namespace Interpreter { struct Token {}; typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { inline Tokens Tokenize(std::string expr) { throw std::exception(); } } // namespace Lexer } // namespace Interpreter</code> <br>   ,  ,   , .   ,    ,    <a href="http://cleancoder.posterous.com/the-transformation-priority-premise">The Transformation Priority Premise (TPP)</a>   .    , ,    ,     ,        .            .     ,     ,      ,           .  ,  ,   (   )    ,  ,  .     ,  ,         .     ,   TPP          . <br> <br>   : <br> <br> ({} ‚Üí nil)     ,   . (nil ‚Üí constant)    . (constant ‚Üí constant+)      (        ,  ). (constant ‚Üí scalar)    ,  . (statement ‚Üí statements)    (break, continue, return  ). (unconditional ‚Üí if)       . (scalar ‚Üí array)  / . (array ‚Üí container)     . (statement ‚Üí recursion)   . (if ‚Üí while)    . (expression ‚Üí function)   . (variable ‚Üí assignment)   . <br>        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::string expr) { return{}; }</code> <br> ,         .     . <br> <br> <s>         </s> .           .           .               .            .       . <br>  ,  <code>std::string</code>  <code>std::wstring</code> .         ,      Unicode.     . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); }</code> <br>  <code>AssertRange</code> -   ,       <code>AreEqual</code> ,   ,  ,    . <br> <br> <b class="spoiler_title">AssertRange</b> <code class="cpp">namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange</code> <br> <br>         <code>Operator</code>    .          <code>wchar_t</code>   ,         ,      . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', }; typedef Operator Token;</code> <br>    ,   ,        <code>Assert</code> ,    <code>ToString</code> ,    . <br> <br> <b class="spoiler_title">std::wstring ToString(const Token &amp;)</b> <code class="cpp">inline std::wstring ToString(const Token &amp;token) { return{ static_cast&lt;wchar_t&gt;(token) }; }</code> <br> <br>    ,   ,        .  ,   (unconditional ‚Üí if). <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { if(expr.empty()) { return{}; } return{ static_cast&lt;Operator&gt;(expr[0]) }; }</code> <br> <s>         </s> . <s>          .</s>           . ‚Ä¶ <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); }</code> <br>     .   ,     ,   - .    , : <br> <br>        ,      <code>Token</code> .       <code>dynamic_cast</code>    ,   .  ,    ,      .      <code>std::function</code>        .        .  Boost.Any,  - .            . <br>   ,   .      -  .  ,      ,      . <br> <br> ‚Ä¶        .        .        .        . <br>             . <br> <br> <code class="cpp">enum class TokenType { Operator, Number }; class Token { public: Token(Operator) {} TokenType Type() const { return TokenType::Operator; } }; ‚Ä¶ TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } };</code> <br>   <code>ToString</code>   <code>TokenType</code>       ,   ,   .     . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); }</code> <br>   .   (constant ‚Üí scalar)   . <br> <br> <code class="cpp">class Token { public: Token(Operator) :m_type(TokenType::Operator) {} Token(double) :m_type(TokenType::Number) {} TokenType Type() const { return m_type; } private: TokenType m_type; };</code> <br> ‚Ä¶ <s>       </s> . <s>       </s> .        .        . <br>    . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); }</code> <br>            . <br> <br> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} operator Operator() const { return m_operator; } ‚Ä¶ Operator m_operator; };</code> <br>      . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); }</code> <br>          ,  ,       <code>union</code> .         . <br> <br> <b class="spoiler_title">Token</b> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: return "Unknown token."; } }</code> <br> <br>  ,    ,      ,    .       .    . <br> <br> <i>          .</i>               .            .       . <br>        : <br> <br> <code class="cpp"> if(expr[0] &gt;= '0' &amp;&amp; expr[0] &lt;= '9') { return{ (double) expr[0] - '0' }; } return{ static_cast&lt;Operator&gt;(expr[0]) };</code> <br>      ,   . <br> <br> ‚Ä¶ <s>          .</s> <i>              .</i> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); }</code> <br> ,     <code>C</code>   ,  <code>isdigit</code> , ,       <code>atof</code> ,    ,      <code>wchar_t</code> .  (expression ‚Üí function).         . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { const wchar_t *current = expr.c_str(); if(!*current) return{}; if(iswdigit(*current)) return{ _wtof(current) }; return{ static_cast&lt;Operator&gt;(*current) }; }</code> <br>         .      . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>   ,        .  ,     .     .   <code>result</code> ,     . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); if(!*current) return result; if(iswdigit(*current)) { result.push_back(_wtof(current)); } else { result.push_back(static_cast&lt;Operator&gt;(*current)); } return result; }</code> <br>      :   (if ‚Üí while).     ,        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } } return result; }</code> <br>  <code>wcstod</code>    ,   <code>_wtof</code> ,           .           ,              .  ,    . <br> <br> <s>           .</s>       . <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>  (unconditional ‚Üí if)    ,    . <br> <br> <code class="cpp"> while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else if(*current == static_cast&lt;wchar_t&gt;(Operator::Plus)) { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } else { ++current; } }</code> <br>       .          .       <code>Detail</code>      .   <code>Tokenize</code>       . <br> <br> <code class="cpp">inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); }</code> <br> <b class="spoiler_title"> Detail::Tokenizer</b> <code class="cpp">namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { return *m_current == static_cast&lt;wchar_t&gt;(Operator::Plus); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail</code> <br> <br>  ,      .      ,  , .       . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); }</code> <br>      <code>Operator</code> ,    . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', };</code> <br>   .         <code>IsOperator</code>  <code>Tokenizer</code> . <br> <br> <code class="cpp"> bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); }</code> <br>         .        . <br> <br> <b class="spoiler_title">Interpreter.h</b> <code class="cpp">#pragma once; #include &lt;vector&gt; #include &lt;wchar.h&gt; #include &lt;algorithm&gt; namespace Interpreter { enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', }; inline std::wstring ToString(const Operator &amp;op) { return{ static_cast&lt;wchar_t&gt;(op) }; } enum class TokenType { Operator, Number }; inline std::wstring ToString(const TokenType &amp;type) { switch(type) { case TokenType::Operator: return L"Operator"; case TokenType::Number: return L"Number"; default: throw std::out_of_range("TokenType"); } } class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } friend inline bool operator==(const Token &amp;left, const Token &amp;right) { if(left.m_type == right.m_type) { switch(left.m_type) { case Interpreter::TokenType::Operator: return left.m_operator == right.m_operator; case Interpreter::TokenType::Number: return left.m_number == right.m_number; default: throw std::out_of_range("TokenType"); } } return false; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: throw std::out_of_range("TokenType"); } } typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); } } // namespace Lexer } // namespace Interpreter</code> <br> <br> <b class="spoiler_title">InterpreterTests.cpp</b> <code class="cpp">#include "stdafx.h" #include "CppUnitTest.h" #include "Interpreter.h" namespace InterpreterTests { using namespace Microsoft::VisualStudio::CppUnitTestFramework; using namespace Interpreter; using namespace std; namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual&lt;T&gt;(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange TEST_CLASS(LexerTests) { public: TEST_METHOD(Should_return_empty_token_list_when_put_empty_expression) { Tokens tokens = Lexer::Tokenize(L""); Assert::IsTrue(tokens.empty()); } TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); } TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); } TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); } TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); } }; TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); } TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); } TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); } }; }</code> <br> <br> <a href="https://github.com/Unril/InterpreterTDD/releases/tag/%25D0%259A%25D0%25BE%25D0%25BD%25D0%25B5%25D1%2586_%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B2%25D0%25BE%25D0%25B9_%25D1%2587%25D0%25B0%25D1%2581%25D1%2582%25D0%25B8">    GitHub</a> .         ,  .      "__". <br> <br>   <a href="http://habrahabr.ru/post/232081/">    </a> .      ,      <a href="http://habrahabr.ru/post/232097/">    </a> .</code> </li> <li> <code><code>std::vector,      Tokens</code> .            . <br> <br> <code class="cpp">#pragma once; #include &lt;vector&gt; namespace Interpreter { struct Token {}; typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { inline Tokens Tokenize(std::string expr) { throw std::exception(); } } // namespace Lexer } // namespace Interpreter</code> <br>   ,  ,   , .   ,    ,    <a href="http://cleancoder.posterous.com/the-transformation-priority-premise">The Transformation Priority Premise (TPP)</a>   .    , ,    ,     ,        .            .     ,     ,      ,           .  ,  ,   (   )    ,  ,  .     ,  ,         .     ,   TPP          . <br> <br>   : <br> <br> ({} ‚Üí nil)     ,   . (nil ‚Üí constant)    . (constant ‚Üí constant+)      (        ,  ). (constant ‚Üí scalar)    ,  . (statement ‚Üí statements)    (break, continue, return  ). (unconditional ‚Üí if)       . (scalar ‚Üí array)  / . (array ‚Üí container)     . (statement ‚Üí recursion)   . (if ‚Üí while)    . (expression ‚Üí function)   . (variable ‚Üí assignment)   . <br>        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::string expr) { return{}; }</code> <br> ,         .     . <br> <br> <s>         </s> .           .           .               .            .       . <br>  ,  <code>std::string</code>  <code>std::wstring</code> .         ,      Unicode.     . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); }</code> <br>  <code>AssertRange</code> -   ,       <code>AreEqual</code> ,   ,  ,    . <br> <br> <b class="spoiler_title">AssertRange</b> <code class="cpp">namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange</code> <br> <br>         <code>Operator</code>    .          <code>wchar_t</code>   ,         ,      . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', }; typedef Operator Token;</code> <br>    ,   ,        <code>Assert</code> ,    <code>ToString</code> ,    . <br> <br> <b class="spoiler_title">std::wstring ToString(const Token &amp;)</b> <code class="cpp">inline std::wstring ToString(const Token &amp;token) { return{ static_cast&lt;wchar_t&gt;(token) }; }</code> <br> <br>    ,   ,        .  ,   (unconditional ‚Üí if). <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { if(expr.empty()) { return{}; } return{ static_cast&lt;Operator&gt;(expr[0]) }; }</code> <br> <s>         </s> . <s>          .</s>           . ‚Ä¶ <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); }</code> <br>     .   ,     ,   - .    , : <br> <br>        ,      <code>Token</code> .       <code>dynamic_cast</code>    ,   .  ,    ,      .      <code>std::function</code>        .        .  Boost.Any,  - .            . <br>   ,   .      -  .  ,      ,      . <br> <br> ‚Ä¶        .        .        .        . <br>             . <br> <br> <code class="cpp">enum class TokenType { Operator, Number }; class Token { public: Token(Operator) {} TokenType Type() const { return TokenType::Operator; } }; ‚Ä¶ TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } };</code> <br>   <code>ToString</code>   <code>TokenType</code>       ,   ,   .     . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); }</code> <br>   .   (constant ‚Üí scalar)   . <br> <br> <code class="cpp">class Token { public: Token(Operator) :m_type(TokenType::Operator) {} Token(double) :m_type(TokenType::Number) {} TokenType Type() const { return m_type; } private: TokenType m_type; };</code> <br> ‚Ä¶ <s>       </s> . <s>       </s> .        .        . <br>    . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); }</code> <br>            . <br> <br> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} operator Operator() const { return m_operator; } ‚Ä¶ Operator m_operator; };</code> <br>      . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); }</code> <br>          ,  ,       <code>union</code> .         . <br> <br> <b class="spoiler_title">Token</b> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: return "Unknown token."; } }</code> <br> <br>  ,    ,      ,    .       .    . <br> <br> <i>          .</i>               .            .       . <br>        : <br> <br> <code class="cpp"> if(expr[0] &gt;= '0' &amp;&amp; expr[0] &lt;= '9') { return{ (double) expr[0] - '0' }; } return{ static_cast&lt;Operator&gt;(expr[0]) };</code> <br>      ,   . <br> <br> ‚Ä¶ <s>          .</s> <i>              .</i> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); }</code> <br> ,     <code>C</code>   ,  <code>isdigit</code> , ,       <code>atof</code> ,    ,      <code>wchar_t</code> .  (expression ‚Üí function).         . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { const wchar_t *current = expr.c_str(); if(!*current) return{}; if(iswdigit(*current)) return{ _wtof(current) }; return{ static_cast&lt;Operator&gt;(*current) }; }</code> <br>         .      . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>   ,        .  ,     .     .   <code>result</code> ,     . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); if(!*current) return result; if(iswdigit(*current)) { result.push_back(_wtof(current)); } else { result.push_back(static_cast&lt;Operator&gt;(*current)); } return result; }</code> <br>      :   (if ‚Üí while).     ,        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } } return result; }</code> <br>  <code>wcstod</code>    ,   <code>_wtof</code> ,           .           ,              .  ,    . <br> <br> <s>           .</s>       . <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>  (unconditional ‚Üí if)    ,    . <br> <br> <code class="cpp"> while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else if(*current == static_cast&lt;wchar_t&gt;(Operator::Plus)) { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } else { ++current; } }</code> <br>       .          .       <code>Detail</code>      .   <code>Tokenize</code>       . <br> <br> <code class="cpp">inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); }</code> <br> <b class="spoiler_title"> Detail::Tokenizer</b> <code class="cpp">namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { return *m_current == static_cast&lt;wchar_t&gt;(Operator::Plus); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail</code> <br> <br>  ,      .      ,  , .       . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); }</code> <br>      <code>Operator</code> ,    . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', };</code> <br>   .         <code>IsOperator</code>  <code>Tokenizer</code> . <br> <br> <code class="cpp"> bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); }</code> <br>         .        . <br> <br> <b class="spoiler_title">Interpreter.h</b> <code class="cpp">#pragma once; #include &lt;vector&gt; #include &lt;wchar.h&gt; #include &lt;algorithm&gt; namespace Interpreter { enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', }; inline std::wstring ToString(const Operator &amp;op) { return{ static_cast&lt;wchar_t&gt;(op) }; } enum class TokenType { Operator, Number }; inline std::wstring ToString(const TokenType &amp;type) { switch(type) { case TokenType::Operator: return L"Operator"; case TokenType::Number: return L"Number"; default: throw std::out_of_range("TokenType"); } } class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } friend inline bool operator==(const Token &amp;left, const Token &amp;right) { if(left.m_type == right.m_type) { switch(left.m_type) { case Interpreter::TokenType::Operator: return left.m_operator == right.m_operator; case Interpreter::TokenType::Number: return left.m_number == right.m_number; default: throw std::out_of_range("TokenType"); } } return false; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: throw std::out_of_range("TokenType"); } } typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); } } // namespace Lexer } // namespace Interpreter</code> <br> <br> <b class="spoiler_title">InterpreterTests.cpp</b> <code class="cpp">#include "stdafx.h" #include "CppUnitTest.h" #include "Interpreter.h" namespace InterpreterTests { using namespace Microsoft::VisualStudio::CppUnitTestFramework; using namespace Interpreter; using namespace std; namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual&lt;T&gt;(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange TEST_CLASS(LexerTests) { public: TEST_METHOD(Should_return_empty_token_list_when_put_empty_expression) { Tokens tokens = Lexer::Tokenize(L""); Assert::IsTrue(tokens.empty()); } TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); } TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); } TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); } TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); } }; TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); } TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); } TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); } }; }</code> <br> <br> <a href="https://github.com/Unril/InterpreterTDD/releases/tag/%25D0%259A%25D0%25BE%25D0%25BD%25D0%25B5%25D1%2586_%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B2%25D0%25BE%25D0%25B9_%25D1%2587%25D0%25B0%25D1%2581%25D1%2582%25D0%25B8">    GitHub</a> .         ,  .      "__". <br> <br>   <a href="http://habrahabr.ru/post/232081/">    </a> .      ,      <a href="http://habrahabr.ru/post/232097/">    </a> .</code> </li> <li> <code><code>std::vector,      Tokens</code> .            . <br> <br> <code class="cpp">#pragma once; #include &lt;vector&gt; namespace Interpreter { struct Token {}; typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { inline Tokens Tokenize(std::string expr) { throw std::exception(); } } // namespace Lexer } // namespace Interpreter</code> <br>   ,  ,   , .   ,    ,    <a href="http://cleancoder.posterous.com/the-transformation-priority-premise">The Transformation Priority Premise (TPP)</a>   .    , ,    ,     ,        .            .     ,     ,      ,           .  ,  ,   (   )    ,  ,  .     ,  ,         .     ,   TPP          . <br> <br>   : <br> <br> ({} ‚Üí nil)     ,   . (nil ‚Üí constant)    . (constant ‚Üí constant+)      (        ,  ). (constant ‚Üí scalar)    ,  . (statement ‚Üí statements)    (break, continue, return  ). (unconditional ‚Üí if)       . (scalar ‚Üí array)  / . (array ‚Üí container)     . (statement ‚Üí recursion)   . (if ‚Üí while)    . (expression ‚Üí function)   . (variable ‚Üí assignment)   . <br>        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::string expr) { return{}; }</code> <br> ,         .     . <br> <br> <s>         </s> .           .           .               .            .       . <br>  ,  <code>std::string</code>  <code>std::wstring</code> .         ,      Unicode.     . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); }</code> <br>  <code>AssertRange</code> -   ,       <code>AreEqual</code> ,   ,  ,    . <br> <br> <b class="spoiler_title">AssertRange</b> <code class="cpp">namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange</code> <br> <br>         <code>Operator</code>    .          <code>wchar_t</code>   ,         ,      . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', }; typedef Operator Token;</code> <br>    ,   ,        <code>Assert</code> ,    <code>ToString</code> ,    . <br> <br> <b class="spoiler_title">std::wstring ToString(const Token &amp;)</b> <code class="cpp">inline std::wstring ToString(const Token &amp;token) { return{ static_cast&lt;wchar_t&gt;(token) }; }</code> <br> <br>    ,   ,        .  ,   (unconditional ‚Üí if). <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { if(expr.empty()) { return{}; } return{ static_cast&lt;Operator&gt;(expr[0]) }; }</code> <br> <s>         </s> . <s>          .</s>           . ‚Ä¶ <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); }</code> <br>     .   ,     ,   - .    , : <br> <br>        ,      <code>Token</code> .       <code>dynamic_cast</code>    ,   .  ,    ,      .      <code>std::function</code>        .        .  Boost.Any,  - .            . <br>   ,   .      -  .  ,      ,      . <br> <br> ‚Ä¶        .        .        .        . <br>             . <br> <br> <code class="cpp">enum class TokenType { Operator, Number }; class Token { public: Token(Operator) {} TokenType Type() const { return TokenType::Operator; } }; ‚Ä¶ TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } };</code> <br>   <code>ToString</code>   <code>TokenType</code>       ,   ,   .     . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); }</code> <br>   .   (constant ‚Üí scalar)   . <br> <br> <code class="cpp">class Token { public: Token(Operator) :m_type(TokenType::Operator) {} Token(double) :m_type(TokenType::Number) {} TokenType Type() const { return m_type; } private: TokenType m_type; };</code> <br> ‚Ä¶ <s>       </s> . <s>       </s> .        .        . <br>    . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); }</code> <br>            . <br> <br> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} operator Operator() const { return m_operator; } ‚Ä¶ Operator m_operator; };</code> <br>      . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); }</code> <br>          ,  ,       <code>union</code> .         . <br> <br> <b class="spoiler_title">Token</b> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: return "Unknown token."; } }</code> <br> <br>  ,    ,      ,    .       .    . <br> <br> <i>          .</i>               .            .       . <br>        : <br> <br> <code class="cpp"> if(expr[0] &gt;= '0' &amp;&amp; expr[0] &lt;= '9') { return{ (double) expr[0] - '0' }; } return{ static_cast&lt;Operator&gt;(expr[0]) };</code> <br>      ,   . <br> <br> ‚Ä¶ <s>          .</s> <i>              .</i> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); }</code> <br> ,     <code>C</code>   ,  <code>isdigit</code> , ,       <code>atof</code> ,    ,      <code>wchar_t</code> .  (expression ‚Üí function).         . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { const wchar_t *current = expr.c_str(); if(!*current) return{}; if(iswdigit(*current)) return{ _wtof(current) }; return{ static_cast&lt;Operator&gt;(*current) }; }</code> <br>         .      . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>   ,        .  ,     .     .   <code>result</code> ,     . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); if(!*current) return result; if(iswdigit(*current)) { result.push_back(_wtof(current)); } else { result.push_back(static_cast&lt;Operator&gt;(*current)); } return result; }</code> <br>      :   (if ‚Üí while).     ,        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } } return result; }</code> <br>  <code>wcstod</code>    ,   <code>_wtof</code> ,           .           ,              .  ,    . <br> <br> <s>           .</s>       . <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>  (unconditional ‚Üí if)    ,    . <br> <br> <code class="cpp"> while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else if(*current == static_cast&lt;wchar_t&gt;(Operator::Plus)) { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } else { ++current; } }</code> <br>       .          .       <code>Detail</code>      .   <code>Tokenize</code>       . <br> <br> <code class="cpp">inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); }</code> <br> <b class="spoiler_title"> Detail::Tokenizer</b> <code class="cpp">namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { return *m_current == static_cast&lt;wchar_t&gt;(Operator::Plus); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail</code> <br> <br>  ,      .      ,  , .       . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); }</code> <br>      <code>Operator</code> ,    . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', };</code> <br>   .         <code>IsOperator</code>  <code>Tokenizer</code> . <br> <br> <code class="cpp"> bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); }</code> <br>         .        . <br> <br> <b class="spoiler_title">Interpreter.h</b> <code class="cpp">#pragma once; #include &lt;vector&gt; #include &lt;wchar.h&gt; #include &lt;algorithm&gt; namespace Interpreter { enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', }; inline std::wstring ToString(const Operator &amp;op) { return{ static_cast&lt;wchar_t&gt;(op) }; } enum class TokenType { Operator, Number }; inline std::wstring ToString(const TokenType &amp;type) { switch(type) { case TokenType::Operator: return L"Operator"; case TokenType::Number: return L"Number"; default: throw std::out_of_range("TokenType"); } } class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } friend inline bool operator==(const Token &amp;left, const Token &amp;right) { if(left.m_type == right.m_type) { switch(left.m_type) { case Interpreter::TokenType::Operator: return left.m_operator == right.m_operator; case Interpreter::TokenType::Number: return left.m_number == right.m_number; default: throw std::out_of_range("TokenType"); } } return false; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: throw std::out_of_range("TokenType"); } } typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); } } // namespace Lexer } // namespace Interpreter</code> <br> <br> <b class="spoiler_title">InterpreterTests.cpp</b> <code class="cpp">#include "stdafx.h" #include "CppUnitTest.h" #include "Interpreter.h" namespace InterpreterTests { using namespace Microsoft::VisualStudio::CppUnitTestFramework; using namespace Interpreter; using namespace std; namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual&lt;T&gt;(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange TEST_CLASS(LexerTests) { public: TEST_METHOD(Should_return_empty_token_list_when_put_empty_expression) { Tokens tokens = Lexer::Tokenize(L""); Assert::IsTrue(tokens.empty()); } TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); } TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); } TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); } TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); } }; TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); } TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); } TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); } }; }</code> <br> <br> <a href="https://github.com/Unril/InterpreterTDD/releases/tag/%25D0%259A%25D0%25BE%25D0%25BD%25D0%25B5%25D1%2586_%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B2%25D0%25BE%25D0%25B9_%25D1%2587%25D0%25B0%25D1%2581%25D1%2582%25D0%25B8">    GitHub</a> .         ,  .      "__". <br> <br>   <a href="http://habrahabr.ru/post/232081/">    </a> .      ,      <a href="http://habrahabr.ru/post/232097/">    </a> .</code> </li> <li> <code><code>std::vector,      Tokens</code> .            . <br> <br> <code class="cpp">#pragma once; #include &lt;vector&gt; namespace Interpreter { struct Token {}; typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { inline Tokens Tokenize(std::string expr) { throw std::exception(); } } // namespace Lexer } // namespace Interpreter</code> <br>   ,  ,   , .   ,    ,    <a href="http://cleancoder.posterous.com/the-transformation-priority-premise">The Transformation Priority Premise (TPP)</a>   .    , ,    ,     ,        .            .     ,     ,      ,           .  ,  ,   (   )    ,  ,  .     ,  ,         .     ,   TPP          . <br> <br>   : <br> <br> ({} ‚Üí nil)     ,   . (nil ‚Üí constant)    . (constant ‚Üí constant+)      (        ,  ). (constant ‚Üí scalar)    ,  . (statement ‚Üí statements)    (break, continue, return  ). (unconditional ‚Üí if)       . (scalar ‚Üí array)  / . (array ‚Üí container)     . (statement ‚Üí recursion)   . (if ‚Üí while)    . (expression ‚Üí function)   . (variable ‚Üí assignment)   . <br>        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::string expr) { return{}; }</code> <br> ,         .     . <br> <br> <s>         </s> .           .           .               .            .       . <br>  ,  <code>std::string</code>  <code>std::wstring</code> .         ,      Unicode.     . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); }</code> <br>  <code>AssertRange</code> -   ,       <code>AreEqual</code> ,   ,  ,    . <br> <br> <b class="spoiler_title">AssertRange</b> <code class="cpp">namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange</code> <br> <br>         <code>Operator</code>    .          <code>wchar_t</code>   ,         ,      . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', }; typedef Operator Token;</code> <br>    ,   ,        <code>Assert</code> ,    <code>ToString</code> ,    . <br> <br> <b class="spoiler_title">std::wstring ToString(const Token &amp;)</b> <code class="cpp">inline std::wstring ToString(const Token &amp;token) { return{ static_cast&lt;wchar_t&gt;(token) }; }</code> <br> <br>    ,   ,        .  ,   (unconditional ‚Üí if). <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { if(expr.empty()) { return{}; } return{ static_cast&lt;Operator&gt;(expr[0]) }; }</code> <br> <s>         </s> . <s>          .</s>           . ‚Ä¶ <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); }</code> <br>     .   ,     ,   - .    , : <br> <br>        ,      <code>Token</code> .       <code>dynamic_cast</code>    ,   .  ,    ,      .      <code>std::function</code>        .        .  Boost.Any,  - .            . <br>   ,   .      -  .  ,      ,      . <br> <br> ‚Ä¶        .        .        .        . <br>             . <br> <br> <code class="cpp">enum class TokenType { Operator, Number }; class Token { public: Token(Operator) {} TokenType Type() const { return TokenType::Operator; } }; ‚Ä¶ TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } };</code> <br>   <code>ToString</code>   <code>TokenType</code>       ,   ,   .     . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); }</code> <br>   .   (constant ‚Üí scalar)   . <br> <br> <code class="cpp">class Token { public: Token(Operator) :m_type(TokenType::Operator) {} Token(double) :m_type(TokenType::Number) {} TokenType Type() const { return m_type; } private: TokenType m_type; };</code> <br> ‚Ä¶ <s>       </s> . <s>       </s> .        .        . <br>    . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); }</code> <br>            . <br> <br> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} operator Operator() const { return m_operator; } ‚Ä¶ Operator m_operator; };</code> <br>      . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); }</code> <br>          ,  ,       <code>union</code> .         . <br> <br> <b class="spoiler_title">Token</b> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: return "Unknown token."; } }</code> <br> <br>  ,    ,      ,    .       .    . <br> <br> <i>          .</i>               .            .       . <br>        : <br> <br> <code class="cpp"> if(expr[0] &gt;= '0' &amp;&amp; expr[0] &lt;= '9') { return{ (double) expr[0] - '0' }; } return{ static_cast&lt;Operator&gt;(expr[0]) };</code> <br>      ,   . <br> <br> ‚Ä¶ <s>          .</s> <i>              .</i> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); }</code> <br> ,     <code>C</code>   ,  <code>isdigit</code> , ,       <code>atof</code> ,    ,      <code>wchar_t</code> .  (expression ‚Üí function).         . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { const wchar_t *current = expr.c_str(); if(!*current) return{}; if(iswdigit(*current)) return{ _wtof(current) }; return{ static_cast&lt;Operator&gt;(*current) }; }</code> <br>         .      . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>   ,        .  ,     .     .   <code>result</code> ,     . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); if(!*current) return result; if(iswdigit(*current)) { result.push_back(_wtof(current)); } else { result.push_back(static_cast&lt;Operator&gt;(*current)); } return result; }</code> <br>      :   (if ‚Üí while).     ,        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } } return result; }</code> <br>  <code>wcstod</code>    ,   <code>_wtof</code> ,           .           ,              .  ,    . <br> <br> <s>           .</s>       . <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>  (unconditional ‚Üí if)    ,    . <br> <br> <code class="cpp"> while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else if(*current == static_cast&lt;wchar_t&gt;(Operator::Plus)) { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } else { ++current; } }</code> <br>       .          .       <code>Detail</code>      .   <code>Tokenize</code>       . <br> <br> <code class="cpp">inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); }</code> <br> <b class="spoiler_title"> Detail::Tokenizer</b> <code class="cpp">namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { return *m_current == static_cast&lt;wchar_t&gt;(Operator::Plus); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail</code> <br> <br>  ,      .      ,  , .       . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); }</code> <br>      <code>Operator</code> ,    . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', };</code> <br>   .         <code>IsOperator</code>  <code>Tokenizer</code> . <br> <br> <code class="cpp"> bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); }</code> <br>         .        . <br> <br> <b class="spoiler_title">Interpreter.h</b> <code class="cpp">#pragma once; #include &lt;vector&gt; #include &lt;wchar.h&gt; #include &lt;algorithm&gt; namespace Interpreter { enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', }; inline std::wstring ToString(const Operator &amp;op) { return{ static_cast&lt;wchar_t&gt;(op) }; } enum class TokenType { Operator, Number }; inline std::wstring ToString(const TokenType &amp;type) { switch(type) { case TokenType::Operator: return L"Operator"; case TokenType::Number: return L"Number"; default: throw std::out_of_range("TokenType"); } } class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } friend inline bool operator==(const Token &amp;left, const Token &amp;right) { if(left.m_type == right.m_type) { switch(left.m_type) { case Interpreter::TokenType::Operator: return left.m_operator == right.m_operator; case Interpreter::TokenType::Number: return left.m_number == right.m_number; default: throw std::out_of_range("TokenType"); } } return false; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: throw std::out_of_range("TokenType"); } } typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); } } // namespace Lexer } // namespace Interpreter</code> <br> <br> <b class="spoiler_title">InterpreterTests.cpp</b> <code class="cpp">#include "stdafx.h" #include "CppUnitTest.h" #include "Interpreter.h" namespace InterpreterTests { using namespace Microsoft::VisualStudio::CppUnitTestFramework; using namespace Interpreter; using namespace std; namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual&lt;T&gt;(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange TEST_CLASS(LexerTests) { public: TEST_METHOD(Should_return_empty_token_list_when_put_empty_expression) { Tokens tokens = Lexer::Tokenize(L""); Assert::IsTrue(tokens.empty()); } TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); } TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); } TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); } TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); } }; TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); } TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); } TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); } }; }</code> <br> <br> <a href="https://github.com/Unril/InterpreterTDD/releases/tag/%25D0%259A%25D0%25BE%25D0%25BD%25D0%25B5%25D1%2586_%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B2%25D0%25BE%25D0%25B9_%25D1%2587%25D0%25B0%25D1%2581%25D1%2582%25D0%25B8">    GitHub</a> .         ,  .      "__". <br> <br>   <a href="http://habrahabr.ru/post/232081/">    </a> .      ,      <a href="http://habrahabr.ru/post/232097/">    </a> .</code> </li> <li> <code><code>std::vector,      Tokens</code> .            . <br> <br> <code class="cpp">#pragma once; #include &lt;vector&gt; namespace Interpreter { struct Token {}; typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { inline Tokens Tokenize(std::string expr) { throw std::exception(); } } // namespace Lexer } // namespace Interpreter</code> <br>   ,  ,   , .   ,    ,    <a href="http://cleancoder.posterous.com/the-transformation-priority-premise">The Transformation Priority Premise (TPP)</a>   .    , ,    ,     ,        .            .     ,     ,      ,           .  ,  ,   (   )    ,  ,  .     ,  ,         .     ,   TPP          . <br> <br>   : <br> <br> ({} ‚Üí nil)     ,   . (nil ‚Üí constant)    . (constant ‚Üí constant+)      (        ,  ). (constant ‚Üí scalar)    ,  . (statement ‚Üí statements)    (break, continue, return  ). (unconditional ‚Üí if)       . (scalar ‚Üí array)  / . (array ‚Üí container)     . (statement ‚Üí recursion)   . (if ‚Üí while)    . (expression ‚Üí function)   . (variable ‚Üí assignment)   . <br>        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::string expr) { return{}; }</code> <br> ,         .     . <br> <br> <s>         </s> .           .           .               .            .       . <br>  ,  <code>std::string</code>  <code>std::wstring</code> .         ,      Unicode.     . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); }</code> <br>  <code>AssertRange</code> -   ,       <code>AreEqual</code> ,   ,  ,    . <br> <br> <b class="spoiler_title">AssertRange</b> <code class="cpp">namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange</code> <br> <br>         <code>Operator</code>    .          <code>wchar_t</code>   ,         ,      . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', }; typedef Operator Token;</code> <br>    ,   ,        <code>Assert</code> ,    <code>ToString</code> ,    . <br> <br> <b class="spoiler_title">std::wstring ToString(const Token &amp;)</b> <code class="cpp">inline std::wstring ToString(const Token &amp;token) { return{ static_cast&lt;wchar_t&gt;(token) }; }</code> <br> <br>    ,   ,        .  ,   (unconditional ‚Üí if). <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { if(expr.empty()) { return{}; } return{ static_cast&lt;Operator&gt;(expr[0]) }; }</code> <br> <s>         </s> . <s>          .</s>           . ‚Ä¶ <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); }</code> <br>     .   ,     ,   - .    , : <br> <br>        ,      <code>Token</code> .       <code>dynamic_cast</code>    ,   .  ,    ,      .      <code>std::function</code>        .        .  Boost.Any,  - .            . <br>   ,   .      -  .  ,      ,      . <br> <br> ‚Ä¶        .        .        .        . <br>             . <br> <br> <code class="cpp">enum class TokenType { Operator, Number }; class Token { public: Token(Operator) {} TokenType Type() const { return TokenType::Operator; } }; ‚Ä¶ TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } };</code> <br>   <code>ToString</code>   <code>TokenType</code>       ,   ,   .     . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); }</code> <br>   .   (constant ‚Üí scalar)   . <br> <br> <code class="cpp">class Token { public: Token(Operator) :m_type(TokenType::Operator) {} Token(double) :m_type(TokenType::Number) {} TokenType Type() const { return m_type; } private: TokenType m_type; };</code> <br> ‚Ä¶ <s>       </s> . <s>       </s> .        .        . <br>    . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); }</code> <br>            . <br> <br> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} operator Operator() const { return m_operator; } ‚Ä¶ Operator m_operator; };</code> <br>      . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); }</code> <br>          ,  ,       <code>union</code> .         . <br> <br> <b class="spoiler_title">Token</b> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: return "Unknown token."; } }</code> <br> <br>  ,    ,      ,    .       .    . <br> <br> <i>          .</i>               .            .       . <br>        : <br> <br> <code class="cpp"> if(expr[0] &gt;= '0' &amp;&amp; expr[0] &lt;= '9') { return{ (double) expr[0] - '0' }; } return{ static_cast&lt;Operator&gt;(expr[0]) };</code> <br>      ,   . <br> <br> ‚Ä¶ <s>          .</s> <i>              .</i> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); }</code> <br> ,     <code>C</code>   ,  <code>isdigit</code> , ,       <code>atof</code> ,    ,      <code>wchar_t</code> .  (expression ‚Üí function).         . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { const wchar_t *current = expr.c_str(); if(!*current) return{}; if(iswdigit(*current)) return{ _wtof(current) }; return{ static_cast&lt;Operator&gt;(*current) }; }</code> <br>         .      . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>   ,        .  ,     .     .   <code>result</code> ,     . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); if(!*current) return result; if(iswdigit(*current)) { result.push_back(_wtof(current)); } else { result.push_back(static_cast&lt;Operator&gt;(*current)); } return result; }</code> <br>      :   (if ‚Üí while).     ,        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } } return result; }</code> <br>  <code>wcstod</code>    ,   <code>_wtof</code> ,           .           ,              .  ,    . <br> <br> <s>           .</s>       . <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>  (unconditional ‚Üí if)    ,    . <br> <br> <code class="cpp"> while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else if(*current == static_cast&lt;wchar_t&gt;(Operator::Plus)) { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } else { ++current; } }</code> <br>       .          .       <code>Detail</code>      .   <code>Tokenize</code>       . <br> <br> <code class="cpp">inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); }</code> <br> <b class="spoiler_title"> Detail::Tokenizer</b> <code class="cpp">namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { return *m_current == static_cast&lt;wchar_t&gt;(Operator::Plus); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail</code> <br> <br>  ,      .      ,  , .       . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); }</code> <br>      <code>Operator</code> ,    . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', };</code> <br>   .         <code>IsOperator</code>  <code>Tokenizer</code> . <br> <br> <code class="cpp"> bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); }</code> <br>         .        . <br> <br> <b class="spoiler_title">Interpreter.h</b> <code class="cpp">#pragma once; #include &lt;vector&gt; #include &lt;wchar.h&gt; #include &lt;algorithm&gt; namespace Interpreter { enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', }; inline std::wstring ToString(const Operator &amp;op) { return{ static_cast&lt;wchar_t&gt;(op) }; } enum class TokenType { Operator, Number }; inline std::wstring ToString(const TokenType &amp;type) { switch(type) { case TokenType::Operator: return L"Operator"; case TokenType::Number: return L"Number"; default: throw std::out_of_range("TokenType"); } } class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } friend inline bool operator==(const Token &amp;left, const Token &amp;right) { if(left.m_type == right.m_type) { switch(left.m_type) { case Interpreter::TokenType::Operator: return left.m_operator == right.m_operator; case Interpreter::TokenType::Number: return left.m_number == right.m_number; default: throw std::out_of_range("TokenType"); } } return false; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: throw std::out_of_range("TokenType"); } } typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); } } // namespace Lexer } // namespace Interpreter</code> <br> <br> <b class="spoiler_title">InterpreterTests.cpp</b> <code class="cpp">#include "stdafx.h" #include "CppUnitTest.h" #include "Interpreter.h" namespace InterpreterTests { using namespace Microsoft::VisualStudio::CppUnitTestFramework; using namespace Interpreter; using namespace std; namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual&lt;T&gt;(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange TEST_CLASS(LexerTests) { public: TEST_METHOD(Should_return_empty_token_list_when_put_empty_expression) { Tokens tokens = Lexer::Tokenize(L""); Assert::IsTrue(tokens.empty()); } TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); } TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); } TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); } TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); } }; TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); } TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); } TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); } }; }</code> <br> <br> <a href="https://github.com/Unril/InterpreterTDD/releases/tag/%25D0%259A%25D0%25BE%25D0%25BD%25D0%25B5%25D1%2586_%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B2%25D0%25BE%25D0%25B9_%25D1%2587%25D0%25B0%25D1%2581%25D1%2582%25D0%25B8">    GitHub</a> .         ,  .      "__". <br> <br>   <a href="http://habrahabr.ru/post/232081/">    </a> .      ,      <a href="http://habrahabr.ru/post/232097/">    </a> .</code> </li> <li> <code><code>std::vector,      Tokens</code> .            . <br> <br> <code class="cpp">#pragma once; #include &lt;vector&gt; namespace Interpreter { struct Token {}; typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { inline Tokens Tokenize(std::string expr) { throw std::exception(); } } // namespace Lexer } // namespace Interpreter</code> <br>   ,  ,   , .   ,    ,    <a href="http://cleancoder.posterous.com/the-transformation-priority-premise">The Transformation Priority Premise (TPP)</a>   .    , ,    ,     ,        .            .     ,     ,      ,           .  ,  ,   (   )    ,  ,  .     ,  ,         .     ,   TPP          . <br> <br>   : <br> <br> ({} ‚Üí nil)     ,   . (nil ‚Üí constant)    . (constant ‚Üí constant+)      (        ,  ). (constant ‚Üí scalar)    ,  . (statement ‚Üí statements)    (break, continue, return  ). (unconditional ‚Üí if)       . (scalar ‚Üí array)  / . (array ‚Üí container)     . (statement ‚Üí recursion)   . (if ‚Üí while)    . (expression ‚Üí function)   . (variable ‚Üí assignment)   . <br>        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::string expr) { return{}; }</code> <br> ,         .     . <br> <br> <s>         </s> .           .           .               .            .       . <br>  ,  <code>std::string</code>  <code>std::wstring</code> .         ,      Unicode.     . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); }</code> <br>  <code>AssertRange</code> -   ,       <code>AreEqual</code> ,   ,  ,    . <br> <br> <b class="spoiler_title">AssertRange</b> <code class="cpp">namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange</code> <br> <br>         <code>Operator</code>    .          <code>wchar_t</code>   ,         ,      . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', }; typedef Operator Token;</code> <br>    ,   ,        <code>Assert</code> ,    <code>ToString</code> ,    . <br> <br> <b class="spoiler_title">std::wstring ToString(const Token &amp;)</b> <code class="cpp">inline std::wstring ToString(const Token &amp;token) { return{ static_cast&lt;wchar_t&gt;(token) }; }</code> <br> <br>    ,   ,        .  ,   (unconditional ‚Üí if). <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { if(expr.empty()) { return{}; } return{ static_cast&lt;Operator&gt;(expr[0]) }; }</code> <br> <s>         </s> . <s>          .</s>           . ‚Ä¶ <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); }</code> <br>     .   ,     ,   - .    , : <br> <br>        ,      <code>Token</code> .       <code>dynamic_cast</code>    ,   .  ,    ,      .      <code>std::function</code>        .        .  Boost.Any,  - .            . <br>   ,   .      -  .  ,      ,      . <br> <br> ‚Ä¶        .        .        .        . <br>             . <br> <br> <code class="cpp">enum class TokenType { Operator, Number }; class Token { public: Token(Operator) {} TokenType Type() const { return TokenType::Operator; } }; ‚Ä¶ TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } };</code> <br>   <code>ToString</code>   <code>TokenType</code>       ,   ,   .     . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); }</code> <br>   .   (constant ‚Üí scalar)   . <br> <br> <code class="cpp">class Token { public: Token(Operator) :m_type(TokenType::Operator) {} Token(double) :m_type(TokenType::Number) {} TokenType Type() const { return m_type; } private: TokenType m_type; };</code> <br> ‚Ä¶ <s>       </s> . <s>       </s> .        .        . <br>    . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); }</code> <br>            . <br> <br> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} operator Operator() const { return m_operator; } ‚Ä¶ Operator m_operator; };</code> <br>      . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); }</code> <br>          ,  ,       <code>union</code> .         . <br> <br> <b class="spoiler_title">Token</b> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: return "Unknown token."; } }</code> <br> <br>  ,    ,      ,    .       .    . <br> <br> <i>          .</i>               .            .       . <br>        : <br> <br> <code class="cpp"> if(expr[0] &gt;= '0' &amp;&amp; expr[0] &lt;= '9') { return{ (double) expr[0] - '0' }; } return{ static_cast&lt;Operator&gt;(expr[0]) };</code> <br>      ,   . <br> <br> ‚Ä¶ <s>          .</s> <i>              .</i> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); }</code> <br> ,     <code>C</code>   ,  <code>isdigit</code> , ,       <code>atof</code> ,    ,      <code>wchar_t</code> .  (expression ‚Üí function).         . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { const wchar_t *current = expr.c_str(); if(!*current) return{}; if(iswdigit(*current)) return{ _wtof(current) }; return{ static_cast&lt;Operator&gt;(*current) }; }</code> <br>         .      . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>   ,        .  ,     .     .   <code>result</code> ,     . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); if(!*current) return result; if(iswdigit(*current)) { result.push_back(_wtof(current)); } else { result.push_back(static_cast&lt;Operator&gt;(*current)); } return result; }</code> <br>      :   (if ‚Üí while).     ,        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } } return result; }</code> <br>  <code>wcstod</code>    ,   <code>_wtof</code> ,           .           ,              .  ,    . <br> <br> <s>           .</s>       . <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>  (unconditional ‚Üí if)    ,    . <br> <br> <code class="cpp"> while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else if(*current == static_cast&lt;wchar_t&gt;(Operator::Plus)) { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } else { ++current; } }</code> <br>       .          .       <code>Detail</code>      .   <code>Tokenize</code>       . <br> <br> <code class="cpp">inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); }</code> <br> <b class="spoiler_title"> Detail::Tokenizer</b> <code class="cpp">namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { return *m_current == static_cast&lt;wchar_t&gt;(Operator::Plus); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail</code> <br> <br>  ,      .      ,  , .       . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); }</code> <br>      <code>Operator</code> ,    . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', };</code> <br>   .         <code>IsOperator</code>  <code>Tokenizer</code> . <br> <br> <code class="cpp"> bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); }</code> <br>         .        . <br> <br> <b class="spoiler_title">Interpreter.h</b> <code class="cpp">#pragma once; #include &lt;vector&gt; #include &lt;wchar.h&gt; #include &lt;algorithm&gt; namespace Interpreter { enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', }; inline std::wstring ToString(const Operator &amp;op) { return{ static_cast&lt;wchar_t&gt;(op) }; } enum class TokenType { Operator, Number }; inline std::wstring ToString(const TokenType &amp;type) { switch(type) { case TokenType::Operator: return L"Operator"; case TokenType::Number: return L"Number"; default: throw std::out_of_range("TokenType"); } } class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } friend inline bool operator==(const Token &amp;left, const Token &amp;right) { if(left.m_type == right.m_type) { switch(left.m_type) { case Interpreter::TokenType::Operator: return left.m_operator == right.m_operator; case Interpreter::TokenType::Number: return left.m_number == right.m_number; default: throw std::out_of_range("TokenType"); } } return false; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: throw std::out_of_range("TokenType"); } } typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); } } // namespace Lexer } // namespace Interpreter</code> <br> <br> <b class="spoiler_title">InterpreterTests.cpp</b> <code class="cpp">#include "stdafx.h" #include "CppUnitTest.h" #include "Interpreter.h" namespace InterpreterTests { using namespace Microsoft::VisualStudio::CppUnitTestFramework; using namespace Interpreter; using namespace std; namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual&lt;T&gt;(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange TEST_CLASS(LexerTests) { public: TEST_METHOD(Should_return_empty_token_list_when_put_empty_expression) { Tokens tokens = Lexer::Tokenize(L""); Assert::IsTrue(tokens.empty()); } TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); } TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); } TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); } TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); } }; TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); } TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); } TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); } }; }</code> <br> <br> <a href="https://github.com/Unril/InterpreterTDD/releases/tag/%25D0%259A%25D0%25BE%25D0%25BD%25D0%25B5%25D1%2586_%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B2%25D0%25BE%25D0%25B9_%25D1%2587%25D0%25B0%25D1%2581%25D1%2582%25D0%25B8">    GitHub</a> .         ,  .      "__". <br> <br>   <a href="http://habrahabr.ru/post/232081/">    </a> .      ,      <a href="http://habrahabr.ru/post/232097/">    </a> .</code> </li> <li> <code><code>std::vector,      Tokens</code> .            . <br> <br> <code class="cpp">#pragma once; #include &lt;vector&gt; namespace Interpreter { struct Token {}; typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { inline Tokens Tokenize(std::string expr) { throw std::exception(); } } // namespace Lexer } // namespace Interpreter</code> <br>   ,  ,   , .   ,    ,    <a href="http://cleancoder.posterous.com/the-transformation-priority-premise">The Transformation Priority Premise (TPP)</a>   .    , ,    ,     ,        .            .     ,     ,      ,           .  ,  ,   (   )    ,  ,  .     ,  ,         .     ,   TPP          . <br> <br>   : <br> <br> ({} ‚Üí nil)     ,   . (nil ‚Üí constant)    . (constant ‚Üí constant+)      (        ,  ). (constant ‚Üí scalar)    ,  . (statement ‚Üí statements)    (break, continue, return  ). (unconditional ‚Üí if)       . (scalar ‚Üí array)  / . (array ‚Üí container)     . (statement ‚Üí recursion)   . (if ‚Üí while)    . (expression ‚Üí function)   . (variable ‚Üí assignment)   . <br>        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::string expr) { return{}; }</code> <br> ,         .     . <br> <br> <s>         </s> .           .           .               .            .       . <br>  ,  <code>std::string</code>  <code>std::wstring</code> .         ,      Unicode.     . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); }</code> <br>  <code>AssertRange</code> -   ,       <code>AreEqual</code> ,   ,  ,    . <br> <br> <b class="spoiler_title">AssertRange</b> <code class="cpp">namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange</code> <br> <br>         <code>Operator</code>    .          <code>wchar_t</code>   ,         ,      . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', }; typedef Operator Token;</code> <br>    ,   ,        <code>Assert</code> ,    <code>ToString</code> ,    . <br> <br> <b class="spoiler_title">std::wstring ToString(const Token &amp;)</b> <code class="cpp">inline std::wstring ToString(const Token &amp;token) { return{ static_cast&lt;wchar_t&gt;(token) }; }</code> <br> <br>    ,   ,        .  ,   (unconditional ‚Üí if). <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { if(expr.empty()) { return{}; } return{ static_cast&lt;Operator&gt;(expr[0]) }; }</code> <br> <s>         </s> . <s>          .</s>           . ‚Ä¶ <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); }</code> <br>     .   ,     ,   - .    , : <br> <br>        ,      <code>Token</code> .       <code>dynamic_cast</code>    ,   .  ,    ,      .      <code>std::function</code>        .        .  Boost.Any,  - .            . <br>   ,   .      -  .  ,      ,      . <br> <br> ‚Ä¶        .        .        .        . <br>             . <br> <br> <code class="cpp">enum class TokenType { Operator, Number }; class Token { public: Token(Operator) {} TokenType Type() const { return TokenType::Operator; } }; ‚Ä¶ TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } };</code> <br>   <code>ToString</code>   <code>TokenType</code>       ,   ,   .     . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); }</code> <br>   .   (constant ‚Üí scalar)   . <br> <br> <code class="cpp">class Token { public: Token(Operator) :m_type(TokenType::Operator) {} Token(double) :m_type(TokenType::Number) {} TokenType Type() const { return m_type; } private: TokenType m_type; };</code> <br> ‚Ä¶ <s>       </s> . <s>       </s> .        .        . <br>    . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); }</code> <br>            . <br> <br> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} operator Operator() const { return m_operator; } ‚Ä¶ Operator m_operator; };</code> <br>      . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); }</code> <br>          ,  ,       <code>union</code> .         . <br> <br> <b class="spoiler_title">Token</b> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: return "Unknown token."; } }</code> <br> <br>  ,    ,      ,    .       .    . <br> <br> <i>          .</i>               .            .       . <br>        : <br> <br> <code class="cpp"> if(expr[0] &gt;= '0' &amp;&amp; expr[0] &lt;= '9') { return{ (double) expr[0] - '0' }; } return{ static_cast&lt;Operator&gt;(expr[0]) };</code> <br>      ,   . <br> <br> ‚Ä¶ <s>          .</s> <i>              .</i> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); }</code> <br> ,     <code>C</code>   ,  <code>isdigit</code> , ,       <code>atof</code> ,    ,      <code>wchar_t</code> .  (expression ‚Üí function).         . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { const wchar_t *current = expr.c_str(); if(!*current) return{}; if(iswdigit(*current)) return{ _wtof(current) }; return{ static_cast&lt;Operator&gt;(*current) }; }</code> <br>         .      . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>   ,        .  ,     .     .   <code>result</code> ,     . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); if(!*current) return result; if(iswdigit(*current)) { result.push_back(_wtof(current)); } else { result.push_back(static_cast&lt;Operator&gt;(*current)); } return result; }</code> <br>      :   (if ‚Üí while).     ,        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } } return result; }</code> <br>  <code>wcstod</code>    ,   <code>_wtof</code> ,           .           ,              .  ,    . <br> <br> <s>           .</s>       . <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>  (unconditional ‚Üí if)    ,    . <br> <br> <code class="cpp"> while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else if(*current == static_cast&lt;wchar_t&gt;(Operator::Plus)) { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } else { ++current; } }</code> <br>       .          .       <code>Detail</code>      .   <code>Tokenize</code>       . <br> <br> <code class="cpp">inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); }</code> <br> <b class="spoiler_title"> Detail::Tokenizer</b> <code class="cpp">namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { return *m_current == static_cast&lt;wchar_t&gt;(Operator::Plus); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail</code> <br> <br>  ,      .      ,  , .       . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); }</code> <br>      <code>Operator</code> ,    . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', };</code> <br>   .         <code>IsOperator</code>  <code>Tokenizer</code> . <br> <br> <code class="cpp"> bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); }</code> <br>         .        . <br> <br> <b class="spoiler_title">Interpreter.h</b> <code class="cpp">#pragma once; #include &lt;vector&gt; #include &lt;wchar.h&gt; #include &lt;algorithm&gt; namespace Interpreter { enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', }; inline std::wstring ToString(const Operator &amp;op) { return{ static_cast&lt;wchar_t&gt;(op) }; } enum class TokenType { Operator, Number }; inline std::wstring ToString(const TokenType &amp;type) { switch(type) { case TokenType::Operator: return L"Operator"; case TokenType::Number: return L"Number"; default: throw std::out_of_range("TokenType"); } } class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } friend inline bool operator==(const Token &amp;left, const Token &amp;right) { if(left.m_type == right.m_type) { switch(left.m_type) { case Interpreter::TokenType::Operator: return left.m_operator == right.m_operator; case Interpreter::TokenType::Number: return left.m_number == right.m_number; default: throw std::out_of_range("TokenType"); } } return false; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: throw std::out_of_range("TokenType"); } } typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); } } // namespace Lexer } // namespace Interpreter</code> <br> <br> <b class="spoiler_title">InterpreterTests.cpp</b> <code class="cpp">#include "stdafx.h" #include "CppUnitTest.h" #include "Interpreter.h" namespace InterpreterTests { using namespace Microsoft::VisualStudio::CppUnitTestFramework; using namespace Interpreter; using namespace std; namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual&lt;T&gt;(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange TEST_CLASS(LexerTests) { public: TEST_METHOD(Should_return_empty_token_list_when_put_empty_expression) { Tokens tokens = Lexer::Tokenize(L""); Assert::IsTrue(tokens.empty()); } TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); } TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); } TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); } TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); } }; TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); } TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); } TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); } }; }</code> <br> <br> <a href="https://github.com/Unril/InterpreterTDD/releases/tag/%25D0%259A%25D0%25BE%25D0%25BD%25D0%25B5%25D1%2586_%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B2%25D0%25BE%25D0%25B9_%25D1%2587%25D0%25B0%25D1%2581%25D1%2582%25D0%25B8">    GitHub</a> .         ,  .      "__". <br> <br>   <a href="http://habrahabr.ru/post/232081/">    </a> .      ,      <a href="http://habrahabr.ru/post/232097/">    </a> .</code> </li> </ol> <code><code>std::vector,      Tokens</code> .            . <br> <br> <code class="cpp">#pragma once; #include &lt;vector&gt; namespace Interpreter { struct Token {}; typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { inline Tokens Tokenize(std::string expr) { throw std::exception(); } } // namespace Lexer } // namespace Interpreter</code> <br>   ,  ,   , .   ,    ,    <a href="http://cleancoder.posterous.com/the-transformation-priority-premise">The Transformation Priority Premise (TPP)</a>   .    , ,    ,     ,        .            .     ,     ,      ,           .  ,  ,   (   )    ,  ,  .     ,  ,         .     ,   TPP          . <br> <br>   : <br> <br> ({} ‚Üí nil)     ,   . (nil ‚Üí constant)    . (constant ‚Üí constant+)      (        ,  ). (constant ‚Üí scalar)    ,  . (statement ‚Üí statements)    (break, continue, return  ). (unconditional ‚Üí if)       . (scalar ‚Üí array)  / . (array ‚Üí container)     . (statement ‚Üí recursion)   . (if ‚Üí while)    . (expression ‚Üí function)   . (variable ‚Üí assignment)   . <br>        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::string expr) { return{}; }</code> <br> ,         .     . <br> <br> <s>         </s> .           .           .               .            .       . <br>  ,  <code>std::string</code>  <code>std::wstring</code> .         ,      Unicode.     . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); }</code> <br>  <code>AssertRange</code> -   ,       <code>AreEqual</code> ,   ,  ,    . <br> <br> <b class="spoiler_title">AssertRange</b> <code class="cpp">namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange</code> <br> <br>         <code>Operator</code>    .          <code>wchar_t</code>   ,         ,      . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', }; typedef Operator Token;</code> <br>    ,   ,        <code>Assert</code> ,    <code>ToString</code> ,    . <br> <br> <b class="spoiler_title">std::wstring ToString(const Token &amp;)</b> <code class="cpp">inline std::wstring ToString(const Token &amp;token) { return{ static_cast&lt;wchar_t&gt;(token) }; }</code> <br> <br>    ,   ,        .  ,   (unconditional ‚Üí if). <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { if(expr.empty()) { return{}; } return{ static_cast&lt;Operator&gt;(expr[0]) }; }</code> <br> <s>         </s> . <s>          .</s>           . ‚Ä¶ <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); }</code> <br>     .   ,     ,   - .    , : <br> <br>        ,      <code>Token</code> .       <code>dynamic_cast</code>    ,   .  ,    ,      .      <code>std::function</code>        .        .  Boost.Any,  - .            . <br>   ,   .      -  .  ,      ,      . <br> <br> ‚Ä¶        .        .        .        . <br>             . <br> <br> <code class="cpp">enum class TokenType { Operator, Number }; class Token { public: Token(Operator) {} TokenType Type() const { return TokenType::Operator; } }; ‚Ä¶ TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } };</code> <br>   <code>ToString</code>   <code>TokenType</code>       ,   ,   .     . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); }</code> <br>   .   (constant ‚Üí scalar)   . <br> <br> <code class="cpp">class Token { public: Token(Operator) :m_type(TokenType::Operator) {} Token(double) :m_type(TokenType::Number) {} TokenType Type() const { return m_type; } private: TokenType m_type; };</code> <br> ‚Ä¶ <s>       </s> . <s>       </s> .        .        . <br>    . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); }</code> <br>            . <br> <br> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} operator Operator() const { return m_operator; } ‚Ä¶ Operator m_operator; };</code> <br>      . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); }</code> <br>          ,  ,       <code>union</code> .         . <br> <br> <b class="spoiler_title">Token</b> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: return "Unknown token."; } }</code> <br> <br>  ,    ,      ,    .       .    . <br> <br> <i>          .</i>               .            .       . <br>        : <br> <br> <code class="cpp"> if(expr[0] &gt;= '0' &amp;&amp; expr[0] &lt;= '9') { return{ (double) expr[0] - '0' }; } return{ static_cast&lt;Operator&gt;(expr[0]) };</code> <br>      ,   . <br> <br> ‚Ä¶ <s>          .</s> <i>              .</i> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); }</code> <br> ,     <code>C</code>   ,  <code>isdigit</code> , ,       <code>atof</code> ,    ,      <code>wchar_t</code> .  (expression ‚Üí function).         . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { const wchar_t *current = expr.c_str(); if(!*current) return{}; if(iswdigit(*current)) return{ _wtof(current) }; return{ static_cast&lt;Operator&gt;(*current) }; }</code> <br>         .      . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>   ,        .  ,     .     .   <code>result</code> ,     . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); if(!*current) return result; if(iswdigit(*current)) { result.push_back(_wtof(current)); } else { result.push_back(static_cast&lt;Operator&gt;(*current)); } return result; }</code> <br>      :   (if ‚Üí while).     ,        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } } return result; }</code> <br>  <code>wcstod</code>    ,   <code>_wtof</code> ,           .           ,              .  ,    . <br> <br> <s>           .</s>       . <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>  (unconditional ‚Üí if)    ,    . <br> <br> <code class="cpp"> while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else if(*current == static_cast&lt;wchar_t&gt;(Operator::Plus)) { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } else { ++current; } }</code> <br>       .          .       <code>Detail</code>      .   <code>Tokenize</code>       . <br> <br> <code class="cpp">inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); }</code> <br> <b class="spoiler_title"> Detail::Tokenizer</b> <code class="cpp">namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { return *m_current == static_cast&lt;wchar_t&gt;(Operator::Plus); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail</code> <br> <br>  ,      .      ,  , .       . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); }</code> <br>      <code>Operator</code> ,    . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', };</code> <br>   .         <code>IsOperator</code>  <code>Tokenizer</code> . <br> <br> <code class="cpp"> bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); }</code> <br>         .        . <br> <br> <b class="spoiler_title">Interpreter.h</b> <code class="cpp">#pragma once; #include &lt;vector&gt; #include &lt;wchar.h&gt; #include &lt;algorithm&gt; namespace Interpreter { enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', }; inline std::wstring ToString(const Operator &amp;op) { return{ static_cast&lt;wchar_t&gt;(op) }; } enum class TokenType { Operator, Number }; inline std::wstring ToString(const TokenType &amp;type) { switch(type) { case TokenType::Operator: return L"Operator"; case TokenType::Number: return L"Number"; default: throw std::out_of_range("TokenType"); } } class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } friend inline bool operator==(const Token &amp;left, const Token &amp;right) { if(left.m_type == right.m_type) { switch(left.m_type) { case Interpreter::TokenType::Operator: return left.m_operator == right.m_operator; case Interpreter::TokenType::Number: return left.m_number == right.m_number; default: throw std::out_of_range("TokenType"); } } return false; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: throw std::out_of_range("TokenType"); } } typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); } } // namespace Lexer } // namespace Interpreter</code> <br> <br> <b class="spoiler_title">InterpreterTests.cpp</b> <code class="cpp">#include "stdafx.h" #include "CppUnitTest.h" #include "Interpreter.h" namespace InterpreterTests { using namespace Microsoft::VisualStudio::CppUnitTestFramework; using namespace Interpreter; using namespace std; namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual&lt;T&gt;(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange TEST_CLASS(LexerTests) { public: TEST_METHOD(Should_return_empty_token_list_when_put_empty_expression) { Tokens tokens = Lexer::Tokenize(L""); Assert::IsTrue(tokens.empty()); } TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); } TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); } TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); } TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); } }; TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); } TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); } TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); } }; }</code> <br> <br> <a href="https://github.com/Unril/InterpreterTDD/releases/tag/%25D0%259A%25D0%25BE%25D0%25BD%25D0%25B5%25D1%2586_%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B2%25D0%25BE%25D0%25B9_%25D1%2587%25D0%25B0%25D1%2581%25D1%2582%25D0%25B8">    GitHub</a> .         ,  .      "__". <br> <br>   <a href="http://habrahabr.ru/post/232081/">    </a> .      ,      <a href="http://habrahabr.ru/post/232097/">    </a> .</code> <pre> <code class="hljs lua"><code class="cpp"><code>std::vector,      Tokens</code> .            . <br> <br> <code class="cpp">#pragma once; #include &lt;vector&gt; namespace Interpreter { struct Token {}; typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { inline Tokens Tokenize(std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> expr) { throw std::exception(); } } // namespace Lexer } // namespace Interpreter</code> <br>   ,  ,   , .   ,    ,    <a href="http://cleancoder.posterous.com/the-transformation-priority-premise">The Transformation Priority Premise (TPP)</a>   .    , ,    ,     ,        .            .     ,     ,      ,           .  ,  ,   (   )    ,  ,  .     ,  ,         .     ,   TPP          . <br> <br>   : <br> <br> ({} ‚Üí <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)     ,   . (<span class="hljs-literal"><span class="hljs-literal">nil</span></span> ‚Üí constant)    . (constant ‚Üí constant+)      (        ,  ). (constant ‚Üí scalar)    ,  . (statement ‚Üí statements)    (<span class="hljs-keyword"><span class="hljs-keyword">break</span></span>, continue, <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>  ). (unconditional ‚Üí <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>)       . (scalar ‚Üí array)  / . (array ‚Üí container)     . (statement ‚Üí recursion)   . (<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ‚Üí <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>)    . (expression ‚Üí <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">)</span></span>   . (variable ‚Üí assignment)   . <br>        . <br> <br> inline Tokens Tokenize(std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> expr) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{}; } <br> ,         .     . <br> <br> <s>         </s> .           .           .               .            .       . <br>  ,  <code>std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span></code>  <code>std::wstring</code> .         ,      Unicode.     . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"+"</span></span>); AssertRange::AreEqual({ Operator::Plus }, tokens); }</code> <br>  <code>AssertRange</code> -   ,       <code>AreEqual</code> ,   ,  ,    . <br> <br> <b class="spoiler_title">AssertRange</b> <code class="cpp">namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(expect)), distance(actualIter, <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(actual)), L<span class="hljs-string"><span class="hljs-string">"Size differs."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(; expectIter != <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(expect) &amp;&amp; actualIter != <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(actual); ++expectIter, ++actualIter) { auto message = L<span class="hljs-string"><span class="hljs-string">"Mismatch in position "</span></span> + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange</code> <br> <br>         <code>Operator</code>    .          <code>wchar_t</code>   ,         ,      . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L<span class="hljs-string"><span class="hljs-string">'+'</span></span>, }; typedef Operator Token;</code> <br>    ,   ,        <code>Assert</code> ,    <code>ToString</code> ,    . <br> <br> <b class="spoiler_title">std::wstring ToString(const Token &amp;)</b> <code class="cpp">inline std::wstring ToString(const Token &amp;token) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ static_cast&lt;wchar_t&gt;(token) }; }</code> <br> <br>    ,   ,        .  ,   (unconditional ‚Üí <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>). <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(expr.empty()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{}; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ static_cast&lt;Operator&gt;(expr[<span class="hljs-number"><span class="hljs-number">0</span></span>]) }; }</code> <br> <s>         </s> . <s>          .</s>           . ‚Ä¶ <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"1"</span></span>); AssertRange::AreEqual({ <span class="hljs-number"><span class="hljs-number">1.0</span></span> }, tokens); }</code> <br>     .   ,     ,   - .    , : <br> <br>        ,      <code>Token</code> .       <code>dynamic_cast</code>    ,   .  ,    ,      .      <code>std::<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span></span></code><span class="hljs-function"><span class="hljs-function">        .        .  </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Boost.Any</span></span></span><span class="hljs-function">,  - .            . </span></span><br><span class="hljs-function"><span class="hljs-function">   ,   .      -  .  ,      ,      . </span></span><br><span class="hljs-function"><span class="hljs-function"> </span></span><br><span class="hljs-function"><span class="hljs-function"> ‚Ä¶        .        .        .        . </span></span><br><span class="hljs-function"><span class="hljs-function">             . </span></span><br><span class="hljs-function"><span class="hljs-function"> </span></span><br><span class="hljs-function"><span class="hljs-function"> </span></span><code class="cpp"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">enum</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">class</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TokenType</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Operator</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Number</span></span></span><span class="hljs-function"> }; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">class</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Token</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">public</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Token</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Operator)</span></span></span></span> {} TokenType Type() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TokenType::Operator; } }; ‚Ä¶ TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } };</code> <br>   <code>ToString</code>   <code>TokenType</code>       ,   ,   .     . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_type_for_number_token) { Token numToken(<span class="hljs-number"><span class="hljs-number">1.2</span></span>); Assert::AreEqual(TokenType::Number, numToken.Type()); }</code> <br>   .   (constant ‚Üí scalar)   . <br> <br> <code class="cpp">class Token { public: Token(Operator) :m_type(TokenType::Operator) {} Token(double) :m_type(TokenType::Number) {} TokenType Type() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_type; } private: TokenType m_type; };</code> <br> ‚Ä¶ <s>       </s> . <s>       </s> .        .        . <br>    . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); }</code> <br>            . <br> <br> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} operator Operator() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_operator; } ‚Ä¶ Operator m_operator; };</code> <br>      . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_number_value_from_number_token) { Token token(<span class="hljs-number"><span class="hljs-number">1.23</span></span>); Assert::AreEqual&lt;double&gt;(<span class="hljs-number"><span class="hljs-number">1.23</span></span>, token); }</code> <br>          ,  ,       <code>union</code> .         . <br> <br> <b class="spoiler_title">Token</b> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_type; } operator Operator() const { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(m_type != TokenType::Operator) throw std::logic_error(<span class="hljs-string"><span class="hljs-string">"Should be operator token."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_operator; } operator double() const { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(m_type != TokenType::Number) throw std::logic_error(<span class="hljs-string"><span class="hljs-string">"Should be number token."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_number; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ToString(static_cast&lt;Operator&gt;(token)); default: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Unknown token."</span></span>; } }</code> <br> <br>  ,    ,      ,    .       .    . <br> <br> <i>          .</i>               .            .       . <br>        : <br> <br> <code class="cpp"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(expr[<span class="hljs-number"><span class="hljs-number">0</span></span>] &gt;= <span class="hljs-string"><span class="hljs-string">'0'</span></span> &amp;&amp; expr[<span class="hljs-number"><span class="hljs-number">0</span></span>] &lt;= <span class="hljs-string"><span class="hljs-string">'9'</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ (double) expr[<span class="hljs-number"><span class="hljs-number">0</span></span>] - <span class="hljs-string"><span class="hljs-string">'0'</span></span> }; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ static_cast&lt;Operator&gt;(expr[<span class="hljs-number"><span class="hljs-number">0</span></span>]) };</code> <br>      ,   . <br> <br> ‚Ä¶ <s>          .</s> <i>              .</i> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"12.34"</span></span>); AssertRange::AreEqual({ <span class="hljs-number"><span class="hljs-number">12.34</span></span> }, tokens); }</code> <br> ,     <code>C</code>   ,  <code>isdigit</code> , ,       <code>atof</code> ,    ,      <code>wchar_t</code> .  (expression ‚Üí <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">)</span></span>.         . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { const wchar_t *current = expr.c_str(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!*current) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{}; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(iswdigit(*current)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ _wtof(current) }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ static_cast&lt;Operator&gt;(*current) }; }</code> <br>         .      . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"+12.34"</span></span>); AssertRange::AreEqual({ Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">12.34</span></span>) }, tokens); }</code> <br>   ,        .  ,     .     .   <code>result</code> ,     . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!*current) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(iswdigit(*current)) { result.push_back(_wtof(current)); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { result.push_back(static_cast&lt;Operator&gt;(*current)); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> <br>      :   (<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ‚Üí <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>).     ,        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(*current) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(iswdigit(*current)) { wchar_t *<span class="hljs-keyword"><span class="hljs-keyword">end</span></span> = nullptr; result.push_back(wcstod(current, &amp;<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>)); current = <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> <br>  <code>wcstod</code>    ,   <code>_wtof</code> ,           .           ,              .  ,    . <br> <br> <s>           .</s>       . <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">" 1 + 12.34 "</span></span>); AssertRange::AreEqual({ Token(<span class="hljs-number"><span class="hljs-number">1.0</span></span>), Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">12.34</span></span>) }, tokens); }</code> <br>  (unconditional ‚Üí <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>)    ,    . <br> <br> <code class="cpp"> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(*current) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(iswdigit(*current)) { wchar_t *<span class="hljs-keyword"><span class="hljs-keyword">end</span></span> = nullptr; result.push_back(wcstod(current, &amp;<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>)); current = <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(*current == static_cast&lt;wchar_t&gt;(Operator::Plus)) { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { ++current; } }</code> <br>       .          .       <code>Detail</code>      .   <code>Tokenize</code>       . <br> <br> <code class="cpp">inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tokenizer.Result(); }</code> <br> <b class="spoiler_title"> Detail::Tokenizer</b> <code class="cpp">namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!EndOfExperssion()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(IsNumber()) { ScanNumber(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(IsOperator()) { ScanOperator(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { MoveNext(); } } } const Tokens &amp;Result() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_result; } private: bool EndOfExperssion() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_current == L<span class="hljs-string"><span class="hljs-string">'\0'</span></span>; } bool IsNumber() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> iswdigit(*m_current) != <span class="hljs-number"><span class="hljs-number">0</span></span>; } void ScanNumber() { wchar_t *<span class="hljs-keyword"><span class="hljs-keyword">end</span></span> = nullptr; m_result.push_back(wcstod(m_current, &amp;<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>)); m_current = <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; } bool IsOperator() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_current == static_cast&lt;wchar_t&gt;(Operator::Plus); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail</code> <br> <br>  ,      .      ,  , .       . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"1+2*3/(4-5)"</span></span>); AssertRange::AreEqual({ Token(<span class="hljs-number"><span class="hljs-number">1</span></span>), Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">2</span></span>), Token(Operator::Mul), Token(<span class="hljs-number"><span class="hljs-number">3</span></span>), Token(Operator::Div), Token(Operator::LParen), Token(<span class="hljs-number"><span class="hljs-number">4</span></span>), Token(Operator::Minus), Token(<span class="hljs-number"><span class="hljs-number">5</span></span>), Token(Operator::RParen) }, tokens); }</code> <br>      <code>Operator</code> ,    . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L<span class="hljs-string"><span class="hljs-string">'+'</span></span>, Minus = L<span class="hljs-string"><span class="hljs-string">'-'</span></span>, Mul = L<span class="hljs-string"><span class="hljs-string">'*'</span></span>, Div = L<span class="hljs-string"><span class="hljs-string">'/'</span></span>, LParen = L<span class="hljs-string"><span class="hljs-string">'('</span></span>, RParen = L<span class="hljs-string"><span class="hljs-string">')'</span></span>, };</code> <br>   .         <code>IsOperator</code>  <code>Tokenizer</code> . <br> <br> <code class="cpp"> bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> std::any_of(all.begin(), all.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(), [this](Operator o) {<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_current == static_cast&lt;wchar_t&gt;(o); }); }</code> <br>         .        . <br> <br> <b class="spoiler_title">Interpreter.h</b> <code class="cpp">#pragma once; #include &lt;vector&gt; #include &lt;wchar.h&gt; #include &lt;algorithm&gt; namespace Interpreter { enum class Operator : wchar_t { Plus = L<span class="hljs-string"><span class="hljs-string">'+'</span></span>, Minus = L<span class="hljs-string"><span class="hljs-string">'-'</span></span>, Mul = L<span class="hljs-string"><span class="hljs-string">'*'</span></span>, Div = L<span class="hljs-string"><span class="hljs-string">'/'</span></span>, LParen = L<span class="hljs-string"><span class="hljs-string">'('</span></span>, RParen = L<span class="hljs-string"><span class="hljs-string">')'</span></span>, }; inline std::wstring ToString(const Operator &amp;op) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ static_cast&lt;wchar_t&gt;(op) }; } enum class TokenType { Operator, Number }; inline std::wstring ToString(const TokenType &amp;<span class="hljs-built_in"><span class="hljs-built_in">type</span></span>) { switch(<span class="hljs-built_in"><span class="hljs-built_in">type</span></span>) { case TokenType::Operator: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> L<span class="hljs-string"><span class="hljs-string">"Operator"</span></span>; case TokenType::Number: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> L<span class="hljs-string"><span class="hljs-string">"Number"</span></span>; default: throw std::out_of_range(<span class="hljs-string"><span class="hljs-string">"TokenType"</span></span>); } } class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_type; } operator Operator() const { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(m_type != TokenType::Operator) throw std::logic_error(<span class="hljs-string"><span class="hljs-string">"Should be operator token."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_operator; } operator double() const { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(m_type != TokenType::Number) throw std::logic_error(<span class="hljs-string"><span class="hljs-string">"Should be number token."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_number; } friend inline bool operator==(const Token &amp;left, const Token &amp;right) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(left.m_type == right.m_type) { switch(left.m_type) { case Interpreter::TokenType::Operator: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> left.m_operator == right.m_operator; case Interpreter::TokenType::Number: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> left.m_number == right.m_number; default: throw std::out_of_range(<span class="hljs-string"><span class="hljs-string">"TokenType"</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ToString(static_cast&lt;Operator&gt;(token)); default: throw std::out_of_range(<span class="hljs-string"><span class="hljs-string">"TokenType"</span></span>); } } typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!EndOfExperssion()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(IsNumber()) { ScanNumber(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(IsOperator()) { ScanOperator(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { MoveNext(); } } } const Tokens &amp;Result() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_result; } private: bool EndOfExperssion() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_current == L<span class="hljs-string"><span class="hljs-string">'\0'</span></span>; } bool IsNumber() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> iswdigit(*m_current) != <span class="hljs-number"><span class="hljs-number">0</span></span>; } void ScanNumber() { wchar_t *<span class="hljs-keyword"><span class="hljs-keyword">end</span></span> = nullptr; m_result.push_back(wcstod(m_current, &amp;<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>)); m_current = <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; } bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> std::any_of(all.begin(), all.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(), [this](Operator o) {<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_current == static_cast&lt;wchar_t&gt;(o); }); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tokenizer.Result(); } } // namespace Lexer } // namespace Interpreter</code> <br> <br> <b class="spoiler_title">InterpreterTests.cpp</b> <code class="cpp">#include <span class="hljs-string"><span class="hljs-string">"stdafx.h"</span></span> #include <span class="hljs-string"><span class="hljs-string">"CppUnitTest.h"</span></span> #include <span class="hljs-string"><span class="hljs-string">"Interpreter.h"</span></span> namespace InterpreterTests { using namespace Microsoft::VisualStudio::CppUnitTestFramework; using namespace Interpreter; using namespace std; namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(expect)), distance(actualIter, <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(actual)), L<span class="hljs-string"><span class="hljs-string">"Size differs."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(; expectIter != <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(expect) &amp;&amp; actualIter != <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(actual); ++expectIter, ++actualIter) { auto message = L<span class="hljs-string"><span class="hljs-string">"Mismatch in position "</span></span> + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual&lt;T&gt;(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange TEST_CLASS(LexerTests) { public: TEST_METHOD(Should_return_empty_token_list_when_put_empty_expression) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">""</span></span>); Assert::IsTrue(tokens.empty()); } TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"+"</span></span>); AssertRange::AreEqual({ Operator::Plus }, tokens); } TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"1"</span></span>); AssertRange::AreEqual({ <span class="hljs-number"><span class="hljs-number">1.0</span></span> }, tokens); } TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"12.34"</span></span>); AssertRange::AreEqual({ <span class="hljs-number"><span class="hljs-number">12.34</span></span> }, tokens); } TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"+12.34"</span></span>); AssertRange::AreEqual({ Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">12.34</span></span>) }, tokens); } TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">" 1 + 12.34 "</span></span>); AssertRange::AreEqual({ Token(<span class="hljs-number"><span class="hljs-number">1.0</span></span>), Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">12.34</span></span>) }, tokens); } TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"1+2*3/(4-5)"</span></span>); AssertRange::AreEqual({ Token(<span class="hljs-number"><span class="hljs-number">1</span></span>), Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">2</span></span>), Token(Operator::Mul), Token(<span class="hljs-number"><span class="hljs-number">3</span></span>), Token(Operator::Div), Token(Operator::LParen), Token(<span class="hljs-number"><span class="hljs-number">4</span></span>), Token(Operator::Minus), Token(<span class="hljs-number"><span class="hljs-number">5</span></span>), Token(Operator::RParen) }, tokens); } }; TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } TEST_METHOD(Should_get_type_for_number_token) { Token numToken(<span class="hljs-number"><span class="hljs-number">1.2</span></span>); Assert::AreEqual(TokenType::Number, numToken.Type()); } TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); } TEST_METHOD(Should_get_number_value_from_number_token) { Token token(<span class="hljs-number"><span class="hljs-number">1.23</span></span>); Assert::AreEqual&lt;double&gt;(<span class="hljs-number"><span class="hljs-number">1.23</span></span>, token); } }; }</code> <br> <br> <a href="https://github.com/Unril/InterpreterTDD/releases/tag/%25D0%259A%25D0%25BE%25D0%25BD%25D0%25B5%25D1%2586_%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B2%25D0%25BE%25D0%25B9_%25D1%2587%25D0%25B0%25D1%2581%25D1%2582%25D0%25B8">    GitHub</a> .         ,  .      <span class="hljs-string"><span class="hljs-string">"__"</span></span>. <br> <br>   <a href="http://habrahabr.ru/post/232081/">    </a> .      ,      <a href="http://habrahabr.ru/post/232097/">    </a> .</code></code> </pre> <code><code>std::vector,      Tokens</code> .            . <br> <br> <code class="cpp">#pragma once; #include &lt;vector&gt; namespace Interpreter { struct Token {}; typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { inline Tokens Tokenize(std::string expr) { throw std::exception(); } } // namespace Lexer } // namespace Interpreter</code> <br>   ,  ,   , .   ,    ,    <a href="http://cleancoder.posterous.com/the-transformation-priority-premise">The Transformation Priority Premise (TPP)</a>   .    , ,    ,     ,        .            .     ,     ,      ,           .  ,  ,   (   )    ,  ,  .     ,  ,         .     ,   TPP          . <br> <br>   : <br> <br> ({} ‚Üí nil)     ,   . (nil ‚Üí constant)    . (constant ‚Üí constant+)      (        ,  ). (constant ‚Üí scalar)    ,  . (statement ‚Üí statements)    (break, continue, return  ). (unconditional ‚Üí if)       . (scalar ‚Üí array)  / . (array ‚Üí container)     . (statement ‚Üí recursion)   . (if ‚Üí while)    . (expression ‚Üí function)   . (variable ‚Üí assignment)   . <br>        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::string expr) { return{}; }</code> <br> ,         .     . <br> <br> <s>         </s> .           .           .               .            .       . <br>  ,  <code>std::string</code>  <code>std::wstring</code> .         ,      Unicode.     . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); }</code> <br>  <code>AssertRange</code> -   ,       <code>AreEqual</code> ,   ,  ,    . <br> <br> <b class="spoiler_title">AssertRange</b> <code class="cpp">namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange</code> <br> <br>         <code>Operator</code>    .          <code>wchar_t</code>   ,         ,      . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', }; typedef Operator Token;</code> <br>    ,   ,        <code>Assert</code> ,    <code>ToString</code> ,    . <br> <br> <b class="spoiler_title">std::wstring ToString(const Token &amp;)</b> <code class="cpp">inline std::wstring ToString(const Token &amp;token) { return{ static_cast&lt;wchar_t&gt;(token) }; }</code> <br> <br>    ,   ,        .  ,   (unconditional ‚Üí if). <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { if(expr.empty()) { return{}; } return{ static_cast&lt;Operator&gt;(expr[0]) }; }</code> <br> <s>         </s> . <s>          .</s>           . ‚Ä¶ <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); }</code> <br>     .   ,     ,   - .    , : <br> <br>        ,      <code>Token</code> .       <code>dynamic_cast</code>    ,   .  ,    ,      .      <code>std::function</code>        .        .  Boost.Any,  - .            . <br>   ,   .      -  .  ,      ,      . <br> <br> ‚Ä¶        .        .        .        . <br>             . <br> <br> <code class="cpp">enum class TokenType { Operator, Number }; class Token { public: Token(Operator) {} TokenType Type() const { return TokenType::Operator; } }; ‚Ä¶ TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } };</code> <br>   <code>ToString</code>   <code>TokenType</code>       ,   ,   .     . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); }</code> <br>   .   (constant ‚Üí scalar)   . <br> <br> <code class="cpp">class Token { public: Token(Operator) :m_type(TokenType::Operator) {} Token(double) :m_type(TokenType::Number) {} TokenType Type() const { return m_type; } private: TokenType m_type; };</code> <br> ‚Ä¶ <s>       </s> . <s>       </s> .        .        . <br>    . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); }</code> <br>            . <br> <br> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} operator Operator() const { return m_operator; } ‚Ä¶ Operator m_operator; };</code> <br>      . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); }</code> <br>          ,  ,       <code>union</code> .         . <br> <br> <b class="spoiler_title">Token</b> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: return "Unknown token."; } }</code> <br> <br>  ,    ,      ,    .       .    . <br> <br> <i>          .</i>               .            .       . <br>        : <br> <br> <code class="cpp"> if(expr[0] &gt;= '0' &amp;&amp; expr[0] &lt;= '9') { return{ (double) expr[0] - '0' }; } return{ static_cast&lt;Operator&gt;(expr[0]) };</code> <br>      ,   . <br> <br> ‚Ä¶ <s>          .</s> <i>              .</i> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); }</code> <br> ,     <code>C</code>   ,  <code>isdigit</code> , ,       <code>atof</code> ,    ,      <code>wchar_t</code> .  (expression ‚Üí function).         . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { const wchar_t *current = expr.c_str(); if(!*current) return{}; if(iswdigit(*current)) return{ _wtof(current) }; return{ static_cast&lt;Operator&gt;(*current) }; }</code> <br>         .      . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>   ,        .  ,     .     .   <code>result</code> ,     . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); if(!*current) return result; if(iswdigit(*current)) { result.push_back(_wtof(current)); } else { result.push_back(static_cast&lt;Operator&gt;(*current)); } return result; }</code> <br>      :   (if ‚Üí while).     ,        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } } return result; }</code> <br>  <code>wcstod</code>    ,   <code>_wtof</code> ,           .           ,              .  ,    . <br> <br> <s>           .</s>       . <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>  (unconditional ‚Üí if)    ,    . <br> <br> <code class="cpp"> while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else if(*current == static_cast&lt;wchar_t&gt;(Operator::Plus)) { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } else { ++current; } }</code> <br>       .          .       <code>Detail</code>      .   <code>Tokenize</code>       . <br> <br> <code class="cpp">inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); }</code> <br> <b class="spoiler_title"> Detail::Tokenizer</b> <code class="cpp">namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { return *m_current == static_cast&lt;wchar_t&gt;(Operator::Plus); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail</code> <br> <br>  ,      .      ,  , .       . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); }</code> <br>      <code>Operator</code> ,    . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', };</code> <br>   .         <code>IsOperator</code>  <code>Tokenizer</code> . <br> <br> <code class="cpp"> bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); }</code> <br>         .        . <br> <br> <b class="spoiler_title">Interpreter.h</b> <code class="cpp">#pragma once; #include &lt;vector&gt; #include &lt;wchar.h&gt; #include &lt;algorithm&gt; namespace Interpreter { enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', }; inline std::wstring ToString(const Operator &amp;op) { return{ static_cast&lt;wchar_t&gt;(op) }; } enum class TokenType { Operator, Number }; inline std::wstring ToString(const TokenType &amp;type) { switch(type) { case TokenType::Operator: return L"Operator"; case TokenType::Number: return L"Number"; default: throw std::out_of_range("TokenType"); } } class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } friend inline bool operator==(const Token &amp;left, const Token &amp;right) { if(left.m_type == right.m_type) { switch(left.m_type) { case Interpreter::TokenType::Operator: return left.m_operator == right.m_operator; case Interpreter::TokenType::Number: return left.m_number == right.m_number; default: throw std::out_of_range("TokenType"); } } return false; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: throw std::out_of_range("TokenType"); } } typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); } } // namespace Lexer } // namespace Interpreter</code> <br> <br> <b class="spoiler_title">InterpreterTests.cpp</b> <code class="cpp">#include "stdafx.h" #include "CppUnitTest.h" #include "Interpreter.h" namespace InterpreterTests { using namespace Microsoft::VisualStudio::CppUnitTestFramework; using namespace Interpreter; using namespace std; namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual&lt;T&gt;(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange TEST_CLASS(LexerTests) { public: TEST_METHOD(Should_return_empty_token_list_when_put_empty_expression) { Tokens tokens = Lexer::Tokenize(L""); Assert::IsTrue(tokens.empty()); } TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); } TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); } TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); } TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); } }; TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); } TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); } TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); } }; }</code> <br> <br> <a href="https://github.com/Unril/InterpreterTDD/releases/tag/%25D0%259A%25D0%25BE%25D0%25BD%25D0%25B5%25D1%2586_%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B2%25D0%25BE%25D0%25B9_%25D1%2587%25D0%25B0%25D1%2581%25D1%2582%25D0%25B8">    GitHub</a> .         ,  .      "__". <br> <br>   <a href="http://habrahabr.ru/post/232081/">    </a> .      ,      <a href="http://habrahabr.ru/post/232097/">    </a> .</code> <ul><li> <code><code>std::vector,      Tokens</code> .            . <br> <br> <code class="cpp">#pragma once; #include &lt;vector&gt; namespace Interpreter { struct Token {}; typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { inline Tokens Tokenize(std::string expr) { throw std::exception(); } } // namespace Lexer } // namespace Interpreter</code> <br>   ,  ,   , .   ,    ,    <a href="http://cleancoder.posterous.com/the-transformation-priority-premise">The Transformation Priority Premise (TPP)</a>   .    , ,    ,     ,        .            .     ,     ,      ,           .  ,  ,   (   )    ,  ,  .     ,  ,         .     ,   TPP          . <br> <br>   : <br> <br> ({} ‚Üí nil)     ,   . (nil ‚Üí constant)    . (constant ‚Üí constant+)      (        ,  ). (constant ‚Üí scalar)    ,  . (statement ‚Üí statements)    (break, continue, return  ). (unconditional ‚Üí if)       . (scalar ‚Üí array)  / . (array ‚Üí container)     . (statement ‚Üí recursion)   . (if ‚Üí while)    . (expression ‚Üí function)   . (variable ‚Üí assignment)   . <br>        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::string expr) { return{}; }</code> <br> ,         .     . <br> <br> <s>         </s> .           .           .               .            .       . <br>  ,  <code>std::string</code>  <code>std::wstring</code> .         ,      Unicode.     . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); }</code> <br>  <code>AssertRange</code> -   ,       <code>AreEqual</code> ,   ,  ,    . <br> <br> <b class="spoiler_title">AssertRange</b> <code class="cpp">namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange</code> <br> <br>         <code>Operator</code>    .          <code>wchar_t</code>   ,         ,      . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', }; typedef Operator Token;</code> <br>    ,   ,        <code>Assert</code> ,    <code>ToString</code> ,    . <br> <br> <b class="spoiler_title">std::wstring ToString(const Token &amp;)</b> <code class="cpp">inline std::wstring ToString(const Token &amp;token) { return{ static_cast&lt;wchar_t&gt;(token) }; }</code> <br> <br>    ,   ,        .  ,   (unconditional ‚Üí if). <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { if(expr.empty()) { return{}; } return{ static_cast&lt;Operator&gt;(expr[0]) }; }</code> <br> <s>         </s> . <s>          .</s>           . ‚Ä¶ <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); }</code> <br>     .   ,     ,   - .    , : <br> <br>        ,      <code>Token</code> .       <code>dynamic_cast</code>    ,   .  ,    ,      .      <code>std::function</code>        .        .  Boost.Any,  - .            . <br>   ,   .      -  .  ,      ,      . <br> <br> ‚Ä¶        .        .        .        . <br>             . <br> <br> <code class="cpp">enum class TokenType { Operator, Number }; class Token { public: Token(Operator) {} TokenType Type() const { return TokenType::Operator; } }; ‚Ä¶ TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } };</code> <br>   <code>ToString</code>   <code>TokenType</code>       ,   ,   .     . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); }</code> <br>   .   (constant ‚Üí scalar)   . <br> <br> <code class="cpp">class Token { public: Token(Operator) :m_type(TokenType::Operator) {} Token(double) :m_type(TokenType::Number) {} TokenType Type() const { return m_type; } private: TokenType m_type; };</code> <br> ‚Ä¶ <s>       </s> . <s>       </s> .        .        . <br>    . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); }</code> <br>            . <br> <br> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} operator Operator() const { return m_operator; } ‚Ä¶ Operator m_operator; };</code> <br>      . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); }</code> <br>          ,  ,       <code>union</code> .         . <br> <br> <b class="spoiler_title">Token</b> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: return "Unknown token."; } }</code> <br> <br>  ,    ,      ,    .       .    . <br> <br> <i>          .</i>               .            .       . <br>        : <br> <br> <code class="cpp"> if(expr[0] &gt;= '0' &amp;&amp; expr[0] &lt;= '9') { return{ (double) expr[0] - '0' }; } return{ static_cast&lt;Operator&gt;(expr[0]) };</code> <br>      ,   . <br> <br> ‚Ä¶ <s>          .</s> <i>              .</i> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); }</code> <br> ,     <code>C</code>   ,  <code>isdigit</code> , ,       <code>atof</code> ,    ,      <code>wchar_t</code> .  (expression ‚Üí function).         . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { const wchar_t *current = expr.c_str(); if(!*current) return{}; if(iswdigit(*current)) return{ _wtof(current) }; return{ static_cast&lt;Operator&gt;(*current) }; }</code> <br>         .      . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>   ,        .  ,     .     .   <code>result</code> ,     . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); if(!*current) return result; if(iswdigit(*current)) { result.push_back(_wtof(current)); } else { result.push_back(static_cast&lt;Operator&gt;(*current)); } return result; }</code> <br>      :   (if ‚Üí while).     ,        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } } return result; }</code> <br>  <code>wcstod</code>    ,   <code>_wtof</code> ,           .           ,              .  ,    . <br> <br> <s>           .</s>       . <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>  (unconditional ‚Üí if)    ,    . <br> <br> <code class="cpp"> while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else if(*current == static_cast&lt;wchar_t&gt;(Operator::Plus)) { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } else { ++current; } }</code> <br>       .          .       <code>Detail</code>      .   <code>Tokenize</code>       . <br> <br> <code class="cpp">inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); }</code> <br> <b class="spoiler_title"> Detail::Tokenizer</b> <code class="cpp">namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { return *m_current == static_cast&lt;wchar_t&gt;(Operator::Plus); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail</code> <br> <br>  ,      .      ,  , .       . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); }</code> <br>      <code>Operator</code> ,    . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', };</code> <br>   .         <code>IsOperator</code>  <code>Tokenizer</code> . <br> <br> <code class="cpp"> bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); }</code> <br>         .        . <br> <br> <b class="spoiler_title">Interpreter.h</b> <code class="cpp">#pragma once; #include &lt;vector&gt; #include &lt;wchar.h&gt; #include &lt;algorithm&gt; namespace Interpreter { enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', }; inline std::wstring ToString(const Operator &amp;op) { return{ static_cast&lt;wchar_t&gt;(op) }; } enum class TokenType { Operator, Number }; inline std::wstring ToString(const TokenType &amp;type) { switch(type) { case TokenType::Operator: return L"Operator"; case TokenType::Number: return L"Number"; default: throw std::out_of_range("TokenType"); } } class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } friend inline bool operator==(const Token &amp;left, const Token &amp;right) { if(left.m_type == right.m_type) { switch(left.m_type) { case Interpreter::TokenType::Operator: return left.m_operator == right.m_operator; case Interpreter::TokenType::Number: return left.m_number == right.m_number; default: throw std::out_of_range("TokenType"); } } return false; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: throw std::out_of_range("TokenType"); } } typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); } } // namespace Lexer } // namespace Interpreter</code> <br> <br> <b class="spoiler_title">InterpreterTests.cpp</b> <code class="cpp">#include "stdafx.h" #include "CppUnitTest.h" #include "Interpreter.h" namespace InterpreterTests { using namespace Microsoft::VisualStudio::CppUnitTestFramework; using namespace Interpreter; using namespace std; namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual&lt;T&gt;(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange TEST_CLASS(LexerTests) { public: TEST_METHOD(Should_return_empty_token_list_when_put_empty_expression) { Tokens tokens = Lexer::Tokenize(L""); Assert::IsTrue(tokens.empty()); } TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); } TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); } TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); } TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); } }; TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); } TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); } TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); } }; }</code> <br> <br> <a href="https://github.com/Unril/InterpreterTDD/releases/tag/%25D0%259A%25D0%25BE%25D0%25BD%25D0%25B5%25D1%2586_%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B2%25D0%25BE%25D0%25B9_%25D1%2587%25D0%25B0%25D1%2581%25D1%2582%25D0%25B8">    GitHub</a> .         ,  .      "__". <br> <br>   <a href="http://habrahabr.ru/post/232081/">    </a> .      ,      <a href="http://habrahabr.ru/post/232097/">    </a> .</code> </li> <li> <code><code>std::vector,      Tokens</code> .            . <br> <br> <code class="cpp">#pragma once; #include &lt;vector&gt; namespace Interpreter { struct Token {}; typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { inline Tokens Tokenize(std::string expr) { throw std::exception(); } } // namespace Lexer } // namespace Interpreter</code> <br>   ,  ,   , .   ,    ,    <a href="http://cleancoder.posterous.com/the-transformation-priority-premise">The Transformation Priority Premise (TPP)</a>   .    , ,    ,     ,        .            .     ,     ,      ,           .  ,  ,   (   )    ,  ,  .     ,  ,         .     ,   TPP          . <br> <br>   : <br> <br> ({} ‚Üí nil)     ,   . (nil ‚Üí constant)    . (constant ‚Üí constant+)      (        ,  ). (constant ‚Üí scalar)    ,  . (statement ‚Üí statements)    (break, continue, return  ). (unconditional ‚Üí if)       . (scalar ‚Üí array)  / . (array ‚Üí container)     . (statement ‚Üí recursion)   . (if ‚Üí while)    . (expression ‚Üí function)   . (variable ‚Üí assignment)   . <br>        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::string expr) { return{}; }</code> <br> ,         .     . <br> <br> <s>         </s> .           .           .               .            .       . <br>  ,  <code>std::string</code>  <code>std::wstring</code> .         ,      Unicode.     . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); }</code> <br>  <code>AssertRange</code> -   ,       <code>AreEqual</code> ,   ,  ,    . <br> <br> <b class="spoiler_title">AssertRange</b> <code class="cpp">namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange</code> <br> <br>         <code>Operator</code>    .          <code>wchar_t</code>   ,         ,      . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', }; typedef Operator Token;</code> <br>    ,   ,        <code>Assert</code> ,    <code>ToString</code> ,    . <br> <br> <b class="spoiler_title">std::wstring ToString(const Token &amp;)</b> <code class="cpp">inline std::wstring ToString(const Token &amp;token) { return{ static_cast&lt;wchar_t&gt;(token) }; }</code> <br> <br>    ,   ,        .  ,   (unconditional ‚Üí if). <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { if(expr.empty()) { return{}; } return{ static_cast&lt;Operator&gt;(expr[0]) }; }</code> <br> <s>         </s> . <s>          .</s>           . ‚Ä¶ <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); }</code> <br>     .   ,     ,   - .    , : <br> <br>        ,      <code>Token</code> .       <code>dynamic_cast</code>    ,   .  ,    ,      .      <code>std::function</code>        .        .  Boost.Any,  - .            . <br>   ,   .      -  .  ,      ,      . <br> <br> ‚Ä¶        .        .        .        . <br>             . <br> <br> <code class="cpp">enum class TokenType { Operator, Number }; class Token { public: Token(Operator) {} TokenType Type() const { return TokenType::Operator; } }; ‚Ä¶ TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } };</code> <br>   <code>ToString</code>   <code>TokenType</code>       ,   ,   .     . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); }</code> <br>   .   (constant ‚Üí scalar)   . <br> <br> <code class="cpp">class Token { public: Token(Operator) :m_type(TokenType::Operator) {} Token(double) :m_type(TokenType::Number) {} TokenType Type() const { return m_type; } private: TokenType m_type; };</code> <br> ‚Ä¶ <s>       </s> . <s>       </s> .        .        . <br>    . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); }</code> <br>            . <br> <br> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} operator Operator() const { return m_operator; } ‚Ä¶ Operator m_operator; };</code> <br>      . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); }</code> <br>          ,  ,       <code>union</code> .         . <br> <br> <b class="spoiler_title">Token</b> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: return "Unknown token."; } }</code> <br> <br>  ,    ,      ,    .       .    . <br> <br> <i>          .</i>               .            .       . <br>        : <br> <br> <code class="cpp"> if(expr[0] &gt;= '0' &amp;&amp; expr[0] &lt;= '9') { return{ (double) expr[0] - '0' }; } return{ static_cast&lt;Operator&gt;(expr[0]) };</code> <br>      ,   . <br> <br> ‚Ä¶ <s>          .</s> <i>              .</i> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); }</code> <br> ,     <code>C</code>   ,  <code>isdigit</code> , ,       <code>atof</code> ,    ,      <code>wchar_t</code> .  (expression ‚Üí function).         . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { const wchar_t *current = expr.c_str(); if(!*current) return{}; if(iswdigit(*current)) return{ _wtof(current) }; return{ static_cast&lt;Operator&gt;(*current) }; }</code> <br>         .      . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>   ,        .  ,     .     .   <code>result</code> ,     . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); if(!*current) return result; if(iswdigit(*current)) { result.push_back(_wtof(current)); } else { result.push_back(static_cast&lt;Operator&gt;(*current)); } return result; }</code> <br>      :   (if ‚Üí while).     ,        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } } return result; }</code> <br>  <code>wcstod</code>    ,   <code>_wtof</code> ,           .           ,              .  ,    . <br> <br> <s>           .</s>       . <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>  (unconditional ‚Üí if)    ,    . <br> <br> <code class="cpp"> while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else if(*current == static_cast&lt;wchar_t&gt;(Operator::Plus)) { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } else { ++current; } }</code> <br>       .          .       <code>Detail</code>      .   <code>Tokenize</code>       . <br> <br> <code class="cpp">inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); }</code> <br> <b class="spoiler_title"> Detail::Tokenizer</b> <code class="cpp">namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { return *m_current == static_cast&lt;wchar_t&gt;(Operator::Plus); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail</code> <br> <br>  ,      .      ,  , .       . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); }</code> <br>      <code>Operator</code> ,    . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', };</code> <br>   .         <code>IsOperator</code>  <code>Tokenizer</code> . <br> <br> <code class="cpp"> bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); }</code> <br>         .        . <br> <br> <b class="spoiler_title">Interpreter.h</b> <code class="cpp">#pragma once; #include &lt;vector&gt; #include &lt;wchar.h&gt; #include &lt;algorithm&gt; namespace Interpreter { enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', }; inline std::wstring ToString(const Operator &amp;op) { return{ static_cast&lt;wchar_t&gt;(op) }; } enum class TokenType { Operator, Number }; inline std::wstring ToString(const TokenType &amp;type) { switch(type) { case TokenType::Operator: return L"Operator"; case TokenType::Number: return L"Number"; default: throw std::out_of_range("TokenType"); } } class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } friend inline bool operator==(const Token &amp;left, const Token &amp;right) { if(left.m_type == right.m_type) { switch(left.m_type) { case Interpreter::TokenType::Operator: return left.m_operator == right.m_operator; case Interpreter::TokenType::Number: return left.m_number == right.m_number; default: throw std::out_of_range("TokenType"); } } return false; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: throw std::out_of_range("TokenType"); } } typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); } } // namespace Lexer } // namespace Interpreter</code> <br> <br> <b class="spoiler_title">InterpreterTests.cpp</b> <code class="cpp">#include "stdafx.h" #include "CppUnitTest.h" #include "Interpreter.h" namespace InterpreterTests { using namespace Microsoft::VisualStudio::CppUnitTestFramework; using namespace Interpreter; using namespace std; namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual&lt;T&gt;(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange TEST_CLASS(LexerTests) { public: TEST_METHOD(Should_return_empty_token_list_when_put_empty_expression) { Tokens tokens = Lexer::Tokenize(L""); Assert::IsTrue(tokens.empty()); } TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); } TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); } TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); } TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); } }; TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); } TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); } TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); } }; }</code> <br> <br> <a href="https://github.com/Unril/InterpreterTDD/releases/tag/%25D0%259A%25D0%25BE%25D0%25BD%25D0%25B5%25D1%2586_%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B2%25D0%25BE%25D0%25B9_%25D1%2587%25D0%25B0%25D1%2581%25D1%2582%25D0%25B8">    GitHub</a> .         ,  .      "__". <br> <br>   <a href="http://habrahabr.ru/post/232081/">    </a> .      ,      <a href="http://habrahabr.ru/post/232097/">    </a> .</code> </li> <li> <code><code>std::vector,      Tokens</code> .            . <br> <br> <code class="cpp">#pragma once; #include &lt;vector&gt; namespace Interpreter { struct Token {}; typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { inline Tokens Tokenize(std::string expr) { throw std::exception(); } } // namespace Lexer } // namespace Interpreter</code> <br>   ,  ,   , .   ,    ,    <a href="http://cleancoder.posterous.com/the-transformation-priority-premise">The Transformation Priority Premise (TPP)</a>   .    , ,    ,     ,        .            .     ,     ,      ,           .  ,  ,   (   )    ,  ,  .     ,  ,         .     ,   TPP          . <br> <br>   : <br> <br> ({} ‚Üí nil)     ,   . (nil ‚Üí constant)    . (constant ‚Üí constant+)      (        ,  ). (constant ‚Üí scalar)    ,  . (statement ‚Üí statements)    (break, continue, return  ). (unconditional ‚Üí if)       . (scalar ‚Üí array)  / . (array ‚Üí container)     . (statement ‚Üí recursion)   . (if ‚Üí while)    . (expression ‚Üí function)   . (variable ‚Üí assignment)   . <br>        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::string expr) { return{}; }</code> <br> ,         .     . <br> <br> <s>         </s> .           .           .               .            .       . <br>  ,  <code>std::string</code>  <code>std::wstring</code> .         ,      Unicode.     . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); }</code> <br>  <code>AssertRange</code> -   ,       <code>AreEqual</code> ,   ,  ,    . <br> <br> <b class="spoiler_title">AssertRange</b> <code class="cpp">namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange</code> <br> <br>         <code>Operator</code>    .          <code>wchar_t</code>   ,         ,      . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', }; typedef Operator Token;</code> <br>    ,   ,        <code>Assert</code> ,    <code>ToString</code> ,    . <br> <br> <b class="spoiler_title">std::wstring ToString(const Token &amp;)</b> <code class="cpp">inline std::wstring ToString(const Token &amp;token) { return{ static_cast&lt;wchar_t&gt;(token) }; }</code> <br> <br>    ,   ,        .  ,   (unconditional ‚Üí if). <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { if(expr.empty()) { return{}; } return{ static_cast&lt;Operator&gt;(expr[0]) }; }</code> <br> <s>         </s> . <s>          .</s>           . ‚Ä¶ <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); }</code> <br>     .   ,     ,   - .    , : <br> <br>        ,      <code>Token</code> .       <code>dynamic_cast</code>    ,   .  ,    ,      .      <code>std::function</code>        .        .  Boost.Any,  - .            . <br>   ,   .      -  .  ,      ,      . <br> <br> ‚Ä¶        .        .        .        . <br>             . <br> <br> <code class="cpp">enum class TokenType { Operator, Number }; class Token { public: Token(Operator) {} TokenType Type() const { return TokenType::Operator; } }; ‚Ä¶ TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } };</code> <br>   <code>ToString</code>   <code>TokenType</code>       ,   ,   .     . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); }</code> <br>   .   (constant ‚Üí scalar)   . <br> <br> <code class="cpp">class Token { public: Token(Operator) :m_type(TokenType::Operator) {} Token(double) :m_type(TokenType::Number) {} TokenType Type() const { return m_type; } private: TokenType m_type; };</code> <br> ‚Ä¶ <s>       </s> . <s>       </s> .        .        . <br>    . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); }</code> <br>            . <br> <br> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} operator Operator() const { return m_operator; } ‚Ä¶ Operator m_operator; };</code> <br>      . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); }</code> <br>          ,  ,       <code>union</code> .         . <br> <br> <b class="spoiler_title">Token</b> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: return "Unknown token."; } }</code> <br> <br>  ,    ,      ,    .       .    . <br> <br> <i>          .</i>               .            .       . <br>        : <br> <br> <code class="cpp"> if(expr[0] &gt;= '0' &amp;&amp; expr[0] &lt;= '9') { return{ (double) expr[0] - '0' }; } return{ static_cast&lt;Operator&gt;(expr[0]) };</code> <br>      ,   . <br> <br> ‚Ä¶ <s>          .</s> <i>              .</i> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); }</code> <br> ,     <code>C</code>   ,  <code>isdigit</code> , ,       <code>atof</code> ,    ,      <code>wchar_t</code> .  (expression ‚Üí function).         . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { const wchar_t *current = expr.c_str(); if(!*current) return{}; if(iswdigit(*current)) return{ _wtof(current) }; return{ static_cast&lt;Operator&gt;(*current) }; }</code> <br>         .      . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>   ,        .  ,     .     .   <code>result</code> ,     . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); if(!*current) return result; if(iswdigit(*current)) { result.push_back(_wtof(current)); } else { result.push_back(static_cast&lt;Operator&gt;(*current)); } return result; }</code> <br>      :   (if ‚Üí while).     ,        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } } return result; }</code> <br>  <code>wcstod</code>    ,   <code>_wtof</code> ,           .           ,              .  ,    . <br> <br> <s>           .</s>       . <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>  (unconditional ‚Üí if)    ,    . <br> <br> <code class="cpp"> while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else if(*current == static_cast&lt;wchar_t&gt;(Operator::Plus)) { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } else { ++current; } }</code> <br>       .          .       <code>Detail</code>      .   <code>Tokenize</code>       . <br> <br> <code class="cpp">inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); }</code> <br> <b class="spoiler_title"> Detail::Tokenizer</b> <code class="cpp">namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { return *m_current == static_cast&lt;wchar_t&gt;(Operator::Plus); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail</code> <br> <br>  ,      .      ,  , .       . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); }</code> <br>      <code>Operator</code> ,    . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', };</code> <br>   .         <code>IsOperator</code>  <code>Tokenizer</code> . <br> <br> <code class="cpp"> bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); }</code> <br>         .        . <br> <br> <b class="spoiler_title">Interpreter.h</b> <code class="cpp">#pragma once; #include &lt;vector&gt; #include &lt;wchar.h&gt; #include &lt;algorithm&gt; namespace Interpreter { enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', }; inline std::wstring ToString(const Operator &amp;op) { return{ static_cast&lt;wchar_t&gt;(op) }; } enum class TokenType { Operator, Number }; inline std::wstring ToString(const TokenType &amp;type) { switch(type) { case TokenType::Operator: return L"Operator"; case TokenType::Number: return L"Number"; default: throw std::out_of_range("TokenType"); } } class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } friend inline bool operator==(const Token &amp;left, const Token &amp;right) { if(left.m_type == right.m_type) { switch(left.m_type) { case Interpreter::TokenType::Operator: return left.m_operator == right.m_operator; case Interpreter::TokenType::Number: return left.m_number == right.m_number; default: throw std::out_of_range("TokenType"); } } return false; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: throw std::out_of_range("TokenType"); } } typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); } } // namespace Lexer } // namespace Interpreter</code> <br> <br> <b class="spoiler_title">InterpreterTests.cpp</b> <code class="cpp">#include "stdafx.h" #include "CppUnitTest.h" #include "Interpreter.h" namespace InterpreterTests { using namespace Microsoft::VisualStudio::CppUnitTestFramework; using namespace Interpreter; using namespace std; namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual&lt;T&gt;(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange TEST_CLASS(LexerTests) { public: TEST_METHOD(Should_return_empty_token_list_when_put_empty_expression) { Tokens tokens = Lexer::Tokenize(L""); Assert::IsTrue(tokens.empty()); } TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); } TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); } TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); } TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); } }; TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); } TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); } TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); } }; }</code> <br> <br> <a href="https://github.com/Unril/InterpreterTDD/releases/tag/%25D0%259A%25D0%25BE%25D0%25BD%25D0%25B5%25D1%2586_%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B2%25D0%25BE%25D0%25B9_%25D1%2587%25D0%25B0%25D1%2581%25D1%2582%25D0%25B8">    GitHub</a> .         ,  .      "__". <br> <br>   <a href="http://habrahabr.ru/post/232081/">    </a> .      ,      <a href="http://habrahabr.ru/post/232097/">    </a> .</code> </li> <li> <code><code>std::vector,      Tokens</code> .            . <br> <br> <code class="cpp">#pragma once; #include &lt;vector&gt; namespace Interpreter { struct Token {}; typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { inline Tokens Tokenize(std::string expr) { throw std::exception(); } } // namespace Lexer } // namespace Interpreter</code> <br>   ,  ,   , .   ,    ,    <a href="http://cleancoder.posterous.com/the-transformation-priority-premise">The Transformation Priority Premise (TPP)</a>   .    , ,    ,     ,        .            .     ,     ,      ,           .  ,  ,   (   )    ,  ,  .     ,  ,         .     ,   TPP          . <br> <br>   : <br> <br> ({} ‚Üí nil)     ,   . (nil ‚Üí constant)    . (constant ‚Üí constant+)      (        ,  ). (constant ‚Üí scalar)    ,  . (statement ‚Üí statements)    (break, continue, return  ). (unconditional ‚Üí if)       . (scalar ‚Üí array)  / . (array ‚Üí container)     . (statement ‚Üí recursion)   . (if ‚Üí while)    . (expression ‚Üí function)   . (variable ‚Üí assignment)   . <br>        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::string expr) { return{}; }</code> <br> ,         .     . <br> <br> <s>         </s> .           .           .               .            .       . <br>  ,  <code>std::string</code>  <code>std::wstring</code> .         ,      Unicode.     . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); }</code> <br>  <code>AssertRange</code> -   ,       <code>AreEqual</code> ,   ,  ,    . <br> <br> <b class="spoiler_title">AssertRange</b> <code class="cpp">namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange</code> <br> <br>         <code>Operator</code>    .          <code>wchar_t</code>   ,         ,      . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', }; typedef Operator Token;</code> <br>    ,   ,        <code>Assert</code> ,    <code>ToString</code> ,    . <br> <br> <b class="spoiler_title">std::wstring ToString(const Token &amp;)</b> <code class="cpp">inline std::wstring ToString(const Token &amp;token) { return{ static_cast&lt;wchar_t&gt;(token) }; }</code> <br> <br>    ,   ,        .  ,   (unconditional ‚Üí if). <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { if(expr.empty()) { return{}; } return{ static_cast&lt;Operator&gt;(expr[0]) }; }</code> <br> <s>         </s> . <s>          .</s>           . ‚Ä¶ <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); }</code> <br>     .   ,     ,   - .    , : <br> <br>        ,      <code>Token</code> .       <code>dynamic_cast</code>    ,   .  ,    ,      .      <code>std::function</code>        .        .  Boost.Any,  - .            . <br>   ,   .      -  .  ,      ,      . <br> <br> ‚Ä¶        .        .        .        . <br>             . <br> <br> <code class="cpp">enum class TokenType { Operator, Number }; class Token { public: Token(Operator) {} TokenType Type() const { return TokenType::Operator; } }; ‚Ä¶ TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } };</code> <br>   <code>ToString</code>   <code>TokenType</code>       ,   ,   .     . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); }</code> <br>   .   (constant ‚Üí scalar)   . <br> <br> <code class="cpp">class Token { public: Token(Operator) :m_type(TokenType::Operator) {} Token(double) :m_type(TokenType::Number) {} TokenType Type() const { return m_type; } private: TokenType m_type; };</code> <br> ‚Ä¶ <s>       </s> . <s>       </s> .        .        . <br>    . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); }</code> <br>            . <br> <br> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} operator Operator() const { return m_operator; } ‚Ä¶ Operator m_operator; };</code> <br>      . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); }</code> <br>          ,  ,       <code>union</code> .         . <br> <br> <b class="spoiler_title">Token</b> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: return "Unknown token."; } }</code> <br> <br>  ,    ,      ,    .       .    . <br> <br> <i>          .</i>               .            .       . <br>        : <br> <br> <code class="cpp"> if(expr[0] &gt;= '0' &amp;&amp; expr[0] &lt;= '9') { return{ (double) expr[0] - '0' }; } return{ static_cast&lt;Operator&gt;(expr[0]) };</code> <br>      ,   . <br> <br> ‚Ä¶ <s>          .</s> <i>              .</i> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); }</code> <br> ,     <code>C</code>   ,  <code>isdigit</code> , ,       <code>atof</code> ,    ,      <code>wchar_t</code> .  (expression ‚Üí function).         . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { const wchar_t *current = expr.c_str(); if(!*current) return{}; if(iswdigit(*current)) return{ _wtof(current) }; return{ static_cast&lt;Operator&gt;(*current) }; }</code> <br>         .      . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>   ,        .  ,     .     .   <code>result</code> ,     . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); if(!*current) return result; if(iswdigit(*current)) { result.push_back(_wtof(current)); } else { result.push_back(static_cast&lt;Operator&gt;(*current)); } return result; }</code> <br>      :   (if ‚Üí while).     ,        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } } return result; }</code> <br>  <code>wcstod</code>    ,   <code>_wtof</code> ,           .           ,              .  ,    . <br> <br> <s>           .</s>       . <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>  (unconditional ‚Üí if)    ,    . <br> <br> <code class="cpp"> while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else if(*current == static_cast&lt;wchar_t&gt;(Operator::Plus)) { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } else { ++current; } }</code> <br>       .          .       <code>Detail</code>      .   <code>Tokenize</code>       . <br> <br> <code class="cpp">inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); }</code> <br> <b class="spoiler_title"> Detail::Tokenizer</b> <code class="cpp">namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { return *m_current == static_cast&lt;wchar_t&gt;(Operator::Plus); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail</code> <br> <br>  ,      .      ,  , .       . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); }</code> <br>      <code>Operator</code> ,    . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', };</code> <br>   .         <code>IsOperator</code>  <code>Tokenizer</code> . <br> <br> <code class="cpp"> bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); }</code> <br>         .        . <br> <br> <b class="spoiler_title">Interpreter.h</b> <code class="cpp">#pragma once; #include &lt;vector&gt; #include &lt;wchar.h&gt; #include &lt;algorithm&gt; namespace Interpreter { enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', }; inline std::wstring ToString(const Operator &amp;op) { return{ static_cast&lt;wchar_t&gt;(op) }; } enum class TokenType { Operator, Number }; inline std::wstring ToString(const TokenType &amp;type) { switch(type) { case TokenType::Operator: return L"Operator"; case TokenType::Number: return L"Number"; default: throw std::out_of_range("TokenType"); } } class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } friend inline bool operator==(const Token &amp;left, const Token &amp;right) { if(left.m_type == right.m_type) { switch(left.m_type) { case Interpreter::TokenType::Operator: return left.m_operator == right.m_operator; case Interpreter::TokenType::Number: return left.m_number == right.m_number; default: throw std::out_of_range("TokenType"); } } return false; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: throw std::out_of_range("TokenType"); } } typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); } } // namespace Lexer } // namespace Interpreter</code> <br> <br> <b class="spoiler_title">InterpreterTests.cpp</b> <code class="cpp">#include "stdafx.h" #include "CppUnitTest.h" #include "Interpreter.h" namespace InterpreterTests { using namespace Microsoft::VisualStudio::CppUnitTestFramework; using namespace Interpreter; using namespace std; namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual&lt;T&gt;(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange TEST_CLASS(LexerTests) { public: TEST_METHOD(Should_return_empty_token_list_when_put_empty_expression) { Tokens tokens = Lexer::Tokenize(L""); Assert::IsTrue(tokens.empty()); } TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); } TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); } TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); } TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); } }; TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); } TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); } TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); } }; }</code> <br> <br> <a href="https://github.com/Unril/InterpreterTDD/releases/tag/%25D0%259A%25D0%25BE%25D0%25BD%25D0%25B5%25D1%2586_%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B2%25D0%25BE%25D0%25B9_%25D1%2587%25D0%25B0%25D1%2581%25D1%2582%25D0%25B8">    GitHub</a> .         ,  .      "__". <br> <br>   <a href="http://habrahabr.ru/post/232081/">    </a> .      ,      <a href="http://habrahabr.ru/post/232097/">    </a> .</code> </li> <li> <code><code>std::vector,      Tokens</code> .            . <br> <br> <code class="cpp">#pragma once; #include &lt;vector&gt; namespace Interpreter { struct Token {}; typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { inline Tokens Tokenize(std::string expr) { throw std::exception(); } } // namespace Lexer } // namespace Interpreter</code> <br>   ,  ,   , .   ,    ,    <a href="http://cleancoder.posterous.com/the-transformation-priority-premise">The Transformation Priority Premise (TPP)</a>   .    , ,    ,     ,        .            .     ,     ,      ,           .  ,  ,   (   )    ,  ,  .     ,  ,         .     ,   TPP          . <br> <br>   : <br> <br> ({} ‚Üí nil)     ,   . (nil ‚Üí constant)    . (constant ‚Üí constant+)      (        ,  ). (constant ‚Üí scalar)    ,  . (statement ‚Üí statements)    (break, continue, return  ). (unconditional ‚Üí if)       . (scalar ‚Üí array)  / . (array ‚Üí container)     . (statement ‚Üí recursion)   . (if ‚Üí while)    . (expression ‚Üí function)   . (variable ‚Üí assignment)   . <br>        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::string expr) { return{}; }</code> <br> ,         .     . <br> <br> <s>         </s> .           .           .               .            .       . <br>  ,  <code>std::string</code>  <code>std::wstring</code> .         ,      Unicode.     . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); }</code> <br>  <code>AssertRange</code> -   ,       <code>AreEqual</code> ,   ,  ,    . <br> <br> <b class="spoiler_title">AssertRange</b> <code class="cpp">namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange</code> <br> <br>         <code>Operator</code>    .          <code>wchar_t</code>   ,         ,      . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', }; typedef Operator Token;</code> <br>    ,   ,        <code>Assert</code> ,    <code>ToString</code> ,    . <br> <br> <b class="spoiler_title">std::wstring ToString(const Token &amp;)</b> <code class="cpp">inline std::wstring ToString(const Token &amp;token) { return{ static_cast&lt;wchar_t&gt;(token) }; }</code> <br> <br>    ,   ,        .  ,   (unconditional ‚Üí if). <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { if(expr.empty()) { return{}; } return{ static_cast&lt;Operator&gt;(expr[0]) }; }</code> <br> <s>         </s> . <s>          .</s>           . ‚Ä¶ <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); }</code> <br>     .   ,     ,   - .    , : <br> <br>        ,      <code>Token</code> .       <code>dynamic_cast</code>    ,   .  ,    ,      .      <code>std::function</code>        .        .  Boost.Any,  - .            . <br>   ,   .      -  .  ,      ,      . <br> <br> ‚Ä¶        .        .        .        . <br>             . <br> <br> <code class="cpp">enum class TokenType { Operator, Number }; class Token { public: Token(Operator) {} TokenType Type() const { return TokenType::Operator; } }; ‚Ä¶ TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } };</code> <br>   <code>ToString</code>   <code>TokenType</code>       ,   ,   .     . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); }</code> <br>   .   (constant ‚Üí scalar)   . <br> <br> <code class="cpp">class Token { public: Token(Operator) :m_type(TokenType::Operator) {} Token(double) :m_type(TokenType::Number) {} TokenType Type() const { return m_type; } private: TokenType m_type; };</code> <br> ‚Ä¶ <s>       </s> . <s>       </s> .        .        . <br>    . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); }</code> <br>            . <br> <br> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} operator Operator() const { return m_operator; } ‚Ä¶ Operator m_operator; };</code> <br>      . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); }</code> <br>          ,  ,       <code>union</code> .         . <br> <br> <b class="spoiler_title">Token</b> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: return "Unknown token."; } }</code> <br> <br>  ,    ,      ,    .       .    . <br> <br> <i>          .</i>               .            .       . <br>        : <br> <br> <code class="cpp"> if(expr[0] &gt;= '0' &amp;&amp; expr[0] &lt;= '9') { return{ (double) expr[0] - '0' }; } return{ static_cast&lt;Operator&gt;(expr[0]) };</code> <br>      ,   . <br> <br> ‚Ä¶ <s>          .</s> <i>              .</i> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); }</code> <br> ,     <code>C</code>   ,  <code>isdigit</code> , ,       <code>atof</code> ,    ,      <code>wchar_t</code> .  (expression ‚Üí function).         . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { const wchar_t *current = expr.c_str(); if(!*current) return{}; if(iswdigit(*current)) return{ _wtof(current) }; return{ static_cast&lt;Operator&gt;(*current) }; }</code> <br>         .      . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>   ,        .  ,     .     .   <code>result</code> ,     . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); if(!*current) return result; if(iswdigit(*current)) { result.push_back(_wtof(current)); } else { result.push_back(static_cast&lt;Operator&gt;(*current)); } return result; }</code> <br>      :   (if ‚Üí while).     ,        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } } return result; }</code> <br>  <code>wcstod</code>    ,   <code>_wtof</code> ,           .           ,              .  ,    . <br> <br> <s>           .</s>       . <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>  (unconditional ‚Üí if)    ,    . <br> <br> <code class="cpp"> while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else if(*current == static_cast&lt;wchar_t&gt;(Operator::Plus)) { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } else { ++current; } }</code> <br>       .          .       <code>Detail</code>      .   <code>Tokenize</code>       . <br> <br> <code class="cpp">inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); }</code> <br> <b class="spoiler_title"> Detail::Tokenizer</b> <code class="cpp">namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { return *m_current == static_cast&lt;wchar_t&gt;(Operator::Plus); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail</code> <br> <br>  ,      .      ,  , .       . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); }</code> <br>      <code>Operator</code> ,    . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', };</code> <br>   .         <code>IsOperator</code>  <code>Tokenizer</code> . <br> <br> <code class="cpp"> bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); }</code> <br>         .        . <br> <br> <b class="spoiler_title">Interpreter.h</b> <code class="cpp">#pragma once; #include &lt;vector&gt; #include &lt;wchar.h&gt; #include &lt;algorithm&gt; namespace Interpreter { enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', }; inline std::wstring ToString(const Operator &amp;op) { return{ static_cast&lt;wchar_t&gt;(op) }; } enum class TokenType { Operator, Number }; inline std::wstring ToString(const TokenType &amp;type) { switch(type) { case TokenType::Operator: return L"Operator"; case TokenType::Number: return L"Number"; default: throw std::out_of_range("TokenType"); } } class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } friend inline bool operator==(const Token &amp;left, const Token &amp;right) { if(left.m_type == right.m_type) { switch(left.m_type) { case Interpreter::TokenType::Operator: return left.m_operator == right.m_operator; case Interpreter::TokenType::Number: return left.m_number == right.m_number; default: throw std::out_of_range("TokenType"); } } return false; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: throw std::out_of_range("TokenType"); } } typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); } } // namespace Lexer } // namespace Interpreter</code> <br> <br> <b class="spoiler_title">InterpreterTests.cpp</b> <code class="cpp">#include "stdafx.h" #include "CppUnitTest.h" #include "Interpreter.h" namespace InterpreterTests { using namespace Microsoft::VisualStudio::CppUnitTestFramework; using namespace Interpreter; using namespace std; namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual&lt;T&gt;(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange TEST_CLASS(LexerTests) { public: TEST_METHOD(Should_return_empty_token_list_when_put_empty_expression) { Tokens tokens = Lexer::Tokenize(L""); Assert::IsTrue(tokens.empty()); } TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); } TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); } TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); } TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); } }; TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); } TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); } TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); } }; }</code> <br> <br> <a href="https://github.com/Unril/InterpreterTDD/releases/tag/%25D0%259A%25D0%25BE%25D0%25BD%25D0%25B5%25D1%2586_%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B2%25D0%25BE%25D0%25B9_%25D1%2587%25D0%25B0%25D1%2581%25D1%2582%25D0%25B8">    GitHub</a> .         ,  .      "__". <br> <br>   <a href="http://habrahabr.ru/post/232081/">    </a> .      ,      <a href="http://habrahabr.ru/post/232097/">    </a> .</code> </li> <li> <code><code>std::vector,      Tokens</code> .            . <br> <br> <code class="cpp">#pragma once; #include &lt;vector&gt; namespace Interpreter { struct Token {}; typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { inline Tokens Tokenize(std::string expr) { throw std::exception(); } } // namespace Lexer } // namespace Interpreter</code> <br>   ,  ,   , .   ,    ,    <a href="http://cleancoder.posterous.com/the-transformation-priority-premise">The Transformation Priority Premise (TPP)</a>   .    , ,    ,     ,        .            .     ,     ,      ,           .  ,  ,   (   )    ,  ,  .     ,  ,         .     ,   TPP          . <br> <br>   : <br> <br> ({} ‚Üí nil)     ,   . (nil ‚Üí constant)    . (constant ‚Üí constant+)      (        ,  ). (constant ‚Üí scalar)    ,  . (statement ‚Üí statements)    (break, continue, return  ). (unconditional ‚Üí if)       . (scalar ‚Üí array)  / . (array ‚Üí container)     . (statement ‚Üí recursion)   . (if ‚Üí while)    . (expression ‚Üí function)   . (variable ‚Üí assignment)   . <br>        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::string expr) { return{}; }</code> <br> ,         .     . <br> <br> <s>         </s> .           .           .               .            .       . <br>  ,  <code>std::string</code>  <code>std::wstring</code> .         ,      Unicode.     . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); }</code> <br>  <code>AssertRange</code> -   ,       <code>AreEqual</code> ,   ,  ,    . <br> <br> <b class="spoiler_title">AssertRange</b> <code class="cpp">namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange</code> <br> <br>         <code>Operator</code>    .          <code>wchar_t</code>   ,         ,      . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', }; typedef Operator Token;</code> <br>    ,   ,        <code>Assert</code> ,    <code>ToString</code> ,    . <br> <br> <b class="spoiler_title">std::wstring ToString(const Token &amp;)</b> <code class="cpp">inline std::wstring ToString(const Token &amp;token) { return{ static_cast&lt;wchar_t&gt;(token) }; }</code> <br> <br>    ,   ,        .  ,   (unconditional ‚Üí if). <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { if(expr.empty()) { return{}; } return{ static_cast&lt;Operator&gt;(expr[0]) }; }</code> <br> <s>         </s> . <s>          .</s>           . ‚Ä¶ <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); }</code> <br>     .   ,     ,   - .    , : <br> <br>        ,      <code>Token</code> .       <code>dynamic_cast</code>    ,   .  ,    ,      .      <code>std::function</code>        .        .  Boost.Any,  - .            . <br>   ,   .      -  .  ,      ,      . <br> <br> ‚Ä¶        .        .        .        . <br>             . <br> <br> <code class="cpp">enum class TokenType { Operator, Number }; class Token { public: Token(Operator) {} TokenType Type() const { return TokenType::Operator; } }; ‚Ä¶ TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } };</code> <br>   <code>ToString</code>   <code>TokenType</code>       ,   ,   .     . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); }</code> <br>   .   (constant ‚Üí scalar)   . <br> <br> <code class="cpp">class Token { public: Token(Operator) :m_type(TokenType::Operator) {} Token(double) :m_type(TokenType::Number) {} TokenType Type() const { return m_type; } private: TokenType m_type; };</code> <br> ‚Ä¶ <s>       </s> . <s>       </s> .        .        . <br>    . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); }</code> <br>            . <br> <br> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} operator Operator() const { return m_operator; } ‚Ä¶ Operator m_operator; };</code> <br>      . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); }</code> <br>          ,  ,       <code>union</code> .         . <br> <br> <b class="spoiler_title">Token</b> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: return "Unknown token."; } }</code> <br> <br>  ,    ,      ,    .       .    . <br> <br> <i>          .</i>               .            .       . <br>        : <br> <br> <code class="cpp"> if(expr[0] &gt;= '0' &amp;&amp; expr[0] &lt;= '9') { return{ (double) expr[0] - '0' }; } return{ static_cast&lt;Operator&gt;(expr[0]) };</code> <br>      ,   . <br> <br> ‚Ä¶ <s>          .</s> <i>              .</i> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); }</code> <br> ,     <code>C</code>   ,  <code>isdigit</code> , ,       <code>atof</code> ,    ,      <code>wchar_t</code> .  (expression ‚Üí function).         . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { const wchar_t *current = expr.c_str(); if(!*current) return{}; if(iswdigit(*current)) return{ _wtof(current) }; return{ static_cast&lt;Operator&gt;(*current) }; }</code> <br>         .      . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>   ,        .  ,     .     .   <code>result</code> ,     . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); if(!*current) return result; if(iswdigit(*current)) { result.push_back(_wtof(current)); } else { result.push_back(static_cast&lt;Operator&gt;(*current)); } return result; }</code> <br>      :   (if ‚Üí while).     ,        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } } return result; }</code> <br>  <code>wcstod</code>    ,   <code>_wtof</code> ,           .           ,              .  ,    . <br> <br> <s>           .</s>       . <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>  (unconditional ‚Üí if)    ,    . <br> <br> <code class="cpp"> while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else if(*current == static_cast&lt;wchar_t&gt;(Operator::Plus)) { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } else { ++current; } }</code> <br>       .          .       <code>Detail</code>      .   <code>Tokenize</code>       . <br> <br> <code class="cpp">inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); }</code> <br> <b class="spoiler_title"> Detail::Tokenizer</b> <code class="cpp">namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { return *m_current == static_cast&lt;wchar_t&gt;(Operator::Plus); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail</code> <br> <br>  ,      .      ,  , .       . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); }</code> <br>      <code>Operator</code> ,    . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', };</code> <br>   .         <code>IsOperator</code>  <code>Tokenizer</code> . <br> <br> <code class="cpp"> bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); }</code> <br>         .        . <br> <br> <b class="spoiler_title">Interpreter.h</b> <code class="cpp">#pragma once; #include &lt;vector&gt; #include &lt;wchar.h&gt; #include &lt;algorithm&gt; namespace Interpreter { enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', }; inline std::wstring ToString(const Operator &amp;op) { return{ static_cast&lt;wchar_t&gt;(op) }; } enum class TokenType { Operator, Number }; inline std::wstring ToString(const TokenType &amp;type) { switch(type) { case TokenType::Operator: return L"Operator"; case TokenType::Number: return L"Number"; default: throw std::out_of_range("TokenType"); } } class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } friend inline bool operator==(const Token &amp;left, const Token &amp;right) { if(left.m_type == right.m_type) { switch(left.m_type) { case Interpreter::TokenType::Operator: return left.m_operator == right.m_operator; case Interpreter::TokenType::Number: return left.m_number == right.m_number; default: throw std::out_of_range("TokenType"); } } return false; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: throw std::out_of_range("TokenType"); } } typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); } } // namespace Lexer } // namespace Interpreter</code> <br> <br> <b class="spoiler_title">InterpreterTests.cpp</b> <code class="cpp">#include "stdafx.h" #include "CppUnitTest.h" #include "Interpreter.h" namespace InterpreterTests { using namespace Microsoft::VisualStudio::CppUnitTestFramework; using namespace Interpreter; using namespace std; namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual&lt;T&gt;(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange TEST_CLASS(LexerTests) { public: TEST_METHOD(Should_return_empty_token_list_when_put_empty_expression) { Tokens tokens = Lexer::Tokenize(L""); Assert::IsTrue(tokens.empty()); } TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); } TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); } TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); } TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); } }; TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); } TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); } TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); } }; }</code> <br> <br> <a href="https://github.com/Unril/InterpreterTDD/releases/tag/%25D0%259A%25D0%25BE%25D0%25BD%25D0%25B5%25D1%2586_%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B2%25D0%25BE%25D0%25B9_%25D1%2587%25D0%25B0%25D1%2581%25D1%2582%25D0%25B8">    GitHub</a> .         ,  .      "__". <br> <br>   <a href="http://habrahabr.ru/post/232081/">    </a> .      ,      <a href="http://habrahabr.ru/post/232097/">    </a> .</code> </li> </ul> <code><code>std::vector,      Tokens</code> .            . <br> <br> <code class="cpp">#pragma once; #include &lt;vector&gt; namespace Interpreter { struct Token {}; typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { inline Tokens Tokenize(std::string expr) { throw std::exception(); } } // namespace Lexer } // namespace Interpreter</code> <br>   ,  ,   , .   ,    ,    <a href="http://cleancoder.posterous.com/the-transformation-priority-premise">The Transformation Priority Premise (TPP)</a>   .    , ,    ,     ,        .            .     ,     ,      ,           .  ,  ,   (   )    ,  ,  .     ,  ,         .     ,   TPP          . <br> <br>   : <br> <br> ({} ‚Üí nil)     ,   . (nil ‚Üí constant)    . (constant ‚Üí constant+)      (        ,  ). (constant ‚Üí scalar)    ,  . (statement ‚Üí statements)    (break, continue, return  ). (unconditional ‚Üí if)       . (scalar ‚Üí array)  / . (array ‚Üí container)     . (statement ‚Üí recursion)   . (if ‚Üí while)    . (expression ‚Üí function)   . (variable ‚Üí assignment)   . <br>        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::string expr) { return{}; }</code> <br> ,         .     . <br> <br> <s>         </s> .           .           .               .            .       . <br>  ,  <code>std::string</code>  <code>std::wstring</code> .         ,      Unicode.     . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); }</code> <br>  <code>AssertRange</code> -   ,       <code>AreEqual</code> ,   ,  ,    . <br> <br> <b class="spoiler_title">AssertRange</b> <code class="cpp">namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange</code> <br> <br>         <code>Operator</code>    .          <code>wchar_t</code>   ,         ,      . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', }; typedef Operator Token;</code> <br>    ,   ,        <code>Assert</code> ,    <code>ToString</code> ,    . <br> <br> <b class="spoiler_title">std::wstring ToString(const Token &amp;)</b> <code class="cpp">inline std::wstring ToString(const Token &amp;token) { return{ static_cast&lt;wchar_t&gt;(token) }; }</code> <br> <br>    ,   ,        .  ,   (unconditional ‚Üí if). <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { if(expr.empty()) { return{}; } return{ static_cast&lt;Operator&gt;(expr[0]) }; }</code> <br> <s>         </s> . <s>          .</s>           . ‚Ä¶ <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); }</code> <br>     .   ,     ,   - .    , : <br> <br>        ,      <code>Token</code> .       <code>dynamic_cast</code>    ,   .  ,    ,      .      <code>std::function</code>        .        .  Boost.Any,  - .            . <br>   ,   .      -  .  ,      ,      . <br> <br> ‚Ä¶        .        .        .        . <br>             . <br> <br> <code class="cpp">enum class TokenType { Operator, Number }; class Token { public: Token(Operator) {} TokenType Type() const { return TokenType::Operator; } }; ‚Ä¶ TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } };</code> <br>   <code>ToString</code>   <code>TokenType</code>       ,   ,   .     . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); }</code> <br>   .   (constant ‚Üí scalar)   . <br> <br> <code class="cpp">class Token { public: Token(Operator) :m_type(TokenType::Operator) {} Token(double) :m_type(TokenType::Number) {} TokenType Type() const { return m_type; } private: TokenType m_type; };</code> <br> ‚Ä¶ <s>       </s> . <s>       </s> .        .        . <br>    . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); }</code> <br>            . <br> <br> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} operator Operator() const { return m_operator; } ‚Ä¶ Operator m_operator; };</code> <br>      . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); }</code> <br>          ,  ,       <code>union</code> .         . <br> <br> <b class="spoiler_title">Token</b> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: return "Unknown token."; } }</code> <br> <br>  ,    ,      ,    .       .    . <br> <br> <i>          .</i>               .            .       . <br>        : <br> <br> <code class="cpp"> if(expr[0] &gt;= '0' &amp;&amp; expr[0] &lt;= '9') { return{ (double) expr[0] - '0' }; } return{ static_cast&lt;Operator&gt;(expr[0]) };</code> <br>      ,   . <br> <br> ‚Ä¶ <s>          .</s> <i>              .</i> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); }</code> <br> ,     <code>C</code>   ,  <code>isdigit</code> , ,       <code>atof</code> ,    ,      <code>wchar_t</code> .  (expression ‚Üí function).         . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { const wchar_t *current = expr.c_str(); if(!*current) return{}; if(iswdigit(*current)) return{ _wtof(current) }; return{ static_cast&lt;Operator&gt;(*current) }; }</code> <br>         .      . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>   ,        .  ,     .     .   <code>result</code> ,     . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); if(!*current) return result; if(iswdigit(*current)) { result.push_back(_wtof(current)); } else { result.push_back(static_cast&lt;Operator&gt;(*current)); } return result; }</code> <br>      :   (if ‚Üí while).     ,        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } } return result; }</code> <br>  <code>wcstod</code>    ,   <code>_wtof</code> ,           .           ,              .  ,    . <br> <br> <s>           .</s>       . <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>  (unconditional ‚Üí if)    ,    . <br> <br> <code class="cpp"> while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else if(*current == static_cast&lt;wchar_t&gt;(Operator::Plus)) { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } else { ++current; } }</code> <br>       .          .       <code>Detail</code>      .   <code>Tokenize</code>       . <br> <br> <code class="cpp">inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); }</code> <br> <b class="spoiler_title"> Detail::Tokenizer</b> <code class="cpp">namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { return *m_current == static_cast&lt;wchar_t&gt;(Operator::Plus); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail</code> <br> <br>  ,      .      ,  , .       . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); }</code> <br>      <code>Operator</code> ,    . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', };</code> <br>   .         <code>IsOperator</code>  <code>Tokenizer</code> . <br> <br> <code class="cpp"> bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); }</code> <br>         .        . <br> <br> <b class="spoiler_title">Interpreter.h</b> <code class="cpp">#pragma once; #include &lt;vector&gt; #include &lt;wchar.h&gt; #include &lt;algorithm&gt; namespace Interpreter { enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', }; inline std::wstring ToString(const Operator &amp;op) { return{ static_cast&lt;wchar_t&gt;(op) }; } enum class TokenType { Operator, Number }; inline std::wstring ToString(const TokenType &amp;type) { switch(type) { case TokenType::Operator: return L"Operator"; case TokenType::Number: return L"Number"; default: throw std::out_of_range("TokenType"); } } class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } friend inline bool operator==(const Token &amp;left, const Token &amp;right) { if(left.m_type == right.m_type) { switch(left.m_type) { case Interpreter::TokenType::Operator: return left.m_operator == right.m_operator; case Interpreter::TokenType::Number: return left.m_number == right.m_number; default: throw std::out_of_range("TokenType"); } } return false; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: throw std::out_of_range("TokenType"); } } typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); } } // namespace Lexer } // namespace Interpreter</code> <br> <br> <b class="spoiler_title">InterpreterTests.cpp</b> <code class="cpp">#include "stdafx.h" #include "CppUnitTest.h" #include "Interpreter.h" namespace InterpreterTests { using namespace Microsoft::VisualStudio::CppUnitTestFramework; using namespace Interpreter; using namespace std; namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual&lt;T&gt;(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange TEST_CLASS(LexerTests) { public: TEST_METHOD(Should_return_empty_token_list_when_put_empty_expression) { Tokens tokens = Lexer::Tokenize(L""); Assert::IsTrue(tokens.empty()); } TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); } TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); } TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); } TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); } }; TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); } TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); } TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); } }; }</code> <br> <br> <a href="https://github.com/Unril/InterpreterTDD/releases/tag/%25D0%259A%25D0%25BE%25D0%25BD%25D0%25B5%25D1%2586_%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B2%25D0%25BE%25D0%25B9_%25D1%2587%25D0%25B0%25D1%2581%25D1%2582%25D0%25B8">    GitHub</a> .         ,  .      "__". <br> <br>   <a href="http://habrahabr.ru/post/232081/">    </a> .      ,      <a href="http://habrahabr.ru/post/232097/">    </a> .</code> <pre> <code class="hljs lua"><code>std::vector,      Tokens</code> .            . <br> <br> <code class="cpp">#pragma once; #include &lt;vector&gt; namespace Interpreter { struct Token {}; typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { inline Tokens Tokenize(std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> expr) { throw std::exception(); } } // namespace Lexer } // namespace Interpreter</code> <br>   ,  ,   , .   ,    ,    <a href="http://cleancoder.posterous.com/the-transformation-priority-premise">The Transformation Priority Premise (TPP)</a>   .    , ,    ,     ,        .            .     ,     ,      ,           .  ,  ,   (   )    ,  ,  .     ,  ,         .     ,   TPP          . <br> <br>   : <br> <br> ({} ‚Üí <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)     ,   . (<span class="hljs-literal"><span class="hljs-literal">nil</span></span> ‚Üí constant)    . (constant ‚Üí constant+)      (        ,  ). (constant ‚Üí scalar)    ,  . (statement ‚Üí statements)    (<span class="hljs-keyword"><span class="hljs-keyword">break</span></span>, continue, <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>  ). (unconditional ‚Üí <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>)       . (scalar ‚Üí array)  / . (array ‚Üí container)     . (statement ‚Üí recursion)   . (<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ‚Üí <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>)    . (expression ‚Üí <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">)</span></span>   . (variable ‚Üí assignment)   . <br>        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> expr) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{}; }</code> <br> ,         .     . <br> <br> <s>         </s> .           .           .               .            .       . <br>  ,  <code>std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span></code>  <code>std::wstring</code> .         ,      Unicode.     . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"+"</span></span>); AssertRange::AreEqual({ Operator::Plus }, tokens); }</code> <br>  <code>AssertRange</code> -   ,       <code>AreEqual</code> ,   ,  ,    . <br> <br> <b class="spoiler_title">AssertRange</b> <code class="cpp">namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(expect)), distance(actualIter, <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(actual)), L<span class="hljs-string"><span class="hljs-string">"Size differs."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(; expectIter != <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(expect) &amp;&amp; actualIter != <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(actual); ++expectIter, ++actualIter) { auto message = L<span class="hljs-string"><span class="hljs-string">"Mismatch in position "</span></span> + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange</code> <br> <br>         <code>Operator</code>    .          <code>wchar_t</code>   ,         ,      . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L<span class="hljs-string"><span class="hljs-string">'+'</span></span>, }; typedef Operator Token;</code> <br>    ,   ,        <code>Assert</code> ,    <code>ToString</code> ,    . <br> <br> <b class="spoiler_title">std::wstring ToString(const Token &amp;)</b> <code class="cpp">inline std::wstring ToString(const Token &amp;token) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ static_cast&lt;wchar_t&gt;(token) }; }</code> <br> <br>    ,   ,        .  ,   (unconditional ‚Üí <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>). <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(expr.empty()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{}; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ static_cast&lt;Operator&gt;(expr[<span class="hljs-number"><span class="hljs-number">0</span></span>]) }; }</code> <br> <s>         </s> . <s>          .</s>           . ‚Ä¶ <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"1"</span></span>); AssertRange::AreEqual({ <span class="hljs-number"><span class="hljs-number">1.0</span></span> }, tokens); }</code> <br>     .   ,     ,   - .    , : <br> <br>        ,      <code>Token</code> .       <code>dynamic_cast</code>    ,   .  ,    ,      .      <code>std::<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span></span></code><span class="hljs-function"><span class="hljs-function">        .        .  </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Boost.Any</span></span></span><span class="hljs-function">,  - .            . </span></span><br><span class="hljs-function"><span class="hljs-function">   ,   .      -  .  ,      ,      . </span></span><br><span class="hljs-function"><span class="hljs-function"> </span></span><br><span class="hljs-function"><span class="hljs-function"> ‚Ä¶        .        .        .        . </span></span><br><span class="hljs-function"><span class="hljs-function">             . </span></span><br><span class="hljs-function"><span class="hljs-function"> </span></span><br><span class="hljs-function"><span class="hljs-function"> </span></span><code class="cpp"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">enum</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">class</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TokenType</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Operator</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Number</span></span></span><span class="hljs-function"> }; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">class</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Token</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">public</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Token</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Operator)</span></span></span></span> {} TokenType Type() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TokenType::Operator; } }; ‚Ä¶ TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } };</code> <br>   <code>ToString</code>   <code>TokenType</code>       ,   ,   .     . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_type_for_number_token) { Token numToken(<span class="hljs-number"><span class="hljs-number">1.2</span></span>); Assert::AreEqual(TokenType::Number, numToken.Type()); }</code> <br>   .   (constant ‚Üí scalar)   . <br> <br> <code class="cpp">class Token { public: Token(Operator) :m_type(TokenType::Operator) {} Token(double) :m_type(TokenType::Number) {} TokenType Type() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_type; } private: TokenType m_type; };</code> <br> ‚Ä¶ <s>       </s> . <s>       </s> .        .        . <br>    . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); }</code> <br>            . <br> <br> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} operator Operator() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_operator; } ‚Ä¶ Operator m_operator; };</code> <br>      . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_number_value_from_number_token) { Token token(<span class="hljs-number"><span class="hljs-number">1.23</span></span>); Assert::AreEqual&lt;double&gt;(<span class="hljs-number"><span class="hljs-number">1.23</span></span>, token); }</code> <br>          ,  ,       <code>union</code> .         . <br> <br> <b class="spoiler_title">Token</b> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_type; } operator Operator() const { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(m_type != TokenType::Operator) throw std::logic_error(<span class="hljs-string"><span class="hljs-string">"Should be operator token."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_operator; } operator double() const { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(m_type != TokenType::Number) throw std::logic_error(<span class="hljs-string"><span class="hljs-string">"Should be number token."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_number; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ToString(static_cast&lt;Operator&gt;(token)); default: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Unknown token."</span></span>; } }</code> <br> <br>  ,    ,      ,    .       .    . <br> <br> <i>          .</i>               .            .       . <br>        : <br> <br> <code class="cpp"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(expr[<span class="hljs-number"><span class="hljs-number">0</span></span>] &gt;= <span class="hljs-string"><span class="hljs-string">'0'</span></span> &amp;&amp; expr[<span class="hljs-number"><span class="hljs-number">0</span></span>] &lt;= <span class="hljs-string"><span class="hljs-string">'9'</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ (double) expr[<span class="hljs-number"><span class="hljs-number">0</span></span>] - <span class="hljs-string"><span class="hljs-string">'0'</span></span> }; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ static_cast&lt;Operator&gt;(expr[<span class="hljs-number"><span class="hljs-number">0</span></span>]) };</code> <br>      ,   . <br> <br> ‚Ä¶ <s>          .</s> <i>              .</i> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"12.34"</span></span>); AssertRange::AreEqual({ <span class="hljs-number"><span class="hljs-number">12.34</span></span> }, tokens); }</code> <br> ,     <code>C</code>   ,  <code>isdigit</code> , ,       <code>atof</code> ,    ,      <code>wchar_t</code> .  (expression ‚Üí <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">)</span></span>.         . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { const wchar_t *current = expr.c_str(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!*current) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{}; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(iswdigit(*current)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ _wtof(current) }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ static_cast&lt;Operator&gt;(*current) }; }</code> <br>         .      . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"+12.34"</span></span>); AssertRange::AreEqual({ Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">12.34</span></span>) }, tokens); }</code> <br>   ,        .  ,     .     .   <code>result</code> ,     . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!*current) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(iswdigit(*current)) { result.push_back(_wtof(current)); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { result.push_back(static_cast&lt;Operator&gt;(*current)); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> <br>      :   (<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ‚Üí <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>).     ,        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(*current) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(iswdigit(*current)) { wchar_t *<span class="hljs-keyword"><span class="hljs-keyword">end</span></span> = nullptr; result.push_back(wcstod(current, &amp;<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>)); current = <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> <br>  <code>wcstod</code>    ,   <code>_wtof</code> ,           .           ,              .  ,    . <br> <br> <s>           .</s>       . <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">" 1 + 12.34 "</span></span>); AssertRange::AreEqual({ Token(<span class="hljs-number"><span class="hljs-number">1.0</span></span>), Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">12.34</span></span>) }, tokens); }</code> <br>  (unconditional ‚Üí <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>)    ,    . <br> <br> <code class="cpp"> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(*current) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(iswdigit(*current)) { wchar_t *<span class="hljs-keyword"><span class="hljs-keyword">end</span></span> = nullptr; result.push_back(wcstod(current, &amp;<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>)); current = <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(*current == static_cast&lt;wchar_t&gt;(Operator::Plus)) { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { ++current; } }</code> <br>       .          .       <code>Detail</code>      .   <code>Tokenize</code>       . <br> <br> <code class="cpp">inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tokenizer.Result(); }</code> <br> <b class="spoiler_title"> Detail::Tokenizer</b> <code class="cpp">namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!EndOfExperssion()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(IsNumber()) { ScanNumber(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(IsOperator()) { ScanOperator(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { MoveNext(); } } } const Tokens &amp;Result() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_result; } private: bool EndOfExperssion() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_current == L<span class="hljs-string"><span class="hljs-string">'\0'</span></span>; } bool IsNumber() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> iswdigit(*m_current) != <span class="hljs-number"><span class="hljs-number">0</span></span>; } void ScanNumber() { wchar_t *<span class="hljs-keyword"><span class="hljs-keyword">end</span></span> = nullptr; m_result.push_back(wcstod(m_current, &amp;<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>)); m_current = <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; } bool IsOperator() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_current == static_cast&lt;wchar_t&gt;(Operator::Plus); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail</code> <br> <br>  ,      .      ,  , .       . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"1+2*3/(4-5)"</span></span>); AssertRange::AreEqual({ Token(<span class="hljs-number"><span class="hljs-number">1</span></span>), Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">2</span></span>), Token(Operator::Mul), Token(<span class="hljs-number"><span class="hljs-number">3</span></span>), Token(Operator::Div), Token(Operator::LParen), Token(<span class="hljs-number"><span class="hljs-number">4</span></span>), Token(Operator::Minus), Token(<span class="hljs-number"><span class="hljs-number">5</span></span>), Token(Operator::RParen) }, tokens); }</code> <br>      <code>Operator</code> ,    . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L<span class="hljs-string"><span class="hljs-string">'+'</span></span>, Minus = L<span class="hljs-string"><span class="hljs-string">'-'</span></span>, Mul = L<span class="hljs-string"><span class="hljs-string">'*'</span></span>, Div = L<span class="hljs-string"><span class="hljs-string">'/'</span></span>, LParen = L<span class="hljs-string"><span class="hljs-string">'('</span></span>, RParen = L<span class="hljs-string"><span class="hljs-string">')'</span></span>, };</code> <br>   .         <code>IsOperator</code>  <code>Tokenizer</code> . <br> <br> <code class="cpp"> bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> std::any_of(all.begin(), all.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(), [this](Operator o) {<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_current == static_cast&lt;wchar_t&gt;(o); }); }</code> <br>         .        . <br> <br> <b class="spoiler_title">Interpreter.h</b> <code class="cpp">#pragma once; #include &lt;vector&gt; #include &lt;wchar.h&gt; #include &lt;algorithm&gt; namespace Interpreter { enum class Operator : wchar_t { Plus = L<span class="hljs-string"><span class="hljs-string">'+'</span></span>, Minus = L<span class="hljs-string"><span class="hljs-string">'-'</span></span>, Mul = L<span class="hljs-string"><span class="hljs-string">'*'</span></span>, Div = L<span class="hljs-string"><span class="hljs-string">'/'</span></span>, LParen = L<span class="hljs-string"><span class="hljs-string">'('</span></span>, RParen = L<span class="hljs-string"><span class="hljs-string">')'</span></span>, }; inline std::wstring ToString(const Operator &amp;op) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ static_cast&lt;wchar_t&gt;(op) }; } enum class TokenType { Operator, Number }; inline std::wstring ToString(const TokenType &amp;<span class="hljs-built_in"><span class="hljs-built_in">type</span></span>) { switch(<span class="hljs-built_in"><span class="hljs-built_in">type</span></span>) { case TokenType::Operator: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> L<span class="hljs-string"><span class="hljs-string">"Operator"</span></span>; case TokenType::Number: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> L<span class="hljs-string"><span class="hljs-string">"Number"</span></span>; default: throw std::out_of_range(<span class="hljs-string"><span class="hljs-string">"TokenType"</span></span>); } } class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_type; } operator Operator() const { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(m_type != TokenType::Operator) throw std::logic_error(<span class="hljs-string"><span class="hljs-string">"Should be operator token."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_operator; } operator double() const { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(m_type != TokenType::Number) throw std::logic_error(<span class="hljs-string"><span class="hljs-string">"Should be number token."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_number; } friend inline bool operator==(const Token &amp;left, const Token &amp;right) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(left.m_type == right.m_type) { switch(left.m_type) { case Interpreter::TokenType::Operator: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> left.m_operator == right.m_operator; case Interpreter::TokenType::Number: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> left.m_number == right.m_number; default: throw std::out_of_range(<span class="hljs-string"><span class="hljs-string">"TokenType"</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ToString(static_cast&lt;Operator&gt;(token)); default: throw std::out_of_range(<span class="hljs-string"><span class="hljs-string">"TokenType"</span></span>); } } typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!EndOfExperssion()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(IsNumber()) { ScanNumber(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(IsOperator()) { ScanOperator(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { MoveNext(); } } } const Tokens &amp;Result() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_result; } private: bool EndOfExperssion() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_current == L<span class="hljs-string"><span class="hljs-string">'\0'</span></span>; } bool IsNumber() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> iswdigit(*m_current) != <span class="hljs-number"><span class="hljs-number">0</span></span>; } void ScanNumber() { wchar_t *<span class="hljs-keyword"><span class="hljs-keyword">end</span></span> = nullptr; m_result.push_back(wcstod(m_current, &amp;<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>)); m_current = <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; } bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> std::any_of(all.begin(), all.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(), [this](Operator o) {<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_current == static_cast&lt;wchar_t&gt;(o); }); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tokenizer.Result(); } } // namespace Lexer } // namespace Interpreter</code> <br> <br> <b class="spoiler_title">InterpreterTests.cpp</b> <code class="cpp">#include <span class="hljs-string"><span class="hljs-string">"stdafx.h"</span></span> #include <span class="hljs-string"><span class="hljs-string">"CppUnitTest.h"</span></span> #include <span class="hljs-string"><span class="hljs-string">"Interpreter.h"</span></span> namespace InterpreterTests { using namespace Microsoft::VisualStudio::CppUnitTestFramework; using namespace Interpreter; using namespace std; namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(expect)), distance(actualIter, <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(actual)), L<span class="hljs-string"><span class="hljs-string">"Size differs."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(; expectIter != <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(expect) &amp;&amp; actualIter != <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(actual); ++expectIter, ++actualIter) { auto message = L<span class="hljs-string"><span class="hljs-string">"Mismatch in position "</span></span> + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual&lt;T&gt;(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange TEST_CLASS(LexerTests) { public: TEST_METHOD(Should_return_empty_token_list_when_put_empty_expression) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">""</span></span>); Assert::IsTrue(tokens.empty()); } TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"+"</span></span>); AssertRange::AreEqual({ Operator::Plus }, tokens); } TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"1"</span></span>); AssertRange::AreEqual({ <span class="hljs-number"><span class="hljs-number">1.0</span></span> }, tokens); } TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"12.34"</span></span>); AssertRange::AreEqual({ <span class="hljs-number"><span class="hljs-number">12.34</span></span> }, tokens); } TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"+12.34"</span></span>); AssertRange::AreEqual({ Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">12.34</span></span>) }, tokens); } TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">" 1 + 12.34 "</span></span>); AssertRange::AreEqual({ Token(<span class="hljs-number"><span class="hljs-number">1.0</span></span>), Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">12.34</span></span>) }, tokens); } TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"1+2*3/(4-5)"</span></span>); AssertRange::AreEqual({ Token(<span class="hljs-number"><span class="hljs-number">1</span></span>), Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">2</span></span>), Token(Operator::Mul), Token(<span class="hljs-number"><span class="hljs-number">3</span></span>), Token(Operator::Div), Token(Operator::LParen), Token(<span class="hljs-number"><span class="hljs-number">4</span></span>), Token(Operator::Minus), Token(<span class="hljs-number"><span class="hljs-number">5</span></span>), Token(Operator::RParen) }, tokens); } }; TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } TEST_METHOD(Should_get_type_for_number_token) { Token numToken(<span class="hljs-number"><span class="hljs-number">1.2</span></span>); Assert::AreEqual(TokenType::Number, numToken.Type()); } TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); } TEST_METHOD(Should_get_number_value_from_number_token) { Token token(<span class="hljs-number"><span class="hljs-number">1.23</span></span>); Assert::AreEqual&lt;double&gt;(<span class="hljs-number"><span class="hljs-number">1.23</span></span>, token); } }; }</code> <br> <br> <a href="https://github.com/Unril/InterpreterTDD/releases/tag/%25D0%259A%25D0%25BE%25D0%25BD%25D0%25B5%25D1%2586_%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B2%25D0%25BE%25D0%25B9_%25D1%2587%25D0%25B0%25D1%2581%25D1%2582%25D0%25B8">    GitHub</a> .         ,  .      <span class="hljs-string"><span class="hljs-string">"__"</span></span>. <br> <br>   <a href="http://habrahabr.ru/post/232081/">    </a> .      ,      <a href="http://habrahabr.ru/post/232097/">    </a> .</code> </pre> <code><code>std::vector,      Tokens</code> .            . <br> <br> <code class="cpp">#pragma once; #include &lt;vector&gt; namespace Interpreter { struct Token {}; typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { inline Tokens Tokenize(std::string expr) { throw std::exception(); } } // namespace Lexer } // namespace Interpreter</code> <br>   ,  ,   , .   ,    ,    <a href="http://cleancoder.posterous.com/the-transformation-priority-premise">The Transformation Priority Premise (TPP)</a>   .    , ,    ,     ,        .            .     ,     ,      ,           .  ,  ,   (   )    ,  ,  .     ,  ,         .     ,   TPP          . <br> <br>   : <br> <br> ({} ‚Üí nil)     ,   . (nil ‚Üí constant)    . (constant ‚Üí constant+)      (        ,  ). (constant ‚Üí scalar)    ,  . (statement ‚Üí statements)    (break, continue, return  ). (unconditional ‚Üí if)       . (scalar ‚Üí array)  / . (array ‚Üí container)     . (statement ‚Üí recursion)   . (if ‚Üí while)    . (expression ‚Üí function)   . (variable ‚Üí assignment)   . <br>        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::string expr) { return{}; }</code> <br> ,         .     . <br> <br> <s>         </s> .           .           .               .            .       . <br>  ,  <code>std::string</code>  <code>std::wstring</code> .         ,      Unicode.     . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); }</code> <br>  <code>AssertRange</code> -   ,       <code>AreEqual</code> ,   ,  ,    . <br> <br> <b class="spoiler_title">AssertRange</b> <code class="cpp">namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange</code> <br> <br>         <code>Operator</code>    .          <code>wchar_t</code>   ,         ,      . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', }; typedef Operator Token;</code> <br>    ,   ,        <code>Assert</code> ,    <code>ToString</code> ,    . <br> <br> <b class="spoiler_title">std::wstring ToString(const Token &amp;)</b> <code class="cpp">inline std::wstring ToString(const Token &amp;token) { return{ static_cast&lt;wchar_t&gt;(token) }; }</code> <br> <br>    ,   ,        .  ,   (unconditional ‚Üí if). <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { if(expr.empty()) { return{}; } return{ static_cast&lt;Operator&gt;(expr[0]) }; }</code> <br> <s>         </s> . <s>          .</s>           . ‚Ä¶ <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); }</code> <br>     .   ,     ,   - .    , : <br> <br>        ,      <code>Token</code> .       <code>dynamic_cast</code>    ,   .  ,    ,      .      <code>std::function</code>        .        .  Boost.Any,  - .            . <br>   ,   .      -  .  ,      ,      . <br> <br> ‚Ä¶        .        .        .        . <br>             . <br> <br> <code class="cpp">enum class TokenType { Operator, Number }; class Token { public: Token(Operator) {} TokenType Type() const { return TokenType::Operator; } }; ‚Ä¶ TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } };</code> <br>   <code>ToString</code>   <code>TokenType</code>       ,   ,   .     . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); }</code> <br>   .   (constant ‚Üí scalar)   . <br> <br> <code class="cpp">class Token { public: Token(Operator) :m_type(TokenType::Operator) {} Token(double) :m_type(TokenType::Number) {} TokenType Type() const { return m_type; } private: TokenType m_type; };</code> <br> ‚Ä¶ <s>       </s> . <s>       </s> .        .        . <br>    . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); }</code> <br>            . <br> <br> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} operator Operator() const { return m_operator; } ‚Ä¶ Operator m_operator; };</code> <br>      . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); }</code> <br>          ,  ,       <code>union</code> .         . <br> <br> <b class="spoiler_title">Token</b> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: return "Unknown token."; } }</code> <br> <br>  ,    ,      ,    .       .    . <br> <br> <i>          .</i>               .            .       . <br>        : <br> <br> <code class="cpp"> if(expr[0] &gt;= '0' &amp;&amp; expr[0] &lt;= '9') { return{ (double) expr[0] - '0' }; } return{ static_cast&lt;Operator&gt;(expr[0]) };</code> <br>      ,   . <br> <br> ‚Ä¶ <s>          .</s> <i>              .</i> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); }</code> <br> ,     <code>C</code>   ,  <code>isdigit</code> , ,       <code>atof</code> ,    ,      <code>wchar_t</code> .  (expression ‚Üí function).         . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { const wchar_t *current = expr.c_str(); if(!*current) return{}; if(iswdigit(*current)) return{ _wtof(current) }; return{ static_cast&lt;Operator&gt;(*current) }; }</code> <br>         .      . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>   ,        .  ,     .     .   <code>result</code> ,     . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); if(!*current) return result; if(iswdigit(*current)) { result.push_back(_wtof(current)); } else { result.push_back(static_cast&lt;Operator&gt;(*current)); } return result; }</code> <br>      :   (if ‚Üí while).     ,        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } } return result; }</code> <br>  <code>wcstod</code>    ,   <code>_wtof</code> ,           .           ,              .  ,    . <br> <br> <s>           .</s>       . <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>  (unconditional ‚Üí if)    ,    . <br> <br> <code class="cpp"> while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else if(*current == static_cast&lt;wchar_t&gt;(Operator::Plus)) { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } else { ++current; } }</code> <br>       .          .       <code>Detail</code>      .   <code>Tokenize</code>       . <br> <br> <code class="cpp">inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); }</code> <br> <b class="spoiler_title"> Detail::Tokenizer</b> <code class="cpp">namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { return *m_current == static_cast&lt;wchar_t&gt;(Operator::Plus); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail</code> <br> <br>  ,      .      ,  , .       . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); }</code> <br>      <code>Operator</code> ,    . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', };</code> <br>   .         <code>IsOperator</code>  <code>Tokenizer</code> . <br> <br> <code class="cpp"> bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); }</code> <br>         .        . <br> <br> <b class="spoiler_title">Interpreter.h</b> <code class="cpp">#pragma once; #include &lt;vector&gt; #include &lt;wchar.h&gt; #include &lt;algorithm&gt; namespace Interpreter { enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', }; inline std::wstring ToString(const Operator &amp;op) { return{ static_cast&lt;wchar_t&gt;(op) }; } enum class TokenType { Operator, Number }; inline std::wstring ToString(const TokenType &amp;type) { switch(type) { case TokenType::Operator: return L"Operator"; case TokenType::Number: return L"Number"; default: throw std::out_of_range("TokenType"); } } class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } friend inline bool operator==(const Token &amp;left, const Token &amp;right) { if(left.m_type == right.m_type) { switch(left.m_type) { case Interpreter::TokenType::Operator: return left.m_operator == right.m_operator; case Interpreter::TokenType::Number: return left.m_number == right.m_number; default: throw std::out_of_range("TokenType"); } } return false; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: throw std::out_of_range("TokenType"); } } typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); } } // namespace Lexer } // namespace Interpreter</code> <br> <br> <b class="spoiler_title">InterpreterTests.cpp</b> <code class="cpp">#include "stdafx.h" #include "CppUnitTest.h" #include "Interpreter.h" namespace InterpreterTests { using namespace Microsoft::VisualStudio::CppUnitTestFramework; using namespace Interpreter; using namespace std; namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual&lt;T&gt;(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange TEST_CLASS(LexerTests) { public: TEST_METHOD(Should_return_empty_token_list_when_put_empty_expression) { Tokens tokens = Lexer::Tokenize(L""); Assert::IsTrue(tokens.empty()); } TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); } TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); } TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); } TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); } }; TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); } TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); } TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); } }; }</code> <br> <br> <a href="https://github.com/Unril/InterpreterTDD/releases/tag/%25D0%259A%25D0%25BE%25D0%25BD%25D0%25B5%25D1%2586_%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B2%25D0%25BE%25D0%25B9_%25D1%2587%25D0%25B0%25D1%2581%25D1%2582%25D0%25B8">    GitHub</a> .         ,  .      "__". <br> <br>   <a href="http://habrahabr.ru/post/232081/">    </a> .      ,      <a href="http://habrahabr.ru/post/232097/">    </a> .</code> <div class="spoiler"> <code><b class="spoiler_title"><code>std::vector,      Tokens</code> .            . <br> <br> <code class="cpp">#pragma once; #include &lt;vector&gt; namespace Interpreter { struct Token {}; typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { inline Tokens Tokenize(std::string expr) { throw std::exception(); } } // namespace Lexer } // namespace Interpreter</code> <br>   ,  ,   , .   ,    ,    <a href="http://cleancoder.posterous.com/the-transformation-priority-premise">The Transformation Priority Premise (TPP)</a>   .    , ,    ,     ,        .            .     ,     ,      ,           .  ,  ,   (   )    ,  ,  .     ,  ,         .     ,   TPP          . <br> <br>   : <br> <br> ({} ‚Üí nil)     ,   . (nil ‚Üí constant)    . (constant ‚Üí constant+)      (        ,  ). (constant ‚Üí scalar)    ,  . (statement ‚Üí statements)    (break, continue, return  ). (unconditional ‚Üí if)       . (scalar ‚Üí array)  / . (array ‚Üí container)     . (statement ‚Üí recursion)   . (if ‚Üí while)    . (expression ‚Üí function)   . (variable ‚Üí assignment)   . <br>        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::string expr) { return{}; }</code> <br> ,         .     . <br> <br> <s>         </s> .           .           .               .            .       . <br>  ,  <code>std::string</code>  <code>std::wstring</code> .         ,      Unicode.     . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); }</code> <br>  <code>AssertRange</code> -   ,       <code>AreEqual</code> ,   ,  ,    . <br> <br> AssertRange <code class="cpp">namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange</code> <br> <br>         <code>Operator</code>    .          <code>wchar_t</code>   ,         ,      . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', }; typedef Operator Token;</code> <br>    ,   ,        <code>Assert</code> ,    <code>ToString</code> ,    . <br> <br> <b class="spoiler_title">std::wstring ToString(const Token &amp;)</b> <code class="cpp">inline std::wstring ToString(const Token &amp;token) { return{ static_cast&lt;wchar_t&gt;(token) }; }</code> <br> <br>    ,   ,        .  ,   (unconditional ‚Üí if). <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { if(expr.empty()) { return{}; } return{ static_cast&lt;Operator&gt;(expr[0]) }; }</code> <br> <s>         </s> . <s>          .</s>           . ‚Ä¶ <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); }</code> <br>     .   ,     ,   - .    , : <br> <br>        ,      <code>Token</code> .       <code>dynamic_cast</code>    ,   .  ,    ,      .      <code>std::function</code>        .        .  Boost.Any,  - .            . <br>   ,   .      -  .  ,      ,      . <br> <br> ‚Ä¶        .        .        .        . <br>             . <br> <br> <code class="cpp">enum class TokenType { Operator, Number }; class Token { public: Token(Operator) {} TokenType Type() const { return TokenType::Operator; } }; ‚Ä¶ TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } };</code> <br>   <code>ToString</code>   <code>TokenType</code>       ,   ,   .     . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); }</code> <br>   .   (constant ‚Üí scalar)   . <br> <br> <code class="cpp">class Token { public: Token(Operator) :m_type(TokenType::Operator) {} Token(double) :m_type(TokenType::Number) {} TokenType Type() const { return m_type; } private: TokenType m_type; };</code> <br> ‚Ä¶ <s>       </s> . <s>       </s> .        .        . <br>    . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); }</code> <br>            . <br> <br> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} operator Operator() const { return m_operator; } ‚Ä¶ Operator m_operator; };</code> <br>      . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); }</code> <br>          ,  ,       <code>union</code> .         . <br> <br> <b class="spoiler_title">Token</b> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: return "Unknown token."; } }</code> <br> <br>  ,    ,      ,    .       .    . <br> <br> <i>          .</i>               .            .       . <br>        : <br> <br> <code class="cpp"> if(expr[0] &gt;= '0' &amp;&amp; expr[0] &lt;= '9') { return{ (double) expr[0] - '0' }; } return{ static_cast&lt;Operator&gt;(expr[0]) };</code> <br>      ,   . <br> <br> ‚Ä¶ <s>          .</s> <i>              .</i> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); }</code> <br> ,     <code>C</code>   ,  <code>isdigit</code> , ,       <code>atof</code> ,    ,      <code>wchar_t</code> .  (expression ‚Üí function).         . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { const wchar_t *current = expr.c_str(); if(!*current) return{}; if(iswdigit(*current)) return{ _wtof(current) }; return{ static_cast&lt;Operator&gt;(*current) }; }</code> <br>         .      . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>   ,        .  ,     .     .   <code>result</code> ,     . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); if(!*current) return result; if(iswdigit(*current)) { result.push_back(_wtof(current)); } else { result.push_back(static_cast&lt;Operator&gt;(*current)); } return result; }</code> <br>      :   (if ‚Üí while).     ,        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } } return result; }</code> <br>  <code>wcstod</code>    ,   <code>_wtof</code> ,           .           ,              .  ,    . <br> <br> <s>           .</s>       . <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>  (unconditional ‚Üí if)    ,    . <br> <br> <code class="cpp"> while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else if(*current == static_cast&lt;wchar_t&gt;(Operator::Plus)) { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } else { ++current; } }</code> <br>       .          .       <code>Detail</code>      .   <code>Tokenize</code>       . <br> <br> <code class="cpp">inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); }</code> <br> <b class="spoiler_title"> Detail::Tokenizer</b> <code class="cpp">namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { return *m_current == static_cast&lt;wchar_t&gt;(Operator::Plus); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail</code> <br> <br>  ,      .      ,  , .       . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); }</code> <br>      <code>Operator</code> ,    . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', };</code> <br>   .         <code>IsOperator</code>  <code>Tokenizer</code> . <br> <br> <code class="cpp"> bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); }</code> <br>         .        . <br> <br> <b class="spoiler_title">Interpreter.h</b> <code class="cpp">#pragma once; #include &lt;vector&gt; #include &lt;wchar.h&gt; #include &lt;algorithm&gt; namespace Interpreter { enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', }; inline std::wstring ToString(const Operator &amp;op) { return{ static_cast&lt;wchar_t&gt;(op) }; } enum class TokenType { Operator, Number }; inline std::wstring ToString(const TokenType &amp;type) { switch(type) { case TokenType::Operator: return L"Operator"; case TokenType::Number: return L"Number"; default: throw std::out_of_range("TokenType"); } } class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } friend inline bool operator==(const Token &amp;left, const Token &amp;right) { if(left.m_type == right.m_type) { switch(left.m_type) { case Interpreter::TokenType::Operator: return left.m_operator == right.m_operator; case Interpreter::TokenType::Number: return left.m_number == right.m_number; default: throw std::out_of_range("TokenType"); } } return false; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: throw std::out_of_range("TokenType"); } } typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); } } // namespace Lexer } // namespace Interpreter</code> <br> <br> <b class="spoiler_title">InterpreterTests.cpp</b> <code class="cpp">#include "stdafx.h" #include "CppUnitTest.h" #include "Interpreter.h" namespace InterpreterTests { using namespace Microsoft::VisualStudio::CppUnitTestFramework; using namespace Interpreter; using namespace std; namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual&lt;T&gt;(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange TEST_CLASS(LexerTests) { public: TEST_METHOD(Should_return_empty_token_list_when_put_empty_expression) { Tokens tokens = Lexer::Tokenize(L""); Assert::IsTrue(tokens.empty()); } TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); } TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); } TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); } TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); } }; TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); } TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); } TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); } }; }</code> <br> <br> <a href="https://github.com/Unril/InterpreterTDD/releases/tag/%25D0%259A%25D0%25BE%25D0%25BD%25D0%25B5%25D1%2586_%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B2%25D0%25BE%25D0%25B9_%25D1%2587%25D0%25B0%25D1%2581%25D1%2582%25D0%25B8">    GitHub</a> .         ,  .      "__". <br> <br>   <a href="http://habrahabr.ru/post/232081/">    </a> .      ,      <a href="http://habrahabr.ru/post/232097/">    </a> .</b></code> <div class="spoiler_text"> <pre> <code class="hljs lua"><code>std::vector,      Tokens</code> .            . <br> <br> <code class="cpp">#pragma once; #include &lt;vector&gt; namespace Interpreter { struct Token {}; typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { inline Tokens Tokenize(std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> expr) { throw std::exception(); } } // namespace Lexer } // namespace Interpreter</code> <br>   ,  ,   , .   ,    ,    <a href="http://cleancoder.posterous.com/the-transformation-priority-premise">The Transformation Priority Premise (TPP)</a>   .    , ,    ,     ,        .            .     ,     ,      ,           .  ,  ,   (   )    ,  ,  .     ,  ,         .     ,   TPP          . <br> <br>   : <br> <br> ({} ‚Üí <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)     ,   . (<span class="hljs-literal"><span class="hljs-literal">nil</span></span> ‚Üí constant)    . (constant ‚Üí constant+)      (        ,  ). (constant ‚Üí scalar)    ,  . (statement ‚Üí statements)    (<span class="hljs-keyword"><span class="hljs-keyword">break</span></span>, continue, <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>  ). (unconditional ‚Üí <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>)       . (scalar ‚Üí array)  / . (array ‚Üí container)     . (statement ‚Üí recursion)   . (<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ‚Üí <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>)    . (expression ‚Üí <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">)</span></span>   . (variable ‚Üí assignment)   . <br>        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> expr) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{}; }</code> <br> ,         .     . <br> <br> <s>         </s> .           .           .               .            .       . <br>  ,  <code>std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span></code>  <code>std::wstring</code> .         ,      Unicode.     . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"+"</span></span>); AssertRange::AreEqual({ Operator::Plus }, tokens); }</code> <br>  <code>AssertRange</code> -   ,       <code>AreEqual</code> ,   ,  ,    . <br> <br> <b class="spoiler_title">AssertRange</b> <code class="cpp">namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(expect)), distance(actualIter, <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(actual)), L<span class="hljs-string"><span class="hljs-string">"Size differs."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(; expectIter != <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(expect) &amp;&amp; actualIter != <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(actual); ++expectIter, ++actualIter) { auto message = L<span class="hljs-string"><span class="hljs-string">"Mismatch in position "</span></span> + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange</code> <br> <br>         <code>Operator</code>    .          <code>wchar_t</code>   ,         ,      . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L<span class="hljs-string"><span class="hljs-string">'+'</span></span>, }; typedef Operator Token;</code> <br>    ,   ,        <code>Assert</code> ,    <code>ToString</code> ,    . <br> <br> <b class="spoiler_title">std::wstring ToString(const Token &amp;)</b> <code class="cpp">inline std::wstring ToString(const Token &amp;token) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ static_cast&lt;wchar_t&gt;(token) }; }</code> <br> <br>    ,   ,        .  ,   (unconditional ‚Üí <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>). <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(expr.empty()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{}; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ static_cast&lt;Operator&gt;(expr[<span class="hljs-number"><span class="hljs-number">0</span></span>]) }; }</code> <br> <s>         </s> . <s>          .</s>           . ‚Ä¶ <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"1"</span></span>); AssertRange::AreEqual({ <span class="hljs-number"><span class="hljs-number">1.0</span></span> }, tokens); }</code> <br>     .   ,     ,   - .    , : <br> <br>        ,      <code>Token</code> .       <code>dynamic_cast</code>    ,   .  ,    ,      .      <code>std::<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span></span></code><span class="hljs-function"><span class="hljs-function">        .        .  </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Boost.Any</span></span></span><span class="hljs-function">,  - .            . </span></span><br><span class="hljs-function"><span class="hljs-function">   ,   .      -  .  ,      ,      . </span></span><br><span class="hljs-function"><span class="hljs-function"> </span></span><br><span class="hljs-function"><span class="hljs-function"> ‚Ä¶        .        .        .        . </span></span><br><span class="hljs-function"><span class="hljs-function">             . </span></span><br><span class="hljs-function"><span class="hljs-function"> </span></span><br><span class="hljs-function"><span class="hljs-function"> </span></span><code class="cpp"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">enum</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">class</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TokenType</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Operator</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Number</span></span></span><span class="hljs-function"> }; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">class</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Token</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">public</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Token</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Operator)</span></span></span></span> {} TokenType Type() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TokenType::Operator; } }; ‚Ä¶ TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } };</code> <br>   <code>ToString</code>   <code>TokenType</code>       ,   ,   .     . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_type_for_number_token) { Token numToken(<span class="hljs-number"><span class="hljs-number">1.2</span></span>); Assert::AreEqual(TokenType::Number, numToken.Type()); }</code> <br>   .   (constant ‚Üí scalar)   . <br> <br> <code class="cpp">class Token { public: Token(Operator) :m_type(TokenType::Operator) {} Token(double) :m_type(TokenType::Number) {} TokenType Type() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_type; } private: TokenType m_type; };</code> <br> ‚Ä¶ <s>       </s> . <s>       </s> .        .        . <br>    . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); }</code> <br>            . <br> <br> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} operator Operator() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_operator; } ‚Ä¶ Operator m_operator; };</code> <br>      . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_number_value_from_number_token) { Token token(<span class="hljs-number"><span class="hljs-number">1.23</span></span>); Assert::AreEqual&lt;double&gt;(<span class="hljs-number"><span class="hljs-number">1.23</span></span>, token); }</code> <br>          ,  ,       <code>union</code> .         . <br> <br> <b class="spoiler_title">Token</b> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_type; } operator Operator() const { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(m_type != TokenType::Operator) throw std::logic_error(<span class="hljs-string"><span class="hljs-string">"Should be operator token."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_operator; } operator double() const { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(m_type != TokenType::Number) throw std::logic_error(<span class="hljs-string"><span class="hljs-string">"Should be number token."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_number; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ToString(static_cast&lt;Operator&gt;(token)); default: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Unknown token."</span></span>; } }</code> <br> <br>  ,    ,      ,    .       .    . <br> <br> <i>          .</i>               .            .       . <br>        : <br> <br> <code class="cpp"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(expr[<span class="hljs-number"><span class="hljs-number">0</span></span>] &gt;= <span class="hljs-string"><span class="hljs-string">'0'</span></span> &amp;&amp; expr[<span class="hljs-number"><span class="hljs-number">0</span></span>] &lt;= <span class="hljs-string"><span class="hljs-string">'9'</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ (double) expr[<span class="hljs-number"><span class="hljs-number">0</span></span>] - <span class="hljs-string"><span class="hljs-string">'0'</span></span> }; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ static_cast&lt;Operator&gt;(expr[<span class="hljs-number"><span class="hljs-number">0</span></span>]) };</code> <br>      ,   . <br> <br> ‚Ä¶ <s>          .</s> <i>              .</i> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"12.34"</span></span>); AssertRange::AreEqual({ <span class="hljs-number"><span class="hljs-number">12.34</span></span> }, tokens); }</code> <br> ,     <code>C</code>   ,  <code>isdigit</code> , ,       <code>atof</code> ,    ,      <code>wchar_t</code> .  (expression ‚Üí <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">)</span></span>.         . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { const wchar_t *current = expr.c_str(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!*current) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{}; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(iswdigit(*current)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ _wtof(current) }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ static_cast&lt;Operator&gt;(*current) }; }</code> <br>         .      . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"+12.34"</span></span>); AssertRange::AreEqual({ Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">12.34</span></span>) }, tokens); }</code> <br>   ,        .  ,     .     .   <code>result</code> ,     . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!*current) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(iswdigit(*current)) { result.push_back(_wtof(current)); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { result.push_back(static_cast&lt;Operator&gt;(*current)); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> <br>      :   (<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ‚Üí <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>).     ,        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(*current) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(iswdigit(*current)) { wchar_t *<span class="hljs-keyword"><span class="hljs-keyword">end</span></span> = nullptr; result.push_back(wcstod(current, &amp;<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>)); current = <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> <br>  <code>wcstod</code>    ,   <code>_wtof</code> ,           .           ,              .  ,    . <br> <br> <s>           .</s>       . <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">" 1 + 12.34 "</span></span>); AssertRange::AreEqual({ Token(<span class="hljs-number"><span class="hljs-number">1.0</span></span>), Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">12.34</span></span>) }, tokens); }</code> <br>  (unconditional ‚Üí <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>)    ,    . <br> <br> <code class="cpp"> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(*current) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(iswdigit(*current)) { wchar_t *<span class="hljs-keyword"><span class="hljs-keyword">end</span></span> = nullptr; result.push_back(wcstod(current, &amp;<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>)); current = <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(*current == static_cast&lt;wchar_t&gt;(Operator::Plus)) { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { ++current; } }</code> <br>       .          .       <code>Detail</code>      .   <code>Tokenize</code>       . <br> <br> <code class="cpp">inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tokenizer.Result(); }</code> <br> <b class="spoiler_title"> Detail::Tokenizer</b> <code class="cpp">namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!EndOfExperssion()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(IsNumber()) { ScanNumber(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(IsOperator()) { ScanOperator(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { MoveNext(); } } } const Tokens &amp;Result() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_result; } private: bool EndOfExperssion() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_current == L<span class="hljs-string"><span class="hljs-string">'\0'</span></span>; } bool IsNumber() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> iswdigit(*m_current) != <span class="hljs-number"><span class="hljs-number">0</span></span>; } void ScanNumber() { wchar_t *<span class="hljs-keyword"><span class="hljs-keyword">end</span></span> = nullptr; m_result.push_back(wcstod(m_current, &amp;<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>)); m_current = <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; } bool IsOperator() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_current == static_cast&lt;wchar_t&gt;(Operator::Plus); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail</code> <br> <br>  ,      .      ,  , .       . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"1+2*3/(4-5)"</span></span>); AssertRange::AreEqual({ Token(<span class="hljs-number"><span class="hljs-number">1</span></span>), Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">2</span></span>), Token(Operator::Mul), Token(<span class="hljs-number"><span class="hljs-number">3</span></span>), Token(Operator::Div), Token(Operator::LParen), Token(<span class="hljs-number"><span class="hljs-number">4</span></span>), Token(Operator::Minus), Token(<span class="hljs-number"><span class="hljs-number">5</span></span>), Token(Operator::RParen) }, tokens); }</code> <br>      <code>Operator</code> ,    . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L<span class="hljs-string"><span class="hljs-string">'+'</span></span>, Minus = L<span class="hljs-string"><span class="hljs-string">'-'</span></span>, Mul = L<span class="hljs-string"><span class="hljs-string">'*'</span></span>, Div = L<span class="hljs-string"><span class="hljs-string">'/'</span></span>, LParen = L<span class="hljs-string"><span class="hljs-string">'('</span></span>, RParen = L<span class="hljs-string"><span class="hljs-string">')'</span></span>, };</code> <br>   .         <code>IsOperator</code>  <code>Tokenizer</code> . <br> <br> <code class="cpp"> bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> std::any_of(all.begin(), all.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(), [this](Operator o) {<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_current == static_cast&lt;wchar_t&gt;(o); }); }</code> <br>         .        . <br> <br> <b class="spoiler_title">Interpreter.h</b> <code class="cpp">#pragma once; #include &lt;vector&gt; #include &lt;wchar.h&gt; #include &lt;algorithm&gt; namespace Interpreter { enum class Operator : wchar_t { Plus = L<span class="hljs-string"><span class="hljs-string">'+'</span></span>, Minus = L<span class="hljs-string"><span class="hljs-string">'-'</span></span>, Mul = L<span class="hljs-string"><span class="hljs-string">'*'</span></span>, Div = L<span class="hljs-string"><span class="hljs-string">'/'</span></span>, LParen = L<span class="hljs-string"><span class="hljs-string">'('</span></span>, RParen = L<span class="hljs-string"><span class="hljs-string">')'</span></span>, }; inline std::wstring ToString(const Operator &amp;op) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ static_cast&lt;wchar_t&gt;(op) }; } enum class TokenType { Operator, Number }; inline std::wstring ToString(const TokenType &amp;<span class="hljs-built_in"><span class="hljs-built_in">type</span></span>) { switch(<span class="hljs-built_in"><span class="hljs-built_in">type</span></span>) { case TokenType::Operator: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> L<span class="hljs-string"><span class="hljs-string">"Operator"</span></span>; case TokenType::Number: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> L<span class="hljs-string"><span class="hljs-string">"Number"</span></span>; default: throw std::out_of_range(<span class="hljs-string"><span class="hljs-string">"TokenType"</span></span>); } } class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_type; } operator Operator() const { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(m_type != TokenType::Operator) throw std::logic_error(<span class="hljs-string"><span class="hljs-string">"Should be operator token."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_operator; } operator double() const { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(m_type != TokenType::Number) throw std::logic_error(<span class="hljs-string"><span class="hljs-string">"Should be number token."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_number; } friend inline bool operator==(const Token &amp;left, const Token &amp;right) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(left.m_type == right.m_type) { switch(left.m_type) { case Interpreter::TokenType::Operator: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> left.m_operator == right.m_operator; case Interpreter::TokenType::Number: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> left.m_number == right.m_number; default: throw std::out_of_range(<span class="hljs-string"><span class="hljs-string">"TokenType"</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ToString(static_cast&lt;Operator&gt;(token)); default: throw std::out_of_range(<span class="hljs-string"><span class="hljs-string">"TokenType"</span></span>); } } typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!EndOfExperssion()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(IsNumber()) { ScanNumber(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(IsOperator()) { ScanOperator(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { MoveNext(); } } } const Tokens &amp;Result() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_result; } private: bool EndOfExperssion() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_current == L<span class="hljs-string"><span class="hljs-string">'\0'</span></span>; } bool IsNumber() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> iswdigit(*m_current) != <span class="hljs-number"><span class="hljs-number">0</span></span>; } void ScanNumber() { wchar_t *<span class="hljs-keyword"><span class="hljs-keyword">end</span></span> = nullptr; m_result.push_back(wcstod(m_current, &amp;<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>)); m_current = <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; } bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> std::any_of(all.begin(), all.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(), [this](Operator o) {<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_current == static_cast&lt;wchar_t&gt;(o); }); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tokenizer.Result(); } } // namespace Lexer } // namespace Interpreter</code> <br> <br> <b class="spoiler_title">InterpreterTests.cpp</b> <code class="cpp">#include <span class="hljs-string"><span class="hljs-string">"stdafx.h"</span></span> #include <span class="hljs-string"><span class="hljs-string">"CppUnitTest.h"</span></span> #include <span class="hljs-string"><span class="hljs-string">"Interpreter.h"</span></span> namespace InterpreterTests { using namespace Microsoft::VisualStudio::CppUnitTestFramework; using namespace Interpreter; using namespace std; namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(expect)), distance(actualIter, <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(actual)), L<span class="hljs-string"><span class="hljs-string">"Size differs."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(; expectIter != <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(expect) &amp;&amp; actualIter != <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(actual); ++expectIter, ++actualIter) { auto message = L<span class="hljs-string"><span class="hljs-string">"Mismatch in position "</span></span> + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual&lt;T&gt;(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange TEST_CLASS(LexerTests) { public: TEST_METHOD(Should_return_empty_token_list_when_put_empty_expression) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">""</span></span>); Assert::IsTrue(tokens.empty()); } TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"+"</span></span>); AssertRange::AreEqual({ Operator::Plus }, tokens); } TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"1"</span></span>); AssertRange::AreEqual({ <span class="hljs-number"><span class="hljs-number">1.0</span></span> }, tokens); } TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"12.34"</span></span>); AssertRange::AreEqual({ <span class="hljs-number"><span class="hljs-number">12.34</span></span> }, tokens); } TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"+12.34"</span></span>); AssertRange::AreEqual({ Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">12.34</span></span>) }, tokens); } TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">" 1 + 12.34 "</span></span>); AssertRange::AreEqual({ Token(<span class="hljs-number"><span class="hljs-number">1.0</span></span>), Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">12.34</span></span>) }, tokens); } TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"1+2*3/(4-5)"</span></span>); AssertRange::AreEqual({ Token(<span class="hljs-number"><span class="hljs-number">1</span></span>), Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">2</span></span>), Token(Operator::Mul), Token(<span class="hljs-number"><span class="hljs-number">3</span></span>), Token(Operator::Div), Token(Operator::LParen), Token(<span class="hljs-number"><span class="hljs-number">4</span></span>), Token(Operator::Minus), Token(<span class="hljs-number"><span class="hljs-number">5</span></span>), Token(Operator::RParen) }, tokens); } }; TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } TEST_METHOD(Should_get_type_for_number_token) { Token numToken(<span class="hljs-number"><span class="hljs-number">1.2</span></span>); Assert::AreEqual(TokenType::Number, numToken.Type()); } TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); } TEST_METHOD(Should_get_number_value_from_number_token) { Token token(<span class="hljs-number"><span class="hljs-number">1.23</span></span>); Assert::AreEqual&lt;double&gt;(<span class="hljs-number"><span class="hljs-number">1.23</span></span>, token); } }; }</code> <br> <br> <a href="https://github.com/Unril/InterpreterTDD/releases/tag/%25D0%259A%25D0%25BE%25D0%25BD%25D0%25B5%25D1%2586_%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B2%25D0%25BE%25D0%25B9_%25D1%2587%25D0%25B0%25D1%2581%25D1%2582%25D0%25B8">    GitHub</a> .         ,  .      <span class="hljs-string"><span class="hljs-string">"__"</span></span>. <br> <br>   <a href="http://habrahabr.ru/post/232081/">    </a> .      ,      <a href="http://habrahabr.ru/post/232097/">    </a> .</code> </pre> <code><code>std::vector,      Tokens</code> .            . <br> <br> <code class="cpp">#pragma once; #include &lt;vector&gt; namespace Interpreter { struct Token {}; typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { inline Tokens Tokenize(std::string expr) { throw std::exception(); } } // namespace Lexer } // namespace Interpreter</code> <br>   ,  ,   , .   ,    ,    <a href="http://cleancoder.posterous.com/the-transformation-priority-premise">The Transformation Priority Premise (TPP)</a>   .    , ,    ,     ,        .            .     ,     ,      ,           .  ,  ,   (   )    ,  ,  .     ,  ,         .     ,   TPP          . <br> <br>   : <br> <br> ({} ‚Üí nil)     ,   . (nil ‚Üí constant)    . (constant ‚Üí constant+)      (        ,  ). (constant ‚Üí scalar)    ,  . (statement ‚Üí statements)    (break, continue, return  ). (unconditional ‚Üí if)       . (scalar ‚Üí array)  / . (array ‚Üí container)     . (statement ‚Üí recursion)   . (if ‚Üí while)    . (expression ‚Üí function)   . (variable ‚Üí assignment)   . <br>        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::string expr) { return{}; }</code> <br> ,         .     . <br> <br> <s>         </s> .           .           .               .            .       . <br>  ,  <code>std::string</code>  <code>std::wstring</code> .         ,      Unicode.     . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); }</code> <br>  <code>AssertRange</code> -   ,       <code>AreEqual</code> ,   ,  ,    . <br> <br> <b class="spoiler_title">AssertRange</b> <code class="cpp">namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange</code> <br> <br>         <code>Operator</code>    .          <code>wchar_t</code>   ,         ,      . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', }; typedef Operator Token;</code> <br>    ,   ,        <code>Assert</code> ,    <code>ToString</code> ,    . <br> <br> <b class="spoiler_title">std::wstring ToString(const Token &amp;)</b> <code class="cpp">inline std::wstring ToString(const Token &amp;token) { return{ static_cast&lt;wchar_t&gt;(token) }; }</code> <br> <br>    ,   ,        .  ,   (unconditional ‚Üí if). <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { if(expr.empty()) { return{}; } return{ static_cast&lt;Operator&gt;(expr[0]) }; }</code> <br> <s>         </s> . <s>          .</s>           . ‚Ä¶ <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); }</code> <br>     .   ,     ,   - .    , : <br> <br>        ,      <code>Token</code> .       <code>dynamic_cast</code>    ,   .  ,    ,      .      <code>std::function</code>        .        .  Boost.Any,  - .            . <br>   ,   .      -  .  ,      ,      . <br> <br> ‚Ä¶        .        .        .        . <br>             . <br> <br> <code class="cpp">enum class TokenType { Operator, Number }; class Token { public: Token(Operator) {} TokenType Type() const { return TokenType::Operator; } }; ‚Ä¶ TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } };</code> <br>   <code>ToString</code>   <code>TokenType</code>       ,   ,   .     . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); }</code> <br>   .   (constant ‚Üí scalar)   . <br> <br> <code class="cpp">class Token { public: Token(Operator) :m_type(TokenType::Operator) {} Token(double) :m_type(TokenType::Number) {} TokenType Type() const { return m_type; } private: TokenType m_type; };</code> <br> ‚Ä¶ <s>       </s> . <s>       </s> .        .        . <br>    . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); }</code> <br>            . <br> <br> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} operator Operator() const { return m_operator; } ‚Ä¶ Operator m_operator; };</code> <br>      . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); }</code> <br>          ,  ,       <code>union</code> .         . <br> <br> <b class="spoiler_title">Token</b> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: return "Unknown token."; } }</code> <br> <br>  ,    ,      ,    .       .    . <br> <br> <i>          .</i>               .            .       . <br>        : <br> <br> <code class="cpp"> if(expr[0] &gt;= '0' &amp;&amp; expr[0] &lt;= '9') { return{ (double) expr[0] - '0' }; } return{ static_cast&lt;Operator&gt;(expr[0]) };</code> <br>      ,   . <br> <br> ‚Ä¶ <s>          .</s> <i>              .</i> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); }</code> <br> ,     <code>C</code>   ,  <code>isdigit</code> , ,       <code>atof</code> ,    ,      <code>wchar_t</code> .  (expression ‚Üí function).         . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { const wchar_t *current = expr.c_str(); if(!*current) return{}; if(iswdigit(*current)) return{ _wtof(current) }; return{ static_cast&lt;Operator&gt;(*current) }; }</code> <br>         .      . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>   ,        .  ,     .     .   <code>result</code> ,     . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); if(!*current) return result; if(iswdigit(*current)) { result.push_back(_wtof(current)); } else { result.push_back(static_cast&lt;Operator&gt;(*current)); } return result; }</code> <br>      :   (if ‚Üí while).     ,        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } } return result; }</code> <br>  <code>wcstod</code>    ,   <code>_wtof</code> ,           .           ,              .  ,    . <br> <br> <s>           .</s>       . <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>  (unconditional ‚Üí if)    ,    . <br> <br> <code class="cpp"> while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else if(*current == static_cast&lt;wchar_t&gt;(Operator::Plus)) { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } else { ++current; } }</code> <br>       .          .       <code>Detail</code>      .   <code>Tokenize</code>       . <br> <br> <code class="cpp">inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); }</code> <br> <b class="spoiler_title"> Detail::Tokenizer</b> <code class="cpp">namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { return *m_current == static_cast&lt;wchar_t&gt;(Operator::Plus); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail</code> <br> <br>  ,      .      ,  , .       . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); }</code> <br>      <code>Operator</code> ,    . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', };</code> <br>   .         <code>IsOperator</code>  <code>Tokenizer</code> . <br> <br> <code class="cpp"> bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); }</code> <br>         .        . <br> <br> <b class="spoiler_title">Interpreter.h</b> <code class="cpp">#pragma once; #include &lt;vector&gt; #include &lt;wchar.h&gt; #include &lt;algorithm&gt; namespace Interpreter { enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', }; inline std::wstring ToString(const Operator &amp;op) { return{ static_cast&lt;wchar_t&gt;(op) }; } enum class TokenType { Operator, Number }; inline std::wstring ToString(const TokenType &amp;type) { switch(type) { case TokenType::Operator: return L"Operator"; case TokenType::Number: return L"Number"; default: throw std::out_of_range("TokenType"); } } class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } friend inline bool operator==(const Token &amp;left, const Token &amp;right) { if(left.m_type == right.m_type) { switch(left.m_type) { case Interpreter::TokenType::Operator: return left.m_operator == right.m_operator; case Interpreter::TokenType::Number: return left.m_number == right.m_number; default: throw std::out_of_range("TokenType"); } } return false; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: throw std::out_of_range("TokenType"); } } typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); } } // namespace Lexer } // namespace Interpreter</code> <br> <br> <b class="spoiler_title">InterpreterTests.cpp</b> <code class="cpp">#include "stdafx.h" #include "CppUnitTest.h" #include "Interpreter.h" namespace InterpreterTests { using namespace Microsoft::VisualStudio::CppUnitTestFramework; using namespace Interpreter; using namespace std; namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual&lt;T&gt;(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange TEST_CLASS(LexerTests) { public: TEST_METHOD(Should_return_empty_token_list_when_put_empty_expression) { Tokens tokens = Lexer::Tokenize(L""); Assert::IsTrue(tokens.empty()); } TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); } TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); } TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); } TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); } }; TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); } TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); } TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); } }; }</code> <br> <br> <a href="https://github.com/Unril/InterpreterTDD/releases/tag/%25D0%259A%25D0%25BE%25D0%25BD%25D0%25B5%25D1%2586_%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B2%25D0%25BE%25D0%25B9_%25D1%2587%25D0%25B0%25D1%2581%25D1%2582%25D0%25B8">    GitHub</a> .         ,  .      "__". <br> <br>   <a href="http://habrahabr.ru/post/232081/">    </a> .      ,      <a href="http://habrahabr.ru/post/232097/">    </a> .</code> </div></div> <code><code>std::vector,      Tokens</code> .            . <br> <br> <code class="cpp">#pragma once; #include &lt;vector&gt; namespace Interpreter { struct Token {}; typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { inline Tokens Tokenize(std::string expr) { throw std::exception(); } } // namespace Lexer } // namespace Interpreter</code> <br>   ,  ,   , .   ,    ,    <a href="http://cleancoder.posterous.com/the-transformation-priority-premise">The Transformation Priority Premise (TPP)</a>   .    , ,    ,     ,        .            .     ,     ,      ,           .  ,  ,   (   )    ,  ,  .     ,  ,         .     ,   TPP          . <br> <br>   : <br> <br> ({} ‚Üí nil)     ,   . (nil ‚Üí constant)    . (constant ‚Üí constant+)      (        ,  ). (constant ‚Üí scalar)    ,  . (statement ‚Üí statements)    (break, continue, return  ). (unconditional ‚Üí if)       . (scalar ‚Üí array)  / . (array ‚Üí container)     . (statement ‚Üí recursion)   . (if ‚Üí while)    . (expression ‚Üí function)   . (variable ‚Üí assignment)   . <br>        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::string expr) { return{}; }</code> <br> ,         .     . <br> <br> <s>         </s> .           .           .               .            .       . <br>  ,  <code>std::string</code>  <code>std::wstring</code> .         ,      Unicode.     . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); }</code> <br>  <code>AssertRange</code> -   ,       <code>AreEqual</code> ,   ,  ,    . <br> <br> <b class="spoiler_title">AssertRange</b> <code class="cpp">namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange</code> <br> <br>         <code>Operator</code>    .          <code>wchar_t</code>   ,         ,      . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', }; typedef Operator Token;</code> <br>    ,   ,        <code>Assert</code> ,    <code>ToString</code> ,    . <br> <br> <b class="spoiler_title">std::wstring ToString(const Token &amp;)</b> <code class="cpp">inline std::wstring ToString(const Token &amp;token) { return{ static_cast&lt;wchar_t&gt;(token) }; }</code> <br> <br>    ,   ,        .  ,   (unconditional ‚Üí if). <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { if(expr.empty()) { return{}; } return{ static_cast&lt;Operator&gt;(expr[0]) }; }</code> <br> <s>         </s> . <s>          .</s>           . ‚Ä¶ <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); }</code> <br>     .   ,     ,   - .    , : <br> <br>        ,      <code>Token</code> .       <code>dynamic_cast</code>    ,   .  ,    ,      .      <code>std::function</code>        .        .  Boost.Any,  - .            . <br>   ,   .      -  .  ,      ,      . <br> <br> ‚Ä¶        .        .        .        . <br>             . <br> <br> <code class="cpp">enum class TokenType { Operator, Number }; class Token { public: Token(Operator) {} TokenType Type() const { return TokenType::Operator; } }; ‚Ä¶ TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } };</code> <br>   <code>ToString</code>   <code>TokenType</code>       ,   ,   .     . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); }</code> <br>   .   (constant ‚Üí scalar)   . <br> <br> <code class="cpp">class Token { public: Token(Operator) :m_type(TokenType::Operator) {} Token(double) :m_type(TokenType::Number) {} TokenType Type() const { return m_type; } private: TokenType m_type; };</code> <br> ‚Ä¶ <s>       </s> . <s>       </s> .        .        . <br>    . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); }</code> <br>            . <br> <br> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} operator Operator() const { return m_operator; } ‚Ä¶ Operator m_operator; };</code> <br>      . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); }</code> <br>          ,  ,       <code>union</code> .         . <br> <br> <b class="spoiler_title">Token</b> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: return "Unknown token."; } }</code> <br> <br>  ,    ,      ,    .       .    . <br> <br> <i>          .</i>               .            .       . <br>        : <br> <br> <code class="cpp"> if(expr[0] &gt;= '0' &amp;&amp; expr[0] &lt;= '9') { return{ (double) expr[0] - '0' }; } return{ static_cast&lt;Operator&gt;(expr[0]) };</code> <br>      ,   . <br> <br> ‚Ä¶ <s>          .</s> <i>              .</i> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); }</code> <br> ,     <code>C</code>   ,  <code>isdigit</code> , ,       <code>atof</code> ,    ,      <code>wchar_t</code> .  (expression ‚Üí function).         . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { const wchar_t *current = expr.c_str(); if(!*current) return{}; if(iswdigit(*current)) return{ _wtof(current) }; return{ static_cast&lt;Operator&gt;(*current) }; }</code> <br>         .      . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>   ,        .  ,     .     .   <code>result</code> ,     . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); if(!*current) return result; if(iswdigit(*current)) { result.push_back(_wtof(current)); } else { result.push_back(static_cast&lt;Operator&gt;(*current)); } return result; }</code> <br>      :   (if ‚Üí while).     ,        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } } return result; }</code> <br>  <code>wcstod</code>    ,   <code>_wtof</code> ,           .           ,              .  ,    . <br> <br> <s>           .</s>       . <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>  (unconditional ‚Üí if)    ,    . <br> <br> <code class="cpp"> while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else if(*current == static_cast&lt;wchar_t&gt;(Operator::Plus)) { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } else { ++current; } }</code> <br>       .          .       <code>Detail</code>      .   <code>Tokenize</code>       . <br> <br> <code class="cpp">inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); }</code> <br> <b class="spoiler_title"> Detail::Tokenizer</b> <code class="cpp">namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { return *m_current == static_cast&lt;wchar_t&gt;(Operator::Plus); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail</code> <br> <br>  ,      .      ,  , .       . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); }</code> <br>      <code>Operator</code> ,    . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', };</code> <br>   .         <code>IsOperator</code>  <code>Tokenizer</code> . <br> <br> <code class="cpp"> bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); }</code> <br>         .        . <br> <br> <b class="spoiler_title">Interpreter.h</b> <code class="cpp">#pragma once; #include &lt;vector&gt; #include &lt;wchar.h&gt; #include &lt;algorithm&gt; namespace Interpreter { enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', }; inline std::wstring ToString(const Operator &amp;op) { return{ static_cast&lt;wchar_t&gt;(op) }; } enum class TokenType { Operator, Number }; inline std::wstring ToString(const TokenType &amp;type) { switch(type) { case TokenType::Operator: return L"Operator"; case TokenType::Number: return L"Number"; default: throw std::out_of_range("TokenType"); } } class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } friend inline bool operator==(const Token &amp;left, const Token &amp;right) { if(left.m_type == right.m_type) { switch(left.m_type) { case Interpreter::TokenType::Operator: return left.m_operator == right.m_operator; case Interpreter::TokenType::Number: return left.m_number == right.m_number; default: throw std::out_of_range("TokenType"); } } return false; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: throw std::out_of_range("TokenType"); } } typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); } } // namespace Lexer } // namespace Interpreter</code> <br> <br> <b class="spoiler_title">InterpreterTests.cpp</b> <code class="cpp">#include "stdafx.h" #include "CppUnitTest.h" #include "Interpreter.h" namespace InterpreterTests { using namespace Microsoft::VisualStudio::CppUnitTestFramework; using namespace Interpreter; using namespace std; namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual&lt;T&gt;(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange TEST_CLASS(LexerTests) { public: TEST_METHOD(Should_return_empty_token_list_when_put_empty_expression) { Tokens tokens = Lexer::Tokenize(L""); Assert::IsTrue(tokens.empty()); } TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); } TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); } TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); } TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); } }; TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); } TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); } TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); } }; }</code> <br> <br> <a href="https://github.com/Unril/InterpreterTDD/releases/tag/%25D0%259A%25D0%25BE%25D0%25BD%25D0%25B5%25D1%2586_%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B2%25D0%25BE%25D0%25B9_%25D1%2587%25D0%25B0%25D1%2581%25D1%2582%25D0%25B8">    GitHub</a> .         ,  .      "__". <br> <br>   <a href="http://habrahabr.ru/post/232081/">    </a> .      ,      <a href="http://habrahabr.ru/post/232097/">    </a> .</code> <pre> <code class="hljs lua"><code>std::vector,      Tokens</code> .            . <br> <br> <code class="cpp">#pragma once; #include &lt;vector&gt; namespace Interpreter { struct Token {}; typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { inline Tokens Tokenize(std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> expr) { throw std::exception(); } } // namespace Lexer } // namespace Interpreter</code> <br>   ,  ,   , .   ,    ,    <a href="http://cleancoder.posterous.com/the-transformation-priority-premise">The Transformation Priority Premise (TPP)</a>   .    , ,    ,     ,        .            .     ,     ,      ,           .  ,  ,   (   )    ,  ,  .     ,  ,         .     ,   TPP          . <br> <br>   : <br> <br> ({} ‚Üí <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)     ,   . (<span class="hljs-literal"><span class="hljs-literal">nil</span></span> ‚Üí constant)    . (constant ‚Üí constant+)      (        ,  ). (constant ‚Üí scalar)    ,  . (statement ‚Üí statements)    (<span class="hljs-keyword"><span class="hljs-keyword">break</span></span>, continue, <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>  ). (unconditional ‚Üí <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>)       . (scalar ‚Üí array)  / . (array ‚Üí container)     . (statement ‚Üí recursion)   . (<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ‚Üí <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>)    . (expression ‚Üí <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">)</span></span>   . (variable ‚Üí assignment)   . <br>        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> expr) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{}; }</code> <br> ,         .     . <br> <br> <s>         </s> .           .           .               .            .       . <br>  ,  <code>std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span></code>  <code>std::wstring</code> .         ,      Unicode.     . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"+"</span></span>); AssertRange::AreEqual({ Operator::Plus }, tokens); }</code> <br>  <code>AssertRange</code> -   ,       <code>AreEqual</code> ,   ,  ,    . <br> <br> <b class="spoiler_title">AssertRange</b> <code class="cpp">namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(expect)), distance(actualIter, <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(actual)), L<span class="hljs-string"><span class="hljs-string">"Size differs."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(; expectIter != <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(expect) &amp;&amp; actualIter != <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(actual); ++expectIter, ++actualIter) { auto message = L<span class="hljs-string"><span class="hljs-string">"Mismatch in position "</span></span> + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange</code> <br> <br>         <code>Operator</code>    .          <code>wchar_t</code>   ,         ,      . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L<span class="hljs-string"><span class="hljs-string">'+'</span></span>, }; typedef Operator Token;</code> <br>    ,   ,        <code>Assert</code> ,    <code>ToString</code> ,    . <br> <br> <b class="spoiler_title">std::wstring ToString(const Token &amp;)</b> <code class="cpp">inline std::wstring ToString(const Token &amp;token) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ static_cast&lt;wchar_t&gt;(token) }; }</code> <br> <br>    ,   ,        .  ,   (unconditional ‚Üí <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>). <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(expr.empty()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{}; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ static_cast&lt;Operator&gt;(expr[<span class="hljs-number"><span class="hljs-number">0</span></span>]) }; }</code> <br> <s>         </s> . <s>          .</s>           . ‚Ä¶ <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"1"</span></span>); AssertRange::AreEqual({ <span class="hljs-number"><span class="hljs-number">1.0</span></span> }, tokens); }</code> <br>     .   ,     ,   - .    , : <br> <br>        ,      <code>Token</code> .       <code>dynamic_cast</code>    ,   .  ,    ,      .      <code>std::<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span></span></code><span class="hljs-function"><span class="hljs-function">        .        .  </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Boost.Any</span></span></span><span class="hljs-function">,  - .            . </span></span><br><span class="hljs-function"><span class="hljs-function">   ,   .      -  .  ,      ,      . </span></span><br><span class="hljs-function"><span class="hljs-function"> </span></span><br><span class="hljs-function"><span class="hljs-function"> ‚Ä¶        .        .        .        . </span></span><br><span class="hljs-function"><span class="hljs-function">             . </span></span><br><span class="hljs-function"><span class="hljs-function"> </span></span><br><span class="hljs-function"><span class="hljs-function"> </span></span><code class="cpp"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">enum</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">class</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TokenType</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Operator</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Number</span></span></span><span class="hljs-function"> }; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">class</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Token</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">public</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Token</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Operator)</span></span></span></span> {} TokenType Type() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TokenType::Operator; } }; ‚Ä¶ TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } };</code> <br>   <code>ToString</code>   <code>TokenType</code>       ,   ,   .     . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_type_for_number_token) { Token numToken(<span class="hljs-number"><span class="hljs-number">1.2</span></span>); Assert::AreEqual(TokenType::Number, numToken.Type()); }</code> <br>   .   (constant ‚Üí scalar)   . <br> <br> <code class="cpp">class Token { public: Token(Operator) :m_type(TokenType::Operator) {} Token(double) :m_type(TokenType::Number) {} TokenType Type() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_type; } private: TokenType m_type; };</code> <br> ‚Ä¶ <s>       </s> . <s>       </s> .        .        . <br>    . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); }</code> <br>            . <br> <br> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} operator Operator() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_operator; } ‚Ä¶ Operator m_operator; };</code> <br>      . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_number_value_from_number_token) { Token token(<span class="hljs-number"><span class="hljs-number">1.23</span></span>); Assert::AreEqual&lt;double&gt;(<span class="hljs-number"><span class="hljs-number">1.23</span></span>, token); }</code> <br>          ,  ,       <code>union</code> .         . <br> <br> <b class="spoiler_title">Token</b> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_type; } operator Operator() const { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(m_type != TokenType::Operator) throw std::logic_error(<span class="hljs-string"><span class="hljs-string">"Should be operator token."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_operator; } operator double() const { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(m_type != TokenType::Number) throw std::logic_error(<span class="hljs-string"><span class="hljs-string">"Should be number token."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_number; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ToString(static_cast&lt;Operator&gt;(token)); default: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Unknown token."</span></span>; } }</code> <br> <br>  ,    ,      ,    .       .    . <br> <br> <i>          .</i>               .            .       . <br>        : <br> <br> <code class="cpp"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(expr[<span class="hljs-number"><span class="hljs-number">0</span></span>] &gt;= <span class="hljs-string"><span class="hljs-string">'0'</span></span> &amp;&amp; expr[<span class="hljs-number"><span class="hljs-number">0</span></span>] &lt;= <span class="hljs-string"><span class="hljs-string">'9'</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ (double) expr[<span class="hljs-number"><span class="hljs-number">0</span></span>] - <span class="hljs-string"><span class="hljs-string">'0'</span></span> }; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ static_cast&lt;Operator&gt;(expr[<span class="hljs-number"><span class="hljs-number">0</span></span>]) };</code> <br>      ,   . <br> <br> ‚Ä¶ <s>          .</s> <i>              .</i> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"12.34"</span></span>); AssertRange::AreEqual({ <span class="hljs-number"><span class="hljs-number">12.34</span></span> }, tokens); }</code> <br> ,     <code>C</code>   ,  <code>isdigit</code> , ,       <code>atof</code> ,    ,      <code>wchar_t</code> .  (expression ‚Üí <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">)</span></span>.         . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { const wchar_t *current = expr.c_str(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!*current) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{}; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(iswdigit(*current)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ _wtof(current) }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ static_cast&lt;Operator&gt;(*current) }; }</code> <br>         .      . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"+12.34"</span></span>); AssertRange::AreEqual({ Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">12.34</span></span>) }, tokens); }</code> <br>   ,        .  ,     .     .   <code>result</code> ,     . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!*current) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(iswdigit(*current)) { result.push_back(_wtof(current)); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { result.push_back(static_cast&lt;Operator&gt;(*current)); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> <br>      :   (<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ‚Üí <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>).     ,        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(*current) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(iswdigit(*current)) { wchar_t *<span class="hljs-keyword"><span class="hljs-keyword">end</span></span> = nullptr; result.push_back(wcstod(current, &amp;<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>)); current = <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> <br>  <code>wcstod</code>    ,   <code>_wtof</code> ,           .           ,              .  ,    . <br> <br> <s>           .</s>       . <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">" 1 + 12.34 "</span></span>); AssertRange::AreEqual({ Token(<span class="hljs-number"><span class="hljs-number">1.0</span></span>), Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">12.34</span></span>) }, tokens); }</code> <br>  (unconditional ‚Üí <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>)    ,    . <br> <br> <code class="cpp"> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(*current) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(iswdigit(*current)) { wchar_t *<span class="hljs-keyword"><span class="hljs-keyword">end</span></span> = nullptr; result.push_back(wcstod(current, &amp;<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>)); current = <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(*current == static_cast&lt;wchar_t&gt;(Operator::Plus)) { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { ++current; } }</code> <br>       .          .       <code>Detail</code>      .   <code>Tokenize</code>       . <br> <br> <code class="cpp">inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tokenizer.Result(); }</code> <br> <b class="spoiler_title"> Detail::Tokenizer</b> <code class="cpp">namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!EndOfExperssion()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(IsNumber()) { ScanNumber(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(IsOperator()) { ScanOperator(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { MoveNext(); } } } const Tokens &amp;Result() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_result; } private: bool EndOfExperssion() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_current == L<span class="hljs-string"><span class="hljs-string">'\0'</span></span>; } bool IsNumber() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> iswdigit(*m_current) != <span class="hljs-number"><span class="hljs-number">0</span></span>; } void ScanNumber() { wchar_t *<span class="hljs-keyword"><span class="hljs-keyword">end</span></span> = nullptr; m_result.push_back(wcstod(m_current, &amp;<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>)); m_current = <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; } bool IsOperator() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_current == static_cast&lt;wchar_t&gt;(Operator::Plus); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail</code> <br> <br>  ,      .      ,  , .       . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"1+2*3/(4-5)"</span></span>); AssertRange::AreEqual({ Token(<span class="hljs-number"><span class="hljs-number">1</span></span>), Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">2</span></span>), Token(Operator::Mul), Token(<span class="hljs-number"><span class="hljs-number">3</span></span>), Token(Operator::Div), Token(Operator::LParen), Token(<span class="hljs-number"><span class="hljs-number">4</span></span>), Token(Operator::Minus), Token(<span class="hljs-number"><span class="hljs-number">5</span></span>), Token(Operator::RParen) }, tokens); }</code> <br>      <code>Operator</code> ,    . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L<span class="hljs-string"><span class="hljs-string">'+'</span></span>, Minus = L<span class="hljs-string"><span class="hljs-string">'-'</span></span>, Mul = L<span class="hljs-string"><span class="hljs-string">'*'</span></span>, Div = L<span class="hljs-string"><span class="hljs-string">'/'</span></span>, LParen = L<span class="hljs-string"><span class="hljs-string">'('</span></span>, RParen = L<span class="hljs-string"><span class="hljs-string">')'</span></span>, };</code> <br>   .         <code>IsOperator</code>  <code>Tokenizer</code> . <br> <br> <code class="cpp"> bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> std::any_of(all.begin(), all.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(), [this](Operator o) {<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_current == static_cast&lt;wchar_t&gt;(o); }); }</code> <br>         .        . <br> <br> <b class="spoiler_title">Interpreter.h</b> <code class="cpp">#pragma once; #include &lt;vector&gt; #include &lt;wchar.h&gt; #include &lt;algorithm&gt; namespace Interpreter { enum class Operator : wchar_t { Plus = L<span class="hljs-string"><span class="hljs-string">'+'</span></span>, Minus = L<span class="hljs-string"><span class="hljs-string">'-'</span></span>, Mul = L<span class="hljs-string"><span class="hljs-string">'*'</span></span>, Div = L<span class="hljs-string"><span class="hljs-string">'/'</span></span>, LParen = L<span class="hljs-string"><span class="hljs-string">'('</span></span>, RParen = L<span class="hljs-string"><span class="hljs-string">')'</span></span>, }; inline std::wstring ToString(const Operator &amp;op) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ static_cast&lt;wchar_t&gt;(op) }; } enum class TokenType { Operator, Number }; inline std::wstring ToString(const TokenType &amp;<span class="hljs-built_in"><span class="hljs-built_in">type</span></span>) { switch(<span class="hljs-built_in"><span class="hljs-built_in">type</span></span>) { case TokenType::Operator: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> L<span class="hljs-string"><span class="hljs-string">"Operator"</span></span>; case TokenType::Number: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> L<span class="hljs-string"><span class="hljs-string">"Number"</span></span>; default: throw std::out_of_range(<span class="hljs-string"><span class="hljs-string">"TokenType"</span></span>); } } class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_type; } operator Operator() const { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(m_type != TokenType::Operator) throw std::logic_error(<span class="hljs-string"><span class="hljs-string">"Should be operator token."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_operator; } operator double() const { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(m_type != TokenType::Number) throw std::logic_error(<span class="hljs-string"><span class="hljs-string">"Should be number token."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_number; } friend inline bool operator==(const Token &amp;left, const Token &amp;right) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(left.m_type == right.m_type) { switch(left.m_type) { case Interpreter::TokenType::Operator: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> left.m_operator == right.m_operator; case Interpreter::TokenType::Number: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> left.m_number == right.m_number; default: throw std::out_of_range(<span class="hljs-string"><span class="hljs-string">"TokenType"</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ToString(static_cast&lt;Operator&gt;(token)); default: throw std::out_of_range(<span class="hljs-string"><span class="hljs-string">"TokenType"</span></span>); } } typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!EndOfExperssion()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(IsNumber()) { ScanNumber(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(IsOperator()) { ScanOperator(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { MoveNext(); } } } const Tokens &amp;Result() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_result; } private: bool EndOfExperssion() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_current == L<span class="hljs-string"><span class="hljs-string">'\0'</span></span>; } bool IsNumber() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> iswdigit(*m_current) != <span class="hljs-number"><span class="hljs-number">0</span></span>; } void ScanNumber() { wchar_t *<span class="hljs-keyword"><span class="hljs-keyword">end</span></span> = nullptr; m_result.push_back(wcstod(m_current, &amp;<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>)); m_current = <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; } bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> std::any_of(all.begin(), all.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(), [this](Operator o) {<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_current == static_cast&lt;wchar_t&gt;(o); }); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tokenizer.Result(); } } // namespace Lexer } // namespace Interpreter</code> <br> <br> <b class="spoiler_title">InterpreterTests.cpp</b> <code class="cpp">#include <span class="hljs-string"><span class="hljs-string">"stdafx.h"</span></span> #include <span class="hljs-string"><span class="hljs-string">"CppUnitTest.h"</span></span> #include <span class="hljs-string"><span class="hljs-string">"Interpreter.h"</span></span> namespace InterpreterTests { using namespace Microsoft::VisualStudio::CppUnitTestFramework; using namespace Interpreter; using namespace std; namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(expect)), distance(actualIter, <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(actual)), L<span class="hljs-string"><span class="hljs-string">"Size differs."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(; expectIter != <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(expect) &amp;&amp; actualIter != <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(actual); ++expectIter, ++actualIter) { auto message = L<span class="hljs-string"><span class="hljs-string">"Mismatch in position "</span></span> + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual&lt;T&gt;(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange TEST_CLASS(LexerTests) { public: TEST_METHOD(Should_return_empty_token_list_when_put_empty_expression) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">""</span></span>); Assert::IsTrue(tokens.empty()); } TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"+"</span></span>); AssertRange::AreEqual({ Operator::Plus }, tokens); } TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"1"</span></span>); AssertRange::AreEqual({ <span class="hljs-number"><span class="hljs-number">1.0</span></span> }, tokens); } TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"12.34"</span></span>); AssertRange::AreEqual({ <span class="hljs-number"><span class="hljs-number">12.34</span></span> }, tokens); } TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"+12.34"</span></span>); AssertRange::AreEqual({ Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">12.34</span></span>) }, tokens); } TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">" 1 + 12.34 "</span></span>); AssertRange::AreEqual({ Token(<span class="hljs-number"><span class="hljs-number">1.0</span></span>), Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">12.34</span></span>) }, tokens); } TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"1+2*3/(4-5)"</span></span>); AssertRange::AreEqual({ Token(<span class="hljs-number"><span class="hljs-number">1</span></span>), Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">2</span></span>), Token(Operator::Mul), Token(<span class="hljs-number"><span class="hljs-number">3</span></span>), Token(Operator::Div), Token(Operator::LParen), Token(<span class="hljs-number"><span class="hljs-number">4</span></span>), Token(Operator::Minus), Token(<span class="hljs-number"><span class="hljs-number">5</span></span>), Token(Operator::RParen) }, tokens); } }; TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } TEST_METHOD(Should_get_type_for_number_token) { Token numToken(<span class="hljs-number"><span class="hljs-number">1.2</span></span>); Assert::AreEqual(TokenType::Number, numToken.Type()); } TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); } TEST_METHOD(Should_get_number_value_from_number_token) { Token token(<span class="hljs-number"><span class="hljs-number">1.23</span></span>); Assert::AreEqual&lt;double&gt;(<span class="hljs-number"><span class="hljs-number">1.23</span></span>, token); } }; }</code> <br> <br> <a href="https://github.com/Unril/InterpreterTDD/releases/tag/%25D0%259A%25D0%25BE%25D0%25BD%25D0%25B5%25D1%2586_%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B2%25D0%25BE%25D0%25B9_%25D1%2587%25D0%25B0%25D1%2581%25D1%2582%25D0%25B8">    GitHub</a> .         ,  .      <span class="hljs-string"><span class="hljs-string">"__"</span></span>. <br> <br>   <a href="http://habrahabr.ru/post/232081/">    </a> .      ,      <a href="http://habrahabr.ru/post/232097/">    </a> .</code> </pre> <code><code>std::vector,      Tokens</code> .            . <br> <br> <code class="cpp">#pragma once; #include &lt;vector&gt; namespace Interpreter { struct Token {}; typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { inline Tokens Tokenize(std::string expr) { throw std::exception(); } } // namespace Lexer } // namespace Interpreter</code> <br>   ,  ,   , .   ,    ,    <a href="http://cleancoder.posterous.com/the-transformation-priority-premise">The Transformation Priority Premise (TPP)</a>   .    , ,    ,     ,        .            .     ,     ,      ,           .  ,  ,   (   )    ,  ,  .     ,  ,         .     ,   TPP          . <br> <br>   : <br> <br> ({} ‚Üí nil)     ,   . (nil ‚Üí constant)    . (constant ‚Üí constant+)      (        ,  ). (constant ‚Üí scalar)    ,  . (statement ‚Üí statements)    (break, continue, return  ). (unconditional ‚Üí if)       . (scalar ‚Üí array)  / . (array ‚Üí container)     . (statement ‚Üí recursion)   . (if ‚Üí while)    . (expression ‚Üí function)   . (variable ‚Üí assignment)   . <br>        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::string expr) { return{}; }</code> <br> ,         .     . <br> <br> <s>         </s> .           .           .               .            .       . <br>  ,  <code>std::string</code>  <code>std::wstring</code> .         ,      Unicode.     . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); }</code> <br>  <code>AssertRange</code> -   ,       <code>AreEqual</code> ,   ,  ,    . <br> <br> <b class="spoiler_title">AssertRange</b> <code class="cpp">namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange</code> <br> <br>         <code>Operator</code>    .          <code>wchar_t</code>   ,         ,      . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', }; typedef Operator Token;</code> <br>    ,   ,        <code>Assert</code> ,    <code>ToString</code> ,    . <br> <br> <b class="spoiler_title">std::wstring ToString(const Token &amp;)</b> <code class="cpp">inline std::wstring ToString(const Token &amp;token) { return{ static_cast&lt;wchar_t&gt;(token) }; }</code> <br> <br>    ,   ,        .  ,   (unconditional ‚Üí if). <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { if(expr.empty()) { return{}; } return{ static_cast&lt;Operator&gt;(expr[0]) }; }</code> <br> <s>         </s> . <s>          .</s>           . ‚Ä¶ <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); }</code> <br>     .   ,     ,   - .    , : <br> <br>        ,      <code>Token</code> .       <code>dynamic_cast</code>    ,   .  ,    ,      .      <code>std::function</code>        .        .  Boost.Any,  - .            . <br>   ,   .      -  .  ,      ,      . <br> <br> ‚Ä¶        .        .        .        . <br>             . <br> <br> <code class="cpp">enum class TokenType { Operator, Number }; class Token { public: Token(Operator) {} TokenType Type() const { return TokenType::Operator; } }; ‚Ä¶ TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } };</code> <br>   <code>ToString</code>   <code>TokenType</code>       ,   ,   .     . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); }</code> <br>   .   (constant ‚Üí scalar)   . <br> <br> <code class="cpp">class Token { public: Token(Operator) :m_type(TokenType::Operator) {} Token(double) :m_type(TokenType::Number) {} TokenType Type() const { return m_type; } private: TokenType m_type; };</code> <br> ‚Ä¶ <s>       </s> . <s>       </s> .        .        . <br>    . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); }</code> <br>            . <br> <br> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} operator Operator() const { return m_operator; } ‚Ä¶ Operator m_operator; };</code> <br>      . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); }</code> <br>          ,  ,       <code>union</code> .         . <br> <br> <b class="spoiler_title">Token</b> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: return "Unknown token."; } }</code> <br> <br>  ,    ,      ,    .       .    . <br> <br> <i>          .</i>               .            .       . <br>        : <br> <br> <code class="cpp"> if(expr[0] &gt;= '0' &amp;&amp; expr[0] &lt;= '9') { return{ (double) expr[0] - '0' }; } return{ static_cast&lt;Operator&gt;(expr[0]) };</code> <br>      ,   . <br> <br> ‚Ä¶ <s>          .</s> <i>              .</i> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); }</code> <br> ,     <code>C</code>   ,  <code>isdigit</code> , ,       <code>atof</code> ,    ,      <code>wchar_t</code> .  (expression ‚Üí function).         . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { const wchar_t *current = expr.c_str(); if(!*current) return{}; if(iswdigit(*current)) return{ _wtof(current) }; return{ static_cast&lt;Operator&gt;(*current) }; }</code> <br>         .      . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>   ,        .  ,     .     .   <code>result</code> ,     . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); if(!*current) return result; if(iswdigit(*current)) { result.push_back(_wtof(current)); } else { result.push_back(static_cast&lt;Operator&gt;(*current)); } return result; }</code> <br>      :   (if ‚Üí while).     ,        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } } return result; }</code> <br>  <code>wcstod</code>    ,   <code>_wtof</code> ,           .           ,              .  ,    . <br> <br> <s>           .</s>       . <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>  (unconditional ‚Üí if)    ,    . <br> <br> <code class="cpp"> while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else if(*current == static_cast&lt;wchar_t&gt;(Operator::Plus)) { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } else { ++current; } }</code> <br>       .          .       <code>Detail</code>      .   <code>Tokenize</code>       . <br> <br> <code class="cpp">inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); }</code> <br> <b class="spoiler_title"> Detail::Tokenizer</b> <code class="cpp">namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { return *m_current == static_cast&lt;wchar_t&gt;(Operator::Plus); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail</code> <br> <br>  ,      .      ,  , .       . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); }</code> <br>      <code>Operator</code> ,    . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', };</code> <br>   .         <code>IsOperator</code>  <code>Tokenizer</code> . <br> <br> <code class="cpp"> bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); }</code> <br>         .        . <br> <br> <b class="spoiler_title">Interpreter.h</b> <code class="cpp">#pragma once; #include &lt;vector&gt; #include &lt;wchar.h&gt; #include &lt;algorithm&gt; namespace Interpreter { enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', }; inline std::wstring ToString(const Operator &amp;op) { return{ static_cast&lt;wchar_t&gt;(op) }; } enum class TokenType { Operator, Number }; inline std::wstring ToString(const TokenType &amp;type) { switch(type) { case TokenType::Operator: return L"Operator"; case TokenType::Number: return L"Number"; default: throw std::out_of_range("TokenType"); } } class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } friend inline bool operator==(const Token &amp;left, const Token &amp;right) { if(left.m_type == right.m_type) { switch(left.m_type) { case Interpreter::TokenType::Operator: return left.m_operator == right.m_operator; case Interpreter::TokenType::Number: return left.m_number == right.m_number; default: throw std::out_of_range("TokenType"); } } return false; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: throw std::out_of_range("TokenType"); } } typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); } } // namespace Lexer } // namespace Interpreter</code> <br> <br> <b class="spoiler_title">InterpreterTests.cpp</b> <code class="cpp">#include "stdafx.h" #include "CppUnitTest.h" #include "Interpreter.h" namespace InterpreterTests { using namespace Microsoft::VisualStudio::CppUnitTestFramework; using namespace Interpreter; using namespace std; namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual&lt;T&gt;(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange TEST_CLASS(LexerTests) { public: TEST_METHOD(Should_return_empty_token_list_when_put_empty_expression) { Tokens tokens = Lexer::Tokenize(L""); Assert::IsTrue(tokens.empty()); } TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); } TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); } TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); } TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); } }; TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); } TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); } TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); } }; }</code> <br> <br> <a href="https://github.com/Unril/InterpreterTDD/releases/tag/%25D0%259A%25D0%25BE%25D0%25BD%25D0%25B5%25D1%2586_%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B2%25D0%25BE%25D0%25B9_%25D1%2587%25D0%25B0%25D1%2581%25D1%2582%25D0%25B8">    GitHub</a> .         ,  .      "__". <br> <br>   <a href="http://habrahabr.ru/post/232081/">    </a> .      ,      <a href="http://habrahabr.ru/post/232097/">    </a> .</code> <div class="spoiler"> <code><b class="spoiler_title"><code>std::vector,      Tokens</code> .            . <br> <br> <code class="cpp">#pragma once; #include &lt;vector&gt; namespace Interpreter { struct Token {}; typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { inline Tokens Tokenize(std::string expr) { throw std::exception(); } } // namespace Lexer } // namespace Interpreter</code> <br>   ,  ,   , .   ,    ,    <a href="http://cleancoder.posterous.com/the-transformation-priority-premise">The Transformation Priority Premise (TPP)</a>   .    , ,    ,     ,        .            .     ,     ,      ,           .  ,  ,   (   )    ,  ,  .     ,  ,         .     ,   TPP          . <br> <br>   : <br> <br> ({} ‚Üí nil)     ,   . (nil ‚Üí constant)    . (constant ‚Üí constant+)      (        ,  ). (constant ‚Üí scalar)    ,  . (statement ‚Üí statements)    (break, continue, return  ). (unconditional ‚Üí if)       . (scalar ‚Üí array)  / . (array ‚Üí container)     . (statement ‚Üí recursion)   . (if ‚Üí while)    . (expression ‚Üí function)   . (variable ‚Üí assignment)   . <br>        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::string expr) { return{}; }</code> <br> ,         .     . <br> <br> <s>         </s> .           .           .               .            .       . <br>  ,  <code>std::string</code>  <code>std::wstring</code> .         ,      Unicode.     . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); }</code> <br>  <code>AssertRange</code> -   ,       <code>AreEqual</code> ,   ,  ,    . <br> <br> <b class="spoiler_title">AssertRange</b> <code class="cpp">namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange</code> <br> <br>         <code>Operator</code>    .          <code>wchar_t</code>   ,         ,      . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', }; typedef Operator Token;</code> <br>    ,   ,        <code>Assert</code> ,    <code>ToString</code> ,    . <br> <br> std::wstring ToString(const Token &amp;) <code class="cpp">inline std::wstring ToString(const Token &amp;token) { return{ static_cast&lt;wchar_t&gt;(token) }; }</code> <br> <br>    ,   ,        .  ,   (unconditional ‚Üí if). <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { if(expr.empty()) { return{}; } return{ static_cast&lt;Operator&gt;(expr[0]) }; }</code> <br> <s>         </s> . <s>          .</s>           . ‚Ä¶ <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); }</code> <br>     .   ,     ,   - .    , : <br> <br>        ,      <code>Token</code> .       <code>dynamic_cast</code>    ,   .  ,    ,      .      <code>std::function</code>        .        .  Boost.Any,  - .            . <br>   ,   .      -  .  ,      ,      . <br> <br> ‚Ä¶        .        .        .        . <br>             . <br> <br> <code class="cpp">enum class TokenType { Operator, Number }; class Token { public: Token(Operator) {} TokenType Type() const { return TokenType::Operator; } }; ‚Ä¶ TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } };</code> <br>   <code>ToString</code>   <code>TokenType</code>       ,   ,   .     . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); }</code> <br>   .   (constant ‚Üí scalar)   . <br> <br> <code class="cpp">class Token { public: Token(Operator) :m_type(TokenType::Operator) {} Token(double) :m_type(TokenType::Number) {} TokenType Type() const { return m_type; } private: TokenType m_type; };</code> <br> ‚Ä¶ <s>       </s> . <s>       </s> .        .        . <br>    . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); }</code> <br>            . <br> <br> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} operator Operator() const { return m_operator; } ‚Ä¶ Operator m_operator; };</code> <br>      . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); }</code> <br>          ,  ,       <code>union</code> .         . <br> <br> <b class="spoiler_title">Token</b> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: return "Unknown token."; } }</code> <br> <br>  ,    ,      ,    .       .    . <br> <br> <i>          .</i>               .            .       . <br>        : <br> <br> <code class="cpp"> if(expr[0] &gt;= '0' &amp;&amp; expr[0] &lt;= '9') { return{ (double) expr[0] - '0' }; } return{ static_cast&lt;Operator&gt;(expr[0]) };</code> <br>      ,   . <br> <br> ‚Ä¶ <s>          .</s> <i>              .</i> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); }</code> <br> ,     <code>C</code>   ,  <code>isdigit</code> , ,       <code>atof</code> ,    ,      <code>wchar_t</code> .  (expression ‚Üí function).         . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { const wchar_t *current = expr.c_str(); if(!*current) return{}; if(iswdigit(*current)) return{ _wtof(current) }; return{ static_cast&lt;Operator&gt;(*current) }; }</code> <br>         .      . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>   ,        .  ,     .     .   <code>result</code> ,     . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); if(!*current) return result; if(iswdigit(*current)) { result.push_back(_wtof(current)); } else { result.push_back(static_cast&lt;Operator&gt;(*current)); } return result; }</code> <br>      :   (if ‚Üí while).     ,        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } } return result; }</code> <br>  <code>wcstod</code>    ,   <code>_wtof</code> ,           .           ,              .  ,    . <br> <br> <s>           .</s>       . <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>  (unconditional ‚Üí if)    ,    . <br> <br> <code class="cpp"> while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else if(*current == static_cast&lt;wchar_t&gt;(Operator::Plus)) { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } else { ++current; } }</code> <br>       .          .       <code>Detail</code>      .   <code>Tokenize</code>       . <br> <br> <code class="cpp">inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); }</code> <br> <b class="spoiler_title"> Detail::Tokenizer</b> <code class="cpp">namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { return *m_current == static_cast&lt;wchar_t&gt;(Operator::Plus); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail</code> <br> <br>  ,      .      ,  , .       . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); }</code> <br>      <code>Operator</code> ,    . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', };</code> <br>   .         <code>IsOperator</code>  <code>Tokenizer</code> . <br> <br> <code class="cpp"> bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); }</code> <br>         .        . <br> <br> <b class="spoiler_title">Interpreter.h</b> <code class="cpp">#pragma once; #include &lt;vector&gt; #include &lt;wchar.h&gt; #include &lt;algorithm&gt; namespace Interpreter { enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', }; inline std::wstring ToString(const Operator &amp;op) { return{ static_cast&lt;wchar_t&gt;(op) }; } enum class TokenType { Operator, Number }; inline std::wstring ToString(const TokenType &amp;type) { switch(type) { case TokenType::Operator: return L"Operator"; case TokenType::Number: return L"Number"; default: throw std::out_of_range("TokenType"); } } class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } friend inline bool operator==(const Token &amp;left, const Token &amp;right) { if(left.m_type == right.m_type) { switch(left.m_type) { case Interpreter::TokenType::Operator: return left.m_operator == right.m_operator; case Interpreter::TokenType::Number: return left.m_number == right.m_number; default: throw std::out_of_range("TokenType"); } } return false; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: throw std::out_of_range("TokenType"); } } typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); } } // namespace Lexer } // namespace Interpreter</code> <br> <br> <b class="spoiler_title">InterpreterTests.cpp</b> <code class="cpp">#include "stdafx.h" #include "CppUnitTest.h" #include "Interpreter.h" namespace InterpreterTests { using namespace Microsoft::VisualStudio::CppUnitTestFramework; using namespace Interpreter; using namespace std; namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual&lt;T&gt;(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange TEST_CLASS(LexerTests) { public: TEST_METHOD(Should_return_empty_token_list_when_put_empty_expression) { Tokens tokens = Lexer::Tokenize(L""); Assert::IsTrue(tokens.empty()); } TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); } TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); } TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); } TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); } }; TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); } TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); } TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); } }; }</code> <br> <br> <a href="https://github.com/Unril/InterpreterTDD/releases/tag/%25D0%259A%25D0%25BE%25D0%25BD%25D0%25B5%25D1%2586_%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B2%25D0%25BE%25D0%25B9_%25D1%2587%25D0%25B0%25D1%2581%25D1%2582%25D0%25B8">    GitHub</a> .         ,  .      "__". <br> <br>   <a href="http://habrahabr.ru/post/232081/">    </a> .      ,      <a href="http://habrahabr.ru/post/232097/">    </a> .</b></code> <div class="spoiler_text"> <pre> <code class="hljs lua"><code>std::vector,      Tokens</code> .            . <br> <br> <code class="cpp">#pragma once; #include &lt;vector&gt; namespace Interpreter { struct Token {}; typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { inline Tokens Tokenize(std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> expr) { throw std::exception(); } } // namespace Lexer } // namespace Interpreter</code> <br>   ,  ,   , .   ,    ,    <a href="http://cleancoder.posterous.com/the-transformation-priority-premise">The Transformation Priority Premise (TPP)</a>   .    , ,    ,     ,        .            .     ,     ,      ,           .  ,  ,   (   )    ,  ,  .     ,  ,         .     ,   TPP          . <br> <br>   : <br> <br> ({} ‚Üí <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)     ,   . (<span class="hljs-literal"><span class="hljs-literal">nil</span></span> ‚Üí constant)    . (constant ‚Üí constant+)      (        ,  ). (constant ‚Üí scalar)    ,  . (statement ‚Üí statements)    (<span class="hljs-keyword"><span class="hljs-keyword">break</span></span>, continue, <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>  ). (unconditional ‚Üí <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>)       . (scalar ‚Üí array)  / . (array ‚Üí container)     . (statement ‚Üí recursion)   . (<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ‚Üí <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>)    . (expression ‚Üí <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">)</span></span>   . (variable ‚Üí assignment)   . <br>        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> expr) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{}; }</code> <br> ,         .     . <br> <br> <s>         </s> .           .           .               .            .       . <br>  ,  <code>std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span></code>  <code>std::wstring</code> .         ,      Unicode.     . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"+"</span></span>); AssertRange::AreEqual({ Operator::Plus }, tokens); }</code> <br>  <code>AssertRange</code> -   ,       <code>AreEqual</code> ,   ,  ,    . <br> <br> <b class="spoiler_title">AssertRange</b> <code class="cpp">namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(expect)), distance(actualIter, <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(actual)), L<span class="hljs-string"><span class="hljs-string">"Size differs."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(; expectIter != <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(expect) &amp;&amp; actualIter != <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(actual); ++expectIter, ++actualIter) { auto message = L<span class="hljs-string"><span class="hljs-string">"Mismatch in position "</span></span> + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange</code> <br> <br>         <code>Operator</code>    .          <code>wchar_t</code>   ,         ,      . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L<span class="hljs-string"><span class="hljs-string">'+'</span></span>, }; typedef Operator Token;</code> <br>    ,   ,        <code>Assert</code> ,    <code>ToString</code> ,    . <br> <br> <b class="spoiler_title">std::wstring ToString(const Token &amp;)</b> <code class="cpp">inline std::wstring ToString(const Token &amp;token) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ static_cast&lt;wchar_t&gt;(token) }; }</code> <br> <br>    ,   ,        .  ,   (unconditional ‚Üí <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>). <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(expr.empty()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{}; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ static_cast&lt;Operator&gt;(expr[<span class="hljs-number"><span class="hljs-number">0</span></span>]) }; }</code> <br> <s>         </s> . <s>          .</s>           . ‚Ä¶ <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"1"</span></span>); AssertRange::AreEqual({ <span class="hljs-number"><span class="hljs-number">1.0</span></span> }, tokens); }</code> <br>     .   ,     ,   - .    , : <br> <br>        ,      <code>Token</code> .       <code>dynamic_cast</code>    ,   .  ,    ,      .      <code>std::<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span></span></code><span class="hljs-function"><span class="hljs-function">        .        .  </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Boost.Any</span></span></span><span class="hljs-function">,  - .            . </span></span><br><span class="hljs-function"><span class="hljs-function">   ,   .      -  .  ,      ,      . </span></span><br><span class="hljs-function"><span class="hljs-function"> </span></span><br><span class="hljs-function"><span class="hljs-function"> ‚Ä¶        .        .        .        . </span></span><br><span class="hljs-function"><span class="hljs-function">             . </span></span><br><span class="hljs-function"><span class="hljs-function"> </span></span><br><span class="hljs-function"><span class="hljs-function"> </span></span><code class="cpp"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">enum</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">class</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TokenType</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Operator</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Number</span></span></span><span class="hljs-function"> }; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">class</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Token</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">public</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Token</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Operator)</span></span></span></span> {} TokenType Type() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TokenType::Operator; } }; ‚Ä¶ TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } };</code> <br>   <code>ToString</code>   <code>TokenType</code>       ,   ,   .     . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_type_for_number_token) { Token numToken(<span class="hljs-number"><span class="hljs-number">1.2</span></span>); Assert::AreEqual(TokenType::Number, numToken.Type()); }</code> <br>   .   (constant ‚Üí scalar)   . <br> <br> <code class="cpp">class Token { public: Token(Operator) :m_type(TokenType::Operator) {} Token(double) :m_type(TokenType::Number) {} TokenType Type() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_type; } private: TokenType m_type; };</code> <br> ‚Ä¶ <s>       </s> . <s>       </s> .        .        . <br>    . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); }</code> <br>            . <br> <br> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} operator Operator() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_operator; } ‚Ä¶ Operator m_operator; };</code> <br>      . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_number_value_from_number_token) { Token token(<span class="hljs-number"><span class="hljs-number">1.23</span></span>); Assert::AreEqual&lt;double&gt;(<span class="hljs-number"><span class="hljs-number">1.23</span></span>, token); }</code> <br>          ,  ,       <code>union</code> .         . <br> <br> <b class="spoiler_title">Token</b> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_type; } operator Operator() const { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(m_type != TokenType::Operator) throw std::logic_error(<span class="hljs-string"><span class="hljs-string">"Should be operator token."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_operator; } operator double() const { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(m_type != TokenType::Number) throw std::logic_error(<span class="hljs-string"><span class="hljs-string">"Should be number token."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_number; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ToString(static_cast&lt;Operator&gt;(token)); default: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Unknown token."</span></span>; } }</code> <br> <br>  ,    ,      ,    .       .    . <br> <br> <i>          .</i>               .            .       . <br>        : <br> <br> <code class="cpp"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(expr[<span class="hljs-number"><span class="hljs-number">0</span></span>] &gt;= <span class="hljs-string"><span class="hljs-string">'0'</span></span> &amp;&amp; expr[<span class="hljs-number"><span class="hljs-number">0</span></span>] &lt;= <span class="hljs-string"><span class="hljs-string">'9'</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ (double) expr[<span class="hljs-number"><span class="hljs-number">0</span></span>] - <span class="hljs-string"><span class="hljs-string">'0'</span></span> }; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ static_cast&lt;Operator&gt;(expr[<span class="hljs-number"><span class="hljs-number">0</span></span>]) };</code> <br>      ,   . <br> <br> ‚Ä¶ <s>          .</s> <i>              .</i> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"12.34"</span></span>); AssertRange::AreEqual({ <span class="hljs-number"><span class="hljs-number">12.34</span></span> }, tokens); }</code> <br> ,     <code>C</code>   ,  <code>isdigit</code> , ,       <code>atof</code> ,    ,      <code>wchar_t</code> .  (expression ‚Üí <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">)</span></span>.         . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { const wchar_t *current = expr.c_str(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!*current) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{}; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(iswdigit(*current)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ _wtof(current) }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ static_cast&lt;Operator&gt;(*current) }; }</code> <br>         .      . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"+12.34"</span></span>); AssertRange::AreEqual({ Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">12.34</span></span>) }, tokens); }</code> <br>   ,        .  ,     .     .   <code>result</code> ,     . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!*current) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(iswdigit(*current)) { result.push_back(_wtof(current)); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { result.push_back(static_cast&lt;Operator&gt;(*current)); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> <br>      :   (<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ‚Üí <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>).     ,        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(*current) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(iswdigit(*current)) { wchar_t *<span class="hljs-keyword"><span class="hljs-keyword">end</span></span> = nullptr; result.push_back(wcstod(current, &amp;<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>)); current = <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> <br>  <code>wcstod</code>    ,   <code>_wtof</code> ,           .           ,              .  ,    . <br> <br> <s>           .</s>       . <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">" 1 + 12.34 "</span></span>); AssertRange::AreEqual({ Token(<span class="hljs-number"><span class="hljs-number">1.0</span></span>), Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">12.34</span></span>) }, tokens); }</code> <br>  (unconditional ‚Üí <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>)    ,    . <br> <br> <code class="cpp"> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(*current) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(iswdigit(*current)) { wchar_t *<span class="hljs-keyword"><span class="hljs-keyword">end</span></span> = nullptr; result.push_back(wcstod(current, &amp;<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>)); current = <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(*current == static_cast&lt;wchar_t&gt;(Operator::Plus)) { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { ++current; } }</code> <br>       .          .       <code>Detail</code>      .   <code>Tokenize</code>       . <br> <br> <code class="cpp">inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tokenizer.Result(); }</code> <br> <b class="spoiler_title"> Detail::Tokenizer</b> <code class="cpp">namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!EndOfExperssion()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(IsNumber()) { ScanNumber(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(IsOperator()) { ScanOperator(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { MoveNext(); } } } const Tokens &amp;Result() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_result; } private: bool EndOfExperssion() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_current == L<span class="hljs-string"><span class="hljs-string">'\0'</span></span>; } bool IsNumber() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> iswdigit(*m_current) != <span class="hljs-number"><span class="hljs-number">0</span></span>; } void ScanNumber() { wchar_t *<span class="hljs-keyword"><span class="hljs-keyword">end</span></span> = nullptr; m_result.push_back(wcstod(m_current, &amp;<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>)); m_current = <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; } bool IsOperator() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_current == static_cast&lt;wchar_t&gt;(Operator::Plus); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail</code> <br> <br>  ,      .      ,  , .       . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"1+2*3/(4-5)"</span></span>); AssertRange::AreEqual({ Token(<span class="hljs-number"><span class="hljs-number">1</span></span>), Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">2</span></span>), Token(Operator::Mul), Token(<span class="hljs-number"><span class="hljs-number">3</span></span>), Token(Operator::Div), Token(Operator::LParen), Token(<span class="hljs-number"><span class="hljs-number">4</span></span>), Token(Operator::Minus), Token(<span class="hljs-number"><span class="hljs-number">5</span></span>), Token(Operator::RParen) }, tokens); }</code> <br>      <code>Operator</code> ,    . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L<span class="hljs-string"><span class="hljs-string">'+'</span></span>, Minus = L<span class="hljs-string"><span class="hljs-string">'-'</span></span>, Mul = L<span class="hljs-string"><span class="hljs-string">'*'</span></span>, Div = L<span class="hljs-string"><span class="hljs-string">'/'</span></span>, LParen = L<span class="hljs-string"><span class="hljs-string">'('</span></span>, RParen = L<span class="hljs-string"><span class="hljs-string">')'</span></span>, };</code> <br>   .         <code>IsOperator</code>  <code>Tokenizer</code> . <br> <br> <code class="cpp"> bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> std::any_of(all.begin(), all.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(), [this](Operator o) {<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_current == static_cast&lt;wchar_t&gt;(o); }); }</code> <br>         .        . <br> <br> <b class="spoiler_title">Interpreter.h</b> <code class="cpp">#pragma once; #include &lt;vector&gt; #include &lt;wchar.h&gt; #include &lt;algorithm&gt; namespace Interpreter { enum class Operator : wchar_t { Plus = L<span class="hljs-string"><span class="hljs-string">'+'</span></span>, Minus = L<span class="hljs-string"><span class="hljs-string">'-'</span></span>, Mul = L<span class="hljs-string"><span class="hljs-string">'*'</span></span>, Div = L<span class="hljs-string"><span class="hljs-string">'/'</span></span>, LParen = L<span class="hljs-string"><span class="hljs-string">'('</span></span>, RParen = L<span class="hljs-string"><span class="hljs-string">')'</span></span>, }; inline std::wstring ToString(const Operator &amp;op) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ static_cast&lt;wchar_t&gt;(op) }; } enum class TokenType { Operator, Number }; inline std::wstring ToString(const TokenType &amp;<span class="hljs-built_in"><span class="hljs-built_in">type</span></span>) { switch(<span class="hljs-built_in"><span class="hljs-built_in">type</span></span>) { case TokenType::Operator: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> L<span class="hljs-string"><span class="hljs-string">"Operator"</span></span>; case TokenType::Number: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> L<span class="hljs-string"><span class="hljs-string">"Number"</span></span>; default: throw std::out_of_range(<span class="hljs-string"><span class="hljs-string">"TokenType"</span></span>); } } class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_type; } operator Operator() const { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(m_type != TokenType::Operator) throw std::logic_error(<span class="hljs-string"><span class="hljs-string">"Should be operator token."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_operator; } operator double() const { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(m_type != TokenType::Number) throw std::logic_error(<span class="hljs-string"><span class="hljs-string">"Should be number token."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_number; } friend inline bool operator==(const Token &amp;left, const Token &amp;right) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(left.m_type == right.m_type) { switch(left.m_type) { case Interpreter::TokenType::Operator: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> left.m_operator == right.m_operator; case Interpreter::TokenType::Number: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> left.m_number == right.m_number; default: throw std::out_of_range(<span class="hljs-string"><span class="hljs-string">"TokenType"</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ToString(static_cast&lt;Operator&gt;(token)); default: throw std::out_of_range(<span class="hljs-string"><span class="hljs-string">"TokenType"</span></span>); } } typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!EndOfExperssion()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(IsNumber()) { ScanNumber(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(IsOperator()) { ScanOperator(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { MoveNext(); } } } const Tokens &amp;Result() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_result; } private: bool EndOfExperssion() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_current == L<span class="hljs-string"><span class="hljs-string">'\0'</span></span>; } bool IsNumber() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> iswdigit(*m_current) != <span class="hljs-number"><span class="hljs-number">0</span></span>; } void ScanNumber() { wchar_t *<span class="hljs-keyword"><span class="hljs-keyword">end</span></span> = nullptr; m_result.push_back(wcstod(m_current, &amp;<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>)); m_current = <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; } bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> std::any_of(all.begin(), all.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(), [this](Operator o) {<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_current == static_cast&lt;wchar_t&gt;(o); }); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tokenizer.Result(); } } // namespace Lexer } // namespace Interpreter</code> <br> <br> <b class="spoiler_title">InterpreterTests.cpp</b> <code class="cpp">#include <span class="hljs-string"><span class="hljs-string">"stdafx.h"</span></span> #include <span class="hljs-string"><span class="hljs-string">"CppUnitTest.h"</span></span> #include <span class="hljs-string"><span class="hljs-string">"Interpreter.h"</span></span> namespace InterpreterTests { using namespace Microsoft::VisualStudio::CppUnitTestFramework; using namespace Interpreter; using namespace std; namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(expect)), distance(actualIter, <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(actual)), L<span class="hljs-string"><span class="hljs-string">"Size differs."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(; expectIter != <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(expect) &amp;&amp; actualIter != <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(actual); ++expectIter, ++actualIter) { auto message = L<span class="hljs-string"><span class="hljs-string">"Mismatch in position "</span></span> + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual&lt;T&gt;(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange TEST_CLASS(LexerTests) { public: TEST_METHOD(Should_return_empty_token_list_when_put_empty_expression) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">""</span></span>); Assert::IsTrue(tokens.empty()); } TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"+"</span></span>); AssertRange::AreEqual({ Operator::Plus }, tokens); } TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"1"</span></span>); AssertRange::AreEqual({ <span class="hljs-number"><span class="hljs-number">1.0</span></span> }, tokens); } TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"12.34"</span></span>); AssertRange::AreEqual({ <span class="hljs-number"><span class="hljs-number">12.34</span></span> }, tokens); } TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"+12.34"</span></span>); AssertRange::AreEqual({ Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">12.34</span></span>) }, tokens); } TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">" 1 + 12.34 "</span></span>); AssertRange::AreEqual({ Token(<span class="hljs-number"><span class="hljs-number">1.0</span></span>), Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">12.34</span></span>) }, tokens); } TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"1+2*3/(4-5)"</span></span>); AssertRange::AreEqual({ Token(<span class="hljs-number"><span class="hljs-number">1</span></span>), Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">2</span></span>), Token(Operator::Mul), Token(<span class="hljs-number"><span class="hljs-number">3</span></span>), Token(Operator::Div), Token(Operator::LParen), Token(<span class="hljs-number"><span class="hljs-number">4</span></span>), Token(Operator::Minus), Token(<span class="hljs-number"><span class="hljs-number">5</span></span>), Token(Operator::RParen) }, tokens); } }; TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } TEST_METHOD(Should_get_type_for_number_token) { Token numToken(<span class="hljs-number"><span class="hljs-number">1.2</span></span>); Assert::AreEqual(TokenType::Number, numToken.Type()); } TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); } TEST_METHOD(Should_get_number_value_from_number_token) { Token token(<span class="hljs-number"><span class="hljs-number">1.23</span></span>); Assert::AreEqual&lt;double&gt;(<span class="hljs-number"><span class="hljs-number">1.23</span></span>, token); } }; }</code> <br> <br> <a href="https://github.com/Unril/InterpreterTDD/releases/tag/%25D0%259A%25D0%25BE%25D0%25BD%25D0%25B5%25D1%2586_%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B2%25D0%25BE%25D0%25B9_%25D1%2587%25D0%25B0%25D1%2581%25D1%2582%25D0%25B8">    GitHub</a> .         ,  .      <span class="hljs-string"><span class="hljs-string">"__"</span></span>. <br> <br>   <a href="http://habrahabr.ru/post/232081/">    </a> .      ,      <a href="http://habrahabr.ru/post/232097/">    </a> .</code> </pre> <code><code>std::vector,      Tokens</code> .            . <br> <br> <code class="cpp">#pragma once; #include &lt;vector&gt; namespace Interpreter { struct Token {}; typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { inline Tokens Tokenize(std::string expr) { throw std::exception(); } } // namespace Lexer } // namespace Interpreter</code> <br>   ,  ,   , .   ,    ,    <a href="http://cleancoder.posterous.com/the-transformation-priority-premise">The Transformation Priority Premise (TPP)</a>   .    , ,    ,     ,        .            .     ,     ,      ,           .  ,  ,   (   )    ,  ,  .     ,  ,         .     ,   TPP          . <br> <br>   : <br> <br> ({} ‚Üí nil)     ,   . (nil ‚Üí constant)    . (constant ‚Üí constant+)      (        ,  ). (constant ‚Üí scalar)    ,  . (statement ‚Üí statements)    (break, continue, return  ). (unconditional ‚Üí if)       . (scalar ‚Üí array)  / . (array ‚Üí container)     . (statement ‚Üí recursion)   . (if ‚Üí while)    . (expression ‚Üí function)   . (variable ‚Üí assignment)   . <br>        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::string expr) { return{}; }</code> <br> ,         .     . <br> <br> <s>         </s> .           .           .               .            .       . <br>  ,  <code>std::string</code>  <code>std::wstring</code> .         ,      Unicode.     . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); }</code> <br>  <code>AssertRange</code> -   ,       <code>AreEqual</code> ,   ,  ,    . <br> <br> <b class="spoiler_title">AssertRange</b> <code class="cpp">namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange</code> <br> <br>         <code>Operator</code>    .          <code>wchar_t</code>   ,         ,      . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', }; typedef Operator Token;</code> <br>    ,   ,        <code>Assert</code> ,    <code>ToString</code> ,    . <br> <br> <b class="spoiler_title">std::wstring ToString(const Token &amp;)</b> <code class="cpp">inline std::wstring ToString(const Token &amp;token) { return{ static_cast&lt;wchar_t&gt;(token) }; }</code> <br> <br>    ,   ,        .  ,   (unconditional ‚Üí if). <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { if(expr.empty()) { return{}; } return{ static_cast&lt;Operator&gt;(expr[0]) }; }</code> <br> <s>         </s> . <s>          .</s>           . ‚Ä¶ <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); }</code> <br>     .   ,     ,   - .    , : <br> <br>        ,      <code>Token</code> .       <code>dynamic_cast</code>    ,   .  ,    ,      .      <code>std::function</code>        .        .  Boost.Any,  - .            . <br>   ,   .      -  .  ,      ,      . <br> <br> ‚Ä¶        .        .        .        . <br>             . <br> <br> <code class="cpp">enum class TokenType { Operator, Number }; class Token { public: Token(Operator) {} TokenType Type() const { return TokenType::Operator; } }; ‚Ä¶ TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } };</code> <br>   <code>ToString</code>   <code>TokenType</code>       ,   ,   .     . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); }</code> <br>   .   (constant ‚Üí scalar)   . <br> <br> <code class="cpp">class Token { public: Token(Operator) :m_type(TokenType::Operator) {} Token(double) :m_type(TokenType::Number) {} TokenType Type() const { return m_type; } private: TokenType m_type; };</code> <br> ‚Ä¶ <s>       </s> . <s>       </s> .        .        . <br>    . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); }</code> <br>            . <br> <br> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} operator Operator() const { return m_operator; } ‚Ä¶ Operator m_operator; };</code> <br>      . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); }</code> <br>          ,  ,       <code>union</code> .         . <br> <br> <b class="spoiler_title">Token</b> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: return "Unknown token."; } }</code> <br> <br>  ,    ,      ,    .       .    . <br> <br> <i>          .</i>               .            .       . <br>        : <br> <br> <code class="cpp"> if(expr[0] &gt;= '0' &amp;&amp; expr[0] &lt;= '9') { return{ (double) expr[0] - '0' }; } return{ static_cast&lt;Operator&gt;(expr[0]) };</code> <br>      ,   . <br> <br> ‚Ä¶ <s>          .</s> <i>              .</i> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); }</code> <br> ,     <code>C</code>   ,  <code>isdigit</code> , ,       <code>atof</code> ,    ,      <code>wchar_t</code> .  (expression ‚Üí function).         . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { const wchar_t *current = expr.c_str(); if(!*current) return{}; if(iswdigit(*current)) return{ _wtof(current) }; return{ static_cast&lt;Operator&gt;(*current) }; }</code> <br>         .      . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>   ,        .  ,     .     .   <code>result</code> ,     . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); if(!*current) return result; if(iswdigit(*current)) { result.push_back(_wtof(current)); } else { result.push_back(static_cast&lt;Operator&gt;(*current)); } return result; }</code> <br>      :   (if ‚Üí while).     ,        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } } return result; }</code> <br>  <code>wcstod</code>    ,   <code>_wtof</code> ,           .           ,              .  ,    . <br> <br> <s>           .</s>       . <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>  (unconditional ‚Üí if)    ,    . <br> <br> <code class="cpp"> while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else if(*current == static_cast&lt;wchar_t&gt;(Operator::Plus)) { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } else { ++current; } }</code> <br>       .          .       <code>Detail</code>      .   <code>Tokenize</code>       . <br> <br> <code class="cpp">inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); }</code> <br> <b class="spoiler_title"> Detail::Tokenizer</b> <code class="cpp">namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { return *m_current == static_cast&lt;wchar_t&gt;(Operator::Plus); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail</code> <br> <br>  ,      .      ,  , .       . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); }</code> <br>      <code>Operator</code> ,    . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', };</code> <br>   .         <code>IsOperator</code>  <code>Tokenizer</code> . <br> <br> <code class="cpp"> bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); }</code> <br>         .        . <br> <br> <b class="spoiler_title">Interpreter.h</b> <code class="cpp">#pragma once; #include &lt;vector&gt; #include &lt;wchar.h&gt; #include &lt;algorithm&gt; namespace Interpreter { enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', }; inline std::wstring ToString(const Operator &amp;op) { return{ static_cast&lt;wchar_t&gt;(op) }; } enum class TokenType { Operator, Number }; inline std::wstring ToString(const TokenType &amp;type) { switch(type) { case TokenType::Operator: return L"Operator"; case TokenType::Number: return L"Number"; default: throw std::out_of_range("TokenType"); } } class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } friend inline bool operator==(const Token &amp;left, const Token &amp;right) { if(left.m_type == right.m_type) { switch(left.m_type) { case Interpreter::TokenType::Operator: return left.m_operator == right.m_operator; case Interpreter::TokenType::Number: return left.m_number == right.m_number; default: throw std::out_of_range("TokenType"); } } return false; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: throw std::out_of_range("TokenType"); } } typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); } } // namespace Lexer } // namespace Interpreter</code> <br> <br> <b class="spoiler_title">InterpreterTests.cpp</b> <code class="cpp">#include "stdafx.h" #include "CppUnitTest.h" #include "Interpreter.h" namespace InterpreterTests { using namespace Microsoft::VisualStudio::CppUnitTestFramework; using namespace Interpreter; using namespace std; namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual&lt;T&gt;(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange TEST_CLASS(LexerTests) { public: TEST_METHOD(Should_return_empty_token_list_when_put_empty_expression) { Tokens tokens = Lexer::Tokenize(L""); Assert::IsTrue(tokens.empty()); } TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); } TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); } TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); } TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); } }; TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); } TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); } TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); } }; }</code> <br> <br> <a href="https://github.com/Unril/InterpreterTDD/releases/tag/%25D0%259A%25D0%25BE%25D0%25BD%25D0%25B5%25D1%2586_%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B2%25D0%25BE%25D0%25B9_%25D1%2587%25D0%25B0%25D1%2581%25D1%2582%25D0%25B8">    GitHub</a> .         ,  .      "__". <br> <br>   <a href="http://habrahabr.ru/post/232081/">    </a> .      ,      <a href="http://habrahabr.ru/post/232097/">    </a> .</code> </div></div> <code><code>std::vector,      Tokens</code> .            . <br> <br> <code class="cpp">#pragma once; #include &lt;vector&gt; namespace Interpreter { struct Token {}; typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { inline Tokens Tokenize(std::string expr) { throw std::exception(); } } // namespace Lexer } // namespace Interpreter</code> <br>   ,  ,   , .   ,    ,    <a href="http://cleancoder.posterous.com/the-transformation-priority-premise">The Transformation Priority Premise (TPP)</a>   .    , ,    ,     ,        .            .     ,     ,      ,           .  ,  ,   (   )    ,  ,  .     ,  ,         .     ,   TPP          . <br> <br>   : <br> <br> ({} ‚Üí nil)     ,   . (nil ‚Üí constant)    . (constant ‚Üí constant+)      (        ,  ). (constant ‚Üí scalar)    ,  . (statement ‚Üí statements)    (break, continue, return  ). (unconditional ‚Üí if)       . (scalar ‚Üí array)  / . (array ‚Üí container)     . (statement ‚Üí recursion)   . (if ‚Üí while)    . (expression ‚Üí function)   . (variable ‚Üí assignment)   . <br>        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::string expr) { return{}; }</code> <br> ,         .     . <br> <br> <s>         </s> .           .           .               .            .       . <br>  ,  <code>std::string</code>  <code>std::wstring</code> .         ,      Unicode.     . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); }</code> <br>  <code>AssertRange</code> -   ,       <code>AreEqual</code> ,   ,  ,    . <br> <br> <b class="spoiler_title">AssertRange</b> <code class="cpp">namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange</code> <br> <br>         <code>Operator</code>    .          <code>wchar_t</code>   ,         ,      . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', }; typedef Operator Token;</code> <br>    ,   ,        <code>Assert</code> ,    <code>ToString</code> ,    . <br> <br> <b class="spoiler_title">std::wstring ToString(const Token &amp;)</b> <code class="cpp">inline std::wstring ToString(const Token &amp;token) { return{ static_cast&lt;wchar_t&gt;(token) }; }</code> <br> <br>    ,   ,        .  ,   (unconditional ‚Üí if). <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { if(expr.empty()) { return{}; } return{ static_cast&lt;Operator&gt;(expr[0]) }; }</code> <br> <s>         </s> . <s>          .</s>           . ‚Ä¶ <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); }</code> <br>     .   ,     ,   - .    , : <br> <br>        ,      <code>Token</code> .       <code>dynamic_cast</code>    ,   .  ,    ,      .      <code>std::function</code>        .        .  Boost.Any,  - .            . <br>   ,   .      -  .  ,      ,      . <br> <br> ‚Ä¶        .        .        .        . <br>             . <br> <br> <code class="cpp">enum class TokenType { Operator, Number }; class Token { public: Token(Operator) {} TokenType Type() const { return TokenType::Operator; } }; ‚Ä¶ TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } };</code> <br>   <code>ToString</code>   <code>TokenType</code>       ,   ,   .     . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); }</code> <br>   .   (constant ‚Üí scalar)   . <br> <br> <code class="cpp">class Token { public: Token(Operator) :m_type(TokenType::Operator) {} Token(double) :m_type(TokenType::Number) {} TokenType Type() const { return m_type; } private: TokenType m_type; };</code> <br> ‚Ä¶ <s>       </s> . <s>       </s> .        .        . <br>    . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); }</code> <br>            . <br> <br> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} operator Operator() const { return m_operator; } ‚Ä¶ Operator m_operator; };</code> <br>      . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); }</code> <br>          ,  ,       <code>union</code> .         . <br> <br> <b class="spoiler_title">Token</b> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: return "Unknown token."; } }</code> <br> <br>  ,    ,      ,    .       .    . <br> <br> <i>          .</i>               .            .       . <br>        : <br> <br> <code class="cpp"> if(expr[0] &gt;= '0' &amp;&amp; expr[0] &lt;= '9') { return{ (double) expr[0] - '0' }; } return{ static_cast&lt;Operator&gt;(expr[0]) };</code> <br>      ,   . <br> <br> ‚Ä¶ <s>          .</s> <i>              .</i> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); }</code> <br> ,     <code>C</code>   ,  <code>isdigit</code> , ,       <code>atof</code> ,    ,      <code>wchar_t</code> .  (expression ‚Üí function).         . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { const wchar_t *current = expr.c_str(); if(!*current) return{}; if(iswdigit(*current)) return{ _wtof(current) }; return{ static_cast&lt;Operator&gt;(*current) }; }</code> <br>         .      . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>   ,        .  ,     .     .   <code>result</code> ,     . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); if(!*current) return result; if(iswdigit(*current)) { result.push_back(_wtof(current)); } else { result.push_back(static_cast&lt;Operator&gt;(*current)); } return result; }</code> <br>      :   (if ‚Üí while).     ,        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } } return result; }</code> <br>  <code>wcstod</code>    ,   <code>_wtof</code> ,           .           ,              .  ,    . <br> <br> <s>           .</s>       . <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>  (unconditional ‚Üí if)    ,    . <br> <br> <code class="cpp"> while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else if(*current == static_cast&lt;wchar_t&gt;(Operator::Plus)) { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } else { ++current; } }</code> <br>       .          .       <code>Detail</code>      .   <code>Tokenize</code>       . <br> <br> <code class="cpp">inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); }</code> <br> <b class="spoiler_title"> Detail::Tokenizer</b> <code class="cpp">namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { return *m_current == static_cast&lt;wchar_t&gt;(Operator::Plus); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail</code> <br> <br>  ,      .      ,  , .       . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); }</code> <br>      <code>Operator</code> ,    . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', };</code> <br>   .         <code>IsOperator</code>  <code>Tokenizer</code> . <br> <br> <code class="cpp"> bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); }</code> <br>         .        . <br> <br> <b class="spoiler_title">Interpreter.h</b> <code class="cpp">#pragma once; #include &lt;vector&gt; #include &lt;wchar.h&gt; #include &lt;algorithm&gt; namespace Interpreter { enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', }; inline std::wstring ToString(const Operator &amp;op) { return{ static_cast&lt;wchar_t&gt;(op) }; } enum class TokenType { Operator, Number }; inline std::wstring ToString(const TokenType &amp;type) { switch(type) { case TokenType::Operator: return L"Operator"; case TokenType::Number: return L"Number"; default: throw std::out_of_range("TokenType"); } } class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } friend inline bool operator==(const Token &amp;left, const Token &amp;right) { if(left.m_type == right.m_type) { switch(left.m_type) { case Interpreter::TokenType::Operator: return left.m_operator == right.m_operator; case Interpreter::TokenType::Number: return left.m_number == right.m_number; default: throw std::out_of_range("TokenType"); } } return false; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: throw std::out_of_range("TokenType"); } } typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); } } // namespace Lexer } // namespace Interpreter</code> <br> <br> <b class="spoiler_title">InterpreterTests.cpp</b> <code class="cpp">#include "stdafx.h" #include "CppUnitTest.h" #include "Interpreter.h" namespace InterpreterTests { using namespace Microsoft::VisualStudio::CppUnitTestFramework; using namespace Interpreter; using namespace std; namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual&lt;T&gt;(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange TEST_CLASS(LexerTests) { public: TEST_METHOD(Should_return_empty_token_list_when_put_empty_expression) { Tokens tokens = Lexer::Tokenize(L""); Assert::IsTrue(tokens.empty()); } TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); } TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); } TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); } TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); } }; TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); } TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); } TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); } }; }</code> <br> <br> <a href="https://github.com/Unril/InterpreterTDD/releases/tag/%25D0%259A%25D0%25BE%25D0%25BD%25D0%25B5%25D1%2586_%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B2%25D0%25BE%25D0%25B9_%25D1%2587%25D0%25B0%25D1%2581%25D1%2582%25D0%25B8">    GitHub</a> .         ,  .      "__". <br> <br>   <a href="http://habrahabr.ru/post/232081/">    </a> .      ,      <a href="http://habrahabr.ru/post/232097/">    </a> .</code> <pre> <code class="hljs lua"><code>std::vector,      Tokens</code> .            . <br> <br> <code class="cpp">#pragma once; #include &lt;vector&gt; namespace Interpreter { struct Token {}; typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { inline Tokens Tokenize(std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> expr) { throw std::exception(); } } // namespace Lexer } // namespace Interpreter</code> <br>   ,  ,   , .   ,    ,    <a href="http://cleancoder.posterous.com/the-transformation-priority-premise">The Transformation Priority Premise (TPP)</a>   .    , ,    ,     ,        .            .     ,     ,      ,           .  ,  ,   (   )    ,  ,  .     ,  ,         .     ,   TPP          . <br> <br>   : <br> <br> ({} ‚Üí <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)     ,   . (<span class="hljs-literal"><span class="hljs-literal">nil</span></span> ‚Üí constant)    . (constant ‚Üí constant+)      (        ,  ). (constant ‚Üí scalar)    ,  . (statement ‚Üí statements)    (<span class="hljs-keyword"><span class="hljs-keyword">break</span></span>, continue, <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>  ). (unconditional ‚Üí <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>)       . (scalar ‚Üí array)  / . (array ‚Üí container)     . (statement ‚Üí recursion)   . (<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ‚Üí <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>)    . (expression ‚Üí <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">)</span></span>   . (variable ‚Üí assignment)   . <br>        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> expr) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{}; }</code> <br> ,         .     . <br> <br> <s>         </s> .           .           .               .            .       . <br>  ,  <code>std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span></code>  <code>std::wstring</code> .         ,      Unicode.     . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"+"</span></span>); AssertRange::AreEqual({ Operator::Plus }, tokens); }</code> <br>  <code>AssertRange</code> -   ,       <code>AreEqual</code> ,   ,  ,    . <br> <br> <b class="spoiler_title">AssertRange</b> <code class="cpp">namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(expect)), distance(actualIter, <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(actual)), L<span class="hljs-string"><span class="hljs-string">"Size differs."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(; expectIter != <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(expect) &amp;&amp; actualIter != <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(actual); ++expectIter, ++actualIter) { auto message = L<span class="hljs-string"><span class="hljs-string">"Mismatch in position "</span></span> + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange</code> <br> <br>         <code>Operator</code>    .          <code>wchar_t</code>   ,         ,      . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L<span class="hljs-string"><span class="hljs-string">'+'</span></span>, }; typedef Operator Token;</code> <br>    ,   ,        <code>Assert</code> ,    <code>ToString</code> ,    . <br> <br> <b class="spoiler_title">std::wstring ToString(const Token &amp;)</b> <code class="cpp">inline std::wstring ToString(const Token &amp;token) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ static_cast&lt;wchar_t&gt;(token) }; }</code> <br> <br>    ,   ,        .  ,   (unconditional ‚Üí <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>). <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(expr.empty()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{}; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ static_cast&lt;Operator&gt;(expr[<span class="hljs-number"><span class="hljs-number">0</span></span>]) }; }</code> <br> <s>         </s> . <s>          .</s>           . ‚Ä¶ <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"1"</span></span>); AssertRange::AreEqual({ <span class="hljs-number"><span class="hljs-number">1.0</span></span> }, tokens); }</code> <br>     .   ,     ,   - .    , : <br> <br>        ,      <code>Token</code> .       <code>dynamic_cast</code>    ,   .  ,    ,      .      <code>std::<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span></span></code><span class="hljs-function"><span class="hljs-function">        .        .  </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Boost.Any</span></span></span><span class="hljs-function">,  - .            . </span></span><br><span class="hljs-function"><span class="hljs-function">   ,   .      -  .  ,      ,      . </span></span><br><span class="hljs-function"><span class="hljs-function"> </span></span><br><span class="hljs-function"><span class="hljs-function"> ‚Ä¶        .        .        .        . </span></span><br><span class="hljs-function"><span class="hljs-function">             . </span></span><br><span class="hljs-function"><span class="hljs-function"> </span></span><br><span class="hljs-function"><span class="hljs-function"> </span></span><code class="cpp"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">enum</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">class</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TokenType</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Operator</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Number</span></span></span><span class="hljs-function"> }; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">class</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Token</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">public</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Token</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Operator)</span></span></span></span> {} TokenType Type() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TokenType::Operator; } }; ‚Ä¶ TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } };</code> <br>   <code>ToString</code>   <code>TokenType</code>       ,   ,   .     . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_type_for_number_token) { Token numToken(<span class="hljs-number"><span class="hljs-number">1.2</span></span>); Assert::AreEqual(TokenType::Number, numToken.Type()); }</code> <br>   .   (constant ‚Üí scalar)   . <br> <br> <code class="cpp">class Token { public: Token(Operator) :m_type(TokenType::Operator) {} Token(double) :m_type(TokenType::Number) {} TokenType Type() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_type; } private: TokenType m_type; };</code> <br> ‚Ä¶ <s>       </s> . <s>       </s> .        .        . <br>    . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); }</code> <br>            . <br> <br> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} operator Operator() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_operator; } ‚Ä¶ Operator m_operator; };</code> <br>      . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_number_value_from_number_token) { Token token(<span class="hljs-number"><span class="hljs-number">1.23</span></span>); Assert::AreEqual&lt;double&gt;(<span class="hljs-number"><span class="hljs-number">1.23</span></span>, token); }</code> <br>          ,  ,       <code>union</code> .         . <br> <br> <b class="spoiler_title">Token</b> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_type; } operator Operator() const { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(m_type != TokenType::Operator) throw std::logic_error(<span class="hljs-string"><span class="hljs-string">"Should be operator token."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_operator; } operator double() const { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(m_type != TokenType::Number) throw std::logic_error(<span class="hljs-string"><span class="hljs-string">"Should be number token."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_number; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ToString(static_cast&lt;Operator&gt;(token)); default: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Unknown token."</span></span>; } }</code> <br> <br>  ,    ,      ,    .       .    . <br> <br> <i>          .</i>               .            .       . <br>        : <br> <br> <code class="cpp"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(expr[<span class="hljs-number"><span class="hljs-number">0</span></span>] &gt;= <span class="hljs-string"><span class="hljs-string">'0'</span></span> &amp;&amp; expr[<span class="hljs-number"><span class="hljs-number">0</span></span>] &lt;= <span class="hljs-string"><span class="hljs-string">'9'</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ (double) expr[<span class="hljs-number"><span class="hljs-number">0</span></span>] - <span class="hljs-string"><span class="hljs-string">'0'</span></span> }; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ static_cast&lt;Operator&gt;(expr[<span class="hljs-number"><span class="hljs-number">0</span></span>]) };</code> <br>      ,   . <br> <br> ‚Ä¶ <s>          .</s> <i>              .</i> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"12.34"</span></span>); AssertRange::AreEqual({ <span class="hljs-number"><span class="hljs-number">12.34</span></span> }, tokens); }</code> <br> ,     <code>C</code>   ,  <code>isdigit</code> , ,       <code>atof</code> ,    ,      <code>wchar_t</code> .  (expression ‚Üí <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">)</span></span>.         . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { const wchar_t *current = expr.c_str(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!*current) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{}; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(iswdigit(*current)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ _wtof(current) }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ static_cast&lt;Operator&gt;(*current) }; }</code> <br>         .      . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"+12.34"</span></span>); AssertRange::AreEqual({ Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">12.34</span></span>) }, tokens); }</code> <br>   ,        .  ,     .     .   <code>result</code> ,     . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!*current) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(iswdigit(*current)) { result.push_back(_wtof(current)); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { result.push_back(static_cast&lt;Operator&gt;(*current)); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> <br>      :   (<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ‚Üí <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>).     ,        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(*current) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(iswdigit(*current)) { wchar_t *<span class="hljs-keyword"><span class="hljs-keyword">end</span></span> = nullptr; result.push_back(wcstod(current, &amp;<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>)); current = <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> <br>  <code>wcstod</code>    ,   <code>_wtof</code> ,           .           ,              .  ,    . <br> <br> <s>           .</s>       . <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">" 1 + 12.34 "</span></span>); AssertRange::AreEqual({ Token(<span class="hljs-number"><span class="hljs-number">1.0</span></span>), Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">12.34</span></span>) }, tokens); }</code> <br>  (unconditional ‚Üí <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>)    ,    . <br> <br> <code class="cpp"> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(*current) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(iswdigit(*current)) { wchar_t *<span class="hljs-keyword"><span class="hljs-keyword">end</span></span> = nullptr; result.push_back(wcstod(current, &amp;<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>)); current = <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(*current == static_cast&lt;wchar_t&gt;(Operator::Plus)) { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { ++current; } }</code> <br>       .          .       <code>Detail</code>      .   <code>Tokenize</code>       . <br> <br> <code class="cpp">inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tokenizer.Result(); }</code> <br> <b class="spoiler_title"> Detail::Tokenizer</b> <code class="cpp">namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!EndOfExperssion()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(IsNumber()) { ScanNumber(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(IsOperator()) { ScanOperator(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { MoveNext(); } } } const Tokens &amp;Result() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_result; } private: bool EndOfExperssion() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_current == L<span class="hljs-string"><span class="hljs-string">'\0'</span></span>; } bool IsNumber() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> iswdigit(*m_current) != <span class="hljs-number"><span class="hljs-number">0</span></span>; } void ScanNumber() { wchar_t *<span class="hljs-keyword"><span class="hljs-keyword">end</span></span> = nullptr; m_result.push_back(wcstod(m_current, &amp;<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>)); m_current = <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; } bool IsOperator() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_current == static_cast&lt;wchar_t&gt;(Operator::Plus); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail</code> <br> <br>  ,      .      ,  , .       . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"1+2*3/(4-5)"</span></span>); AssertRange::AreEqual({ Token(<span class="hljs-number"><span class="hljs-number">1</span></span>), Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">2</span></span>), Token(Operator::Mul), Token(<span class="hljs-number"><span class="hljs-number">3</span></span>), Token(Operator::Div), Token(Operator::LParen), Token(<span class="hljs-number"><span class="hljs-number">4</span></span>), Token(Operator::Minus), Token(<span class="hljs-number"><span class="hljs-number">5</span></span>), Token(Operator::RParen) }, tokens); }</code> <br>      <code>Operator</code> ,    . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L<span class="hljs-string"><span class="hljs-string">'+'</span></span>, Minus = L<span class="hljs-string"><span class="hljs-string">'-'</span></span>, Mul = L<span class="hljs-string"><span class="hljs-string">'*'</span></span>, Div = L<span class="hljs-string"><span class="hljs-string">'/'</span></span>, LParen = L<span class="hljs-string"><span class="hljs-string">'('</span></span>, RParen = L<span class="hljs-string"><span class="hljs-string">')'</span></span>, };</code> <br>   .         <code>IsOperator</code>  <code>Tokenizer</code> . <br> <br> <code class="cpp"> bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> std::any_of(all.begin(), all.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(), [this](Operator o) {<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_current == static_cast&lt;wchar_t&gt;(o); }); }</code> <br>         .        . <br> <br> <b class="spoiler_title">Interpreter.h</b> <code class="cpp">#pragma once; #include &lt;vector&gt; #include &lt;wchar.h&gt; #include &lt;algorithm&gt; namespace Interpreter { enum class Operator : wchar_t { Plus = L<span class="hljs-string"><span class="hljs-string">'+'</span></span>, Minus = L<span class="hljs-string"><span class="hljs-string">'-'</span></span>, Mul = L<span class="hljs-string"><span class="hljs-string">'*'</span></span>, Div = L<span class="hljs-string"><span class="hljs-string">'/'</span></span>, LParen = L<span class="hljs-string"><span class="hljs-string">'('</span></span>, RParen = L<span class="hljs-string"><span class="hljs-string">')'</span></span>, }; inline std::wstring ToString(const Operator &amp;op) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ static_cast&lt;wchar_t&gt;(op) }; } enum class TokenType { Operator, Number }; inline std::wstring ToString(const TokenType &amp;<span class="hljs-built_in"><span class="hljs-built_in">type</span></span>) { switch(<span class="hljs-built_in"><span class="hljs-built_in">type</span></span>) { case TokenType::Operator: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> L<span class="hljs-string"><span class="hljs-string">"Operator"</span></span>; case TokenType::Number: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> L<span class="hljs-string"><span class="hljs-string">"Number"</span></span>; default: throw std::out_of_range(<span class="hljs-string"><span class="hljs-string">"TokenType"</span></span>); } } class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_type; } operator Operator() const { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(m_type != TokenType::Operator) throw std::logic_error(<span class="hljs-string"><span class="hljs-string">"Should be operator token."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_operator; } operator double() const { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(m_type != TokenType::Number) throw std::logic_error(<span class="hljs-string"><span class="hljs-string">"Should be number token."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_number; } friend inline bool operator==(const Token &amp;left, const Token &amp;right) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(left.m_type == right.m_type) { switch(left.m_type) { case Interpreter::TokenType::Operator: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> left.m_operator == right.m_operator; case Interpreter::TokenType::Number: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> left.m_number == right.m_number; default: throw std::out_of_range(<span class="hljs-string"><span class="hljs-string">"TokenType"</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ToString(static_cast&lt;Operator&gt;(token)); default: throw std::out_of_range(<span class="hljs-string"><span class="hljs-string">"TokenType"</span></span>); } } typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!EndOfExperssion()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(IsNumber()) { ScanNumber(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(IsOperator()) { ScanOperator(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { MoveNext(); } } } const Tokens &amp;Result() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_result; } private: bool EndOfExperssion() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_current == L<span class="hljs-string"><span class="hljs-string">'\0'</span></span>; } bool IsNumber() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> iswdigit(*m_current) != <span class="hljs-number"><span class="hljs-number">0</span></span>; } void ScanNumber() { wchar_t *<span class="hljs-keyword"><span class="hljs-keyword">end</span></span> = nullptr; m_result.push_back(wcstod(m_current, &amp;<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>)); m_current = <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; } bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> std::any_of(all.begin(), all.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(), [this](Operator o) {<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_current == static_cast&lt;wchar_t&gt;(o); }); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tokenizer.Result(); } } // namespace Lexer } // namespace Interpreter</code> <br> <br> <b class="spoiler_title">InterpreterTests.cpp</b> <code class="cpp">#include <span class="hljs-string"><span class="hljs-string">"stdafx.h"</span></span> #include <span class="hljs-string"><span class="hljs-string">"CppUnitTest.h"</span></span> #include <span class="hljs-string"><span class="hljs-string">"Interpreter.h"</span></span> namespace InterpreterTests { using namespace Microsoft::VisualStudio::CppUnitTestFramework; using namespace Interpreter; using namespace std; namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(expect)), distance(actualIter, <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(actual)), L<span class="hljs-string"><span class="hljs-string">"Size differs."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(; expectIter != <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(expect) &amp;&amp; actualIter != <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(actual); ++expectIter, ++actualIter) { auto message = L<span class="hljs-string"><span class="hljs-string">"Mismatch in position "</span></span> + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual&lt;T&gt;(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange TEST_CLASS(LexerTests) { public: TEST_METHOD(Should_return_empty_token_list_when_put_empty_expression) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">""</span></span>); Assert::IsTrue(tokens.empty()); } TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"+"</span></span>); AssertRange::AreEqual({ Operator::Plus }, tokens); } TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"1"</span></span>); AssertRange::AreEqual({ <span class="hljs-number"><span class="hljs-number">1.0</span></span> }, tokens); } TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"12.34"</span></span>); AssertRange::AreEqual({ <span class="hljs-number"><span class="hljs-number">12.34</span></span> }, tokens); } TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"+12.34"</span></span>); AssertRange::AreEqual({ Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">12.34</span></span>) }, tokens); } TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">" 1 + 12.34 "</span></span>); AssertRange::AreEqual({ Token(<span class="hljs-number"><span class="hljs-number">1.0</span></span>), Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">12.34</span></span>) }, tokens); } TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"1+2*3/(4-5)"</span></span>); AssertRange::AreEqual({ Token(<span class="hljs-number"><span class="hljs-number">1</span></span>), Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">2</span></span>), Token(Operator::Mul), Token(<span class="hljs-number"><span class="hljs-number">3</span></span>), Token(Operator::Div), Token(Operator::LParen), Token(<span class="hljs-number"><span class="hljs-number">4</span></span>), Token(Operator::Minus), Token(<span class="hljs-number"><span class="hljs-number">5</span></span>), Token(Operator::RParen) }, tokens); } }; TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } TEST_METHOD(Should_get_type_for_number_token) { Token numToken(<span class="hljs-number"><span class="hljs-number">1.2</span></span>); Assert::AreEqual(TokenType::Number, numToken.Type()); } TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); } TEST_METHOD(Should_get_number_value_from_number_token) { Token token(<span class="hljs-number"><span class="hljs-number">1.23</span></span>); Assert::AreEqual&lt;double&gt;(<span class="hljs-number"><span class="hljs-number">1.23</span></span>, token); } }; }</code> <br> <br> <a href="https://github.com/Unril/InterpreterTDD/releases/tag/%25D0%259A%25D0%25BE%25D0%25BD%25D0%25B5%25D1%2586_%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B2%25D0%25BE%25D0%25B9_%25D1%2587%25D0%25B0%25D1%2581%25D1%2582%25D0%25B8">    GitHub</a> .         ,  .      <span class="hljs-string"><span class="hljs-string">"__"</span></span>. <br> <br>   <a href="http://habrahabr.ru/post/232081/">    </a> .      ,      <a href="http://habrahabr.ru/post/232097/">    </a> .</code> </pre> <code><code>std::vector,      Tokens</code> .            . <br> <br> <code class="cpp">#pragma once; #include &lt;vector&gt; namespace Interpreter { struct Token {}; typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { inline Tokens Tokenize(std::string expr) { throw std::exception(); } } // namespace Lexer } // namespace Interpreter</code> <br>   ,  ,   , .   ,    ,    <a href="http://cleancoder.posterous.com/the-transformation-priority-premise">The Transformation Priority Premise (TPP)</a>   .    , ,    ,     ,        .            .     ,     ,      ,           .  ,  ,   (   )    ,  ,  .     ,  ,         .     ,   TPP          . <br> <br>   : <br> <br> ({} ‚Üí nil)     ,   . (nil ‚Üí constant)    . (constant ‚Üí constant+)      (        ,  ). (constant ‚Üí scalar)    ,  . (statement ‚Üí statements)    (break, continue, return  ). (unconditional ‚Üí if)       . (scalar ‚Üí array)  / . (array ‚Üí container)     . (statement ‚Üí recursion)   . (if ‚Üí while)    . (expression ‚Üí function)   . (variable ‚Üí assignment)   . <br>        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::string expr) { return{}; }</code> <br> ,         .     . <br> <br> <s>         </s> .           .           .               .            .       . <br>  ,  <code>std::string</code>  <code>std::wstring</code> .         ,      Unicode.     . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); }</code> <br>  <code>AssertRange</code> -   ,       <code>AreEqual</code> ,   ,  ,    . <br> <br> <b class="spoiler_title">AssertRange</b> <code class="cpp">namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange</code> <br> <br>         <code>Operator</code>    .          <code>wchar_t</code>   ,         ,      . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', }; typedef Operator Token;</code> <br>    ,   ,        <code>Assert</code> ,    <code>ToString</code> ,    . <br> <br> <b class="spoiler_title">std::wstring ToString(const Token &amp;)</b> <code class="cpp">inline std::wstring ToString(const Token &amp;token) { return{ static_cast&lt;wchar_t&gt;(token) }; }</code> <br> <br>    ,   ,        .  ,   (unconditional ‚Üí if). <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { if(expr.empty()) { return{}; } return{ static_cast&lt;Operator&gt;(expr[0]) }; }</code> <br> <s>         </s> . <s>          .</s>           . ‚Ä¶ <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); }</code> <br>     .   ,     ,   - .    , : <br> <br>        ,      <code>Token</code> .       <code>dynamic_cast</code>    ,   .  ,    ,      .      <code>std::function</code>        .        .  Boost.Any,  - .            . <br>   ,   .      -  .  ,      ,      . <br> <br> ‚Ä¶        .        .        .        . <br>             . <br> <br> <code class="cpp">enum class TokenType { Operator, Number }; class Token { public: Token(Operator) {} TokenType Type() const { return TokenType::Operator; } }; ‚Ä¶ TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } };</code> <br>   <code>ToString</code>   <code>TokenType</code>       ,   ,   .     . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); }</code> <br>   .   (constant ‚Üí scalar)   . <br> <br> <code class="cpp">class Token { public: Token(Operator) :m_type(TokenType::Operator) {} Token(double) :m_type(TokenType::Number) {} TokenType Type() const { return m_type; } private: TokenType m_type; };</code> <br> ‚Ä¶ <s>       </s> . <s>       </s> .        .        . <br>    . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); }</code> <br>            . <br> <br> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} operator Operator() const { return m_operator; } ‚Ä¶ Operator m_operator; };</code> <br>      . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); }</code> <br>          ,  ,       <code>union</code> .         . <br> <br> <b class="spoiler_title">Token</b> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: return "Unknown token."; } }</code> <br> <br>  ,    ,      ,    .       .    . <br> <br> <i>          .</i>               .            .       . <br>        : <br> <br> <code class="cpp"> if(expr[0] &gt;= '0' &amp;&amp; expr[0] &lt;= '9') { return{ (double) expr[0] - '0' }; } return{ static_cast&lt;Operator&gt;(expr[0]) };</code> <br>      ,   . <br> <br> ‚Ä¶ <s>          .</s> <i>              .</i> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); }</code> <br> ,     <code>C</code>   ,  <code>isdigit</code> , ,       <code>atof</code> ,    ,      <code>wchar_t</code> .  (expression ‚Üí function).         . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { const wchar_t *current = expr.c_str(); if(!*current) return{}; if(iswdigit(*current)) return{ _wtof(current) }; return{ static_cast&lt;Operator&gt;(*current) }; }</code> <br>         .      . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>   ,        .  ,     .     .   <code>result</code> ,     . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); if(!*current) return result; if(iswdigit(*current)) { result.push_back(_wtof(current)); } else { result.push_back(static_cast&lt;Operator&gt;(*current)); } return result; }</code> <br>      :   (if ‚Üí while).     ,        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } } return result; }</code> <br>  <code>wcstod</code>    ,   <code>_wtof</code> ,           .           ,              .  ,    . <br> <br> <s>           .</s>       . <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>  (unconditional ‚Üí if)    ,    . <br> <br> <code class="cpp"> while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else if(*current == static_cast&lt;wchar_t&gt;(Operator::Plus)) { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } else { ++current; } }</code> <br>       .          .       <code>Detail</code>      .   <code>Tokenize</code>       . <br> <br> <code class="cpp">inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); }</code> <br> <b class="spoiler_title"> Detail::Tokenizer</b> <code class="cpp">namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { return *m_current == static_cast&lt;wchar_t&gt;(Operator::Plus); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail</code> <br> <br>  ,      .      ,  , .       . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); }</code> <br>      <code>Operator</code> ,    . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', };</code> <br>   .         <code>IsOperator</code>  <code>Tokenizer</code> . <br> <br> <code class="cpp"> bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); }</code> <br>         .        . <br> <br> <b class="spoiler_title">Interpreter.h</b> <code class="cpp">#pragma once; #include &lt;vector&gt; #include &lt;wchar.h&gt; #include &lt;algorithm&gt; namespace Interpreter { enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', }; inline std::wstring ToString(const Operator &amp;op) { return{ static_cast&lt;wchar_t&gt;(op) }; } enum class TokenType { Operator, Number }; inline std::wstring ToString(const TokenType &amp;type) { switch(type) { case TokenType::Operator: return L"Operator"; case TokenType::Number: return L"Number"; default: throw std::out_of_range("TokenType"); } } class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } friend inline bool operator==(const Token &amp;left, const Token &amp;right) { if(left.m_type == right.m_type) { switch(left.m_type) { case Interpreter::TokenType::Operator: return left.m_operator == right.m_operator; case Interpreter::TokenType::Number: return left.m_number == right.m_number; default: throw std::out_of_range("TokenType"); } } return false; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: throw std::out_of_range("TokenType"); } } typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); } } // namespace Lexer } // namespace Interpreter</code> <br> <br> <b class="spoiler_title">InterpreterTests.cpp</b> <code class="cpp">#include "stdafx.h" #include "CppUnitTest.h" #include "Interpreter.h" namespace InterpreterTests { using namespace Microsoft::VisualStudio::CppUnitTestFramework; using namespace Interpreter; using namespace std; namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual&lt;T&gt;(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange TEST_CLASS(LexerTests) { public: TEST_METHOD(Should_return_empty_token_list_when_put_empty_expression) { Tokens tokens = Lexer::Tokenize(L""); Assert::IsTrue(tokens.empty()); } TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); } TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); } TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); } TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); } }; TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); } TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); } TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); } }; }</code> <br> <br> <a href="https://github.com/Unril/InterpreterTDD/releases/tag/%25D0%259A%25D0%25BE%25D0%25BD%25D0%25B5%25D1%2586_%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B2%25D0%25BE%25D0%25B9_%25D1%2587%25D0%25B0%25D1%2581%25D1%2582%25D0%25B8">    GitHub</a> .         ,  .      "__". <br> <br>   <a href="http://habrahabr.ru/post/232081/">    </a> .      ,      <a href="http://habrahabr.ru/post/232097/">    </a> .</code> <ul><li> <code><code>std::vector,      Tokens</code> .            . <br> <br> <code class="cpp">#pragma once; #include &lt;vector&gt; namespace Interpreter { struct Token {}; typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { inline Tokens Tokenize(std::string expr) { throw std::exception(); } } // namespace Lexer } // namespace Interpreter</code> <br>   ,  ,   , .   ,    ,    <a href="http://cleancoder.posterous.com/the-transformation-priority-premise">The Transformation Priority Premise (TPP)</a>   .    , ,    ,     ,        .            .     ,     ,      ,           .  ,  ,   (   )    ,  ,  .     ,  ,         .     ,   TPP          . <br> <br>   : <br> <br> ({} ‚Üí nil)     ,   . (nil ‚Üí constant)    . (constant ‚Üí constant+)      (        ,  ). (constant ‚Üí scalar)    ,  . (statement ‚Üí statements)    (break, continue, return  ). (unconditional ‚Üí if)       . (scalar ‚Üí array)  / . (array ‚Üí container)     . (statement ‚Üí recursion)   . (if ‚Üí while)    . (expression ‚Üí function)   . (variable ‚Üí assignment)   . <br>        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::string expr) { return{}; }</code> <br> ,         .     . <br> <br> <s>         </s> .           .           .               .            .       . <br>  ,  <code>std::string</code>  <code>std::wstring</code> .         ,      Unicode.     . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); }</code> <br>  <code>AssertRange</code> -   ,       <code>AreEqual</code> ,   ,  ,    . <br> <br> <b class="spoiler_title">AssertRange</b> <code class="cpp">namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange</code> <br> <br>         <code>Operator</code>    .          <code>wchar_t</code>   ,         ,      . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', }; typedef Operator Token;</code> <br>    ,   ,        <code>Assert</code> ,    <code>ToString</code> ,    . <br> <br> <b class="spoiler_title">std::wstring ToString(const Token &amp;)</b> <code class="cpp">inline std::wstring ToString(const Token &amp;token) { return{ static_cast&lt;wchar_t&gt;(token) }; }</code> <br> <br>    ,   ,        .  ,   (unconditional ‚Üí if). <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { if(expr.empty()) { return{}; } return{ static_cast&lt;Operator&gt;(expr[0]) }; }</code> <br> <s>         </s> . <s>          .</s>           . ‚Ä¶ <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); }</code> <br>     .   ,     ,   - .    , : <br> <br>        ,      <code>Token</code> .       <code>dynamic_cast</code>    ,   .  ,    ,      .      <code>std::function</code>        .        .  Boost.Any,  - .            . <br>   ,   .      -  .  ,      ,      . <br> <br> ‚Ä¶        .        .        .        . <br>             . <br> <br> <code class="cpp">enum class TokenType { Operator, Number }; class Token { public: Token(Operator) {} TokenType Type() const { return TokenType::Operator; } }; ‚Ä¶ TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } };</code> <br>   <code>ToString</code>   <code>TokenType</code>       ,   ,   .     . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); }</code> <br>   .   (constant ‚Üí scalar)   . <br> <br> <code class="cpp">class Token { public: Token(Operator) :m_type(TokenType::Operator) {} Token(double) :m_type(TokenType::Number) {} TokenType Type() const { return m_type; } private: TokenType m_type; };</code> <br> ‚Ä¶ <s>       </s> . <s>       </s> .        .        . <br>    . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); }</code> <br>            . <br> <br> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} operator Operator() const { return m_operator; } ‚Ä¶ Operator m_operator; };</code> <br>      . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); }</code> <br>          ,  ,       <code>union</code> .         . <br> <br> <b class="spoiler_title">Token</b> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: return "Unknown token."; } }</code> <br> <br>  ,    ,      ,    .       .    . <br> <br> <i>          .</i>               .            .       . <br>        : <br> <br> <code class="cpp"> if(expr[0] &gt;= '0' &amp;&amp; expr[0] &lt;= '9') { return{ (double) expr[0] - '0' }; } return{ static_cast&lt;Operator&gt;(expr[0]) };</code> <br>      ,   . <br> <br> ‚Ä¶ <s>          .</s> <i>              .</i> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); }</code> <br> ,     <code>C</code>   ,  <code>isdigit</code> , ,       <code>atof</code> ,    ,      <code>wchar_t</code> .  (expression ‚Üí function).         . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { const wchar_t *current = expr.c_str(); if(!*current) return{}; if(iswdigit(*current)) return{ _wtof(current) }; return{ static_cast&lt;Operator&gt;(*current) }; }</code> <br>         .      . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>   ,        .  ,     .     .   <code>result</code> ,     . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); if(!*current) return result; if(iswdigit(*current)) { result.push_back(_wtof(current)); } else { result.push_back(static_cast&lt;Operator&gt;(*current)); } return result; }</code> <br>      :   (if ‚Üí while).     ,        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } } return result; }</code> <br>  <code>wcstod</code>    ,   <code>_wtof</code> ,           .           ,              .  ,    . <br> <br> <s>           .</s>       . <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>  (unconditional ‚Üí if)    ,    . <br> <br> <code class="cpp"> while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else if(*current == static_cast&lt;wchar_t&gt;(Operator::Plus)) { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } else { ++current; } }</code> <br>       .          .       <code>Detail</code>      .   <code>Tokenize</code>       . <br> <br> <code class="cpp">inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); }</code> <br> <b class="spoiler_title"> Detail::Tokenizer</b> <code class="cpp">namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { return *m_current == static_cast&lt;wchar_t&gt;(Operator::Plus); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail</code> <br> <br>  ,      .      ,  , .       . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); }</code> <br>      <code>Operator</code> ,    . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', };</code> <br>   .         <code>IsOperator</code>  <code>Tokenizer</code> . <br> <br> <code class="cpp"> bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); }</code> <br>         .        . <br> <br> <b class="spoiler_title">Interpreter.h</b> <code class="cpp">#pragma once; #include &lt;vector&gt; #include &lt;wchar.h&gt; #include &lt;algorithm&gt; namespace Interpreter { enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', }; inline std::wstring ToString(const Operator &amp;op) { return{ static_cast&lt;wchar_t&gt;(op) }; } enum class TokenType { Operator, Number }; inline std::wstring ToString(const TokenType &amp;type) { switch(type) { case TokenType::Operator: return L"Operator"; case TokenType::Number: return L"Number"; default: throw std::out_of_range("TokenType"); } } class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } friend inline bool operator==(const Token &amp;left, const Token &amp;right) { if(left.m_type == right.m_type) { switch(left.m_type) { case Interpreter::TokenType::Operator: return left.m_operator == right.m_operator; case Interpreter::TokenType::Number: return left.m_number == right.m_number; default: throw std::out_of_range("TokenType"); } } return false; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: throw std::out_of_range("TokenType"); } } typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); } } // namespace Lexer } // namespace Interpreter</code> <br> <br> <b class="spoiler_title">InterpreterTests.cpp</b> <code class="cpp">#include "stdafx.h" #include "CppUnitTest.h" #include "Interpreter.h" namespace InterpreterTests { using namespace Microsoft::VisualStudio::CppUnitTestFramework; using namespace Interpreter; using namespace std; namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual&lt;T&gt;(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange TEST_CLASS(LexerTests) { public: TEST_METHOD(Should_return_empty_token_list_when_put_empty_expression) { Tokens tokens = Lexer::Tokenize(L""); Assert::IsTrue(tokens.empty()); } TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); } TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); } TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); } TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); } }; TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); } TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); } TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); } }; }</code> <br> <br> <a href="https://github.com/Unril/InterpreterTDD/releases/tag/%25D0%259A%25D0%25BE%25D0%25BD%25D0%25B5%25D1%2586_%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B2%25D0%25BE%25D0%25B9_%25D1%2587%25D0%25B0%25D1%2581%25D1%2582%25D0%25B8">    GitHub</a> .         ,  .      "__". <br> <br>   <a href="http://habrahabr.ru/post/232081/">    </a> .      ,      <a href="http://habrahabr.ru/post/232097/">    </a> .</code> </li> <li> <code><s><code>std::vector,      Tokens</code> .            . <br> <br> <code class="cpp">#pragma once; #include &lt;vector&gt; namespace Interpreter { struct Token {}; typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { inline Tokens Tokenize(std::string expr) { throw std::exception(); } } // namespace Lexer } // namespace Interpreter</code> <br>   ,  ,   , .   ,    ,    <a href="http://cleancoder.posterous.com/the-transformation-priority-premise">The Transformation Priority Premise (TPP)</a>   .    , ,    ,     ,        .            .     ,     ,      ,           .  ,  ,   (   )    ,  ,  .     ,  ,         .     ,   TPP          . <br> <br>   : <br> <br> ({} ‚Üí nil)     ,   . (nil ‚Üí constant)    . (constant ‚Üí constant+)      (        ,  ). (constant ‚Üí scalar)    ,  . (statement ‚Üí statements)    (break, continue, return  ). (unconditional ‚Üí if)       . (scalar ‚Üí array)  / . (array ‚Üí container)     . (statement ‚Üí recursion)   . (if ‚Üí while)    . (expression ‚Üí function)   . (variable ‚Üí assignment)   . <br>        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::string expr) { return{}; }</code> <br> ,         .     . <br> <br> <s>         </s> .           .           .               .            .       . <br>  ,  <code>std::string</code>  <code>std::wstring</code> .         ,      Unicode.     . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); }</code> <br>  <code>AssertRange</code> -   ,       <code>AreEqual</code> ,   ,  ,    . <br> <br> <b class="spoiler_title">AssertRange</b> <code class="cpp">namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange</code> <br> <br>         <code>Operator</code>    .          <code>wchar_t</code>   ,         ,      . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', }; typedef Operator Token;</code> <br>    ,   ,        <code>Assert</code> ,    <code>ToString</code> ,    . <br> <br> <b class="spoiler_title">std::wstring ToString(const Token &amp;)</b> <code class="cpp">inline std::wstring ToString(const Token &amp;token) { return{ static_cast&lt;wchar_t&gt;(token) }; }</code> <br> <br>    ,   ,        .  ,   (unconditional ‚Üí if). <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { if(expr.empty()) { return{}; } return{ static_cast&lt;Operator&gt;(expr[0]) }; }</code> <br> <s>         </s> .           .           . ‚Ä¶ <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); }</code> <br>     .   ,     ,   - .    , : <br> <br>        ,      <code>Token</code> .       <code>dynamic_cast</code>    ,   .  ,    ,      .      <code>std::function</code>        .        .  Boost.Any,  - .            . <br>   ,   .      -  .  ,      ,      . <br> <br> ‚Ä¶        .        .        .        . <br>             . <br> <br> <code class="cpp">enum class TokenType { Operator, Number }; class Token { public: Token(Operator) {} TokenType Type() const { return TokenType::Operator; } }; ‚Ä¶ TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } };</code> <br>   <code>ToString</code>   <code>TokenType</code>       ,   ,   .     . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); }</code> <br>   .   (constant ‚Üí scalar)   . <br> <br> <code class="cpp">class Token { public: Token(Operator) :m_type(TokenType::Operator) {} Token(double) :m_type(TokenType::Number) {} TokenType Type() const { return m_type; } private: TokenType m_type; };</code> <br> ‚Ä¶ <s>       </s> . <s>       </s> .        .        . <br>    . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); }</code> <br>            . <br> <br> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} operator Operator() const { return m_operator; } ‚Ä¶ Operator m_operator; };</code> <br>      . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); }</code> <br>          ,  ,       <code>union</code> .         . <br> <br> <b class="spoiler_title">Token</b> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: return "Unknown token."; } }</code> <br> <br>  ,    ,      ,    .       .    . <br> <br> <i>          .</i>               .            .       . <br>        : <br> <br> <code class="cpp"> if(expr[0] &gt;= '0' &amp;&amp; expr[0] &lt;= '9') { return{ (double) expr[0] - '0' }; } return{ static_cast&lt;Operator&gt;(expr[0]) };</code> <br>      ,   . <br> <br> ‚Ä¶ <s>          .</s> <i>              .</i> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); }</code> <br> ,     <code>C</code>   ,  <code>isdigit</code> , ,       <code>atof</code> ,    ,      <code>wchar_t</code> .  (expression ‚Üí function).         . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { const wchar_t *current = expr.c_str(); if(!*current) return{}; if(iswdigit(*current)) return{ _wtof(current) }; return{ static_cast&lt;Operator&gt;(*current) }; }</code> <br>         .      . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>   ,        .  ,     .     .   <code>result</code> ,     . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); if(!*current) return result; if(iswdigit(*current)) { result.push_back(_wtof(current)); } else { result.push_back(static_cast&lt;Operator&gt;(*current)); } return result; }</code> <br>      :   (if ‚Üí while).     ,        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } } return result; }</code> <br>  <code>wcstod</code>    ,   <code>_wtof</code> ,           .           ,              .  ,    . <br> <br> <s>           .</s>       . <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>  (unconditional ‚Üí if)    ,    . <br> <br> <code class="cpp"> while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else if(*current == static_cast&lt;wchar_t&gt;(Operator::Plus)) { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } else { ++current; } }</code> <br>       .          .       <code>Detail</code>      .   <code>Tokenize</code>       . <br> <br> <code class="cpp">inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); }</code> <br> <b class="spoiler_title"> Detail::Tokenizer</b> <code class="cpp">namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { return *m_current == static_cast&lt;wchar_t&gt;(Operator::Plus); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail</code> <br> <br>  ,      .      ,  , .       . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); }</code> <br>      <code>Operator</code> ,    . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', };</code> <br>   .         <code>IsOperator</code>  <code>Tokenizer</code> . <br> <br> <code class="cpp"> bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); }</code> <br>         .        . <br> <br> <b class="spoiler_title">Interpreter.h</b> <code class="cpp">#pragma once; #include &lt;vector&gt; #include &lt;wchar.h&gt; #include &lt;algorithm&gt; namespace Interpreter { enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', }; inline std::wstring ToString(const Operator &amp;op) { return{ static_cast&lt;wchar_t&gt;(op) }; } enum class TokenType { Operator, Number }; inline std::wstring ToString(const TokenType &amp;type) { switch(type) { case TokenType::Operator: return L"Operator"; case TokenType::Number: return L"Number"; default: throw std::out_of_range("TokenType"); } } class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } friend inline bool operator==(const Token &amp;left, const Token &amp;right) { if(left.m_type == right.m_type) { switch(left.m_type) { case Interpreter::TokenType::Operator: return left.m_operator == right.m_operator; case Interpreter::TokenType::Number: return left.m_number == right.m_number; default: throw std::out_of_range("TokenType"); } } return false; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: throw std::out_of_range("TokenType"); } } typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); } } // namespace Lexer } // namespace Interpreter</code> <br> <br> <b class="spoiler_title">InterpreterTests.cpp</b> <code class="cpp">#include "stdafx.h" #include "CppUnitTest.h" #include "Interpreter.h" namespace InterpreterTests { using namespace Microsoft::VisualStudio::CppUnitTestFramework; using namespace Interpreter; using namespace std; namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual&lt;T&gt;(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange TEST_CLASS(LexerTests) { public: TEST_METHOD(Should_return_empty_token_list_when_put_empty_expression) { Tokens tokens = Lexer::Tokenize(L""); Assert::IsTrue(tokens.empty()); } TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); } TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); } TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); } TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); } }; TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); } TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); } TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); } }; }</code> <br> <br> <a href="https://github.com/Unril/InterpreterTDD/releases/tag/%25D0%259A%25D0%25BE%25D0%25BD%25D0%25B5%25D1%2586_%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B2%25D0%25BE%25D0%25B9_%25D1%2587%25D0%25B0%25D1%2581%25D1%2582%25D0%25B8">    GitHub</a> .         ,  .      "__". <br> <br>   <a href="http://habrahabr.ru/post/232081/">    </a> .      ,      <a href="http://habrahabr.ru/post/232097/">    </a> .</s></code> </li> <li> <code><code>std::vector,      Tokens</code> .            . <br> <br> <code class="cpp">#pragma once; #include &lt;vector&gt; namespace Interpreter { struct Token {}; typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { inline Tokens Tokenize(std::string expr) { throw std::exception(); } } // namespace Lexer } // namespace Interpreter</code> <br>   ,  ,   , .   ,    ,    <a href="http://cleancoder.posterous.com/the-transformation-priority-premise">The Transformation Priority Premise (TPP)</a>   .    , ,    ,     ,        .            .     ,     ,      ,           .  ,  ,   (   )    ,  ,  .     ,  ,         .     ,   TPP          . <br> <br>   : <br> <br> ({} ‚Üí nil)     ,   . (nil ‚Üí constant)    . (constant ‚Üí constant+)      (        ,  ). (constant ‚Üí scalar)    ,  . (statement ‚Üí statements)    (break, continue, return  ). (unconditional ‚Üí if)       . (scalar ‚Üí array)  / . (array ‚Üí container)     . (statement ‚Üí recursion)   . (if ‚Üí while)    . (expression ‚Üí function)   . (variable ‚Üí assignment)   . <br>        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::string expr) { return{}; }</code> <br> ,         .     . <br> <br> <s>         </s> .           .           .               .            .       . <br>  ,  <code>std::string</code>  <code>std::wstring</code> .         ,      Unicode.     . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); }</code> <br>  <code>AssertRange</code> -   ,       <code>AreEqual</code> ,   ,  ,    . <br> <br> <b class="spoiler_title">AssertRange</b> <code class="cpp">namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange</code> <br> <br>         <code>Operator</code>    .          <code>wchar_t</code>   ,         ,      . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', }; typedef Operator Token;</code> <br>    ,   ,        <code>Assert</code> ,    <code>ToString</code> ,    . <br> <br> <b class="spoiler_title">std::wstring ToString(const Token &amp;)</b> <code class="cpp">inline std::wstring ToString(const Token &amp;token) { return{ static_cast&lt;wchar_t&gt;(token) }; }</code> <br> <br>    ,   ,        .  ,   (unconditional ‚Üí if). <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { if(expr.empty()) { return{}; } return{ static_cast&lt;Operator&gt;(expr[0]) }; }</code> <br> <s>         </s> . <s>          .</s>           . ‚Ä¶ <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); }</code> <br>     .   ,     ,   - .    , : <br> <br>        ,      <code>Token</code> .       <code>dynamic_cast</code>    ,   .  ,    ,      .      <code>std::function</code>        .        .  Boost.Any,  - .            . <br>   ,   .      -  .  ,      ,      . <br> <br> ‚Ä¶        .        .        .        . <br>             . <br> <br> <code class="cpp">enum class TokenType { Operator, Number }; class Token { public: Token(Operator) {} TokenType Type() const { return TokenType::Operator; } }; ‚Ä¶ TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } };</code> <br>   <code>ToString</code>   <code>TokenType</code>       ,   ,   .     . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); }</code> <br>   .   (constant ‚Üí scalar)   . <br> <br> <code class="cpp">class Token { public: Token(Operator) :m_type(TokenType::Operator) {} Token(double) :m_type(TokenType::Number) {} TokenType Type() const { return m_type; } private: TokenType m_type; };</code> <br> ‚Ä¶ <s>       </s> . <s>       </s> .        .        . <br>    . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); }</code> <br>            . <br> <br> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} operator Operator() const { return m_operator; } ‚Ä¶ Operator m_operator; };</code> <br>      . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); }</code> <br>          ,  ,       <code>union</code> .         . <br> <br> <b class="spoiler_title">Token</b> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: return "Unknown token."; } }</code> <br> <br>  ,    ,      ,    .       .    . <br> <br> <i>          .</i>               .            .       . <br>        : <br> <br> <code class="cpp"> if(expr[0] &gt;= '0' &amp;&amp; expr[0] &lt;= '9') { return{ (double) expr[0] - '0' }; } return{ static_cast&lt;Operator&gt;(expr[0]) };</code> <br>      ,   . <br> <br> ‚Ä¶ <s>          .</s> <i>              .</i> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); }</code> <br> ,     <code>C</code>   ,  <code>isdigit</code> , ,       <code>atof</code> ,    ,      <code>wchar_t</code> .  (expression ‚Üí function).         . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { const wchar_t *current = expr.c_str(); if(!*current) return{}; if(iswdigit(*current)) return{ _wtof(current) }; return{ static_cast&lt;Operator&gt;(*current) }; }</code> <br>         .      . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>   ,        .  ,     .     .   <code>result</code> ,     . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); if(!*current) return result; if(iswdigit(*current)) { result.push_back(_wtof(current)); } else { result.push_back(static_cast&lt;Operator&gt;(*current)); } return result; }</code> <br>      :   (if ‚Üí while).     ,        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } } return result; }</code> <br>  <code>wcstod</code>    ,   <code>_wtof</code> ,           .           ,              .  ,    . <br> <br> <s>           .</s>       . <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>  (unconditional ‚Üí if)    ,    . <br> <br> <code class="cpp"> while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else if(*current == static_cast&lt;wchar_t&gt;(Operator::Plus)) { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } else { ++current; } }</code> <br>       .          .       <code>Detail</code>      .   <code>Tokenize</code>       . <br> <br> <code class="cpp">inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); }</code> <br> <b class="spoiler_title"> Detail::Tokenizer</b> <code class="cpp">namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { return *m_current == static_cast&lt;wchar_t&gt;(Operator::Plus); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail</code> <br> <br>  ,      .      ,  , .       . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); }</code> <br>      <code>Operator</code> ,    . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', };</code> <br>   .         <code>IsOperator</code>  <code>Tokenizer</code> . <br> <br> <code class="cpp"> bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); }</code> <br>         .        . <br> <br> <b class="spoiler_title">Interpreter.h</b> <code class="cpp">#pragma once; #include &lt;vector&gt; #include &lt;wchar.h&gt; #include &lt;algorithm&gt; namespace Interpreter { enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', }; inline std::wstring ToString(const Operator &amp;op) { return{ static_cast&lt;wchar_t&gt;(op) }; } enum class TokenType { Operator, Number }; inline std::wstring ToString(const TokenType &amp;type) { switch(type) { case TokenType::Operator: return L"Operator"; case TokenType::Number: return L"Number"; default: throw std::out_of_range("TokenType"); } } class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } friend inline bool operator==(const Token &amp;left, const Token &amp;right) { if(left.m_type == right.m_type) { switch(left.m_type) { case Interpreter::TokenType::Operator: return left.m_operator == right.m_operator; case Interpreter::TokenType::Number: return left.m_number == right.m_number; default: throw std::out_of_range("TokenType"); } } return false; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: throw std::out_of_range("TokenType"); } } typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); } } // namespace Lexer } // namespace Interpreter</code> <br> <br> <b class="spoiler_title">InterpreterTests.cpp</b> <code class="cpp">#include "stdafx.h" #include "CppUnitTest.h" #include "Interpreter.h" namespace InterpreterTests { using namespace Microsoft::VisualStudio::CppUnitTestFramework; using namespace Interpreter; using namespace std; namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual&lt;T&gt;(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange TEST_CLASS(LexerTests) { public: TEST_METHOD(Should_return_empty_token_list_when_put_empty_expression) { Tokens tokens = Lexer::Tokenize(L""); Assert::IsTrue(tokens.empty()); } TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); } TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); } TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); } TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); } }; TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); } TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); } TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); } }; }</code> <br> <br> <a href="https://github.com/Unril/InterpreterTDD/releases/tag/%25D0%259A%25D0%25BE%25D0%25BD%25D0%25B5%25D1%2586_%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B2%25D0%25BE%25D0%25B9_%25D1%2587%25D0%25B0%25D1%2581%25D1%2582%25D0%25B8">    GitHub</a> .         ,  .      "__". <br> <br>   <a href="http://habrahabr.ru/post/232081/">    </a> .      ,      <a href="http://habrahabr.ru/post/232097/">    </a> .</code> </li> <li> <code><code>std::vector,      Tokens</code> .            . <br> <br> <code class="cpp">#pragma once; #include &lt;vector&gt; namespace Interpreter { struct Token {}; typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { inline Tokens Tokenize(std::string expr) { throw std::exception(); } } // namespace Lexer } // namespace Interpreter</code> <br>   ,  ,   , .   ,    ,    <a href="http://cleancoder.posterous.com/the-transformation-priority-premise">The Transformation Priority Premise (TPP)</a>   .    , ,    ,     ,        .            .     ,     ,      ,           .  ,  ,   (   )    ,  ,  .     ,  ,         .     ,   TPP          . <br> <br>   : <br> <br> ({} ‚Üí nil)     ,   . (nil ‚Üí constant)    . (constant ‚Üí constant+)      (        ,  ). (constant ‚Üí scalar)    ,  . (statement ‚Üí statements)    (break, continue, return  ). (unconditional ‚Üí if)       . (scalar ‚Üí array)  / . (array ‚Üí container)     . (statement ‚Üí recursion)   . (if ‚Üí while)    . (expression ‚Üí function)   . (variable ‚Üí assignment)   . <br>        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::string expr) { return{}; }</code> <br> ,         .     . <br> <br> <s>         </s> .           .           .               .            .       . <br>  ,  <code>std::string</code>  <code>std::wstring</code> .         ,      Unicode.     . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); }</code> <br>  <code>AssertRange</code> -   ,       <code>AreEqual</code> ,   ,  ,    . <br> <br> <b class="spoiler_title">AssertRange</b> <code class="cpp">namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange</code> <br> <br>         <code>Operator</code>    .          <code>wchar_t</code>   ,         ,      . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', }; typedef Operator Token;</code> <br>    ,   ,        <code>Assert</code> ,    <code>ToString</code> ,    . <br> <br> <b class="spoiler_title">std::wstring ToString(const Token &amp;)</b> <code class="cpp">inline std::wstring ToString(const Token &amp;token) { return{ static_cast&lt;wchar_t&gt;(token) }; }</code> <br> <br>    ,   ,        .  ,   (unconditional ‚Üí if). <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { if(expr.empty()) { return{}; } return{ static_cast&lt;Operator&gt;(expr[0]) }; }</code> <br> <s>         </s> . <s>          .</s>           . ‚Ä¶ <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); }</code> <br>     .   ,     ,   - .    , : <br> <br>        ,      <code>Token</code> .       <code>dynamic_cast</code>    ,   .  ,    ,      .      <code>std::function</code>        .        .  Boost.Any,  - .            . <br>   ,   .      -  .  ,      ,      . <br> <br> ‚Ä¶        .        .        .        . <br>             . <br> <br> <code class="cpp">enum class TokenType { Operator, Number }; class Token { public: Token(Operator) {} TokenType Type() const { return TokenType::Operator; } }; ‚Ä¶ TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } };</code> <br>   <code>ToString</code>   <code>TokenType</code>       ,   ,   .     . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); }</code> <br>   .   (constant ‚Üí scalar)   . <br> <br> <code class="cpp">class Token { public: Token(Operator) :m_type(TokenType::Operator) {} Token(double) :m_type(TokenType::Number) {} TokenType Type() const { return m_type; } private: TokenType m_type; };</code> <br> ‚Ä¶ <s>       </s> . <s>       </s> .        .        . <br>    . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); }</code> <br>            . <br> <br> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} operator Operator() const { return m_operator; } ‚Ä¶ Operator m_operator; };</code> <br>      . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); }</code> <br>          ,  ,       <code>union</code> .         . <br> <br> <b class="spoiler_title">Token</b> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: return "Unknown token."; } }</code> <br> <br>  ,    ,      ,    .       .    . <br> <br> <i>          .</i>               .            .       . <br>        : <br> <br> <code class="cpp"> if(expr[0] &gt;= '0' &amp;&amp; expr[0] &lt;= '9') { return{ (double) expr[0] - '0' }; } return{ static_cast&lt;Operator&gt;(expr[0]) };</code> <br>      ,   . <br> <br> ‚Ä¶ <s>          .</s> <i>              .</i> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); }</code> <br> ,     <code>C</code>   ,  <code>isdigit</code> , ,       <code>atof</code> ,    ,      <code>wchar_t</code> .  (expression ‚Üí function).         . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { const wchar_t *current = expr.c_str(); if(!*current) return{}; if(iswdigit(*current)) return{ _wtof(current) }; return{ static_cast&lt;Operator&gt;(*current) }; }</code> <br>         .      . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>   ,        .  ,     .     .   <code>result</code> ,     . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); if(!*current) return result; if(iswdigit(*current)) { result.push_back(_wtof(current)); } else { result.push_back(static_cast&lt;Operator&gt;(*current)); } return result; }</code> <br>      :   (if ‚Üí while).     ,        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } } return result; }</code> <br>  <code>wcstod</code>    ,   <code>_wtof</code> ,           .           ,              .  ,    . <br> <br> <s>           .</s>       . <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>  (unconditional ‚Üí if)    ,    . <br> <br> <code class="cpp"> while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else if(*current == static_cast&lt;wchar_t&gt;(Operator::Plus)) { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } else { ++current; } }</code> <br>       .          .       <code>Detail</code>      .   <code>Tokenize</code>       . <br> <br> <code class="cpp">inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); }</code> <br> <b class="spoiler_title"> Detail::Tokenizer</b> <code class="cpp">namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { return *m_current == static_cast&lt;wchar_t&gt;(Operator::Plus); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail</code> <br> <br>  ,      .      ,  , .       . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); }</code> <br>      <code>Operator</code> ,    . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', };</code> <br>   .         <code>IsOperator</code>  <code>Tokenizer</code> . <br> <br> <code class="cpp"> bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); }</code> <br>         .        . <br> <br> <b class="spoiler_title">Interpreter.h</b> <code class="cpp">#pragma once; #include &lt;vector&gt; #include &lt;wchar.h&gt; #include &lt;algorithm&gt; namespace Interpreter { enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', }; inline std::wstring ToString(const Operator &amp;op) { return{ static_cast&lt;wchar_t&gt;(op) }; } enum class TokenType { Operator, Number }; inline std::wstring ToString(const TokenType &amp;type) { switch(type) { case TokenType::Operator: return L"Operator"; case TokenType::Number: return L"Number"; default: throw std::out_of_range("TokenType"); } } class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } friend inline bool operator==(const Token &amp;left, const Token &amp;right) { if(left.m_type == right.m_type) { switch(left.m_type) { case Interpreter::TokenType::Operator: return left.m_operator == right.m_operator; case Interpreter::TokenType::Number: return left.m_number == right.m_number; default: throw std::out_of_range("TokenType"); } } return false; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: throw std::out_of_range("TokenType"); } } typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); } } // namespace Lexer } // namespace Interpreter</code> <br> <br> <b class="spoiler_title">InterpreterTests.cpp</b> <code class="cpp">#include "stdafx.h" #include "CppUnitTest.h" #include "Interpreter.h" namespace InterpreterTests { using namespace Microsoft::VisualStudio::CppUnitTestFramework; using namespace Interpreter; using namespace std; namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual&lt;T&gt;(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange TEST_CLASS(LexerTests) { public: TEST_METHOD(Should_return_empty_token_list_when_put_empty_expression) { Tokens tokens = Lexer::Tokenize(L""); Assert::IsTrue(tokens.empty()); } TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); } TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); } TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); } TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); } }; TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); } TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); } TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); } }; }</code> <br> <br> <a href="https://github.com/Unril/InterpreterTDD/releases/tag/%25D0%259A%25D0%25BE%25D0%25BD%25D0%25B5%25D1%2586_%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B2%25D0%25BE%25D0%25B9_%25D1%2587%25D0%25B0%25D1%2581%25D1%2582%25D0%25B8">    GitHub</a> .         ,  .      "__". <br> <br>   <a href="http://habrahabr.ru/post/232081/">    </a> .      ,      <a href="http://habrahabr.ru/post/232097/">    </a> .</code> </li> </ul> <code><code>std::vector,      Tokens</code> .            . <br> <br> <code class="cpp">#pragma once; #include &lt;vector&gt; namespace Interpreter { struct Token {}; typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { inline Tokens Tokenize(std::string expr) { throw std::exception(); } } // namespace Lexer } // namespace Interpreter</code> <br>   ,  ,   , .   ,    ,    <a href="http://cleancoder.posterous.com/the-transformation-priority-premise">The Transformation Priority Premise (TPP)</a>   .    , ,    ,     ,        .            .     ,     ,      ,           .  ,  ,   (   )    ,  ,  .     ,  ,         .     ,   TPP          . <br> <br>   : <br> <br> ({} ‚Üí nil)     ,   . (nil ‚Üí constant)    . (constant ‚Üí constant+)      (        ,  ). (constant ‚Üí scalar)    ,  . (statement ‚Üí statements)    (break, continue, return  ). (unconditional ‚Üí if)       . (scalar ‚Üí array)  / . (array ‚Üí container)     . (statement ‚Üí recursion)   . (if ‚Üí while)    . (expression ‚Üí function)   . (variable ‚Üí assignment)   . <br>        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::string expr) { return{}; }</code> <br> ,         .     . <br> <br> <s>         </s> .           .           .               .            .       . <br>  ,  <code>std::string</code>  <code>std::wstring</code> .         ,      Unicode.     . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); }</code> <br>  <code>AssertRange</code> -   ,       <code>AreEqual</code> ,   ,  ,    . <br> <br> <b class="spoiler_title">AssertRange</b> <code class="cpp">namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange</code> <br> <br>         <code>Operator</code>    .          <code>wchar_t</code>   ,         ,      . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', }; typedef Operator Token;</code> <br>    ,   ,        <code>Assert</code> ,    <code>ToString</code> ,    . <br> <br> <b class="spoiler_title">std::wstring ToString(const Token &amp;)</b> <code class="cpp">inline std::wstring ToString(const Token &amp;token) { return{ static_cast&lt;wchar_t&gt;(token) }; }</code> <br> <br>    ,   ,        .  ,   (unconditional ‚Üí if). <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { if(expr.empty()) { return{}; } return{ static_cast&lt;Operator&gt;(expr[0]) }; }</code> <br> <s>         </s> . <s>          .</s>           . ‚Ä¶ <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); }</code> <br>     .   ,     ,   - .    , : <br> <br>        ,      <code>Token</code> .       <code>dynamic_cast</code>    ,   .  ,    ,      .      <code>std::function</code>        .        .  Boost.Any,  - .            . <br>   ,   .      -  .  ,      ,      . <br> <br> ‚Ä¶        .        .        .        . <br>             . <br> <br> <code class="cpp">enum class TokenType { Operator, Number }; class Token { public: Token(Operator) {} TokenType Type() const { return TokenType::Operator; } }; ‚Ä¶ TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } };</code> <br>   <code>ToString</code>   <code>TokenType</code>       ,   ,   .     . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); }</code> <br>   .   (constant ‚Üí scalar)   . <br> <br> <code class="cpp">class Token { public: Token(Operator) :m_type(TokenType::Operator) {} Token(double) :m_type(TokenType::Number) {} TokenType Type() const { return m_type; } private: TokenType m_type; };</code> <br> ‚Ä¶ <s>       </s> . <s>       </s> .        .        . <br>    . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); }</code> <br>            . <br> <br> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} operator Operator() const { return m_operator; } ‚Ä¶ Operator m_operator; };</code> <br>      . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); }</code> <br>          ,  ,       <code>union</code> .         . <br> <br> <b class="spoiler_title">Token</b> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: return "Unknown token."; } }</code> <br> <br>  ,    ,      ,    .       .    . <br> <br> <i>          .</i>               .            .       . <br>        : <br> <br> <code class="cpp"> if(expr[0] &gt;= '0' &amp;&amp; expr[0] &lt;= '9') { return{ (double) expr[0] - '0' }; } return{ static_cast&lt;Operator&gt;(expr[0]) };</code> <br>      ,   . <br> <br> ‚Ä¶ <s>          .</s> <i>              .</i> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); }</code> <br> ,     <code>C</code>   ,  <code>isdigit</code> , ,       <code>atof</code> ,    ,      <code>wchar_t</code> .  (expression ‚Üí function).         . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { const wchar_t *current = expr.c_str(); if(!*current) return{}; if(iswdigit(*current)) return{ _wtof(current) }; return{ static_cast&lt;Operator&gt;(*current) }; }</code> <br>         .      . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>   ,        .  ,     .     .   <code>result</code> ,     . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); if(!*current) return result; if(iswdigit(*current)) { result.push_back(_wtof(current)); } else { result.push_back(static_cast&lt;Operator&gt;(*current)); } return result; }</code> <br>      :   (if ‚Üí while).     ,        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } } return result; }</code> <br>  <code>wcstod</code>    ,   <code>_wtof</code> ,           .           ,              .  ,    . <br> <br> <s>           .</s>       . <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>  (unconditional ‚Üí if)    ,    . <br> <br> <code class="cpp"> while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else if(*current == static_cast&lt;wchar_t&gt;(Operator::Plus)) { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } else { ++current; } }</code> <br>       .          .       <code>Detail</code>      .   <code>Tokenize</code>       . <br> <br> <code class="cpp">inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); }</code> <br> <b class="spoiler_title"> Detail::Tokenizer</b> <code class="cpp">namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { return *m_current == static_cast&lt;wchar_t&gt;(Operator::Plus); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail</code> <br> <br>  ,      .      ,  , .       . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); }</code> <br>      <code>Operator</code> ,    . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', };</code> <br>   .         <code>IsOperator</code>  <code>Tokenizer</code> . <br> <br> <code class="cpp"> bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); }</code> <br>         .        . <br> <br> <b class="spoiler_title">Interpreter.h</b> <code class="cpp">#pragma once; #include &lt;vector&gt; #include &lt;wchar.h&gt; #include &lt;algorithm&gt; namespace Interpreter { enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', }; inline std::wstring ToString(const Operator &amp;op) { return{ static_cast&lt;wchar_t&gt;(op) }; } enum class TokenType { Operator, Number }; inline std::wstring ToString(const TokenType &amp;type) { switch(type) { case TokenType::Operator: return L"Operator"; case TokenType::Number: return L"Number"; default: throw std::out_of_range("TokenType"); } } class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } friend inline bool operator==(const Token &amp;left, const Token &amp;right) { if(left.m_type == right.m_type) { switch(left.m_type) { case Interpreter::TokenType::Operator: return left.m_operator == right.m_operator; case Interpreter::TokenType::Number: return left.m_number == right.m_number; default: throw std::out_of_range("TokenType"); } } return false; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: throw std::out_of_range("TokenType"); } } typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); } } // namespace Lexer } // namespace Interpreter</code> <br> <br> <b class="spoiler_title">InterpreterTests.cpp</b> <code class="cpp">#include "stdafx.h" #include "CppUnitTest.h" #include "Interpreter.h" namespace InterpreterTests { using namespace Microsoft::VisualStudio::CppUnitTestFramework; using namespace Interpreter; using namespace std; namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual&lt;T&gt;(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange TEST_CLASS(LexerTests) { public: TEST_METHOD(Should_return_empty_token_list_when_put_empty_expression) { Tokens tokens = Lexer::Tokenize(L""); Assert::IsTrue(tokens.empty()); } TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); } TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); } TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); } TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); } }; TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); } TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); } TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); } }; }</code> <br> <br> <a href="https://github.com/Unril/InterpreterTDD/releases/tag/%25D0%259A%25D0%25BE%25D0%25BD%25D0%25B5%25D1%2586_%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B2%25D0%25BE%25D0%25B9_%25D1%2587%25D0%25B0%25D1%2581%25D1%2582%25D0%25B8">    GitHub</a> .         ,  .      "__". <br> <br>   <a href="http://habrahabr.ru/post/232081/">    </a> .      ,      <a href="http://habrahabr.ru/post/232097/">    </a> .</code> <pre> <code class="hljs lua"><code>std::vector,      Tokens</code> .            . <br> <br> <code class="cpp">#pragma once; #include &lt;vector&gt; namespace Interpreter { struct Token {}; typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { inline Tokens Tokenize(std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> expr) { throw std::exception(); } } // namespace Lexer } // namespace Interpreter</code> <br>   ,  ,   , .   ,    ,    <a href="http://cleancoder.posterous.com/the-transformation-priority-premise">The Transformation Priority Premise (TPP)</a>   .    , ,    ,     ,        .            .     ,     ,      ,           .  ,  ,   (   )    ,  ,  .     ,  ,         .     ,   TPP          . <br> <br>   : <br> <br> ({} ‚Üí <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)     ,   . (<span class="hljs-literal"><span class="hljs-literal">nil</span></span> ‚Üí constant)    . (constant ‚Üí constant+)      (        ,  ). (constant ‚Üí scalar)    ,  . (statement ‚Üí statements)    (<span class="hljs-keyword"><span class="hljs-keyword">break</span></span>, continue, <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>  ). (unconditional ‚Üí <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>)       . (scalar ‚Üí array)  / . (array ‚Üí container)     . (statement ‚Üí recursion)   . (<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ‚Üí <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>)    . (expression ‚Üí <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">)</span></span>   . (variable ‚Üí assignment)   . <br>        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> expr) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{}; }</code> <br> ,         .     . <br> <br> <s>         </s> .           .           .               .            .       . <br>  ,  <code>std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span></code>  <code>std::wstring</code> .         ,      Unicode.     . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"+"</span></span>); AssertRange::AreEqual({ Operator::Plus }, tokens); }</code> <br>  <code>AssertRange</code> -   ,       <code>AreEqual</code> ,   ,  ,    . <br> <br> <b class="spoiler_title">AssertRange</b> <code class="cpp">namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(expect)), distance(actualIter, <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(actual)), L<span class="hljs-string"><span class="hljs-string">"Size differs."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(; expectIter != <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(expect) &amp;&amp; actualIter != <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(actual); ++expectIter, ++actualIter) { auto message = L<span class="hljs-string"><span class="hljs-string">"Mismatch in position "</span></span> + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange</code> <br> <br>         <code>Operator</code>    .          <code>wchar_t</code>   ,         ,      . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L<span class="hljs-string"><span class="hljs-string">'+'</span></span>, }; typedef Operator Token;</code> <br>    ,   ,        <code>Assert</code> ,    <code>ToString</code> ,    . <br> <br> <b class="spoiler_title">std::wstring ToString(const Token &amp;)</b> <code class="cpp">inline std::wstring ToString(const Token &amp;token) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ static_cast&lt;wchar_t&gt;(token) }; }</code> <br> <br>    ,   ,        .  ,   (unconditional ‚Üí <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>). <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(expr.empty()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{}; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ static_cast&lt;Operator&gt;(expr[<span class="hljs-number"><span class="hljs-number">0</span></span>]) }; }</code> <br> <s>         </s> . <s>          .</s>           . ‚Ä¶ <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"1"</span></span>); AssertRange::AreEqual({ <span class="hljs-number"><span class="hljs-number">1.0</span></span> }, tokens); }</code> <br>     .   ,     ,   - .    , : <br> <br>        ,      <code>Token</code> .       <code>dynamic_cast</code>    ,   .  ,    ,      .      <code>std::<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span></span></code><span class="hljs-function"><span class="hljs-function">        .        .  </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Boost.Any</span></span></span><span class="hljs-function">,  - .            . </span></span><br><span class="hljs-function"><span class="hljs-function">   ,   .      -  .  ,      ,      . </span></span><br><span class="hljs-function"><span class="hljs-function"> </span></span><br><span class="hljs-function"><span class="hljs-function"> ‚Ä¶        .        .        .        . </span></span><br><span class="hljs-function"><span class="hljs-function">             . </span></span><br><span class="hljs-function"><span class="hljs-function"> </span></span><br><span class="hljs-function"><span class="hljs-function"> </span></span><code class="cpp"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">enum</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">class</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TokenType</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Operator</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Number</span></span></span><span class="hljs-function"> }; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">class</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Token</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">public</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Token</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Operator)</span></span></span></span> {} TokenType Type() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TokenType::Operator; } }; ‚Ä¶ TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } };</code> <br>   <code>ToString</code>   <code>TokenType</code>       ,   ,   .     . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_type_for_number_token) { Token numToken(<span class="hljs-number"><span class="hljs-number">1.2</span></span>); Assert::AreEqual(TokenType::Number, numToken.Type()); }</code> <br>   .   (constant ‚Üí scalar)   . <br> <br> <code class="cpp">class Token { public: Token(Operator) :m_type(TokenType::Operator) {} Token(double) :m_type(TokenType::Number) {} TokenType Type() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_type; } private: TokenType m_type; };</code> <br> ‚Ä¶ <s>       </s> . <s>       </s> .        .        . <br>    . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); }</code> <br>            . <br> <br> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} operator Operator() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_operator; } ‚Ä¶ Operator m_operator; };</code> <br>      . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_number_value_from_number_token) { Token token(<span class="hljs-number"><span class="hljs-number">1.23</span></span>); Assert::AreEqual&lt;double&gt;(<span class="hljs-number"><span class="hljs-number">1.23</span></span>, token); }</code> <br>          ,  ,       <code>union</code> .         . <br> <br> <b class="spoiler_title">Token</b> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_type; } operator Operator() const { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(m_type != TokenType::Operator) throw std::logic_error(<span class="hljs-string"><span class="hljs-string">"Should be operator token."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_operator; } operator double() const { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(m_type != TokenType::Number) throw std::logic_error(<span class="hljs-string"><span class="hljs-string">"Should be number token."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_number; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ToString(static_cast&lt;Operator&gt;(token)); default: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Unknown token."</span></span>; } }</code> <br> <br>  ,    ,      ,    .       .    . <br> <br> <i>          .</i>               .            .       . <br>        : <br> <br> <code class="cpp"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(expr[<span class="hljs-number"><span class="hljs-number">0</span></span>] &gt;= <span class="hljs-string"><span class="hljs-string">'0'</span></span> &amp;&amp; expr[<span class="hljs-number"><span class="hljs-number">0</span></span>] &lt;= <span class="hljs-string"><span class="hljs-string">'9'</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ (double) expr[<span class="hljs-number"><span class="hljs-number">0</span></span>] - <span class="hljs-string"><span class="hljs-string">'0'</span></span> }; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ static_cast&lt;Operator&gt;(expr[<span class="hljs-number"><span class="hljs-number">0</span></span>]) };</code> <br>      ,   . <br> <br> ‚Ä¶ <s>          .</s> <i>              .</i> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"12.34"</span></span>); AssertRange::AreEqual({ <span class="hljs-number"><span class="hljs-number">12.34</span></span> }, tokens); }</code> <br> ,     <code>C</code>   ,  <code>isdigit</code> , ,       <code>atof</code> ,    ,      <code>wchar_t</code> .  (expression ‚Üí <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">)</span></span>.         . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { const wchar_t *current = expr.c_str(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!*current) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{}; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(iswdigit(*current)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ _wtof(current) }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ static_cast&lt;Operator&gt;(*current) }; }</code> <br>         .      . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"+12.34"</span></span>); AssertRange::AreEqual({ Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">12.34</span></span>) }, tokens); }</code> <br>   ,        .  ,     .     .   <code>result</code> ,     . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!*current) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(iswdigit(*current)) { result.push_back(_wtof(current)); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { result.push_back(static_cast&lt;Operator&gt;(*current)); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> <br>      :   (<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ‚Üí <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>).     ,        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(*current) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(iswdigit(*current)) { wchar_t *<span class="hljs-keyword"><span class="hljs-keyword">end</span></span> = nullptr; result.push_back(wcstod(current, &amp;<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>)); current = <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> <br>  <code>wcstod</code>    ,   <code>_wtof</code> ,           .           ,              .  ,    . <br> <br> <s>           .</s>       . <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">" 1 + 12.34 "</span></span>); AssertRange::AreEqual({ Token(<span class="hljs-number"><span class="hljs-number">1.0</span></span>), Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">12.34</span></span>) }, tokens); }</code> <br>  (unconditional ‚Üí <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>)    ,    . <br> <br> <code class="cpp"> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(*current) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(iswdigit(*current)) { wchar_t *<span class="hljs-keyword"><span class="hljs-keyword">end</span></span> = nullptr; result.push_back(wcstod(current, &amp;<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>)); current = <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(*current == static_cast&lt;wchar_t&gt;(Operator::Plus)) { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { ++current; } }</code> <br>       .          .       <code>Detail</code>      .   <code>Tokenize</code>       . <br> <br> <code class="cpp">inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tokenizer.Result(); }</code> <br> <b class="spoiler_title"> Detail::Tokenizer</b> <code class="cpp">namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!EndOfExperssion()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(IsNumber()) { ScanNumber(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(IsOperator()) { ScanOperator(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { MoveNext(); } } } const Tokens &amp;Result() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_result; } private: bool EndOfExperssion() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_current == L<span class="hljs-string"><span class="hljs-string">'\0'</span></span>; } bool IsNumber() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> iswdigit(*m_current) != <span class="hljs-number"><span class="hljs-number">0</span></span>; } void ScanNumber() { wchar_t *<span class="hljs-keyword"><span class="hljs-keyword">end</span></span> = nullptr; m_result.push_back(wcstod(m_current, &amp;<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>)); m_current = <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; } bool IsOperator() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_current == static_cast&lt;wchar_t&gt;(Operator::Plus); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail</code> <br> <br>  ,      .      ,  , .       . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"1+2*3/(4-5)"</span></span>); AssertRange::AreEqual({ Token(<span class="hljs-number"><span class="hljs-number">1</span></span>), Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">2</span></span>), Token(Operator::Mul), Token(<span class="hljs-number"><span class="hljs-number">3</span></span>), Token(Operator::Div), Token(Operator::LParen), Token(<span class="hljs-number"><span class="hljs-number">4</span></span>), Token(Operator::Minus), Token(<span class="hljs-number"><span class="hljs-number">5</span></span>), Token(Operator::RParen) }, tokens); }</code> <br>      <code>Operator</code> ,    . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L<span class="hljs-string"><span class="hljs-string">'+'</span></span>, Minus = L<span class="hljs-string"><span class="hljs-string">'-'</span></span>, Mul = L<span class="hljs-string"><span class="hljs-string">'*'</span></span>, Div = L<span class="hljs-string"><span class="hljs-string">'/'</span></span>, LParen = L<span class="hljs-string"><span class="hljs-string">'('</span></span>, RParen = L<span class="hljs-string"><span class="hljs-string">')'</span></span>, };</code> <br>   .         <code>IsOperator</code>  <code>Tokenizer</code> . <br> <br> <code class="cpp"> bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> std::any_of(all.begin(), all.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(), [this](Operator o) {<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_current == static_cast&lt;wchar_t&gt;(o); }); }</code> <br>         .        . <br> <br> <b class="spoiler_title">Interpreter.h</b> <code class="cpp">#pragma once; #include &lt;vector&gt; #include &lt;wchar.h&gt; #include &lt;algorithm&gt; namespace Interpreter { enum class Operator : wchar_t { Plus = L<span class="hljs-string"><span class="hljs-string">'+'</span></span>, Minus = L<span class="hljs-string"><span class="hljs-string">'-'</span></span>, Mul = L<span class="hljs-string"><span class="hljs-string">'*'</span></span>, Div = L<span class="hljs-string"><span class="hljs-string">'/'</span></span>, LParen = L<span class="hljs-string"><span class="hljs-string">'('</span></span>, RParen = L<span class="hljs-string"><span class="hljs-string">')'</span></span>, }; inline std::wstring ToString(const Operator &amp;op) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ static_cast&lt;wchar_t&gt;(op) }; } enum class TokenType { Operator, Number }; inline std::wstring ToString(const TokenType &amp;<span class="hljs-built_in"><span class="hljs-built_in">type</span></span>) { switch(<span class="hljs-built_in"><span class="hljs-built_in">type</span></span>) { case TokenType::Operator: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> L<span class="hljs-string"><span class="hljs-string">"Operator"</span></span>; case TokenType::Number: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> L<span class="hljs-string"><span class="hljs-string">"Number"</span></span>; default: throw std::out_of_range(<span class="hljs-string"><span class="hljs-string">"TokenType"</span></span>); } } class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_type; } operator Operator() const { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(m_type != TokenType::Operator) throw std::logic_error(<span class="hljs-string"><span class="hljs-string">"Should be operator token."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_operator; } operator double() const { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(m_type != TokenType::Number) throw std::logic_error(<span class="hljs-string"><span class="hljs-string">"Should be number token."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_number; } friend inline bool operator==(const Token &amp;left, const Token &amp;right) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(left.m_type == right.m_type) { switch(left.m_type) { case Interpreter::TokenType::Operator: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> left.m_operator == right.m_operator; case Interpreter::TokenType::Number: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> left.m_number == right.m_number; default: throw std::out_of_range(<span class="hljs-string"><span class="hljs-string">"TokenType"</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ToString(static_cast&lt;Operator&gt;(token)); default: throw std::out_of_range(<span class="hljs-string"><span class="hljs-string">"TokenType"</span></span>); } } typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!EndOfExperssion()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(IsNumber()) { ScanNumber(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(IsOperator()) { ScanOperator(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { MoveNext(); } } } const Tokens &amp;Result() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_result; } private: bool EndOfExperssion() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_current == L<span class="hljs-string"><span class="hljs-string">'\0'</span></span>; } bool IsNumber() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> iswdigit(*m_current) != <span class="hljs-number"><span class="hljs-number">0</span></span>; } void ScanNumber() { wchar_t *<span class="hljs-keyword"><span class="hljs-keyword">end</span></span> = nullptr; m_result.push_back(wcstod(m_current, &amp;<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>)); m_current = <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; } bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> std::any_of(all.begin(), all.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(), [this](Operator o) {<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_current == static_cast&lt;wchar_t&gt;(o); }); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tokenizer.Result(); } } // namespace Lexer } // namespace Interpreter</code> <br> <br> <b class="spoiler_title">InterpreterTests.cpp</b> <code class="cpp">#include <span class="hljs-string"><span class="hljs-string">"stdafx.h"</span></span> #include <span class="hljs-string"><span class="hljs-string">"CppUnitTest.h"</span></span> #include <span class="hljs-string"><span class="hljs-string">"Interpreter.h"</span></span> namespace InterpreterTests { using namespace Microsoft::VisualStudio::CppUnitTestFramework; using namespace Interpreter; using namespace std; namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(expect)), distance(actualIter, <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(actual)), L<span class="hljs-string"><span class="hljs-string">"Size differs."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(; expectIter != <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(expect) &amp;&amp; actualIter != <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(actual); ++expectIter, ++actualIter) { auto message = L<span class="hljs-string"><span class="hljs-string">"Mismatch in position "</span></span> + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual&lt;T&gt;(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange TEST_CLASS(LexerTests) { public: TEST_METHOD(Should_return_empty_token_list_when_put_empty_expression) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">""</span></span>); Assert::IsTrue(tokens.empty()); } TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"+"</span></span>); AssertRange::AreEqual({ Operator::Plus }, tokens); } TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"1"</span></span>); AssertRange::AreEqual({ <span class="hljs-number"><span class="hljs-number">1.0</span></span> }, tokens); } TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"12.34"</span></span>); AssertRange::AreEqual({ <span class="hljs-number"><span class="hljs-number">12.34</span></span> }, tokens); } TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"+12.34"</span></span>); AssertRange::AreEqual({ Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">12.34</span></span>) }, tokens); } TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">" 1 + 12.34 "</span></span>); AssertRange::AreEqual({ Token(<span class="hljs-number"><span class="hljs-number">1.0</span></span>), Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">12.34</span></span>) }, tokens); } TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"1+2*3/(4-5)"</span></span>); AssertRange::AreEqual({ Token(<span class="hljs-number"><span class="hljs-number">1</span></span>), Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">2</span></span>), Token(Operator::Mul), Token(<span class="hljs-number"><span class="hljs-number">3</span></span>), Token(Operator::Div), Token(Operator::LParen), Token(<span class="hljs-number"><span class="hljs-number">4</span></span>), Token(Operator::Minus), Token(<span class="hljs-number"><span class="hljs-number">5</span></span>), Token(Operator::RParen) }, tokens); } }; TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } TEST_METHOD(Should_get_type_for_number_token) { Token numToken(<span class="hljs-number"><span class="hljs-number">1.2</span></span>); Assert::AreEqual(TokenType::Number, numToken.Type()); } TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); } TEST_METHOD(Should_get_number_value_from_number_token) { Token token(<span class="hljs-number"><span class="hljs-number">1.23</span></span>); Assert::AreEqual&lt;double&gt;(<span class="hljs-number"><span class="hljs-number">1.23</span></span>, token); } }; }</code> <br> <br> <a href="https://github.com/Unril/InterpreterTDD/releases/tag/%25D0%259A%25D0%25BE%25D0%25BD%25D0%25B5%25D1%2586_%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B2%25D0%25BE%25D0%25B9_%25D1%2587%25D0%25B0%25D1%2581%25D1%2582%25D0%25B8">    GitHub</a> .         ,  .      <span class="hljs-string"><span class="hljs-string">"__"</span></span>. <br> <br>   <a href="http://habrahabr.ru/post/232081/">    </a> .      ,      <a href="http://habrahabr.ru/post/232097/">    </a> .</code> </pre> <code><code>std::vector,      Tokens</code> .            . <br> <br> <code class="cpp">#pragma once; #include &lt;vector&gt; namespace Interpreter { struct Token {}; typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { inline Tokens Tokenize(std::string expr) { throw std::exception(); } } // namespace Lexer } // namespace Interpreter</code> <br>   ,  ,   , .   ,    ,    <a href="http://cleancoder.posterous.com/the-transformation-priority-premise">The Transformation Priority Premise (TPP)</a>   .    , ,    ,     ,        .            .     ,     ,      ,           .  ,  ,   (   )    ,  ,  .     ,  ,         .     ,   TPP          . <br> <br>   : <br> <br> ({} ‚Üí nil)     ,   . (nil ‚Üí constant)    . (constant ‚Üí constant+)      (        ,  ). (constant ‚Üí scalar)    ,  . (statement ‚Üí statements)    (break, continue, return  ). (unconditional ‚Üí if)       . (scalar ‚Üí array)  / . (array ‚Üí container)     . (statement ‚Üí recursion)   . (if ‚Üí while)    . (expression ‚Üí function)   . (variable ‚Üí assignment)   . <br>        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::string expr) { return{}; }</code> <br> ,         .     . <br> <br> <s>         </s> .           .           .               .            .       . <br>  ,  <code>std::string</code>  <code>std::wstring</code> .         ,      Unicode.     . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); }</code> <br>  <code>AssertRange</code> -   ,       <code>AreEqual</code> ,   ,  ,    . <br> <br> <b class="spoiler_title">AssertRange</b> <code class="cpp">namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange</code> <br> <br>         <code>Operator</code>    .          <code>wchar_t</code>   ,         ,      . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', }; typedef Operator Token;</code> <br>    ,   ,        <code>Assert</code> ,    <code>ToString</code> ,    . <br> <br> <b class="spoiler_title">std::wstring ToString(const Token &amp;)</b> <code class="cpp">inline std::wstring ToString(const Token &amp;token) { return{ static_cast&lt;wchar_t&gt;(token) }; }</code> <br> <br>    ,   ,        .  ,   (unconditional ‚Üí if). <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { if(expr.empty()) { return{}; } return{ static_cast&lt;Operator&gt;(expr[0]) }; }</code> <br> <s>         </s> . <s>          .</s>           . ‚Ä¶ <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); }</code> <br>     .   ,     ,   - .    , : <br> <br>        ,      <code>Token</code> .       <code>dynamic_cast</code>    ,   .  ,    ,      .      <code>std::function</code>        .        .  Boost.Any,  - .            . <br>   ,   .      -  .  ,      ,      . <br> <br> ‚Ä¶        .        .        .        . <br>             . <br> <br> <code class="cpp">enum class TokenType { Operator, Number }; class Token { public: Token(Operator) {} TokenType Type() const { return TokenType::Operator; } }; ‚Ä¶ TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } };</code> <br>   <code>ToString</code>   <code>TokenType</code>       ,   ,   .     . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); }</code> <br>   .   (constant ‚Üí scalar)   . <br> <br> <code class="cpp">class Token { public: Token(Operator) :m_type(TokenType::Operator) {} Token(double) :m_type(TokenType::Number) {} TokenType Type() const { return m_type; } private: TokenType m_type; };</code> <br> ‚Ä¶ <s>       </s> . <s>       </s> .        .        . <br>    . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); }</code> <br>            . <br> <br> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} operator Operator() const { return m_operator; } ‚Ä¶ Operator m_operator; };</code> <br>      . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); }</code> <br>          ,  ,       <code>union</code> .         . <br> <br> <b class="spoiler_title">Token</b> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: return "Unknown token."; } }</code> <br> <br>  ,    ,      ,    .       .    . <br> <br> <i>          .</i>               .            .       . <br>        : <br> <br> <code class="cpp"> if(expr[0] &gt;= '0' &amp;&amp; expr[0] &lt;= '9') { return{ (double) expr[0] - '0' }; } return{ static_cast&lt;Operator&gt;(expr[0]) };</code> <br>      ,   . <br> <br> ‚Ä¶ <s>          .</s> <i>              .</i> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); }</code> <br> ,     <code>C</code>   ,  <code>isdigit</code> , ,       <code>atof</code> ,    ,      <code>wchar_t</code> .  (expression ‚Üí function).         . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { const wchar_t *current = expr.c_str(); if(!*current) return{}; if(iswdigit(*current)) return{ _wtof(current) }; return{ static_cast&lt;Operator&gt;(*current) }; }</code> <br>         .      . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>   ,        .  ,     .     .   <code>result</code> ,     . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); if(!*current) return result; if(iswdigit(*current)) { result.push_back(_wtof(current)); } else { result.push_back(static_cast&lt;Operator&gt;(*current)); } return result; }</code> <br>      :   (if ‚Üí while).     ,        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } } return result; }</code> <br>  <code>wcstod</code>    ,   <code>_wtof</code> ,           .           ,              .  ,    . <br> <br> <s>           .</s>       . <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>  (unconditional ‚Üí if)    ,    . <br> <br> <code class="cpp"> while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else if(*current == static_cast&lt;wchar_t&gt;(Operator::Plus)) { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } else { ++current; } }</code> <br>       .          .       <code>Detail</code>      .   <code>Tokenize</code>       . <br> <br> <code class="cpp">inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); }</code> <br> <b class="spoiler_title"> Detail::Tokenizer</b> <code class="cpp">namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { return *m_current == static_cast&lt;wchar_t&gt;(Operator::Plus); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail</code> <br> <br>  ,      .      ,  , .       . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); }</code> <br>      <code>Operator</code> ,    . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', };</code> <br>   .         <code>IsOperator</code>  <code>Tokenizer</code> . <br> <br> <code class="cpp"> bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); }</code> <br>         .        . <br> <br> <b class="spoiler_title">Interpreter.h</b> <code class="cpp">#pragma once; #include &lt;vector&gt; #include &lt;wchar.h&gt; #include &lt;algorithm&gt; namespace Interpreter { enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', }; inline std::wstring ToString(const Operator &amp;op) { return{ static_cast&lt;wchar_t&gt;(op) }; } enum class TokenType { Operator, Number }; inline std::wstring ToString(const TokenType &amp;type) { switch(type) { case TokenType::Operator: return L"Operator"; case TokenType::Number: return L"Number"; default: throw std::out_of_range("TokenType"); } } class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } friend inline bool operator==(const Token &amp;left, const Token &amp;right) { if(left.m_type == right.m_type) { switch(left.m_type) { case Interpreter::TokenType::Operator: return left.m_operator == right.m_operator; case Interpreter::TokenType::Number: return left.m_number == right.m_number; default: throw std::out_of_range("TokenType"); } } return false; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: throw std::out_of_range("TokenType"); } } typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); } } // namespace Lexer } // namespace Interpreter</code> <br> <br> <b class="spoiler_title">InterpreterTests.cpp</b> <code class="cpp">#include "stdafx.h" #include "CppUnitTest.h" #include "Interpreter.h" namespace InterpreterTests { using namespace Microsoft::VisualStudio::CppUnitTestFramework; using namespace Interpreter; using namespace std; namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual&lt;T&gt;(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange TEST_CLASS(LexerTests) { public: TEST_METHOD(Should_return_empty_token_list_when_put_empty_expression) { Tokens tokens = Lexer::Tokenize(L""); Assert::IsTrue(tokens.empty()); } TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); } TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); } TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); } TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); } }; TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); } TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); } TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); } }; }</code> <br> <br> <a href="https://github.com/Unril/InterpreterTDD/releases/tag/%25D0%259A%25D0%25BE%25D0%25BD%25D0%25B5%25D1%2586_%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B2%25D0%25BE%25D0%25B9_%25D1%2587%25D0%25B0%25D1%2581%25D1%2582%25D0%25B8">    GitHub</a> .         ,  .      "__". <br> <br>   <a href="http://habrahabr.ru/post/232081/">    </a> .      ,      <a href="http://habrahabr.ru/post/232097/">    </a> .</code> <ul><li> <code><code>std::vector,      Tokens</code> .            . <br> <br> <code class="cpp">#pragma once; #include &lt;vector&gt; namespace Interpreter { struct Token {}; typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { inline Tokens Tokenize(std::string expr) { throw std::exception(); } } // namespace Lexer } // namespace Interpreter</code> <br>   ,  ,   , .   ,    ,    <a href="http://cleancoder.posterous.com/the-transformation-priority-premise">The Transformation Priority Premise (TPP)</a>   .    , ,    ,     ,        .            .     ,     ,      ,           .  ,  ,   (   )    ,  ,  .     ,  ,         .     ,   TPP          . <br> <br>   : <br> <br> ({} ‚Üí nil)     ,   . (nil ‚Üí constant)    . (constant ‚Üí constant+)      (        ,  ). (constant ‚Üí scalar)    ,  . (statement ‚Üí statements)    (break, continue, return  ). (unconditional ‚Üí if)       . (scalar ‚Üí array)  / . (array ‚Üí container)     . (statement ‚Üí recursion)   . (if ‚Üí while)    . (expression ‚Üí function)   . (variable ‚Üí assignment)   . <br>        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::string expr) { return{}; }</code> <br> ,         .     . <br> <br> <s>         </s> .           .           .               .            .       . <br>  ,  <code>std::string</code>  <code>std::wstring</code> .         ,      Unicode.     . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); }</code> <br>  <code>AssertRange</code> -   ,       <code>AreEqual</code> ,   ,  ,    . <br> <br> <b class="spoiler_title">AssertRange</b> <code class="cpp">namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange</code> <br> <br>         <code>Operator</code>    .          <code>wchar_t</code>   ,         ,      . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', }; typedef Operator Token;</code> <br>    ,   ,        <code>Assert</code> ,    <code>ToString</code> ,    . <br> <br> <b class="spoiler_title">std::wstring ToString(const Token &amp;)</b> <code class="cpp">inline std::wstring ToString(const Token &amp;token) { return{ static_cast&lt;wchar_t&gt;(token) }; }</code> <br> <br>    ,   ,        .  ,   (unconditional ‚Üí if). <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { if(expr.empty()) { return{}; } return{ static_cast&lt;Operator&gt;(expr[0]) }; }</code> <br> <s>         </s> . <s>          .</s>           . ‚Ä¶ <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); }</code> <br>     .   ,     ,   - .    , : <br> <br>        ,      <code>Token</code> .       <code>dynamic_cast</code>    ,   .  ,    ,      .      <code>std::function</code>        .        .  Boost.Any,  - .            . <br>   ,   .      -  .  ,      ,      . <br> <br> ‚Ä¶        .        .        .        . <br>             . <br> <br> <code class="cpp">enum class TokenType { Operator, Number }; class Token { public: Token(Operator) {} TokenType Type() const { return TokenType::Operator; } }; ‚Ä¶ TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } };</code> <br>   <code>ToString</code>   <code>TokenType</code>       ,   ,   .     . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); }</code> <br>   .   (constant ‚Üí scalar)   . <br> <br> <code class="cpp">class Token { public: Token(Operator) :m_type(TokenType::Operator) {} Token(double) :m_type(TokenType::Number) {} TokenType Type() const { return m_type; } private: TokenType m_type; };</code> <br> ‚Ä¶ <s>       </s> . <s>       </s> .        .        . <br>    . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); }</code> <br>            . <br> <br> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} operator Operator() const { return m_operator; } ‚Ä¶ Operator m_operator; };</code> <br>      . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); }</code> <br>          ,  ,       <code>union</code> .         . <br> <br> <b class="spoiler_title">Token</b> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: return "Unknown token."; } }</code> <br> <br>  ,    ,      ,    .       .    . <br> <br> <i>          .</i>               .            .       . <br>        : <br> <br> <code class="cpp"> if(expr[0] &gt;= '0' &amp;&amp; expr[0] &lt;= '9') { return{ (double) expr[0] - '0' }; } return{ static_cast&lt;Operator&gt;(expr[0]) };</code> <br>      ,   . <br> <br> ‚Ä¶ <s>          .</s> <i>              .</i> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); }</code> <br> ,     <code>C</code>   ,  <code>isdigit</code> , ,       <code>atof</code> ,    ,      <code>wchar_t</code> .  (expression ‚Üí function).         . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { const wchar_t *current = expr.c_str(); if(!*current) return{}; if(iswdigit(*current)) return{ _wtof(current) }; return{ static_cast&lt;Operator&gt;(*current) }; }</code> <br>         .      . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>   ,        .  ,     .     .   <code>result</code> ,     . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); if(!*current) return result; if(iswdigit(*current)) { result.push_back(_wtof(current)); } else { result.push_back(static_cast&lt;Operator&gt;(*current)); } return result; }</code> <br>      :   (if ‚Üí while).     ,        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } } return result; }</code> <br>  <code>wcstod</code>    ,   <code>_wtof</code> ,           .           ,              .  ,    . <br> <br> <s>           .</s>       . <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>  (unconditional ‚Üí if)    ,    . <br> <br> <code class="cpp"> while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else if(*current == static_cast&lt;wchar_t&gt;(Operator::Plus)) { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } else { ++current; } }</code> <br>       .          .       <code>Detail</code>      .   <code>Tokenize</code>       . <br> <br> <code class="cpp">inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); }</code> <br> <b class="spoiler_title"> Detail::Tokenizer</b> <code class="cpp">namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { return *m_current == static_cast&lt;wchar_t&gt;(Operator::Plus); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail</code> <br> <br>  ,      .      ,  , .       . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); }</code> <br>      <code>Operator</code> ,    . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', };</code> <br>   .         <code>IsOperator</code>  <code>Tokenizer</code> . <br> <br> <code class="cpp"> bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); }</code> <br>         .        . <br> <br> <b class="spoiler_title">Interpreter.h</b> <code class="cpp">#pragma once; #include &lt;vector&gt; #include &lt;wchar.h&gt; #include &lt;algorithm&gt; namespace Interpreter { enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', }; inline std::wstring ToString(const Operator &amp;op) { return{ static_cast&lt;wchar_t&gt;(op) }; } enum class TokenType { Operator, Number }; inline std::wstring ToString(const TokenType &amp;type) { switch(type) { case TokenType::Operator: return L"Operator"; case TokenType::Number: return L"Number"; default: throw std::out_of_range("TokenType"); } } class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } friend inline bool operator==(const Token &amp;left, const Token &amp;right) { if(left.m_type == right.m_type) { switch(left.m_type) { case Interpreter::TokenType::Operator: return left.m_operator == right.m_operator; case Interpreter::TokenType::Number: return left.m_number == right.m_number; default: throw std::out_of_range("TokenType"); } } return false; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: throw std::out_of_range("TokenType"); } } typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); } } // namespace Lexer } // namespace Interpreter</code> <br> <br> <b class="spoiler_title">InterpreterTests.cpp</b> <code class="cpp">#include "stdafx.h" #include "CppUnitTest.h" #include "Interpreter.h" namespace InterpreterTests { using namespace Microsoft::VisualStudio::CppUnitTestFramework; using namespace Interpreter; using namespace std; namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual&lt;T&gt;(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange TEST_CLASS(LexerTests) { public: TEST_METHOD(Should_return_empty_token_list_when_put_empty_expression) { Tokens tokens = Lexer::Tokenize(L""); Assert::IsTrue(tokens.empty()); } TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); } TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); } TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); } TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); } }; TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); } TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); } TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); } }; }</code> <br> <br> <a href="https://github.com/Unril/InterpreterTDD/releases/tag/%25D0%259A%25D0%25BE%25D0%25BD%25D0%25B5%25D1%2586_%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B2%25D0%25BE%25D0%25B9_%25D1%2587%25D0%25B0%25D1%2581%25D1%2582%25D0%25B8">    GitHub</a> .         ,  .      "__". <br> <br>   <a href="http://habrahabr.ru/post/232081/">    </a> .      ,      <a href="http://habrahabr.ru/post/232097/">    </a> .</code> </li> <li> <code><code>std::vector,      Tokens</code> .            . <br> <br> <code class="cpp">#pragma once; #include &lt;vector&gt; namespace Interpreter { struct Token {}; typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { inline Tokens Tokenize(std::string expr) { throw std::exception(); } } // namespace Lexer } // namespace Interpreter</code> <br>   ,  ,   , .   ,    ,    <a href="http://cleancoder.posterous.com/the-transformation-priority-premise">The Transformation Priority Premise (TPP)</a>   .    , ,    ,     ,        .            .     ,     ,      ,           .  ,  ,   (   )    ,  ,  .     ,  ,         .     ,   TPP          . <br> <br>   : <br> <br> ({} ‚Üí nil)     ,   . (nil ‚Üí constant)    . (constant ‚Üí constant+)      (        ,  ). (constant ‚Üí scalar)    ,  . (statement ‚Üí statements)    (break, continue, return  ). (unconditional ‚Üí if)       . (scalar ‚Üí array)  / . (array ‚Üí container)     . (statement ‚Üí recursion)   . (if ‚Üí while)    . (expression ‚Üí function)   . (variable ‚Üí assignment)   . <br>        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::string expr) { return{}; }</code> <br> ,         .     . <br> <br> <s>         </s> .           .           .               .            .       . <br>  ,  <code>std::string</code>  <code>std::wstring</code> .         ,      Unicode.     . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); }</code> <br>  <code>AssertRange</code> -   ,       <code>AreEqual</code> ,   ,  ,    . <br> <br> <b class="spoiler_title">AssertRange</b> <code class="cpp">namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange</code> <br> <br>         <code>Operator</code>    .          <code>wchar_t</code>   ,         ,      . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', }; typedef Operator Token;</code> <br>    ,   ,        <code>Assert</code> ,    <code>ToString</code> ,    . <br> <br> <b class="spoiler_title">std::wstring ToString(const Token &amp;)</b> <code class="cpp">inline std::wstring ToString(const Token &amp;token) { return{ static_cast&lt;wchar_t&gt;(token) }; }</code> <br> <br>    ,   ,        .  ,   (unconditional ‚Üí if). <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { if(expr.empty()) { return{}; } return{ static_cast&lt;Operator&gt;(expr[0]) }; }</code> <br> <s>         </s> . <s>          .</s>           . ‚Ä¶ <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); }</code> <br>     .   ,     ,   - .    , : <br> <br>        ,      <code>Token</code> .       <code>dynamic_cast</code>    ,   .  ,    ,      .      <code>std::function</code>        .        .  Boost.Any,  - .            . <br>   ,   .      -  .  ,      ,      . <br> <br> ‚Ä¶        .        .        .        . <br>             . <br> <br> <code class="cpp">enum class TokenType { Operator, Number }; class Token { public: Token(Operator) {} TokenType Type() const { return TokenType::Operator; } }; ‚Ä¶ TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } };</code> <br>   <code>ToString</code>   <code>TokenType</code>       ,   ,   .     . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); }</code> <br>   .   (constant ‚Üí scalar)   . <br> <br> <code class="cpp">class Token { public: Token(Operator) :m_type(TokenType::Operator) {} Token(double) :m_type(TokenType::Number) {} TokenType Type() const { return m_type; } private: TokenType m_type; };</code> <br> ‚Ä¶ <s>       </s> . <s>       </s> .        .        . <br>    . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); }</code> <br>            . <br> <br> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} operator Operator() const { return m_operator; } ‚Ä¶ Operator m_operator; };</code> <br>      . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); }</code> <br>          ,  ,       <code>union</code> .         . <br> <br> <b class="spoiler_title">Token</b> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: return "Unknown token."; } }</code> <br> <br>  ,    ,      ,    .       .    . <br> <br> <i>          .</i>               .            .       . <br>        : <br> <br> <code class="cpp"> if(expr[0] &gt;= '0' &amp;&amp; expr[0] &lt;= '9') { return{ (double) expr[0] - '0' }; } return{ static_cast&lt;Operator&gt;(expr[0]) };</code> <br>      ,   . <br> <br> ‚Ä¶ <s>          .</s> <i>              .</i> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); }</code> <br> ,     <code>C</code>   ,  <code>isdigit</code> , ,       <code>atof</code> ,    ,      <code>wchar_t</code> .  (expression ‚Üí function).         . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { const wchar_t *current = expr.c_str(); if(!*current) return{}; if(iswdigit(*current)) return{ _wtof(current) }; return{ static_cast&lt;Operator&gt;(*current) }; }</code> <br>         .      . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>   ,        .  ,     .     .   <code>result</code> ,     . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); if(!*current) return result; if(iswdigit(*current)) { result.push_back(_wtof(current)); } else { result.push_back(static_cast&lt;Operator&gt;(*current)); } return result; }</code> <br>      :   (if ‚Üí while).     ,        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } } return result; }</code> <br>  <code>wcstod</code>    ,   <code>_wtof</code> ,           .           ,              .  ,    . <br> <br> <s>           .</s>       . <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>  (unconditional ‚Üí if)    ,    . <br> <br> <code class="cpp"> while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else if(*current == static_cast&lt;wchar_t&gt;(Operator::Plus)) { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } else { ++current; } }</code> <br>       .          .       <code>Detail</code>      .   <code>Tokenize</code>       . <br> <br> <code class="cpp">inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); }</code> <br> <b class="spoiler_title"> Detail::Tokenizer</b> <code class="cpp">namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { return *m_current == static_cast&lt;wchar_t&gt;(Operator::Plus); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail</code> <br> <br>  ,      .      ,  , .       . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); }</code> <br>      <code>Operator</code> ,    . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', };</code> <br>   .         <code>IsOperator</code>  <code>Tokenizer</code> . <br> <br> <code class="cpp"> bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); }</code> <br>         .        . <br> <br> <b class="spoiler_title">Interpreter.h</b> <code class="cpp">#pragma once; #include &lt;vector&gt; #include &lt;wchar.h&gt; #include &lt;algorithm&gt; namespace Interpreter { enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', }; inline std::wstring ToString(const Operator &amp;op) { return{ static_cast&lt;wchar_t&gt;(op) }; } enum class TokenType { Operator, Number }; inline std::wstring ToString(const TokenType &amp;type) { switch(type) { case TokenType::Operator: return L"Operator"; case TokenType::Number: return L"Number"; default: throw std::out_of_range("TokenType"); } } class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } friend inline bool operator==(const Token &amp;left, const Token &amp;right) { if(left.m_type == right.m_type) { switch(left.m_type) { case Interpreter::TokenType::Operator: return left.m_operator == right.m_operator; case Interpreter::TokenType::Number: return left.m_number == right.m_number; default: throw std::out_of_range("TokenType"); } } return false; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: throw std::out_of_range("TokenType"); } } typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); } } // namespace Lexer } // namespace Interpreter</code> <br> <br> <b class="spoiler_title">InterpreterTests.cpp</b> <code class="cpp">#include "stdafx.h" #include "CppUnitTest.h" #include "Interpreter.h" namespace InterpreterTests { using namespace Microsoft::VisualStudio::CppUnitTestFramework; using namespace Interpreter; using namespace std; namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual&lt;T&gt;(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange TEST_CLASS(LexerTests) { public: TEST_METHOD(Should_return_empty_token_list_when_put_empty_expression) { Tokens tokens = Lexer::Tokenize(L""); Assert::IsTrue(tokens.empty()); } TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); } TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); } TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); } TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); } }; TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); } TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); } TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); } }; }</code> <br> <br> <a href="https://github.com/Unril/InterpreterTDD/releases/tag/%25D0%259A%25D0%25BE%25D0%25BD%25D0%25B5%25D1%2586_%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B2%25D0%25BE%25D0%25B9_%25D1%2587%25D0%25B0%25D1%2581%25D1%2582%25D0%25B8">    GitHub</a> .         ,  .      "__". <br> <br>   <a href="http://habrahabr.ru/post/232081/">    </a> .      ,      <a href="http://habrahabr.ru/post/232097/">    </a> .</code> </li> <li> <code><code>std::vector,      Tokens</code> .            . <br> <br> <code class="cpp">#pragma once; #include &lt;vector&gt; namespace Interpreter { struct Token {}; typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { inline Tokens Tokenize(std::string expr) { throw std::exception(); } } // namespace Lexer } // namespace Interpreter</code> <br>   ,  ,   , .   ,    ,    <a href="http://cleancoder.posterous.com/the-transformation-priority-premise">The Transformation Priority Premise (TPP)</a>   .    , ,    ,     ,        .            .     ,     ,      ,           .  ,  ,   (   )    ,  ,  .     ,  ,         .     ,   TPP          . <br> <br>   : <br> <br> ({} ‚Üí nil)     ,   . (nil ‚Üí constant)    . (constant ‚Üí constant+)      (        ,  ). (constant ‚Üí scalar)    ,  . (statement ‚Üí statements)    (break, continue, return  ). (unconditional ‚Üí if)       . (scalar ‚Üí array)  / . (array ‚Üí container)     . (statement ‚Üí recursion)   . (if ‚Üí while)    . (expression ‚Üí function)   . (variable ‚Üí assignment)   . <br>        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::string expr) { return{}; }</code> <br> ,         .     . <br> <br> <s>         </s> .           .           .               .            .       . <br>  ,  <code>std::string</code>  <code>std::wstring</code> .         ,      Unicode.     . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); }</code> <br>  <code>AssertRange</code> -   ,       <code>AreEqual</code> ,   ,  ,    . <br> <br> <b class="spoiler_title">AssertRange</b> <code class="cpp">namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange</code> <br> <br>         <code>Operator</code>    .          <code>wchar_t</code>   ,         ,      . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', }; typedef Operator Token;</code> <br>    ,   ,        <code>Assert</code> ,    <code>ToString</code> ,    . <br> <br> <b class="spoiler_title">std::wstring ToString(const Token &amp;)</b> <code class="cpp">inline std::wstring ToString(const Token &amp;token) { return{ static_cast&lt;wchar_t&gt;(token) }; }</code> <br> <br>    ,   ,        .  ,   (unconditional ‚Üí if). <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { if(expr.empty()) { return{}; } return{ static_cast&lt;Operator&gt;(expr[0]) }; }</code> <br> <s>         </s> . <s>          .</s>           . ‚Ä¶ <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); }</code> <br>     .   ,     ,   - .    , : <br> <br>        ,      <code>Token</code> .       <code>dynamic_cast</code>    ,   .  ,    ,      .      <code>std::function</code>        .        .  Boost.Any,  - .            . <br>   ,   .      -  .  ,      ,      . <br> <br> ‚Ä¶        .        .        .        . <br>             . <br> <br> <code class="cpp">enum class TokenType { Operator, Number }; class Token { public: Token(Operator) {} TokenType Type() const { return TokenType::Operator; } }; ‚Ä¶ TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } };</code> <br>   <code>ToString</code>   <code>TokenType</code>       ,   ,   .     . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); }</code> <br>   .   (constant ‚Üí scalar)   . <br> <br> <code class="cpp">class Token { public: Token(Operator) :m_type(TokenType::Operator) {} Token(double) :m_type(TokenType::Number) {} TokenType Type() const { return m_type; } private: TokenType m_type; };</code> <br> ‚Ä¶ <s>       </s> . <s>       </s> .        .        . <br>    . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); }</code> <br>            . <br> <br> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} operator Operator() const { return m_operator; } ‚Ä¶ Operator m_operator; };</code> <br>      . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); }</code> <br>          ,  ,       <code>union</code> .         . <br> <br> <b class="spoiler_title">Token</b> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: return "Unknown token."; } }</code> <br> <br>  ,    ,      ,    .       .    . <br> <br> <i>          .</i>               .            .       . <br>        : <br> <br> <code class="cpp"> if(expr[0] &gt;= '0' &amp;&amp; expr[0] &lt;= '9') { return{ (double) expr[0] - '0' }; } return{ static_cast&lt;Operator&gt;(expr[0]) };</code> <br>      ,   . <br> <br> ‚Ä¶ <s>          .</s> <i>              .</i> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); }</code> <br> ,     <code>C</code>   ,  <code>isdigit</code> , ,       <code>atof</code> ,    ,      <code>wchar_t</code> .  (expression ‚Üí function).         . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { const wchar_t *current = expr.c_str(); if(!*current) return{}; if(iswdigit(*current)) return{ _wtof(current) }; return{ static_cast&lt;Operator&gt;(*current) }; }</code> <br>         .      . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>   ,        .  ,     .     .   <code>result</code> ,     . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); if(!*current) return result; if(iswdigit(*current)) { result.push_back(_wtof(current)); } else { result.push_back(static_cast&lt;Operator&gt;(*current)); } return result; }</code> <br>      :   (if ‚Üí while).     ,        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } } return result; }</code> <br>  <code>wcstod</code>    ,   <code>_wtof</code> ,           .           ,              .  ,    . <br> <br> <s>           .</s>       . <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>  (unconditional ‚Üí if)    ,    . <br> <br> <code class="cpp"> while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else if(*current == static_cast&lt;wchar_t&gt;(Operator::Plus)) { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } else { ++current; } }</code> <br>       .          .       <code>Detail</code>      .   <code>Tokenize</code>       . <br> <br> <code class="cpp">inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); }</code> <br> <b class="spoiler_title"> Detail::Tokenizer</b> <code class="cpp">namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { return *m_current == static_cast&lt;wchar_t&gt;(Operator::Plus); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail</code> <br> <br>  ,      .      ,  , .       . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); }</code> <br>      <code>Operator</code> ,    . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', };</code> <br>   .         <code>IsOperator</code>  <code>Tokenizer</code> . <br> <br> <code class="cpp"> bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); }</code> <br>         .        . <br> <br> <b class="spoiler_title">Interpreter.h</b> <code class="cpp">#pragma once; #include &lt;vector&gt; #include &lt;wchar.h&gt; #include &lt;algorithm&gt; namespace Interpreter { enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', }; inline std::wstring ToString(const Operator &amp;op) { return{ static_cast&lt;wchar_t&gt;(op) }; } enum class TokenType { Operator, Number }; inline std::wstring ToString(const TokenType &amp;type) { switch(type) { case TokenType::Operator: return L"Operator"; case TokenType::Number: return L"Number"; default: throw std::out_of_range("TokenType"); } } class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } friend inline bool operator==(const Token &amp;left, const Token &amp;right) { if(left.m_type == right.m_type) { switch(left.m_type) { case Interpreter::TokenType::Operator: return left.m_operator == right.m_operator; case Interpreter::TokenType::Number: return left.m_number == right.m_number; default: throw std::out_of_range("TokenType"); } } return false; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: throw std::out_of_range("TokenType"); } } typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); } } // namespace Lexer } // namespace Interpreter</code> <br> <br> <b class="spoiler_title">InterpreterTests.cpp</b> <code class="cpp">#include "stdafx.h" #include "CppUnitTest.h" #include "Interpreter.h" namespace InterpreterTests { using namespace Microsoft::VisualStudio::CppUnitTestFramework; using namespace Interpreter; using namespace std; namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual&lt;T&gt;(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange TEST_CLASS(LexerTests) { public: TEST_METHOD(Should_return_empty_token_list_when_put_empty_expression) { Tokens tokens = Lexer::Tokenize(L""); Assert::IsTrue(tokens.empty()); } TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); } TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); } TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); } TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); } }; TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); } TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); } TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); } }; }</code> <br> <br> <a href="https://github.com/Unril/InterpreterTDD/releases/tag/%25D0%259A%25D0%25BE%25D0%25BD%25D0%25B5%25D1%2586_%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B2%25D0%25BE%25D0%25B9_%25D1%2587%25D0%25B0%25D1%2581%25D1%2582%25D0%25B8">    GitHub</a> .         ,  .      "__". <br> <br>   <a href="http://habrahabr.ru/post/232081/">    </a> .      ,      <a href="http://habrahabr.ru/post/232097/">    </a> .</code> </li> <li> <code><code>std::vector,      Tokens</code> .            . <br> <br> <code class="cpp">#pragma once; #include &lt;vector&gt; namespace Interpreter { struct Token {}; typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { inline Tokens Tokenize(std::string expr) { throw std::exception(); } } // namespace Lexer } // namespace Interpreter</code> <br>   ,  ,   , .   ,    ,    <a href="http://cleancoder.posterous.com/the-transformation-priority-premise">The Transformation Priority Premise (TPP)</a>   .    , ,    ,     ,        .            .     ,     ,      ,           .  ,  ,   (   )    ,  ,  .     ,  ,         .     ,   TPP          . <br> <br>   : <br> <br> ({} ‚Üí nil)     ,   . (nil ‚Üí constant)    . (constant ‚Üí constant+)      (        ,  ). (constant ‚Üí scalar)    ,  . (statement ‚Üí statements)    (break, continue, return  ). (unconditional ‚Üí if)       . (scalar ‚Üí array)  / . (array ‚Üí container)     . (statement ‚Üí recursion)   . (if ‚Üí while)    . (expression ‚Üí function)   . (variable ‚Üí assignment)   . <br>        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::string expr) { return{}; }</code> <br> ,         .     . <br> <br> <s>         </s> .           .           .               .            .       . <br>  ,  <code>std::string</code>  <code>std::wstring</code> .         ,      Unicode.     . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); }</code> <br>  <code>AssertRange</code> -   ,       <code>AreEqual</code> ,   ,  ,    . <br> <br> <b class="spoiler_title">AssertRange</b> <code class="cpp">namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange</code> <br> <br>         <code>Operator</code>    .          <code>wchar_t</code>   ,         ,      . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', }; typedef Operator Token;</code> <br>    ,   ,        <code>Assert</code> ,    <code>ToString</code> ,    . <br> <br> <b class="spoiler_title">std::wstring ToString(const Token &amp;)</b> <code class="cpp">inline std::wstring ToString(const Token &amp;token) { return{ static_cast&lt;wchar_t&gt;(token) }; }</code> <br> <br>    ,   ,        .  ,   (unconditional ‚Üí if). <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { if(expr.empty()) { return{}; } return{ static_cast&lt;Operator&gt;(expr[0]) }; }</code> <br> <s>         </s> . <s>          .</s>           . ‚Ä¶ <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); }</code> <br>     .   ,     ,   - .    , : <br> <br>        ,      <code>Token</code> .       <code>dynamic_cast</code>    ,   .  ,    ,      .      <code>std::function</code>        .        .  Boost.Any,  - .            . <br>   ,   .      -  .  ,      ,      . <br> <br> ‚Ä¶        .        .        .        . <br>             . <br> <br> <code class="cpp">enum class TokenType { Operator, Number }; class Token { public: Token(Operator) {} TokenType Type() const { return TokenType::Operator; } }; ‚Ä¶ TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } };</code> <br>   <code>ToString</code>   <code>TokenType</code>       ,   ,   .     . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); }</code> <br>   .   (constant ‚Üí scalar)   . <br> <br> <code class="cpp">class Token { public: Token(Operator) :m_type(TokenType::Operator) {} Token(double) :m_type(TokenType::Number) {} TokenType Type() const { return m_type; } private: TokenType m_type; };</code> <br> ‚Ä¶ <s>       </s> . <s>       </s> .        .        . <br>    . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); }</code> <br>            . <br> <br> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} operator Operator() const { return m_operator; } ‚Ä¶ Operator m_operator; };</code> <br>      . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); }</code> <br>          ,  ,       <code>union</code> .         . <br> <br> <b class="spoiler_title">Token</b> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: return "Unknown token."; } }</code> <br> <br>  ,    ,      ,    .       .    . <br> <br> <i>          .</i>               .            .       . <br>        : <br> <br> <code class="cpp"> if(expr[0] &gt;= '0' &amp;&amp; expr[0] &lt;= '9') { return{ (double) expr[0] - '0' }; } return{ static_cast&lt;Operator&gt;(expr[0]) };</code> <br>      ,   . <br> <br> ‚Ä¶ <s>          .</s> <i>              .</i> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); }</code> <br> ,     <code>C</code>   ,  <code>isdigit</code> , ,       <code>atof</code> ,    ,      <code>wchar_t</code> .  (expression ‚Üí function).         . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { const wchar_t *current = expr.c_str(); if(!*current) return{}; if(iswdigit(*current)) return{ _wtof(current) }; return{ static_cast&lt;Operator&gt;(*current) }; }</code> <br>         .      . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>   ,        .  ,     .     .   <code>result</code> ,     . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); if(!*current) return result; if(iswdigit(*current)) { result.push_back(_wtof(current)); } else { result.push_back(static_cast&lt;Operator&gt;(*current)); } return result; }</code> <br>      :   (if ‚Üí while).     ,        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } } return result; }</code> <br>  <code>wcstod</code>    ,   <code>_wtof</code> ,           .           ,              .  ,    . <br> <br> <s>           .</s>       . <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>  (unconditional ‚Üí if)    ,    . <br> <br> <code class="cpp"> while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else if(*current == static_cast&lt;wchar_t&gt;(Operator::Plus)) { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } else { ++current; } }</code> <br>       .          .       <code>Detail</code>      .   <code>Tokenize</code>       . <br> <br> <code class="cpp">inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); }</code> <br> <b class="spoiler_title"> Detail::Tokenizer</b> <code class="cpp">namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { return *m_current == static_cast&lt;wchar_t&gt;(Operator::Plus); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail</code> <br> <br>  ,      .      ,  , .       . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); }</code> <br>      <code>Operator</code> ,    . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', };</code> <br>   .         <code>IsOperator</code>  <code>Tokenizer</code> . <br> <br> <code class="cpp"> bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); }</code> <br>         .        . <br> <br> <b class="spoiler_title">Interpreter.h</b> <code class="cpp">#pragma once; #include &lt;vector&gt; #include &lt;wchar.h&gt; #include &lt;algorithm&gt; namespace Interpreter { enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', }; inline std::wstring ToString(const Operator &amp;op) { return{ static_cast&lt;wchar_t&gt;(op) }; } enum class TokenType { Operator, Number }; inline std::wstring ToString(const TokenType &amp;type) { switch(type) { case TokenType::Operator: return L"Operator"; case TokenType::Number: return L"Number"; default: throw std::out_of_range("TokenType"); } } class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } friend inline bool operator==(const Token &amp;left, const Token &amp;right) { if(left.m_type == right.m_type) { switch(left.m_type) { case Interpreter::TokenType::Operator: return left.m_operator == right.m_operator; case Interpreter::TokenType::Number: return left.m_number == right.m_number; default: throw std::out_of_range("TokenType"); } } return false; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: throw std::out_of_range("TokenType"); } } typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); } } // namespace Lexer } // namespace Interpreter</code> <br> <br> <b class="spoiler_title">InterpreterTests.cpp</b> <code class="cpp">#include "stdafx.h" #include "CppUnitTest.h" #include "Interpreter.h" namespace InterpreterTests { using namespace Microsoft::VisualStudio::CppUnitTestFramework; using namespace Interpreter; using namespace std; namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual&lt;T&gt;(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange TEST_CLASS(LexerTests) { public: TEST_METHOD(Should_return_empty_token_list_when_put_empty_expression) { Tokens tokens = Lexer::Tokenize(L""); Assert::IsTrue(tokens.empty()); } TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); } TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); } TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); } TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); } }; TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); } TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); } TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); } }; }</code> <br> <br> <a href="https://github.com/Unril/InterpreterTDD/releases/tag/%25D0%259A%25D0%25BE%25D0%25BD%25D0%25B5%25D1%2586_%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B2%25D0%25BE%25D0%25B9_%25D1%2587%25D0%25B0%25D1%2581%25D1%2582%25D0%25B8">    GitHub</a> .         ,  .      "__". <br> <br>   <a href="http://habrahabr.ru/post/232081/">    </a> .      ,      <a href="http://habrahabr.ru/post/232097/">    </a> .</code> </li> <li> <code><code>std::vector,      Tokens</code> .            . <br> <br> <code class="cpp">#pragma once; #include &lt;vector&gt; namespace Interpreter { struct Token {}; typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { inline Tokens Tokenize(std::string expr) { throw std::exception(); } } // namespace Lexer } // namespace Interpreter</code> <br>   ,  ,   , .   ,    ,    <a href="http://cleancoder.posterous.com/the-transformation-priority-premise">The Transformation Priority Premise (TPP)</a>   .    , ,    ,     ,        .            .     ,     ,      ,           .  ,  ,   (   )    ,  ,  .     ,  ,         .     ,   TPP          . <br> <br>   : <br> <br> ({} ‚Üí nil)     ,   . (nil ‚Üí constant)    . (constant ‚Üí constant+)      (        ,  ). (constant ‚Üí scalar)    ,  . (statement ‚Üí statements)    (break, continue, return  ). (unconditional ‚Üí if)       . (scalar ‚Üí array)  / . (array ‚Üí container)     . (statement ‚Üí recursion)   . (if ‚Üí while)    . (expression ‚Üí function)   . (variable ‚Üí assignment)   . <br>        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::string expr) { return{}; }</code> <br> ,         .     . <br> <br> <s>         </s> .           .           .               .            .       . <br>  ,  <code>std::string</code>  <code>std::wstring</code> .         ,      Unicode.     . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); }</code> <br>  <code>AssertRange</code> -   ,       <code>AreEqual</code> ,   ,  ,    . <br> <br> <b class="spoiler_title">AssertRange</b> <code class="cpp">namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange</code> <br> <br>         <code>Operator</code>    .          <code>wchar_t</code>   ,         ,      . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', }; typedef Operator Token;</code> <br>    ,   ,        <code>Assert</code> ,    <code>ToString</code> ,    . <br> <br> <b class="spoiler_title">std::wstring ToString(const Token &amp;)</b> <code class="cpp">inline std::wstring ToString(const Token &amp;token) { return{ static_cast&lt;wchar_t&gt;(token) }; }</code> <br> <br>    ,   ,        .  ,   (unconditional ‚Üí if). <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { if(expr.empty()) { return{}; } return{ static_cast&lt;Operator&gt;(expr[0]) }; }</code> <br> <s>         </s> . <s>          .</s>           . ‚Ä¶ <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); }</code> <br>     .   ,     ,   - .    , : <br> <br>        ,      <code>Token</code> .       <code>dynamic_cast</code>    ,   .  ,    ,      .      <code>std::function</code>        .        .  Boost.Any,  - .            . <br>   ,   .      -  .  ,      ,      . <br> <br> ‚Ä¶        .        .        .        . <br>             . <br> <br> <code class="cpp">enum class TokenType { Operator, Number }; class Token { public: Token(Operator) {} TokenType Type() const { return TokenType::Operator; } }; ‚Ä¶ TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } };</code> <br>   <code>ToString</code>   <code>TokenType</code>       ,   ,   .     . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); }</code> <br>   .   (constant ‚Üí scalar)   . <br> <br> <code class="cpp">class Token { public: Token(Operator) :m_type(TokenType::Operator) {} Token(double) :m_type(TokenType::Number) {} TokenType Type() const { return m_type; } private: TokenType m_type; };</code> <br> ‚Ä¶ <s>       </s> . <s>       </s> .        .        . <br>    . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); }</code> <br>            . <br> <br> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} operator Operator() const { return m_operator; } ‚Ä¶ Operator m_operator; };</code> <br>      . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); }</code> <br>          ,  ,       <code>union</code> .         . <br> <br> <b class="spoiler_title">Token</b> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: return "Unknown token."; } }</code> <br> <br>  ,    ,      ,    .       .    . <br> <br> <i>          .</i>               .            .       . <br>        : <br> <br> <code class="cpp"> if(expr[0] &gt;= '0' &amp;&amp; expr[0] &lt;= '9') { return{ (double) expr[0] - '0' }; } return{ static_cast&lt;Operator&gt;(expr[0]) };</code> <br>      ,   . <br> <br> ‚Ä¶ <s>          .</s> <i>              .</i> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); }</code> <br> ,     <code>C</code>   ,  <code>isdigit</code> , ,       <code>atof</code> ,    ,      <code>wchar_t</code> .  (expression ‚Üí function).         . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { const wchar_t *current = expr.c_str(); if(!*current) return{}; if(iswdigit(*current)) return{ _wtof(current) }; return{ static_cast&lt;Operator&gt;(*current) }; }</code> <br>         .      . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>   ,        .  ,     .     .   <code>result</code> ,     . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); if(!*current) return result; if(iswdigit(*current)) { result.push_back(_wtof(current)); } else { result.push_back(static_cast&lt;Operator&gt;(*current)); } return result; }</code> <br>      :   (if ‚Üí while).     ,        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } } return result; }</code> <br>  <code>wcstod</code>    ,   <code>_wtof</code> ,           .           ,              .  ,    . <br> <br> <s>           .</s>       . <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>  (unconditional ‚Üí if)    ,    . <br> <br> <code class="cpp"> while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else if(*current == static_cast&lt;wchar_t&gt;(Operator::Plus)) { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } else { ++current; } }</code> <br>       .          .       <code>Detail</code>      .   <code>Tokenize</code>       . <br> <br> <code class="cpp">inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); }</code> <br> <b class="spoiler_title"> Detail::Tokenizer</b> <code class="cpp">namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { return *m_current == static_cast&lt;wchar_t&gt;(Operator::Plus); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail</code> <br> <br>  ,      .      ,  , .       . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); }</code> <br>      <code>Operator</code> ,    . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', };</code> <br>   .         <code>IsOperator</code>  <code>Tokenizer</code> . <br> <br> <code class="cpp"> bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); }</code> <br>         .        . <br> <br> <b class="spoiler_title">Interpreter.h</b> <code class="cpp">#pragma once; #include &lt;vector&gt; #include &lt;wchar.h&gt; #include &lt;algorithm&gt; namespace Interpreter { enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', }; inline std::wstring ToString(const Operator &amp;op) { return{ static_cast&lt;wchar_t&gt;(op) }; } enum class TokenType { Operator, Number }; inline std::wstring ToString(const TokenType &amp;type) { switch(type) { case TokenType::Operator: return L"Operator"; case TokenType::Number: return L"Number"; default: throw std::out_of_range("TokenType"); } } class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } friend inline bool operator==(const Token &amp;left, const Token &amp;right) { if(left.m_type == right.m_type) { switch(left.m_type) { case Interpreter::TokenType::Operator: return left.m_operator == right.m_operator; case Interpreter::TokenType::Number: return left.m_number == right.m_number; default: throw std::out_of_range("TokenType"); } } return false; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: throw std::out_of_range("TokenType"); } } typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); } } // namespace Lexer } // namespace Interpreter</code> <br> <br> <b class="spoiler_title">InterpreterTests.cpp</b> <code class="cpp">#include "stdafx.h" #include "CppUnitTest.h" #include "Interpreter.h" namespace InterpreterTests { using namespace Microsoft::VisualStudio::CppUnitTestFramework; using namespace Interpreter; using namespace std; namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual&lt;T&gt;(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange TEST_CLASS(LexerTests) { public: TEST_METHOD(Should_return_empty_token_list_when_put_empty_expression) { Tokens tokens = Lexer::Tokenize(L""); Assert::IsTrue(tokens.empty()); } TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); } TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); } TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); } TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); } }; TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); } TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); } TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); } }; }</code> <br> <br> <a href="https://github.com/Unril/InterpreterTDD/releases/tag/%25D0%259A%25D0%25BE%25D0%25BD%25D0%25B5%25D1%2586_%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B2%25D0%25BE%25D0%25B9_%25D1%2587%25D0%25B0%25D1%2581%25D1%2582%25D0%25B8">    GitHub</a> .         ,  .      "__". <br> <br>   <a href="http://habrahabr.ru/post/232081/">    </a> .      ,      <a href="http://habrahabr.ru/post/232097/">    </a> .</code> </li> </ul> <code><code>std::vector,      Tokens</code> .            . <br> <br> <code class="cpp">#pragma once; #include &lt;vector&gt; namespace Interpreter { struct Token {}; typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { inline Tokens Tokenize(std::string expr) { throw std::exception(); } } // namespace Lexer } // namespace Interpreter</code> <br>   ,  ,   , .   ,    ,    <a href="http://cleancoder.posterous.com/the-transformation-priority-premise">The Transformation Priority Premise (TPP)</a>   .    , ,    ,     ,        .            .     ,     ,      ,           .  ,  ,   (   )    ,  ,  .     ,  ,         .     ,   TPP          . <br> <br>   : <br> <br> ({} ‚Üí nil)     ,   . (nil ‚Üí constant)    . (constant ‚Üí constant+)      (        ,  ). (constant ‚Üí scalar)    ,  . (statement ‚Üí statements)    (break, continue, return  ). (unconditional ‚Üí if)       . (scalar ‚Üí array)  / . (array ‚Üí container)     . (statement ‚Üí recursion)   . (if ‚Üí while)    . (expression ‚Üí function)   . (variable ‚Üí assignment)   . <br>        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::string expr) { return{}; }</code> <br> ,         .     . <br> <br> <s>         </s> .           .           .               .            .       . <br>  ,  <code>std::string</code>  <code>std::wstring</code> .         ,      Unicode.     . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); }</code> <br>  <code>AssertRange</code> -   ,       <code>AreEqual</code> ,   ,  ,    . <br> <br> <b class="spoiler_title">AssertRange</b> <code class="cpp">namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange</code> <br> <br>         <code>Operator</code>    .          <code>wchar_t</code>   ,         ,      . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', }; typedef Operator Token;</code> <br>    ,   ,        <code>Assert</code> ,    <code>ToString</code> ,    . <br> <br> <b class="spoiler_title">std::wstring ToString(const Token &amp;)</b> <code class="cpp">inline std::wstring ToString(const Token &amp;token) { return{ static_cast&lt;wchar_t&gt;(token) }; }</code> <br> <br>    ,   ,        .  ,   (unconditional ‚Üí if). <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { if(expr.empty()) { return{}; } return{ static_cast&lt;Operator&gt;(expr[0]) }; }</code> <br> <s>         </s> . <s>          .</s>           . ‚Ä¶ <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); }</code> <br>     .   ,     ,   - .    , : <br> <br>        ,      <code>Token</code> .       <code>dynamic_cast</code>    ,   .  ,    ,      .      <code>std::function</code>        .        .  Boost.Any,  - .            . <br>   ,   .      -  .  ,      ,      . <br> <br> ‚Ä¶        .        .        .        . <br>             . <br> <br> <code class="cpp">enum class TokenType { Operator, Number }; class Token { public: Token(Operator) {} TokenType Type() const { return TokenType::Operator; } }; ‚Ä¶ TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } };</code> <br>   <code>ToString</code>   <code>TokenType</code>       ,   ,   .     . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); }</code> <br>   .   (constant ‚Üí scalar)   . <br> <br> <code class="cpp">class Token { public: Token(Operator) :m_type(TokenType::Operator) {} Token(double) :m_type(TokenType::Number) {} TokenType Type() const { return m_type; } private: TokenType m_type; };</code> <br> ‚Ä¶ <s>       </s> . <s>       </s> .        .        . <br>    . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); }</code> <br>            . <br> <br> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} operator Operator() const { return m_operator; } ‚Ä¶ Operator m_operator; };</code> <br>      . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); }</code> <br>          ,  ,       <code>union</code> .         . <br> <br> <b class="spoiler_title">Token</b> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: return "Unknown token."; } }</code> <br> <br>  ,    ,      ,    .       .    . <br> <br> <i>          .</i>               .            .       . <br>        : <br> <br> <code class="cpp"> if(expr[0] &gt;= '0' &amp;&amp; expr[0] &lt;= '9') { return{ (double) expr[0] - '0' }; } return{ static_cast&lt;Operator&gt;(expr[0]) };</code> <br>      ,   . <br> <br> ‚Ä¶ <s>          .</s> <i>              .</i> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); }</code> <br> ,     <code>C</code>   ,  <code>isdigit</code> , ,       <code>atof</code> ,    ,      <code>wchar_t</code> .  (expression ‚Üí function).         . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { const wchar_t *current = expr.c_str(); if(!*current) return{}; if(iswdigit(*current)) return{ _wtof(current) }; return{ static_cast&lt;Operator&gt;(*current) }; }</code> <br>         .      . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>   ,        .  ,     .     .   <code>result</code> ,     . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); if(!*current) return result; if(iswdigit(*current)) { result.push_back(_wtof(current)); } else { result.push_back(static_cast&lt;Operator&gt;(*current)); } return result; }</code> <br>      :   (if ‚Üí while).     ,        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } } return result; }</code> <br>  <code>wcstod</code>    ,   <code>_wtof</code> ,           .           ,              .  ,    . <br> <br> <s>           .</s>       . <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>  (unconditional ‚Üí if)    ,    . <br> <br> <code class="cpp"> while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else if(*current == static_cast&lt;wchar_t&gt;(Operator::Plus)) { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } else { ++current; } }</code> <br>       .          .       <code>Detail</code>      .   <code>Tokenize</code>       . <br> <br> <code class="cpp">inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); }</code> <br> <b class="spoiler_title"> Detail::Tokenizer</b> <code class="cpp">namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { return *m_current == static_cast&lt;wchar_t&gt;(Operator::Plus); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail</code> <br> <br>  ,      .      ,  , .       . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); }</code> <br>      <code>Operator</code> ,    . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', };</code> <br>   .         <code>IsOperator</code>  <code>Tokenizer</code> . <br> <br> <code class="cpp"> bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); }</code> <br>         .        . <br> <br> <b class="spoiler_title">Interpreter.h</b> <code class="cpp">#pragma once; #include &lt;vector&gt; #include &lt;wchar.h&gt; #include &lt;algorithm&gt; namespace Interpreter { enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', }; inline std::wstring ToString(const Operator &amp;op) { return{ static_cast&lt;wchar_t&gt;(op) }; } enum class TokenType { Operator, Number }; inline std::wstring ToString(const TokenType &amp;type) { switch(type) { case TokenType::Operator: return L"Operator"; case TokenType::Number: return L"Number"; default: throw std::out_of_range("TokenType"); } } class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } friend inline bool operator==(const Token &amp;left, const Token &amp;right) { if(left.m_type == right.m_type) { switch(left.m_type) { case Interpreter::TokenType::Operator: return left.m_operator == right.m_operator; case Interpreter::TokenType::Number: return left.m_number == right.m_number; default: throw std::out_of_range("TokenType"); } } return false; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: throw std::out_of_range("TokenType"); } } typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); } } // namespace Lexer } // namespace Interpreter</code> <br> <br> <b class="spoiler_title">InterpreterTests.cpp</b> <code class="cpp">#include "stdafx.h" #include "CppUnitTest.h" #include "Interpreter.h" namespace InterpreterTests { using namespace Microsoft::VisualStudio::CppUnitTestFramework; using namespace Interpreter; using namespace std; namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual&lt;T&gt;(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange TEST_CLASS(LexerTests) { public: TEST_METHOD(Should_return_empty_token_list_when_put_empty_expression) { Tokens tokens = Lexer::Tokenize(L""); Assert::IsTrue(tokens.empty()); } TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); } TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); } TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); } TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); } }; TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); } TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); } TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); } }; }</code> <br> <br> <a href="https://github.com/Unril/InterpreterTDD/releases/tag/%25D0%259A%25D0%25BE%25D0%25BD%25D0%25B5%25D1%2586_%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B2%25D0%25BE%25D0%25B9_%25D1%2587%25D0%25B0%25D1%2581%25D1%2582%25D0%25B8">    GitHub</a> .         ,  .      "__". <br> <br>   <a href="http://habrahabr.ru/post/232081/">    </a> .      ,      <a href="http://habrahabr.ru/post/232097/">    </a> .</code> <ul><li> <code><code>std::vector,      Tokens</code> .            . <br> <br> <code class="cpp">#pragma once; #include &lt;vector&gt; namespace Interpreter { struct Token {}; typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { inline Tokens Tokenize(std::string expr) { throw std::exception(); } } // namespace Lexer } // namespace Interpreter</code> <br>   ,  ,   , .   ,    ,    <a href="http://cleancoder.posterous.com/the-transformation-priority-premise">The Transformation Priority Premise (TPP)</a>   .    , ,    ,     ,        .            .     ,     ,      ,           .  ,  ,   (   )    ,  ,  .     ,  ,         .     ,   TPP          . <br> <br>   : <br> <br> ({} ‚Üí nil)     ,   . (nil ‚Üí constant)    . (constant ‚Üí constant+)      (        ,  ). (constant ‚Üí scalar)    ,  . (statement ‚Üí statements)    (break, continue, return  ). (unconditional ‚Üí if)       . (scalar ‚Üí array)  / . (array ‚Üí container)     . (statement ‚Üí recursion)   . (if ‚Üí while)    . (expression ‚Üí function)   . (variable ‚Üí assignment)   . <br>        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::string expr) { return{}; }</code> <br> ,         .     . <br> <br> <s>         </s> .           .           .               .            .       . <br>  ,  <code>std::string</code>  <code>std::wstring</code> .         ,      Unicode.     . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); }</code> <br>  <code>AssertRange</code> -   ,       <code>AreEqual</code> ,   ,  ,    . <br> <br> <b class="spoiler_title">AssertRange</b> <code class="cpp">namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange</code> <br> <br>         <code>Operator</code>    .          <code>wchar_t</code>   ,         ,      . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', }; typedef Operator Token;</code> <br>    ,   ,        <code>Assert</code> ,    <code>ToString</code> ,    . <br> <br> <b class="spoiler_title">std::wstring ToString(const Token &amp;)</b> <code class="cpp">inline std::wstring ToString(const Token &amp;token) { return{ static_cast&lt;wchar_t&gt;(token) }; }</code> <br> <br>    ,   ,        .  ,   (unconditional ‚Üí if). <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { if(expr.empty()) { return{}; } return{ static_cast&lt;Operator&gt;(expr[0]) }; }</code> <br> <s>         </s> . <s>          .</s>           . ‚Ä¶ <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); }</code> <br>     .   ,     ,   - .    , : <br> <br>        ,      <code>Token</code> .       <code>dynamic_cast</code>    ,   .  ,    ,      .      <code>std::function</code>        .        .  Boost.Any,  - .            . <br>   ,   .      -  .  ,      ,      . <br> <br> ‚Ä¶        .        .        .        . <br>             . <br> <br> <code class="cpp">enum class TokenType { Operator, Number }; class Token { public: Token(Operator) {} TokenType Type() const { return TokenType::Operator; } }; ‚Ä¶ TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } };</code> <br>   <code>ToString</code>   <code>TokenType</code>       ,   ,   .     . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); }</code> <br>   .   (constant ‚Üí scalar)   . <br> <br> <code class="cpp">class Token { public: Token(Operator) :m_type(TokenType::Operator) {} Token(double) :m_type(TokenType::Number) {} TokenType Type() const { return m_type; } private: TokenType m_type; };</code> <br> ‚Ä¶ <s>       </s> . <s>       </s> .        .        . <br>    . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); }</code> <br>            . <br> <br> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} operator Operator() const { return m_operator; } ‚Ä¶ Operator m_operator; };</code> <br>      . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); }</code> <br>          ,  ,       <code>union</code> .         . <br> <br> <b class="spoiler_title">Token</b> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: return "Unknown token."; } }</code> <br> <br>  ,    ,      ,    .       .    . <br> <br> <i>          .</i>               .            .       . <br>        : <br> <br> <code class="cpp"> if(expr[0] &gt;= '0' &amp;&amp; expr[0] &lt;= '9') { return{ (double) expr[0] - '0' }; } return{ static_cast&lt;Operator&gt;(expr[0]) };</code> <br>      ,   . <br> <br> ‚Ä¶ <s>          .</s> <i>              .</i> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); }</code> <br> ,     <code>C</code>   ,  <code>isdigit</code> , ,       <code>atof</code> ,    ,      <code>wchar_t</code> .  (expression ‚Üí function).         . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { const wchar_t *current = expr.c_str(); if(!*current) return{}; if(iswdigit(*current)) return{ _wtof(current) }; return{ static_cast&lt;Operator&gt;(*current) }; }</code> <br>         .      . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>   ,        .  ,     .     .   <code>result</code> ,     . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); if(!*current) return result; if(iswdigit(*current)) { result.push_back(_wtof(current)); } else { result.push_back(static_cast&lt;Operator&gt;(*current)); } return result; }</code> <br>      :   (if ‚Üí while).     ,        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } } return result; }</code> <br>  <code>wcstod</code>    ,   <code>_wtof</code> ,           .           ,              .  ,    . <br> <br> <s>           .</s>       . <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>  (unconditional ‚Üí if)    ,    . <br> <br> <code class="cpp"> while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else if(*current == static_cast&lt;wchar_t&gt;(Operator::Plus)) { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } else { ++current; } }</code> <br>       .          .       <code>Detail</code>      .   <code>Tokenize</code>       . <br> <br> <code class="cpp">inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); }</code> <br> <b class="spoiler_title"> Detail::Tokenizer</b> <code class="cpp">namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { return *m_current == static_cast&lt;wchar_t&gt;(Operator::Plus); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail</code> <br> <br>  ,      .      ,  , .       . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); }</code> <br>      <code>Operator</code> ,    . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', };</code> <br>   .         <code>IsOperator</code>  <code>Tokenizer</code> . <br> <br> <code class="cpp"> bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); }</code> <br>         .        . <br> <br> <b class="spoiler_title">Interpreter.h</b> <code class="cpp">#pragma once; #include &lt;vector&gt; #include &lt;wchar.h&gt; #include &lt;algorithm&gt; namespace Interpreter { enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', }; inline std::wstring ToString(const Operator &amp;op) { return{ static_cast&lt;wchar_t&gt;(op) }; } enum class TokenType { Operator, Number }; inline std::wstring ToString(const TokenType &amp;type) { switch(type) { case TokenType::Operator: return L"Operator"; case TokenType::Number: return L"Number"; default: throw std::out_of_range("TokenType"); } } class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } friend inline bool operator==(const Token &amp;left, const Token &amp;right) { if(left.m_type == right.m_type) { switch(left.m_type) { case Interpreter::TokenType::Operator: return left.m_operator == right.m_operator; case Interpreter::TokenType::Number: return left.m_number == right.m_number; default: throw std::out_of_range("TokenType"); } } return false; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: throw std::out_of_range("TokenType"); } } typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); } } // namespace Lexer } // namespace Interpreter</code> <br> <br> <b class="spoiler_title">InterpreterTests.cpp</b> <code class="cpp">#include "stdafx.h" #include "CppUnitTest.h" #include "Interpreter.h" namespace InterpreterTests { using namespace Microsoft::VisualStudio::CppUnitTestFramework; using namespace Interpreter; using namespace std; namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual&lt;T&gt;(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange TEST_CLASS(LexerTests) { public: TEST_METHOD(Should_return_empty_token_list_when_put_empty_expression) { Tokens tokens = Lexer::Tokenize(L""); Assert::IsTrue(tokens.empty()); } TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); } TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); } TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); } TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); } }; TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); } TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); } TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); } }; }</code> <br> <br> <a href="https://github.com/Unril/InterpreterTDD/releases/tag/%25D0%259A%25D0%25BE%25D0%25BD%25D0%25B5%25D1%2586_%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B2%25D0%25BE%25D0%25B9_%25D1%2587%25D0%25B0%25D1%2581%25D1%2582%25D0%25B8">    GitHub</a> .         ,  .      "__". <br> <br>   <a href="http://habrahabr.ru/post/232081/">    </a> .      ,      <a href="http://habrahabr.ru/post/232097/">    </a> .</code> </li> <li> <code><code>std::vector,      Tokens</code> .            . <br> <br> <code class="cpp">#pragma once; #include &lt;vector&gt; namespace Interpreter { struct Token {}; typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { inline Tokens Tokenize(std::string expr) { throw std::exception(); } } // namespace Lexer } // namespace Interpreter</code> <br>   ,  ,   , .   ,    ,    <a href="http://cleancoder.posterous.com/the-transformation-priority-premise">The Transformation Priority Premise (TPP)</a>   .    , ,    ,     ,        .            .     ,     ,      ,           .  ,  ,   (   )    ,  ,  .     ,  ,         .     ,   TPP          . <br> <br>   : <br> <br> ({} ‚Üí nil)     ,   . (nil ‚Üí constant)    . (constant ‚Üí constant+)      (        ,  ). (constant ‚Üí scalar)    ,  . (statement ‚Üí statements)    (break, continue, return  ). (unconditional ‚Üí if)       . (scalar ‚Üí array)  / . (array ‚Üí container)     . (statement ‚Üí recursion)   . (if ‚Üí while)    . (expression ‚Üí function)   . (variable ‚Üí assignment)   . <br>        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::string expr) { return{}; }</code> <br> ,         .     . <br> <br> <s>         </s> .           .           .               .            .       . <br>  ,  <code>std::string</code>  <code>std::wstring</code> .         ,      Unicode.     . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); }</code> <br>  <code>AssertRange</code> -   ,       <code>AreEqual</code> ,   ,  ,    . <br> <br> <b class="spoiler_title">AssertRange</b> <code class="cpp">namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange</code> <br> <br>         <code>Operator</code>    .          <code>wchar_t</code>   ,         ,      . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', }; typedef Operator Token;</code> <br>    ,   ,        <code>Assert</code> ,    <code>ToString</code> ,    . <br> <br> <b class="spoiler_title">std::wstring ToString(const Token &amp;)</b> <code class="cpp">inline std::wstring ToString(const Token &amp;token) { return{ static_cast&lt;wchar_t&gt;(token) }; }</code> <br> <br>    ,   ,        .  ,   (unconditional ‚Üí if). <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { if(expr.empty()) { return{}; } return{ static_cast&lt;Operator&gt;(expr[0]) }; }</code> <br> <s>         </s> . <s>          .</s>           . ‚Ä¶ <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); }</code> <br>     .   ,     ,   - .    , : <br> <br>        ,      <code>Token</code> .       <code>dynamic_cast</code>    ,   .  ,    ,      .      <code>std::function</code>        .        .  Boost.Any,  - .            . <br>   ,   .      -  .  ,      ,      . <br> <br> ‚Ä¶        .        .        .        . <br>             . <br> <br> <code class="cpp">enum class TokenType { Operator, Number }; class Token { public: Token(Operator) {} TokenType Type() const { return TokenType::Operator; } }; ‚Ä¶ TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } };</code> <br>   <code>ToString</code>   <code>TokenType</code>       ,   ,   .     . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); }</code> <br>   .   (constant ‚Üí scalar)   . <br> <br> <code class="cpp">class Token { public: Token(Operator) :m_type(TokenType::Operator) {} Token(double) :m_type(TokenType::Number) {} TokenType Type() const { return m_type; } private: TokenType m_type; };</code> <br> ‚Ä¶ <s>       </s> . <s>       </s> .        .        . <br>    . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); }</code> <br>            . <br> <br> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} operator Operator() const { return m_operator; } ‚Ä¶ Operator m_operator; };</code> <br>      . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); }</code> <br>          ,  ,       <code>union</code> .         . <br> <br> <b class="spoiler_title">Token</b> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: return "Unknown token."; } }</code> <br> <br>  ,    ,      ,    .       .    . <br> <br> <i>          .</i>               .            .       . <br>        : <br> <br> <code class="cpp"> if(expr[0] &gt;= '0' &amp;&amp; expr[0] &lt;= '9') { return{ (double) expr[0] - '0' }; } return{ static_cast&lt;Operator&gt;(expr[0]) };</code> <br>      ,   . <br> <br> ‚Ä¶ <s>          .</s> <i>              .</i> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); }</code> <br> ,     <code>C</code>   ,  <code>isdigit</code> , ,       <code>atof</code> ,    ,      <code>wchar_t</code> .  (expression ‚Üí function).         . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { const wchar_t *current = expr.c_str(); if(!*current) return{}; if(iswdigit(*current)) return{ _wtof(current) }; return{ static_cast&lt;Operator&gt;(*current) }; }</code> <br>         .      . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>   ,        .  ,     .     .   <code>result</code> ,     . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); if(!*current) return result; if(iswdigit(*current)) { result.push_back(_wtof(current)); } else { result.push_back(static_cast&lt;Operator&gt;(*current)); } return result; }</code> <br>      :   (if ‚Üí while).     ,        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } } return result; }</code> <br>  <code>wcstod</code>    ,   <code>_wtof</code> ,           .           ,              .  ,    . <br> <br> <s>           .</s>       . <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>  (unconditional ‚Üí if)    ,    . <br> <br> <code class="cpp"> while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else if(*current == static_cast&lt;wchar_t&gt;(Operator::Plus)) { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } else { ++current; } }</code> <br>       .          .       <code>Detail</code>      .   <code>Tokenize</code>       . <br> <br> <code class="cpp">inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); }</code> <br> <b class="spoiler_title"> Detail::Tokenizer</b> <code class="cpp">namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { return *m_current == static_cast&lt;wchar_t&gt;(Operator::Plus); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail</code> <br> <br>  ,      .      ,  , .       . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); }</code> <br>      <code>Operator</code> ,    . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', };</code> <br>   .         <code>IsOperator</code>  <code>Tokenizer</code> . <br> <br> <code class="cpp"> bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); }</code> <br>         .        . <br> <br> <b class="spoiler_title">Interpreter.h</b> <code class="cpp">#pragma once; #include &lt;vector&gt; #include &lt;wchar.h&gt; #include &lt;algorithm&gt; namespace Interpreter { enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', }; inline std::wstring ToString(const Operator &amp;op) { return{ static_cast&lt;wchar_t&gt;(op) }; } enum class TokenType { Operator, Number }; inline std::wstring ToString(const TokenType &amp;type) { switch(type) { case TokenType::Operator: return L"Operator"; case TokenType::Number: return L"Number"; default: throw std::out_of_range("TokenType"); } } class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } friend inline bool operator==(const Token &amp;left, const Token &amp;right) { if(left.m_type == right.m_type) { switch(left.m_type) { case Interpreter::TokenType::Operator: return left.m_operator == right.m_operator; case Interpreter::TokenType::Number: return left.m_number == right.m_number; default: throw std::out_of_range("TokenType"); } } return false; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: throw std::out_of_range("TokenType"); } } typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); } } // namespace Lexer } // namespace Interpreter</code> <br> <br> <b class="spoiler_title">InterpreterTests.cpp</b> <code class="cpp">#include "stdafx.h" #include "CppUnitTest.h" #include "Interpreter.h" namespace InterpreterTests { using namespace Microsoft::VisualStudio::CppUnitTestFramework; using namespace Interpreter; using namespace std; namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual&lt;T&gt;(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange TEST_CLASS(LexerTests) { public: TEST_METHOD(Should_return_empty_token_list_when_put_empty_expression) { Tokens tokens = Lexer::Tokenize(L""); Assert::IsTrue(tokens.empty()); } TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); } TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); } TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); } TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); } }; TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); } TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); } TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); } }; }</code> <br> <br> <a href="https://github.com/Unril/InterpreterTDD/releases/tag/%25D0%259A%25D0%25BE%25D0%25BD%25D0%25B5%25D1%2586_%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B2%25D0%25BE%25D0%25B9_%25D1%2587%25D0%25B0%25D1%2581%25D1%2582%25D0%25B8">    GitHub</a> .         ,  .      "__". <br> <br>   <a href="http://habrahabr.ru/post/232081/">    </a> .      ,      <a href="http://habrahabr.ru/post/232097/">    </a> .</code> </li> <li> <code><code>std::vector,      Tokens</code> .            . <br> <br> <code class="cpp">#pragma once; #include &lt;vector&gt; namespace Interpreter { struct Token {}; typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { inline Tokens Tokenize(std::string expr) { throw std::exception(); } } // namespace Lexer } // namespace Interpreter</code> <br>   ,  ,   , .   ,    ,    <a href="http://cleancoder.posterous.com/the-transformation-priority-premise">The Transformation Priority Premise (TPP)</a>   .    , ,    ,     ,        .            .     ,     ,      ,           .  ,  ,   (   )    ,  ,  .     ,  ,         .     ,   TPP          . <br> <br>   : <br> <br> ({} ‚Üí nil)     ,   . (nil ‚Üí constant)    . (constant ‚Üí constant+)      (        ,  ). (constant ‚Üí scalar)    ,  . (statement ‚Üí statements)    (break, continue, return  ). (unconditional ‚Üí if)       . (scalar ‚Üí array)  / . (array ‚Üí container)     . (statement ‚Üí recursion)   . (if ‚Üí while)    . (expression ‚Üí function)   . (variable ‚Üí assignment)   . <br>        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::string expr) { return{}; }</code> <br> ,         .     . <br> <br> <s>         </s> .           .           .               .            .       . <br>  ,  <code>std::string</code>  <code>std::wstring</code> .         ,      Unicode.     . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); }</code> <br>  <code>AssertRange</code> -   ,       <code>AreEqual</code> ,   ,  ,    . <br> <br> <b class="spoiler_title">AssertRange</b> <code class="cpp">namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange</code> <br> <br>         <code>Operator</code>    .          <code>wchar_t</code>   ,         ,      . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', }; typedef Operator Token;</code> <br>    ,   ,        <code>Assert</code> ,    <code>ToString</code> ,    . <br> <br> <b class="spoiler_title">std::wstring ToString(const Token &amp;)</b> <code class="cpp">inline std::wstring ToString(const Token &amp;token) { return{ static_cast&lt;wchar_t&gt;(token) }; }</code> <br> <br>    ,   ,        .  ,   (unconditional ‚Üí if). <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { if(expr.empty()) { return{}; } return{ static_cast&lt;Operator&gt;(expr[0]) }; }</code> <br> <s>         </s> . <s>          .</s>           . ‚Ä¶ <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); }</code> <br>     .   ,     ,   - .    , : <br> <br>        ,      <code>Token</code> .       <code>dynamic_cast</code>    ,   .  ,    ,      .      <code>std::function</code>        .        .  Boost.Any,  - .            . <br>   ,   .      -  .  ,      ,      . <br> <br> ‚Ä¶        .        .        .        . <br>             . <br> <br> <code class="cpp">enum class TokenType { Operator, Number }; class Token { public: Token(Operator) {} TokenType Type() const { return TokenType::Operator; } }; ‚Ä¶ TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } };</code> <br>   <code>ToString</code>   <code>TokenType</code>       ,   ,   .     . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); }</code> <br>   .   (constant ‚Üí scalar)   . <br> <br> <code class="cpp">class Token { public: Token(Operator) :m_type(TokenType::Operator) {} Token(double) :m_type(TokenType::Number) {} TokenType Type() const { return m_type; } private: TokenType m_type; };</code> <br> ‚Ä¶ <s>       </s> . <s>       </s> .        .        . <br>    . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); }</code> <br>            . <br> <br> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} operator Operator() const { return m_operator; } ‚Ä¶ Operator m_operator; };</code> <br>      . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); }</code> <br>          ,  ,       <code>union</code> .         . <br> <br> <b class="spoiler_title">Token</b> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: return "Unknown token."; } }</code> <br> <br>  ,    ,      ,    .       .    . <br> <br> <i>          .</i>               .            .       . <br>        : <br> <br> <code class="cpp"> if(expr[0] &gt;= '0' &amp;&amp; expr[0] &lt;= '9') { return{ (double) expr[0] - '0' }; } return{ static_cast&lt;Operator&gt;(expr[0]) };</code> <br>      ,   . <br> <br> ‚Ä¶ <s>          .</s> <i>              .</i> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); }</code> <br> ,     <code>C</code>   ,  <code>isdigit</code> , ,       <code>atof</code> ,    ,      <code>wchar_t</code> .  (expression ‚Üí function).         . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { const wchar_t *current = expr.c_str(); if(!*current) return{}; if(iswdigit(*current)) return{ _wtof(current) }; return{ static_cast&lt;Operator&gt;(*current) }; }</code> <br>         .      . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>   ,        .  ,     .     .   <code>result</code> ,     . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); if(!*current) return result; if(iswdigit(*current)) { result.push_back(_wtof(current)); } else { result.push_back(static_cast&lt;Operator&gt;(*current)); } return result; }</code> <br>      :   (if ‚Üí while).     ,        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } } return result; }</code> <br>  <code>wcstod</code>    ,   <code>_wtof</code> ,           .           ,              .  ,    . <br> <br> <s>           .</s>       . <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>  (unconditional ‚Üí if)    ,    . <br> <br> <code class="cpp"> while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else if(*current == static_cast&lt;wchar_t&gt;(Operator::Plus)) { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } else { ++current; } }</code> <br>       .          .       <code>Detail</code>      .   <code>Tokenize</code>       . <br> <br> <code class="cpp">inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); }</code> <br> <b class="spoiler_title"> Detail::Tokenizer</b> <code class="cpp">namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { return *m_current == static_cast&lt;wchar_t&gt;(Operator::Plus); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail</code> <br> <br>  ,      .      ,  , .       . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); }</code> <br>      <code>Operator</code> ,    . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', };</code> <br>   .         <code>IsOperator</code>  <code>Tokenizer</code> . <br> <br> <code class="cpp"> bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); }</code> <br>         .        . <br> <br> <b class="spoiler_title">Interpreter.h</b> <code class="cpp">#pragma once; #include &lt;vector&gt; #include &lt;wchar.h&gt; #include &lt;algorithm&gt; namespace Interpreter { enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', }; inline std::wstring ToString(const Operator &amp;op) { return{ static_cast&lt;wchar_t&gt;(op) }; } enum class TokenType { Operator, Number }; inline std::wstring ToString(const TokenType &amp;type) { switch(type) { case TokenType::Operator: return L"Operator"; case TokenType::Number: return L"Number"; default: throw std::out_of_range("TokenType"); } } class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } friend inline bool operator==(const Token &amp;left, const Token &amp;right) { if(left.m_type == right.m_type) { switch(left.m_type) { case Interpreter::TokenType::Operator: return left.m_operator == right.m_operator; case Interpreter::TokenType::Number: return left.m_number == right.m_number; default: throw std::out_of_range("TokenType"); } } return false; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: throw std::out_of_range("TokenType"); } } typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); } } // namespace Lexer } // namespace Interpreter</code> <br> <br> <b class="spoiler_title">InterpreterTests.cpp</b> <code class="cpp">#include "stdafx.h" #include "CppUnitTest.h" #include "Interpreter.h" namespace InterpreterTests { using namespace Microsoft::VisualStudio::CppUnitTestFramework; using namespace Interpreter; using namespace std; namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual&lt;T&gt;(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange TEST_CLASS(LexerTests) { public: TEST_METHOD(Should_return_empty_token_list_when_put_empty_expression) { Tokens tokens = Lexer::Tokenize(L""); Assert::IsTrue(tokens.empty()); } TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); } TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); } TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); } TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); } }; TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); } TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); } TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); } }; }</code> <br> <br> <a href="https://github.com/Unril/InterpreterTDD/releases/tag/%25D0%259A%25D0%25BE%25D0%25BD%25D0%25B5%25D1%2586_%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B2%25D0%25BE%25D0%25B9_%25D1%2587%25D0%25B0%25D1%2581%25D1%2582%25D0%25B8">    GitHub</a> .         ,  .      "__". <br> <br>   <a href="http://habrahabr.ru/post/232081/">    </a> .      ,      <a href="http://habrahabr.ru/post/232097/">    </a> .</code> </li> <li> <code><code>std::vector,      Tokens</code> .            . <br> <br> <code class="cpp">#pragma once; #include &lt;vector&gt; namespace Interpreter { struct Token {}; typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { inline Tokens Tokenize(std::string expr) { throw std::exception(); } } // namespace Lexer } // namespace Interpreter</code> <br>   ,  ,   , .   ,    ,    <a href="http://cleancoder.posterous.com/the-transformation-priority-premise">The Transformation Priority Premise (TPP)</a>   .    , ,    ,     ,        .            .     ,     ,      ,           .  ,  ,   (   )    ,  ,  .     ,  ,         .     ,   TPP          . <br> <br>   : <br> <br> ({} ‚Üí nil)     ,   . (nil ‚Üí constant)    . (constant ‚Üí constant+)      (        ,  ). (constant ‚Üí scalar)    ,  . (statement ‚Üí statements)    (break, continue, return  ). (unconditional ‚Üí if)       . (scalar ‚Üí array)  / . (array ‚Üí container)     . (statement ‚Üí recursion)   . (if ‚Üí while)    . (expression ‚Üí function)   . (variable ‚Üí assignment)   . <br>        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::string expr) { return{}; }</code> <br> ,         .     . <br> <br> <s>         </s> .           .           .               .            .       . <br>  ,  <code>std::string</code>  <code>std::wstring</code> .         ,      Unicode.     . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); }</code> <br>  <code>AssertRange</code> -   ,       <code>AreEqual</code> ,   ,  ,    . <br> <br> <b class="spoiler_title">AssertRange</b> <code class="cpp">namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange</code> <br> <br>         <code>Operator</code>    .          <code>wchar_t</code>   ,         ,      . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', }; typedef Operator Token;</code> <br>    ,   ,        <code>Assert</code> ,    <code>ToString</code> ,    . <br> <br> <b class="spoiler_title">std::wstring ToString(const Token &amp;)</b> <code class="cpp">inline std::wstring ToString(const Token &amp;token) { return{ static_cast&lt;wchar_t&gt;(token) }; }</code> <br> <br>    ,   ,        .  ,   (unconditional ‚Üí if). <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { if(expr.empty()) { return{}; } return{ static_cast&lt;Operator&gt;(expr[0]) }; }</code> <br> <s>         </s> . <s>          .</s>           . ‚Ä¶ <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); }</code> <br>     .   ,     ,   - .    , : <br> <br>        ,      <code>Token</code> .       <code>dynamic_cast</code>    ,   .  ,    ,      .      <code>std::function</code>        .        .  Boost.Any,  - .            . <br>   ,   .      -  .  ,      ,      . <br> <br> ‚Ä¶        .        .        .        . <br>             . <br> <br> <code class="cpp">enum class TokenType { Operator, Number }; class Token { public: Token(Operator) {} TokenType Type() const { return TokenType::Operator; } }; ‚Ä¶ TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } };</code> <br>   <code>ToString</code>   <code>TokenType</code>       ,   ,   .     . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); }</code> <br>   .   (constant ‚Üí scalar)   . <br> <br> <code class="cpp">class Token { public: Token(Operator) :m_type(TokenType::Operator) {} Token(double) :m_type(TokenType::Number) {} TokenType Type() const { return m_type; } private: TokenType m_type; };</code> <br> ‚Ä¶ <s>       </s> . <s>       </s> .        .        . <br>    . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); }</code> <br>            . <br> <br> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} operator Operator() const { return m_operator; } ‚Ä¶ Operator m_operator; };</code> <br>      . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); }</code> <br>          ,  ,       <code>union</code> .         . <br> <br> <b class="spoiler_title">Token</b> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: return "Unknown token."; } }</code> <br> <br>  ,    ,      ,    .       .    . <br> <br> <i>          .</i>               .            .       . <br>        : <br> <br> <code class="cpp"> if(expr[0] &gt;= '0' &amp;&amp; expr[0] &lt;= '9') { return{ (double) expr[0] - '0' }; } return{ static_cast&lt;Operator&gt;(expr[0]) };</code> <br>      ,   . <br> <br> ‚Ä¶ <s>          .</s> <i>              .</i> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); }</code> <br> ,     <code>C</code>   ,  <code>isdigit</code> , ,       <code>atof</code> ,    ,      <code>wchar_t</code> .  (expression ‚Üí function).         . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { const wchar_t *current = expr.c_str(); if(!*current) return{}; if(iswdigit(*current)) return{ _wtof(current) }; return{ static_cast&lt;Operator&gt;(*current) }; }</code> <br>         .      . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>   ,        .  ,     .     .   <code>result</code> ,     . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); if(!*current) return result; if(iswdigit(*current)) { result.push_back(_wtof(current)); } else { result.push_back(static_cast&lt;Operator&gt;(*current)); } return result; }</code> <br>      :   (if ‚Üí while).     ,        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } } return result; }</code> <br>  <code>wcstod</code>    ,   <code>_wtof</code> ,           .           ,              .  ,    . <br> <br> <s>           .</s>       . <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>  (unconditional ‚Üí if)    ,    . <br> <br> <code class="cpp"> while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else if(*current == static_cast&lt;wchar_t&gt;(Operator::Plus)) { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } else { ++current; } }</code> <br>       .          .       <code>Detail</code>      .   <code>Tokenize</code>       . <br> <br> <code class="cpp">inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); }</code> <br> <b class="spoiler_title"> Detail::Tokenizer</b> <code class="cpp">namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { return *m_current == static_cast&lt;wchar_t&gt;(Operator::Plus); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail</code> <br> <br>  ,      .      ,  , .       . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); }</code> <br>      <code>Operator</code> ,    . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', };</code> <br>   .         <code>IsOperator</code>  <code>Tokenizer</code> . <br> <br> <code class="cpp"> bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); }</code> <br>         .        . <br> <br> <b class="spoiler_title">Interpreter.h</b> <code class="cpp">#pragma once; #include &lt;vector&gt; #include &lt;wchar.h&gt; #include &lt;algorithm&gt; namespace Interpreter { enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', }; inline std::wstring ToString(const Operator &amp;op) { return{ static_cast&lt;wchar_t&gt;(op) }; } enum class TokenType { Operator, Number }; inline std::wstring ToString(const TokenType &amp;type) { switch(type) { case TokenType::Operator: return L"Operator"; case TokenType::Number: return L"Number"; default: throw std::out_of_range("TokenType"); } } class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } friend inline bool operator==(const Token &amp;left, const Token &amp;right) { if(left.m_type == right.m_type) { switch(left.m_type) { case Interpreter::TokenType::Operator: return left.m_operator == right.m_operator; case Interpreter::TokenType::Number: return left.m_number == right.m_number; default: throw std::out_of_range("TokenType"); } } return false; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: throw std::out_of_range("TokenType"); } } typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); } } // namespace Lexer } // namespace Interpreter</code> <br> <br> <b class="spoiler_title">InterpreterTests.cpp</b> <code class="cpp">#include "stdafx.h" #include "CppUnitTest.h" #include "Interpreter.h" namespace InterpreterTests { using namespace Microsoft::VisualStudio::CppUnitTestFramework; using namespace Interpreter; using namespace std; namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual&lt;T&gt;(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange TEST_CLASS(LexerTests) { public: TEST_METHOD(Should_return_empty_token_list_when_put_empty_expression) { Tokens tokens = Lexer::Tokenize(L""); Assert::IsTrue(tokens.empty()); } TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); } TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); } TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); } TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); } }; TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); } TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); } TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); } }; }</code> <br> <br> <a href="https://github.com/Unril/InterpreterTDD/releases/tag/%25D0%259A%25D0%25BE%25D0%25BD%25D0%25B5%25D1%2586_%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B2%25D0%25BE%25D0%25B9_%25D1%2587%25D0%25B0%25D1%2581%25D1%2582%25D0%25B8">    GitHub</a> .         ,  .      "__". <br> <br>   <a href="http://habrahabr.ru/post/232081/">    </a> .      ,      <a href="http://habrahabr.ru/post/232097/">    </a> .</code> </li> <li> <code><code>std::vector,      Tokens</code> .            . <br> <br> <code class="cpp">#pragma once; #include &lt;vector&gt; namespace Interpreter { struct Token {}; typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { inline Tokens Tokenize(std::string expr) { throw std::exception(); } } // namespace Lexer } // namespace Interpreter</code> <br>   ,  ,   , .   ,    ,    <a href="http://cleancoder.posterous.com/the-transformation-priority-premise">The Transformation Priority Premise (TPP)</a>   .    , ,    ,     ,        .            .     ,     ,      ,           .  ,  ,   (   )    ,  ,  .     ,  ,         .     ,   TPP          . <br> <br>   : <br> <br> ({} ‚Üí nil)     ,   . (nil ‚Üí constant)    . (constant ‚Üí constant+)      (        ,  ). (constant ‚Üí scalar)    ,  . (statement ‚Üí statements)    (break, continue, return  ). (unconditional ‚Üí if)       . (scalar ‚Üí array)  / . (array ‚Üí container)     . (statement ‚Üí recursion)   . (if ‚Üí while)    . (expression ‚Üí function)   . (variable ‚Üí assignment)   . <br>        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::string expr) { return{}; }</code> <br> ,         .     . <br> <br> <s>         </s> .           .           .               .            .       . <br>  ,  <code>std::string</code>  <code>std::wstring</code> .         ,      Unicode.     . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); }</code> <br>  <code>AssertRange</code> -   ,       <code>AreEqual</code> ,   ,  ,    . <br> <br> <b class="spoiler_title">AssertRange</b> <code class="cpp">namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange</code> <br> <br>         <code>Operator</code>    .          <code>wchar_t</code>   ,         ,      . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', }; typedef Operator Token;</code> <br>    ,   ,        <code>Assert</code> ,    <code>ToString</code> ,    . <br> <br> <b class="spoiler_title">std::wstring ToString(const Token &amp;)</b> <code class="cpp">inline std::wstring ToString(const Token &amp;token) { return{ static_cast&lt;wchar_t&gt;(token) }; }</code> <br> <br>    ,   ,        .  ,   (unconditional ‚Üí if). <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { if(expr.empty()) { return{}; } return{ static_cast&lt;Operator&gt;(expr[0]) }; }</code> <br> <s>         </s> . <s>          .</s>           . ‚Ä¶ <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); }</code> <br>     .   ,     ,   - .    , : <br> <br>        ,      <code>Token</code> .       <code>dynamic_cast</code>    ,   .  ,    ,      .      <code>std::function</code>        .        .  Boost.Any,  - .            . <br>   ,   .      -  .  ,      ,      . <br> <br> ‚Ä¶        .        .        .        . <br>             . <br> <br> <code class="cpp">enum class TokenType { Operator, Number }; class Token { public: Token(Operator) {} TokenType Type() const { return TokenType::Operator; } }; ‚Ä¶ TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } };</code> <br>   <code>ToString</code>   <code>TokenType</code>       ,   ,   .     . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); }</code> <br>   .   (constant ‚Üí scalar)   . <br> <br> <code class="cpp">class Token { public: Token(Operator) :m_type(TokenType::Operator) {} Token(double) :m_type(TokenType::Number) {} TokenType Type() const { return m_type; } private: TokenType m_type; };</code> <br> ‚Ä¶ <s>       </s> . <s>       </s> .        .        . <br>    . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); }</code> <br>            . <br> <br> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} operator Operator() const { return m_operator; } ‚Ä¶ Operator m_operator; };</code> <br>      . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); }</code> <br>          ,  ,       <code>union</code> .         . <br> <br> <b class="spoiler_title">Token</b> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: return "Unknown token."; } }</code> <br> <br>  ,    ,      ,    .       .    . <br> <br> <i>          .</i>               .            .       . <br>        : <br> <br> <code class="cpp"> if(expr[0] &gt;= '0' &amp;&amp; expr[0] &lt;= '9') { return{ (double) expr[0] - '0' }; } return{ static_cast&lt;Operator&gt;(expr[0]) };</code> <br>      ,   . <br> <br> ‚Ä¶ <s>          .</s> <i>              .</i> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); }</code> <br> ,     <code>C</code>   ,  <code>isdigit</code> , ,       <code>atof</code> ,    ,      <code>wchar_t</code> .  (expression ‚Üí function).         . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { const wchar_t *current = expr.c_str(); if(!*current) return{}; if(iswdigit(*current)) return{ _wtof(current) }; return{ static_cast&lt;Operator&gt;(*current) }; }</code> <br>         .      . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>   ,        .  ,     .     .   <code>result</code> ,     . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); if(!*current) return result; if(iswdigit(*current)) { result.push_back(_wtof(current)); } else { result.push_back(static_cast&lt;Operator&gt;(*current)); } return result; }</code> <br>      :   (if ‚Üí while).     ,        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } } return result; }</code> <br>  <code>wcstod</code>    ,   <code>_wtof</code> ,           .           ,              .  ,    . <br> <br> <s>           .</s>       . <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>  (unconditional ‚Üí if)    ,    . <br> <br> <code class="cpp"> while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else if(*current == static_cast&lt;wchar_t&gt;(Operator::Plus)) { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } else { ++current; } }</code> <br>       .          .       <code>Detail</code>      .   <code>Tokenize</code>       . <br> <br> <code class="cpp">inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); }</code> <br> <b class="spoiler_title"> Detail::Tokenizer</b> <code class="cpp">namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { return *m_current == static_cast&lt;wchar_t&gt;(Operator::Plus); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail</code> <br> <br>  ,      .      ,  , .       . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); }</code> <br>      <code>Operator</code> ,    . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', };</code> <br>   .         <code>IsOperator</code>  <code>Tokenizer</code> . <br> <br> <code class="cpp"> bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); }</code> <br>         .        . <br> <br> <b class="spoiler_title">Interpreter.h</b> <code class="cpp">#pragma once; #include &lt;vector&gt; #include &lt;wchar.h&gt; #include &lt;algorithm&gt; namespace Interpreter { enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', }; inline std::wstring ToString(const Operator &amp;op) { return{ static_cast&lt;wchar_t&gt;(op) }; } enum class TokenType { Operator, Number }; inline std::wstring ToString(const TokenType &amp;type) { switch(type) { case TokenType::Operator: return L"Operator"; case TokenType::Number: return L"Number"; default: throw std::out_of_range("TokenType"); } } class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } friend inline bool operator==(const Token &amp;left, const Token &amp;right) { if(left.m_type == right.m_type) { switch(left.m_type) { case Interpreter::TokenType::Operator: return left.m_operator == right.m_operator; case Interpreter::TokenType::Number: return left.m_number == right.m_number; default: throw std::out_of_range("TokenType"); } } return false; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: throw std::out_of_range("TokenType"); } } typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); } } // namespace Lexer } // namespace Interpreter</code> <br> <br> <b class="spoiler_title">InterpreterTests.cpp</b> <code class="cpp">#include "stdafx.h" #include "CppUnitTest.h" #include "Interpreter.h" namespace InterpreterTests { using namespace Microsoft::VisualStudio::CppUnitTestFramework; using namespace Interpreter; using namespace std; namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual&lt;T&gt;(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange TEST_CLASS(LexerTests) { public: TEST_METHOD(Should_return_empty_token_list_when_put_empty_expression) { Tokens tokens = Lexer::Tokenize(L""); Assert::IsTrue(tokens.empty()); } TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); } TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); } TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); } TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); } }; TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); } TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); } TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); } }; }</code> <br> <br> <a href="https://github.com/Unril/InterpreterTDD/releases/tag/%25D0%259A%25D0%25BE%25D0%25BD%25D0%25B5%25D1%2586_%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B2%25D0%25BE%25D0%25B9_%25D1%2587%25D0%25B0%25D1%2581%25D1%2582%25D0%25B8">    GitHub</a> .         ,  .      "__". <br> <br>   <a href="http://habrahabr.ru/post/232081/">    </a> .      ,      <a href="http://habrahabr.ru/post/232097/">    </a> .</code> </li> </ul> <code><code>std::vector,      Tokens</code> .            . <br> <br> <code class="cpp">#pragma once; #include &lt;vector&gt; namespace Interpreter { struct Token {}; typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { inline Tokens Tokenize(std::string expr) { throw std::exception(); } } // namespace Lexer } // namespace Interpreter</code> <br>   ,  ,   , .   ,    ,    <a href="http://cleancoder.posterous.com/the-transformation-priority-premise">The Transformation Priority Premise (TPP)</a>   .    , ,    ,     ,        .            .     ,     ,      ,           .  ,  ,   (   )    ,  ,  .     ,  ,         .     ,   TPP          . <br> <br>   : <br> <br> ({} ‚Üí nil)     ,   . (nil ‚Üí constant)    . (constant ‚Üí constant+)      (        ,  ). (constant ‚Üí scalar)    ,  . (statement ‚Üí statements)    (break, continue, return  ). (unconditional ‚Üí if)       . (scalar ‚Üí array)  / . (array ‚Üí container)     . (statement ‚Üí recursion)   . (if ‚Üí while)    . (expression ‚Üí function)   . (variable ‚Üí assignment)   . <br>        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::string expr) { return{}; }</code> <br> ,         .     . <br> <br> <s>         </s> .           .           .               .            .       . <br>  ,  <code>std::string</code>  <code>std::wstring</code> .         ,      Unicode.     . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); }</code> <br>  <code>AssertRange</code> -   ,       <code>AreEqual</code> ,   ,  ,    . <br> <br> <b class="spoiler_title">AssertRange</b> <code class="cpp">namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange</code> <br> <br>         <code>Operator</code>    .          <code>wchar_t</code>   ,         ,      . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', }; typedef Operator Token;</code> <br>    ,   ,        <code>Assert</code> ,    <code>ToString</code> ,    . <br> <br> <b class="spoiler_title">std::wstring ToString(const Token &amp;)</b> <code class="cpp">inline std::wstring ToString(const Token &amp;token) { return{ static_cast&lt;wchar_t&gt;(token) }; }</code> <br> <br>    ,   ,        .  ,   (unconditional ‚Üí if). <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { if(expr.empty()) { return{}; } return{ static_cast&lt;Operator&gt;(expr[0]) }; }</code> <br> <s>         </s> . <s>          .</s>           . ‚Ä¶ <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); }</code> <br>     .   ,     ,   - .    , : <br> <br>        ,      <code>Token</code> .       <code>dynamic_cast</code>    ,   .  ,    ,      .      <code>std::function</code>        .        .  Boost.Any,  - .            . <br>   ,   .      -  .  ,      ,      . <br> <br> ‚Ä¶        .        .        .        . <br>             . <br> <br> <code class="cpp">enum class TokenType { Operator, Number }; class Token { public: Token(Operator) {} TokenType Type() const { return TokenType::Operator; } }; ‚Ä¶ TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } };</code> <br>   <code>ToString</code>   <code>TokenType</code>       ,   ,   .     . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); }</code> <br>   .   (constant ‚Üí scalar)   . <br> <br> <code class="cpp">class Token { public: Token(Operator) :m_type(TokenType::Operator) {} Token(double) :m_type(TokenType::Number) {} TokenType Type() const { return m_type; } private: TokenType m_type; };</code> <br> ‚Ä¶ <s>       </s> . <s>       </s> .        .        . <br>    . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); }</code> <br>            . <br> <br> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} operator Operator() const { return m_operator; } ‚Ä¶ Operator m_operator; };</code> <br>      . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); }</code> <br>          ,  ,       <code>union</code> .         . <br> <br> <b class="spoiler_title">Token</b> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: return "Unknown token."; } }</code> <br> <br>  ,    ,      ,    .       .    . <br> <br> <i>          .</i>               .            .       . <br>        : <br> <br> <code class="cpp"> if(expr[0] &gt;= '0' &amp;&amp; expr[0] &lt;= '9') { return{ (double) expr[0] - '0' }; } return{ static_cast&lt;Operator&gt;(expr[0]) };</code> <br>      ,   . <br> <br> ‚Ä¶ <s>          .</s> <i>              .</i> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); }</code> <br> ,     <code>C</code>   ,  <code>isdigit</code> , ,       <code>atof</code> ,    ,      <code>wchar_t</code> .  (expression ‚Üí function).         . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { const wchar_t *current = expr.c_str(); if(!*current) return{}; if(iswdigit(*current)) return{ _wtof(current) }; return{ static_cast&lt;Operator&gt;(*current) }; }</code> <br>         .      . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>   ,        .  ,     .     .   <code>result</code> ,     . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); if(!*current) return result; if(iswdigit(*current)) { result.push_back(_wtof(current)); } else { result.push_back(static_cast&lt;Operator&gt;(*current)); } return result; }</code> <br>      :   (if ‚Üí while).     ,        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } } return result; }</code> <br>  <code>wcstod</code>    ,   <code>_wtof</code> ,           .           ,              .  ,    . <br> <br> <s>           .</s>       . <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>  (unconditional ‚Üí if)    ,    . <br> <br> <code class="cpp"> while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else if(*current == static_cast&lt;wchar_t&gt;(Operator::Plus)) { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } else { ++current; } }</code> <br>       .          .       <code>Detail</code>      .   <code>Tokenize</code>       . <br> <br> <code class="cpp">inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); }</code> <br> <b class="spoiler_title"> Detail::Tokenizer</b> <code class="cpp">namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { return *m_current == static_cast&lt;wchar_t&gt;(Operator::Plus); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail</code> <br> <br>  ,      .      ,  , .       . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); }</code> <br>      <code>Operator</code> ,    . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', };</code> <br>   .         <code>IsOperator</code>  <code>Tokenizer</code> . <br> <br> <code class="cpp"> bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); }</code> <br>         .        . <br> <br> <b class="spoiler_title">Interpreter.h</b> <code class="cpp">#pragma once; #include &lt;vector&gt; #include &lt;wchar.h&gt; #include &lt;algorithm&gt; namespace Interpreter { enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', }; inline std::wstring ToString(const Operator &amp;op) { return{ static_cast&lt;wchar_t&gt;(op) }; } enum class TokenType { Operator, Number }; inline std::wstring ToString(const TokenType &amp;type) { switch(type) { case TokenType::Operator: return L"Operator"; case TokenType::Number: return L"Number"; default: throw std::out_of_range("TokenType"); } } class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } friend inline bool operator==(const Token &amp;left, const Token &amp;right) { if(left.m_type == right.m_type) { switch(left.m_type) { case Interpreter::TokenType::Operator: return left.m_operator == right.m_operator; case Interpreter::TokenType::Number: return left.m_number == right.m_number; default: throw std::out_of_range("TokenType"); } } return false; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: throw std::out_of_range("TokenType"); } } typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); } } // namespace Lexer } // namespace Interpreter</code> <br> <br> <b class="spoiler_title">InterpreterTests.cpp</b> <code class="cpp">#include "stdafx.h" #include "CppUnitTest.h" #include "Interpreter.h" namespace InterpreterTests { using namespace Microsoft::VisualStudio::CppUnitTestFramework; using namespace Interpreter; using namespace std; namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual&lt;T&gt;(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange TEST_CLASS(LexerTests) { public: TEST_METHOD(Should_return_empty_token_list_when_put_empty_expression) { Tokens tokens = Lexer::Tokenize(L""); Assert::IsTrue(tokens.empty()); } TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); } TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); } TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); } TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); } }; TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); } TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); } TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); } }; }</code> <br> <br> <a href="https://github.com/Unril/InterpreterTDD/releases/tag/%25D0%259A%25D0%25BE%25D0%25BD%25D0%25B5%25D1%2586_%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B2%25D0%25BE%25D0%25B9_%25D1%2587%25D0%25B0%25D1%2581%25D1%2582%25D0%25B8">    GitHub</a> .         ,  .      "__". <br> <br>   <a href="http://habrahabr.ru/post/232081/">    </a> .      ,      <a href="http://habrahabr.ru/post/232097/">    </a> .</code> <pre> <code class="hljs lua"><code>std::vector,      Tokens</code> .            . <br> <br> <code class="cpp">#pragma once; #include &lt;vector&gt; namespace Interpreter { struct Token {}; typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { inline Tokens Tokenize(std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> expr) { throw std::exception(); } } // namespace Lexer } // namespace Interpreter</code> <br>   ,  ,   , .   ,    ,    <a href="http://cleancoder.posterous.com/the-transformation-priority-premise">The Transformation Priority Premise (TPP)</a>   .    , ,    ,     ,        .            .     ,     ,      ,           .  ,  ,   (   )    ,  ,  .     ,  ,         .     ,   TPP          . <br> <br>   : <br> <br> ({} ‚Üí <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)     ,   . (<span class="hljs-literal"><span class="hljs-literal">nil</span></span> ‚Üí constant)    . (constant ‚Üí constant+)      (        ,  ). (constant ‚Üí scalar)    ,  . (statement ‚Üí statements)    (<span class="hljs-keyword"><span class="hljs-keyword">break</span></span>, continue, <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>  ). (unconditional ‚Üí <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>)       . (scalar ‚Üí array)  / . (array ‚Üí container)     . (statement ‚Üí recursion)   . (<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ‚Üí <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>)    . (expression ‚Üí <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">)</span></span>   . (variable ‚Üí assignment)   . <br>        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> expr) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{}; }</code> <br> ,         .     . <br> <br> <s>         </s> .           .           .               .            .       . <br>  ,  <code>std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span></code>  <code>std::wstring</code> .         ,      Unicode.     . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"+"</span></span>); AssertRange::AreEqual({ Operator::Plus }, tokens); }</code> <br>  <code>AssertRange</code> -   ,       <code>AreEqual</code> ,   ,  ,    . <br> <br> <b class="spoiler_title">AssertRange</b> <code class="cpp">namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(expect)), distance(actualIter, <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(actual)), L<span class="hljs-string"><span class="hljs-string">"Size differs."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(; expectIter != <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(expect) &amp;&amp; actualIter != <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(actual); ++expectIter, ++actualIter) { auto message = L<span class="hljs-string"><span class="hljs-string">"Mismatch in position "</span></span> + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange</code> <br> <br>         <code>Operator</code>    .          <code>wchar_t</code>   ,         ,      . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L<span class="hljs-string"><span class="hljs-string">'+'</span></span>, }; typedef Operator Token;</code> <br>    ,   ,        <code>Assert</code> ,    <code>ToString</code> ,    . <br> <br> <b class="spoiler_title">std::wstring ToString(const Token &amp;)</b> <code class="cpp">inline std::wstring ToString(const Token &amp;token) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ static_cast&lt;wchar_t&gt;(token) }; }</code> <br> <br>    ,   ,        .  ,   (unconditional ‚Üí <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>). <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(expr.empty()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{}; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ static_cast&lt;Operator&gt;(expr[<span class="hljs-number"><span class="hljs-number">0</span></span>]) }; }</code> <br> <s>         </s> . <s>          .</s>           . ‚Ä¶ <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"1"</span></span>); AssertRange::AreEqual({ <span class="hljs-number"><span class="hljs-number">1.0</span></span> }, tokens); }</code> <br>     .   ,     ,   - .    , : <br> <br>        ,      <code>Token</code> .       <code>dynamic_cast</code>    ,   .  ,    ,      .      <code>std::<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span></span></code><span class="hljs-function"><span class="hljs-function">        .        .  </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Boost.Any</span></span></span><span class="hljs-function">,  - .            . </span></span><br><span class="hljs-function"><span class="hljs-function">   ,   .      -  .  ,      ,      . </span></span><br><span class="hljs-function"><span class="hljs-function"> </span></span><br><span class="hljs-function"><span class="hljs-function"> ‚Ä¶        .        .        .        . </span></span><br><span class="hljs-function"><span class="hljs-function">             . </span></span><br><span class="hljs-function"><span class="hljs-function"> </span></span><br><span class="hljs-function"><span class="hljs-function"> </span></span><code class="cpp"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">enum</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">class</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TokenType</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Operator</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Number</span></span></span><span class="hljs-function"> }; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">class</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Token</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">public</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Token</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Operator)</span></span></span></span> {} TokenType Type() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TokenType::Operator; } }; ‚Ä¶ TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } };</code> <br>   <code>ToString</code>   <code>TokenType</code>       ,   ,   .     . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_type_for_number_token) { Token numToken(<span class="hljs-number"><span class="hljs-number">1.2</span></span>); Assert::AreEqual(TokenType::Number, numToken.Type()); }</code> <br>   .   (constant ‚Üí scalar)   . <br> <br> <code class="cpp">class Token { public: Token(Operator) :m_type(TokenType::Operator) {} Token(double) :m_type(TokenType::Number) {} TokenType Type() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_type; } private: TokenType m_type; };</code> <br> ‚Ä¶ <s>       </s> . <s>       </s> .        .        . <br>    . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); }</code> <br>            . <br> <br> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} operator Operator() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_operator; } ‚Ä¶ Operator m_operator; };</code> <br>      . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_number_value_from_number_token) { Token token(<span class="hljs-number"><span class="hljs-number">1.23</span></span>); Assert::AreEqual&lt;double&gt;(<span class="hljs-number"><span class="hljs-number">1.23</span></span>, token); }</code> <br>          ,  ,       <code>union</code> .         . <br> <br> <b class="spoiler_title">Token</b> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_type; } operator Operator() const { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(m_type != TokenType::Operator) throw std::logic_error(<span class="hljs-string"><span class="hljs-string">"Should be operator token."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_operator; } operator double() const { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(m_type != TokenType::Number) throw std::logic_error(<span class="hljs-string"><span class="hljs-string">"Should be number token."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_number; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ToString(static_cast&lt;Operator&gt;(token)); default: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Unknown token."</span></span>; } }</code> <br> <br>  ,    ,      ,    .       .    . <br> <br> <i>          .</i>               .            .       . <br>        : <br> <br> <code class="cpp"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(expr[<span class="hljs-number"><span class="hljs-number">0</span></span>] &gt;= <span class="hljs-string"><span class="hljs-string">'0'</span></span> &amp;&amp; expr[<span class="hljs-number"><span class="hljs-number">0</span></span>] &lt;= <span class="hljs-string"><span class="hljs-string">'9'</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ (double) expr[<span class="hljs-number"><span class="hljs-number">0</span></span>] - <span class="hljs-string"><span class="hljs-string">'0'</span></span> }; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ static_cast&lt;Operator&gt;(expr[<span class="hljs-number"><span class="hljs-number">0</span></span>]) };</code> <br>      ,   . <br> <br> ‚Ä¶ <s>          .</s> <i>              .</i> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"12.34"</span></span>); AssertRange::AreEqual({ <span class="hljs-number"><span class="hljs-number">12.34</span></span> }, tokens); }</code> <br> ,     <code>C</code>   ,  <code>isdigit</code> , ,       <code>atof</code> ,    ,      <code>wchar_t</code> .  (expression ‚Üí <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">)</span></span>.         . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { const wchar_t *current = expr.c_str(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!*current) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{}; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(iswdigit(*current)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ _wtof(current) }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ static_cast&lt;Operator&gt;(*current) }; }</code> <br>         .      . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"+12.34"</span></span>); AssertRange::AreEqual({ Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">12.34</span></span>) }, tokens); }</code> <br>   ,        .  ,     .     .   <code>result</code> ,     . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!*current) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(iswdigit(*current)) { result.push_back(_wtof(current)); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { result.push_back(static_cast&lt;Operator&gt;(*current)); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> <br>      :   (<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ‚Üí <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>).     ,        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(*current) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(iswdigit(*current)) { wchar_t *<span class="hljs-keyword"><span class="hljs-keyword">end</span></span> = nullptr; result.push_back(wcstod(current, &amp;<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>)); current = <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> <br>  <code>wcstod</code>    ,   <code>_wtof</code> ,           .           ,              .  ,    . <br> <br> <s>           .</s>       . <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">" 1 + 12.34 "</span></span>); AssertRange::AreEqual({ Token(<span class="hljs-number"><span class="hljs-number">1.0</span></span>), Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">12.34</span></span>) }, tokens); }</code> <br>  (unconditional ‚Üí <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>)    ,    . <br> <br> <code class="cpp"> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(*current) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(iswdigit(*current)) { wchar_t *<span class="hljs-keyword"><span class="hljs-keyword">end</span></span> = nullptr; result.push_back(wcstod(current, &amp;<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>)); current = <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(*current == static_cast&lt;wchar_t&gt;(Operator::Plus)) { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { ++current; } }</code> <br>       .          .       <code>Detail</code>      .   <code>Tokenize</code>       . <br> <br> <code class="cpp">inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tokenizer.Result(); }</code> <br> <b class="spoiler_title"> Detail::Tokenizer</b> <code class="cpp">namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!EndOfExperssion()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(IsNumber()) { ScanNumber(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(IsOperator()) { ScanOperator(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { MoveNext(); } } } const Tokens &amp;Result() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_result; } private: bool EndOfExperssion() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_current == L<span class="hljs-string"><span class="hljs-string">'\0'</span></span>; } bool IsNumber() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> iswdigit(*m_current) != <span class="hljs-number"><span class="hljs-number">0</span></span>; } void ScanNumber() { wchar_t *<span class="hljs-keyword"><span class="hljs-keyword">end</span></span> = nullptr; m_result.push_back(wcstod(m_current, &amp;<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>)); m_current = <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; } bool IsOperator() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_current == static_cast&lt;wchar_t&gt;(Operator::Plus); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail</code> <br> <br>  ,      .      ,  , .       . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"1+2*3/(4-5)"</span></span>); AssertRange::AreEqual({ Token(<span class="hljs-number"><span class="hljs-number">1</span></span>), Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">2</span></span>), Token(Operator::Mul), Token(<span class="hljs-number"><span class="hljs-number">3</span></span>), Token(Operator::Div), Token(Operator::LParen), Token(<span class="hljs-number"><span class="hljs-number">4</span></span>), Token(Operator::Minus), Token(<span class="hljs-number"><span class="hljs-number">5</span></span>), Token(Operator::RParen) }, tokens); }</code> <br>      <code>Operator</code> ,    . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L<span class="hljs-string"><span class="hljs-string">'+'</span></span>, Minus = L<span class="hljs-string"><span class="hljs-string">'-'</span></span>, Mul = L<span class="hljs-string"><span class="hljs-string">'*'</span></span>, Div = L<span class="hljs-string"><span class="hljs-string">'/'</span></span>, LParen = L<span class="hljs-string"><span class="hljs-string">'('</span></span>, RParen = L<span class="hljs-string"><span class="hljs-string">')'</span></span>, };</code> <br>   .         <code>IsOperator</code>  <code>Tokenizer</code> . <br> <br> <code class="cpp"> bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> std::any_of(all.begin(), all.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(), [this](Operator o) {<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_current == static_cast&lt;wchar_t&gt;(o); }); }</code> <br>         .        . <br> <br> <b class="spoiler_title">Interpreter.h</b> <code class="cpp">#pragma once; #include &lt;vector&gt; #include &lt;wchar.h&gt; #include &lt;algorithm&gt; namespace Interpreter { enum class Operator : wchar_t { Plus = L<span class="hljs-string"><span class="hljs-string">'+'</span></span>, Minus = L<span class="hljs-string"><span class="hljs-string">'-'</span></span>, Mul = L<span class="hljs-string"><span class="hljs-string">'*'</span></span>, Div = L<span class="hljs-string"><span class="hljs-string">'/'</span></span>, LParen = L<span class="hljs-string"><span class="hljs-string">'('</span></span>, RParen = L<span class="hljs-string"><span class="hljs-string">')'</span></span>, }; inline std::wstring ToString(const Operator &amp;op) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ static_cast&lt;wchar_t&gt;(op) }; } enum class TokenType { Operator, Number }; inline std::wstring ToString(const TokenType &amp;<span class="hljs-built_in"><span class="hljs-built_in">type</span></span>) { switch(<span class="hljs-built_in"><span class="hljs-built_in">type</span></span>) { case TokenType::Operator: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> L<span class="hljs-string"><span class="hljs-string">"Operator"</span></span>; case TokenType::Number: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> L<span class="hljs-string"><span class="hljs-string">"Number"</span></span>; default: throw std::out_of_range(<span class="hljs-string"><span class="hljs-string">"TokenType"</span></span>); } } class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_type; } operator Operator() const { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(m_type != TokenType::Operator) throw std::logic_error(<span class="hljs-string"><span class="hljs-string">"Should be operator token."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_operator; } operator double() const { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(m_type != TokenType::Number) throw std::logic_error(<span class="hljs-string"><span class="hljs-string">"Should be number token."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_number; } friend inline bool operator==(const Token &amp;left, const Token &amp;right) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(left.m_type == right.m_type) { switch(left.m_type) { case Interpreter::TokenType::Operator: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> left.m_operator == right.m_operator; case Interpreter::TokenType::Number: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> left.m_number == right.m_number; default: throw std::out_of_range(<span class="hljs-string"><span class="hljs-string">"TokenType"</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ToString(static_cast&lt;Operator&gt;(token)); default: throw std::out_of_range(<span class="hljs-string"><span class="hljs-string">"TokenType"</span></span>); } } typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!EndOfExperssion()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(IsNumber()) { ScanNumber(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(IsOperator()) { ScanOperator(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { MoveNext(); } } } const Tokens &amp;Result() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_result; } private: bool EndOfExperssion() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_current == L<span class="hljs-string"><span class="hljs-string">'\0'</span></span>; } bool IsNumber() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> iswdigit(*m_current) != <span class="hljs-number"><span class="hljs-number">0</span></span>; } void ScanNumber() { wchar_t *<span class="hljs-keyword"><span class="hljs-keyword">end</span></span> = nullptr; m_result.push_back(wcstod(m_current, &amp;<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>)); m_current = <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; } bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> std::any_of(all.begin(), all.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(), [this](Operator o) {<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_current == static_cast&lt;wchar_t&gt;(o); }); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tokenizer.Result(); } } // namespace Lexer } // namespace Interpreter</code> <br> <br> <b class="spoiler_title">InterpreterTests.cpp</b> <code class="cpp">#include <span class="hljs-string"><span class="hljs-string">"stdafx.h"</span></span> #include <span class="hljs-string"><span class="hljs-string">"CppUnitTest.h"</span></span> #include <span class="hljs-string"><span class="hljs-string">"Interpreter.h"</span></span> namespace InterpreterTests { using namespace Microsoft::VisualStudio::CppUnitTestFramework; using namespace Interpreter; using namespace std; namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(expect)), distance(actualIter, <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(actual)), L<span class="hljs-string"><span class="hljs-string">"Size differs."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(; expectIter != <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(expect) &amp;&amp; actualIter != <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(actual); ++expectIter, ++actualIter) { auto message = L<span class="hljs-string"><span class="hljs-string">"Mismatch in position "</span></span> + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual&lt;T&gt;(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange TEST_CLASS(LexerTests) { public: TEST_METHOD(Should_return_empty_token_list_when_put_empty_expression) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">""</span></span>); Assert::IsTrue(tokens.empty()); } TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"+"</span></span>); AssertRange::AreEqual({ Operator::Plus }, tokens); } TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"1"</span></span>); AssertRange::AreEqual({ <span class="hljs-number"><span class="hljs-number">1.0</span></span> }, tokens); } TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"12.34"</span></span>); AssertRange::AreEqual({ <span class="hljs-number"><span class="hljs-number">12.34</span></span> }, tokens); } TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"+12.34"</span></span>); AssertRange::AreEqual({ Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">12.34</span></span>) }, tokens); } TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">" 1 + 12.34 "</span></span>); AssertRange::AreEqual({ Token(<span class="hljs-number"><span class="hljs-number">1.0</span></span>), Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">12.34</span></span>) }, tokens); } TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"1+2*3/(4-5)"</span></span>); AssertRange::AreEqual({ Token(<span class="hljs-number"><span class="hljs-number">1</span></span>), Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">2</span></span>), Token(Operator::Mul), Token(<span class="hljs-number"><span class="hljs-number">3</span></span>), Token(Operator::Div), Token(Operator::LParen), Token(<span class="hljs-number"><span class="hljs-number">4</span></span>), Token(Operator::Minus), Token(<span class="hljs-number"><span class="hljs-number">5</span></span>), Token(Operator::RParen) }, tokens); } }; TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } TEST_METHOD(Should_get_type_for_number_token) { Token numToken(<span class="hljs-number"><span class="hljs-number">1.2</span></span>); Assert::AreEqual(TokenType::Number, numToken.Type()); } TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); } TEST_METHOD(Should_get_number_value_from_number_token) { Token token(<span class="hljs-number"><span class="hljs-number">1.23</span></span>); Assert::AreEqual&lt;double&gt;(<span class="hljs-number"><span class="hljs-number">1.23</span></span>, token); } }; }</code> <br> <br> <a href="https://github.com/Unril/InterpreterTDD/releases/tag/%25D0%259A%25D0%25BE%25D0%25BD%25D0%25B5%25D1%2586_%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B2%25D0%25BE%25D0%25B9_%25D1%2587%25D0%25B0%25D1%2581%25D1%2582%25D0%25B8">    GitHub</a> .         ,  .      <span class="hljs-string"><span class="hljs-string">"__"</span></span>. <br> <br>   <a href="http://habrahabr.ru/post/232081/">    </a> .      ,      <a href="http://habrahabr.ru/post/232097/">    </a> .</code> </pre> <code><code>std::vector,      Tokens</code> .            . <br> <br> <code class="cpp">#pragma once; #include &lt;vector&gt; namespace Interpreter { struct Token {}; typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { inline Tokens Tokenize(std::string expr) { throw std::exception(); } } // namespace Lexer } // namespace Interpreter</code> <br>   ,  ,   , .   ,    ,    <a href="http://cleancoder.posterous.com/the-transformation-priority-premise">The Transformation Priority Premise (TPP)</a>   .    , ,    ,     ,        .            .     ,     ,      ,           .  ,  ,   (   )    ,  ,  .     ,  ,         .     ,   TPP          . <br> <br>   : <br> <br> ({} ‚Üí nil)     ,   . (nil ‚Üí constant)    . (constant ‚Üí constant+)      (        ,  ). (constant ‚Üí scalar)    ,  . (statement ‚Üí statements)    (break, continue, return  ). (unconditional ‚Üí if)       . (scalar ‚Üí array)  / . (array ‚Üí container)     . (statement ‚Üí recursion)   . (if ‚Üí while)    . (expression ‚Üí function)   . (variable ‚Üí assignment)   . <br>        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::string expr) { return{}; }</code> <br> ,         .     . <br> <br> <s>         </s> .           .           .               .            .       . <br>  ,  <code>std::string</code>  <code>std::wstring</code> .         ,      Unicode.     . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); }</code> <br>  <code>AssertRange</code> -   ,       <code>AreEqual</code> ,   ,  ,    . <br> <br> <b class="spoiler_title">AssertRange</b> <code class="cpp">namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange</code> <br> <br>         <code>Operator</code>    .          <code>wchar_t</code>   ,         ,      . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', }; typedef Operator Token;</code> <br>    ,   ,        <code>Assert</code> ,    <code>ToString</code> ,    . <br> <br> <b class="spoiler_title">std::wstring ToString(const Token &amp;)</b> <code class="cpp">inline std::wstring ToString(const Token &amp;token) { return{ static_cast&lt;wchar_t&gt;(token) }; }</code> <br> <br>    ,   ,        .  ,   (unconditional ‚Üí if). <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { if(expr.empty()) { return{}; } return{ static_cast&lt;Operator&gt;(expr[0]) }; }</code> <br> <s>         </s> . <s>          .</s>           . ‚Ä¶ <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); }</code> <br>     .   ,     ,   - .    , : <br> <br>        ,      <code>Token</code> .       <code>dynamic_cast</code>    ,   .  ,    ,      .      <code>std::function</code>        .        .  Boost.Any,  - .            . <br>   ,   .      -  .  ,      ,      . <br> <br> ‚Ä¶        .        .        .        . <br>             . <br> <br> <code class="cpp">enum class TokenType { Operator, Number }; class Token { public: Token(Operator) {} TokenType Type() const { return TokenType::Operator; } }; ‚Ä¶ TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } };</code> <br>   <code>ToString</code>   <code>TokenType</code>       ,   ,   .     . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); }</code> <br>   .   (constant ‚Üí scalar)   . <br> <br> <code class="cpp">class Token { public: Token(Operator) :m_type(TokenType::Operator) {} Token(double) :m_type(TokenType::Number) {} TokenType Type() const { return m_type; } private: TokenType m_type; };</code> <br> ‚Ä¶ <s>       </s> . <s>       </s> .        .        . <br>    . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); }</code> <br>            . <br> <br> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} operator Operator() const { return m_operator; } ‚Ä¶ Operator m_operator; };</code> <br>      . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); }</code> <br>          ,  ,       <code>union</code> .         . <br> <br> <b class="spoiler_title">Token</b> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: return "Unknown token."; } }</code> <br> <br>  ,    ,      ,    .       .    . <br> <br> <i>          .</i>               .            .       . <br>        : <br> <br> <code class="cpp"> if(expr[0] &gt;= '0' &amp;&amp; expr[0] &lt;= '9') { return{ (double) expr[0] - '0' }; } return{ static_cast&lt;Operator&gt;(expr[0]) };</code> <br>      ,   . <br> <br> ‚Ä¶ <s>          .</s> <i>              .</i> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); }</code> <br> ,     <code>C</code>   ,  <code>isdigit</code> , ,       <code>atof</code> ,    ,      <code>wchar_t</code> .  (expression ‚Üí function).         . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { const wchar_t *current = expr.c_str(); if(!*current) return{}; if(iswdigit(*current)) return{ _wtof(current) }; return{ static_cast&lt;Operator&gt;(*current) }; }</code> <br>         .      . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>   ,        .  ,     .     .   <code>result</code> ,     . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); if(!*current) return result; if(iswdigit(*current)) { result.push_back(_wtof(current)); } else { result.push_back(static_cast&lt;Operator&gt;(*current)); } return result; }</code> <br>      :   (if ‚Üí while).     ,        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } } return result; }</code> <br>  <code>wcstod</code>    ,   <code>_wtof</code> ,           .           ,              .  ,    . <br> <br> <s>           .</s>       . <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>  (unconditional ‚Üí if)    ,    . <br> <br> <code class="cpp"> while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else if(*current == static_cast&lt;wchar_t&gt;(Operator::Plus)) { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } else { ++current; } }</code> <br>       .          .       <code>Detail</code>      .   <code>Tokenize</code>       . <br> <br> <code class="cpp">inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); }</code> <br> <b class="spoiler_title"> Detail::Tokenizer</b> <code class="cpp">namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { return *m_current == static_cast&lt;wchar_t&gt;(Operator::Plus); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail</code> <br> <br>  ,      .      ,  , .       . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); }</code> <br>      <code>Operator</code> ,    . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', };</code> <br>   .         <code>IsOperator</code>  <code>Tokenizer</code> . <br> <br> <code class="cpp"> bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); }</code> <br>         .        . <br> <br> <b class="spoiler_title">Interpreter.h</b> <code class="cpp">#pragma once; #include &lt;vector&gt; #include &lt;wchar.h&gt; #include &lt;algorithm&gt; namespace Interpreter { enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', }; inline std::wstring ToString(const Operator &amp;op) { return{ static_cast&lt;wchar_t&gt;(op) }; } enum class TokenType { Operator, Number }; inline std::wstring ToString(const TokenType &amp;type) { switch(type) { case TokenType::Operator: return L"Operator"; case TokenType::Number: return L"Number"; default: throw std::out_of_range("TokenType"); } } class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } friend inline bool operator==(const Token &amp;left, const Token &amp;right) { if(left.m_type == right.m_type) { switch(left.m_type) { case Interpreter::TokenType::Operator: return left.m_operator == right.m_operator; case Interpreter::TokenType::Number: return left.m_number == right.m_number; default: throw std::out_of_range("TokenType"); } } return false; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: throw std::out_of_range("TokenType"); } } typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); } } // namespace Lexer } // namespace Interpreter</code> <br> <br> <b class="spoiler_title">InterpreterTests.cpp</b> <code class="cpp">#include "stdafx.h" #include "CppUnitTest.h" #include "Interpreter.h" namespace InterpreterTests { using namespace Microsoft::VisualStudio::CppUnitTestFramework; using namespace Interpreter; using namespace std; namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual&lt;T&gt;(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange TEST_CLASS(LexerTests) { public: TEST_METHOD(Should_return_empty_token_list_when_put_empty_expression) { Tokens tokens = Lexer::Tokenize(L""); Assert::IsTrue(tokens.empty()); } TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); } TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); } TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); } TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); } }; TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); } TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); } TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); } }; }</code> <br> <br> <a href="https://github.com/Unril/InterpreterTDD/releases/tag/%25D0%259A%25D0%25BE%25D0%25BD%25D0%25B5%25D1%2586_%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B2%25D0%25BE%25D0%25B9_%25D1%2587%25D0%25B0%25D1%2581%25D1%2582%25D0%25B8">    GitHub</a> .         ,  .      "__". <br> <br>   <a href="http://habrahabr.ru/post/232081/">    </a> .      ,      <a href="http://habrahabr.ru/post/232097/">    </a> .</code> <pre> <code class="hljs lua"><code>std::vector,      Tokens</code> .            . <br> <br> <code class="cpp">#pragma once; #include &lt;vector&gt; namespace Interpreter { struct Token {}; typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { inline Tokens Tokenize(std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> expr) { throw std::exception(); } } // namespace Lexer } // namespace Interpreter</code> <br>   ,  ,   , .   ,    ,    <a href="http://cleancoder.posterous.com/the-transformation-priority-premise">The Transformation Priority Premise (TPP)</a>   .    , ,    ,     ,        .            .     ,     ,      ,           .  ,  ,   (   )    ,  ,  .     ,  ,         .     ,   TPP          . <br> <br>   : <br> <br> ({} ‚Üí <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)     ,   . (<span class="hljs-literal"><span class="hljs-literal">nil</span></span> ‚Üí constant)    . (constant ‚Üí constant+)      (        ,  ). (constant ‚Üí scalar)    ,  . (statement ‚Üí statements)    (<span class="hljs-keyword"><span class="hljs-keyword">break</span></span>, continue, <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>  ). (unconditional ‚Üí <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>)       . (scalar ‚Üí array)  / . (array ‚Üí container)     . (statement ‚Üí recursion)   . (<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ‚Üí <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>)    . (expression ‚Üí <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">)</span></span>   . (variable ‚Üí assignment)   . <br>        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> expr) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{}; }</code> <br> ,         .     . <br> <br> <s>         </s> .           .           .               .            .       . <br>  ,  <code>std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span></code>  <code>std::wstring</code> .         ,      Unicode.     . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"+"</span></span>); AssertRange::AreEqual({ Operator::Plus }, tokens); }</code> <br>  <code>AssertRange</code> -   ,       <code>AreEqual</code> ,   ,  ,    . <br> <br> <b class="spoiler_title">AssertRange</b> <code class="cpp">namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(expect)), distance(actualIter, <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(actual)), L<span class="hljs-string"><span class="hljs-string">"Size differs."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(; expectIter != <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(expect) &amp;&amp; actualIter != <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(actual); ++expectIter, ++actualIter) { auto message = L<span class="hljs-string"><span class="hljs-string">"Mismatch in position "</span></span> + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange</code> <br> <br>         <code>Operator</code>    .          <code>wchar_t</code>   ,         ,      . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L<span class="hljs-string"><span class="hljs-string">'+'</span></span>, }; typedef Operator Token;</code> <br>    ,   ,        <code>Assert</code> ,    <code>ToString</code> ,    . <br> <br> <b class="spoiler_title">std::wstring ToString(const Token &amp;)</b> <code class="cpp">inline std::wstring ToString(const Token &amp;token) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ static_cast&lt;wchar_t&gt;(token) }; }</code> <br> <br>    ,   ,        .  ,   (unconditional ‚Üí <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>). <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(expr.empty()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{}; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ static_cast&lt;Operator&gt;(expr[<span class="hljs-number"><span class="hljs-number">0</span></span>]) }; }</code> <br> <s>         </s> . <s>          .</s>           . ‚Ä¶ <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"1"</span></span>); AssertRange::AreEqual({ <span class="hljs-number"><span class="hljs-number">1.0</span></span> }, tokens); }</code> <br>     .   ,     ,   - .    , : <br> <br>        ,      <code>Token</code> .       <code>dynamic_cast</code>    ,   .  ,    ,      .      <code>std::<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span></span></code><span class="hljs-function"><span class="hljs-function">        .        .  </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Boost.Any</span></span></span><span class="hljs-function">,  - .            . </span></span><br><span class="hljs-function"><span class="hljs-function">   ,   .      -  .  ,      ,      . </span></span><br><span class="hljs-function"><span class="hljs-function"> </span></span><br><span class="hljs-function"><span class="hljs-function"> ‚Ä¶        .        .        .        . </span></span><br><span class="hljs-function"><span class="hljs-function">             . </span></span><br><span class="hljs-function"><span class="hljs-function"> </span></span><br><span class="hljs-function"><span class="hljs-function"> </span></span><code class="cpp"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">enum</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">class</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TokenType</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Operator</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Number</span></span></span><span class="hljs-function"> }; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">class</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Token</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">public</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Token</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Operator)</span></span></span></span> {} TokenType Type() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TokenType::Operator; } }; ‚Ä¶ TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } };</code> <br>   <code>ToString</code>   <code>TokenType</code>       ,   ,   .     . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_type_for_number_token) { Token numToken(<span class="hljs-number"><span class="hljs-number">1.2</span></span>); Assert::AreEqual(TokenType::Number, numToken.Type()); }</code> <br>   .   (constant ‚Üí scalar)   . <br> <br> <code class="cpp">class Token { public: Token(Operator) :m_type(TokenType::Operator) {} Token(double) :m_type(TokenType::Number) {} TokenType Type() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_type; } private: TokenType m_type; };</code> <br> ‚Ä¶ <s>       </s> . <s>       </s> .        .        . <br>    . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); }</code> <br>            . <br> <br> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} operator Operator() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_operator; } ‚Ä¶ Operator m_operator; };</code> <br>      . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_number_value_from_number_token) { Token token(<span class="hljs-number"><span class="hljs-number">1.23</span></span>); Assert::AreEqual&lt;double&gt;(<span class="hljs-number"><span class="hljs-number">1.23</span></span>, token); }</code> <br>          ,  ,       <code>union</code> .         . <br> <br> <b class="spoiler_title">Token</b> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_type; } operator Operator() const { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(m_type != TokenType::Operator) throw std::logic_error(<span class="hljs-string"><span class="hljs-string">"Should be operator token."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_operator; } operator double() const { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(m_type != TokenType::Number) throw std::logic_error(<span class="hljs-string"><span class="hljs-string">"Should be number token."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_number; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ToString(static_cast&lt;Operator&gt;(token)); default: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Unknown token."</span></span>; } }</code> <br> <br>  ,    ,      ,    .       .    . <br> <br> <i>          .</i>               .            .       . <br>        : <br> <br> <code class="cpp"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(expr[<span class="hljs-number"><span class="hljs-number">0</span></span>] &gt;= <span class="hljs-string"><span class="hljs-string">'0'</span></span> &amp;&amp; expr[<span class="hljs-number"><span class="hljs-number">0</span></span>] &lt;= <span class="hljs-string"><span class="hljs-string">'9'</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ (double) expr[<span class="hljs-number"><span class="hljs-number">0</span></span>] - <span class="hljs-string"><span class="hljs-string">'0'</span></span> }; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ static_cast&lt;Operator&gt;(expr[<span class="hljs-number"><span class="hljs-number">0</span></span>]) };</code> <br>      ,   . <br> <br> ‚Ä¶ <s>          .</s> <i>              .</i> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"12.34"</span></span>); AssertRange::AreEqual({ <span class="hljs-number"><span class="hljs-number">12.34</span></span> }, tokens); }</code> <br> ,     <code>C</code>   ,  <code>isdigit</code> , ,       <code>atof</code> ,    ,      <code>wchar_t</code> .  (expression ‚Üí <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">)</span></span>.         . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { const wchar_t *current = expr.c_str(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!*current) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{}; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(iswdigit(*current)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ _wtof(current) }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ static_cast&lt;Operator&gt;(*current) }; }</code> <br>         .      . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"+12.34"</span></span>); AssertRange::AreEqual({ Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">12.34</span></span>) }, tokens); }</code> <br>   ,        .  ,     .     .   <code>result</code> ,     . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!*current) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(iswdigit(*current)) { result.push_back(_wtof(current)); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { result.push_back(static_cast&lt;Operator&gt;(*current)); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> <br>      :   (<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ‚Üí <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>).     ,        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(*current) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(iswdigit(*current)) { wchar_t *<span class="hljs-keyword"><span class="hljs-keyword">end</span></span> = nullptr; result.push_back(wcstod(current, &amp;<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>)); current = <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> <br>  <code>wcstod</code>    ,   <code>_wtof</code> ,           .           ,              .  ,    . <br> <br> <s>           .</s>       . <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">" 1 + 12.34 "</span></span>); AssertRange::AreEqual({ Token(<span class="hljs-number"><span class="hljs-number">1.0</span></span>), Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">12.34</span></span>) }, tokens); }</code> <br>  (unconditional ‚Üí <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>)    ,    . <br> <br> <code class="cpp"> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(*current) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(iswdigit(*current)) { wchar_t *<span class="hljs-keyword"><span class="hljs-keyword">end</span></span> = nullptr; result.push_back(wcstod(current, &amp;<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>)); current = <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(*current == static_cast&lt;wchar_t&gt;(Operator::Plus)) { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { ++current; } }</code> <br>       .          .       <code>Detail</code>      .   <code>Tokenize</code>       . <br> <br> <code class="cpp">inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tokenizer.Result(); }</code> <br> <b class="spoiler_title"> Detail::Tokenizer</b> <code class="cpp">namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!EndOfExperssion()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(IsNumber()) { ScanNumber(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(IsOperator()) { ScanOperator(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { MoveNext(); } } } const Tokens &amp;Result() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_result; } private: bool EndOfExperssion() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_current == L<span class="hljs-string"><span class="hljs-string">'\0'</span></span>; } bool IsNumber() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> iswdigit(*m_current) != <span class="hljs-number"><span class="hljs-number">0</span></span>; } void ScanNumber() { wchar_t *<span class="hljs-keyword"><span class="hljs-keyword">end</span></span> = nullptr; m_result.push_back(wcstod(m_current, &amp;<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>)); m_current = <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; } bool IsOperator() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_current == static_cast&lt;wchar_t&gt;(Operator::Plus); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail</code> <br> <br>  ,      .      ,  , .       . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"1+2*3/(4-5)"</span></span>); AssertRange::AreEqual({ Token(<span class="hljs-number"><span class="hljs-number">1</span></span>), Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">2</span></span>), Token(Operator::Mul), Token(<span class="hljs-number"><span class="hljs-number">3</span></span>), Token(Operator::Div), Token(Operator::LParen), Token(<span class="hljs-number"><span class="hljs-number">4</span></span>), Token(Operator::Minus), Token(<span class="hljs-number"><span class="hljs-number">5</span></span>), Token(Operator::RParen) }, tokens); }</code> <br>      <code>Operator</code> ,    . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L<span class="hljs-string"><span class="hljs-string">'+'</span></span>, Minus = L<span class="hljs-string"><span class="hljs-string">'-'</span></span>, Mul = L<span class="hljs-string"><span class="hljs-string">'*'</span></span>, Div = L<span class="hljs-string"><span class="hljs-string">'/'</span></span>, LParen = L<span class="hljs-string"><span class="hljs-string">'('</span></span>, RParen = L<span class="hljs-string"><span class="hljs-string">')'</span></span>, };</code> <br>   .         <code>IsOperator</code>  <code>Tokenizer</code> . <br> <br> <code class="cpp"> bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> std::any_of(all.begin(), all.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(), [this](Operator o) {<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_current == static_cast&lt;wchar_t&gt;(o); }); }</code> <br>         .        . <br> <br> <b class="spoiler_title">Interpreter.h</b> <code class="cpp">#pragma once; #include &lt;vector&gt; #include &lt;wchar.h&gt; #include &lt;algorithm&gt; namespace Interpreter { enum class Operator : wchar_t { Plus = L<span class="hljs-string"><span class="hljs-string">'+'</span></span>, Minus = L<span class="hljs-string"><span class="hljs-string">'-'</span></span>, Mul = L<span class="hljs-string"><span class="hljs-string">'*'</span></span>, Div = L<span class="hljs-string"><span class="hljs-string">'/'</span></span>, LParen = L<span class="hljs-string"><span class="hljs-string">'('</span></span>, RParen = L<span class="hljs-string"><span class="hljs-string">')'</span></span>, }; inline std::wstring ToString(const Operator &amp;op) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ static_cast&lt;wchar_t&gt;(op) }; } enum class TokenType { Operator, Number }; inline std::wstring ToString(const TokenType &amp;<span class="hljs-built_in"><span class="hljs-built_in">type</span></span>) { switch(<span class="hljs-built_in"><span class="hljs-built_in">type</span></span>) { case TokenType::Operator: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> L<span class="hljs-string"><span class="hljs-string">"Operator"</span></span>; case TokenType::Number: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> L<span class="hljs-string"><span class="hljs-string">"Number"</span></span>; default: throw std::out_of_range(<span class="hljs-string"><span class="hljs-string">"TokenType"</span></span>); } } class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_type; } operator Operator() const { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(m_type != TokenType::Operator) throw std::logic_error(<span class="hljs-string"><span class="hljs-string">"Should be operator token."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_operator; } operator double() const { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(m_type != TokenType::Number) throw std::logic_error(<span class="hljs-string"><span class="hljs-string">"Should be number token."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_number; } friend inline bool operator==(const Token &amp;left, const Token &amp;right) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(left.m_type == right.m_type) { switch(left.m_type) { case Interpreter::TokenType::Operator: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> left.m_operator == right.m_operator; case Interpreter::TokenType::Number: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> left.m_number == right.m_number; default: throw std::out_of_range(<span class="hljs-string"><span class="hljs-string">"TokenType"</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ToString(static_cast&lt;Operator&gt;(token)); default: throw std::out_of_range(<span class="hljs-string"><span class="hljs-string">"TokenType"</span></span>); } } typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!EndOfExperssion()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(IsNumber()) { ScanNumber(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(IsOperator()) { ScanOperator(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { MoveNext(); } } } const Tokens &amp;Result() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_result; } private: bool EndOfExperssion() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_current == L<span class="hljs-string"><span class="hljs-string">'\0'</span></span>; } bool IsNumber() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> iswdigit(*m_current) != <span class="hljs-number"><span class="hljs-number">0</span></span>; } void ScanNumber() { wchar_t *<span class="hljs-keyword"><span class="hljs-keyword">end</span></span> = nullptr; m_result.push_back(wcstod(m_current, &amp;<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>)); m_current = <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; } bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> std::any_of(all.begin(), all.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(), [this](Operator o) {<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_current == static_cast&lt;wchar_t&gt;(o); }); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tokenizer.Result(); } } // namespace Lexer } // namespace Interpreter</code> <br> <br> <b class="spoiler_title">InterpreterTests.cpp</b> <code class="cpp">#include <span class="hljs-string"><span class="hljs-string">"stdafx.h"</span></span> #include <span class="hljs-string"><span class="hljs-string">"CppUnitTest.h"</span></span> #include <span class="hljs-string"><span class="hljs-string">"Interpreter.h"</span></span> namespace InterpreterTests { using namespace Microsoft::VisualStudio::CppUnitTestFramework; using namespace Interpreter; using namespace std; namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(expect)), distance(actualIter, <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(actual)), L<span class="hljs-string"><span class="hljs-string">"Size differs."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(; expectIter != <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(expect) &amp;&amp; actualIter != <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(actual); ++expectIter, ++actualIter) { auto message = L<span class="hljs-string"><span class="hljs-string">"Mismatch in position "</span></span> + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual&lt;T&gt;(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange TEST_CLASS(LexerTests) { public: TEST_METHOD(Should_return_empty_token_list_when_put_empty_expression) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">""</span></span>); Assert::IsTrue(tokens.empty()); } TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"+"</span></span>); AssertRange::AreEqual({ Operator::Plus }, tokens); } TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"1"</span></span>); AssertRange::AreEqual({ <span class="hljs-number"><span class="hljs-number">1.0</span></span> }, tokens); } TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"12.34"</span></span>); AssertRange::AreEqual({ <span class="hljs-number"><span class="hljs-number">12.34</span></span> }, tokens); } TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"+12.34"</span></span>); AssertRange::AreEqual({ Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">12.34</span></span>) }, tokens); } TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">" 1 + 12.34 "</span></span>); AssertRange::AreEqual({ Token(<span class="hljs-number"><span class="hljs-number">1.0</span></span>), Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">12.34</span></span>) }, tokens); } TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"1+2*3/(4-5)"</span></span>); AssertRange::AreEqual({ Token(<span class="hljs-number"><span class="hljs-number">1</span></span>), Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">2</span></span>), Token(Operator::Mul), Token(<span class="hljs-number"><span class="hljs-number">3</span></span>), Token(Operator::Div), Token(Operator::LParen), Token(<span class="hljs-number"><span class="hljs-number">4</span></span>), Token(Operator::Minus), Token(<span class="hljs-number"><span class="hljs-number">5</span></span>), Token(Operator::RParen) }, tokens); } }; TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } TEST_METHOD(Should_get_type_for_number_token) { Token numToken(<span class="hljs-number"><span class="hljs-number">1.2</span></span>); Assert::AreEqual(TokenType::Number, numToken.Type()); } TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); } TEST_METHOD(Should_get_number_value_from_number_token) { Token token(<span class="hljs-number"><span class="hljs-number">1.23</span></span>); Assert::AreEqual&lt;double&gt;(<span class="hljs-number"><span class="hljs-number">1.23</span></span>, token); } }; }</code> <br> <br> <a href="https://github.com/Unril/InterpreterTDD/releases/tag/%25D0%259A%25D0%25BE%25D0%25BD%25D0%25B5%25D1%2586_%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B2%25D0%25BE%25D0%25B9_%25D1%2587%25D0%25B0%25D1%2581%25D1%2582%25D0%25B8">    GitHub</a> .         ,  .      <span class="hljs-string"><span class="hljs-string">"__"</span></span>. <br> <br>   <a href="http://habrahabr.ru/post/232081/">    </a> .      ,      <a href="http://habrahabr.ru/post/232097/">    </a> .</code> </pre> <code><code>std::vector,      Tokens</code> .            . <br> <br> <code class="cpp">#pragma once; #include &lt;vector&gt; namespace Interpreter { struct Token {}; typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { inline Tokens Tokenize(std::string expr) { throw std::exception(); } } // namespace Lexer } // namespace Interpreter</code> <br>   ,  ,   , .   ,    ,    <a href="http://cleancoder.posterous.com/the-transformation-priority-premise">The Transformation Priority Premise (TPP)</a>   .    , ,    ,     ,        .            .     ,     ,      ,           .  ,  ,   (   )    ,  ,  .     ,  ,         .     ,   TPP          . <br> <br>   : <br> <br> ({} ‚Üí nil)     ,   . (nil ‚Üí constant)    . (constant ‚Üí constant+)      (        ,  ). (constant ‚Üí scalar)    ,  . (statement ‚Üí statements)    (break, continue, return  ). (unconditional ‚Üí if)       . (scalar ‚Üí array)  / . (array ‚Üí container)     . (statement ‚Üí recursion)   . (if ‚Üí while)    . (expression ‚Üí function)   . (variable ‚Üí assignment)   . <br>        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::string expr) { return{}; }</code> <br> ,         .     . <br> <br> <s>         </s> .           .           .               .            .       . <br>  ,  <code>std::string</code>  <code>std::wstring</code> .         ,      Unicode.     . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); }</code> <br>  <code>AssertRange</code> -   ,       <code>AreEqual</code> ,   ,  ,    . <br> <br> <b class="spoiler_title">AssertRange</b> <code class="cpp">namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange</code> <br> <br>         <code>Operator</code>    .          <code>wchar_t</code>   ,         ,      . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', }; typedef Operator Token;</code> <br>    ,   ,        <code>Assert</code> ,    <code>ToString</code> ,    . <br> <br> <b class="spoiler_title">std::wstring ToString(const Token &amp;)</b> <code class="cpp">inline std::wstring ToString(const Token &amp;token) { return{ static_cast&lt;wchar_t&gt;(token) }; }</code> <br> <br>    ,   ,        .  ,   (unconditional ‚Üí if). <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { if(expr.empty()) { return{}; } return{ static_cast&lt;Operator&gt;(expr[0]) }; }</code> <br> <s>         </s> . <s>          .</s>           . ‚Ä¶ <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); }</code> <br>     .   ,     ,   - .    , : <br> <br>        ,      <code>Token</code> .       <code>dynamic_cast</code>    ,   .  ,    ,      .      <code>std::function</code>        .        .  Boost.Any,  - .            . <br>   ,   .      -  .  ,      ,      . <br> <br> ‚Ä¶        .        .        .        . <br>             . <br> <br> <code class="cpp">enum class TokenType { Operator, Number }; class Token { public: Token(Operator) {} TokenType Type() const { return TokenType::Operator; } }; ‚Ä¶ TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } };</code> <br>   <code>ToString</code>   <code>TokenType</code>       ,   ,   .     . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); }</code> <br>   .   (constant ‚Üí scalar)   . <br> <br> <code class="cpp">class Token { public: Token(Operator) :m_type(TokenType::Operator) {} Token(double) :m_type(TokenType::Number) {} TokenType Type() const { return m_type; } private: TokenType m_type; };</code> <br> ‚Ä¶ <s>       </s> . <s>       </s> .        .        . <br>    . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); }</code> <br>            . <br> <br> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} operator Operator() const { return m_operator; } ‚Ä¶ Operator m_operator; };</code> <br>      . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); }</code> <br>          ,  ,       <code>union</code> .         . <br> <br> <b class="spoiler_title">Token</b> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: return "Unknown token."; } }</code> <br> <br>  ,    ,      ,    .       .    . <br> <br> <i>          .</i>               .            .       . <br>        : <br> <br> <code class="cpp"> if(expr[0] &gt;= '0' &amp;&amp; expr[0] &lt;= '9') { return{ (double) expr[0] - '0' }; } return{ static_cast&lt;Operator&gt;(expr[0]) };</code> <br>      ,   . <br> <br> ‚Ä¶ <s>          .</s> <i>              .</i> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); }</code> <br> ,     <code>C</code>   ,  <code>isdigit</code> , ,       <code>atof</code> ,    ,      <code>wchar_t</code> .  (expression ‚Üí function).         . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { const wchar_t *current = expr.c_str(); if(!*current) return{}; if(iswdigit(*current)) return{ _wtof(current) }; return{ static_cast&lt;Operator&gt;(*current) }; }</code> <br>         .      . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>   ,        .  ,     .     .   <code>result</code> ,     . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); if(!*current) return result; if(iswdigit(*current)) { result.push_back(_wtof(current)); } else { result.push_back(static_cast&lt;Operator&gt;(*current)); } return result; }</code> <br>      :   (if ‚Üí while).     ,        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } } return result; }</code> <br>  <code>wcstod</code>    ,   <code>_wtof</code> ,           .           ,              .  ,    . <br> <br> <s>           .</s>       . <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>  (unconditional ‚Üí if)    ,    . <br> <br> <code class="cpp"> while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else if(*current == static_cast&lt;wchar_t&gt;(Operator::Plus)) { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } else { ++current; } }</code> <br>       .          .       <code>Detail</code>      .   <code>Tokenize</code>       . <br> <br> <code class="cpp">inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); }</code> <br> <b class="spoiler_title"> Detail::Tokenizer</b> <code class="cpp">namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { return *m_current == static_cast&lt;wchar_t&gt;(Operator::Plus); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail</code> <br> <br>  ,      .      ,  , .       . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); }</code> <br>      <code>Operator</code> ,    . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', };</code> <br>   .         <code>IsOperator</code>  <code>Tokenizer</code> . <br> <br> <code class="cpp"> bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); }</code> <br>         .        . <br> <br> <b class="spoiler_title">Interpreter.h</b> <code class="cpp">#pragma once; #include &lt;vector&gt; #include &lt;wchar.h&gt; #include &lt;algorithm&gt; namespace Interpreter { enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', }; inline std::wstring ToString(const Operator &amp;op) { return{ static_cast&lt;wchar_t&gt;(op) }; } enum class TokenType { Operator, Number }; inline std::wstring ToString(const TokenType &amp;type) { switch(type) { case TokenType::Operator: return L"Operator"; case TokenType::Number: return L"Number"; default: throw std::out_of_range("TokenType"); } } class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } friend inline bool operator==(const Token &amp;left, const Token &amp;right) { if(left.m_type == right.m_type) { switch(left.m_type) { case Interpreter::TokenType::Operator: return left.m_operator == right.m_operator; case Interpreter::TokenType::Number: return left.m_number == right.m_number; default: throw std::out_of_range("TokenType"); } } return false; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: throw std::out_of_range("TokenType"); } } typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); } } // namespace Lexer } // namespace Interpreter</code> <br> <br> <b class="spoiler_title">InterpreterTests.cpp</b> <code class="cpp">#include "stdafx.h" #include "CppUnitTest.h" #include "Interpreter.h" namespace InterpreterTests { using namespace Microsoft::VisualStudio::CppUnitTestFramework; using namespace Interpreter; using namespace std; namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual&lt;T&gt;(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange TEST_CLASS(LexerTests) { public: TEST_METHOD(Should_return_empty_token_list_when_put_empty_expression) { Tokens tokens = Lexer::Tokenize(L""); Assert::IsTrue(tokens.empty()); } TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); } TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); } TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); } TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); } }; TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); } TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); } TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); } }; }</code> <br> <br> <a href="https://github.com/Unril/InterpreterTDD/releases/tag/%25D0%259A%25D0%25BE%25D0%25BD%25D0%25B5%25D1%2586_%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B2%25D0%25BE%25D0%25B9_%25D1%2587%25D0%25B0%25D1%2581%25D1%2582%25D0%25B8">    GitHub</a> .         ,  .      "__". <br> <br>   <a href="http://habrahabr.ru/post/232081/">    </a> .      ,      <a href="http://habrahabr.ru/post/232097/">    </a> .</code> <pre> <code class="hljs lua"><code>std::vector,      Tokens</code> .            . <br> <br> <code class="cpp">#pragma once; #include &lt;vector&gt; namespace Interpreter { struct Token {}; typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { inline Tokens Tokenize(std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> expr) { throw std::exception(); } } // namespace Lexer } // namespace Interpreter</code> <br>   ,  ,   , .   ,    ,    <a href="http://cleancoder.posterous.com/the-transformation-priority-premise">The Transformation Priority Premise (TPP)</a>   .    , ,    ,     ,        .            .     ,     ,      ,           .  ,  ,   (   )    ,  ,  .     ,  ,         .     ,   TPP          . <br> <br>   : <br> <br> ({} ‚Üí <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)     ,   . (<span class="hljs-literal"><span class="hljs-literal">nil</span></span> ‚Üí constant)    . (constant ‚Üí constant+)      (        ,  ). (constant ‚Üí scalar)    ,  . (statement ‚Üí statements)    (<span class="hljs-keyword"><span class="hljs-keyword">break</span></span>, continue, <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>  ). (unconditional ‚Üí <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>)       . (scalar ‚Üí array)  / . (array ‚Üí container)     . (statement ‚Üí recursion)   . (<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ‚Üí <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>)    . (expression ‚Üí <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">)</span></span>   . (variable ‚Üí assignment)   . <br>        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> expr) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{}; }</code> <br> ,         .     . <br> <br> <s>         </s> .           .           .               .            .       . <br>  ,  <code>std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span></code>  <code>std::wstring</code> .         ,      Unicode.     . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"+"</span></span>); AssertRange::AreEqual({ Operator::Plus }, tokens); }</code> <br>  <code>AssertRange</code> -   ,       <code>AreEqual</code> ,   ,  ,    . <br> <br> <b class="spoiler_title">AssertRange</b> <code class="cpp">namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(expect)), distance(actualIter, <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(actual)), L<span class="hljs-string"><span class="hljs-string">"Size differs."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(; expectIter != <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(expect) &amp;&amp; actualIter != <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(actual); ++expectIter, ++actualIter) { auto message = L<span class="hljs-string"><span class="hljs-string">"Mismatch in position "</span></span> + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange</code> <br> <br>         <code>Operator</code>    .          <code>wchar_t</code>   ,         ,      . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L<span class="hljs-string"><span class="hljs-string">'+'</span></span>, }; typedef Operator Token;</code> <br>    ,   ,        <code>Assert</code> ,    <code>ToString</code> ,    . <br> <br> <b class="spoiler_title">std::wstring ToString(const Token &amp;)</b> <code class="cpp">inline std::wstring ToString(const Token &amp;token) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ static_cast&lt;wchar_t&gt;(token) }; }</code> <br> <br>    ,   ,        .  ,   (unconditional ‚Üí <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>). <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(expr.empty()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{}; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ static_cast&lt;Operator&gt;(expr[<span class="hljs-number"><span class="hljs-number">0</span></span>]) }; }</code> <br> <s>         </s> . <s>          .</s>           . ‚Ä¶ <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"1"</span></span>); AssertRange::AreEqual({ <span class="hljs-number"><span class="hljs-number">1.0</span></span> }, tokens); }</code> <br>     .   ,     ,   - .    , : <br> <br>        ,      <code>Token</code> .       <code>dynamic_cast</code>    ,   .  ,    ,      .      <code>std::<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span></span></code><span class="hljs-function"><span class="hljs-function">        .        .  </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Boost.Any</span></span></span><span class="hljs-function">,  - .            . </span></span><br><span class="hljs-function"><span class="hljs-function">   ,   .      -  .  ,      ,      . </span></span><br><span class="hljs-function"><span class="hljs-function"> </span></span><br><span class="hljs-function"><span class="hljs-function"> ‚Ä¶        .        .        .        . </span></span><br><span class="hljs-function"><span class="hljs-function">             . </span></span><br><span class="hljs-function"><span class="hljs-function"> </span></span><br><span class="hljs-function"><span class="hljs-function"> </span></span><code class="cpp"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">enum</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">class</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TokenType</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Operator</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Number</span></span></span><span class="hljs-function"> }; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">class</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Token</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">public</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Token</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Operator)</span></span></span></span> {} TokenType Type() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TokenType::Operator; } }; ‚Ä¶ TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } };</code> <br>   <code>ToString</code>   <code>TokenType</code>       ,   ,   .     . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_type_for_number_token) { Token numToken(<span class="hljs-number"><span class="hljs-number">1.2</span></span>); Assert::AreEqual(TokenType::Number, numToken.Type()); }</code> <br>   .   (constant ‚Üí scalar)   . <br> <br> <code class="cpp">class Token { public: Token(Operator) :m_type(TokenType::Operator) {} Token(double) :m_type(TokenType::Number) {} TokenType Type() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_type; } private: TokenType m_type; };</code> <br> ‚Ä¶ <s>       </s> . <s>       </s> .        .        . <br>    . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); }</code> <br>            . <br> <br> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} operator Operator() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_operator; } ‚Ä¶ Operator m_operator; };</code> <br>      . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_number_value_from_number_token) { Token token(<span class="hljs-number"><span class="hljs-number">1.23</span></span>); Assert::AreEqual&lt;double&gt;(<span class="hljs-number"><span class="hljs-number">1.23</span></span>, token); }</code> <br>          ,  ,       <code>union</code> .         . <br> <br> <b class="spoiler_title">Token</b> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_type; } operator Operator() const { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(m_type != TokenType::Operator) throw std::logic_error(<span class="hljs-string"><span class="hljs-string">"Should be operator token."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_operator; } operator double() const { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(m_type != TokenType::Number) throw std::logic_error(<span class="hljs-string"><span class="hljs-string">"Should be number token."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_number; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ToString(static_cast&lt;Operator&gt;(token)); default: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Unknown token."</span></span>; } }</code> <br> <br>  ,    ,      ,    .       .    . <br> <br> <i>          .</i>               .            .       . <br>        : <br> <br> <code class="cpp"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(expr[<span class="hljs-number"><span class="hljs-number">0</span></span>] &gt;= <span class="hljs-string"><span class="hljs-string">'0'</span></span> &amp;&amp; expr[<span class="hljs-number"><span class="hljs-number">0</span></span>] &lt;= <span class="hljs-string"><span class="hljs-string">'9'</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ (double) expr[<span class="hljs-number"><span class="hljs-number">0</span></span>] - <span class="hljs-string"><span class="hljs-string">'0'</span></span> }; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ static_cast&lt;Operator&gt;(expr[<span class="hljs-number"><span class="hljs-number">0</span></span>]) };</code> <br>      ,   . <br> <br> ‚Ä¶ <s>          .</s> <i>              .</i> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"12.34"</span></span>); AssertRange::AreEqual({ <span class="hljs-number"><span class="hljs-number">12.34</span></span> }, tokens); }</code> <br> ,     <code>C</code>   ,  <code>isdigit</code> , ,       <code>atof</code> ,    ,      <code>wchar_t</code> .  (expression ‚Üí <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">)</span></span>.         . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { const wchar_t *current = expr.c_str(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!*current) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{}; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(iswdigit(*current)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ _wtof(current) }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ static_cast&lt;Operator&gt;(*current) }; }</code> <br>         .      . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"+12.34"</span></span>); AssertRange::AreEqual({ Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">12.34</span></span>) }, tokens); }</code> <br>   ,        .  ,     .     .   <code>result</code> ,     . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!*current) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(iswdigit(*current)) { result.push_back(_wtof(current)); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { result.push_back(static_cast&lt;Operator&gt;(*current)); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> <br>      :   (<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ‚Üí <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>).     ,        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(*current) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(iswdigit(*current)) { wchar_t *<span class="hljs-keyword"><span class="hljs-keyword">end</span></span> = nullptr; result.push_back(wcstod(current, &amp;<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>)); current = <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> <br>  <code>wcstod</code>    ,   <code>_wtof</code> ,           .           ,              .  ,    . <br> <br> <s>           .</s>       . <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">" 1 + 12.34 "</span></span>); AssertRange::AreEqual({ Token(<span class="hljs-number"><span class="hljs-number">1.0</span></span>), Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">12.34</span></span>) }, tokens); }</code> <br>  (unconditional ‚Üí <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>)    ,    . <br> <br> <code class="cpp"> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(*current) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(iswdigit(*current)) { wchar_t *<span class="hljs-keyword"><span class="hljs-keyword">end</span></span> = nullptr; result.push_back(wcstod(current, &amp;<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>)); current = <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(*current == static_cast&lt;wchar_t&gt;(Operator::Plus)) { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { ++current; } }</code> <br>       .          .       <code>Detail</code>      .   <code>Tokenize</code>       . <br> <br> <code class="cpp">inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tokenizer.Result(); }</code> <br> <b class="spoiler_title"> Detail::Tokenizer</b> <code class="cpp">namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!EndOfExperssion()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(IsNumber()) { ScanNumber(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(IsOperator()) { ScanOperator(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { MoveNext(); } } } const Tokens &amp;Result() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_result; } private: bool EndOfExperssion() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_current == L<span class="hljs-string"><span class="hljs-string">'\0'</span></span>; } bool IsNumber() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> iswdigit(*m_current) != <span class="hljs-number"><span class="hljs-number">0</span></span>; } void ScanNumber() { wchar_t *<span class="hljs-keyword"><span class="hljs-keyword">end</span></span> = nullptr; m_result.push_back(wcstod(m_current, &amp;<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>)); m_current = <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; } bool IsOperator() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_current == static_cast&lt;wchar_t&gt;(Operator::Plus); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail</code> <br> <br>  ,      .      ,  , .       . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"1+2*3/(4-5)"</span></span>); AssertRange::AreEqual({ Token(<span class="hljs-number"><span class="hljs-number">1</span></span>), Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">2</span></span>), Token(Operator::Mul), Token(<span class="hljs-number"><span class="hljs-number">3</span></span>), Token(Operator::Div), Token(Operator::LParen), Token(<span class="hljs-number"><span class="hljs-number">4</span></span>), Token(Operator::Minus), Token(<span class="hljs-number"><span class="hljs-number">5</span></span>), Token(Operator::RParen) }, tokens); }</code> <br>      <code>Operator</code> ,    . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L<span class="hljs-string"><span class="hljs-string">'+'</span></span>, Minus = L<span class="hljs-string"><span class="hljs-string">'-'</span></span>, Mul = L<span class="hljs-string"><span class="hljs-string">'*'</span></span>, Div = L<span class="hljs-string"><span class="hljs-string">'/'</span></span>, LParen = L<span class="hljs-string"><span class="hljs-string">'('</span></span>, RParen = L<span class="hljs-string"><span class="hljs-string">')'</span></span>, };</code> <br>   .         <code>IsOperator</code>  <code>Tokenizer</code> . <br> <br> <code class="cpp"> bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> std::any_of(all.begin(), all.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(), [this](Operator o) {<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_current == static_cast&lt;wchar_t&gt;(o); }); }</code> <br>         .        . <br> <br> <b class="spoiler_title">Interpreter.h</b> <code class="cpp">#pragma once; #include &lt;vector&gt; #include &lt;wchar.h&gt; #include &lt;algorithm&gt; namespace Interpreter { enum class Operator : wchar_t { Plus = L<span class="hljs-string"><span class="hljs-string">'+'</span></span>, Minus = L<span class="hljs-string"><span class="hljs-string">'-'</span></span>, Mul = L<span class="hljs-string"><span class="hljs-string">'*'</span></span>, Div = L<span class="hljs-string"><span class="hljs-string">'/'</span></span>, LParen = L<span class="hljs-string"><span class="hljs-string">'('</span></span>, RParen = L<span class="hljs-string"><span class="hljs-string">')'</span></span>, }; inline std::wstring ToString(const Operator &amp;op) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ static_cast&lt;wchar_t&gt;(op) }; } enum class TokenType { Operator, Number }; inline std::wstring ToString(const TokenType &amp;<span class="hljs-built_in"><span class="hljs-built_in">type</span></span>) { switch(<span class="hljs-built_in"><span class="hljs-built_in">type</span></span>) { case TokenType::Operator: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> L<span class="hljs-string"><span class="hljs-string">"Operator"</span></span>; case TokenType::Number: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> L<span class="hljs-string"><span class="hljs-string">"Number"</span></span>; default: throw std::out_of_range(<span class="hljs-string"><span class="hljs-string">"TokenType"</span></span>); } } class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_type; } operator Operator() const { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(m_type != TokenType::Operator) throw std::logic_error(<span class="hljs-string"><span class="hljs-string">"Should be operator token."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_operator; } operator double() const { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(m_type != TokenType::Number) throw std::logic_error(<span class="hljs-string"><span class="hljs-string">"Should be number token."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_number; } friend inline bool operator==(const Token &amp;left, const Token &amp;right) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(left.m_type == right.m_type) { switch(left.m_type) { case Interpreter::TokenType::Operator: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> left.m_operator == right.m_operator; case Interpreter::TokenType::Number: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> left.m_number == right.m_number; default: throw std::out_of_range(<span class="hljs-string"><span class="hljs-string">"TokenType"</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ToString(static_cast&lt;Operator&gt;(token)); default: throw std::out_of_range(<span class="hljs-string"><span class="hljs-string">"TokenType"</span></span>); } } typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!EndOfExperssion()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(IsNumber()) { ScanNumber(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(IsOperator()) { ScanOperator(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { MoveNext(); } } } const Tokens &amp;Result() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_result; } private: bool EndOfExperssion() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_current == L<span class="hljs-string"><span class="hljs-string">'\0'</span></span>; } bool IsNumber() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> iswdigit(*m_current) != <span class="hljs-number"><span class="hljs-number">0</span></span>; } void ScanNumber() { wchar_t *<span class="hljs-keyword"><span class="hljs-keyword">end</span></span> = nullptr; m_result.push_back(wcstod(m_current, &amp;<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>)); m_current = <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; } bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> std::any_of(all.begin(), all.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(), [this](Operator o) {<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_current == static_cast&lt;wchar_t&gt;(o); }); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tokenizer.Result(); } } // namespace Lexer } // namespace Interpreter</code> <br> <br> <b class="spoiler_title">InterpreterTests.cpp</b> <code class="cpp">#include <span class="hljs-string"><span class="hljs-string">"stdafx.h"</span></span> #include <span class="hljs-string"><span class="hljs-string">"CppUnitTest.h"</span></span> #include <span class="hljs-string"><span class="hljs-string">"Interpreter.h"</span></span> namespace InterpreterTests { using namespace Microsoft::VisualStudio::CppUnitTestFramework; using namespace Interpreter; using namespace std; namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(expect)), distance(actualIter, <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(actual)), L<span class="hljs-string"><span class="hljs-string">"Size differs."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(; expectIter != <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(expect) &amp;&amp; actualIter != <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(actual); ++expectIter, ++actualIter) { auto message = L<span class="hljs-string"><span class="hljs-string">"Mismatch in position "</span></span> + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual&lt;T&gt;(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange TEST_CLASS(LexerTests) { public: TEST_METHOD(Should_return_empty_token_list_when_put_empty_expression) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">""</span></span>); Assert::IsTrue(tokens.empty()); } TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"+"</span></span>); AssertRange::AreEqual({ Operator::Plus }, tokens); } TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"1"</span></span>); AssertRange::AreEqual({ <span class="hljs-number"><span class="hljs-number">1.0</span></span> }, tokens); } TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"12.34"</span></span>); AssertRange::AreEqual({ <span class="hljs-number"><span class="hljs-number">12.34</span></span> }, tokens); } TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"+12.34"</span></span>); AssertRange::AreEqual({ Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">12.34</span></span>) }, tokens); } TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">" 1 + 12.34 "</span></span>); AssertRange::AreEqual({ Token(<span class="hljs-number"><span class="hljs-number">1.0</span></span>), Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">12.34</span></span>) }, tokens); } TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"1+2*3/(4-5)"</span></span>); AssertRange::AreEqual({ Token(<span class="hljs-number"><span class="hljs-number">1</span></span>), Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">2</span></span>), Token(Operator::Mul), Token(<span class="hljs-number"><span class="hljs-number">3</span></span>), Token(Operator::Div), Token(Operator::LParen), Token(<span class="hljs-number"><span class="hljs-number">4</span></span>), Token(Operator::Minus), Token(<span class="hljs-number"><span class="hljs-number">5</span></span>), Token(Operator::RParen) }, tokens); } }; TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } TEST_METHOD(Should_get_type_for_number_token) { Token numToken(<span class="hljs-number"><span class="hljs-number">1.2</span></span>); Assert::AreEqual(TokenType::Number, numToken.Type()); } TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); } TEST_METHOD(Should_get_number_value_from_number_token) { Token token(<span class="hljs-number"><span class="hljs-number">1.23</span></span>); Assert::AreEqual&lt;double&gt;(<span class="hljs-number"><span class="hljs-number">1.23</span></span>, token); } }; }</code> <br> <br> <a href="https://github.com/Unril/InterpreterTDD/releases/tag/%25D0%259A%25D0%25BE%25D0%25BD%25D0%25B5%25D1%2586_%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B2%25D0%25BE%25D0%25B9_%25D1%2587%25D0%25B0%25D1%2581%25D1%2582%25D0%25B8">    GitHub</a> .         ,  .      <span class="hljs-string"><span class="hljs-string">"__"</span></span>. <br> <br>   <a href="http://habrahabr.ru/post/232081/">    </a> .      ,      <a href="http://habrahabr.ru/post/232097/">    </a> .</code> </pre> <code><code>std::vector,      Tokens</code> .            . <br> <br> <code class="cpp">#pragma once; #include &lt;vector&gt; namespace Interpreter { struct Token {}; typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { inline Tokens Tokenize(std::string expr) { throw std::exception(); } } // namespace Lexer } // namespace Interpreter</code> <br>   ,  ,   , .   ,    ,    <a href="http://cleancoder.posterous.com/the-transformation-priority-premise">The Transformation Priority Premise (TPP)</a>   .    , ,    ,     ,        .            .     ,     ,      ,           .  ,  ,   (   )    ,  ,  .     ,  ,         .     ,   TPP          . <br> <br>   : <br> <br> ({} ‚Üí nil)     ,   . (nil ‚Üí constant)    . (constant ‚Üí constant+)      (        ,  ). (constant ‚Üí scalar)    ,  . (statement ‚Üí statements)    (break, continue, return  ). (unconditional ‚Üí if)       . (scalar ‚Üí array)  / . (array ‚Üí container)     . (statement ‚Üí recursion)   . (if ‚Üí while)    . (expression ‚Üí function)   . (variable ‚Üí assignment)   . <br>        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::string expr) { return{}; }</code> <br> ,         .     . <br> <br> <s>         </s> .           .           .               .            .       . <br>  ,  <code>std::string</code>  <code>std::wstring</code> .         ,      Unicode.     . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); }</code> <br>  <code>AssertRange</code> -   ,       <code>AreEqual</code> ,   ,  ,    . <br> <br> <b class="spoiler_title">AssertRange</b> <code class="cpp">namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange</code> <br> <br>         <code>Operator</code>    .          <code>wchar_t</code>   ,         ,      . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', }; typedef Operator Token;</code> <br>    ,   ,        <code>Assert</code> ,    <code>ToString</code> ,    . <br> <br> <b class="spoiler_title">std::wstring ToString(const Token &amp;)</b> <code class="cpp">inline std::wstring ToString(const Token &amp;token) { return{ static_cast&lt;wchar_t&gt;(token) }; }</code> <br> <br>    ,   ,        .  ,   (unconditional ‚Üí if). <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { if(expr.empty()) { return{}; } return{ static_cast&lt;Operator&gt;(expr[0]) }; }</code> <br> <s>         </s> . <s>          .</s>           . ‚Ä¶ <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); }</code> <br>     .   ,     ,   - .    , : <br> <br>        ,      <code>Token</code> .       <code>dynamic_cast</code>    ,   .  ,    ,      .      <code>std::function</code>        .        .  Boost.Any,  - .            . <br>   ,   .      -  .  ,      ,      . <br> <br> ‚Ä¶        .        .        .        . <br>             . <br> <br> <code class="cpp">enum class TokenType { Operator, Number }; class Token { public: Token(Operator) {} TokenType Type() const { return TokenType::Operator; } }; ‚Ä¶ TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } };</code> <br>   <code>ToString</code>   <code>TokenType</code>       ,   ,   .     . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); }</code> <br>   .   (constant ‚Üí scalar)   . <br> <br> <code class="cpp">class Token { public: Token(Operator) :m_type(TokenType::Operator) {} Token(double) :m_type(TokenType::Number) {} TokenType Type() const { return m_type; } private: TokenType m_type; };</code> <br> ‚Ä¶ <s>       </s> . <s>       </s> .        .        . <br>    . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); }</code> <br>            . <br> <br> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} operator Operator() const { return m_operator; } ‚Ä¶ Operator m_operator; };</code> <br>      . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); }</code> <br>          ,  ,       <code>union</code> .         . <br> <br> <b class="spoiler_title">Token</b> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: return "Unknown token."; } }</code> <br> <br>  ,    ,      ,    .       .    . <br> <br> <i>          .</i>               .            .       . <br>        : <br> <br> <code class="cpp"> if(expr[0] &gt;= '0' &amp;&amp; expr[0] &lt;= '9') { return{ (double) expr[0] - '0' }; } return{ static_cast&lt;Operator&gt;(expr[0]) };</code> <br>      ,   . <br> <br> ‚Ä¶ <s>          .</s> <i>              .</i> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); }</code> <br> ,     <code>C</code>   ,  <code>isdigit</code> , ,       <code>atof</code> ,    ,      <code>wchar_t</code> .  (expression ‚Üí function).         . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { const wchar_t *current = expr.c_str(); if(!*current) return{}; if(iswdigit(*current)) return{ _wtof(current) }; return{ static_cast&lt;Operator&gt;(*current) }; }</code> <br>         .      . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>   ,        .  ,     .     .   <code>result</code> ,     . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); if(!*current) return result; if(iswdigit(*current)) { result.push_back(_wtof(current)); } else { result.push_back(static_cast&lt;Operator&gt;(*current)); } return result; }</code> <br>      :   (if ‚Üí while).     ,        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } } return result; }</code> <br>  <code>wcstod</code>    ,   <code>_wtof</code> ,           .           ,              .  ,    . <br> <br> <s>           .</s>       . <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>  (unconditional ‚Üí if)    ,    . <br> <br> <code class="cpp"> while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else if(*current == static_cast&lt;wchar_t&gt;(Operator::Plus)) { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } else { ++current; } }</code> <br>       .          .       <code>Detail</code>      .   <code>Tokenize</code>       . <br> <br> <code class="cpp">inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); }</code> <br> <b class="spoiler_title"> Detail::Tokenizer</b> <code class="cpp">namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { return *m_current == static_cast&lt;wchar_t&gt;(Operator::Plus); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail</code> <br> <br>  ,      .      ,  , .       . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); }</code> <br>      <code>Operator</code> ,    . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', };</code> <br>   .         <code>IsOperator</code>  <code>Tokenizer</code> . <br> <br> <code class="cpp"> bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); }</code> <br>         .        . <br> <br> <b class="spoiler_title">Interpreter.h</b> <code class="cpp">#pragma once; #include &lt;vector&gt; #include &lt;wchar.h&gt; #include &lt;algorithm&gt; namespace Interpreter { enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', }; inline std::wstring ToString(const Operator &amp;op) { return{ static_cast&lt;wchar_t&gt;(op) }; } enum class TokenType { Operator, Number }; inline std::wstring ToString(const TokenType &amp;type) { switch(type) { case TokenType::Operator: return L"Operator"; case TokenType::Number: return L"Number"; default: throw std::out_of_range("TokenType"); } } class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } friend inline bool operator==(const Token &amp;left, const Token &amp;right) { if(left.m_type == right.m_type) { switch(left.m_type) { case Interpreter::TokenType::Operator: return left.m_operator == right.m_operator; case Interpreter::TokenType::Number: return left.m_number == right.m_number; default: throw std::out_of_range("TokenType"); } } return false; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: throw std::out_of_range("TokenType"); } } typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); } } // namespace Lexer } // namespace Interpreter</code> <br> <br> <b class="spoiler_title">InterpreterTests.cpp</b> <code class="cpp">#include "stdafx.h" #include "CppUnitTest.h" #include "Interpreter.h" namespace InterpreterTests { using namespace Microsoft::VisualStudio::CppUnitTestFramework; using namespace Interpreter; using namespace std; namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual&lt;T&gt;(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange TEST_CLASS(LexerTests) { public: TEST_METHOD(Should_return_empty_token_list_when_put_empty_expression) { Tokens tokens = Lexer::Tokenize(L""); Assert::IsTrue(tokens.empty()); } TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); } TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); } TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); } TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); } }; TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); } TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); } TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); } }; }</code> <br> <br> <a href="https://github.com/Unril/InterpreterTDD/releases/tag/%25D0%259A%25D0%25BE%25D0%25BD%25D0%25B5%25D1%2586_%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B2%25D0%25BE%25D0%25B9_%25D1%2587%25D0%25B0%25D1%2581%25D1%2582%25D0%25B8">    GitHub</a> .         ,  .      "__". <br> <br>   <a href="http://habrahabr.ru/post/232081/">    </a> .      ,      <a href="http://habrahabr.ru/post/232097/">    </a> .</code> <ul><li> <code><code>std::vector,      Tokens</code> .            . <br> <br> <code class="cpp">#pragma once; #include &lt;vector&gt; namespace Interpreter { struct Token {}; typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { inline Tokens Tokenize(std::string expr) { throw std::exception(); } } // namespace Lexer } // namespace Interpreter</code> <br>   ,  ,   , .   ,    ,    <a href="http://cleancoder.posterous.com/the-transformation-priority-premise">The Transformation Priority Premise (TPP)</a>   .    , ,    ,     ,        .            .     ,     ,      ,           .  ,  ,   (   )    ,  ,  .     ,  ,         .     ,   TPP          . <br> <br>   : <br> <br> ({} ‚Üí nil)     ,   . (nil ‚Üí constant)    . (constant ‚Üí constant+)      (        ,  ). (constant ‚Üí scalar)    ,  . (statement ‚Üí statements)    (break, continue, return  ). (unconditional ‚Üí if)       . (scalar ‚Üí array)  / . (array ‚Üí container)     . (statement ‚Üí recursion)   . (if ‚Üí while)    . (expression ‚Üí function)   . (variable ‚Üí assignment)   . <br>        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::string expr) { return{}; }</code> <br> ,         .     . <br> <br> <s>         </s> .           .           .               .            .       . <br>  ,  <code>std::string</code>  <code>std::wstring</code> .         ,      Unicode.     . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); }</code> <br>  <code>AssertRange</code> -   ,       <code>AreEqual</code> ,   ,  ,    . <br> <br> <b class="spoiler_title">AssertRange</b> <code class="cpp">namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange</code> <br> <br>         <code>Operator</code>    .          <code>wchar_t</code>   ,         ,      . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', }; typedef Operator Token;</code> <br>    ,   ,        <code>Assert</code> ,    <code>ToString</code> ,    . <br> <br> <b class="spoiler_title">std::wstring ToString(const Token &amp;)</b> <code class="cpp">inline std::wstring ToString(const Token &amp;token) { return{ static_cast&lt;wchar_t&gt;(token) }; }</code> <br> <br>    ,   ,        .  ,   (unconditional ‚Üí if). <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { if(expr.empty()) { return{}; } return{ static_cast&lt;Operator&gt;(expr[0]) }; }</code> <br> <s>         </s> . <s>          .</s>           . ‚Ä¶ <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); }</code> <br>     .   ,     ,   - .    , : <br> <br>        ,      <code>Token</code> .       <code>dynamic_cast</code>    ,   .  ,    ,      .      <code>std::function</code>        .        .  Boost.Any,  - .            . <br>   ,   .      -  .  ,      ,      . <br> <br> ‚Ä¶        .        .        .        . <br>             . <br> <br> <code class="cpp">enum class TokenType { Operator, Number }; class Token { public: Token(Operator) {} TokenType Type() const { return TokenType::Operator; } }; ‚Ä¶ TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } };</code> <br>   <code>ToString</code>   <code>TokenType</code>       ,   ,   .     . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); }</code> <br>   .   (constant ‚Üí scalar)   . <br> <br> <code class="cpp">class Token { public: Token(Operator) :m_type(TokenType::Operator) {} Token(double) :m_type(TokenType::Number) {} TokenType Type() const { return m_type; } private: TokenType m_type; };</code> <br> ‚Ä¶ <s>       </s> . <s>       </s> .        .        . <br>    . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); }</code> <br>            . <br> <br> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} operator Operator() const { return m_operator; } ‚Ä¶ Operator m_operator; };</code> <br>      . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); }</code> <br>          ,  ,       <code>union</code> .         . <br> <br> <b class="spoiler_title">Token</b> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: return "Unknown token."; } }</code> <br> <br>  ,    ,      ,    .       .    . <br> <br> <i>          .</i>               .            .       . <br>        : <br> <br> <code class="cpp"> if(expr[0] &gt;= '0' &amp;&amp; expr[0] &lt;= '9') { return{ (double) expr[0] - '0' }; } return{ static_cast&lt;Operator&gt;(expr[0]) };</code> <br>      ,   . <br> <br> ‚Ä¶ <s>          .</s> <i>              .</i> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); }</code> <br> ,     <code>C</code>   ,  <code>isdigit</code> , ,       <code>atof</code> ,    ,      <code>wchar_t</code> .  (expression ‚Üí function).         . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { const wchar_t *current = expr.c_str(); if(!*current) return{}; if(iswdigit(*current)) return{ _wtof(current) }; return{ static_cast&lt;Operator&gt;(*current) }; }</code> <br>         .      . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>   ,        .  ,     .     .   <code>result</code> ,     . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); if(!*current) return result; if(iswdigit(*current)) { result.push_back(_wtof(current)); } else { result.push_back(static_cast&lt;Operator&gt;(*current)); } return result; }</code> <br>      :   (if ‚Üí while).     ,        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } } return result; }</code> <br>  <code>wcstod</code>    ,   <code>_wtof</code> ,           .           ,              .  ,    . <br> <br> <s>           .</s>       . <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>  (unconditional ‚Üí if)    ,    . <br> <br> <code class="cpp"> while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else if(*current == static_cast&lt;wchar_t&gt;(Operator::Plus)) { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } else { ++current; } }</code> <br>       .          .       <code>Detail</code>      .   <code>Tokenize</code>       . <br> <br> <code class="cpp">inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); }</code> <br> <b class="spoiler_title"> Detail::Tokenizer</b> <code class="cpp">namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { return *m_current == static_cast&lt;wchar_t&gt;(Operator::Plus); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail</code> <br> <br>  ,      .      ,  , .       . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); }</code> <br>      <code>Operator</code> ,    . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', };</code> <br>   .         <code>IsOperator</code>  <code>Tokenizer</code> . <br> <br> <code class="cpp"> bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); }</code> <br>         .        . <br> <br> <b class="spoiler_title">Interpreter.h</b> <code class="cpp">#pragma once; #include &lt;vector&gt; #include &lt;wchar.h&gt; #include &lt;algorithm&gt; namespace Interpreter { enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', }; inline std::wstring ToString(const Operator &amp;op) { return{ static_cast&lt;wchar_t&gt;(op) }; } enum class TokenType { Operator, Number }; inline std::wstring ToString(const TokenType &amp;type) { switch(type) { case TokenType::Operator: return L"Operator"; case TokenType::Number: return L"Number"; default: throw std::out_of_range("TokenType"); } } class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } friend inline bool operator==(const Token &amp;left, const Token &amp;right) { if(left.m_type == right.m_type) { switch(left.m_type) { case Interpreter::TokenType::Operator: return left.m_operator == right.m_operator; case Interpreter::TokenType::Number: return left.m_number == right.m_number; default: throw std::out_of_range("TokenType"); } } return false; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: throw std::out_of_range("TokenType"); } } typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); } } // namespace Lexer } // namespace Interpreter</code> <br> <br> <b class="spoiler_title">InterpreterTests.cpp</b> <code class="cpp">#include "stdafx.h" #include "CppUnitTest.h" #include "Interpreter.h" namespace InterpreterTests { using namespace Microsoft::VisualStudio::CppUnitTestFramework; using namespace Interpreter; using namespace std; namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual&lt;T&gt;(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange TEST_CLASS(LexerTests) { public: TEST_METHOD(Should_return_empty_token_list_when_put_empty_expression) { Tokens tokens = Lexer::Tokenize(L""); Assert::IsTrue(tokens.empty()); } TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); } TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); } TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); } TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); } }; TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); } TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); } TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); } }; }</code> <br> <br> <a href="https://github.com/Unril/InterpreterTDD/releases/tag/%25D0%259A%25D0%25BE%25D0%25BD%25D0%25B5%25D1%2586_%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B2%25D0%25BE%25D0%25B9_%25D1%2587%25D0%25B0%25D1%2581%25D1%2582%25D0%25B8">    GitHub</a> .         ,  .      "__". <br> <br>   <a href="http://habrahabr.ru/post/232081/">    </a> .      ,      <a href="http://habrahabr.ru/post/232097/">    </a> .</code> </li> <li> <code><code>std::vector,      Tokens</code> .            . <br> <br> <code class="cpp">#pragma once; #include &lt;vector&gt; namespace Interpreter { struct Token {}; typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { inline Tokens Tokenize(std::string expr) { throw std::exception(); } } // namespace Lexer } // namespace Interpreter</code> <br>   ,  ,   , .   ,    ,    <a href="http://cleancoder.posterous.com/the-transformation-priority-premise">The Transformation Priority Premise (TPP)</a>   .    , ,    ,     ,        .            .     ,     ,      ,           .  ,  ,   (   )    ,  ,  .     ,  ,         .     ,   TPP          . <br> <br>   : <br> <br> ({} ‚Üí nil)     ,   . (nil ‚Üí constant)    . (constant ‚Üí constant+)      (        ,  ). (constant ‚Üí scalar)    ,  . (statement ‚Üí statements)    (break, continue, return  ). (unconditional ‚Üí if)       . (scalar ‚Üí array)  / . (array ‚Üí container)     . (statement ‚Üí recursion)   . (if ‚Üí while)    . (expression ‚Üí function)   . (variable ‚Üí assignment)   . <br>        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::string expr) { return{}; }</code> <br> ,         .     . <br> <br> <s>         </s> .           .           .               .            .       . <br>  ,  <code>std::string</code>  <code>std::wstring</code> .         ,      Unicode.     . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); }</code> <br>  <code>AssertRange</code> -   ,       <code>AreEqual</code> ,   ,  ,    . <br> <br> <b class="spoiler_title">AssertRange</b> <code class="cpp">namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange</code> <br> <br>         <code>Operator</code>    .          <code>wchar_t</code>   ,         ,      . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', }; typedef Operator Token;</code> <br>    ,   ,        <code>Assert</code> ,    <code>ToString</code> ,    . <br> <br> <b class="spoiler_title">std::wstring ToString(const Token &amp;)</b> <code class="cpp">inline std::wstring ToString(const Token &amp;token) { return{ static_cast&lt;wchar_t&gt;(token) }; }</code> <br> <br>    ,   ,        .  ,   (unconditional ‚Üí if). <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { if(expr.empty()) { return{}; } return{ static_cast&lt;Operator&gt;(expr[0]) }; }</code> <br> <s>         </s> . <s>          .</s>           . ‚Ä¶ <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); }</code> <br>     .   ,     ,   - .    , : <br> <br>        ,      <code>Token</code> .       <code>dynamic_cast</code>    ,   .  ,    ,      .      <code>std::function</code>        .        .  Boost.Any,  - .            . <br>   ,   .      -  .  ,      ,      . <br> <br> ‚Ä¶        .        .        .        . <br>             . <br> <br> <code class="cpp">enum class TokenType { Operator, Number }; class Token { public: Token(Operator) {} TokenType Type() const { return TokenType::Operator; } }; ‚Ä¶ TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } };</code> <br>   <code>ToString</code>   <code>TokenType</code>       ,   ,   .     . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); }</code> <br>   .   (constant ‚Üí scalar)   . <br> <br> <code class="cpp">class Token { public: Token(Operator) :m_type(TokenType::Operator) {} Token(double) :m_type(TokenType::Number) {} TokenType Type() const { return m_type; } private: TokenType m_type; };</code> <br> ‚Ä¶ <s>       </s> . <s>       </s> .        .        . <br>    . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); }</code> <br>            . <br> <br> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} operator Operator() const { return m_operator; } ‚Ä¶ Operator m_operator; };</code> <br>      . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); }</code> <br>          ,  ,       <code>union</code> .         . <br> <br> <b class="spoiler_title">Token</b> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: return "Unknown token."; } }</code> <br> <br>  ,    ,      ,    .       .    . <br> <br> <i>          .</i>               .            .       . <br>        : <br> <br> <code class="cpp"> if(expr[0] &gt;= '0' &amp;&amp; expr[0] &lt;= '9') { return{ (double) expr[0] - '0' }; } return{ static_cast&lt;Operator&gt;(expr[0]) };</code> <br>      ,   . <br> <br> ‚Ä¶ <s>          .</s> <i>              .</i> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); }</code> <br> ,     <code>C</code>   ,  <code>isdigit</code> , ,       <code>atof</code> ,    ,      <code>wchar_t</code> .  (expression ‚Üí function).         . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { const wchar_t *current = expr.c_str(); if(!*current) return{}; if(iswdigit(*current)) return{ _wtof(current) }; return{ static_cast&lt;Operator&gt;(*current) }; }</code> <br>         .      . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>   ,        .  ,     .     .   <code>result</code> ,     . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); if(!*current) return result; if(iswdigit(*current)) { result.push_back(_wtof(current)); } else { result.push_back(static_cast&lt;Operator&gt;(*current)); } return result; }</code> <br>      :   (if ‚Üí while).     ,        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } } return result; }</code> <br>  <code>wcstod</code>    ,   <code>_wtof</code> ,           .           ,              .  ,    . <br> <br> <s>           .</s>       . <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>  (unconditional ‚Üí if)    ,    . <br> <br> <code class="cpp"> while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else if(*current == static_cast&lt;wchar_t&gt;(Operator::Plus)) { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } else { ++current; } }</code> <br>       .          .       <code>Detail</code>      .   <code>Tokenize</code>       . <br> <br> <code class="cpp">inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); }</code> <br> <b class="spoiler_title"> Detail::Tokenizer</b> <code class="cpp">namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { return *m_current == static_cast&lt;wchar_t&gt;(Operator::Plus); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail</code> <br> <br>  ,      .      ,  , .       . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); }</code> <br>      <code>Operator</code> ,    . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', };</code> <br>   .         <code>IsOperator</code>  <code>Tokenizer</code> . <br> <br> <code class="cpp"> bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); }</code> <br>         .        . <br> <br> <b class="spoiler_title">Interpreter.h</b> <code class="cpp">#pragma once; #include &lt;vector&gt; #include &lt;wchar.h&gt; #include &lt;algorithm&gt; namespace Interpreter { enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', }; inline std::wstring ToString(const Operator &amp;op) { return{ static_cast&lt;wchar_t&gt;(op) }; } enum class TokenType { Operator, Number }; inline std::wstring ToString(const TokenType &amp;type) { switch(type) { case TokenType::Operator: return L"Operator"; case TokenType::Number: return L"Number"; default: throw std::out_of_range("TokenType"); } } class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } friend inline bool operator==(const Token &amp;left, const Token &amp;right) { if(left.m_type == right.m_type) { switch(left.m_type) { case Interpreter::TokenType::Operator: return left.m_operator == right.m_operator; case Interpreter::TokenType::Number: return left.m_number == right.m_number; default: throw std::out_of_range("TokenType"); } } return false; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: throw std::out_of_range("TokenType"); } } typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); } } // namespace Lexer } // namespace Interpreter</code> <br> <br> <b class="spoiler_title">InterpreterTests.cpp</b> <code class="cpp">#include "stdafx.h" #include "CppUnitTest.h" #include "Interpreter.h" namespace InterpreterTests { using namespace Microsoft::VisualStudio::CppUnitTestFramework; using namespace Interpreter; using namespace std; namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual&lt;T&gt;(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange TEST_CLASS(LexerTests) { public: TEST_METHOD(Should_return_empty_token_list_when_put_empty_expression) { Tokens tokens = Lexer::Tokenize(L""); Assert::IsTrue(tokens.empty()); } TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); } TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); } TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); } TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); } }; TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); } TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); } TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); } }; }</code> <br> <br> <a href="https://github.com/Unril/InterpreterTDD/releases/tag/%25D0%259A%25D0%25BE%25D0%25BD%25D0%25B5%25D1%2586_%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B2%25D0%25BE%25D0%25B9_%25D1%2587%25D0%25B0%25D1%2581%25D1%2582%25D0%25B8">    GitHub</a> .         ,  .      "__". <br> <br>   <a href="http://habrahabr.ru/post/232081/">    </a> .      ,      <a href="http://habrahabr.ru/post/232097/">    </a> .</code> </li> <li> <code><code>std::vector,      Tokens</code> .            . <br> <br> <code class="cpp">#pragma once; #include &lt;vector&gt; namespace Interpreter { struct Token {}; typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { inline Tokens Tokenize(std::string expr) { throw std::exception(); } } // namespace Lexer } // namespace Interpreter</code> <br>   ,  ,   , .   ,    ,    <a href="http://cleancoder.posterous.com/the-transformation-priority-premise">The Transformation Priority Premise (TPP)</a>   .    , ,    ,     ,        .            .     ,     ,      ,           .  ,  ,   (   )    ,  ,  .     ,  ,         .     ,   TPP          . <br> <br>   : <br> <br> ({} ‚Üí nil)     ,   . (nil ‚Üí constant)    . (constant ‚Üí constant+)      (        ,  ). (constant ‚Üí scalar)    ,  . (statement ‚Üí statements)    (break, continue, return  ). (unconditional ‚Üí if)       . (scalar ‚Üí array)  / . (array ‚Üí container)     . (statement ‚Üí recursion)   . (if ‚Üí while)    . (expression ‚Üí function)   . (variable ‚Üí assignment)   . <br>        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::string expr) { return{}; }</code> <br> ,         .     . <br> <br> <s>         </s> .           .           .               .            .       . <br>  ,  <code>std::string</code>  <code>std::wstring</code> .         ,      Unicode.     . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); }</code> <br>  <code>AssertRange</code> -   ,       <code>AreEqual</code> ,   ,  ,    . <br> <br> <b class="spoiler_title">AssertRange</b> <code class="cpp">namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange</code> <br> <br>         <code>Operator</code>    .          <code>wchar_t</code>   ,         ,      . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', }; typedef Operator Token;</code> <br>    ,   ,        <code>Assert</code> ,    <code>ToString</code> ,    . <br> <br> <b class="spoiler_title">std::wstring ToString(const Token &amp;)</b> <code class="cpp">inline std::wstring ToString(const Token &amp;token) { return{ static_cast&lt;wchar_t&gt;(token) }; }</code> <br> <br>    ,   ,        .  ,   (unconditional ‚Üí if). <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { if(expr.empty()) { return{}; } return{ static_cast&lt;Operator&gt;(expr[0]) }; }</code> <br> <s>         </s> . <s>          .</s>           . ‚Ä¶ <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); }</code> <br>     .   ,     ,   - .    , : <br> <br>        ,      <code>Token</code> .       <code>dynamic_cast</code>    ,   .  ,    ,      .      <code>std::function</code>        .        .  Boost.Any,  - .            . <br>   ,   .      -  .  ,      ,      . <br> <br> ‚Ä¶        .        .        .        . <br>             . <br> <br> <code class="cpp">enum class TokenType { Operator, Number }; class Token { public: Token(Operator) {} TokenType Type() const { return TokenType::Operator; } }; ‚Ä¶ TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } };</code> <br>   <code>ToString</code>   <code>TokenType</code>       ,   ,   .     . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); }</code> <br>   .   (constant ‚Üí scalar)   . <br> <br> <code class="cpp">class Token { public: Token(Operator) :m_type(TokenType::Operator) {} Token(double) :m_type(TokenType::Number) {} TokenType Type() const { return m_type; } private: TokenType m_type; };</code> <br> ‚Ä¶ <s>       </s> . <s>       </s> .        .        . <br>    . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); }</code> <br>            . <br> <br> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} operator Operator() const { return m_operator; } ‚Ä¶ Operator m_operator; };</code> <br>      . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); }</code> <br>          ,  ,       <code>union</code> .         . <br> <br> <b class="spoiler_title">Token</b> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: return "Unknown token."; } }</code> <br> <br>  ,    ,      ,    .       .    . <br> <br> <i>          .</i>               .            .       . <br>        : <br> <br> <code class="cpp"> if(expr[0] &gt;= '0' &amp;&amp; expr[0] &lt;= '9') { return{ (double) expr[0] - '0' }; } return{ static_cast&lt;Operator&gt;(expr[0]) };</code> <br>      ,   . <br> <br> ‚Ä¶ <s>          .</s> <i>              .</i> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); }</code> <br> ,     <code>C</code>   ,  <code>isdigit</code> , ,       <code>atof</code> ,    ,      <code>wchar_t</code> .  (expression ‚Üí function).         . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { const wchar_t *current = expr.c_str(); if(!*current) return{}; if(iswdigit(*current)) return{ _wtof(current) }; return{ static_cast&lt;Operator&gt;(*current) }; }</code> <br>         .      . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>   ,        .  ,     .     .   <code>result</code> ,     . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); if(!*current) return result; if(iswdigit(*current)) { result.push_back(_wtof(current)); } else { result.push_back(static_cast&lt;Operator&gt;(*current)); } return result; }</code> <br>      :   (if ‚Üí while).     ,        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } } return result; }</code> <br>  <code>wcstod</code>    ,   <code>_wtof</code> ,           .           ,              .  ,    . <br> <br> <s>           .</s>       . <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>  (unconditional ‚Üí if)    ,    . <br> <br> <code class="cpp"> while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else if(*current == static_cast&lt;wchar_t&gt;(Operator::Plus)) { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } else { ++current; } }</code> <br>       .          .       <code>Detail</code>      .   <code>Tokenize</code>       . <br> <br> <code class="cpp">inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); }</code> <br> <b class="spoiler_title"> Detail::Tokenizer</b> <code class="cpp">namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { return *m_current == static_cast&lt;wchar_t&gt;(Operator::Plus); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail</code> <br> <br>  ,      .      ,  , .       . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); }</code> <br>      <code>Operator</code> ,    . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', };</code> <br>   .         <code>IsOperator</code>  <code>Tokenizer</code> . <br> <br> <code class="cpp"> bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); }</code> <br>         .        . <br> <br> <b class="spoiler_title">Interpreter.h</b> <code class="cpp">#pragma once; #include &lt;vector&gt; #include &lt;wchar.h&gt; #include &lt;algorithm&gt; namespace Interpreter { enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', }; inline std::wstring ToString(const Operator &amp;op) { return{ static_cast&lt;wchar_t&gt;(op) }; } enum class TokenType { Operator, Number }; inline std::wstring ToString(const TokenType &amp;type) { switch(type) { case TokenType::Operator: return L"Operator"; case TokenType::Number: return L"Number"; default: throw std::out_of_range("TokenType"); } } class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } friend inline bool operator==(const Token &amp;left, const Token &amp;right) { if(left.m_type == right.m_type) { switch(left.m_type) { case Interpreter::TokenType::Operator: return left.m_operator == right.m_operator; case Interpreter::TokenType::Number: return left.m_number == right.m_number; default: throw std::out_of_range("TokenType"); } } return false; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: throw std::out_of_range("TokenType"); } } typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); } } // namespace Lexer } // namespace Interpreter</code> <br> <br> <b class="spoiler_title">InterpreterTests.cpp</b> <code class="cpp">#include "stdafx.h" #include "CppUnitTest.h" #include "Interpreter.h" namespace InterpreterTests { using namespace Microsoft::VisualStudio::CppUnitTestFramework; using namespace Interpreter; using namespace std; namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual&lt;T&gt;(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange TEST_CLASS(LexerTests) { public: TEST_METHOD(Should_return_empty_token_list_when_put_empty_expression) { Tokens tokens = Lexer::Tokenize(L""); Assert::IsTrue(tokens.empty()); } TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); } TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); } TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); } TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); } }; TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); } TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); } TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); } }; }</code> <br> <br> <a href="https://github.com/Unril/InterpreterTDD/releases/tag/%25D0%259A%25D0%25BE%25D0%25BD%25D0%25B5%25D1%2586_%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B2%25D0%25BE%25D0%25B9_%25D1%2587%25D0%25B0%25D1%2581%25D1%2582%25D0%25B8">    GitHub</a> .         ,  .      "__". <br> <br>   <a href="http://habrahabr.ru/post/232081/">    </a> .      ,      <a href="http://habrahabr.ru/post/232097/">    </a> .</code> </li> <li> <code><code>std::vector,      Tokens</code> .            . <br> <br> <code class="cpp">#pragma once; #include &lt;vector&gt; namespace Interpreter { struct Token {}; typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { inline Tokens Tokenize(std::string expr) { throw std::exception(); } } // namespace Lexer } // namespace Interpreter</code> <br>   ,  ,   , .   ,    ,    <a href="http://cleancoder.posterous.com/the-transformation-priority-premise">The Transformation Priority Premise (TPP)</a>   .    , ,    ,     ,        .            .     ,     ,      ,           .  ,  ,   (   )    ,  ,  .     ,  ,         .     ,   TPP          . <br> <br>   : <br> <br> ({} ‚Üí nil)     ,   . (nil ‚Üí constant)    . (constant ‚Üí constant+)      (        ,  ). (constant ‚Üí scalar)    ,  . (statement ‚Üí statements)    (break, continue, return  ). (unconditional ‚Üí if)       . (scalar ‚Üí array)  / . (array ‚Üí container)     . (statement ‚Üí recursion)   . (if ‚Üí while)    . (expression ‚Üí function)   . (variable ‚Üí assignment)   . <br>        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::string expr) { return{}; }</code> <br> ,         .     . <br> <br> <s>         </s> .           .           .               .            .       . <br>  ,  <code>std::string</code>  <code>std::wstring</code> .         ,      Unicode.     . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); }</code> <br>  <code>AssertRange</code> -   ,       <code>AreEqual</code> ,   ,  ,    . <br> <br> <b class="spoiler_title">AssertRange</b> <code class="cpp">namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange</code> <br> <br>         <code>Operator</code>    .          <code>wchar_t</code>   ,         ,      . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', }; typedef Operator Token;</code> <br>    ,   ,        <code>Assert</code> ,    <code>ToString</code> ,    . <br> <br> <b class="spoiler_title">std::wstring ToString(const Token &amp;)</b> <code class="cpp">inline std::wstring ToString(const Token &amp;token) { return{ static_cast&lt;wchar_t&gt;(token) }; }</code> <br> <br>    ,   ,        .  ,   (unconditional ‚Üí if). <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { if(expr.empty()) { return{}; } return{ static_cast&lt;Operator&gt;(expr[0]) }; }</code> <br> <s>         </s> . <s>          .</s>           . ‚Ä¶ <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); }</code> <br>     .   ,     ,   - .    , : <br> <br>        ,      <code>Token</code> .       <code>dynamic_cast</code>    ,   .  ,    ,      .      <code>std::function</code>        .        .  Boost.Any,  - .            . <br>   ,   .      -  .  ,      ,      . <br> <br> ‚Ä¶        .        .        .        . <br>             . <br> <br> <code class="cpp">enum class TokenType { Operator, Number }; class Token { public: Token(Operator) {} TokenType Type() const { return TokenType::Operator; } }; ‚Ä¶ TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } };</code> <br>   <code>ToString</code>   <code>TokenType</code>       ,   ,   .     . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); }</code> <br>   .   (constant ‚Üí scalar)   . <br> <br> <code class="cpp">class Token { public: Token(Operator) :m_type(TokenType::Operator) {} Token(double) :m_type(TokenType::Number) {} TokenType Type() const { return m_type; } private: TokenType m_type; };</code> <br> ‚Ä¶ <s>       </s> . <s>       </s> .        .        . <br>    . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); }</code> <br>            . <br> <br> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} operator Operator() const { return m_operator; } ‚Ä¶ Operator m_operator; };</code> <br>      . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); }</code> <br>          ,  ,       <code>union</code> .         . <br> <br> <b class="spoiler_title">Token</b> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: return "Unknown token."; } }</code> <br> <br>  ,    ,      ,    .       .    . <br> <br> <i>          .</i>               .            .       . <br>        : <br> <br> <code class="cpp"> if(expr[0] &gt;= '0' &amp;&amp; expr[0] &lt;= '9') { return{ (double) expr[0] - '0' }; } return{ static_cast&lt;Operator&gt;(expr[0]) };</code> <br>      ,   . <br> <br> ‚Ä¶ <s>          .</s> <i>              .</i> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); }</code> <br> ,     <code>C</code>   ,  <code>isdigit</code> , ,       <code>atof</code> ,    ,      <code>wchar_t</code> .  (expression ‚Üí function).         . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { const wchar_t *current = expr.c_str(); if(!*current) return{}; if(iswdigit(*current)) return{ _wtof(current) }; return{ static_cast&lt;Operator&gt;(*current) }; }</code> <br>         .      . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>   ,        .  ,     .     .   <code>result</code> ,     . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); if(!*current) return result; if(iswdigit(*current)) { result.push_back(_wtof(current)); } else { result.push_back(static_cast&lt;Operator&gt;(*current)); } return result; }</code> <br>      :   (if ‚Üí while).     ,        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } } return result; }</code> <br>  <code>wcstod</code>    ,   <code>_wtof</code> ,           .           ,              .  ,    . <br> <br> <s>           .</s>       . <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>  (unconditional ‚Üí if)    ,    . <br> <br> <code class="cpp"> while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else if(*current == static_cast&lt;wchar_t&gt;(Operator::Plus)) { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } else { ++current; } }</code> <br>       .          .       <code>Detail</code>      .   <code>Tokenize</code>       . <br> <br> <code class="cpp">inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); }</code> <br> <b class="spoiler_title"> Detail::Tokenizer</b> <code class="cpp">namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { return *m_current == static_cast&lt;wchar_t&gt;(Operator::Plus); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail</code> <br> <br>  ,      .      ,  , .       . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); }</code> <br>      <code>Operator</code> ,    . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', };</code> <br>   .         <code>IsOperator</code>  <code>Tokenizer</code> . <br> <br> <code class="cpp"> bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); }</code> <br>         .        . <br> <br> <b class="spoiler_title">Interpreter.h</b> <code class="cpp">#pragma once; #include &lt;vector&gt; #include &lt;wchar.h&gt; #include &lt;algorithm&gt; namespace Interpreter { enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', }; inline std::wstring ToString(const Operator &amp;op) { return{ static_cast&lt;wchar_t&gt;(op) }; } enum class TokenType { Operator, Number }; inline std::wstring ToString(const TokenType &amp;type) { switch(type) { case TokenType::Operator: return L"Operator"; case TokenType::Number: return L"Number"; default: throw std::out_of_range("TokenType"); } } class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } friend inline bool operator==(const Token &amp;left, const Token &amp;right) { if(left.m_type == right.m_type) { switch(left.m_type) { case Interpreter::TokenType::Operator: return left.m_operator == right.m_operator; case Interpreter::TokenType::Number: return left.m_number == right.m_number; default: throw std::out_of_range("TokenType"); } } return false; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: throw std::out_of_range("TokenType"); } } typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); } } // namespace Lexer } // namespace Interpreter</code> <br> <br> <b class="spoiler_title">InterpreterTests.cpp</b> <code class="cpp">#include "stdafx.h" #include "CppUnitTest.h" #include "Interpreter.h" namespace InterpreterTests { using namespace Microsoft::VisualStudio::CppUnitTestFramework; using namespace Interpreter; using namespace std; namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual&lt;T&gt;(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange TEST_CLASS(LexerTests) { public: TEST_METHOD(Should_return_empty_token_list_when_put_empty_expression) { Tokens tokens = Lexer::Tokenize(L""); Assert::IsTrue(tokens.empty()); } TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); } TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); } TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); } TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); } }; TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); } TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); } TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); } }; }</code> <br> <br> <a href="https://github.com/Unril/InterpreterTDD/releases/tag/%25D0%259A%25D0%25BE%25D0%25BD%25D0%25B5%25D1%2586_%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B2%25D0%25BE%25D0%25B9_%25D1%2587%25D0%25B0%25D1%2581%25D1%2582%25D0%25B8">    GitHub</a> .         ,  .      "__". <br> <br>   <a href="http://habrahabr.ru/post/232081/">    </a> .      ,      <a href="http://habrahabr.ru/post/232097/">    </a> .</code> </li> <li> <code><code>std::vector,      Tokens</code> .            . <br> <br> <code class="cpp">#pragma once; #include &lt;vector&gt; namespace Interpreter { struct Token {}; typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { inline Tokens Tokenize(std::string expr) { throw std::exception(); } } // namespace Lexer } // namespace Interpreter</code> <br>   ,  ,   , .   ,    ,    <a href="http://cleancoder.posterous.com/the-transformation-priority-premise">The Transformation Priority Premise (TPP)</a>   .    , ,    ,     ,        .            .     ,     ,      ,           .  ,  ,   (   )    ,  ,  .     ,  ,         .     ,   TPP          . <br> <br>   : <br> <br> ({} ‚Üí nil)     ,   . (nil ‚Üí constant)    . (constant ‚Üí constant+)      (        ,  ). (constant ‚Üí scalar)    ,  . (statement ‚Üí statements)    (break, continue, return  ). (unconditional ‚Üí if)       . (scalar ‚Üí array)  / . (array ‚Üí container)     . (statement ‚Üí recursion)   . (if ‚Üí while)    . (expression ‚Üí function)   . (variable ‚Üí assignment)   . <br>        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::string expr) { return{}; }</code> <br> ,         .     . <br> <br> <s>         </s> .           .           .               .            .       . <br>  ,  <code>std::string</code>  <code>std::wstring</code> .         ,      Unicode.     . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); }</code> <br>  <code>AssertRange</code> -   ,       <code>AreEqual</code> ,   ,  ,    . <br> <br> <b class="spoiler_title">AssertRange</b> <code class="cpp">namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange</code> <br> <br>         <code>Operator</code>    .          <code>wchar_t</code>   ,         ,      . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', }; typedef Operator Token;</code> <br>    ,   ,        <code>Assert</code> ,    <code>ToString</code> ,    . <br> <br> <b class="spoiler_title">std::wstring ToString(const Token &amp;)</b> <code class="cpp">inline std::wstring ToString(const Token &amp;token) { return{ static_cast&lt;wchar_t&gt;(token) }; }</code> <br> <br>    ,   ,        .  ,   (unconditional ‚Üí if). <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { if(expr.empty()) { return{}; } return{ static_cast&lt;Operator&gt;(expr[0]) }; }</code> <br> <s>         </s> . <s>          .</s>           . ‚Ä¶ <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); }</code> <br>     .   ,     ,   - .    , : <br> <br>        ,      <code>Token</code> .       <code>dynamic_cast</code>    ,   .  ,    ,      .      <code>std::function</code>        .        .  Boost.Any,  - .            . <br>   ,   .      -  .  ,      ,      . <br> <br> ‚Ä¶        .        .        .        . <br>             . <br> <br> <code class="cpp">enum class TokenType { Operator, Number }; class Token { public: Token(Operator) {} TokenType Type() const { return TokenType::Operator; } }; ‚Ä¶ TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } };</code> <br>   <code>ToString</code>   <code>TokenType</code>       ,   ,   .     . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); }</code> <br>   .   (constant ‚Üí scalar)   . <br> <br> <code class="cpp">class Token { public: Token(Operator) :m_type(TokenType::Operator) {} Token(double) :m_type(TokenType::Number) {} TokenType Type() const { return m_type; } private: TokenType m_type; };</code> <br> ‚Ä¶ <s>       </s> . <s>       </s> .        .        . <br>    . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); }</code> <br>            . <br> <br> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} operator Operator() const { return m_operator; } ‚Ä¶ Operator m_operator; };</code> <br>      . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); }</code> <br>          ,  ,       <code>union</code> .         . <br> <br> <b class="spoiler_title">Token</b> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: return "Unknown token."; } }</code> <br> <br>  ,    ,      ,    .       .    . <br> <br> <i>          .</i>               .            .       . <br>        : <br> <br> <code class="cpp"> if(expr[0] &gt;= '0' &amp;&amp; expr[0] &lt;= '9') { return{ (double) expr[0] - '0' }; } return{ static_cast&lt;Operator&gt;(expr[0]) };</code> <br>      ,   . <br> <br> ‚Ä¶ <s>          .</s> <i>              .</i> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); }</code> <br> ,     <code>C</code>   ,  <code>isdigit</code> , ,       <code>atof</code> ,    ,      <code>wchar_t</code> .  (expression ‚Üí function).         . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { const wchar_t *current = expr.c_str(); if(!*current) return{}; if(iswdigit(*current)) return{ _wtof(current) }; return{ static_cast&lt;Operator&gt;(*current) }; }</code> <br>         .      . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>   ,        .  ,     .     .   <code>result</code> ,     . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); if(!*current) return result; if(iswdigit(*current)) { result.push_back(_wtof(current)); } else { result.push_back(static_cast&lt;Operator&gt;(*current)); } return result; }</code> <br>      :   (if ‚Üí while).     ,        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } } return result; }</code> <br>  <code>wcstod</code>    ,   <code>_wtof</code> ,           .           ,              .  ,    . <br> <br> <s>           .</s>       . <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>  (unconditional ‚Üí if)    ,    . <br> <br> <code class="cpp"> while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else if(*current == static_cast&lt;wchar_t&gt;(Operator::Plus)) { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } else { ++current; } }</code> <br>       .          .       <code>Detail</code>      .   <code>Tokenize</code>       . <br> <br> <code class="cpp">inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); }</code> <br> <b class="spoiler_title"> Detail::Tokenizer</b> <code class="cpp">namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { return *m_current == static_cast&lt;wchar_t&gt;(Operator::Plus); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail</code> <br> <br>  ,      .      ,  , .       . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); }</code> <br>      <code>Operator</code> ,    . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', };</code> <br>   .         <code>IsOperator</code>  <code>Tokenizer</code> . <br> <br> <code class="cpp"> bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); }</code> <br>         .        . <br> <br> <b class="spoiler_title">Interpreter.h</b> <code class="cpp">#pragma once; #include &lt;vector&gt; #include &lt;wchar.h&gt; #include &lt;algorithm&gt; namespace Interpreter { enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', }; inline std::wstring ToString(const Operator &amp;op) { return{ static_cast&lt;wchar_t&gt;(op) }; } enum class TokenType { Operator, Number }; inline std::wstring ToString(const TokenType &amp;type) { switch(type) { case TokenType::Operator: return L"Operator"; case TokenType::Number: return L"Number"; default: throw std::out_of_range("TokenType"); } } class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } friend inline bool operator==(const Token &amp;left, const Token &amp;right) { if(left.m_type == right.m_type) { switch(left.m_type) { case Interpreter::TokenType::Operator: return left.m_operator == right.m_operator; case Interpreter::TokenType::Number: return left.m_number == right.m_number; default: throw std::out_of_range("TokenType"); } } return false; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: throw std::out_of_range("TokenType"); } } typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); } } // namespace Lexer } // namespace Interpreter</code> <br> <br> <b class="spoiler_title">InterpreterTests.cpp</b> <code class="cpp">#include "stdafx.h" #include "CppUnitTest.h" #include "Interpreter.h" namespace InterpreterTests { using namespace Microsoft::VisualStudio::CppUnitTestFramework; using namespace Interpreter; using namespace std; namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual&lt;T&gt;(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange TEST_CLASS(LexerTests) { public: TEST_METHOD(Should_return_empty_token_list_when_put_empty_expression) { Tokens tokens = Lexer::Tokenize(L""); Assert::IsTrue(tokens.empty()); } TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); } TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); } TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); } TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); } }; TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); } TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); } TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); } }; }</code> <br> <br> <a href="https://github.com/Unril/InterpreterTDD/releases/tag/%25D0%259A%25D0%25BE%25D0%25BD%25D0%25B5%25D1%2586_%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B2%25D0%25BE%25D0%25B9_%25D1%2587%25D0%25B0%25D1%2581%25D1%2582%25D0%25B8">    GitHub</a> .         ,  .      "__". <br> <br>   <a href="http://habrahabr.ru/post/232081/">    </a> .      ,      <a href="http://habrahabr.ru/post/232097/">    </a> .</code> </li> </ul> <code><code>std::vector,      Tokens</code> .            . <br> <br> <code class="cpp">#pragma once; #include &lt;vector&gt; namespace Interpreter { struct Token {}; typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { inline Tokens Tokenize(std::string expr) { throw std::exception(); } } // namespace Lexer } // namespace Interpreter</code> <br>   ,  ,   , .   ,    ,    <a href="http://cleancoder.posterous.com/the-transformation-priority-premise">The Transformation Priority Premise (TPP)</a>   .    , ,    ,     ,        .            .     ,     ,      ,           .  ,  ,   (   )    ,  ,  .     ,  ,         .     ,   TPP          . <br> <br>   : <br> <br> ({} ‚Üí nil)     ,   . (nil ‚Üí constant)    . (constant ‚Üí constant+)      (        ,  ). (constant ‚Üí scalar)    ,  . (statement ‚Üí statements)    (break, continue, return  ). (unconditional ‚Üí if)       . (scalar ‚Üí array)  / . (array ‚Üí container)     . (statement ‚Üí recursion)   . (if ‚Üí while)    . (expression ‚Üí function)   . (variable ‚Üí assignment)   . <br>        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::string expr) { return{}; }</code> <br> ,         .     . <br> <br> <s>         </s> .           .           .               .            .       . <br>  ,  <code>std::string</code>  <code>std::wstring</code> .         ,      Unicode.     . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); }</code> <br>  <code>AssertRange</code> -   ,       <code>AreEqual</code> ,   ,  ,    . <br> <br> <b class="spoiler_title">AssertRange</b> <code class="cpp">namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange</code> <br> <br>         <code>Operator</code>    .          <code>wchar_t</code>   ,         ,      . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', }; typedef Operator Token;</code> <br>    ,   ,        <code>Assert</code> ,    <code>ToString</code> ,    . <br> <br> <b class="spoiler_title">std::wstring ToString(const Token &amp;)</b> <code class="cpp">inline std::wstring ToString(const Token &amp;token) { return{ static_cast&lt;wchar_t&gt;(token) }; }</code> <br> <br>    ,   ,        .  ,   (unconditional ‚Üí if). <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { if(expr.empty()) { return{}; } return{ static_cast&lt;Operator&gt;(expr[0]) }; }</code> <br> <s>         </s> . <s>          .</s>           . ‚Ä¶ <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); }</code> <br>     .   ,     ,   - .    , : <br> <br>        ,      <code>Token</code> .       <code>dynamic_cast</code>    ,   .  ,    ,      .      <code>std::function</code>        .        .  Boost.Any,  - .            . <br>   ,   .      -  .  ,      ,      . <br> <br> ‚Ä¶        .        .        .        . <br>             . <br> <br> <code class="cpp">enum class TokenType { Operator, Number }; class Token { public: Token(Operator) {} TokenType Type() const { return TokenType::Operator; } }; ‚Ä¶ TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } };</code> <br>   <code>ToString</code>   <code>TokenType</code>       ,   ,   .     . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); }</code> <br>   .   (constant ‚Üí scalar)   . <br> <br> <code class="cpp">class Token { public: Token(Operator) :m_type(TokenType::Operator) {} Token(double) :m_type(TokenType::Number) {} TokenType Type() const { return m_type; } private: TokenType m_type; };</code> <br> ‚Ä¶ <s>       </s> . <s>       </s> .        .        . <br>    . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); }</code> <br>            . <br> <br> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} operator Operator() const { return m_operator; } ‚Ä¶ Operator m_operator; };</code> <br>      . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); }</code> <br>          ,  ,       <code>union</code> .         . <br> <br> <b class="spoiler_title">Token</b> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: return "Unknown token."; } }</code> <br> <br>  ,    ,      ,    .       .    . <br> <br> <i>          .</i>               .            .       . <br>        : <br> <br> <code class="cpp"> if(expr[0] &gt;= '0' &amp;&amp; expr[0] &lt;= '9') { return{ (double) expr[0] - '0' }; } return{ static_cast&lt;Operator&gt;(expr[0]) };</code> <br>      ,   . <br> <br> ‚Ä¶ <s>          .</s> <i>              .</i> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); }</code> <br> ,     <code>C</code>   ,  <code>isdigit</code> , ,       <code>atof</code> ,    ,      <code>wchar_t</code> .  (expression ‚Üí function).         . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { const wchar_t *current = expr.c_str(); if(!*current) return{}; if(iswdigit(*current)) return{ _wtof(current) }; return{ static_cast&lt;Operator&gt;(*current) }; }</code> <br>         .      . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>   ,        .  ,     .     .   <code>result</code> ,     . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); if(!*current) return result; if(iswdigit(*current)) { result.push_back(_wtof(current)); } else { result.push_back(static_cast&lt;Operator&gt;(*current)); } return result; }</code> <br>      :   (if ‚Üí while).     ,        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } } return result; }</code> <br>  <code>wcstod</code>    ,   <code>_wtof</code> ,           .           ,              .  ,    . <br> <br> <s>           .</s>       . <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>  (unconditional ‚Üí if)    ,    . <br> <br> <code class="cpp"> while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else if(*current == static_cast&lt;wchar_t&gt;(Operator::Plus)) { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } else { ++current; } }</code> <br>       .          .       <code>Detail</code>      .   <code>Tokenize</code>       . <br> <br> <code class="cpp">inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); }</code> <br> <b class="spoiler_title"> Detail::Tokenizer</b> <code class="cpp">namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { return *m_current == static_cast&lt;wchar_t&gt;(Operator::Plus); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail</code> <br> <br>  ,      .      ,  , .       . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); }</code> <br>      <code>Operator</code> ,    . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', };</code> <br>   .         <code>IsOperator</code>  <code>Tokenizer</code> . <br> <br> <code class="cpp"> bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); }</code> <br>         .        . <br> <br> <b class="spoiler_title">Interpreter.h</b> <code class="cpp">#pragma once; #include &lt;vector&gt; #include &lt;wchar.h&gt; #include &lt;algorithm&gt; namespace Interpreter { enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', }; inline std::wstring ToString(const Operator &amp;op) { return{ static_cast&lt;wchar_t&gt;(op) }; } enum class TokenType { Operator, Number }; inline std::wstring ToString(const TokenType &amp;type) { switch(type) { case TokenType::Operator: return L"Operator"; case TokenType::Number: return L"Number"; default: throw std::out_of_range("TokenType"); } } class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } friend inline bool operator==(const Token &amp;left, const Token &amp;right) { if(left.m_type == right.m_type) { switch(left.m_type) { case Interpreter::TokenType::Operator: return left.m_operator == right.m_operator; case Interpreter::TokenType::Number: return left.m_number == right.m_number; default: throw std::out_of_range("TokenType"); } } return false; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: throw std::out_of_range("TokenType"); } } typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); } } // namespace Lexer } // namespace Interpreter</code> <br> <br> <b class="spoiler_title">InterpreterTests.cpp</b> <code class="cpp">#include "stdafx.h" #include "CppUnitTest.h" #include "Interpreter.h" namespace InterpreterTests { using namespace Microsoft::VisualStudio::CppUnitTestFramework; using namespace Interpreter; using namespace std; namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual&lt;T&gt;(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange TEST_CLASS(LexerTests) { public: TEST_METHOD(Should_return_empty_token_list_when_put_empty_expression) { Tokens tokens = Lexer::Tokenize(L""); Assert::IsTrue(tokens.empty()); } TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); } TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); } TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); } TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); } }; TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); } TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); } TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); } }; }</code> <br> <br> <a href="https://github.com/Unril/InterpreterTDD/releases/tag/%25D0%259A%25D0%25BE%25D0%25BD%25D0%25B5%25D1%2586_%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B2%25D0%25BE%25D0%25B9_%25D1%2587%25D0%25B0%25D1%2581%25D1%2582%25D0%25B8">    GitHub</a> .         ,  .      "__". <br> <br>   <a href="http://habrahabr.ru/post/232081/">    </a> .      ,      <a href="http://habrahabr.ru/post/232097/">    </a> .</code> <pre> <code class="hljs lua"><code>std::vector,      Tokens</code> .            . <br> <br> <code class="cpp">#pragma once; #include &lt;vector&gt; namespace Interpreter { struct Token {}; typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { inline Tokens Tokenize(std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> expr) { throw std::exception(); } } // namespace Lexer } // namespace Interpreter</code> <br>   ,  ,   , .   ,    ,    <a href="http://cleancoder.posterous.com/the-transformation-priority-premise">The Transformation Priority Premise (TPP)</a>   .    , ,    ,     ,        .            .     ,     ,      ,           .  ,  ,   (   )    ,  ,  .     ,  ,         .     ,   TPP          . <br> <br>   : <br> <br> ({} ‚Üí <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)     ,   . (<span class="hljs-literal"><span class="hljs-literal">nil</span></span> ‚Üí constant)    . (constant ‚Üí constant+)      (        ,  ). (constant ‚Üí scalar)    ,  . (statement ‚Üí statements)    (<span class="hljs-keyword"><span class="hljs-keyword">break</span></span>, continue, <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>  ). (unconditional ‚Üí <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>)       . (scalar ‚Üí array)  / . (array ‚Üí container)     . (statement ‚Üí recursion)   . (<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ‚Üí <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>)    . (expression ‚Üí <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">)</span></span>   . (variable ‚Üí assignment)   . <br>        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> expr) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{}; }</code> <br> ,         .     . <br> <br> <s>         </s> .           .           .               .            .       . <br>  ,  <code>std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span></code>  <code>std::wstring</code> .         ,      Unicode.     . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"+"</span></span>); AssertRange::AreEqual({ Operator::Plus }, tokens); }</code> <br>  <code>AssertRange</code> -   ,       <code>AreEqual</code> ,   ,  ,    . <br> <br> <b class="spoiler_title">AssertRange</b> <code class="cpp">namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(expect)), distance(actualIter, <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(actual)), L<span class="hljs-string"><span class="hljs-string">"Size differs."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(; expectIter != <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(expect) &amp;&amp; actualIter != <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(actual); ++expectIter, ++actualIter) { auto message = L<span class="hljs-string"><span class="hljs-string">"Mismatch in position "</span></span> + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange</code> <br> <br>         <code>Operator</code>    .          <code>wchar_t</code>   ,         ,      . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L<span class="hljs-string"><span class="hljs-string">'+'</span></span>, }; typedef Operator Token;</code> <br>    ,   ,        <code>Assert</code> ,    <code>ToString</code> ,    . <br> <br> <b class="spoiler_title">std::wstring ToString(const Token &amp;)</b> <code class="cpp">inline std::wstring ToString(const Token &amp;token) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ static_cast&lt;wchar_t&gt;(token) }; }</code> <br> <br>    ,   ,        .  ,   (unconditional ‚Üí <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>). <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(expr.empty()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{}; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ static_cast&lt;Operator&gt;(expr[<span class="hljs-number"><span class="hljs-number">0</span></span>]) }; }</code> <br> <s>         </s> . <s>          .</s>           . ‚Ä¶ <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"1"</span></span>); AssertRange::AreEqual({ <span class="hljs-number"><span class="hljs-number">1.0</span></span> }, tokens); }</code> <br>     .   ,     ,   - .    , : <br> <br>        ,      <code>Token</code> .       <code>dynamic_cast</code>    ,   .  ,    ,      .      <code>std::<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span></span></code><span class="hljs-function"><span class="hljs-function">        .        .  </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Boost.Any</span></span></span><span class="hljs-function">,  - .            . </span></span><br><span class="hljs-function"><span class="hljs-function">   ,   .      -  .  ,      ,      . </span></span><br><span class="hljs-function"><span class="hljs-function"> </span></span><br><span class="hljs-function"><span class="hljs-function"> ‚Ä¶        .        .        .        . </span></span><br><span class="hljs-function"><span class="hljs-function">             . </span></span><br><span class="hljs-function"><span class="hljs-function"> </span></span><br><span class="hljs-function"><span class="hljs-function"> </span></span><code class="cpp"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">enum</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">class</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TokenType</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Operator</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Number</span></span></span><span class="hljs-function"> }; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">class</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Token</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">public</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Token</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Operator)</span></span></span></span> {} TokenType Type() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TokenType::Operator; } }; ‚Ä¶ TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } };</code> <br>   <code>ToString</code>   <code>TokenType</code>       ,   ,   .     . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_type_for_number_token) { Token numToken(<span class="hljs-number"><span class="hljs-number">1.2</span></span>); Assert::AreEqual(TokenType::Number, numToken.Type()); }</code> <br>   .   (constant ‚Üí scalar)   . <br> <br> <code class="cpp">class Token { public: Token(Operator) :m_type(TokenType::Operator) {} Token(double) :m_type(TokenType::Number) {} TokenType Type() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_type; } private: TokenType m_type; };</code> <br> ‚Ä¶ <s>       </s> . <s>       </s> .        .        . <br>    . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); }</code> <br>            . <br> <br> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} operator Operator() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_operator; } ‚Ä¶ Operator m_operator; };</code> <br>      . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_number_value_from_number_token) { Token token(<span class="hljs-number"><span class="hljs-number">1.23</span></span>); Assert::AreEqual&lt;double&gt;(<span class="hljs-number"><span class="hljs-number">1.23</span></span>, token); }</code> <br>          ,  ,       <code>union</code> .         . <br> <br> <b class="spoiler_title">Token</b> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_type; } operator Operator() const { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(m_type != TokenType::Operator) throw std::logic_error(<span class="hljs-string"><span class="hljs-string">"Should be operator token."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_operator; } operator double() const { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(m_type != TokenType::Number) throw std::logic_error(<span class="hljs-string"><span class="hljs-string">"Should be number token."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_number; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ToString(static_cast&lt;Operator&gt;(token)); default: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Unknown token."</span></span>; } }</code> <br> <br>  ,    ,      ,    .       .    . <br> <br> <i>          .</i>               .            .       . <br>        : <br> <br> <code class="cpp"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(expr[<span class="hljs-number"><span class="hljs-number">0</span></span>] &gt;= <span class="hljs-string"><span class="hljs-string">'0'</span></span> &amp;&amp; expr[<span class="hljs-number"><span class="hljs-number">0</span></span>] &lt;= <span class="hljs-string"><span class="hljs-string">'9'</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ (double) expr[<span class="hljs-number"><span class="hljs-number">0</span></span>] - <span class="hljs-string"><span class="hljs-string">'0'</span></span> }; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ static_cast&lt;Operator&gt;(expr[<span class="hljs-number"><span class="hljs-number">0</span></span>]) };</code> <br>      ,   . <br> <br> ‚Ä¶ <s>          .</s> <i>              .</i> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"12.34"</span></span>); AssertRange::AreEqual({ <span class="hljs-number"><span class="hljs-number">12.34</span></span> }, tokens); }</code> <br> ,     <code>C</code>   ,  <code>isdigit</code> , ,       <code>atof</code> ,    ,      <code>wchar_t</code> .  (expression ‚Üí <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">)</span></span>.         . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { const wchar_t *current = expr.c_str(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!*current) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{}; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(iswdigit(*current)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ _wtof(current) }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ static_cast&lt;Operator&gt;(*current) }; }</code> <br>         .      . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"+12.34"</span></span>); AssertRange::AreEqual({ Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">12.34</span></span>) }, tokens); }</code> <br>   ,        .  ,     .     .   <code>result</code> ,     . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!*current) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(iswdigit(*current)) { result.push_back(_wtof(current)); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { result.push_back(static_cast&lt;Operator&gt;(*current)); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> <br>      :   (<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ‚Üí <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>).     ,        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(*current) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(iswdigit(*current)) { wchar_t *<span class="hljs-keyword"><span class="hljs-keyword">end</span></span> = nullptr; result.push_back(wcstod(current, &amp;<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>)); current = <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> <br>  <code>wcstod</code>    ,   <code>_wtof</code> ,           .           ,              .  ,    . <br> <br> <s>           .</s>       . <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">" 1 + 12.34 "</span></span>); AssertRange::AreEqual({ Token(<span class="hljs-number"><span class="hljs-number">1.0</span></span>), Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">12.34</span></span>) }, tokens); }</code> <br>  (unconditional ‚Üí <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>)    ,    . <br> <br> <code class="cpp"> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(*current) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(iswdigit(*current)) { wchar_t *<span class="hljs-keyword"><span class="hljs-keyword">end</span></span> = nullptr; result.push_back(wcstod(current, &amp;<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>)); current = <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(*current == static_cast&lt;wchar_t&gt;(Operator::Plus)) { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { ++current; } }</code> <br>       .          .       <code>Detail</code>      .   <code>Tokenize</code>       . <br> <br> <code class="cpp">inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tokenizer.Result(); }</code> <br> <b class="spoiler_title"> Detail::Tokenizer</b> <code class="cpp">namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!EndOfExperssion()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(IsNumber()) { ScanNumber(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(IsOperator()) { ScanOperator(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { MoveNext(); } } } const Tokens &amp;Result() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_result; } private: bool EndOfExperssion() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_current == L<span class="hljs-string"><span class="hljs-string">'\0'</span></span>; } bool IsNumber() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> iswdigit(*m_current) != <span class="hljs-number"><span class="hljs-number">0</span></span>; } void ScanNumber() { wchar_t *<span class="hljs-keyword"><span class="hljs-keyword">end</span></span> = nullptr; m_result.push_back(wcstod(m_current, &amp;<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>)); m_current = <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; } bool IsOperator() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_current == static_cast&lt;wchar_t&gt;(Operator::Plus); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail</code> <br> <br>  ,      .      ,  , .       . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"1+2*3/(4-5)"</span></span>); AssertRange::AreEqual({ Token(<span class="hljs-number"><span class="hljs-number">1</span></span>), Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">2</span></span>), Token(Operator::Mul), Token(<span class="hljs-number"><span class="hljs-number">3</span></span>), Token(Operator::Div), Token(Operator::LParen), Token(<span class="hljs-number"><span class="hljs-number">4</span></span>), Token(Operator::Minus), Token(<span class="hljs-number"><span class="hljs-number">5</span></span>), Token(Operator::RParen) }, tokens); }</code> <br>      <code>Operator</code> ,    . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L<span class="hljs-string"><span class="hljs-string">'+'</span></span>, Minus = L<span class="hljs-string"><span class="hljs-string">'-'</span></span>, Mul = L<span class="hljs-string"><span class="hljs-string">'*'</span></span>, Div = L<span class="hljs-string"><span class="hljs-string">'/'</span></span>, LParen = L<span class="hljs-string"><span class="hljs-string">'('</span></span>, RParen = L<span class="hljs-string"><span class="hljs-string">')'</span></span>, };</code> <br>   .         <code>IsOperator</code>  <code>Tokenizer</code> . <br> <br> <code class="cpp"> bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> std::any_of(all.begin(), all.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(), [this](Operator o) {<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_current == static_cast&lt;wchar_t&gt;(o); }); }</code> <br>         .        . <br> <br> <b class="spoiler_title">Interpreter.h</b> <code class="cpp">#pragma once; #include &lt;vector&gt; #include &lt;wchar.h&gt; #include &lt;algorithm&gt; namespace Interpreter { enum class Operator : wchar_t { Plus = L<span class="hljs-string"><span class="hljs-string">'+'</span></span>, Minus = L<span class="hljs-string"><span class="hljs-string">'-'</span></span>, Mul = L<span class="hljs-string"><span class="hljs-string">'*'</span></span>, Div = L<span class="hljs-string"><span class="hljs-string">'/'</span></span>, LParen = L<span class="hljs-string"><span class="hljs-string">'('</span></span>, RParen = L<span class="hljs-string"><span class="hljs-string">')'</span></span>, }; inline std::wstring ToString(const Operator &amp;op) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ static_cast&lt;wchar_t&gt;(op) }; } enum class TokenType { Operator, Number }; inline std::wstring ToString(const TokenType &amp;<span class="hljs-built_in"><span class="hljs-built_in">type</span></span>) { switch(<span class="hljs-built_in"><span class="hljs-built_in">type</span></span>) { case TokenType::Operator: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> L<span class="hljs-string"><span class="hljs-string">"Operator"</span></span>; case TokenType::Number: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> L<span class="hljs-string"><span class="hljs-string">"Number"</span></span>; default: throw std::out_of_range(<span class="hljs-string"><span class="hljs-string">"TokenType"</span></span>); } } class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_type; } operator Operator() const { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(m_type != TokenType::Operator) throw std::logic_error(<span class="hljs-string"><span class="hljs-string">"Should be operator token."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_operator; } operator double() const { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(m_type != TokenType::Number) throw std::logic_error(<span class="hljs-string"><span class="hljs-string">"Should be number token."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_number; } friend inline bool operator==(const Token &amp;left, const Token &amp;right) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(left.m_type == right.m_type) { switch(left.m_type) { case Interpreter::TokenType::Operator: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> left.m_operator == right.m_operator; case Interpreter::TokenType::Number: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> left.m_number == right.m_number; default: throw std::out_of_range(<span class="hljs-string"><span class="hljs-string">"TokenType"</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ToString(static_cast&lt;Operator&gt;(token)); default: throw std::out_of_range(<span class="hljs-string"><span class="hljs-string">"TokenType"</span></span>); } } typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!EndOfExperssion()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(IsNumber()) { ScanNumber(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(IsOperator()) { ScanOperator(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { MoveNext(); } } } const Tokens &amp;Result() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_result; } private: bool EndOfExperssion() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_current == L<span class="hljs-string"><span class="hljs-string">'\0'</span></span>; } bool IsNumber() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> iswdigit(*m_current) != <span class="hljs-number"><span class="hljs-number">0</span></span>; } void ScanNumber() { wchar_t *<span class="hljs-keyword"><span class="hljs-keyword">end</span></span> = nullptr; m_result.push_back(wcstod(m_current, &amp;<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>)); m_current = <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; } bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> std::any_of(all.begin(), all.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(), [this](Operator o) {<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_current == static_cast&lt;wchar_t&gt;(o); }); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tokenizer.Result(); } } // namespace Lexer } // namespace Interpreter</code> <br> <br> <b class="spoiler_title">InterpreterTests.cpp</b> <code class="cpp">#include <span class="hljs-string"><span class="hljs-string">"stdafx.h"</span></span> #include <span class="hljs-string"><span class="hljs-string">"CppUnitTest.h"</span></span> #include <span class="hljs-string"><span class="hljs-string">"Interpreter.h"</span></span> namespace InterpreterTests { using namespace Microsoft::VisualStudio::CppUnitTestFramework; using namespace Interpreter; using namespace std; namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(expect)), distance(actualIter, <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(actual)), L<span class="hljs-string"><span class="hljs-string">"Size differs."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(; expectIter != <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(expect) &amp;&amp; actualIter != <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(actual); ++expectIter, ++actualIter) { auto message = L<span class="hljs-string"><span class="hljs-string">"Mismatch in position "</span></span> + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual&lt;T&gt;(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange TEST_CLASS(LexerTests) { public: TEST_METHOD(Should_return_empty_token_list_when_put_empty_expression) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">""</span></span>); Assert::IsTrue(tokens.empty()); } TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"+"</span></span>); AssertRange::AreEqual({ Operator::Plus }, tokens); } TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"1"</span></span>); AssertRange::AreEqual({ <span class="hljs-number"><span class="hljs-number">1.0</span></span> }, tokens); } TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"12.34"</span></span>); AssertRange::AreEqual({ <span class="hljs-number"><span class="hljs-number">12.34</span></span> }, tokens); } TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"+12.34"</span></span>); AssertRange::AreEqual({ Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">12.34</span></span>) }, tokens); } TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">" 1 + 12.34 "</span></span>); AssertRange::AreEqual({ Token(<span class="hljs-number"><span class="hljs-number">1.0</span></span>), Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">12.34</span></span>) }, tokens); } TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"1+2*3/(4-5)"</span></span>); AssertRange::AreEqual({ Token(<span class="hljs-number"><span class="hljs-number">1</span></span>), Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">2</span></span>), Token(Operator::Mul), Token(<span class="hljs-number"><span class="hljs-number">3</span></span>), Token(Operator::Div), Token(Operator::LParen), Token(<span class="hljs-number"><span class="hljs-number">4</span></span>), Token(Operator::Minus), Token(<span class="hljs-number"><span class="hljs-number">5</span></span>), Token(Operator::RParen) }, tokens); } }; TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } TEST_METHOD(Should_get_type_for_number_token) { Token numToken(<span class="hljs-number"><span class="hljs-number">1.2</span></span>); Assert::AreEqual(TokenType::Number, numToken.Type()); } TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); } TEST_METHOD(Should_get_number_value_from_number_token) { Token token(<span class="hljs-number"><span class="hljs-number">1.23</span></span>); Assert::AreEqual&lt;double&gt;(<span class="hljs-number"><span class="hljs-number">1.23</span></span>, token); } }; }</code> <br> <br> <a href="https://github.com/Unril/InterpreterTDD/releases/tag/%25D0%259A%25D0%25BE%25D0%25BD%25D0%25B5%25D1%2586_%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B2%25D0%25BE%25D0%25B9_%25D1%2587%25D0%25B0%25D1%2581%25D1%2582%25D0%25B8">    GitHub</a> .         ,  .      <span class="hljs-string"><span class="hljs-string">"__"</span></span>. <br> <br>   <a href="http://habrahabr.ru/post/232081/">    </a> .      ,      <a href="http://habrahabr.ru/post/232097/">    </a> .</code> </pre> <code><code>std::vector,      Tokens</code> .            . <br> <br> <code class="cpp">#pragma once; #include &lt;vector&gt; namespace Interpreter { struct Token {}; typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { inline Tokens Tokenize(std::string expr) { throw std::exception(); } } // namespace Lexer } // namespace Interpreter</code> <br>   ,  ,   , .   ,    ,    <a href="http://cleancoder.posterous.com/the-transformation-priority-premise">The Transformation Priority Premise (TPP)</a>   .    , ,    ,     ,        .            .     ,     ,      ,           .  ,  ,   (   )    ,  ,  .     ,  ,         .     ,   TPP          . <br> <br>   : <br> <br> ({} ‚Üí nil)     ,   . (nil ‚Üí constant)    . (constant ‚Üí constant+)      (        ,  ). (constant ‚Üí scalar)    ,  . (statement ‚Üí statements)    (break, continue, return  ). (unconditional ‚Üí if)       . (scalar ‚Üí array)  / . (array ‚Üí container)     . (statement ‚Üí recursion)   . (if ‚Üí while)    . (expression ‚Üí function)   . (variable ‚Üí assignment)   . <br>        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::string expr) { return{}; }</code> <br> ,         .     . <br> <br> <s>         </s> .           .           .               .            .       . <br>  ,  <code>std::string</code>  <code>std::wstring</code> .         ,      Unicode.     . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); }</code> <br>  <code>AssertRange</code> -   ,       <code>AreEqual</code> ,   ,  ,    . <br> <br> <b class="spoiler_title">AssertRange</b> <code class="cpp">namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange</code> <br> <br>         <code>Operator</code>    .          <code>wchar_t</code>   ,         ,      . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', }; typedef Operator Token;</code> <br>    ,   ,        <code>Assert</code> ,    <code>ToString</code> ,    . <br> <br> <b class="spoiler_title">std::wstring ToString(const Token &amp;)</b> <code class="cpp">inline std::wstring ToString(const Token &amp;token) { return{ static_cast&lt;wchar_t&gt;(token) }; }</code> <br> <br>    ,   ,        .  ,   (unconditional ‚Üí if). <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { if(expr.empty()) { return{}; } return{ static_cast&lt;Operator&gt;(expr[0]) }; }</code> <br> <s>         </s> . <s>          .</s>           . ‚Ä¶ <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); }</code> <br>     .   ,     ,   - .    , : <br> <br>        ,      <code>Token</code> .       <code>dynamic_cast</code>    ,   .  ,    ,      .      <code>std::function</code>        .        .  Boost.Any,  - .            . <br>   ,   .      -  .  ,      ,      . <br> <br> ‚Ä¶        .        .        .        . <br>             . <br> <br> <code class="cpp">enum class TokenType { Operator, Number }; class Token { public: Token(Operator) {} TokenType Type() const { return TokenType::Operator; } }; ‚Ä¶ TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } };</code> <br>   <code>ToString</code>   <code>TokenType</code>       ,   ,   .     . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); }</code> <br>   .   (constant ‚Üí scalar)   . <br> <br> <code class="cpp">class Token { public: Token(Operator) :m_type(TokenType::Operator) {} Token(double) :m_type(TokenType::Number) {} TokenType Type() const { return m_type; } private: TokenType m_type; };</code> <br> ‚Ä¶ <s>       </s> . <s>       </s> .        .        . <br>    . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); }</code> <br>            . <br> <br> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} operator Operator() const { return m_operator; } ‚Ä¶ Operator m_operator; };</code> <br>      . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); }</code> <br>          ,  ,       <code>union</code> .         . <br> <br> <b class="spoiler_title">Token</b> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: return "Unknown token."; } }</code> <br> <br>  ,    ,      ,    .       .    . <br> <br> <i>          .</i>               .            .       . <br>        : <br> <br> <code class="cpp"> if(expr[0] &gt;= '0' &amp;&amp; expr[0] &lt;= '9') { return{ (double) expr[0] - '0' }; } return{ static_cast&lt;Operator&gt;(expr[0]) };</code> <br>      ,   . <br> <br> ‚Ä¶ <s>          .</s> <i>              .</i> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); }</code> <br> ,     <code>C</code>   ,  <code>isdigit</code> , ,       <code>atof</code> ,    ,      <code>wchar_t</code> .  (expression ‚Üí function).         . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { const wchar_t *current = expr.c_str(); if(!*current) return{}; if(iswdigit(*current)) return{ _wtof(current) }; return{ static_cast&lt;Operator&gt;(*current) }; }</code> <br>         .      . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>   ,        .  ,     .     .   <code>result</code> ,     . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); if(!*current) return result; if(iswdigit(*current)) { result.push_back(_wtof(current)); } else { result.push_back(static_cast&lt;Operator&gt;(*current)); } return result; }</code> <br>      :   (if ‚Üí while).     ,        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } } return result; }</code> <br>  <code>wcstod</code>    ,   <code>_wtof</code> ,           .           ,              .  ,    . <br> <br> <s>           .</s>       . <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>  (unconditional ‚Üí if)    ,    . <br> <br> <code class="cpp"> while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else if(*current == static_cast&lt;wchar_t&gt;(Operator::Plus)) { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } else { ++current; } }</code> <br>       .          .       <code>Detail</code>      .   <code>Tokenize</code>       . <br> <br> <code class="cpp">inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); }</code> <br> <b class="spoiler_title"> Detail::Tokenizer</b> <code class="cpp">namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { return *m_current == static_cast&lt;wchar_t&gt;(Operator::Plus); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail</code> <br> <br>  ,      .      ,  , .       . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); }</code> <br>      <code>Operator</code> ,    . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', };</code> <br>   .         <code>IsOperator</code>  <code>Tokenizer</code> . <br> <br> <code class="cpp"> bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); }</code> <br>         .        . <br> <br> <b class="spoiler_title">Interpreter.h</b> <code class="cpp">#pragma once; #include &lt;vector&gt; #include &lt;wchar.h&gt; #include &lt;algorithm&gt; namespace Interpreter { enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', }; inline std::wstring ToString(const Operator &amp;op) { return{ static_cast&lt;wchar_t&gt;(op) }; } enum class TokenType { Operator, Number }; inline std::wstring ToString(const TokenType &amp;type) { switch(type) { case TokenType::Operator: return L"Operator"; case TokenType::Number: return L"Number"; default: throw std::out_of_range("TokenType"); } } class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } friend inline bool operator==(const Token &amp;left, const Token &amp;right) { if(left.m_type == right.m_type) { switch(left.m_type) { case Interpreter::TokenType::Operator: return left.m_operator == right.m_operator; case Interpreter::TokenType::Number: return left.m_number == right.m_number; default: throw std::out_of_range("TokenType"); } } return false; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: throw std::out_of_range("TokenType"); } } typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); } } // namespace Lexer } // namespace Interpreter</code> <br> <br> <b class="spoiler_title">InterpreterTests.cpp</b> <code class="cpp">#include "stdafx.h" #include "CppUnitTest.h" #include "Interpreter.h" namespace InterpreterTests { using namespace Microsoft::VisualStudio::CppUnitTestFramework; using namespace Interpreter; using namespace std; namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual&lt;T&gt;(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange TEST_CLASS(LexerTests) { public: TEST_METHOD(Should_return_empty_token_list_when_put_empty_expression) { Tokens tokens = Lexer::Tokenize(L""); Assert::IsTrue(tokens.empty()); } TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); } TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); } TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); } TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); } }; TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); } TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); } TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); } }; }</code> <br> <br> <a href="https://github.com/Unril/InterpreterTDD/releases/tag/%25D0%259A%25D0%25BE%25D0%25BD%25D0%25B5%25D1%2586_%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B2%25D0%25BE%25D0%25B9_%25D1%2587%25D0%25B0%25D1%2581%25D1%2582%25D0%25B8">    GitHub</a> .         ,  .      "__". <br> <br>   <a href="http://habrahabr.ru/post/232081/">    </a> .      ,      <a href="http://habrahabr.ru/post/232097/">    </a> .</code> <pre> <code class="hljs lua"><code>std::vector,      Tokens</code> .            . <br> <br> <code class="cpp">#pragma once; #include &lt;vector&gt; namespace Interpreter { struct Token {}; typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { inline Tokens Tokenize(std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> expr) { throw std::exception(); } } // namespace Lexer } // namespace Interpreter</code> <br>   ,  ,   , .   ,    ,    <a href="http://cleancoder.posterous.com/the-transformation-priority-premise">The Transformation Priority Premise (TPP)</a>   .    , ,    ,     ,        .            .     ,     ,      ,           .  ,  ,   (   )    ,  ,  .     ,  ,         .     ,   TPP          . <br> <br>   : <br> <br> ({} ‚Üí <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)     ,   . (<span class="hljs-literal"><span class="hljs-literal">nil</span></span> ‚Üí constant)    . (constant ‚Üí constant+)      (        ,  ). (constant ‚Üí scalar)    ,  . (statement ‚Üí statements)    (<span class="hljs-keyword"><span class="hljs-keyword">break</span></span>, continue, <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>  ). (unconditional ‚Üí <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>)       . (scalar ‚Üí array)  / . (array ‚Üí container)     . (statement ‚Üí recursion)   . (<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ‚Üí <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>)    . (expression ‚Üí <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">)</span></span>   . (variable ‚Üí assignment)   . <br>        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> expr) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{}; }</code> <br> ,         .     . <br> <br> <s>         </s> .           .           .               .            .       . <br>  ,  <code>std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span></code>  <code>std::wstring</code> .         ,      Unicode.     . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"+"</span></span>); AssertRange::AreEqual({ Operator::Plus }, tokens); }</code> <br>  <code>AssertRange</code> -   ,       <code>AreEqual</code> ,   ,  ,    . <br> <br> <b class="spoiler_title">AssertRange</b> <code class="cpp">namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(expect)), distance(actualIter, <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(actual)), L<span class="hljs-string"><span class="hljs-string">"Size differs."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(; expectIter != <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(expect) &amp;&amp; actualIter != <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(actual); ++expectIter, ++actualIter) { auto message = L<span class="hljs-string"><span class="hljs-string">"Mismatch in position "</span></span> + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange</code> <br> <br>         <code>Operator</code>    .          <code>wchar_t</code>   ,         ,      . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L<span class="hljs-string"><span class="hljs-string">'+'</span></span>, }; typedef Operator Token;</code> <br>    ,   ,        <code>Assert</code> ,    <code>ToString</code> ,    . <br> <br> <b class="spoiler_title">std::wstring ToString(const Token &amp;)</b> <code class="cpp">inline std::wstring ToString(const Token &amp;token) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ static_cast&lt;wchar_t&gt;(token) }; }</code> <br> <br>    ,   ,        .  ,   (unconditional ‚Üí <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>). <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(expr.empty()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{}; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ static_cast&lt;Operator&gt;(expr[<span class="hljs-number"><span class="hljs-number">0</span></span>]) }; }</code> <br> <s>         </s> . <s>          .</s>           . ‚Ä¶ <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"1"</span></span>); AssertRange::AreEqual({ <span class="hljs-number"><span class="hljs-number">1.0</span></span> }, tokens); }</code> <br>     .   ,     ,   - .    , : <br> <br>        ,      <code>Token</code> .       <code>dynamic_cast</code>    ,   .  ,    ,      .      <code>std::<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span></span></code><span class="hljs-function"><span class="hljs-function">        .        .  </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Boost.Any</span></span></span><span class="hljs-function">,  - .            . </span></span><br><span class="hljs-function"><span class="hljs-function">   ,   .      -  .  ,      ,      . </span></span><br><span class="hljs-function"><span class="hljs-function"> </span></span><br><span class="hljs-function"><span class="hljs-function"> ‚Ä¶        .        .        .        . </span></span><br><span class="hljs-function"><span class="hljs-function">             . </span></span><br><span class="hljs-function"><span class="hljs-function"> </span></span><br><span class="hljs-function"><span class="hljs-function"> </span></span><code class="cpp"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">enum</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">class</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TokenType</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Operator</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Number</span></span></span><span class="hljs-function"> }; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">class</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Token</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">public</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Token</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Operator)</span></span></span></span> {} TokenType Type() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TokenType::Operator; } }; ‚Ä¶ TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } };</code> <br>   <code>ToString</code>   <code>TokenType</code>       ,   ,   .     . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_type_for_number_token) { Token numToken(<span class="hljs-number"><span class="hljs-number">1.2</span></span>); Assert::AreEqual(TokenType::Number, numToken.Type()); }</code> <br>   .   (constant ‚Üí scalar)   . <br> <br> <code class="cpp">class Token { public: Token(Operator) :m_type(TokenType::Operator) {} Token(double) :m_type(TokenType::Number) {} TokenType Type() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_type; } private: TokenType m_type; };</code> <br> ‚Ä¶ <s>       </s> . <s>       </s> .        .        . <br>    . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); }</code> <br>            . <br> <br> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} operator Operator() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_operator; } ‚Ä¶ Operator m_operator; };</code> <br>      . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_number_value_from_number_token) { Token token(<span class="hljs-number"><span class="hljs-number">1.23</span></span>); Assert::AreEqual&lt;double&gt;(<span class="hljs-number"><span class="hljs-number">1.23</span></span>, token); }</code> <br>          ,  ,       <code>union</code> .         . <br> <br> <b class="spoiler_title">Token</b> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_type; } operator Operator() const { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(m_type != TokenType::Operator) throw std::logic_error(<span class="hljs-string"><span class="hljs-string">"Should be operator token."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_operator; } operator double() const { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(m_type != TokenType::Number) throw std::logic_error(<span class="hljs-string"><span class="hljs-string">"Should be number token."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_number; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ToString(static_cast&lt;Operator&gt;(token)); default: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Unknown token."</span></span>; } }</code> <br> <br>  ,    ,      ,    .       .    . <br> <br> <i>          .</i>               .            .       . <br>        : <br> <br> <code class="cpp"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(expr[<span class="hljs-number"><span class="hljs-number">0</span></span>] &gt;= <span class="hljs-string"><span class="hljs-string">'0'</span></span> &amp;&amp; expr[<span class="hljs-number"><span class="hljs-number">0</span></span>] &lt;= <span class="hljs-string"><span class="hljs-string">'9'</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ (double) expr[<span class="hljs-number"><span class="hljs-number">0</span></span>] - <span class="hljs-string"><span class="hljs-string">'0'</span></span> }; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ static_cast&lt;Operator&gt;(expr[<span class="hljs-number"><span class="hljs-number">0</span></span>]) };</code> <br>      ,   . <br> <br> ‚Ä¶ <s>          .</s> <i>              .</i> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"12.34"</span></span>); AssertRange::AreEqual({ <span class="hljs-number"><span class="hljs-number">12.34</span></span> }, tokens); }</code> <br> ,     <code>C</code>   ,  <code>isdigit</code> , ,       <code>atof</code> ,    ,      <code>wchar_t</code> .  (expression ‚Üí <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">)</span></span>.         . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { const wchar_t *current = expr.c_str(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!*current) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{}; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(iswdigit(*current)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ _wtof(current) }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ static_cast&lt;Operator&gt;(*current) }; }</code> <br>         .      . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"+12.34"</span></span>); AssertRange::AreEqual({ Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">12.34</span></span>) }, tokens); }</code> <br>   ,        .  ,     .     .   <code>result</code> ,     . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!*current) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(iswdigit(*current)) { result.push_back(_wtof(current)); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { result.push_back(static_cast&lt;Operator&gt;(*current)); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> <br>      :   (<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ‚Üí <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>).     ,        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(*current) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(iswdigit(*current)) { wchar_t *<span class="hljs-keyword"><span class="hljs-keyword">end</span></span> = nullptr; result.push_back(wcstod(current, &amp;<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>)); current = <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> <br>  <code>wcstod</code>    ,   <code>_wtof</code> ,           .           ,              .  ,    . <br> <br> <s>           .</s>       . <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">" 1 + 12.34 "</span></span>); AssertRange::AreEqual({ Token(<span class="hljs-number"><span class="hljs-number">1.0</span></span>), Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">12.34</span></span>) }, tokens); }</code> <br>  (unconditional ‚Üí <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>)    ,    . <br> <br> <code class="cpp"> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(*current) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(iswdigit(*current)) { wchar_t *<span class="hljs-keyword"><span class="hljs-keyword">end</span></span> = nullptr; result.push_back(wcstod(current, &amp;<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>)); current = <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(*current == static_cast&lt;wchar_t&gt;(Operator::Plus)) { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { ++current; } }</code> <br>       .          .       <code>Detail</code>      .   <code>Tokenize</code>       . <br> <br> <code class="cpp">inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tokenizer.Result(); }</code> <br> <b class="spoiler_title"> Detail::Tokenizer</b> <code class="cpp">namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!EndOfExperssion()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(IsNumber()) { ScanNumber(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(IsOperator()) { ScanOperator(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { MoveNext(); } } } const Tokens &amp;Result() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_result; } private: bool EndOfExperssion() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_current == L<span class="hljs-string"><span class="hljs-string">'\0'</span></span>; } bool IsNumber() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> iswdigit(*m_current) != <span class="hljs-number"><span class="hljs-number">0</span></span>; } void ScanNumber() { wchar_t *<span class="hljs-keyword"><span class="hljs-keyword">end</span></span> = nullptr; m_result.push_back(wcstod(m_current, &amp;<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>)); m_current = <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; } bool IsOperator() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_current == static_cast&lt;wchar_t&gt;(Operator::Plus); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail</code> <br> <br>  ,      .      ,  , .       . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"1+2*3/(4-5)"</span></span>); AssertRange::AreEqual({ Token(<span class="hljs-number"><span class="hljs-number">1</span></span>), Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">2</span></span>), Token(Operator::Mul), Token(<span class="hljs-number"><span class="hljs-number">3</span></span>), Token(Operator::Div), Token(Operator::LParen), Token(<span class="hljs-number"><span class="hljs-number">4</span></span>), Token(Operator::Minus), Token(<span class="hljs-number"><span class="hljs-number">5</span></span>), Token(Operator::RParen) }, tokens); }</code> <br>      <code>Operator</code> ,    . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L<span class="hljs-string"><span class="hljs-string">'+'</span></span>, Minus = L<span class="hljs-string"><span class="hljs-string">'-'</span></span>, Mul = L<span class="hljs-string"><span class="hljs-string">'*'</span></span>, Div = L<span class="hljs-string"><span class="hljs-string">'/'</span></span>, LParen = L<span class="hljs-string"><span class="hljs-string">'('</span></span>, RParen = L<span class="hljs-string"><span class="hljs-string">')'</span></span>, };</code> <br>   .         <code>IsOperator</code>  <code>Tokenizer</code> . <br> <br> <code class="cpp"> bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> std::any_of(all.begin(), all.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(), [this](Operator o) {<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_current == static_cast&lt;wchar_t&gt;(o); }); }</code> <br>         .        . <br> <br> <b class="spoiler_title">Interpreter.h</b> <code class="cpp">#pragma once; #include &lt;vector&gt; #include &lt;wchar.h&gt; #include &lt;algorithm&gt; namespace Interpreter { enum class Operator : wchar_t { Plus = L<span class="hljs-string"><span class="hljs-string">'+'</span></span>, Minus = L<span class="hljs-string"><span class="hljs-string">'-'</span></span>, Mul = L<span class="hljs-string"><span class="hljs-string">'*'</span></span>, Div = L<span class="hljs-string"><span class="hljs-string">'/'</span></span>, LParen = L<span class="hljs-string"><span class="hljs-string">'('</span></span>, RParen = L<span class="hljs-string"><span class="hljs-string">')'</span></span>, }; inline std::wstring ToString(const Operator &amp;op) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ static_cast&lt;wchar_t&gt;(op) }; } enum class TokenType { Operator, Number }; inline std::wstring ToString(const TokenType &amp;<span class="hljs-built_in"><span class="hljs-built_in">type</span></span>) { switch(<span class="hljs-built_in"><span class="hljs-built_in">type</span></span>) { case TokenType::Operator: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> L<span class="hljs-string"><span class="hljs-string">"Operator"</span></span>; case TokenType::Number: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> L<span class="hljs-string"><span class="hljs-string">"Number"</span></span>; default: throw std::out_of_range(<span class="hljs-string"><span class="hljs-string">"TokenType"</span></span>); } } class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_type; } operator Operator() const { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(m_type != TokenType::Operator) throw std::logic_error(<span class="hljs-string"><span class="hljs-string">"Should be operator token."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_operator; } operator double() const { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(m_type != TokenType::Number) throw std::logic_error(<span class="hljs-string"><span class="hljs-string">"Should be number token."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_number; } friend inline bool operator==(const Token &amp;left, const Token &amp;right) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(left.m_type == right.m_type) { switch(left.m_type) { case Interpreter::TokenType::Operator: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> left.m_operator == right.m_operator; case Interpreter::TokenType::Number: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> left.m_number == right.m_number; default: throw std::out_of_range(<span class="hljs-string"><span class="hljs-string">"TokenType"</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ToString(static_cast&lt;Operator&gt;(token)); default: throw std::out_of_range(<span class="hljs-string"><span class="hljs-string">"TokenType"</span></span>); } } typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!EndOfExperssion()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(IsNumber()) { ScanNumber(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(IsOperator()) { ScanOperator(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { MoveNext(); } } } const Tokens &amp;Result() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_result; } private: bool EndOfExperssion() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_current == L<span class="hljs-string"><span class="hljs-string">'\0'</span></span>; } bool IsNumber() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> iswdigit(*m_current) != <span class="hljs-number"><span class="hljs-number">0</span></span>; } void ScanNumber() { wchar_t *<span class="hljs-keyword"><span class="hljs-keyword">end</span></span> = nullptr; m_result.push_back(wcstod(m_current, &amp;<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>)); m_current = <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; } bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> std::any_of(all.begin(), all.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(), [this](Operator o) {<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_current == static_cast&lt;wchar_t&gt;(o); }); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tokenizer.Result(); } } // namespace Lexer } // namespace Interpreter</code> <br> <br> <b class="spoiler_title">InterpreterTests.cpp</b> <code class="cpp">#include <span class="hljs-string"><span class="hljs-string">"stdafx.h"</span></span> #include <span class="hljs-string"><span class="hljs-string">"CppUnitTest.h"</span></span> #include <span class="hljs-string"><span class="hljs-string">"Interpreter.h"</span></span> namespace InterpreterTests { using namespace Microsoft::VisualStudio::CppUnitTestFramework; using namespace Interpreter; using namespace std; namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(expect)), distance(actualIter, <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(actual)), L<span class="hljs-string"><span class="hljs-string">"Size differs."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(; expectIter != <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(expect) &amp;&amp; actualIter != <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(actual); ++expectIter, ++actualIter) { auto message = L<span class="hljs-string"><span class="hljs-string">"Mismatch in position "</span></span> + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual&lt;T&gt;(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange TEST_CLASS(LexerTests) { public: TEST_METHOD(Should_return_empty_token_list_when_put_empty_expression) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">""</span></span>); Assert::IsTrue(tokens.empty()); } TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"+"</span></span>); AssertRange::AreEqual({ Operator::Plus }, tokens); } TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"1"</span></span>); AssertRange::AreEqual({ <span class="hljs-number"><span class="hljs-number">1.0</span></span> }, tokens); } TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"12.34"</span></span>); AssertRange::AreEqual({ <span class="hljs-number"><span class="hljs-number">12.34</span></span> }, tokens); } TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"+12.34"</span></span>); AssertRange::AreEqual({ Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">12.34</span></span>) }, tokens); } TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">" 1 + 12.34 "</span></span>); AssertRange::AreEqual({ Token(<span class="hljs-number"><span class="hljs-number">1.0</span></span>), Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">12.34</span></span>) }, tokens); } TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"1+2*3/(4-5)"</span></span>); AssertRange::AreEqual({ Token(<span class="hljs-number"><span class="hljs-number">1</span></span>), Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">2</span></span>), Token(Operator::Mul), Token(<span class="hljs-number"><span class="hljs-number">3</span></span>), Token(Operator::Div), Token(Operator::LParen), Token(<span class="hljs-number"><span class="hljs-number">4</span></span>), Token(Operator::Minus), Token(<span class="hljs-number"><span class="hljs-number">5</span></span>), Token(Operator::RParen) }, tokens); } }; TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } TEST_METHOD(Should_get_type_for_number_token) { Token numToken(<span class="hljs-number"><span class="hljs-number">1.2</span></span>); Assert::AreEqual(TokenType::Number, numToken.Type()); } TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); } TEST_METHOD(Should_get_number_value_from_number_token) { Token token(<span class="hljs-number"><span class="hljs-number">1.23</span></span>); Assert::AreEqual&lt;double&gt;(<span class="hljs-number"><span class="hljs-number">1.23</span></span>, token); } }; }</code> <br> <br> <a href="https://github.com/Unril/InterpreterTDD/releases/tag/%25D0%259A%25D0%25BE%25D0%25BD%25D0%25B5%25D1%2586_%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B2%25D0%25BE%25D0%25B9_%25D1%2587%25D0%25B0%25D1%2581%25D1%2582%25D0%25B8">    GitHub</a> .         ,  .      <span class="hljs-string"><span class="hljs-string">"__"</span></span>. <br> <br>   <a href="http://habrahabr.ru/post/232081/">    </a> .      ,      <a href="http://habrahabr.ru/post/232097/">    </a> .</code> </pre> <code><code>std::vector,      Tokens</code> .            . <br> <br> <code class="cpp">#pragma once; #include &lt;vector&gt; namespace Interpreter { struct Token {}; typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { inline Tokens Tokenize(std::string expr) { throw std::exception(); } } // namespace Lexer } // namespace Interpreter</code> <br>   ,  ,   , .   ,    ,    <a href="http://cleancoder.posterous.com/the-transformation-priority-premise">The Transformation Priority Premise (TPP)</a>   .    , ,    ,     ,        .            .     ,     ,      ,           .  ,  ,   (   )    ,  ,  .     ,  ,         .     ,   TPP          . <br> <br>   : <br> <br> ({} ‚Üí nil)     ,   . (nil ‚Üí constant)    . (constant ‚Üí constant+)      (        ,  ). (constant ‚Üí scalar)    ,  . (statement ‚Üí statements)    (break, continue, return  ). (unconditional ‚Üí if)       . (scalar ‚Üí array)  / . (array ‚Üí container)     . (statement ‚Üí recursion)   . (if ‚Üí while)    . (expression ‚Üí function)   . (variable ‚Üí assignment)   . <br>        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::string expr) { return{}; }</code> <br> ,         .     . <br> <br> <s>         </s> .           .           .               .            .       . <br>  ,  <code>std::string</code>  <code>std::wstring</code> .         ,      Unicode.     . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); }</code> <br>  <code>AssertRange</code> -   ,       <code>AreEqual</code> ,   ,  ,    . <br> <br> <b class="spoiler_title">AssertRange</b> <code class="cpp">namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange</code> <br> <br>         <code>Operator</code>    .          <code>wchar_t</code>   ,         ,      . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', }; typedef Operator Token;</code> <br>    ,   ,        <code>Assert</code> ,    <code>ToString</code> ,    . <br> <br> <b class="spoiler_title">std::wstring ToString(const Token &amp;)</b> <code class="cpp">inline std::wstring ToString(const Token &amp;token) { return{ static_cast&lt;wchar_t&gt;(token) }; }</code> <br> <br>    ,   ,        .  ,   (unconditional ‚Üí if). <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { if(expr.empty()) { return{}; } return{ static_cast&lt;Operator&gt;(expr[0]) }; }</code> <br> <s>         </s> . <s>          .</s>           . ‚Ä¶ <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); }</code> <br>     .   ,     ,   - .    , : <br> <br>        ,      <code>Token</code> .       <code>dynamic_cast</code>    ,   .  ,    ,      .      <code>std::function</code>        .        .  Boost.Any,  - .            . <br>   ,   .      -  .  ,      ,      . <br> <br> ‚Ä¶        .        .        .        . <br>             . <br> <br> <code class="cpp">enum class TokenType { Operator, Number }; class Token { public: Token(Operator) {} TokenType Type() const { return TokenType::Operator; } }; ‚Ä¶ TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } };</code> <br>   <code>ToString</code>   <code>TokenType</code>       ,   ,   .     . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); }</code> <br>   .   (constant ‚Üí scalar)   . <br> <br> <code class="cpp">class Token { public: Token(Operator) :m_type(TokenType::Operator) {} Token(double) :m_type(TokenType::Number) {} TokenType Type() const { return m_type; } private: TokenType m_type; };</code> <br> ‚Ä¶ <s>       </s> . <s>       </s> .        .        . <br>    . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); }</code> <br>            . <br> <br> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} operator Operator() const { return m_operator; } ‚Ä¶ Operator m_operator; };</code> <br>      . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); }</code> <br>          ,  ,       <code>union</code> .         . <br> <br> <b class="spoiler_title">Token</b> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: return "Unknown token."; } }</code> <br> <br>  ,    ,      ,    .       .    . <br> <br> <i>          .</i>               .            .       . <br>        : <br> <br> <code class="cpp"> if(expr[0] &gt;= '0' &amp;&amp; expr[0] &lt;= '9') { return{ (double) expr[0] - '0' }; } return{ static_cast&lt;Operator&gt;(expr[0]) };</code> <br>      ,   . <br> <br> ‚Ä¶ <s>          .</s> <i>              .</i> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); }</code> <br> ,     <code>C</code>   ,  <code>isdigit</code> , ,       <code>atof</code> ,    ,      <code>wchar_t</code> .  (expression ‚Üí function).         . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { const wchar_t *current = expr.c_str(); if(!*current) return{}; if(iswdigit(*current)) return{ _wtof(current) }; return{ static_cast&lt;Operator&gt;(*current) }; }</code> <br>         .      . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>   ,        .  ,     .     .   <code>result</code> ,     . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); if(!*current) return result; if(iswdigit(*current)) { result.push_back(_wtof(current)); } else { result.push_back(static_cast&lt;Operator&gt;(*current)); } return result; }</code> <br>      :   (if ‚Üí while).     ,        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } } return result; }</code> <br>  <code>wcstod</code>    ,   <code>_wtof</code> ,           .           ,              .  ,    . <br> <br> <s>           .</s>       . <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>  (unconditional ‚Üí if)    ,    . <br> <br> <code class="cpp"> while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else if(*current == static_cast&lt;wchar_t&gt;(Operator::Plus)) { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } else { ++current; } }</code> <br>       .          .       <code>Detail</code>      .   <code>Tokenize</code>       . <br> <br> <code class="cpp">inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); }</code> <br> <b class="spoiler_title"> Detail::Tokenizer</b> <code class="cpp">namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { return *m_current == static_cast&lt;wchar_t&gt;(Operator::Plus); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail</code> <br> <br>  ,      .      ,  , .       . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); }</code> <br>      <code>Operator</code> ,    . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', };</code> <br>   .         <code>IsOperator</code>  <code>Tokenizer</code> . <br> <br> <code class="cpp"> bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); }</code> <br>         .        . <br> <br> <b class="spoiler_title">Interpreter.h</b> <code class="cpp">#pragma once; #include &lt;vector&gt; #include &lt;wchar.h&gt; #include &lt;algorithm&gt; namespace Interpreter { enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', }; inline std::wstring ToString(const Operator &amp;op) { return{ static_cast&lt;wchar_t&gt;(op) }; } enum class TokenType { Operator, Number }; inline std::wstring ToString(const TokenType &amp;type) { switch(type) { case TokenType::Operator: return L"Operator"; case TokenType::Number: return L"Number"; default: throw std::out_of_range("TokenType"); } } class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } friend inline bool operator==(const Token &amp;left, const Token &amp;right) { if(left.m_type == right.m_type) { switch(left.m_type) { case Interpreter::TokenType::Operator: return left.m_operator == right.m_operator; case Interpreter::TokenType::Number: return left.m_number == right.m_number; default: throw std::out_of_range("TokenType"); } } return false; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: throw std::out_of_range("TokenType"); } } typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); } } // namespace Lexer } // namespace Interpreter</code> <br> <br> <b class="spoiler_title">InterpreterTests.cpp</b> <code class="cpp">#include "stdafx.h" #include "CppUnitTest.h" #include "Interpreter.h" namespace InterpreterTests { using namespace Microsoft::VisualStudio::CppUnitTestFramework; using namespace Interpreter; using namespace std; namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual&lt;T&gt;(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange TEST_CLASS(LexerTests) { public: TEST_METHOD(Should_return_empty_token_list_when_put_empty_expression) { Tokens tokens = Lexer::Tokenize(L""); Assert::IsTrue(tokens.empty()); } TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); } TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); } TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); } TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); } }; TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); } TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); } TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); } }; }</code> <br> <br> <a href="https://github.com/Unril/InterpreterTDD/releases/tag/%25D0%259A%25D0%25BE%25D0%25BD%25D0%25B5%25D1%2586_%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B2%25D0%25BE%25D0%25B9_%25D1%2587%25D0%25B0%25D1%2581%25D1%2582%25D0%25B8">    GitHub</a> .         ,  .      "__". <br> <br>   <a href="http://habrahabr.ru/post/232081/">    </a> .      ,      <a href="http://habrahabr.ru/post/232097/">    </a> .</code> <pre> <code class="hljs lua"><code>std::vector,      Tokens</code> .            . <br> <br> <code class="cpp">#pragma once; #include &lt;vector&gt; namespace Interpreter { struct Token {}; typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { inline Tokens Tokenize(std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> expr) { throw std::exception(); } } // namespace Lexer } // namespace Interpreter</code> <br>   ,  ,   , .   ,    ,    <a href="http://cleancoder.posterous.com/the-transformation-priority-premise">The Transformation Priority Premise (TPP)</a>   .    , ,    ,     ,        .            .     ,     ,      ,           .  ,  ,   (   )    ,  ,  .     ,  ,         .     ,   TPP          . <br> <br>   : <br> <br> ({} ‚Üí <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)     ,   . (<span class="hljs-literal"><span class="hljs-literal">nil</span></span> ‚Üí constant)    . (constant ‚Üí constant+)      (        ,  ). (constant ‚Üí scalar)    ,  . (statement ‚Üí statements)    (<span class="hljs-keyword"><span class="hljs-keyword">break</span></span>, continue, <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>  ). (unconditional ‚Üí <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>)       . (scalar ‚Üí array)  / . (array ‚Üí container)     . (statement ‚Üí recursion)   . (<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ‚Üí <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>)    . (expression ‚Üí <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">)</span></span>   . (variable ‚Üí assignment)   . <br>        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> expr) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{}; }</code> <br> ,         .     . <br> <br> <s>         </s> .           .           .               .            .       . <br>  ,  <code>std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span></code>  <code>std::wstring</code> .         ,      Unicode.     . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"+"</span></span>); AssertRange::AreEqual({ Operator::Plus }, tokens); }</code> <br>  <code>AssertRange</code> -   ,       <code>AreEqual</code> ,   ,  ,    . <br> <br> <b class="spoiler_title">AssertRange</b> <code class="cpp">namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(expect)), distance(actualIter, <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(actual)), L<span class="hljs-string"><span class="hljs-string">"Size differs."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(; expectIter != <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(expect) &amp;&amp; actualIter != <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(actual); ++expectIter, ++actualIter) { auto message = L<span class="hljs-string"><span class="hljs-string">"Mismatch in position "</span></span> + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange</code> <br> <br>         <code>Operator</code>    .          <code>wchar_t</code>   ,         ,      . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L<span class="hljs-string"><span class="hljs-string">'+'</span></span>, }; typedef Operator Token;</code> <br>    ,   ,        <code>Assert</code> ,    <code>ToString</code> ,    . <br> <br> <b class="spoiler_title">std::wstring ToString(const Token &amp;)</b> <code class="cpp">inline std::wstring ToString(const Token &amp;token) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ static_cast&lt;wchar_t&gt;(token) }; }</code> <br> <br>    ,   ,        .  ,   (unconditional ‚Üí <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>). <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(expr.empty()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{}; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ static_cast&lt;Operator&gt;(expr[<span class="hljs-number"><span class="hljs-number">0</span></span>]) }; }</code> <br> <s>         </s> . <s>          .</s>           . ‚Ä¶ <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"1"</span></span>); AssertRange::AreEqual({ <span class="hljs-number"><span class="hljs-number">1.0</span></span> }, tokens); }</code> <br>     .   ,     ,   - .    , : <br> <br>        ,      <code>Token</code> .       <code>dynamic_cast</code>    ,   .  ,    ,      .      <code>std::<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span></span></code><span class="hljs-function"><span class="hljs-function">        .        .  </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Boost.Any</span></span></span><span class="hljs-function">,  - .            . </span></span><br><span class="hljs-function"><span class="hljs-function">   ,   .      -  .  ,      ,      . </span></span><br><span class="hljs-function"><span class="hljs-function"> </span></span><br><span class="hljs-function"><span class="hljs-function"> ‚Ä¶        .        .        .        . </span></span><br><span class="hljs-function"><span class="hljs-function">             . </span></span><br><span class="hljs-function"><span class="hljs-function"> </span></span><br><span class="hljs-function"><span class="hljs-function"> </span></span><code class="cpp"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">enum</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">class</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TokenType</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Operator</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Number</span></span></span><span class="hljs-function"> }; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">class</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Token</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">public</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Token</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Operator)</span></span></span></span> {} TokenType Type() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TokenType::Operator; } }; ‚Ä¶ TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } };</code> <br>   <code>ToString</code>   <code>TokenType</code>       ,   ,   .     . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_type_for_number_token) { Token numToken(<span class="hljs-number"><span class="hljs-number">1.2</span></span>); Assert::AreEqual(TokenType::Number, numToken.Type()); }</code> <br>   .   (constant ‚Üí scalar)   . <br> <br> <code class="cpp">class Token { public: Token(Operator) :m_type(TokenType::Operator) {} Token(double) :m_type(TokenType::Number) {} TokenType Type() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_type; } private: TokenType m_type; };</code> <br> ‚Ä¶ <s>       </s> . <s>       </s> .        .        . <br>    . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); }</code> <br>            . <br> <br> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} operator Operator() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_operator; } ‚Ä¶ Operator m_operator; };</code> <br>      . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_number_value_from_number_token) { Token token(<span class="hljs-number"><span class="hljs-number">1.23</span></span>); Assert::AreEqual&lt;double&gt;(<span class="hljs-number"><span class="hljs-number">1.23</span></span>, token); }</code> <br>          ,  ,       <code>union</code> .         . <br> <br> <b class="spoiler_title">Token</b> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_type; } operator Operator() const { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(m_type != TokenType::Operator) throw std::logic_error(<span class="hljs-string"><span class="hljs-string">"Should be operator token."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_operator; } operator double() const { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(m_type != TokenType::Number) throw std::logic_error(<span class="hljs-string"><span class="hljs-string">"Should be number token."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_number; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ToString(static_cast&lt;Operator&gt;(token)); default: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Unknown token."</span></span>; } }</code> <br> <br>  ,    ,      ,    .       .    . <br> <br> <i>          .</i>               .            .       . <br>        : <br> <br> <code class="cpp"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(expr[<span class="hljs-number"><span class="hljs-number">0</span></span>] &gt;= <span class="hljs-string"><span class="hljs-string">'0'</span></span> &amp;&amp; expr[<span class="hljs-number"><span class="hljs-number">0</span></span>] &lt;= <span class="hljs-string"><span class="hljs-string">'9'</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ (double) expr[<span class="hljs-number"><span class="hljs-number">0</span></span>] - <span class="hljs-string"><span class="hljs-string">'0'</span></span> }; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ static_cast&lt;Operator&gt;(expr[<span class="hljs-number"><span class="hljs-number">0</span></span>]) };</code> <br>      ,   . <br> <br> ‚Ä¶ <s>          .</s> <i>              .</i> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"12.34"</span></span>); AssertRange::AreEqual({ <span class="hljs-number"><span class="hljs-number">12.34</span></span> }, tokens); }</code> <br> ,     <code>C</code>   ,  <code>isdigit</code> , ,       <code>atof</code> ,    ,      <code>wchar_t</code> .  (expression ‚Üí <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">)</span></span>.         . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { const wchar_t *current = expr.c_str(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!*current) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{}; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(iswdigit(*current)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ _wtof(current) }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ static_cast&lt;Operator&gt;(*current) }; }</code> <br>         .      . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"+12.34"</span></span>); AssertRange::AreEqual({ Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">12.34</span></span>) }, tokens); }</code> <br>   ,        .  ,     .     .   <code>result</code> ,     . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!*current) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(iswdigit(*current)) { result.push_back(_wtof(current)); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { result.push_back(static_cast&lt;Operator&gt;(*current)); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> <br>      :   (<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ‚Üí <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>).     ,        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(*current) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(iswdigit(*current)) { wchar_t *<span class="hljs-keyword"><span class="hljs-keyword">end</span></span> = nullptr; result.push_back(wcstod(current, &amp;<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>)); current = <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> <br>  <code>wcstod</code>    ,   <code>_wtof</code> ,           .           ,              .  ,    . <br> <br> <s>           .</s>       . <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">" 1 + 12.34 "</span></span>); AssertRange::AreEqual({ Token(<span class="hljs-number"><span class="hljs-number">1.0</span></span>), Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">12.34</span></span>) }, tokens); }</code> <br>  (unconditional ‚Üí <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>)    ,    . <br> <br> <code class="cpp"> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(*current) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(iswdigit(*current)) { wchar_t *<span class="hljs-keyword"><span class="hljs-keyword">end</span></span> = nullptr; result.push_back(wcstod(current, &amp;<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>)); current = <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(*current == static_cast&lt;wchar_t&gt;(Operator::Plus)) { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { ++current; } }</code> <br>       .          .       <code>Detail</code>      .   <code>Tokenize</code>       . <br> <br> <code class="cpp">inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tokenizer.Result(); }</code> <br> <b class="spoiler_title"> Detail::Tokenizer</b> <code class="cpp">namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!EndOfExperssion()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(IsNumber()) { ScanNumber(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(IsOperator()) { ScanOperator(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { MoveNext(); } } } const Tokens &amp;Result() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_result; } private: bool EndOfExperssion() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_current == L<span class="hljs-string"><span class="hljs-string">'\0'</span></span>; } bool IsNumber() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> iswdigit(*m_current) != <span class="hljs-number"><span class="hljs-number">0</span></span>; } void ScanNumber() { wchar_t *<span class="hljs-keyword"><span class="hljs-keyword">end</span></span> = nullptr; m_result.push_back(wcstod(m_current, &amp;<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>)); m_current = <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; } bool IsOperator() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_current == static_cast&lt;wchar_t&gt;(Operator::Plus); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail</code> <br> <br>  ,      .      ,  , .       . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"1+2*3/(4-5)"</span></span>); AssertRange::AreEqual({ Token(<span class="hljs-number"><span class="hljs-number">1</span></span>), Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">2</span></span>), Token(Operator::Mul), Token(<span class="hljs-number"><span class="hljs-number">3</span></span>), Token(Operator::Div), Token(Operator::LParen), Token(<span class="hljs-number"><span class="hljs-number">4</span></span>), Token(Operator::Minus), Token(<span class="hljs-number"><span class="hljs-number">5</span></span>), Token(Operator::RParen) }, tokens); }</code> <br>      <code>Operator</code> ,    . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L<span class="hljs-string"><span class="hljs-string">'+'</span></span>, Minus = L<span class="hljs-string"><span class="hljs-string">'-'</span></span>, Mul = L<span class="hljs-string"><span class="hljs-string">'*'</span></span>, Div = L<span class="hljs-string"><span class="hljs-string">'/'</span></span>, LParen = L<span class="hljs-string"><span class="hljs-string">'('</span></span>, RParen = L<span class="hljs-string"><span class="hljs-string">')'</span></span>, };</code> <br>   .         <code>IsOperator</code>  <code>Tokenizer</code> . <br> <br> <code class="cpp"> bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> std::any_of(all.begin(), all.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(), [this](Operator o) {<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_current == static_cast&lt;wchar_t&gt;(o); }); }</code> <br>         .        . <br> <br> <b class="spoiler_title">Interpreter.h</b> <code class="cpp">#pragma once; #include &lt;vector&gt; #include &lt;wchar.h&gt; #include &lt;algorithm&gt; namespace Interpreter { enum class Operator : wchar_t { Plus = L<span class="hljs-string"><span class="hljs-string">'+'</span></span>, Minus = L<span class="hljs-string"><span class="hljs-string">'-'</span></span>, Mul = L<span class="hljs-string"><span class="hljs-string">'*'</span></span>, Div = L<span class="hljs-string"><span class="hljs-string">'/'</span></span>, LParen = L<span class="hljs-string"><span class="hljs-string">'('</span></span>, RParen = L<span class="hljs-string"><span class="hljs-string">')'</span></span>, }; inline std::wstring ToString(const Operator &amp;op) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ static_cast&lt;wchar_t&gt;(op) }; } enum class TokenType { Operator, Number }; inline std::wstring ToString(const TokenType &amp;<span class="hljs-built_in"><span class="hljs-built_in">type</span></span>) { switch(<span class="hljs-built_in"><span class="hljs-built_in">type</span></span>) { case TokenType::Operator: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> L<span class="hljs-string"><span class="hljs-string">"Operator"</span></span>; case TokenType::Number: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> L<span class="hljs-string"><span class="hljs-string">"Number"</span></span>; default: throw std::out_of_range(<span class="hljs-string"><span class="hljs-string">"TokenType"</span></span>); } } class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_type; } operator Operator() const { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(m_type != TokenType::Operator) throw std::logic_error(<span class="hljs-string"><span class="hljs-string">"Should be operator token."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_operator; } operator double() const { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(m_type != TokenType::Number) throw std::logic_error(<span class="hljs-string"><span class="hljs-string">"Should be number token."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_number; } friend inline bool operator==(const Token &amp;left, const Token &amp;right) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(left.m_type == right.m_type) { switch(left.m_type) { case Interpreter::TokenType::Operator: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> left.m_operator == right.m_operator; case Interpreter::TokenType::Number: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> left.m_number == right.m_number; default: throw std::out_of_range(<span class="hljs-string"><span class="hljs-string">"TokenType"</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ToString(static_cast&lt;Operator&gt;(token)); default: throw std::out_of_range(<span class="hljs-string"><span class="hljs-string">"TokenType"</span></span>); } } typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!EndOfExperssion()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(IsNumber()) { ScanNumber(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(IsOperator()) { ScanOperator(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { MoveNext(); } } } const Tokens &amp;Result() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_result; } private: bool EndOfExperssion() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_current == L<span class="hljs-string"><span class="hljs-string">'\0'</span></span>; } bool IsNumber() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> iswdigit(*m_current) != <span class="hljs-number"><span class="hljs-number">0</span></span>; } void ScanNumber() { wchar_t *<span class="hljs-keyword"><span class="hljs-keyword">end</span></span> = nullptr; m_result.push_back(wcstod(m_current, &amp;<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>)); m_current = <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; } bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> std::any_of(all.begin(), all.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(), [this](Operator o) {<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_current == static_cast&lt;wchar_t&gt;(o); }); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tokenizer.Result(); } } // namespace Lexer } // namespace Interpreter</code> <br> <br> <b class="spoiler_title">InterpreterTests.cpp</b> <code class="cpp">#include <span class="hljs-string"><span class="hljs-string">"stdafx.h"</span></span> #include <span class="hljs-string"><span class="hljs-string">"CppUnitTest.h"</span></span> #include <span class="hljs-string"><span class="hljs-string">"Interpreter.h"</span></span> namespace InterpreterTests { using namespace Microsoft::VisualStudio::CppUnitTestFramework; using namespace Interpreter; using namespace std; namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(expect)), distance(actualIter, <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(actual)), L<span class="hljs-string"><span class="hljs-string">"Size differs."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(; expectIter != <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(expect) &amp;&amp; actualIter != <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(actual); ++expectIter, ++actualIter) { auto message = L<span class="hljs-string"><span class="hljs-string">"Mismatch in position "</span></span> + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual&lt;T&gt;(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange TEST_CLASS(LexerTests) { public: TEST_METHOD(Should_return_empty_token_list_when_put_empty_expression) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">""</span></span>); Assert::IsTrue(tokens.empty()); } TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"+"</span></span>); AssertRange::AreEqual({ Operator::Plus }, tokens); } TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"1"</span></span>); AssertRange::AreEqual({ <span class="hljs-number"><span class="hljs-number">1.0</span></span> }, tokens); } TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"12.34"</span></span>); AssertRange::AreEqual({ <span class="hljs-number"><span class="hljs-number">12.34</span></span> }, tokens); } TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"+12.34"</span></span>); AssertRange::AreEqual({ Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">12.34</span></span>) }, tokens); } TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">" 1 + 12.34 "</span></span>); AssertRange::AreEqual({ Token(<span class="hljs-number"><span class="hljs-number">1.0</span></span>), Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">12.34</span></span>) }, tokens); } TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"1+2*3/(4-5)"</span></span>); AssertRange::AreEqual({ Token(<span class="hljs-number"><span class="hljs-number">1</span></span>), Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">2</span></span>), Token(Operator::Mul), Token(<span class="hljs-number"><span class="hljs-number">3</span></span>), Token(Operator::Div), Token(Operator::LParen), Token(<span class="hljs-number"><span class="hljs-number">4</span></span>), Token(Operator::Minus), Token(<span class="hljs-number"><span class="hljs-number">5</span></span>), Token(Operator::RParen) }, tokens); } }; TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } TEST_METHOD(Should_get_type_for_number_token) { Token numToken(<span class="hljs-number"><span class="hljs-number">1.2</span></span>); Assert::AreEqual(TokenType::Number, numToken.Type()); } TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); } TEST_METHOD(Should_get_number_value_from_number_token) { Token token(<span class="hljs-number"><span class="hljs-number">1.23</span></span>); Assert::AreEqual&lt;double&gt;(<span class="hljs-number"><span class="hljs-number">1.23</span></span>, token); } }; }</code> <br> <br> <a href="https://github.com/Unril/InterpreterTDD/releases/tag/%25D0%259A%25D0%25BE%25D0%25BD%25D0%25B5%25D1%2586_%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B2%25D0%25BE%25D0%25B9_%25D1%2587%25D0%25B0%25D1%2581%25D1%2582%25D0%25B8">    GitHub</a> .         ,  .      <span class="hljs-string"><span class="hljs-string">"__"</span></span>. <br> <br>   <a href="http://habrahabr.ru/post/232081/">    </a> .      ,      <a href="http://habrahabr.ru/post/232097/">    </a> .</code> </pre> <code><code>std::vector,      Tokens</code> .            . <br> <br> <code class="cpp">#pragma once; #include &lt;vector&gt; namespace Interpreter { struct Token {}; typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { inline Tokens Tokenize(std::string expr) { throw std::exception(); } } // namespace Lexer } // namespace Interpreter</code> <br>   ,  ,   , .   ,    ,    <a href="http://cleancoder.posterous.com/the-transformation-priority-premise">The Transformation Priority Premise (TPP)</a>   .    , ,    ,     ,        .            .     ,     ,      ,           .  ,  ,   (   )    ,  ,  .     ,  ,         .     ,   TPP          . <br> <br>   : <br> <br> ({} ‚Üí nil)     ,   . (nil ‚Üí constant)    . (constant ‚Üí constant+)      (        ,  ). (constant ‚Üí scalar)    ,  . (statement ‚Üí statements)    (break, continue, return  ). (unconditional ‚Üí if)       . (scalar ‚Üí array)  / . (array ‚Üí container)     . (statement ‚Üí recursion)   . (if ‚Üí while)    . (expression ‚Üí function)   . (variable ‚Üí assignment)   . <br>        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::string expr) { return{}; }</code> <br> ,         .     . <br> <br> <s>         </s> .           .           .               .            .       . <br>  ,  <code>std::string</code>  <code>std::wstring</code> .         ,      Unicode.     . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); }</code> <br>  <code>AssertRange</code> -   ,       <code>AreEqual</code> ,   ,  ,    . <br> <br> <b class="spoiler_title">AssertRange</b> <code class="cpp">namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange</code> <br> <br>         <code>Operator</code>    .          <code>wchar_t</code>   ,         ,      . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', }; typedef Operator Token;</code> <br>    ,   ,        <code>Assert</code> ,    <code>ToString</code> ,    . <br> <br> <b class="spoiler_title">std::wstring ToString(const Token &amp;)</b> <code class="cpp">inline std::wstring ToString(const Token &amp;token) { return{ static_cast&lt;wchar_t&gt;(token) }; }</code> <br> <br>    ,   ,        .  ,   (unconditional ‚Üí if). <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { if(expr.empty()) { return{}; } return{ static_cast&lt;Operator&gt;(expr[0]) }; }</code> <br> <s>         </s> . <s>          .</s>           . ‚Ä¶ <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); }</code> <br>     .   ,     ,   - .    , : <br> <br>        ,      <code>Token</code> .       <code>dynamic_cast</code>    ,   .  ,    ,      .      <code>std::function</code>        .        .  Boost.Any,  - .            . <br>   ,   .      -  .  ,      ,      . <br> <br> ‚Ä¶        .        .        .        . <br>             . <br> <br> <code class="cpp">enum class TokenType { Operator, Number }; class Token { public: Token(Operator) {} TokenType Type() const { return TokenType::Operator; } }; ‚Ä¶ TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } };</code> <br>   <code>ToString</code>   <code>TokenType</code>       ,   ,   .     . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); }</code> <br>   .   (constant ‚Üí scalar)   . <br> <br> <code class="cpp">class Token { public: Token(Operator) :m_type(TokenType::Operator) {} Token(double) :m_type(TokenType::Number) {} TokenType Type() const { return m_type; } private: TokenType m_type; };</code> <br> ‚Ä¶ <s>       </s> . <s>       </s> .        .        . <br>    . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); }</code> <br>            . <br> <br> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} operator Operator() const { return m_operator; } ‚Ä¶ Operator m_operator; };</code> <br>      . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); }</code> <br>          ,  ,       <code>union</code> .         . <br> <br> <b class="spoiler_title">Token</b> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: return "Unknown token."; } }</code> <br> <br>  ,    ,      ,    .       .    . <br> <br> <i>          .</i>               .            .       . <br>        : <br> <br> <code class="cpp"> if(expr[0] &gt;= '0' &amp;&amp; expr[0] &lt;= '9') { return{ (double) expr[0] - '0' }; } return{ static_cast&lt;Operator&gt;(expr[0]) };</code> <br>      ,   . <br> <br> ‚Ä¶ <s>          .</s> <i>              .</i> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); }</code> <br> ,     <code>C</code>   ,  <code>isdigit</code> , ,       <code>atof</code> ,    ,      <code>wchar_t</code> .  (expression ‚Üí function).         . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { const wchar_t *current = expr.c_str(); if(!*current) return{}; if(iswdigit(*current)) return{ _wtof(current) }; return{ static_cast&lt;Operator&gt;(*current) }; }</code> <br>         .      . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>   ,        .  ,     .     .   <code>result</code> ,     . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); if(!*current) return result; if(iswdigit(*current)) { result.push_back(_wtof(current)); } else { result.push_back(static_cast&lt;Operator&gt;(*current)); } return result; }</code> <br>      :   (if ‚Üí while).     ,        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } } return result; }</code> <br>  <code>wcstod</code>    ,   <code>_wtof</code> ,           .           ,              .  ,    . <br> <br> <s>           .</s>       . <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>  (unconditional ‚Üí if)    ,    . <br> <br> <code class="cpp"> while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else if(*current == static_cast&lt;wchar_t&gt;(Operator::Plus)) { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } else { ++current; } }</code> <br>       .          .       <code>Detail</code>      .   <code>Tokenize</code>       . <br> <br> <code class="cpp">inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); }</code> <br> <b class="spoiler_title"> Detail::Tokenizer</b> <code class="cpp">namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { return *m_current == static_cast&lt;wchar_t&gt;(Operator::Plus); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail</code> <br> <br>  ,      .      ,  , .       . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); }</code> <br>      <code>Operator</code> ,    . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', };</code> <br>   .         <code>IsOperator</code>  <code>Tokenizer</code> . <br> <br> <code class="cpp"> bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); }</code> <br>         .        . <br> <br> <b class="spoiler_title">Interpreter.h</b> <code class="cpp">#pragma once; #include &lt;vector&gt; #include &lt;wchar.h&gt; #include &lt;algorithm&gt; namespace Interpreter { enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', }; inline std::wstring ToString(const Operator &amp;op) { return{ static_cast&lt;wchar_t&gt;(op) }; } enum class TokenType { Operator, Number }; inline std::wstring ToString(const TokenType &amp;type) { switch(type) { case TokenType::Operator: return L"Operator"; case TokenType::Number: return L"Number"; default: throw std::out_of_range("TokenType"); } } class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } friend inline bool operator==(const Token &amp;left, const Token &amp;right) { if(left.m_type == right.m_type) { switch(left.m_type) { case Interpreter::TokenType::Operator: return left.m_operator == right.m_operator; case Interpreter::TokenType::Number: return left.m_number == right.m_number; default: throw std::out_of_range("TokenType"); } } return false; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: throw std::out_of_range("TokenType"); } } typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); } } // namespace Lexer } // namespace Interpreter</code> <br> <br> <b class="spoiler_title">InterpreterTests.cpp</b> <code class="cpp">#include "stdafx.h" #include "CppUnitTest.h" #include "Interpreter.h" namespace InterpreterTests { using namespace Microsoft::VisualStudio::CppUnitTestFramework; using namespace Interpreter; using namespace std; namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual&lt;T&gt;(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange TEST_CLASS(LexerTests) { public: TEST_METHOD(Should_return_empty_token_list_when_put_empty_expression) { Tokens tokens = Lexer::Tokenize(L""); Assert::IsTrue(tokens.empty()); } TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); } TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); } TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); } TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); } }; TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); } TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); } TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); } }; }</code> <br> <br> <a href="https://github.com/Unril/InterpreterTDD/releases/tag/%25D0%259A%25D0%25BE%25D0%25BD%25D0%25B5%25D1%2586_%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B2%25D0%25BE%25D0%25B9_%25D1%2587%25D0%25B0%25D1%2581%25D1%2582%25D0%25B8">    GitHub</a> .         ,  .      "__". <br> <br>   <a href="http://habrahabr.ru/post/232081/">    </a> .      ,      <a href="http://habrahabr.ru/post/232097/">    </a> .</code> <div class="spoiler"> <code><b class="spoiler_title"><code>std::vector,      Tokens</code> .            . <br> <br> <code class="cpp">#pragma once; #include &lt;vector&gt; namespace Interpreter { struct Token {}; typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { inline Tokens Tokenize(std::string expr) { throw std::exception(); } } // namespace Lexer } // namespace Interpreter</code> <br>   ,  ,   , .   ,    ,    <a href="http://cleancoder.posterous.com/the-transformation-priority-premise">The Transformation Priority Premise (TPP)</a>   .    , ,    ,     ,        .            .     ,     ,      ,           .  ,  ,   (   )    ,  ,  .     ,  ,         .     ,   TPP          . <br> <br>   : <br> <br> ({} ‚Üí nil)     ,   . (nil ‚Üí constant)    . (constant ‚Üí constant+)      (        ,  ). (constant ‚Üí scalar)    ,  . (statement ‚Üí statements)    (break, continue, return  ). (unconditional ‚Üí if)       . (scalar ‚Üí array)  / . (array ‚Üí container)     . (statement ‚Üí recursion)   . (if ‚Üí while)    . (expression ‚Üí function)   . (variable ‚Üí assignment)   . <br>        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::string expr) { return{}; }</code> <br> ,         .     . <br> <br> <s>         </s> .           .           .               .            .       . <br>  ,  <code>std::string</code>  <code>std::wstring</code> .         ,      Unicode.     . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); }</code> <br>  <code>AssertRange</code> -   ,       <code>AreEqual</code> ,   ,  ,    . <br> <br> <b class="spoiler_title">AssertRange</b> <code class="cpp">namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange</code> <br> <br>         <code>Operator</code>    .          <code>wchar_t</code>   ,         ,      . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', }; typedef Operator Token;</code> <br>    ,   ,        <code>Assert</code> ,    <code>ToString</code> ,    . <br> <br> <b class="spoiler_title">std::wstring ToString(const Token &amp;)</b> <code class="cpp">inline std::wstring ToString(const Token &amp;token) { return{ static_cast&lt;wchar_t&gt;(token) }; }</code> <br> <br>    ,   ,        .  ,   (unconditional ‚Üí if). <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { if(expr.empty()) { return{}; } return{ static_cast&lt;Operator&gt;(expr[0]) }; }</code> <br> <s>         </s> . <s>          .</s>           . ‚Ä¶ <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); }</code> <br>     .   ,     ,   - .    , : <br> <br>        ,      <code>Token</code> .       <code>dynamic_cast</code>    ,   .  ,    ,      .      <code>std::function</code>        .        .  Boost.Any,  - .            . <br>   ,   .      -  .  ,      ,      . <br> <br> ‚Ä¶        .        .        .        . <br>             . <br> <br> <code class="cpp">enum class TokenType { Operator, Number }; class Token { public: Token(Operator) {} TokenType Type() const { return TokenType::Operator; } }; ‚Ä¶ TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } };</code> <br>   <code>ToString</code>   <code>TokenType</code>       ,   ,   .     . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); }</code> <br>   .   (constant ‚Üí scalar)   . <br> <br> <code class="cpp">class Token { public: Token(Operator) :m_type(TokenType::Operator) {} Token(double) :m_type(TokenType::Number) {} TokenType Type() const { return m_type; } private: TokenType m_type; };</code> <br> ‚Ä¶ <s>       </s> . <s>       </s> .        .        . <br>    . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); }</code> <br>            . <br> <br> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} operator Operator() const { return m_operator; } ‚Ä¶ Operator m_operator; };</code> <br>      . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); }</code> <br>          ,  ,       <code>union</code> .         . <br> <br> Token <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: return "Unknown token."; } }</code> <br> <br>  ,    ,      ,    .       .    . <br> <br> <i>          .</i>               .            .       . <br>        : <br> <br> <code class="cpp"> if(expr[0] &gt;= '0' &amp;&amp; expr[0] &lt;= '9') { return{ (double) expr[0] - '0' }; } return{ static_cast&lt;Operator&gt;(expr[0]) };</code> <br>      ,   . <br> <br> ‚Ä¶ <s>          .</s> <i>              .</i> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); }</code> <br> ,     <code>C</code>   ,  <code>isdigit</code> , ,       <code>atof</code> ,    ,      <code>wchar_t</code> .  (expression ‚Üí function).         . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { const wchar_t *current = expr.c_str(); if(!*current) return{}; if(iswdigit(*current)) return{ _wtof(current) }; return{ static_cast&lt;Operator&gt;(*current) }; }</code> <br>         .      . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>   ,        .  ,     .     .   <code>result</code> ,     . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); if(!*current) return result; if(iswdigit(*current)) { result.push_back(_wtof(current)); } else { result.push_back(static_cast&lt;Operator&gt;(*current)); } return result; }</code> <br>      :   (if ‚Üí while).     ,        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } } return result; }</code> <br>  <code>wcstod</code>    ,   <code>_wtof</code> ,           .           ,              .  ,    . <br> <br> <s>           .</s>       . <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>  (unconditional ‚Üí if)    ,    . <br> <br> <code class="cpp"> while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else if(*current == static_cast&lt;wchar_t&gt;(Operator::Plus)) { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } else { ++current; } }</code> <br>       .          .       <code>Detail</code>      .   <code>Tokenize</code>       . <br> <br> <code class="cpp">inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); }</code> <br> <b class="spoiler_title"> Detail::Tokenizer</b> <code class="cpp">namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { return *m_current == static_cast&lt;wchar_t&gt;(Operator::Plus); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail</code> <br> <br>  ,      .      ,  , .       . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); }</code> <br>      <code>Operator</code> ,    . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', };</code> <br>   .         <code>IsOperator</code>  <code>Tokenizer</code> . <br> <br> <code class="cpp"> bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); }</code> <br>         .        . <br> <br> <b class="spoiler_title">Interpreter.h</b> <code class="cpp">#pragma once; #include &lt;vector&gt; #include &lt;wchar.h&gt; #include &lt;algorithm&gt; namespace Interpreter { enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', }; inline std::wstring ToString(const Operator &amp;op) { return{ static_cast&lt;wchar_t&gt;(op) }; } enum class TokenType { Operator, Number }; inline std::wstring ToString(const TokenType &amp;type) { switch(type) { case TokenType::Operator: return L"Operator"; case TokenType::Number: return L"Number"; default: throw std::out_of_range("TokenType"); } } class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } friend inline bool operator==(const Token &amp;left, const Token &amp;right) { if(left.m_type == right.m_type) { switch(left.m_type) { case Interpreter::TokenType::Operator: return left.m_operator == right.m_operator; case Interpreter::TokenType::Number: return left.m_number == right.m_number; default: throw std::out_of_range("TokenType"); } } return false; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: throw std::out_of_range("TokenType"); } } typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); } } // namespace Lexer } // namespace Interpreter</code> <br> <br> <b class="spoiler_title">InterpreterTests.cpp</b> <code class="cpp">#include "stdafx.h" #include "CppUnitTest.h" #include "Interpreter.h" namespace InterpreterTests { using namespace Microsoft::VisualStudio::CppUnitTestFramework; using namespace Interpreter; using namespace std; namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual&lt;T&gt;(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange TEST_CLASS(LexerTests) { public: TEST_METHOD(Should_return_empty_token_list_when_put_empty_expression) { Tokens tokens = Lexer::Tokenize(L""); Assert::IsTrue(tokens.empty()); } TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); } TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); } TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); } TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); } }; TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); } TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); } TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); } }; }</code> <br> <br> <a href="https://github.com/Unril/InterpreterTDD/releases/tag/%25D0%259A%25D0%25BE%25D0%25BD%25D0%25B5%25D1%2586_%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B2%25D0%25BE%25D0%25B9_%25D1%2587%25D0%25B0%25D1%2581%25D1%2582%25D0%25B8">    GitHub</a> .         ,  .      "__". <br> <br>   <a href="http://habrahabr.ru/post/232081/">    </a> .      ,      <a href="http://habrahabr.ru/post/232097/">    </a> .</b></code> <div class="spoiler_text"> <pre> <code class="hljs lua"><code>std::vector,      Tokens</code> .            . <br> <br> <code class="cpp">#pragma once; #include &lt;vector&gt; namespace Interpreter { struct Token {}; typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { inline Tokens Tokenize(std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> expr) { throw std::exception(); } } // namespace Lexer } // namespace Interpreter</code> <br>   ,  ,   , .   ,    ,    <a href="http://cleancoder.posterous.com/the-transformation-priority-premise">The Transformation Priority Premise (TPP)</a>   .    , ,    ,     ,        .            .     ,     ,      ,           .  ,  ,   (   )    ,  ,  .     ,  ,         .     ,   TPP          . <br> <br>   : <br> <br> ({} ‚Üí <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)     ,   . (<span class="hljs-literal"><span class="hljs-literal">nil</span></span> ‚Üí constant)    . (constant ‚Üí constant+)      (        ,  ). (constant ‚Üí scalar)    ,  . (statement ‚Üí statements)    (<span class="hljs-keyword"><span class="hljs-keyword">break</span></span>, continue, <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>  ). (unconditional ‚Üí <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>)       . (scalar ‚Üí array)  / . (array ‚Üí container)     . (statement ‚Üí recursion)   . (<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ‚Üí <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>)    . (expression ‚Üí <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">)</span></span>   . (variable ‚Üí assignment)   . <br>        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> expr) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{}; }</code> <br> ,         .     . <br> <br> <s>         </s> .           .           .               .            .       . <br>  ,  <code>std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span></code>  <code>std::wstring</code> .         ,      Unicode.     . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"+"</span></span>); AssertRange::AreEqual({ Operator::Plus }, tokens); }</code> <br>  <code>AssertRange</code> -   ,       <code>AreEqual</code> ,   ,  ,    . <br> <br> <b class="spoiler_title">AssertRange</b> <code class="cpp">namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(expect)), distance(actualIter, <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(actual)), L<span class="hljs-string"><span class="hljs-string">"Size differs."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(; expectIter != <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(expect) &amp;&amp; actualIter != <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(actual); ++expectIter, ++actualIter) { auto message = L<span class="hljs-string"><span class="hljs-string">"Mismatch in position "</span></span> + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange</code> <br> <br>         <code>Operator</code>    .          <code>wchar_t</code>   ,         ,      . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L<span class="hljs-string"><span class="hljs-string">'+'</span></span>, }; typedef Operator Token;</code> <br>    ,   ,        <code>Assert</code> ,    <code>ToString</code> ,    . <br> <br> <b class="spoiler_title">std::wstring ToString(const Token &amp;)</b> <code class="cpp">inline std::wstring ToString(const Token &amp;token) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ static_cast&lt;wchar_t&gt;(token) }; }</code> <br> <br>    ,   ,        .  ,   (unconditional ‚Üí <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>). <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(expr.empty()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{}; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ static_cast&lt;Operator&gt;(expr[<span class="hljs-number"><span class="hljs-number">0</span></span>]) }; }</code> <br> <s>         </s> . <s>          .</s>           . ‚Ä¶ <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"1"</span></span>); AssertRange::AreEqual({ <span class="hljs-number"><span class="hljs-number">1.0</span></span> }, tokens); }</code> <br>     .   ,     ,   - .    , : <br> <br>        ,      <code>Token</code> .       <code>dynamic_cast</code>    ,   .  ,    ,      .      <code>std::<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span></span></code><span class="hljs-function"><span class="hljs-function">        .        .  </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Boost.Any</span></span></span><span class="hljs-function">,  - .            . </span></span><br><span class="hljs-function"><span class="hljs-function">   ,   .      -  .  ,      ,      . </span></span><br><span class="hljs-function"><span class="hljs-function"> </span></span><br><span class="hljs-function"><span class="hljs-function"> ‚Ä¶        .        .        .        . </span></span><br><span class="hljs-function"><span class="hljs-function">             . </span></span><br><span class="hljs-function"><span class="hljs-function"> </span></span><br><span class="hljs-function"><span class="hljs-function"> </span></span><code class="cpp"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">enum</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">class</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TokenType</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Operator</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Number</span></span></span><span class="hljs-function"> }; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">class</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Token</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">public</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Token</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Operator)</span></span></span></span> {} TokenType Type() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TokenType::Operator; } }; ‚Ä¶ TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } };</code> <br>   <code>ToString</code>   <code>TokenType</code>       ,   ,   .     . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_type_for_number_token) { Token numToken(<span class="hljs-number"><span class="hljs-number">1.2</span></span>); Assert::AreEqual(TokenType::Number, numToken.Type()); }</code> <br>   .   (constant ‚Üí scalar)   . <br> <br> <code class="cpp">class Token { public: Token(Operator) :m_type(TokenType::Operator) {} Token(double) :m_type(TokenType::Number) {} TokenType Type() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_type; } private: TokenType m_type; };</code> <br> ‚Ä¶ <s>       </s> . <s>       </s> .        .        . <br>    . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); }</code> <br>            . <br> <br> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} operator Operator() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_operator; } ‚Ä¶ Operator m_operator; };</code> <br>      . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_number_value_from_number_token) { Token token(<span class="hljs-number"><span class="hljs-number">1.23</span></span>); Assert::AreEqual&lt;double&gt;(<span class="hljs-number"><span class="hljs-number">1.23</span></span>, token); }</code> <br>          ,  ,       <code>union</code> .         . <br> <br> <b class="spoiler_title">Token</b> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_type; } operator Operator() const { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(m_type != TokenType::Operator) throw std::logic_error(<span class="hljs-string"><span class="hljs-string">"Should be operator token."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_operator; } operator double() const { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(m_type != TokenType::Number) throw std::logic_error(<span class="hljs-string"><span class="hljs-string">"Should be number token."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_number; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ToString(static_cast&lt;Operator&gt;(token)); default: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Unknown token."</span></span>; } }</code> <br> <br>  ,    ,      ,    .       .    . <br> <br> <i>          .</i>               .            .       . <br>        : <br> <br> <code class="cpp"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(expr[<span class="hljs-number"><span class="hljs-number">0</span></span>] &gt;= <span class="hljs-string"><span class="hljs-string">'0'</span></span> &amp;&amp; expr[<span class="hljs-number"><span class="hljs-number">0</span></span>] &lt;= <span class="hljs-string"><span class="hljs-string">'9'</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ (double) expr[<span class="hljs-number"><span class="hljs-number">0</span></span>] - <span class="hljs-string"><span class="hljs-string">'0'</span></span> }; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ static_cast&lt;Operator&gt;(expr[<span class="hljs-number"><span class="hljs-number">0</span></span>]) };</code> <br>      ,   . <br> <br> ‚Ä¶ <s>          .</s> <i>              .</i> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"12.34"</span></span>); AssertRange::AreEqual({ <span class="hljs-number"><span class="hljs-number">12.34</span></span> }, tokens); }</code> <br> ,     <code>C</code>   ,  <code>isdigit</code> , ,       <code>atof</code> ,    ,      <code>wchar_t</code> .  (expression ‚Üí <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">)</span></span>.         . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { const wchar_t *current = expr.c_str(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!*current) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{}; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(iswdigit(*current)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ _wtof(current) }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ static_cast&lt;Operator&gt;(*current) }; }</code> <br>         .      . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"+12.34"</span></span>); AssertRange::AreEqual({ Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">12.34</span></span>) }, tokens); }</code> <br>   ,        .  ,     .     .   <code>result</code> ,     . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!*current) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(iswdigit(*current)) { result.push_back(_wtof(current)); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { result.push_back(static_cast&lt;Operator&gt;(*current)); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> <br>      :   (<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ‚Üí <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>).     ,        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(*current) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(iswdigit(*current)) { wchar_t *<span class="hljs-keyword"><span class="hljs-keyword">end</span></span> = nullptr; result.push_back(wcstod(current, &amp;<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>)); current = <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> <br>  <code>wcstod</code>    ,   <code>_wtof</code> ,           .           ,              .  ,    . <br> <br> <s>           .</s>       . <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">" 1 + 12.34 "</span></span>); AssertRange::AreEqual({ Token(<span class="hljs-number"><span class="hljs-number">1.0</span></span>), Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">12.34</span></span>) }, tokens); }</code> <br>  (unconditional ‚Üí <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>)    ,    . <br> <br> <code class="cpp"> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(*current) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(iswdigit(*current)) { wchar_t *<span class="hljs-keyword"><span class="hljs-keyword">end</span></span> = nullptr; result.push_back(wcstod(current, &amp;<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>)); current = <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(*current == static_cast&lt;wchar_t&gt;(Operator::Plus)) { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { ++current; } }</code> <br>       .          .       <code>Detail</code>      .   <code>Tokenize</code>       . <br> <br> <code class="cpp">inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tokenizer.Result(); }</code> <br> <b class="spoiler_title"> Detail::Tokenizer</b> <code class="cpp">namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!EndOfExperssion()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(IsNumber()) { ScanNumber(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(IsOperator()) { ScanOperator(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { MoveNext(); } } } const Tokens &amp;Result() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_result; } private: bool EndOfExperssion() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_current == L<span class="hljs-string"><span class="hljs-string">'\0'</span></span>; } bool IsNumber() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> iswdigit(*m_current) != <span class="hljs-number"><span class="hljs-number">0</span></span>; } void ScanNumber() { wchar_t *<span class="hljs-keyword"><span class="hljs-keyword">end</span></span> = nullptr; m_result.push_back(wcstod(m_current, &amp;<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>)); m_current = <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; } bool IsOperator() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_current == static_cast&lt;wchar_t&gt;(Operator::Plus); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail</code> <br> <br>  ,      .      ,  , .       . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"1+2*3/(4-5)"</span></span>); AssertRange::AreEqual({ Token(<span class="hljs-number"><span class="hljs-number">1</span></span>), Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">2</span></span>), Token(Operator::Mul), Token(<span class="hljs-number"><span class="hljs-number">3</span></span>), Token(Operator::Div), Token(Operator::LParen), Token(<span class="hljs-number"><span class="hljs-number">4</span></span>), Token(Operator::Minus), Token(<span class="hljs-number"><span class="hljs-number">5</span></span>), Token(Operator::RParen) }, tokens); }</code> <br>      <code>Operator</code> ,    . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L<span class="hljs-string"><span class="hljs-string">'+'</span></span>, Minus = L<span class="hljs-string"><span class="hljs-string">'-'</span></span>, Mul = L<span class="hljs-string"><span class="hljs-string">'*'</span></span>, Div = L<span class="hljs-string"><span class="hljs-string">'/'</span></span>, LParen = L<span class="hljs-string"><span class="hljs-string">'('</span></span>, RParen = L<span class="hljs-string"><span class="hljs-string">')'</span></span>, };</code> <br>   .         <code>IsOperator</code>  <code>Tokenizer</code> . <br> <br> <code class="cpp"> bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> std::any_of(all.begin(), all.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(), [this](Operator o) {<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_current == static_cast&lt;wchar_t&gt;(o); }); }</code> <br>         .        . <br> <br> <b class="spoiler_title">Interpreter.h</b> <code class="cpp">#pragma once; #include &lt;vector&gt; #include &lt;wchar.h&gt; #include &lt;algorithm&gt; namespace Interpreter { enum class Operator : wchar_t { Plus = L<span class="hljs-string"><span class="hljs-string">'+'</span></span>, Minus = L<span class="hljs-string"><span class="hljs-string">'-'</span></span>, Mul = L<span class="hljs-string"><span class="hljs-string">'*'</span></span>, Div = L<span class="hljs-string"><span class="hljs-string">'/'</span></span>, LParen = L<span class="hljs-string"><span class="hljs-string">'('</span></span>, RParen = L<span class="hljs-string"><span class="hljs-string">')'</span></span>, }; inline std::wstring ToString(const Operator &amp;op) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ static_cast&lt;wchar_t&gt;(op) }; } enum class TokenType { Operator, Number }; inline std::wstring ToString(const TokenType &amp;<span class="hljs-built_in"><span class="hljs-built_in">type</span></span>) { switch(<span class="hljs-built_in"><span class="hljs-built_in">type</span></span>) { case TokenType::Operator: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> L<span class="hljs-string"><span class="hljs-string">"Operator"</span></span>; case TokenType::Number: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> L<span class="hljs-string"><span class="hljs-string">"Number"</span></span>; default: throw std::out_of_range(<span class="hljs-string"><span class="hljs-string">"TokenType"</span></span>); } } class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_type; } operator Operator() const { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(m_type != TokenType::Operator) throw std::logic_error(<span class="hljs-string"><span class="hljs-string">"Should be operator token."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_operator; } operator double() const { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(m_type != TokenType::Number) throw std::logic_error(<span class="hljs-string"><span class="hljs-string">"Should be number token."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_number; } friend inline bool operator==(const Token &amp;left, const Token &amp;right) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(left.m_type == right.m_type) { switch(left.m_type) { case Interpreter::TokenType::Operator: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> left.m_operator == right.m_operator; case Interpreter::TokenType::Number: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> left.m_number == right.m_number; default: throw std::out_of_range(<span class="hljs-string"><span class="hljs-string">"TokenType"</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ToString(static_cast&lt;Operator&gt;(token)); default: throw std::out_of_range(<span class="hljs-string"><span class="hljs-string">"TokenType"</span></span>); } } typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!EndOfExperssion()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(IsNumber()) { ScanNumber(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(IsOperator()) { ScanOperator(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { MoveNext(); } } } const Tokens &amp;Result() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_result; } private: bool EndOfExperssion() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_current == L<span class="hljs-string"><span class="hljs-string">'\0'</span></span>; } bool IsNumber() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> iswdigit(*m_current) != <span class="hljs-number"><span class="hljs-number">0</span></span>; } void ScanNumber() { wchar_t *<span class="hljs-keyword"><span class="hljs-keyword">end</span></span> = nullptr; m_result.push_back(wcstod(m_current, &amp;<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>)); m_current = <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; } bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> std::any_of(all.begin(), all.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(), [this](Operator o) {<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_current == static_cast&lt;wchar_t&gt;(o); }); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tokenizer.Result(); } } // namespace Lexer } // namespace Interpreter</code> <br> <br> <b class="spoiler_title">InterpreterTests.cpp</b> <code class="cpp">#include <span class="hljs-string"><span class="hljs-string">"stdafx.h"</span></span> #include <span class="hljs-string"><span class="hljs-string">"CppUnitTest.h"</span></span> #include <span class="hljs-string"><span class="hljs-string">"Interpreter.h"</span></span> namespace InterpreterTests { using namespace Microsoft::VisualStudio::CppUnitTestFramework; using namespace Interpreter; using namespace std; namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(expect)), distance(actualIter, <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(actual)), L<span class="hljs-string"><span class="hljs-string">"Size differs."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(; expectIter != <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(expect) &amp;&amp; actualIter != <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(actual); ++expectIter, ++actualIter) { auto message = L<span class="hljs-string"><span class="hljs-string">"Mismatch in position "</span></span> + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual&lt;T&gt;(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange TEST_CLASS(LexerTests) { public: TEST_METHOD(Should_return_empty_token_list_when_put_empty_expression) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">""</span></span>); Assert::IsTrue(tokens.empty()); } TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"+"</span></span>); AssertRange::AreEqual({ Operator::Plus }, tokens); } TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"1"</span></span>); AssertRange::AreEqual({ <span class="hljs-number"><span class="hljs-number">1.0</span></span> }, tokens); } TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"12.34"</span></span>); AssertRange::AreEqual({ <span class="hljs-number"><span class="hljs-number">12.34</span></span> }, tokens); } TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"+12.34"</span></span>); AssertRange::AreEqual({ Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">12.34</span></span>) }, tokens); } TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">" 1 + 12.34 "</span></span>); AssertRange::AreEqual({ Token(<span class="hljs-number"><span class="hljs-number">1.0</span></span>), Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">12.34</span></span>) }, tokens); } TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"1+2*3/(4-5)"</span></span>); AssertRange::AreEqual({ Token(<span class="hljs-number"><span class="hljs-number">1</span></span>), Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">2</span></span>), Token(Operator::Mul), Token(<span class="hljs-number"><span class="hljs-number">3</span></span>), Token(Operator::Div), Token(Operator::LParen), Token(<span class="hljs-number"><span class="hljs-number">4</span></span>), Token(Operator::Minus), Token(<span class="hljs-number"><span class="hljs-number">5</span></span>), Token(Operator::RParen) }, tokens); } }; TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } TEST_METHOD(Should_get_type_for_number_token) { Token numToken(<span class="hljs-number"><span class="hljs-number">1.2</span></span>); Assert::AreEqual(TokenType::Number, numToken.Type()); } TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); } TEST_METHOD(Should_get_number_value_from_number_token) { Token token(<span class="hljs-number"><span class="hljs-number">1.23</span></span>); Assert::AreEqual&lt;double&gt;(<span class="hljs-number"><span class="hljs-number">1.23</span></span>, token); } }; }</code> <br> <br> <a href="https://github.com/Unril/InterpreterTDD/releases/tag/%25D0%259A%25D0%25BE%25D0%25BD%25D0%25B5%25D1%2586_%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B2%25D0%25BE%25D0%25B9_%25D1%2587%25D0%25B0%25D1%2581%25D1%2582%25D0%25B8">    GitHub</a> .         ,  .      <span class="hljs-string"><span class="hljs-string">"__"</span></span>. <br> <br>   <a href="http://habrahabr.ru/post/232081/">    </a> .      ,      <a href="http://habrahabr.ru/post/232097/">    </a> .</code> </pre> <code><code>std::vector,      Tokens</code> .            . <br> <br> <code class="cpp">#pragma once; #include &lt;vector&gt; namespace Interpreter { struct Token {}; typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { inline Tokens Tokenize(std::string expr) { throw std::exception(); } } // namespace Lexer } // namespace Interpreter</code> <br>   ,  ,   , .   ,    ,    <a href="http://cleancoder.posterous.com/the-transformation-priority-premise">The Transformation Priority Premise (TPP)</a>   .    , ,    ,     ,        .            .     ,     ,      ,           .  ,  ,   (   )    ,  ,  .     ,  ,         .     ,   TPP          . <br> <br>   : <br> <br> ({} ‚Üí nil)     ,   . (nil ‚Üí constant)    . (constant ‚Üí constant+)      (        ,  ). (constant ‚Üí scalar)    ,  . (statement ‚Üí statements)    (break, continue, return  ). (unconditional ‚Üí if)       . (scalar ‚Üí array)  / . (array ‚Üí container)     . (statement ‚Üí recursion)   . (if ‚Üí while)    . (expression ‚Üí function)   . (variable ‚Üí assignment)   . <br>        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::string expr) { return{}; }</code> <br> ,         .     . <br> <br> <s>         </s> .           .           .               .            .       . <br>  ,  <code>std::string</code>  <code>std::wstring</code> .         ,      Unicode.     . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); }</code> <br>  <code>AssertRange</code> -   ,       <code>AreEqual</code> ,   ,  ,    . <br> <br> <b class="spoiler_title">AssertRange</b> <code class="cpp">namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange</code> <br> <br>         <code>Operator</code>    .          <code>wchar_t</code>   ,         ,      . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', }; typedef Operator Token;</code> <br>    ,   ,        <code>Assert</code> ,    <code>ToString</code> ,    . <br> <br> <b class="spoiler_title">std::wstring ToString(const Token &amp;)</b> <code class="cpp">inline std::wstring ToString(const Token &amp;token) { return{ static_cast&lt;wchar_t&gt;(token) }; }</code> <br> <br>    ,   ,        .  ,   (unconditional ‚Üí if). <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { if(expr.empty()) { return{}; } return{ static_cast&lt;Operator&gt;(expr[0]) }; }</code> <br> <s>         </s> . <s>          .</s>           . ‚Ä¶ <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); }</code> <br>     .   ,     ,   - .    , : <br> <br>        ,      <code>Token</code> .       <code>dynamic_cast</code>    ,   .  ,    ,      .      <code>std::function</code>        .        .  Boost.Any,  - .            . <br>   ,   .      -  .  ,      ,      . <br> <br> ‚Ä¶        .        .        .        . <br>             . <br> <br> <code class="cpp">enum class TokenType { Operator, Number }; class Token { public: Token(Operator) {} TokenType Type() const { return TokenType::Operator; } }; ‚Ä¶ TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } };</code> <br>   <code>ToString</code>   <code>TokenType</code>       ,   ,   .     . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); }</code> <br>   .   (constant ‚Üí scalar)   . <br> <br> <code class="cpp">class Token { public: Token(Operator) :m_type(TokenType::Operator) {} Token(double) :m_type(TokenType::Number) {} TokenType Type() const { return m_type; } private: TokenType m_type; };</code> <br> ‚Ä¶ <s>       </s> . <s>       </s> .        .        . <br>    . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); }</code> <br>            . <br> <br> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} operator Operator() const { return m_operator; } ‚Ä¶ Operator m_operator; };</code> <br>      . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); }</code> <br>          ,  ,       <code>union</code> .         . <br> <br> <b class="spoiler_title">Token</b> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: return "Unknown token."; } }</code> <br> <br>  ,    ,      ,    .       .    . <br> <br> <i>          .</i>               .            .       . <br>        : <br> <br> <code class="cpp"> if(expr[0] &gt;= '0' &amp;&amp; expr[0] &lt;= '9') { return{ (double) expr[0] - '0' }; } return{ static_cast&lt;Operator&gt;(expr[0]) };</code> <br>      ,   . <br> <br> ‚Ä¶ <s>          .</s> <i>              .</i> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); }</code> <br> ,     <code>C</code>   ,  <code>isdigit</code> , ,       <code>atof</code> ,    ,      <code>wchar_t</code> .  (expression ‚Üí function).         . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { const wchar_t *current = expr.c_str(); if(!*current) return{}; if(iswdigit(*current)) return{ _wtof(current) }; return{ static_cast&lt;Operator&gt;(*current) }; }</code> <br>         .      . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>   ,        .  ,     .     .   <code>result</code> ,     . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); if(!*current) return result; if(iswdigit(*current)) { result.push_back(_wtof(current)); } else { result.push_back(static_cast&lt;Operator&gt;(*current)); } return result; }</code> <br>      :   (if ‚Üí while).     ,        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } } return result; }</code> <br>  <code>wcstod</code>    ,   <code>_wtof</code> ,           .           ,              .  ,    . <br> <br> <s>           .</s>       . <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>  (unconditional ‚Üí if)    ,    . <br> <br> <code class="cpp"> while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else if(*current == static_cast&lt;wchar_t&gt;(Operator::Plus)) { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } else { ++current; } }</code> <br>       .          .       <code>Detail</code>      .   <code>Tokenize</code>       . <br> <br> <code class="cpp">inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); }</code> <br> <b class="spoiler_title"> Detail::Tokenizer</b> <code class="cpp">namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { return *m_current == static_cast&lt;wchar_t&gt;(Operator::Plus); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail</code> <br> <br>  ,      .      ,  , .       . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); }</code> <br>      <code>Operator</code> ,    . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', };</code> <br>   .         <code>IsOperator</code>  <code>Tokenizer</code> . <br> <br> <code class="cpp"> bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); }</code> <br>         .        . <br> <br> <b class="spoiler_title">Interpreter.h</b> <code class="cpp">#pragma once; #include &lt;vector&gt; #include &lt;wchar.h&gt; #include &lt;algorithm&gt; namespace Interpreter { enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', }; inline std::wstring ToString(const Operator &amp;op) { return{ static_cast&lt;wchar_t&gt;(op) }; } enum class TokenType { Operator, Number }; inline std::wstring ToString(const TokenType &amp;type) { switch(type) { case TokenType::Operator: return L"Operator"; case TokenType::Number: return L"Number"; default: throw std::out_of_range("TokenType"); } } class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } friend inline bool operator==(const Token &amp;left, const Token &amp;right) { if(left.m_type == right.m_type) { switch(left.m_type) { case Interpreter::TokenType::Operator: return left.m_operator == right.m_operator; case Interpreter::TokenType::Number: return left.m_number == right.m_number; default: throw std::out_of_range("TokenType"); } } return false; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: throw std::out_of_range("TokenType"); } } typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); } } // namespace Lexer } // namespace Interpreter</code> <br> <br> <b class="spoiler_title">InterpreterTests.cpp</b> <code class="cpp">#include "stdafx.h" #include "CppUnitTest.h" #include "Interpreter.h" namespace InterpreterTests { using namespace Microsoft::VisualStudio::CppUnitTestFramework; using namespace Interpreter; using namespace std; namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual&lt;T&gt;(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange TEST_CLASS(LexerTests) { public: TEST_METHOD(Should_return_empty_token_list_when_put_empty_expression) { Tokens tokens = Lexer::Tokenize(L""); Assert::IsTrue(tokens.empty()); } TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); } TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); } TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); } TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); } }; TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); } TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); } TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); } }; }</code> <br> <br> <a href="https://github.com/Unril/InterpreterTDD/releases/tag/%25D0%259A%25D0%25BE%25D0%25BD%25D0%25B5%25D1%2586_%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B2%25D0%25BE%25D0%25B9_%25D1%2587%25D0%25B0%25D1%2581%25D1%2582%25D0%25B8">    GitHub</a> .         ,  .      "__". <br> <br>   <a href="http://habrahabr.ru/post/232081/">    </a> .      ,      <a href="http://habrahabr.ru/post/232097/">    </a> .</code> </div></div> <code><code>std::vector,      Tokens</code> .            . <br> <br> <code class="cpp">#pragma once; #include &lt;vector&gt; namespace Interpreter { struct Token {}; typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { inline Tokens Tokenize(std::string expr) { throw std::exception(); } } // namespace Lexer } // namespace Interpreter</code> <br>   ,  ,   , .   ,    ,    <a href="http://cleancoder.posterous.com/the-transformation-priority-premise">The Transformation Priority Premise (TPP)</a>   .    , ,    ,     ,        .            .     ,     ,      ,           .  ,  ,   (   )    ,  ,  .     ,  ,         .     ,   TPP          . <br> <br>   : <br> <br> ({} ‚Üí nil)     ,   . (nil ‚Üí constant)    . (constant ‚Üí constant+)      (        ,  ). (constant ‚Üí scalar)    ,  . (statement ‚Üí statements)    (break, continue, return  ). (unconditional ‚Üí if)       . (scalar ‚Üí array)  / . (array ‚Üí container)     . (statement ‚Üí recursion)   . (if ‚Üí while)    . (expression ‚Üí function)   . (variable ‚Üí assignment)   . <br>        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::string expr) { return{}; }</code> <br> ,         .     . <br> <br> <s>         </s> .           .           .               .            .       . <br>  ,  <code>std::string</code>  <code>std::wstring</code> .         ,      Unicode.     . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); }</code> <br>  <code>AssertRange</code> -   ,       <code>AreEqual</code> ,   ,  ,    . <br> <br> <b class="spoiler_title">AssertRange</b> <code class="cpp">namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange</code> <br> <br>         <code>Operator</code>    .          <code>wchar_t</code>   ,         ,      . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', }; typedef Operator Token;</code> <br>    ,   ,        <code>Assert</code> ,    <code>ToString</code> ,    . <br> <br> <b class="spoiler_title">std::wstring ToString(const Token &amp;)</b> <code class="cpp">inline std::wstring ToString(const Token &amp;token) { return{ static_cast&lt;wchar_t&gt;(token) }; }</code> <br> <br>    ,   ,        .  ,   (unconditional ‚Üí if). <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { if(expr.empty()) { return{}; } return{ static_cast&lt;Operator&gt;(expr[0]) }; }</code> <br> <s>         </s> . <s>          .</s>           . ‚Ä¶ <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); }</code> <br>     .   ,     ,   - .    , : <br> <br>        ,      <code>Token</code> .       <code>dynamic_cast</code>    ,   .  ,    ,      .      <code>std::function</code>        .        .  Boost.Any,  - .            . <br>   ,   .      -  .  ,      ,      . <br> <br> ‚Ä¶        .        .        .        . <br>             . <br> <br> <code class="cpp">enum class TokenType { Operator, Number }; class Token { public: Token(Operator) {} TokenType Type() const { return TokenType::Operator; } }; ‚Ä¶ TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } };</code> <br>   <code>ToString</code>   <code>TokenType</code>       ,   ,   .     . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); }</code> <br>   .   (constant ‚Üí scalar)   . <br> <br> <code class="cpp">class Token { public: Token(Operator) :m_type(TokenType::Operator) {} Token(double) :m_type(TokenType::Number) {} TokenType Type() const { return m_type; } private: TokenType m_type; };</code> <br> ‚Ä¶ <s>       </s> . <s>       </s> .        .        . <br>    . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); }</code> <br>            . <br> <br> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} operator Operator() const { return m_operator; } ‚Ä¶ Operator m_operator; };</code> <br>      . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); }</code> <br>          ,  ,       <code>union</code> .         . <br> <br> <b class="spoiler_title">Token</b> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: return "Unknown token."; } }</code> <br> <br>  ,    ,      ,    .       .    . <br> <br> <i>          .</i>               .            .       . <br>        : <br> <br> <code class="cpp"> if(expr[0] &gt;= '0' &amp;&amp; expr[0] &lt;= '9') { return{ (double) expr[0] - '0' }; } return{ static_cast&lt;Operator&gt;(expr[0]) };</code> <br>      ,   . <br> <br> ‚Ä¶ <s>          .</s> <i>              .</i> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); }</code> <br> ,     <code>C</code>   ,  <code>isdigit</code> , ,       <code>atof</code> ,    ,      <code>wchar_t</code> .  (expression ‚Üí function).         . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { const wchar_t *current = expr.c_str(); if(!*current) return{}; if(iswdigit(*current)) return{ _wtof(current) }; return{ static_cast&lt;Operator&gt;(*current) }; }</code> <br>         .      . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>   ,        .  ,     .     .   <code>result</code> ,     . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); if(!*current) return result; if(iswdigit(*current)) { result.push_back(_wtof(current)); } else { result.push_back(static_cast&lt;Operator&gt;(*current)); } return result; }</code> <br>      :   (if ‚Üí while).     ,        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } } return result; }</code> <br>  <code>wcstod</code>    ,   <code>_wtof</code> ,           .           ,              .  ,    . <br> <br> <s>           .</s>       . <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>  (unconditional ‚Üí if)    ,    . <br> <br> <code class="cpp"> while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else if(*current == static_cast&lt;wchar_t&gt;(Operator::Plus)) { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } else { ++current; } }</code> <br>       .          .       <code>Detail</code>      .   <code>Tokenize</code>       . <br> <br> <code class="cpp">inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); }</code> <br> <b class="spoiler_title"> Detail::Tokenizer</b> <code class="cpp">namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { return *m_current == static_cast&lt;wchar_t&gt;(Operator::Plus); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail</code> <br> <br>  ,      .      ,  , .       . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); }</code> <br>      <code>Operator</code> ,    . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', };</code> <br>   .         <code>IsOperator</code>  <code>Tokenizer</code> . <br> <br> <code class="cpp"> bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); }</code> <br>         .        . <br> <br> <b class="spoiler_title">Interpreter.h</b> <code class="cpp">#pragma once; #include &lt;vector&gt; #include &lt;wchar.h&gt; #include &lt;algorithm&gt; namespace Interpreter { enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', }; inline std::wstring ToString(const Operator &amp;op) { return{ static_cast&lt;wchar_t&gt;(op) }; } enum class TokenType { Operator, Number }; inline std::wstring ToString(const TokenType &amp;type) { switch(type) { case TokenType::Operator: return L"Operator"; case TokenType::Number: return L"Number"; default: throw std::out_of_range("TokenType"); } } class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } friend inline bool operator==(const Token &amp;left, const Token &amp;right) { if(left.m_type == right.m_type) { switch(left.m_type) { case Interpreter::TokenType::Operator: return left.m_operator == right.m_operator; case Interpreter::TokenType::Number: return left.m_number == right.m_number; default: throw std::out_of_range("TokenType"); } } return false; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: throw std::out_of_range("TokenType"); } } typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); } } // namespace Lexer } // namespace Interpreter</code> <br> <br> <b class="spoiler_title">InterpreterTests.cpp</b> <code class="cpp">#include "stdafx.h" #include "CppUnitTest.h" #include "Interpreter.h" namespace InterpreterTests { using namespace Microsoft::VisualStudio::CppUnitTestFramework; using namespace Interpreter; using namespace std; namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual&lt;T&gt;(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange TEST_CLASS(LexerTests) { public: TEST_METHOD(Should_return_empty_token_list_when_put_empty_expression) { Tokens tokens = Lexer::Tokenize(L""); Assert::IsTrue(tokens.empty()); } TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); } TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); } TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); } TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); } }; TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); } TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); } TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); } }; }</code> <br> <br> <a href="https://github.com/Unril/InterpreterTDD/releases/tag/%25D0%259A%25D0%25BE%25D0%25BD%25D0%25B5%25D1%2586_%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B2%25D0%25BE%25D0%25B9_%25D1%2587%25D0%25B0%25D1%2581%25D1%2582%25D0%25B8">    GitHub</a> .         ,  .      "__". <br> <br>   <a href="http://habrahabr.ru/post/232081/">    </a> .      ,      <a href="http://habrahabr.ru/post/232097/">    </a> .</code> <ul><li> <code><i><code>std::vector,      Tokens</code> .            . <br> <br> <code class="cpp">#pragma once; #include &lt;vector&gt; namespace Interpreter { struct Token {}; typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { inline Tokens Tokenize(std::string expr) { throw std::exception(); } } // namespace Lexer } // namespace Interpreter</code> <br>   ,  ,   , .   ,    ,    <a href="http://cleancoder.posterous.com/the-transformation-priority-premise">The Transformation Priority Premise (TPP)</a>   .    , ,    ,     ,        .            .     ,     ,      ,           .  ,  ,   (   )    ,  ,  .     ,  ,         .     ,   TPP          . <br> <br>   : <br> <br> ({} ‚Üí nil)     ,   . (nil ‚Üí constant)    . (constant ‚Üí constant+)      (        ,  ). (constant ‚Üí scalar)    ,  . (statement ‚Üí statements)    (break, continue, return  ). (unconditional ‚Üí if)       . (scalar ‚Üí array)  / . (array ‚Üí container)     . (statement ‚Üí recursion)   . (if ‚Üí while)    . (expression ‚Üí function)   . (variable ‚Üí assignment)   . <br>        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::string expr) { return{}; }</code> <br> ,         .     . <br> <br> <s>         </s> .           .           .               .            .       . <br>  ,  <code>std::string</code>  <code>std::wstring</code> .         ,      Unicode.     . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); }</code> <br>  <code>AssertRange</code> -   ,       <code>AreEqual</code> ,   ,  ,    . <br> <br> <b class="spoiler_title">AssertRange</b> <code class="cpp">namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange</code> <br> <br>         <code>Operator</code>    .          <code>wchar_t</code>   ,         ,      . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', }; typedef Operator Token;</code> <br>    ,   ,        <code>Assert</code> ,    <code>ToString</code> ,    . <br> <br> <b class="spoiler_title">std::wstring ToString(const Token &amp;)</b> <code class="cpp">inline std::wstring ToString(const Token &amp;token) { return{ static_cast&lt;wchar_t&gt;(token) }; }</code> <br> <br>    ,   ,        .  ,   (unconditional ‚Üí if). <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { if(expr.empty()) { return{}; } return{ static_cast&lt;Operator&gt;(expr[0]) }; }</code> <br> <s>         </s> . <s>          .</s>           . ‚Ä¶ <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); }</code> <br>     .   ,     ,   - .    , : <br> <br>        ,      <code>Token</code> .       <code>dynamic_cast</code>    ,   .  ,    ,      .      <code>std::function</code>        .        .  Boost.Any,  - .            . <br>   ,   .      -  .  ,      ,      . <br> <br> ‚Ä¶        .        .        .        . <br>             . <br> <br> <code class="cpp">enum class TokenType { Operator, Number }; class Token { public: Token(Operator) {} TokenType Type() const { return TokenType::Operator; } }; ‚Ä¶ TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } };</code> <br>   <code>ToString</code>   <code>TokenType</code>       ,   ,   .     . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); }</code> <br>   .   (constant ‚Üí scalar)   . <br> <br> <code class="cpp">class Token { public: Token(Operator) :m_type(TokenType::Operator) {} Token(double) :m_type(TokenType::Number) {} TokenType Type() const { return m_type; } private: TokenType m_type; };</code> <br> ‚Ä¶ <s>       </s> . <s>       </s> .        .        . <br>    . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); }</code> <br>            . <br> <br> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} operator Operator() const { return m_operator; } ‚Ä¶ Operator m_operator; };</code> <br>      . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); }</code> <br>          ,  ,       <code>union</code> .         . <br> <br> <b class="spoiler_title">Token</b> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: return "Unknown token."; } }</code> <br> <br>  ,    ,      ,    .       .    . <br> <br>           .               .            .       . <br>        : <br> <br> <code class="cpp"> if(expr[0] &gt;= '0' &amp;&amp; expr[0] &lt;= '9') { return{ (double) expr[0] - '0' }; } return{ static_cast&lt;Operator&gt;(expr[0]) };</code> <br>      ,   . <br> <br> ‚Ä¶ <s>          .</s> <i>              .</i> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); }</code> <br> ,     <code>C</code>   ,  <code>isdigit</code> , ,       <code>atof</code> ,    ,      <code>wchar_t</code> .  (expression ‚Üí function).         . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { const wchar_t *current = expr.c_str(); if(!*current) return{}; if(iswdigit(*current)) return{ _wtof(current) }; return{ static_cast&lt;Operator&gt;(*current) }; }</code> <br>         .      . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>   ,        .  ,     .     .   <code>result</code> ,     . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); if(!*current) return result; if(iswdigit(*current)) { result.push_back(_wtof(current)); } else { result.push_back(static_cast&lt;Operator&gt;(*current)); } return result; }</code> <br>      :   (if ‚Üí while).     ,        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } } return result; }</code> <br>  <code>wcstod</code>    ,   <code>_wtof</code> ,           .           ,              .  ,    . <br> <br> <s>           .</s>       . <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>  (unconditional ‚Üí if)    ,    . <br> <br> <code class="cpp"> while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else if(*current == static_cast&lt;wchar_t&gt;(Operator::Plus)) { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } else { ++current; } }</code> <br>       .          .       <code>Detail</code>      .   <code>Tokenize</code>       . <br> <br> <code class="cpp">inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); }</code> <br> <b class="spoiler_title"> Detail::Tokenizer</b> <code class="cpp">namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { return *m_current == static_cast&lt;wchar_t&gt;(Operator::Plus); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail</code> <br> <br>  ,      .      ,  , .       . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); }</code> <br>      <code>Operator</code> ,    . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', };</code> <br>   .         <code>IsOperator</code>  <code>Tokenizer</code> . <br> <br> <code class="cpp"> bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); }</code> <br>         .        . <br> <br> <b class="spoiler_title">Interpreter.h</b> <code class="cpp">#pragma once; #include &lt;vector&gt; #include &lt;wchar.h&gt; #include &lt;algorithm&gt; namespace Interpreter { enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', }; inline std::wstring ToString(const Operator &amp;op) { return{ static_cast&lt;wchar_t&gt;(op) }; } enum class TokenType { Operator, Number }; inline std::wstring ToString(const TokenType &amp;type) { switch(type) { case TokenType::Operator: return L"Operator"; case TokenType::Number: return L"Number"; default: throw std::out_of_range("TokenType"); } } class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } friend inline bool operator==(const Token &amp;left, const Token &amp;right) { if(left.m_type == right.m_type) { switch(left.m_type) { case Interpreter::TokenType::Operator: return left.m_operator == right.m_operator; case Interpreter::TokenType::Number: return left.m_number == right.m_number; default: throw std::out_of_range("TokenType"); } } return false; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: throw std::out_of_range("TokenType"); } } typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); } } // namespace Lexer } // namespace Interpreter</code> <br> <br> <b class="spoiler_title">InterpreterTests.cpp</b> <code class="cpp">#include "stdafx.h" #include "CppUnitTest.h" #include "Interpreter.h" namespace InterpreterTests { using namespace Microsoft::VisualStudio::CppUnitTestFramework; using namespace Interpreter; using namespace std; namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual&lt;T&gt;(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange TEST_CLASS(LexerTests) { public: TEST_METHOD(Should_return_empty_token_list_when_put_empty_expression) { Tokens tokens = Lexer::Tokenize(L""); Assert::IsTrue(tokens.empty()); } TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); } TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); } TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); } TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); } }; TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); } TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); } TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); } }; }</code> <br> <br> <a href="https://github.com/Unril/InterpreterTDD/releases/tag/%25D0%259A%25D0%25BE%25D0%25BD%25D0%25B5%25D1%2586_%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B2%25D0%25BE%25D0%25B9_%25D1%2587%25D0%25B0%25D1%2581%25D1%2582%25D0%25B8">    GitHub</a> .         ,  .      "__". <br> <br>   <a href="http://habrahabr.ru/post/232081/">    </a> .      ,      <a href="http://habrahabr.ru/post/232097/">    </a> .</i></code> </li> <li> <code><code>std::vector,      Tokens</code> .            . <br> <br> <code class="cpp">#pragma once; #include &lt;vector&gt; namespace Interpreter { struct Token {}; typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { inline Tokens Tokenize(std::string expr) { throw std::exception(); } } // namespace Lexer } // namespace Interpreter</code> <br>   ,  ,   , .   ,    ,    <a href="http://cleancoder.posterous.com/the-transformation-priority-premise">The Transformation Priority Premise (TPP)</a>   .    , ,    ,     ,        .            .     ,     ,      ,           .  ,  ,   (   )    ,  ,  .     ,  ,         .     ,   TPP          . <br> <br>   : <br> <br> ({} ‚Üí nil)     ,   . (nil ‚Üí constant)    . (constant ‚Üí constant+)      (        ,  ). (constant ‚Üí scalar)    ,  . (statement ‚Üí statements)    (break, continue, return  ). (unconditional ‚Üí if)       . (scalar ‚Üí array)  / . (array ‚Üí container)     . (statement ‚Üí recursion)   . (if ‚Üí while)    . (expression ‚Üí function)   . (variable ‚Üí assignment)   . <br>        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::string expr) { return{}; }</code> <br> ,         .     . <br> <br> <s>         </s> .           .           .               .            .       . <br>  ,  <code>std::string</code>  <code>std::wstring</code> .         ,      Unicode.     . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); }</code> <br>  <code>AssertRange</code> -   ,       <code>AreEqual</code> ,   ,  ,    . <br> <br> <b class="spoiler_title">AssertRange</b> <code class="cpp">namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange</code> <br> <br>         <code>Operator</code>    .          <code>wchar_t</code>   ,         ,      . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', }; typedef Operator Token;</code> <br>    ,   ,        <code>Assert</code> ,    <code>ToString</code> ,    . <br> <br> <b class="spoiler_title">std::wstring ToString(const Token &amp;)</b> <code class="cpp">inline std::wstring ToString(const Token &amp;token) { return{ static_cast&lt;wchar_t&gt;(token) }; }</code> <br> <br>    ,   ,        .  ,   (unconditional ‚Üí if). <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { if(expr.empty()) { return{}; } return{ static_cast&lt;Operator&gt;(expr[0]) }; }</code> <br> <s>         </s> . <s>          .</s>           . ‚Ä¶ <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); }</code> <br>     .   ,     ,   - .    , : <br> <br>        ,      <code>Token</code> .       <code>dynamic_cast</code>    ,   .  ,    ,      .      <code>std::function</code>        .        .  Boost.Any,  - .            . <br>   ,   .      -  .  ,      ,      . <br> <br> ‚Ä¶        .        .        .        . <br>             . <br> <br> <code class="cpp">enum class TokenType { Operator, Number }; class Token { public: Token(Operator) {} TokenType Type() const { return TokenType::Operator; } }; ‚Ä¶ TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } };</code> <br>   <code>ToString</code>   <code>TokenType</code>       ,   ,   .     . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); }</code> <br>   .   (constant ‚Üí scalar)   . <br> <br> <code class="cpp">class Token { public: Token(Operator) :m_type(TokenType::Operator) {} Token(double) :m_type(TokenType::Number) {} TokenType Type() const { return m_type; } private: TokenType m_type; };</code> <br> ‚Ä¶ <s>       </s> . <s>       </s> .        .        . <br>    . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); }</code> <br>            . <br> <br> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} operator Operator() const { return m_operator; } ‚Ä¶ Operator m_operator; };</code> <br>      . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); }</code> <br>          ,  ,       <code>union</code> .         . <br> <br> <b class="spoiler_title">Token</b> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: return "Unknown token."; } }</code> <br> <br>  ,    ,      ,    .       .    . <br> <br> <i>          .</i>               .            .       . <br>        : <br> <br> <code class="cpp"> if(expr[0] &gt;= '0' &amp;&amp; expr[0] &lt;= '9') { return{ (double) expr[0] - '0' }; } return{ static_cast&lt;Operator&gt;(expr[0]) };</code> <br>      ,   . <br> <br> ‚Ä¶ <s>          .</s> <i>              .</i> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); }</code> <br> ,     <code>C</code>   ,  <code>isdigit</code> , ,       <code>atof</code> ,    ,      <code>wchar_t</code> .  (expression ‚Üí function).         . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { const wchar_t *current = expr.c_str(); if(!*current) return{}; if(iswdigit(*current)) return{ _wtof(current) }; return{ static_cast&lt;Operator&gt;(*current) }; }</code> <br>         .      . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>   ,        .  ,     .     .   <code>result</code> ,     . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); if(!*current) return result; if(iswdigit(*current)) { result.push_back(_wtof(current)); } else { result.push_back(static_cast&lt;Operator&gt;(*current)); } return result; }</code> <br>      :   (if ‚Üí while).     ,        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } } return result; }</code> <br>  <code>wcstod</code>    ,   <code>_wtof</code> ,           .           ,              .  ,    . <br> <br> <s>           .</s>       . <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>  (unconditional ‚Üí if)    ,    . <br> <br> <code class="cpp"> while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else if(*current == static_cast&lt;wchar_t&gt;(Operator::Plus)) { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } else { ++current; } }</code> <br>       .          .       <code>Detail</code>      .   <code>Tokenize</code>       . <br> <br> <code class="cpp">inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); }</code> <br> <b class="spoiler_title"> Detail::Tokenizer</b> <code class="cpp">namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { return *m_current == static_cast&lt;wchar_t&gt;(Operator::Plus); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail</code> <br> <br>  ,      .      ,  , .       . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); }</code> <br>      <code>Operator</code> ,    . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', };</code> <br>   .         <code>IsOperator</code>  <code>Tokenizer</code> . <br> <br> <code class="cpp"> bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); }</code> <br>         .        . <br> <br> <b class="spoiler_title">Interpreter.h</b> <code class="cpp">#pragma once; #include &lt;vector&gt; #include &lt;wchar.h&gt; #include &lt;algorithm&gt; namespace Interpreter { enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', }; inline std::wstring ToString(const Operator &amp;op) { return{ static_cast&lt;wchar_t&gt;(op) }; } enum class TokenType { Operator, Number }; inline std::wstring ToString(const TokenType &amp;type) { switch(type) { case TokenType::Operator: return L"Operator"; case TokenType::Number: return L"Number"; default: throw std::out_of_range("TokenType"); } } class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } friend inline bool operator==(const Token &amp;left, const Token &amp;right) { if(left.m_type == right.m_type) { switch(left.m_type) { case Interpreter::TokenType::Operator: return left.m_operator == right.m_operator; case Interpreter::TokenType::Number: return left.m_number == right.m_number; default: throw std::out_of_range("TokenType"); } } return false; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: throw std::out_of_range("TokenType"); } } typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); } } // namespace Lexer } // namespace Interpreter</code> <br> <br> <b class="spoiler_title">InterpreterTests.cpp</b> <code class="cpp">#include "stdafx.h" #include "CppUnitTest.h" #include "Interpreter.h" namespace InterpreterTests { using namespace Microsoft::VisualStudio::CppUnitTestFramework; using namespace Interpreter; using namespace std; namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual&lt;T&gt;(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange TEST_CLASS(LexerTests) { public: TEST_METHOD(Should_return_empty_token_list_when_put_empty_expression) { Tokens tokens = Lexer::Tokenize(L""); Assert::IsTrue(tokens.empty()); } TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); } TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); } TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); } TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); } }; TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); } TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); } TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); } }; }</code> <br> <br> <a href="https://github.com/Unril/InterpreterTDD/releases/tag/%25D0%259A%25D0%25BE%25D0%25BD%25D0%25B5%25D1%2586_%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B2%25D0%25BE%25D0%25B9_%25D1%2587%25D0%25B0%25D1%2581%25D1%2582%25D0%25B8">    GitHub</a> .         ,  .      "__". <br> <br>   <a href="http://habrahabr.ru/post/232081/">    </a> .      ,      <a href="http://habrahabr.ru/post/232097/">    </a> .</code> </li> <li> <code><code>std::vector,      Tokens</code> .            . <br> <br> <code class="cpp">#pragma once; #include &lt;vector&gt; namespace Interpreter { struct Token {}; typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { inline Tokens Tokenize(std::string expr) { throw std::exception(); } } // namespace Lexer } // namespace Interpreter</code> <br>   ,  ,   , .   ,    ,    <a href="http://cleancoder.posterous.com/the-transformation-priority-premise">The Transformation Priority Premise (TPP)</a>   .    , ,    ,     ,        .            .     ,     ,      ,           .  ,  ,   (   )    ,  ,  .     ,  ,         .     ,   TPP          . <br> <br>   : <br> <br> ({} ‚Üí nil)     ,   . (nil ‚Üí constant)    . (constant ‚Üí constant+)      (        ,  ). (constant ‚Üí scalar)    ,  . (statement ‚Üí statements)    (break, continue, return  ). (unconditional ‚Üí if)       . (scalar ‚Üí array)  / . (array ‚Üí container)     . (statement ‚Üí recursion)   . (if ‚Üí while)    . (expression ‚Üí function)   . (variable ‚Üí assignment)   . <br>        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::string expr) { return{}; }</code> <br> ,         .     . <br> <br> <s>         </s> .           .           .               .            .       . <br>  ,  <code>std::string</code>  <code>std::wstring</code> .         ,      Unicode.     . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); }</code> <br>  <code>AssertRange</code> -   ,       <code>AreEqual</code> ,   ,  ,    . <br> <br> <b class="spoiler_title">AssertRange</b> <code class="cpp">namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange</code> <br> <br>         <code>Operator</code>    .          <code>wchar_t</code>   ,         ,      . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', }; typedef Operator Token;</code> <br>    ,   ,        <code>Assert</code> ,    <code>ToString</code> ,    . <br> <br> <b class="spoiler_title">std::wstring ToString(const Token &amp;)</b> <code class="cpp">inline std::wstring ToString(const Token &amp;token) { return{ static_cast&lt;wchar_t&gt;(token) }; }</code> <br> <br>    ,   ,        .  ,   (unconditional ‚Üí if). <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { if(expr.empty()) { return{}; } return{ static_cast&lt;Operator&gt;(expr[0]) }; }</code> <br> <s>         </s> . <s>          .</s>           . ‚Ä¶ <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); }</code> <br>     .   ,     ,   - .    , : <br> <br>        ,      <code>Token</code> .       <code>dynamic_cast</code>    ,   .  ,    ,      .      <code>std::function</code>        .        .  Boost.Any,  - .            . <br>   ,   .      -  .  ,      ,      . <br> <br> ‚Ä¶        .        .        .        . <br>             . <br> <br> <code class="cpp">enum class TokenType { Operator, Number }; class Token { public: Token(Operator) {} TokenType Type() const { return TokenType::Operator; } }; ‚Ä¶ TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } };</code> <br>   <code>ToString</code>   <code>TokenType</code>       ,   ,   .     . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); }</code> <br>   .   (constant ‚Üí scalar)   . <br> <br> <code class="cpp">class Token { public: Token(Operator) :m_type(TokenType::Operator) {} Token(double) :m_type(TokenType::Number) {} TokenType Type() const { return m_type; } private: TokenType m_type; };</code> <br> ‚Ä¶ <s>       </s> . <s>       </s> .        .        . <br>    . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); }</code> <br>            . <br> <br> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} operator Operator() const { return m_operator; } ‚Ä¶ Operator m_operator; };</code> <br>      . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); }</code> <br>          ,  ,       <code>union</code> .         . <br> <br> <b class="spoiler_title">Token</b> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: return "Unknown token."; } }</code> <br> <br>  ,    ,      ,    .       .    . <br> <br> <i>          .</i>               .            .       . <br>        : <br> <br> <code class="cpp"> if(expr[0] &gt;= '0' &amp;&amp; expr[0] &lt;= '9') { return{ (double) expr[0] - '0' }; } return{ static_cast&lt;Operator&gt;(expr[0]) };</code> <br>      ,   . <br> <br> ‚Ä¶ <s>          .</s> <i>              .</i> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); }</code> <br> ,     <code>C</code>   ,  <code>isdigit</code> , ,       <code>atof</code> ,    ,      <code>wchar_t</code> .  (expression ‚Üí function).         . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { const wchar_t *current = expr.c_str(); if(!*current) return{}; if(iswdigit(*current)) return{ _wtof(current) }; return{ static_cast&lt;Operator&gt;(*current) }; }</code> <br>         .      . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>   ,        .  ,     .     .   <code>result</code> ,     . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); if(!*current) return result; if(iswdigit(*current)) { result.push_back(_wtof(current)); } else { result.push_back(static_cast&lt;Operator&gt;(*current)); } return result; }</code> <br>      :   (if ‚Üí while).     ,        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } } return result; }</code> <br>  <code>wcstod</code>    ,   <code>_wtof</code> ,           .           ,              .  ,    . <br> <br> <s>           .</s>       . <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>  (unconditional ‚Üí if)    ,    . <br> <br> <code class="cpp"> while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else if(*current == static_cast&lt;wchar_t&gt;(Operator::Plus)) { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } else { ++current; } }</code> <br>       .          .       <code>Detail</code>      .   <code>Tokenize</code>       . <br> <br> <code class="cpp">inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); }</code> <br> <b class="spoiler_title"> Detail::Tokenizer</b> <code class="cpp">namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { return *m_current == static_cast&lt;wchar_t&gt;(Operator::Plus); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail</code> <br> <br>  ,      .      ,  , .       . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); }</code> <br>      <code>Operator</code> ,    . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', };</code> <br>   .         <code>IsOperator</code>  <code>Tokenizer</code> . <br> <br> <code class="cpp"> bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); }</code> <br>         .        . <br> <br> <b class="spoiler_title">Interpreter.h</b> <code class="cpp">#pragma once; #include &lt;vector&gt; #include &lt;wchar.h&gt; #include &lt;algorithm&gt; namespace Interpreter { enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', }; inline std::wstring ToString(const Operator &amp;op) { return{ static_cast&lt;wchar_t&gt;(op) }; } enum class TokenType { Operator, Number }; inline std::wstring ToString(const TokenType &amp;type) { switch(type) { case TokenType::Operator: return L"Operator"; case TokenType::Number: return L"Number"; default: throw std::out_of_range("TokenType"); } } class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } friend inline bool operator==(const Token &amp;left, const Token &amp;right) { if(left.m_type == right.m_type) { switch(left.m_type) { case Interpreter::TokenType::Operator: return left.m_operator == right.m_operator; case Interpreter::TokenType::Number: return left.m_number == right.m_number; default: throw std::out_of_range("TokenType"); } } return false; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: throw std::out_of_range("TokenType"); } } typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); } } // namespace Lexer } // namespace Interpreter</code> <br> <br> <b class="spoiler_title">InterpreterTests.cpp</b> <code class="cpp">#include "stdafx.h" #include "CppUnitTest.h" #include "Interpreter.h" namespace InterpreterTests { using namespace Microsoft::VisualStudio::CppUnitTestFramework; using namespace Interpreter; using namespace std; namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual&lt;T&gt;(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange TEST_CLASS(LexerTests) { public: TEST_METHOD(Should_return_empty_token_list_when_put_empty_expression) { Tokens tokens = Lexer::Tokenize(L""); Assert::IsTrue(tokens.empty()); } TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); } TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); } TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); } TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); } }; TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); } TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); } TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); } }; }</code> <br> <br> <a href="https://github.com/Unril/InterpreterTDD/releases/tag/%25D0%259A%25D0%25BE%25D0%25BD%25D0%25B5%25D1%2586_%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B2%25D0%25BE%25D0%25B9_%25D1%2587%25D0%25B0%25D1%2581%25D1%2582%25D0%25B8">    GitHub</a> .         ,  .      "__". <br> <br>   <a href="http://habrahabr.ru/post/232081/">    </a> .      ,      <a href="http://habrahabr.ru/post/232097/">    </a> .</code> </li> <li> <code><code>std::vector,      Tokens</code> .            . <br> <br> <code class="cpp">#pragma once; #include &lt;vector&gt; namespace Interpreter { struct Token {}; typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { inline Tokens Tokenize(std::string expr) { throw std::exception(); } } // namespace Lexer } // namespace Interpreter</code> <br>   ,  ,   , .   ,    ,    <a href="http://cleancoder.posterous.com/the-transformation-priority-premise">The Transformation Priority Premise (TPP)</a>   .    , ,    ,     ,        .            .     ,     ,      ,           .  ,  ,   (   )    ,  ,  .     ,  ,         .     ,   TPP          . <br> <br>   : <br> <br> ({} ‚Üí nil)     ,   . (nil ‚Üí constant)    . (constant ‚Üí constant+)      (        ,  ). (constant ‚Üí scalar)    ,  . (statement ‚Üí statements)    (break, continue, return  ). (unconditional ‚Üí if)       . (scalar ‚Üí array)  / . (array ‚Üí container)     . (statement ‚Üí recursion)   . (if ‚Üí while)    . (expression ‚Üí function)   . (variable ‚Üí assignment)   . <br>        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::string expr) { return{}; }</code> <br> ,         .     . <br> <br> <s>         </s> .           .           .               .            .       . <br>  ,  <code>std::string</code>  <code>std::wstring</code> .         ,      Unicode.     . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); }</code> <br>  <code>AssertRange</code> -   ,       <code>AreEqual</code> ,   ,  ,    . <br> <br> <b class="spoiler_title">AssertRange</b> <code class="cpp">namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange</code> <br> <br>         <code>Operator</code>    .          <code>wchar_t</code>   ,         ,      . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', }; typedef Operator Token;</code> <br>    ,   ,        <code>Assert</code> ,    <code>ToString</code> ,    . <br> <br> <b class="spoiler_title">std::wstring ToString(const Token &amp;)</b> <code class="cpp">inline std::wstring ToString(const Token &amp;token) { return{ static_cast&lt;wchar_t&gt;(token) }; }</code> <br> <br>    ,   ,        .  ,   (unconditional ‚Üí if). <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { if(expr.empty()) { return{}; } return{ static_cast&lt;Operator&gt;(expr[0]) }; }</code> <br> <s>         </s> . <s>          .</s>           . ‚Ä¶ <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); }</code> <br>     .   ,     ,   - .    , : <br> <br>        ,      <code>Token</code> .       <code>dynamic_cast</code>    ,   .  ,    ,      .      <code>std::function</code>        .        .  Boost.Any,  - .            . <br>   ,   .      -  .  ,      ,      . <br> <br> ‚Ä¶        .        .        .        . <br>             . <br> <br> <code class="cpp">enum class TokenType { Operator, Number }; class Token { public: Token(Operator) {} TokenType Type() const { return TokenType::Operator; } }; ‚Ä¶ TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } };</code> <br>   <code>ToString</code>   <code>TokenType</code>       ,   ,   .     . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); }</code> <br>   .   (constant ‚Üí scalar)   . <br> <br> <code class="cpp">class Token { public: Token(Operator) :m_type(TokenType::Operator) {} Token(double) :m_type(TokenType::Number) {} TokenType Type() const { return m_type; } private: TokenType m_type; };</code> <br> ‚Ä¶ <s>       </s> . <s>       </s> .        .        . <br>    . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); }</code> <br>            . <br> <br> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} operator Operator() const { return m_operator; } ‚Ä¶ Operator m_operator; };</code> <br>      . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); }</code> <br>          ,  ,       <code>union</code> .         . <br> <br> <b class="spoiler_title">Token</b> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: return "Unknown token."; } }</code> <br> <br>  ,    ,      ,    .       .    . <br> <br> <i>          .</i>               .            .       . <br>        : <br> <br> <code class="cpp"> if(expr[0] &gt;= '0' &amp;&amp; expr[0] &lt;= '9') { return{ (double) expr[0] - '0' }; } return{ static_cast&lt;Operator&gt;(expr[0]) };</code> <br>      ,   . <br> <br> ‚Ä¶ <s>          .</s> <i>              .</i> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); }</code> <br> ,     <code>C</code>   ,  <code>isdigit</code> , ,       <code>atof</code> ,    ,      <code>wchar_t</code> .  (expression ‚Üí function).         . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { const wchar_t *current = expr.c_str(); if(!*current) return{}; if(iswdigit(*current)) return{ _wtof(current) }; return{ static_cast&lt;Operator&gt;(*current) }; }</code> <br>         .      . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>   ,        .  ,     .     .   <code>result</code> ,     . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); if(!*current) return result; if(iswdigit(*current)) { result.push_back(_wtof(current)); } else { result.push_back(static_cast&lt;Operator&gt;(*current)); } return result; }</code> <br>      :   (if ‚Üí while).     ,        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } } return result; }</code> <br>  <code>wcstod</code>    ,   <code>_wtof</code> ,           .           ,              .  ,    . <br> <br> <s>           .</s>       . <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>  (unconditional ‚Üí if)    ,    . <br> <br> <code class="cpp"> while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else if(*current == static_cast&lt;wchar_t&gt;(Operator::Plus)) { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } else { ++current; } }</code> <br>       .          .       <code>Detail</code>      .   <code>Tokenize</code>       . <br> <br> <code class="cpp">inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); }</code> <br> <b class="spoiler_title"> Detail::Tokenizer</b> <code class="cpp">namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { return *m_current == static_cast&lt;wchar_t&gt;(Operator::Plus); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail</code> <br> <br>  ,      .      ,  , .       . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); }</code> <br>      <code>Operator</code> ,    . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', };</code> <br>   .         <code>IsOperator</code>  <code>Tokenizer</code> . <br> <br> <code class="cpp"> bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); }</code> <br>         .        . <br> <br> <b class="spoiler_title">Interpreter.h</b> <code class="cpp">#pragma once; #include &lt;vector&gt; #include &lt;wchar.h&gt; #include &lt;algorithm&gt; namespace Interpreter { enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', }; inline std::wstring ToString(const Operator &amp;op) { return{ static_cast&lt;wchar_t&gt;(op) }; } enum class TokenType { Operator, Number }; inline std::wstring ToString(const TokenType &amp;type) { switch(type) { case TokenType::Operator: return L"Operator"; case TokenType::Number: return L"Number"; default: throw std::out_of_range("TokenType"); } } class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } friend inline bool operator==(const Token &amp;left, const Token &amp;right) { if(left.m_type == right.m_type) { switch(left.m_type) { case Interpreter::TokenType::Operator: return left.m_operator == right.m_operator; case Interpreter::TokenType::Number: return left.m_number == right.m_number; default: throw std::out_of_range("TokenType"); } } return false; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: throw std::out_of_range("TokenType"); } } typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); } } // namespace Lexer } // namespace Interpreter</code> <br> <br> <b class="spoiler_title">InterpreterTests.cpp</b> <code class="cpp">#include "stdafx.h" #include "CppUnitTest.h" #include "Interpreter.h" namespace InterpreterTests { using namespace Microsoft::VisualStudio::CppUnitTestFramework; using namespace Interpreter; using namespace std; namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual&lt;T&gt;(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange TEST_CLASS(LexerTests) { public: TEST_METHOD(Should_return_empty_token_list_when_put_empty_expression) { Tokens tokens = Lexer::Tokenize(L""); Assert::IsTrue(tokens.empty()); } TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); } TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); } TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); } TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); } }; TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); } TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); } TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); } }; }</code> <br> <br> <a href="https://github.com/Unril/InterpreterTDD/releases/tag/%25D0%259A%25D0%25BE%25D0%25BD%25D0%25B5%25D1%2586_%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B2%25D0%25BE%25D0%25B9_%25D1%2587%25D0%25B0%25D1%2581%25D1%2582%25D0%25B8">    GitHub</a> .         ,  .      "__". <br> <br>   <a href="http://habrahabr.ru/post/232081/">    </a> .      ,      <a href="http://habrahabr.ru/post/232097/">    </a> .</code> </li> </ul> <code><code>std::vector,      Tokens</code> .            . <br> <br> <code class="cpp">#pragma once; #include &lt;vector&gt; namespace Interpreter { struct Token {}; typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { inline Tokens Tokenize(std::string expr) { throw std::exception(); } } // namespace Lexer } // namespace Interpreter</code> <br>   ,  ,   , .   ,    ,    <a href="http://cleancoder.posterous.com/the-transformation-priority-premise">The Transformation Priority Premise (TPP)</a>   .    , ,    ,     ,        .            .     ,     ,      ,           .  ,  ,   (   )    ,  ,  .     ,  ,         .     ,   TPP          . <br> <br>   : <br> <br> ({} ‚Üí nil)     ,   . (nil ‚Üí constant)    . (constant ‚Üí constant+)      (        ,  ). (constant ‚Üí scalar)    ,  . (statement ‚Üí statements)    (break, continue, return  ). (unconditional ‚Üí if)       . (scalar ‚Üí array)  / . (array ‚Üí container)     . (statement ‚Üí recursion)   . (if ‚Üí while)    . (expression ‚Üí function)   . (variable ‚Üí assignment)   . <br>        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::string expr) { return{}; }</code> <br> ,         .     . <br> <br> <s>         </s> .           .           .               .            .       . <br>  ,  <code>std::string</code>  <code>std::wstring</code> .         ,      Unicode.     . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); }</code> <br>  <code>AssertRange</code> -   ,       <code>AreEqual</code> ,   ,  ,    . <br> <br> <b class="spoiler_title">AssertRange</b> <code class="cpp">namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange</code> <br> <br>         <code>Operator</code>    .          <code>wchar_t</code>   ,         ,      . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', }; typedef Operator Token;</code> <br>    ,   ,        <code>Assert</code> ,    <code>ToString</code> ,    . <br> <br> <b class="spoiler_title">std::wstring ToString(const Token &amp;)</b> <code class="cpp">inline std::wstring ToString(const Token &amp;token) { return{ static_cast&lt;wchar_t&gt;(token) }; }</code> <br> <br>    ,   ,        .  ,   (unconditional ‚Üí if). <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { if(expr.empty()) { return{}; } return{ static_cast&lt;Operator&gt;(expr[0]) }; }</code> <br> <s>         </s> . <s>          .</s>           . ‚Ä¶ <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); }</code> <br>     .   ,     ,   - .    , : <br> <br>        ,      <code>Token</code> .       <code>dynamic_cast</code>    ,   .  ,    ,      .      <code>std::function</code>        .        .  Boost.Any,  - .            . <br>   ,   .      -  .  ,      ,      . <br> <br> ‚Ä¶        .        .        .        . <br>             . <br> <br> <code class="cpp">enum class TokenType { Operator, Number }; class Token { public: Token(Operator) {} TokenType Type() const { return TokenType::Operator; } }; ‚Ä¶ TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } };</code> <br>   <code>ToString</code>   <code>TokenType</code>       ,   ,   .     . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); }</code> <br>   .   (constant ‚Üí scalar)   . <br> <br> <code class="cpp">class Token { public: Token(Operator) :m_type(TokenType::Operator) {} Token(double) :m_type(TokenType::Number) {} TokenType Type() const { return m_type; } private: TokenType m_type; };</code> <br> ‚Ä¶ <s>       </s> . <s>       </s> .        .        . <br>    . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); }</code> <br>            . <br> <br> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} operator Operator() const { return m_operator; } ‚Ä¶ Operator m_operator; };</code> <br>      . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); }</code> <br>          ,  ,       <code>union</code> .         . <br> <br> <b class="spoiler_title">Token</b> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: return "Unknown token."; } }</code> <br> <br>  ,    ,      ,    .       .    . <br> <br> <i>          .</i>               .            .       . <br>        : <br> <br> <code class="cpp"> if(expr[0] &gt;= '0' &amp;&amp; expr[0] &lt;= '9') { return{ (double) expr[0] - '0' }; } return{ static_cast&lt;Operator&gt;(expr[0]) };</code> <br>      ,   . <br> <br> ‚Ä¶ <s>          .</s> <i>              .</i> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); }</code> <br> ,     <code>C</code>   ,  <code>isdigit</code> , ,       <code>atof</code> ,    ,      <code>wchar_t</code> .  (expression ‚Üí function).         . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { const wchar_t *current = expr.c_str(); if(!*current) return{}; if(iswdigit(*current)) return{ _wtof(current) }; return{ static_cast&lt;Operator&gt;(*current) }; }</code> <br>         .      . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>   ,        .  ,     .     .   <code>result</code> ,     . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); if(!*current) return result; if(iswdigit(*current)) { result.push_back(_wtof(current)); } else { result.push_back(static_cast&lt;Operator&gt;(*current)); } return result; }</code> <br>      :   (if ‚Üí while).     ,        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } } return result; }</code> <br>  <code>wcstod</code>    ,   <code>_wtof</code> ,           .           ,              .  ,    . <br> <br> <s>           .</s>       . <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>  (unconditional ‚Üí if)    ,    . <br> <br> <code class="cpp"> while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else if(*current == static_cast&lt;wchar_t&gt;(Operator::Plus)) { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } else { ++current; } }</code> <br>       .          .       <code>Detail</code>      .   <code>Tokenize</code>       . <br> <br> <code class="cpp">inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); }</code> <br> <b class="spoiler_title"> Detail::Tokenizer</b> <code class="cpp">namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { return *m_current == static_cast&lt;wchar_t&gt;(Operator::Plus); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail</code> <br> <br>  ,      .      ,  , .       . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); }</code> <br>      <code>Operator</code> ,    . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', };</code> <br>   .         <code>IsOperator</code>  <code>Tokenizer</code> . <br> <br> <code class="cpp"> bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); }</code> <br>         .        . <br> <br> <b class="spoiler_title">Interpreter.h</b> <code class="cpp">#pragma once; #include &lt;vector&gt; #include &lt;wchar.h&gt; #include &lt;algorithm&gt; namespace Interpreter { enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', }; inline std::wstring ToString(const Operator &amp;op) { return{ static_cast&lt;wchar_t&gt;(op) }; } enum class TokenType { Operator, Number }; inline std::wstring ToString(const TokenType &amp;type) { switch(type) { case TokenType::Operator: return L"Operator"; case TokenType::Number: return L"Number"; default: throw std::out_of_range("TokenType"); } } class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } friend inline bool operator==(const Token &amp;left, const Token &amp;right) { if(left.m_type == right.m_type) { switch(left.m_type) { case Interpreter::TokenType::Operator: return left.m_operator == right.m_operator; case Interpreter::TokenType::Number: return left.m_number == right.m_number; default: throw std::out_of_range("TokenType"); } } return false; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: throw std::out_of_range("TokenType"); } } typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); } } // namespace Lexer } // namespace Interpreter</code> <br> <br> <b class="spoiler_title">InterpreterTests.cpp</b> <code class="cpp">#include "stdafx.h" #include "CppUnitTest.h" #include "Interpreter.h" namespace InterpreterTests { using namespace Microsoft::VisualStudio::CppUnitTestFramework; using namespace Interpreter; using namespace std; namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual&lt;T&gt;(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange TEST_CLASS(LexerTests) { public: TEST_METHOD(Should_return_empty_token_list_when_put_empty_expression) { Tokens tokens = Lexer::Tokenize(L""); Assert::IsTrue(tokens.empty()); } TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); } TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); } TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); } TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); } }; TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); } TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); } TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); } }; }</code> <br> <br> <a href="https://github.com/Unril/InterpreterTDD/releases/tag/%25D0%259A%25D0%25BE%25D0%25BD%25D0%25B5%25D1%2586_%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B2%25D0%25BE%25D0%25B9_%25D1%2587%25D0%25B0%25D1%2581%25D1%2582%25D0%25B8">    GitHub</a> .         ,  .      "__". <br> <br>   <a href="http://habrahabr.ru/post/232081/">    </a> .      ,      <a href="http://habrahabr.ru/post/232097/">    </a> .</code> <pre> <code class="hljs lua"><code>std::vector,      Tokens</code> .            . <br> <br> <code class="cpp">#pragma once; #include &lt;vector&gt; namespace Interpreter { struct Token {}; typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { inline Tokens Tokenize(std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> expr) { throw std::exception(); } } // namespace Lexer } // namespace Interpreter</code> <br>   ,  ,   , .   ,    ,    <a href="http://cleancoder.posterous.com/the-transformation-priority-premise">The Transformation Priority Premise (TPP)</a>   .    , ,    ,     ,        .            .     ,     ,      ,           .  ,  ,   (   )    ,  ,  .     ,  ,         .     ,   TPP          . <br> <br>   : <br> <br> ({} ‚Üí <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)     ,   . (<span class="hljs-literal"><span class="hljs-literal">nil</span></span> ‚Üí constant)    . (constant ‚Üí constant+)      (        ,  ). (constant ‚Üí scalar)    ,  . (statement ‚Üí statements)    (<span class="hljs-keyword"><span class="hljs-keyword">break</span></span>, continue, <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>  ). (unconditional ‚Üí <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>)       . (scalar ‚Üí array)  / . (array ‚Üí container)     . (statement ‚Üí recursion)   . (<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ‚Üí <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>)    . (expression ‚Üí <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">)</span></span>   . (variable ‚Üí assignment)   . <br>        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> expr) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{}; }</code> <br> ,         .     . <br> <br> <s>         </s> .           .           .               .            .       . <br>  ,  <code>std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span></code>  <code>std::wstring</code> .         ,      Unicode.     . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"+"</span></span>); AssertRange::AreEqual({ Operator::Plus }, tokens); }</code> <br>  <code>AssertRange</code> -   ,       <code>AreEqual</code> ,   ,  ,    . <br> <br> <b class="spoiler_title">AssertRange</b> <code class="cpp">namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(expect)), distance(actualIter, <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(actual)), L<span class="hljs-string"><span class="hljs-string">"Size differs."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(; expectIter != <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(expect) &amp;&amp; actualIter != <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(actual); ++expectIter, ++actualIter) { auto message = L<span class="hljs-string"><span class="hljs-string">"Mismatch in position "</span></span> + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange</code> <br> <br>         <code>Operator</code>    .          <code>wchar_t</code>   ,         ,      . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L<span class="hljs-string"><span class="hljs-string">'+'</span></span>, }; typedef Operator Token;</code> <br>    ,   ,        <code>Assert</code> ,    <code>ToString</code> ,    . <br> <br> <b class="spoiler_title">std::wstring ToString(const Token &amp;)</b> <code class="cpp">inline std::wstring ToString(const Token &amp;token) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ static_cast&lt;wchar_t&gt;(token) }; }</code> <br> <br>    ,   ,        .  ,   (unconditional ‚Üí <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>). <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(expr.empty()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{}; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ static_cast&lt;Operator&gt;(expr[<span class="hljs-number"><span class="hljs-number">0</span></span>]) }; }</code> <br> <s>         </s> . <s>          .</s>           . ‚Ä¶ <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"1"</span></span>); AssertRange::AreEqual({ <span class="hljs-number"><span class="hljs-number">1.0</span></span> }, tokens); }</code> <br>     .   ,     ,   - .    , : <br> <br>        ,      <code>Token</code> .       <code>dynamic_cast</code>    ,   .  ,    ,      .      <code>std::<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span></span></code><span class="hljs-function"><span class="hljs-function">        .        .  </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Boost.Any</span></span></span><span class="hljs-function">,  - .            . </span></span><br><span class="hljs-function"><span class="hljs-function">   ,   .      -  .  ,      ,      . </span></span><br><span class="hljs-function"><span class="hljs-function"> </span></span><br><span class="hljs-function"><span class="hljs-function"> ‚Ä¶        .        .        .        . </span></span><br><span class="hljs-function"><span class="hljs-function">             . </span></span><br><span class="hljs-function"><span class="hljs-function"> </span></span><br><span class="hljs-function"><span class="hljs-function"> </span></span><code class="cpp"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">enum</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">class</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TokenType</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Operator</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Number</span></span></span><span class="hljs-function"> }; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">class</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Token</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">public</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Token</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Operator)</span></span></span></span> {} TokenType Type() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TokenType::Operator; } }; ‚Ä¶ TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } };</code> <br>   <code>ToString</code>   <code>TokenType</code>       ,   ,   .     . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_type_for_number_token) { Token numToken(<span class="hljs-number"><span class="hljs-number">1.2</span></span>); Assert::AreEqual(TokenType::Number, numToken.Type()); }</code> <br>   .   (constant ‚Üí scalar)   . <br> <br> <code class="cpp">class Token { public: Token(Operator) :m_type(TokenType::Operator) {} Token(double) :m_type(TokenType::Number) {} TokenType Type() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_type; } private: TokenType m_type; };</code> <br> ‚Ä¶ <s>       </s> . <s>       </s> .        .        . <br>    . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); }</code> <br>            . <br> <br> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} operator Operator() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_operator; } ‚Ä¶ Operator m_operator; };</code> <br>      . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_number_value_from_number_token) { Token token(<span class="hljs-number"><span class="hljs-number">1.23</span></span>); Assert::AreEqual&lt;double&gt;(<span class="hljs-number"><span class="hljs-number">1.23</span></span>, token); }</code> <br>          ,  ,       <code>union</code> .         . <br> <br> <b class="spoiler_title">Token</b> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_type; } operator Operator() const { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(m_type != TokenType::Operator) throw std::logic_error(<span class="hljs-string"><span class="hljs-string">"Should be operator token."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_operator; } operator double() const { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(m_type != TokenType::Number) throw std::logic_error(<span class="hljs-string"><span class="hljs-string">"Should be number token."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_number; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ToString(static_cast&lt;Operator&gt;(token)); default: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Unknown token."</span></span>; } }</code> <br> <br>  ,    ,      ,    .       .    . <br> <br> <i>          .</i>               .            .       . <br>        : <br> <br> <code class="cpp"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(expr[<span class="hljs-number"><span class="hljs-number">0</span></span>] &gt;= <span class="hljs-string"><span class="hljs-string">'0'</span></span> &amp;&amp; expr[<span class="hljs-number"><span class="hljs-number">0</span></span>] &lt;= <span class="hljs-string"><span class="hljs-string">'9'</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ (double) expr[<span class="hljs-number"><span class="hljs-number">0</span></span>] - <span class="hljs-string"><span class="hljs-string">'0'</span></span> }; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ static_cast&lt;Operator&gt;(expr[<span class="hljs-number"><span class="hljs-number">0</span></span>]) };</code> <br>      ,   . <br> <br> ‚Ä¶ <s>          .</s> <i>              .</i> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"12.34"</span></span>); AssertRange::AreEqual({ <span class="hljs-number"><span class="hljs-number">12.34</span></span> }, tokens); }</code> <br> ,     <code>C</code>   ,  <code>isdigit</code> , ,       <code>atof</code> ,    ,      <code>wchar_t</code> .  (expression ‚Üí <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">)</span></span>.         . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { const wchar_t *current = expr.c_str(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!*current) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{}; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(iswdigit(*current)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ _wtof(current) }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ static_cast&lt;Operator&gt;(*current) }; }</code> <br>         .      . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"+12.34"</span></span>); AssertRange::AreEqual({ Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">12.34</span></span>) }, tokens); }</code> <br>   ,        .  ,     .     .   <code>result</code> ,     . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!*current) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(iswdigit(*current)) { result.push_back(_wtof(current)); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { result.push_back(static_cast&lt;Operator&gt;(*current)); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> <br>      :   (<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ‚Üí <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>).     ,        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(*current) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(iswdigit(*current)) { wchar_t *<span class="hljs-keyword"><span class="hljs-keyword">end</span></span> = nullptr; result.push_back(wcstod(current, &amp;<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>)); current = <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> <br>  <code>wcstod</code>    ,   <code>_wtof</code> ,           .           ,              .  ,    . <br> <br> <s>           .</s>       . <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">" 1 + 12.34 "</span></span>); AssertRange::AreEqual({ Token(<span class="hljs-number"><span class="hljs-number">1.0</span></span>), Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">12.34</span></span>) }, tokens); }</code> <br>  (unconditional ‚Üí <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>)    ,    . <br> <br> <code class="cpp"> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(*current) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(iswdigit(*current)) { wchar_t *<span class="hljs-keyword"><span class="hljs-keyword">end</span></span> = nullptr; result.push_back(wcstod(current, &amp;<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>)); current = <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(*current == static_cast&lt;wchar_t&gt;(Operator::Plus)) { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { ++current; } }</code> <br>       .          .       <code>Detail</code>      .   <code>Tokenize</code>       . <br> <br> <code class="cpp">inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tokenizer.Result(); }</code> <br> <b class="spoiler_title"> Detail::Tokenizer</b> <code class="cpp">namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!EndOfExperssion()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(IsNumber()) { ScanNumber(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(IsOperator()) { ScanOperator(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { MoveNext(); } } } const Tokens &amp;Result() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_result; } private: bool EndOfExperssion() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_current == L<span class="hljs-string"><span class="hljs-string">'\0'</span></span>; } bool IsNumber() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> iswdigit(*m_current) != <span class="hljs-number"><span class="hljs-number">0</span></span>; } void ScanNumber() { wchar_t *<span class="hljs-keyword"><span class="hljs-keyword">end</span></span> = nullptr; m_result.push_back(wcstod(m_current, &amp;<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>)); m_current = <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; } bool IsOperator() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_current == static_cast&lt;wchar_t&gt;(Operator::Plus); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail</code> <br> <br>  ,      .      ,  , .       . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"1+2*3/(4-5)"</span></span>); AssertRange::AreEqual({ Token(<span class="hljs-number"><span class="hljs-number">1</span></span>), Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">2</span></span>), Token(Operator::Mul), Token(<span class="hljs-number"><span class="hljs-number">3</span></span>), Token(Operator::Div), Token(Operator::LParen), Token(<span class="hljs-number"><span class="hljs-number">4</span></span>), Token(Operator::Minus), Token(<span class="hljs-number"><span class="hljs-number">5</span></span>), Token(Operator::RParen) }, tokens); }</code> <br>      <code>Operator</code> ,    . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L<span class="hljs-string"><span class="hljs-string">'+'</span></span>, Minus = L<span class="hljs-string"><span class="hljs-string">'-'</span></span>, Mul = L<span class="hljs-string"><span class="hljs-string">'*'</span></span>, Div = L<span class="hljs-string"><span class="hljs-string">'/'</span></span>, LParen = L<span class="hljs-string"><span class="hljs-string">'('</span></span>, RParen = L<span class="hljs-string"><span class="hljs-string">')'</span></span>, };</code> <br>   .         <code>IsOperator</code>  <code>Tokenizer</code> . <br> <br> <code class="cpp"> bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> std::any_of(all.begin(), all.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(), [this](Operator o) {<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_current == static_cast&lt;wchar_t&gt;(o); }); }</code> <br>         .        . <br> <br> <b class="spoiler_title">Interpreter.h</b> <code class="cpp">#pragma once; #include &lt;vector&gt; #include &lt;wchar.h&gt; #include &lt;algorithm&gt; namespace Interpreter { enum class Operator : wchar_t { Plus = L<span class="hljs-string"><span class="hljs-string">'+'</span></span>, Minus = L<span class="hljs-string"><span class="hljs-string">'-'</span></span>, Mul = L<span class="hljs-string"><span class="hljs-string">'*'</span></span>, Div = L<span class="hljs-string"><span class="hljs-string">'/'</span></span>, LParen = L<span class="hljs-string"><span class="hljs-string">'('</span></span>, RParen = L<span class="hljs-string"><span class="hljs-string">')'</span></span>, }; inline std::wstring ToString(const Operator &amp;op) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ static_cast&lt;wchar_t&gt;(op) }; } enum class TokenType { Operator, Number }; inline std::wstring ToString(const TokenType &amp;<span class="hljs-built_in"><span class="hljs-built_in">type</span></span>) { switch(<span class="hljs-built_in"><span class="hljs-built_in">type</span></span>) { case TokenType::Operator: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> L<span class="hljs-string"><span class="hljs-string">"Operator"</span></span>; case TokenType::Number: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> L<span class="hljs-string"><span class="hljs-string">"Number"</span></span>; default: throw std::out_of_range(<span class="hljs-string"><span class="hljs-string">"TokenType"</span></span>); } } class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_type; } operator Operator() const { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(m_type != TokenType::Operator) throw std::logic_error(<span class="hljs-string"><span class="hljs-string">"Should be operator token."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_operator; } operator double() const { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(m_type != TokenType::Number) throw std::logic_error(<span class="hljs-string"><span class="hljs-string">"Should be number token."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_number; } friend inline bool operator==(const Token &amp;left, const Token &amp;right) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(left.m_type == right.m_type) { switch(left.m_type) { case Interpreter::TokenType::Operator: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> left.m_operator == right.m_operator; case Interpreter::TokenType::Number: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> left.m_number == right.m_number; default: throw std::out_of_range(<span class="hljs-string"><span class="hljs-string">"TokenType"</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ToString(static_cast&lt;Operator&gt;(token)); default: throw std::out_of_range(<span class="hljs-string"><span class="hljs-string">"TokenType"</span></span>); } } typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!EndOfExperssion()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(IsNumber()) { ScanNumber(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(IsOperator()) { ScanOperator(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { MoveNext(); } } } const Tokens &amp;Result() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_result; } private: bool EndOfExperssion() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_current == L<span class="hljs-string"><span class="hljs-string">'\0'</span></span>; } bool IsNumber() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> iswdigit(*m_current) != <span class="hljs-number"><span class="hljs-number">0</span></span>; } void ScanNumber() { wchar_t *<span class="hljs-keyword"><span class="hljs-keyword">end</span></span> = nullptr; m_result.push_back(wcstod(m_current, &amp;<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>)); m_current = <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; } bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> std::any_of(all.begin(), all.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(), [this](Operator o) {<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_current == static_cast&lt;wchar_t&gt;(o); }); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tokenizer.Result(); } } // namespace Lexer } // namespace Interpreter</code> <br> <br> <b class="spoiler_title">InterpreterTests.cpp</b> <code class="cpp">#include <span class="hljs-string"><span class="hljs-string">"stdafx.h"</span></span> #include <span class="hljs-string"><span class="hljs-string">"CppUnitTest.h"</span></span> #include <span class="hljs-string"><span class="hljs-string">"Interpreter.h"</span></span> namespace InterpreterTests { using namespace Microsoft::VisualStudio::CppUnitTestFramework; using namespace Interpreter; using namespace std; namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(expect)), distance(actualIter, <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(actual)), L<span class="hljs-string"><span class="hljs-string">"Size differs."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(; expectIter != <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(expect) &amp;&amp; actualIter != <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(actual); ++expectIter, ++actualIter) { auto message = L<span class="hljs-string"><span class="hljs-string">"Mismatch in position "</span></span> + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual&lt;T&gt;(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange TEST_CLASS(LexerTests) { public: TEST_METHOD(Should_return_empty_token_list_when_put_empty_expression) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">""</span></span>); Assert::IsTrue(tokens.empty()); } TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"+"</span></span>); AssertRange::AreEqual({ Operator::Plus }, tokens); } TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"1"</span></span>); AssertRange::AreEqual({ <span class="hljs-number"><span class="hljs-number">1.0</span></span> }, tokens); } TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"12.34"</span></span>); AssertRange::AreEqual({ <span class="hljs-number"><span class="hljs-number">12.34</span></span> }, tokens); } TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"+12.34"</span></span>); AssertRange::AreEqual({ Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">12.34</span></span>) }, tokens); } TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">" 1 + 12.34 "</span></span>); AssertRange::AreEqual({ Token(<span class="hljs-number"><span class="hljs-number">1.0</span></span>), Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">12.34</span></span>) }, tokens); } TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"1+2*3/(4-5)"</span></span>); AssertRange::AreEqual({ Token(<span class="hljs-number"><span class="hljs-number">1</span></span>), Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">2</span></span>), Token(Operator::Mul), Token(<span class="hljs-number"><span class="hljs-number">3</span></span>), Token(Operator::Div), Token(Operator::LParen), Token(<span class="hljs-number"><span class="hljs-number">4</span></span>), Token(Operator::Minus), Token(<span class="hljs-number"><span class="hljs-number">5</span></span>), Token(Operator::RParen) }, tokens); } }; TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } TEST_METHOD(Should_get_type_for_number_token) { Token numToken(<span class="hljs-number"><span class="hljs-number">1.2</span></span>); Assert::AreEqual(TokenType::Number, numToken.Type()); } TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); } TEST_METHOD(Should_get_number_value_from_number_token) { Token token(<span class="hljs-number"><span class="hljs-number">1.23</span></span>); Assert::AreEqual&lt;double&gt;(<span class="hljs-number"><span class="hljs-number">1.23</span></span>, token); } }; }</code> <br> <br> <a href="https://github.com/Unril/InterpreterTDD/releases/tag/%25D0%259A%25D0%25BE%25D0%25BD%25D0%25B5%25D1%2586_%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B2%25D0%25BE%25D0%25B9_%25D1%2587%25D0%25B0%25D1%2581%25D1%2582%25D0%25B8">    GitHub</a> .         ,  .      <span class="hljs-string"><span class="hljs-string">"__"</span></span>. <br> <br>   <a href="http://habrahabr.ru/post/232081/">    </a> .      ,      <a href="http://habrahabr.ru/post/232097/">    </a> .</code> </pre> <code><code>std::vector,      Tokens</code> .            . <br> <br> <code class="cpp">#pragma once; #include &lt;vector&gt; namespace Interpreter { struct Token {}; typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { inline Tokens Tokenize(std::string expr) { throw std::exception(); } } // namespace Lexer } // namespace Interpreter</code> <br>   ,  ,   , .   ,    ,    <a href="http://cleancoder.posterous.com/the-transformation-priority-premise">The Transformation Priority Premise (TPP)</a>   .    , ,    ,     ,        .            .     ,     ,      ,           .  ,  ,   (   )    ,  ,  .     ,  ,         .     ,   TPP          . <br> <br>   : <br> <br> ({} ‚Üí nil)     ,   . (nil ‚Üí constant)    . (constant ‚Üí constant+)      (        ,  ). (constant ‚Üí scalar)    ,  . (statement ‚Üí statements)    (break, continue, return  ). (unconditional ‚Üí if)       . (scalar ‚Üí array)  / . (array ‚Üí container)     . (statement ‚Üí recursion)   . (if ‚Üí while)    . (expression ‚Üí function)   . (variable ‚Üí assignment)   . <br>        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::string expr) { return{}; }</code> <br> ,         .     . <br> <br> <s>         </s> .           .           .               .            .       . <br>  ,  <code>std::string</code>  <code>std::wstring</code> .         ,      Unicode.     . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); }</code> <br>  <code>AssertRange</code> -   ,       <code>AreEqual</code> ,   ,  ,    . <br> <br> <b class="spoiler_title">AssertRange</b> <code class="cpp">namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange</code> <br> <br>         <code>Operator</code>    .          <code>wchar_t</code>   ,         ,      . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', }; typedef Operator Token;</code> <br>    ,   ,        <code>Assert</code> ,    <code>ToString</code> ,    . <br> <br> <b class="spoiler_title">std::wstring ToString(const Token &amp;)</b> <code class="cpp">inline std::wstring ToString(const Token &amp;token) { return{ static_cast&lt;wchar_t&gt;(token) }; }</code> <br> <br>    ,   ,        .  ,   (unconditional ‚Üí if). <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { if(expr.empty()) { return{}; } return{ static_cast&lt;Operator&gt;(expr[0]) }; }</code> <br> <s>         </s> . <s>          .</s>           . ‚Ä¶ <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); }</code> <br>     .   ,     ,   - .    , : <br> <br>        ,      <code>Token</code> .       <code>dynamic_cast</code>    ,   .  ,    ,      .      <code>std::function</code>        .        .  Boost.Any,  - .            . <br>   ,   .      -  .  ,      ,      . <br> <br> ‚Ä¶        .        .        .        . <br>             . <br> <br> <code class="cpp">enum class TokenType { Operator, Number }; class Token { public: Token(Operator) {} TokenType Type() const { return TokenType::Operator; } }; ‚Ä¶ TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } };</code> <br>   <code>ToString</code>   <code>TokenType</code>       ,   ,   .     . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); }</code> <br>   .   (constant ‚Üí scalar)   . <br> <br> <code class="cpp">class Token { public: Token(Operator) :m_type(TokenType::Operator) {} Token(double) :m_type(TokenType::Number) {} TokenType Type() const { return m_type; } private: TokenType m_type; };</code> <br> ‚Ä¶ <s>       </s> . <s>       </s> .        .        . <br>    . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); }</code> <br>            . <br> <br> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} operator Operator() const { return m_operator; } ‚Ä¶ Operator m_operator; };</code> <br>      . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); }</code> <br>          ,  ,       <code>union</code> .         . <br> <br> <b class="spoiler_title">Token</b> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: return "Unknown token."; } }</code> <br> <br>  ,    ,      ,    .       .    . <br> <br> <i>          .</i>               .            .       . <br>        : <br> <br> <code class="cpp"> if(expr[0] &gt;= '0' &amp;&amp; expr[0] &lt;= '9') { return{ (double) expr[0] - '0' }; } return{ static_cast&lt;Operator&gt;(expr[0]) };</code> <br>      ,   . <br> <br> ‚Ä¶ <s>          .</s> <i>              .</i> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); }</code> <br> ,     <code>C</code>   ,  <code>isdigit</code> , ,       <code>atof</code> ,    ,      <code>wchar_t</code> .  (expression ‚Üí function).         . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { const wchar_t *current = expr.c_str(); if(!*current) return{}; if(iswdigit(*current)) return{ _wtof(current) }; return{ static_cast&lt;Operator&gt;(*current) }; }</code> <br>         .      . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>   ,        .  ,     .     .   <code>result</code> ,     . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); if(!*current) return result; if(iswdigit(*current)) { result.push_back(_wtof(current)); } else { result.push_back(static_cast&lt;Operator&gt;(*current)); } return result; }</code> <br>      :   (if ‚Üí while).     ,        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } } return result; }</code> <br>  <code>wcstod</code>    ,   <code>_wtof</code> ,           .           ,              .  ,    . <br> <br> <s>           .</s>       . <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>  (unconditional ‚Üí if)    ,    . <br> <br> <code class="cpp"> while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else if(*current == static_cast&lt;wchar_t&gt;(Operator::Plus)) { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } else { ++current; } }</code> <br>       .          .       <code>Detail</code>      .   <code>Tokenize</code>       . <br> <br> <code class="cpp">inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); }</code> <br> <b class="spoiler_title"> Detail::Tokenizer</b> <code class="cpp">namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { return *m_current == static_cast&lt;wchar_t&gt;(Operator::Plus); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail</code> <br> <br>  ,      .      ,  , .       . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); }</code> <br>      <code>Operator</code> ,    . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', };</code> <br>   .         <code>IsOperator</code>  <code>Tokenizer</code> . <br> <br> <code class="cpp"> bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); }</code> <br>         .        . <br> <br> <b class="spoiler_title">Interpreter.h</b> <code class="cpp">#pragma once; #include &lt;vector&gt; #include &lt;wchar.h&gt; #include &lt;algorithm&gt; namespace Interpreter { enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', }; inline std::wstring ToString(const Operator &amp;op) { return{ static_cast&lt;wchar_t&gt;(op) }; } enum class TokenType { Operator, Number }; inline std::wstring ToString(const TokenType &amp;type) { switch(type) { case TokenType::Operator: return L"Operator"; case TokenType::Number: return L"Number"; default: throw std::out_of_range("TokenType"); } } class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } friend inline bool operator==(const Token &amp;left, const Token &amp;right) { if(left.m_type == right.m_type) { switch(left.m_type) { case Interpreter::TokenType::Operator: return left.m_operator == right.m_operator; case Interpreter::TokenType::Number: return left.m_number == right.m_number; default: throw std::out_of_range("TokenType"); } } return false; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: throw std::out_of_range("TokenType"); } } typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); } } // namespace Lexer } // namespace Interpreter</code> <br> <br> <b class="spoiler_title">InterpreterTests.cpp</b> <code class="cpp">#include "stdafx.h" #include "CppUnitTest.h" #include "Interpreter.h" namespace InterpreterTests { using namespace Microsoft::VisualStudio::CppUnitTestFramework; using namespace Interpreter; using namespace std; namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual&lt;T&gt;(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange TEST_CLASS(LexerTests) { public: TEST_METHOD(Should_return_empty_token_list_when_put_empty_expression) { Tokens tokens = Lexer::Tokenize(L""); Assert::IsTrue(tokens.empty()); } TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); } TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); } TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); } TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); } }; TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); } TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); } TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); } }; }</code> <br> <br> <a href="https://github.com/Unril/InterpreterTDD/releases/tag/%25D0%259A%25D0%25BE%25D0%25BD%25D0%25B5%25D1%2586_%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B2%25D0%25BE%25D0%25B9_%25D1%2587%25D0%25B0%25D1%2581%25D1%2582%25D0%25B8">    GitHub</a> .         ,  .      "__". <br> <br>   <a href="http://habrahabr.ru/post/232081/">    </a> .      ,      <a href="http://habrahabr.ru/post/232097/">    </a> .</code> <ul><li> <code><code>std::vector,      Tokens</code> .            . <br> <br> <code class="cpp">#pragma once; #include &lt;vector&gt; namespace Interpreter { struct Token {}; typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { inline Tokens Tokenize(std::string expr) { throw std::exception(); } } // namespace Lexer } // namespace Interpreter</code> <br>   ,  ,   , .   ,    ,    <a href="http://cleancoder.posterous.com/the-transformation-priority-premise">The Transformation Priority Premise (TPP)</a>   .    , ,    ,     ,        .            .     ,     ,      ,           .  ,  ,   (   )    ,  ,  .     ,  ,         .     ,   TPP          . <br> <br>   : <br> <br> ({} ‚Üí nil)     ,   . (nil ‚Üí constant)    . (constant ‚Üí constant+)      (        ,  ). (constant ‚Üí scalar)    ,  . (statement ‚Üí statements)    (break, continue, return  ). (unconditional ‚Üí if)       . (scalar ‚Üí array)  / . (array ‚Üí container)     . (statement ‚Üí recursion)   . (if ‚Üí while)    . (expression ‚Üí function)   . (variable ‚Üí assignment)   . <br>        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::string expr) { return{}; }</code> <br> ,         .     . <br> <br> <s>         </s> .           .           .               .            .       . <br>  ,  <code>std::string</code>  <code>std::wstring</code> .         ,      Unicode.     . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); }</code> <br>  <code>AssertRange</code> -   ,       <code>AreEqual</code> ,   ,  ,    . <br> <br> <b class="spoiler_title">AssertRange</b> <code class="cpp">namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange</code> <br> <br>         <code>Operator</code>    .          <code>wchar_t</code>   ,         ,      . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', }; typedef Operator Token;</code> <br>    ,   ,        <code>Assert</code> ,    <code>ToString</code> ,    . <br> <br> <b class="spoiler_title">std::wstring ToString(const Token &amp;)</b> <code class="cpp">inline std::wstring ToString(const Token &amp;token) { return{ static_cast&lt;wchar_t&gt;(token) }; }</code> <br> <br>    ,   ,        .  ,   (unconditional ‚Üí if). <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { if(expr.empty()) { return{}; } return{ static_cast&lt;Operator&gt;(expr[0]) }; }</code> <br> <s>         </s> . <s>          .</s>           . ‚Ä¶ <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); }</code> <br>     .   ,     ,   - .    , : <br> <br>        ,      <code>Token</code> .       <code>dynamic_cast</code>    ,   .  ,    ,      .      <code>std::function</code>        .        .  Boost.Any,  - .            . <br>   ,   .      -  .  ,      ,      . <br> <br> ‚Ä¶        .        .        .        . <br>             . <br> <br> <code class="cpp">enum class TokenType { Operator, Number }; class Token { public: Token(Operator) {} TokenType Type() const { return TokenType::Operator; } }; ‚Ä¶ TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } };</code> <br>   <code>ToString</code>   <code>TokenType</code>       ,   ,   .     . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); }</code> <br>   .   (constant ‚Üí scalar)   . <br> <br> <code class="cpp">class Token { public: Token(Operator) :m_type(TokenType::Operator) {} Token(double) :m_type(TokenType::Number) {} TokenType Type() const { return m_type; } private: TokenType m_type; };</code> <br> ‚Ä¶ <s>       </s> . <s>       </s> .        .        . <br>    . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); }</code> <br>            . <br> <br> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} operator Operator() const { return m_operator; } ‚Ä¶ Operator m_operator; };</code> <br>      . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); }</code> <br>          ,  ,       <code>union</code> .         . <br> <br> <b class="spoiler_title">Token</b> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: return "Unknown token."; } }</code> <br> <br>  ,    ,      ,    .       .    . <br> <br> <i>          .</i>               .            .       . <br>        : <br> <br> <code class="cpp"> if(expr[0] &gt;= '0' &amp;&amp; expr[0] &lt;= '9') { return{ (double) expr[0] - '0' }; } return{ static_cast&lt;Operator&gt;(expr[0]) };</code> <br>      ,   . <br> <br> ‚Ä¶ <s>          .</s> <i>              .</i> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); }</code> <br> ,     <code>C</code>   ,  <code>isdigit</code> , ,       <code>atof</code> ,    ,      <code>wchar_t</code> .  (expression ‚Üí function).         . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { const wchar_t *current = expr.c_str(); if(!*current) return{}; if(iswdigit(*current)) return{ _wtof(current) }; return{ static_cast&lt;Operator&gt;(*current) }; }</code> <br>         .      . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>   ,        .  ,     .     .   <code>result</code> ,     . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); if(!*current) return result; if(iswdigit(*current)) { result.push_back(_wtof(current)); } else { result.push_back(static_cast&lt;Operator&gt;(*current)); } return result; }</code> <br>      :   (if ‚Üí while).     ,        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } } return result; }</code> <br>  <code>wcstod</code>    ,   <code>_wtof</code> ,           .           ,              .  ,    . <br> <br> <s>           .</s>       . <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>  (unconditional ‚Üí if)    ,    . <br> <br> <code class="cpp"> while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else if(*current == static_cast&lt;wchar_t&gt;(Operator::Plus)) { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } else { ++current; } }</code> <br>       .          .       <code>Detail</code>      .   <code>Tokenize</code>       . <br> <br> <code class="cpp">inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); }</code> <br> <b class="spoiler_title"> Detail::Tokenizer</b> <code class="cpp">namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { return *m_current == static_cast&lt;wchar_t&gt;(Operator::Plus); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail</code> <br> <br>  ,      .      ,  , .       . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); }</code> <br>      <code>Operator</code> ,    . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', };</code> <br>   .         <code>IsOperator</code>  <code>Tokenizer</code> . <br> <br> <code class="cpp"> bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); }</code> <br>         .        . <br> <br> <b class="spoiler_title">Interpreter.h</b> <code class="cpp">#pragma once; #include &lt;vector&gt; #include &lt;wchar.h&gt; #include &lt;algorithm&gt; namespace Interpreter { enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', }; inline std::wstring ToString(const Operator &amp;op) { return{ static_cast&lt;wchar_t&gt;(op) }; } enum class TokenType { Operator, Number }; inline std::wstring ToString(const TokenType &amp;type) { switch(type) { case TokenType::Operator: return L"Operator"; case TokenType::Number: return L"Number"; default: throw std::out_of_range("TokenType"); } } class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } friend inline bool operator==(const Token &amp;left, const Token &amp;right) { if(left.m_type == right.m_type) { switch(left.m_type) { case Interpreter::TokenType::Operator: return left.m_operator == right.m_operator; case Interpreter::TokenType::Number: return left.m_number == right.m_number; default: throw std::out_of_range("TokenType"); } } return false; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: throw std::out_of_range("TokenType"); } } typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); } } // namespace Lexer } // namespace Interpreter</code> <br> <br> <b class="spoiler_title">InterpreterTests.cpp</b> <code class="cpp">#include "stdafx.h" #include "CppUnitTest.h" #include "Interpreter.h" namespace InterpreterTests { using namespace Microsoft::VisualStudio::CppUnitTestFramework; using namespace Interpreter; using namespace std; namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual&lt;T&gt;(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange TEST_CLASS(LexerTests) { public: TEST_METHOD(Should_return_empty_token_list_when_put_empty_expression) { Tokens tokens = Lexer::Tokenize(L""); Assert::IsTrue(tokens.empty()); } TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); } TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); } TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); } TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); } }; TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); } TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); } TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); } }; }</code> <br> <br> <a href="https://github.com/Unril/InterpreterTDD/releases/tag/%25D0%259A%25D0%25BE%25D0%25BD%25D0%25B5%25D1%2586_%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B2%25D0%25BE%25D0%25B9_%25D1%2587%25D0%25B0%25D1%2581%25D1%2582%25D0%25B8">    GitHub</a> .         ,  .      "__". <br> <br>   <a href="http://habrahabr.ru/post/232081/">    </a> .      ,      <a href="http://habrahabr.ru/post/232097/">    </a> .</code> </li> <li> <code><s><code>std::vector,      Tokens</code> .            . <br> <br> <code class="cpp">#pragma once; #include &lt;vector&gt; namespace Interpreter { struct Token {}; typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { inline Tokens Tokenize(std::string expr) { throw std::exception(); } } // namespace Lexer } // namespace Interpreter</code> <br>   ,  ,   , .   ,    ,    <a href="http://cleancoder.posterous.com/the-transformation-priority-premise">The Transformation Priority Premise (TPP)</a>   .    , ,    ,     ,        .            .     ,     ,      ,           .  ,  ,   (   )    ,  ,  .     ,  ,         .     ,   TPP          . <br> <br>   : <br> <br> ({} ‚Üí nil)     ,   . (nil ‚Üí constant)    . (constant ‚Üí constant+)      (        ,  ). (constant ‚Üí scalar)    ,  . (statement ‚Üí statements)    (break, continue, return  ). (unconditional ‚Üí if)       . (scalar ‚Üí array)  / . (array ‚Üí container)     . (statement ‚Üí recursion)   . (if ‚Üí while)    . (expression ‚Üí function)   . (variable ‚Üí assignment)   . <br>        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::string expr) { return{}; }</code> <br> ,         .     . <br> <br> <s>         </s> .           .           .               .            .       . <br>  ,  <code>std::string</code>  <code>std::wstring</code> .         ,      Unicode.     . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); }</code> <br>  <code>AssertRange</code> -   ,       <code>AreEqual</code> ,   ,  ,    . <br> <br> <b class="spoiler_title">AssertRange</b> <code class="cpp">namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange</code> <br> <br>         <code>Operator</code>    .          <code>wchar_t</code>   ,         ,      . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', }; typedef Operator Token;</code> <br>    ,   ,        <code>Assert</code> ,    <code>ToString</code> ,    . <br> <br> <b class="spoiler_title">std::wstring ToString(const Token &amp;)</b> <code class="cpp">inline std::wstring ToString(const Token &amp;token) { return{ static_cast&lt;wchar_t&gt;(token) }; }</code> <br> <br>    ,   ,        .  ,   (unconditional ‚Üí if). <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { if(expr.empty()) { return{}; } return{ static_cast&lt;Operator&gt;(expr[0]) }; }</code> <br> <s>         </s> . <s>          .</s>           . ‚Ä¶ <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); }</code> <br>     .   ,     ,   - .    , : <br> <br>        ,      <code>Token</code> .       <code>dynamic_cast</code>    ,   .  ,    ,      .      <code>std::function</code>        .        .  Boost.Any,  - .            . <br>   ,   .      -  .  ,      ,      . <br> <br> ‚Ä¶        .        .        .        . <br>             . <br> <br> <code class="cpp">enum class TokenType { Operator, Number }; class Token { public: Token(Operator) {} TokenType Type() const { return TokenType::Operator; } }; ‚Ä¶ TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } };</code> <br>   <code>ToString</code>   <code>TokenType</code>       ,   ,   .     . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); }</code> <br>   .   (constant ‚Üí scalar)   . <br> <br> <code class="cpp">class Token { public: Token(Operator) :m_type(TokenType::Operator) {} Token(double) :m_type(TokenType::Number) {} TokenType Type() const { return m_type; } private: TokenType m_type; };</code> <br> ‚Ä¶ <s>       </s> . <s>       </s> .        .        . <br>    . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); }</code> <br>            . <br> <br> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} operator Operator() const { return m_operator; } ‚Ä¶ Operator m_operator; };</code> <br>      . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); }</code> <br>          ,  ,       <code>union</code> .         . <br> <br> <b class="spoiler_title">Token</b> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: return "Unknown token."; } }</code> <br> <br>  ,    ,      ,    .       .    . <br> <br> <i>          .</i>               .            .       . <br>        : <br> <br> <code class="cpp"> if(expr[0] &gt;= '0' &amp;&amp; expr[0] &lt;= '9') { return{ (double) expr[0] - '0' }; } return{ static_cast&lt;Operator&gt;(expr[0]) };</code> <br>      ,   . <br> <br> ‚Ä¶           . <i>              .</i> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); }</code> <br> ,     <code>C</code>   ,  <code>isdigit</code> , ,       <code>atof</code> ,    ,      <code>wchar_t</code> .  (expression ‚Üí function).         . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { const wchar_t *current = expr.c_str(); if(!*current) return{}; if(iswdigit(*current)) return{ _wtof(current) }; return{ static_cast&lt;Operator&gt;(*current) }; }</code> <br>         .      . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>   ,        .  ,     .     .   <code>result</code> ,     . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); if(!*current) return result; if(iswdigit(*current)) { result.push_back(_wtof(current)); } else { result.push_back(static_cast&lt;Operator&gt;(*current)); } return result; }</code> <br>      :   (if ‚Üí while).     ,        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } } return result; }</code> <br>  <code>wcstod</code>    ,   <code>_wtof</code> ,           .           ,              .  ,    . <br> <br> <s>           .</s>       . <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>  (unconditional ‚Üí if)    ,    . <br> <br> <code class="cpp"> while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else if(*current == static_cast&lt;wchar_t&gt;(Operator::Plus)) { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } else { ++current; } }</code> <br>       .          .       <code>Detail</code>      .   <code>Tokenize</code>       . <br> <br> <code class="cpp">inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); }</code> <br> <b class="spoiler_title"> Detail::Tokenizer</b> <code class="cpp">namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { return *m_current == static_cast&lt;wchar_t&gt;(Operator::Plus); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail</code> <br> <br>  ,      .      ,  , .       . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); }</code> <br>      <code>Operator</code> ,    . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', };</code> <br>   .         <code>IsOperator</code>  <code>Tokenizer</code> . <br> <br> <code class="cpp"> bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); }</code> <br>         .        . <br> <br> <b class="spoiler_title">Interpreter.h</b> <code class="cpp">#pragma once; #include &lt;vector&gt; #include &lt;wchar.h&gt; #include &lt;algorithm&gt; namespace Interpreter { enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', }; inline std::wstring ToString(const Operator &amp;op) { return{ static_cast&lt;wchar_t&gt;(op) }; } enum class TokenType { Operator, Number }; inline std::wstring ToString(const TokenType &amp;type) { switch(type) { case TokenType::Operator: return L"Operator"; case TokenType::Number: return L"Number"; default: throw std::out_of_range("TokenType"); } } class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } friend inline bool operator==(const Token &amp;left, const Token &amp;right) { if(left.m_type == right.m_type) { switch(left.m_type) { case Interpreter::TokenType::Operator: return left.m_operator == right.m_operator; case Interpreter::TokenType::Number: return left.m_number == right.m_number; default: throw std::out_of_range("TokenType"); } } return false; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: throw std::out_of_range("TokenType"); } } typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); } } // namespace Lexer } // namespace Interpreter</code> <br> <br> <b class="spoiler_title">InterpreterTests.cpp</b> <code class="cpp">#include "stdafx.h" #include "CppUnitTest.h" #include "Interpreter.h" namespace InterpreterTests { using namespace Microsoft::VisualStudio::CppUnitTestFramework; using namespace Interpreter; using namespace std; namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual&lt;T&gt;(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange TEST_CLASS(LexerTests) { public: TEST_METHOD(Should_return_empty_token_list_when_put_empty_expression) { Tokens tokens = Lexer::Tokenize(L""); Assert::IsTrue(tokens.empty()); } TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); } TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); } TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); } TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); } }; TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); } TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); } TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); } }; }</code> <br> <br> <a href="https://github.com/Unril/InterpreterTDD/releases/tag/%25D0%259A%25D0%25BE%25D0%25BD%25D0%25B5%25D1%2586_%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B2%25D0%25BE%25D0%25B9_%25D1%2587%25D0%25B0%25D1%2581%25D1%2582%25D0%25B8">    GitHub</a> .         ,  .      "__". <br> <br>   <a href="http://habrahabr.ru/post/232081/">    </a> .      ,      <a href="http://habrahabr.ru/post/232097/">    </a> .</s></code> </li> <li> <code><i><code>std::vector,      Tokens</code> .            . <br> <br> <code class="cpp">#pragma once; #include &lt;vector&gt; namespace Interpreter { struct Token {}; typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { inline Tokens Tokenize(std::string expr) { throw std::exception(); } } // namespace Lexer } // namespace Interpreter</code> <br>   ,  ,   , .   ,    ,    <a href="http://cleancoder.posterous.com/the-transformation-priority-premise">The Transformation Priority Premise (TPP)</a>   .    , ,    ,     ,        .            .     ,     ,      ,           .  ,  ,   (   )    ,  ,  .     ,  ,         .     ,   TPP          . <br> <br>   : <br> <br> ({} ‚Üí nil)     ,   . (nil ‚Üí constant)    . (constant ‚Üí constant+)      (        ,  ). (constant ‚Üí scalar)    ,  . (statement ‚Üí statements)    (break, continue, return  ). (unconditional ‚Üí if)       . (scalar ‚Üí array)  / . (array ‚Üí container)     . (statement ‚Üí recursion)   . (if ‚Üí while)    . (expression ‚Üí function)   . (variable ‚Üí assignment)   . <br>        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::string expr) { return{}; }</code> <br> ,         .     . <br> <br> <s>         </s> .           .           .               .            .       . <br>  ,  <code>std::string</code>  <code>std::wstring</code> .         ,      Unicode.     . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); }</code> <br>  <code>AssertRange</code> -   ,       <code>AreEqual</code> ,   ,  ,    . <br> <br> <b class="spoiler_title">AssertRange</b> <code class="cpp">namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange</code> <br> <br>         <code>Operator</code>    .          <code>wchar_t</code>   ,         ,      . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', }; typedef Operator Token;</code> <br>    ,   ,        <code>Assert</code> ,    <code>ToString</code> ,    . <br> <br> <b class="spoiler_title">std::wstring ToString(const Token &amp;)</b> <code class="cpp">inline std::wstring ToString(const Token &amp;token) { return{ static_cast&lt;wchar_t&gt;(token) }; }</code> <br> <br>    ,   ,        .  ,   (unconditional ‚Üí if). <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { if(expr.empty()) { return{}; } return{ static_cast&lt;Operator&gt;(expr[0]) }; }</code> <br> <s>         </s> . <s>          .</s>           . ‚Ä¶ <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); }</code> <br>     .   ,     ,   - .    , : <br> <br>        ,      <code>Token</code> .       <code>dynamic_cast</code>    ,   .  ,    ,      .      <code>std::function</code>        .        .  Boost.Any,  - .            . <br>   ,   .      -  .  ,      ,      . <br> <br> ‚Ä¶        .        .        .        . <br>             . <br> <br> <code class="cpp">enum class TokenType { Operator, Number }; class Token { public: Token(Operator) {} TokenType Type() const { return TokenType::Operator; } }; ‚Ä¶ TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } };</code> <br>   <code>ToString</code>   <code>TokenType</code>       ,   ,   .     . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); }</code> <br>   .   (constant ‚Üí scalar)   . <br> <br> <code class="cpp">class Token { public: Token(Operator) :m_type(TokenType::Operator) {} Token(double) :m_type(TokenType::Number) {} TokenType Type() const { return m_type; } private: TokenType m_type; };</code> <br> ‚Ä¶ <s>       </s> . <s>       </s> .        .        . <br>    . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); }</code> <br>            . <br> <br> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} operator Operator() const { return m_operator; } ‚Ä¶ Operator m_operator; };</code> <br>      . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); }</code> <br>          ,  ,       <code>union</code> .         . <br> <br> <b class="spoiler_title">Token</b> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: return "Unknown token."; } }</code> <br> <br>  ,    ,      ,    .       .    . <br> <br> <i>          .</i>               .            .       . <br>        : <br> <br> <code class="cpp"> if(expr[0] &gt;= '0' &amp;&amp; expr[0] &lt;= '9') { return{ (double) expr[0] - '0' }; } return{ static_cast&lt;Operator&gt;(expr[0]) };</code> <br>      ,   . <br> <br> ‚Ä¶ <s>          .</s>               . <br> <code class="cpp"> TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); }</code> <br> ,     <code>C</code>   ,  <code>isdigit</code> , ,       <code>atof</code> ,    ,      <code>wchar_t</code> .  (expression ‚Üí function).         . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { const wchar_t *current = expr.c_str(); if(!*current) return{}; if(iswdigit(*current)) return{ _wtof(current) }; return{ static_cast&lt;Operator&gt;(*current) }; }</code> <br>         .      . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>   ,        .  ,     .     .   <code>result</code> ,     . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); if(!*current) return result; if(iswdigit(*current)) { result.push_back(_wtof(current)); } else { result.push_back(static_cast&lt;Operator&gt;(*current)); } return result; }</code> <br>      :   (if ‚Üí while).     ,        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } } return result; }</code> <br>  <code>wcstod</code>    ,   <code>_wtof</code> ,           .           ,              .  ,    . <br> <br> <s>           .</s>       . <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>  (unconditional ‚Üí if)    ,    . <br> <br> <code class="cpp"> while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else if(*current == static_cast&lt;wchar_t&gt;(Operator::Plus)) { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } else { ++current; } }</code> <br>       .          .       <code>Detail</code>      .   <code>Tokenize</code>       . <br> <br> <code class="cpp">inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); }</code> <br> <b class="spoiler_title"> Detail::Tokenizer</b> <code class="cpp">namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { return *m_current == static_cast&lt;wchar_t&gt;(Operator::Plus); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail</code> <br> <br>  ,      .      ,  , .       . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); }</code> <br>      <code>Operator</code> ,    . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', };</code> <br>   .         <code>IsOperator</code>  <code>Tokenizer</code> . <br> <br> <code class="cpp"> bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); }</code> <br>         .        . <br> <br> <b class="spoiler_title">Interpreter.h</b> <code class="cpp">#pragma once; #include &lt;vector&gt; #include &lt;wchar.h&gt; #include &lt;algorithm&gt; namespace Interpreter { enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', }; inline std::wstring ToString(const Operator &amp;op) { return{ static_cast&lt;wchar_t&gt;(op) }; } enum class TokenType { Operator, Number }; inline std::wstring ToString(const TokenType &amp;type) { switch(type) { case TokenType::Operator: return L"Operator"; case TokenType::Number: return L"Number"; default: throw std::out_of_range("TokenType"); } } class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } friend inline bool operator==(const Token &amp;left, const Token &amp;right) { if(left.m_type == right.m_type) { switch(left.m_type) { case Interpreter::TokenType::Operator: return left.m_operator == right.m_operator; case Interpreter::TokenType::Number: return left.m_number == right.m_number; default: throw std::out_of_range("TokenType"); } } return false; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: throw std::out_of_range("TokenType"); } } typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); } } // namespace Lexer } // namespace Interpreter</code> <br> <br> <b class="spoiler_title">InterpreterTests.cpp</b> <code class="cpp">#include "stdafx.h" #include "CppUnitTest.h" #include "Interpreter.h" namespace InterpreterTests { using namespace Microsoft::VisualStudio::CppUnitTestFramework; using namespace Interpreter; using namespace std; namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual&lt;T&gt;(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange TEST_CLASS(LexerTests) { public: TEST_METHOD(Should_return_empty_token_list_when_put_empty_expression) { Tokens tokens = Lexer::Tokenize(L""); Assert::IsTrue(tokens.empty()); } TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); } TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); } TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); } TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); } }; TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); } TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); } TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); } }; }</code> <br> <br> <a href="https://github.com/Unril/InterpreterTDD/releases/tag/%25D0%259A%25D0%25BE%25D0%25BD%25D0%25B5%25D1%2586_%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B2%25D0%25BE%25D0%25B9_%25D1%2587%25D0%25B0%25D1%2581%25D1%2582%25D0%25B8">    GitHub</a> .         ,  .      "__". <br> <br>   <a href="http://habrahabr.ru/post/232081/">    </a> .      ,      <a href="http://habrahabr.ru/post/232097/">    </a> .</i></code> </li> </ul> <code><code>std::vector,      Tokens</code> .            . <br> <br> <code class="cpp">#pragma once; #include &lt;vector&gt; namespace Interpreter { struct Token {}; typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { inline Tokens Tokenize(std::string expr) { throw std::exception(); } } // namespace Lexer } // namespace Interpreter</code> <br>   ,  ,   , .   ,    ,    <a href="http://cleancoder.posterous.com/the-transformation-priority-premise">The Transformation Priority Premise (TPP)</a>   .    , ,    ,     ,        .            .     ,     ,      ,           .  ,  ,   (   )    ,  ,  .     ,  ,         .     ,   TPP          . <br> <br>   : <br> <br> ({} ‚Üí nil)     ,   . (nil ‚Üí constant)    . (constant ‚Üí constant+)      (        ,  ). (constant ‚Üí scalar)    ,  . (statement ‚Üí statements)    (break, continue, return  ). (unconditional ‚Üí if)       . (scalar ‚Üí array)  / . (array ‚Üí container)     . (statement ‚Üí recursion)   . (if ‚Üí while)    . (expression ‚Üí function)   . (variable ‚Üí assignment)   . <br>        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::string expr) { return{}; }</code> <br> ,         .     . <br> <br> <s>         </s> .           .           .               .            .       . <br>  ,  <code>std::string</code>  <code>std::wstring</code> .         ,      Unicode.     . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); }</code> <br>  <code>AssertRange</code> -   ,       <code>AreEqual</code> ,   ,  ,    . <br> <br> <b class="spoiler_title">AssertRange</b> <code class="cpp">namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange</code> <br> <br>         <code>Operator</code>    .          <code>wchar_t</code>   ,         ,      . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', }; typedef Operator Token;</code> <br>    ,   ,        <code>Assert</code> ,    <code>ToString</code> ,    . <br> <br> <b class="spoiler_title">std::wstring ToString(const Token &amp;)</b> <code class="cpp">inline std::wstring ToString(const Token &amp;token) { return{ static_cast&lt;wchar_t&gt;(token) }; }</code> <br> <br>    ,   ,        .  ,   (unconditional ‚Üí if). <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { if(expr.empty()) { return{}; } return{ static_cast&lt;Operator&gt;(expr[0]) }; }</code> <br> <s>         </s> . <s>          .</s>           . ‚Ä¶ <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); }</code> <br>     .   ,     ,   - .    , : <br> <br>        ,      <code>Token</code> .       <code>dynamic_cast</code>    ,   .  ,    ,      .      <code>std::function</code>        .        .  Boost.Any,  - .            . <br>   ,   .      -  .  ,      ,      . <br> <br> ‚Ä¶        .        .        .        . <br>             . <br> <br> <code class="cpp">enum class TokenType { Operator, Number }; class Token { public: Token(Operator) {} TokenType Type() const { return TokenType::Operator; } }; ‚Ä¶ TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } };</code> <br>   <code>ToString</code>   <code>TokenType</code>       ,   ,   .     . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); }</code> <br>   .   (constant ‚Üí scalar)   . <br> <br> <code class="cpp">class Token { public: Token(Operator) :m_type(TokenType::Operator) {} Token(double) :m_type(TokenType::Number) {} TokenType Type() const { return m_type; } private: TokenType m_type; };</code> <br> ‚Ä¶ <s>       </s> . <s>       </s> .        .        . <br>    . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); }</code> <br>            . <br> <br> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} operator Operator() const { return m_operator; } ‚Ä¶ Operator m_operator; };</code> <br>      . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); }</code> <br>          ,  ,       <code>union</code> .         . <br> <br> <b class="spoiler_title">Token</b> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: return "Unknown token."; } }</code> <br> <br>  ,    ,      ,    .       .    . <br> <br> <i>          .</i>               .            .       . <br>        : <br> <br> <code class="cpp"> if(expr[0] &gt;= '0' &amp;&amp; expr[0] &lt;= '9') { return{ (double) expr[0] - '0' }; } return{ static_cast&lt;Operator&gt;(expr[0]) };</code> <br>      ,   . <br> <br> ‚Ä¶ <s>          .</s> <i>              .</i> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); }</code> <br> ,     <code>C</code>   ,  <code>isdigit</code> , ,       <code>atof</code> ,    ,      <code>wchar_t</code> .  (expression ‚Üí function).         . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { const wchar_t *current = expr.c_str(); if(!*current) return{}; if(iswdigit(*current)) return{ _wtof(current) }; return{ static_cast&lt;Operator&gt;(*current) }; }</code> <br>         .      . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>   ,        .  ,     .     .   <code>result</code> ,     . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); if(!*current) return result; if(iswdigit(*current)) { result.push_back(_wtof(current)); } else { result.push_back(static_cast&lt;Operator&gt;(*current)); } return result; }</code> <br>      :   (if ‚Üí while).     ,        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } } return result; }</code> <br>  <code>wcstod</code>    ,   <code>_wtof</code> ,           .           ,              .  ,    . <br> <br> <s>           .</s>       . <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>  (unconditional ‚Üí if)    ,    . <br> <br> <code class="cpp"> while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else if(*current == static_cast&lt;wchar_t&gt;(Operator::Plus)) { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } else { ++current; } }</code> <br>       .          .       <code>Detail</code>      .   <code>Tokenize</code>       . <br> <br> <code class="cpp">inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); }</code> <br> <b class="spoiler_title"> Detail::Tokenizer</b> <code class="cpp">namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { return *m_current == static_cast&lt;wchar_t&gt;(Operator::Plus); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail</code> <br> <br>  ,      .      ,  , .       . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); }</code> <br>      <code>Operator</code> ,    . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', };</code> <br>   .         <code>IsOperator</code>  <code>Tokenizer</code> . <br> <br> <code class="cpp"> bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); }</code> <br>         .        . <br> <br> <b class="spoiler_title">Interpreter.h</b> <code class="cpp">#pragma once; #include &lt;vector&gt; #include &lt;wchar.h&gt; #include &lt;algorithm&gt; namespace Interpreter { enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', }; inline std::wstring ToString(const Operator &amp;op) { return{ static_cast&lt;wchar_t&gt;(op) }; } enum class TokenType { Operator, Number }; inline std::wstring ToString(const TokenType &amp;type) { switch(type) { case TokenType::Operator: return L"Operator"; case TokenType::Number: return L"Number"; default: throw std::out_of_range("TokenType"); } } class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } friend inline bool operator==(const Token &amp;left, const Token &amp;right) { if(left.m_type == right.m_type) { switch(left.m_type) { case Interpreter::TokenType::Operator: return left.m_operator == right.m_operator; case Interpreter::TokenType::Number: return left.m_number == right.m_number; default: throw std::out_of_range("TokenType"); } } return false; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: throw std::out_of_range("TokenType"); } } typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); } } // namespace Lexer } // namespace Interpreter</code> <br> <br> <b class="spoiler_title">InterpreterTests.cpp</b> <code class="cpp">#include "stdafx.h" #include "CppUnitTest.h" #include "Interpreter.h" namespace InterpreterTests { using namespace Microsoft::VisualStudio::CppUnitTestFramework; using namespace Interpreter; using namespace std; namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual&lt;T&gt;(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange TEST_CLASS(LexerTests) { public: TEST_METHOD(Should_return_empty_token_list_when_put_empty_expression) { Tokens tokens = Lexer::Tokenize(L""); Assert::IsTrue(tokens.empty()); } TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); } TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); } TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); } TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); } }; TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); } TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); } TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); } }; }</code> <br> <br> <a href="https://github.com/Unril/InterpreterTDD/releases/tag/%25D0%259A%25D0%25BE%25D0%25BD%25D0%25B5%25D1%2586_%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B2%25D0%25BE%25D0%25B9_%25D1%2587%25D0%25B0%25D1%2581%25D1%2582%25D0%25B8">    GitHub</a> .         ,  .      "__". <br> <br>   <a href="http://habrahabr.ru/post/232081/">    </a> .      ,      <a href="http://habrahabr.ru/post/232097/">    </a> .</code> <pre> <code class="hljs lua"><code>std::vector,      Tokens</code> .            . <br> <br> <code class="cpp">#pragma once; #include &lt;vector&gt; namespace Interpreter { struct Token {}; typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { inline Tokens Tokenize(std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> expr) { throw std::exception(); } } // namespace Lexer } // namespace Interpreter</code> <br>   ,  ,   , .   ,    ,    <a href="http://cleancoder.posterous.com/the-transformation-priority-premise">The Transformation Priority Premise (TPP)</a>   .    , ,    ,     ,        .            .     ,     ,      ,           .  ,  ,   (   )    ,  ,  .     ,  ,         .     ,   TPP          . <br> <br>   : <br> <br> ({} ‚Üí <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)     ,   . (<span class="hljs-literal"><span class="hljs-literal">nil</span></span> ‚Üí constant)    . (constant ‚Üí constant+)      (        ,  ). (constant ‚Üí scalar)    ,  . (statement ‚Üí statements)    (<span class="hljs-keyword"><span class="hljs-keyword">break</span></span>, continue, <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>  ). (unconditional ‚Üí <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>)       . (scalar ‚Üí array)  / . (array ‚Üí container)     . (statement ‚Üí recursion)   . (<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ‚Üí <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>)    . (expression ‚Üí <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">)</span></span>   . (variable ‚Üí assignment)   . <br>        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> expr) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{}; }</code> <br> ,         .     . <br> <br> <s>         </s> .           .           .               .            .       . <br>  ,  <code>std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span></code>  <code>std::wstring</code> .         ,      Unicode.     . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"+"</span></span>); AssertRange::AreEqual({ Operator::Plus }, tokens); }</code> <br>  <code>AssertRange</code> -   ,       <code>AreEqual</code> ,   ,  ,    . <br> <br> <b class="spoiler_title">AssertRange</b> <code class="cpp">namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(expect)), distance(actualIter, <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(actual)), L<span class="hljs-string"><span class="hljs-string">"Size differs."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(; expectIter != <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(expect) &amp;&amp; actualIter != <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(actual); ++expectIter, ++actualIter) { auto message = L<span class="hljs-string"><span class="hljs-string">"Mismatch in position "</span></span> + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange</code> <br> <br>         <code>Operator</code>    .          <code>wchar_t</code>   ,         ,      . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L<span class="hljs-string"><span class="hljs-string">'+'</span></span>, }; typedef Operator Token;</code> <br>    ,   ,        <code>Assert</code> ,    <code>ToString</code> ,    . <br> <br> <b class="spoiler_title">std::wstring ToString(const Token &amp;)</b> <code class="cpp">inline std::wstring ToString(const Token &amp;token) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ static_cast&lt;wchar_t&gt;(token) }; }</code> <br> <br>    ,   ,        .  ,   (unconditional ‚Üí <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>). <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(expr.empty()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{}; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ static_cast&lt;Operator&gt;(expr[<span class="hljs-number"><span class="hljs-number">0</span></span>]) }; }</code> <br> <s>         </s> . <s>          .</s>           . ‚Ä¶ <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"1"</span></span>); AssertRange::AreEqual({ <span class="hljs-number"><span class="hljs-number">1.0</span></span> }, tokens); }</code> <br>     .   ,     ,   - .    , : <br> <br>        ,      <code>Token</code> .       <code>dynamic_cast</code>    ,   .  ,    ,      .      <code>std::<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span></span></code><span class="hljs-function"><span class="hljs-function">        .        .  </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Boost.Any</span></span></span><span class="hljs-function">,  - .            . </span></span><br><span class="hljs-function"><span class="hljs-function">   ,   .      -  .  ,      ,      . </span></span><br><span class="hljs-function"><span class="hljs-function"> </span></span><br><span class="hljs-function"><span class="hljs-function"> ‚Ä¶        .        .        .        . </span></span><br><span class="hljs-function"><span class="hljs-function">             . </span></span><br><span class="hljs-function"><span class="hljs-function"> </span></span><br><span class="hljs-function"><span class="hljs-function"> </span></span><code class="cpp"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">enum</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">class</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TokenType</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Operator</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Number</span></span></span><span class="hljs-function"> }; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">class</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Token</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">public</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Token</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Operator)</span></span></span></span> {} TokenType Type() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TokenType::Operator; } }; ‚Ä¶ TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } };</code> <br>   <code>ToString</code>   <code>TokenType</code>       ,   ,   .     . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_type_for_number_token) { Token numToken(<span class="hljs-number"><span class="hljs-number">1.2</span></span>); Assert::AreEqual(TokenType::Number, numToken.Type()); }</code> <br>   .   (constant ‚Üí scalar)   . <br> <br> <code class="cpp">class Token { public: Token(Operator) :m_type(TokenType::Operator) {} Token(double) :m_type(TokenType::Number) {} TokenType Type() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_type; } private: TokenType m_type; };</code> <br> ‚Ä¶ <s>       </s> . <s>       </s> .        .        . <br>    . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); }</code> <br>            . <br> <br> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} operator Operator() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_operator; } ‚Ä¶ Operator m_operator; };</code> <br>      . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_number_value_from_number_token) { Token token(<span class="hljs-number"><span class="hljs-number">1.23</span></span>); Assert::AreEqual&lt;double&gt;(<span class="hljs-number"><span class="hljs-number">1.23</span></span>, token); }</code> <br>          ,  ,       <code>union</code> .         . <br> <br> <b class="spoiler_title">Token</b> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_type; } operator Operator() const { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(m_type != TokenType::Operator) throw std::logic_error(<span class="hljs-string"><span class="hljs-string">"Should be operator token."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_operator; } operator double() const { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(m_type != TokenType::Number) throw std::logic_error(<span class="hljs-string"><span class="hljs-string">"Should be number token."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_number; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ToString(static_cast&lt;Operator&gt;(token)); default: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Unknown token."</span></span>; } }</code> <br> <br>  ,    ,      ,    .       .    . <br> <br> <i>          .</i>               .            .       . <br>        : <br> <br> <code class="cpp"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(expr[<span class="hljs-number"><span class="hljs-number">0</span></span>] &gt;= <span class="hljs-string"><span class="hljs-string">'0'</span></span> &amp;&amp; expr[<span class="hljs-number"><span class="hljs-number">0</span></span>] &lt;= <span class="hljs-string"><span class="hljs-string">'9'</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ (double) expr[<span class="hljs-number"><span class="hljs-number">0</span></span>] - <span class="hljs-string"><span class="hljs-string">'0'</span></span> }; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ static_cast&lt;Operator&gt;(expr[<span class="hljs-number"><span class="hljs-number">0</span></span>]) };</code> <br>      ,   . <br> <br> ‚Ä¶ <s>          .</s> <i>              .</i> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"12.34"</span></span>); AssertRange::AreEqual({ <span class="hljs-number"><span class="hljs-number">12.34</span></span> }, tokens); }</code> <br> ,     <code>C</code>   ,  <code>isdigit</code> , ,       <code>atof</code> ,    ,      <code>wchar_t</code> .  (expression ‚Üí <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">)</span></span>.         . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { const wchar_t *current = expr.c_str(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!*current) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{}; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(iswdigit(*current)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ _wtof(current) }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ static_cast&lt;Operator&gt;(*current) }; }</code> <br>         .      . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"+12.34"</span></span>); AssertRange::AreEqual({ Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">12.34</span></span>) }, tokens); }</code> <br>   ,        .  ,     .     .   <code>result</code> ,     . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!*current) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(iswdigit(*current)) { result.push_back(_wtof(current)); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { result.push_back(static_cast&lt;Operator&gt;(*current)); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> <br>      :   (<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ‚Üí <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>).     ,        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(*current) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(iswdigit(*current)) { wchar_t *<span class="hljs-keyword"><span class="hljs-keyword">end</span></span> = nullptr; result.push_back(wcstod(current, &amp;<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>)); current = <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> <br>  <code>wcstod</code>    ,   <code>_wtof</code> ,           .           ,              .  ,    . <br> <br> <s>           .</s>       . <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">" 1 + 12.34 "</span></span>); AssertRange::AreEqual({ Token(<span class="hljs-number"><span class="hljs-number">1.0</span></span>), Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">12.34</span></span>) }, tokens); }</code> <br>  (unconditional ‚Üí <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>)    ,    . <br> <br> <code class="cpp"> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(*current) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(iswdigit(*current)) { wchar_t *<span class="hljs-keyword"><span class="hljs-keyword">end</span></span> = nullptr; result.push_back(wcstod(current, &amp;<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>)); current = <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(*current == static_cast&lt;wchar_t&gt;(Operator::Plus)) { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { ++current; } }</code> <br>       .          .       <code>Detail</code>      .   <code>Tokenize</code>       . <br> <br> <code class="cpp">inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tokenizer.Result(); }</code> <br> <b class="spoiler_title"> Detail::Tokenizer</b> <code class="cpp">namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!EndOfExperssion()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(IsNumber()) { ScanNumber(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(IsOperator()) { ScanOperator(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { MoveNext(); } } } const Tokens &amp;Result() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_result; } private: bool EndOfExperssion() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_current == L<span class="hljs-string"><span class="hljs-string">'\0'</span></span>; } bool IsNumber() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> iswdigit(*m_current) != <span class="hljs-number"><span class="hljs-number">0</span></span>; } void ScanNumber() { wchar_t *<span class="hljs-keyword"><span class="hljs-keyword">end</span></span> = nullptr; m_result.push_back(wcstod(m_current, &amp;<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>)); m_current = <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; } bool IsOperator() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_current == static_cast&lt;wchar_t&gt;(Operator::Plus); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail</code> <br> <br>  ,      .      ,  , .       . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"1+2*3/(4-5)"</span></span>); AssertRange::AreEqual({ Token(<span class="hljs-number"><span class="hljs-number">1</span></span>), Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">2</span></span>), Token(Operator::Mul), Token(<span class="hljs-number"><span class="hljs-number">3</span></span>), Token(Operator::Div), Token(Operator::LParen), Token(<span class="hljs-number"><span class="hljs-number">4</span></span>), Token(Operator::Minus), Token(<span class="hljs-number"><span class="hljs-number">5</span></span>), Token(Operator::RParen) }, tokens); }</code> <br>      <code>Operator</code> ,    . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L<span class="hljs-string"><span class="hljs-string">'+'</span></span>, Minus = L<span class="hljs-string"><span class="hljs-string">'-'</span></span>, Mul = L<span class="hljs-string"><span class="hljs-string">'*'</span></span>, Div = L<span class="hljs-string"><span class="hljs-string">'/'</span></span>, LParen = L<span class="hljs-string"><span class="hljs-string">'('</span></span>, RParen = L<span class="hljs-string"><span class="hljs-string">')'</span></span>, };</code> <br>   .         <code>IsOperator</code>  <code>Tokenizer</code> . <br> <br> <code class="cpp"> bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> std::any_of(all.begin(), all.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(), [this](Operator o) {<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_current == static_cast&lt;wchar_t&gt;(o); }); }</code> <br>         .        . <br> <br> <b class="spoiler_title">Interpreter.h</b> <code class="cpp">#pragma once; #include &lt;vector&gt; #include &lt;wchar.h&gt; #include &lt;algorithm&gt; namespace Interpreter { enum class Operator : wchar_t { Plus = L<span class="hljs-string"><span class="hljs-string">'+'</span></span>, Minus = L<span class="hljs-string"><span class="hljs-string">'-'</span></span>, Mul = L<span class="hljs-string"><span class="hljs-string">'*'</span></span>, Div = L<span class="hljs-string"><span class="hljs-string">'/'</span></span>, LParen = L<span class="hljs-string"><span class="hljs-string">'('</span></span>, RParen = L<span class="hljs-string"><span class="hljs-string">')'</span></span>, }; inline std::wstring ToString(const Operator &amp;op) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ static_cast&lt;wchar_t&gt;(op) }; } enum class TokenType { Operator, Number }; inline std::wstring ToString(const TokenType &amp;<span class="hljs-built_in"><span class="hljs-built_in">type</span></span>) { switch(<span class="hljs-built_in"><span class="hljs-built_in">type</span></span>) { case TokenType::Operator: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> L<span class="hljs-string"><span class="hljs-string">"Operator"</span></span>; case TokenType::Number: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> L<span class="hljs-string"><span class="hljs-string">"Number"</span></span>; default: throw std::out_of_range(<span class="hljs-string"><span class="hljs-string">"TokenType"</span></span>); } } class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_type; } operator Operator() const { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(m_type != TokenType::Operator) throw std::logic_error(<span class="hljs-string"><span class="hljs-string">"Should be operator token."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_operator; } operator double() const { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(m_type != TokenType::Number) throw std::logic_error(<span class="hljs-string"><span class="hljs-string">"Should be number token."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_number; } friend inline bool operator==(const Token &amp;left, const Token &amp;right) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(left.m_type == right.m_type) { switch(left.m_type) { case Interpreter::TokenType::Operator: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> left.m_operator == right.m_operator; case Interpreter::TokenType::Number: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> left.m_number == right.m_number; default: throw std::out_of_range(<span class="hljs-string"><span class="hljs-string">"TokenType"</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ToString(static_cast&lt;Operator&gt;(token)); default: throw std::out_of_range(<span class="hljs-string"><span class="hljs-string">"TokenType"</span></span>); } } typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!EndOfExperssion()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(IsNumber()) { ScanNumber(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(IsOperator()) { ScanOperator(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { MoveNext(); } } } const Tokens &amp;Result() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_result; } private: bool EndOfExperssion() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_current == L<span class="hljs-string"><span class="hljs-string">'\0'</span></span>; } bool IsNumber() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> iswdigit(*m_current) != <span class="hljs-number"><span class="hljs-number">0</span></span>; } void ScanNumber() { wchar_t *<span class="hljs-keyword"><span class="hljs-keyword">end</span></span> = nullptr; m_result.push_back(wcstod(m_current, &amp;<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>)); m_current = <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; } bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> std::any_of(all.begin(), all.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(), [this](Operator o) {<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_current == static_cast&lt;wchar_t&gt;(o); }); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tokenizer.Result(); } } // namespace Lexer } // namespace Interpreter</code> <br> <br> <b class="spoiler_title">InterpreterTests.cpp</b> <code class="cpp">#include <span class="hljs-string"><span class="hljs-string">"stdafx.h"</span></span> #include <span class="hljs-string"><span class="hljs-string">"CppUnitTest.h"</span></span> #include <span class="hljs-string"><span class="hljs-string">"Interpreter.h"</span></span> namespace InterpreterTests { using namespace Microsoft::VisualStudio::CppUnitTestFramework; using namespace Interpreter; using namespace std; namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(expect)), distance(actualIter, <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(actual)), L<span class="hljs-string"><span class="hljs-string">"Size differs."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(; expectIter != <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(expect) &amp;&amp; actualIter != <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(actual); ++expectIter, ++actualIter) { auto message = L<span class="hljs-string"><span class="hljs-string">"Mismatch in position "</span></span> + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual&lt;T&gt;(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange TEST_CLASS(LexerTests) { public: TEST_METHOD(Should_return_empty_token_list_when_put_empty_expression) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">""</span></span>); Assert::IsTrue(tokens.empty()); } TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"+"</span></span>); AssertRange::AreEqual({ Operator::Plus }, tokens); } TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"1"</span></span>); AssertRange::AreEqual({ <span class="hljs-number"><span class="hljs-number">1.0</span></span> }, tokens); } TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"12.34"</span></span>); AssertRange::AreEqual({ <span class="hljs-number"><span class="hljs-number">12.34</span></span> }, tokens); } TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"+12.34"</span></span>); AssertRange::AreEqual({ Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">12.34</span></span>) }, tokens); } TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">" 1 + 12.34 "</span></span>); AssertRange::AreEqual({ Token(<span class="hljs-number"><span class="hljs-number">1.0</span></span>), Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">12.34</span></span>) }, tokens); } TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"1+2*3/(4-5)"</span></span>); AssertRange::AreEqual({ Token(<span class="hljs-number"><span class="hljs-number">1</span></span>), Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">2</span></span>), Token(Operator::Mul), Token(<span class="hljs-number"><span class="hljs-number">3</span></span>), Token(Operator::Div), Token(Operator::LParen), Token(<span class="hljs-number"><span class="hljs-number">4</span></span>), Token(Operator::Minus), Token(<span class="hljs-number"><span class="hljs-number">5</span></span>), Token(Operator::RParen) }, tokens); } }; TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } TEST_METHOD(Should_get_type_for_number_token) { Token numToken(<span class="hljs-number"><span class="hljs-number">1.2</span></span>); Assert::AreEqual(TokenType::Number, numToken.Type()); } TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); } TEST_METHOD(Should_get_number_value_from_number_token) { Token token(<span class="hljs-number"><span class="hljs-number">1.23</span></span>); Assert::AreEqual&lt;double&gt;(<span class="hljs-number"><span class="hljs-number">1.23</span></span>, token); } }; }</code> <br> <br> <a href="https://github.com/Unril/InterpreterTDD/releases/tag/%25D0%259A%25D0%25BE%25D0%25BD%25D0%25B5%25D1%2586_%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B2%25D0%25BE%25D0%25B9_%25D1%2587%25D0%25B0%25D1%2581%25D1%2582%25D0%25B8">    GitHub</a> .         ,  .      <span class="hljs-string"><span class="hljs-string">"__"</span></span>. <br> <br>   <a href="http://habrahabr.ru/post/232081/">    </a> .      ,      <a href="http://habrahabr.ru/post/232097/">    </a> .</code> </pre> <code><code>std::vector,      Tokens</code> .            . <br> <br> <code class="cpp">#pragma once; #include &lt;vector&gt; namespace Interpreter { struct Token {}; typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { inline Tokens Tokenize(std::string expr) { throw std::exception(); } } // namespace Lexer } // namespace Interpreter</code> <br>   ,  ,   , .   ,    ,    <a href="http://cleancoder.posterous.com/the-transformation-priority-premise">The Transformation Priority Premise (TPP)</a>   .    , ,    ,     ,        .            .     ,     ,      ,           .  ,  ,   (   )    ,  ,  .     ,  ,         .     ,   TPP          . <br> <br>   : <br> <br> ({} ‚Üí nil)     ,   . (nil ‚Üí constant)    . (constant ‚Üí constant+)      (        ,  ). (constant ‚Üí scalar)    ,  . (statement ‚Üí statements)    (break, continue, return  ). (unconditional ‚Üí if)       . (scalar ‚Üí array)  / . (array ‚Üí container)     . (statement ‚Üí recursion)   . (if ‚Üí while)    . (expression ‚Üí function)   . (variable ‚Üí assignment)   . <br>        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::string expr) { return{}; }</code> <br> ,         .     . <br> <br> <s>         </s> .           .           .               .            .       . <br>  ,  <code>std::string</code>  <code>std::wstring</code> .         ,      Unicode.     . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); }</code> <br>  <code>AssertRange</code> -   ,       <code>AreEqual</code> ,   ,  ,    . <br> <br> <b class="spoiler_title">AssertRange</b> <code class="cpp">namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange</code> <br> <br>         <code>Operator</code>    .          <code>wchar_t</code>   ,         ,      . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', }; typedef Operator Token;</code> <br>    ,   ,        <code>Assert</code> ,    <code>ToString</code> ,    . <br> <br> <b class="spoiler_title">std::wstring ToString(const Token &amp;)</b> <code class="cpp">inline std::wstring ToString(const Token &amp;token) { return{ static_cast&lt;wchar_t&gt;(token) }; }</code> <br> <br>    ,   ,        .  ,   (unconditional ‚Üí if). <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { if(expr.empty()) { return{}; } return{ static_cast&lt;Operator&gt;(expr[0]) }; }</code> <br> <s>         </s> . <s>          .</s>           . ‚Ä¶ <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); }</code> <br>     .   ,     ,   - .    , : <br> <br>        ,      <code>Token</code> .       <code>dynamic_cast</code>    ,   .  ,    ,      .      <code>std::function</code>        .        .  Boost.Any,  - .            . <br>   ,   .      -  .  ,      ,      . <br> <br> ‚Ä¶        .        .        .        . <br>             . <br> <br> <code class="cpp">enum class TokenType { Operator, Number }; class Token { public: Token(Operator) {} TokenType Type() const { return TokenType::Operator; } }; ‚Ä¶ TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } };</code> <br>   <code>ToString</code>   <code>TokenType</code>       ,   ,   .     . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); }</code> <br>   .   (constant ‚Üí scalar)   . <br> <br> <code class="cpp">class Token { public: Token(Operator) :m_type(TokenType::Operator) {} Token(double) :m_type(TokenType::Number) {} TokenType Type() const { return m_type; } private: TokenType m_type; };</code> <br> ‚Ä¶ <s>       </s> . <s>       </s> .        .        . <br>    . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); }</code> <br>            . <br> <br> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} operator Operator() const { return m_operator; } ‚Ä¶ Operator m_operator; };</code> <br>      . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); }</code> <br>          ,  ,       <code>union</code> .         . <br> <br> <b class="spoiler_title">Token</b> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: return "Unknown token."; } }</code> <br> <br>  ,    ,      ,    .       .    . <br> <br> <i>          .</i>               .            .       . <br>        : <br> <br> <code class="cpp"> if(expr[0] &gt;= '0' &amp;&amp; expr[0] &lt;= '9') { return{ (double) expr[0] - '0' }; } return{ static_cast&lt;Operator&gt;(expr[0]) };</code> <br>      ,   . <br> <br> ‚Ä¶ <s>          .</s> <i>              .</i> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); }</code> <br> ,     <code>C</code>   ,  <code>isdigit</code> , ,       <code>atof</code> ,    ,      <code>wchar_t</code> .  (expression ‚Üí function).         . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { const wchar_t *current = expr.c_str(); if(!*current) return{}; if(iswdigit(*current)) return{ _wtof(current) }; return{ static_cast&lt;Operator&gt;(*current) }; }</code> <br>         .      . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>   ,        .  ,     .     .   <code>result</code> ,     . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); if(!*current) return result; if(iswdigit(*current)) { result.push_back(_wtof(current)); } else { result.push_back(static_cast&lt;Operator&gt;(*current)); } return result; }</code> <br>      :   (if ‚Üí while).     ,        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } } return result; }</code> <br>  <code>wcstod</code>    ,   <code>_wtof</code> ,           .           ,              .  ,    . <br> <br> <s>           .</s>       . <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>  (unconditional ‚Üí if)    ,    . <br> <br> <code class="cpp"> while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else if(*current == static_cast&lt;wchar_t&gt;(Operator::Plus)) { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } else { ++current; } }</code> <br>       .          .       <code>Detail</code>      .   <code>Tokenize</code>       . <br> <br> <code class="cpp">inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); }</code> <br> <b class="spoiler_title"> Detail::Tokenizer</b> <code class="cpp">namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { return *m_current == static_cast&lt;wchar_t&gt;(Operator::Plus); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail</code> <br> <br>  ,      .      ,  , .       . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); }</code> <br>      <code>Operator</code> ,    . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', };</code> <br>   .         <code>IsOperator</code>  <code>Tokenizer</code> . <br> <br> <code class="cpp"> bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); }</code> <br>         .        . <br> <br> <b class="spoiler_title">Interpreter.h</b> <code class="cpp">#pragma once; #include &lt;vector&gt; #include &lt;wchar.h&gt; #include &lt;algorithm&gt; namespace Interpreter { enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', }; inline std::wstring ToString(const Operator &amp;op) { return{ static_cast&lt;wchar_t&gt;(op) }; } enum class TokenType { Operator, Number }; inline std::wstring ToString(const TokenType &amp;type) { switch(type) { case TokenType::Operator: return L"Operator"; case TokenType::Number: return L"Number"; default: throw std::out_of_range("TokenType"); } } class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } friend inline bool operator==(const Token &amp;left, const Token &amp;right) { if(left.m_type == right.m_type) { switch(left.m_type) { case Interpreter::TokenType::Operator: return left.m_operator == right.m_operator; case Interpreter::TokenType::Number: return left.m_number == right.m_number; default: throw std::out_of_range("TokenType"); } } return false; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: throw std::out_of_range("TokenType"); } } typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); } } // namespace Lexer } // namespace Interpreter</code> <br> <br> <b class="spoiler_title">InterpreterTests.cpp</b> <code class="cpp">#include "stdafx.h" #include "CppUnitTest.h" #include "Interpreter.h" namespace InterpreterTests { using namespace Microsoft::VisualStudio::CppUnitTestFramework; using namespace Interpreter; using namespace std; namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual&lt;T&gt;(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange TEST_CLASS(LexerTests) { public: TEST_METHOD(Should_return_empty_token_list_when_put_empty_expression) { Tokens tokens = Lexer::Tokenize(L""); Assert::IsTrue(tokens.empty()); } TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); } TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); } TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); } TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); } }; TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); } TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); } TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); } }; }</code> <br> <br> <a href="https://github.com/Unril/InterpreterTDD/releases/tag/%25D0%259A%25D0%25BE%25D0%25BD%25D0%25B5%25D1%2586_%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B2%25D0%25BE%25D0%25B9_%25D1%2587%25D0%25B0%25D1%2581%25D1%2582%25D0%25B8">    GitHub</a> .         ,  .      "__". <br> <br>   <a href="http://habrahabr.ru/post/232081/">    </a> .      ,      <a href="http://habrahabr.ru/post/232097/">    </a> .</code> <pre> <code class="hljs lua"><code>std::vector,      Tokens</code> .            . <br> <br> <code class="cpp">#pragma once; #include &lt;vector&gt; namespace Interpreter { struct Token {}; typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { inline Tokens Tokenize(std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> expr) { throw std::exception(); } } // namespace Lexer } // namespace Interpreter</code> <br>   ,  ,   , .   ,    ,    <a href="http://cleancoder.posterous.com/the-transformation-priority-premise">The Transformation Priority Premise (TPP)</a>   .    , ,    ,     ,        .            .     ,     ,      ,           .  ,  ,   (   )    ,  ,  .     ,  ,         .     ,   TPP          . <br> <br>   : <br> <br> ({} ‚Üí <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)     ,   . (<span class="hljs-literal"><span class="hljs-literal">nil</span></span> ‚Üí constant)    . (constant ‚Üí constant+)      (        ,  ). (constant ‚Üí scalar)    ,  . (statement ‚Üí statements)    (<span class="hljs-keyword"><span class="hljs-keyword">break</span></span>, continue, <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>  ). (unconditional ‚Üí <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>)       . (scalar ‚Üí array)  / . (array ‚Üí container)     . (statement ‚Üí recursion)   . (<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ‚Üí <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>)    . (expression ‚Üí <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">)</span></span>   . (variable ‚Üí assignment)   . <br>        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> expr) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{}; }</code> <br> ,         .     . <br> <br> <s>         </s> .           .           .               .            .       . <br>  ,  <code>std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span></code>  <code>std::wstring</code> .         ,      Unicode.     . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"+"</span></span>); AssertRange::AreEqual({ Operator::Plus }, tokens); }</code> <br>  <code>AssertRange</code> -   ,       <code>AreEqual</code> ,   ,  ,    . <br> <br> <b class="spoiler_title">AssertRange</b> <code class="cpp">namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(expect)), distance(actualIter, <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(actual)), L<span class="hljs-string"><span class="hljs-string">"Size differs."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(; expectIter != <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(expect) &amp;&amp; actualIter != <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(actual); ++expectIter, ++actualIter) { auto message = L<span class="hljs-string"><span class="hljs-string">"Mismatch in position "</span></span> + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange</code> <br> <br>         <code>Operator</code>    .          <code>wchar_t</code>   ,         ,      . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L<span class="hljs-string"><span class="hljs-string">'+'</span></span>, }; typedef Operator Token;</code> <br>    ,   ,        <code>Assert</code> ,    <code>ToString</code> ,    . <br> <br> <b class="spoiler_title">std::wstring ToString(const Token &amp;)</b> <code class="cpp">inline std::wstring ToString(const Token &amp;token) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ static_cast&lt;wchar_t&gt;(token) }; }</code> <br> <br>    ,   ,        .  ,   (unconditional ‚Üí <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>). <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(expr.empty()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{}; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ static_cast&lt;Operator&gt;(expr[<span class="hljs-number"><span class="hljs-number">0</span></span>]) }; }</code> <br> <s>         </s> . <s>          .</s>           . ‚Ä¶ <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"1"</span></span>); AssertRange::AreEqual({ <span class="hljs-number"><span class="hljs-number">1.0</span></span> }, tokens); }</code> <br>     .   ,     ,   - .    , : <br> <br>        ,      <code>Token</code> .       <code>dynamic_cast</code>    ,   .  ,    ,      .      <code>std::<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span></span></code><span class="hljs-function"><span class="hljs-function">        .        .  </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Boost.Any</span></span></span><span class="hljs-function">,  - .            . </span></span><br><span class="hljs-function"><span class="hljs-function">   ,   .      -  .  ,      ,      . </span></span><br><span class="hljs-function"><span class="hljs-function"> </span></span><br><span class="hljs-function"><span class="hljs-function"> ‚Ä¶        .        .        .        . </span></span><br><span class="hljs-function"><span class="hljs-function">             . </span></span><br><span class="hljs-function"><span class="hljs-function"> </span></span><br><span class="hljs-function"><span class="hljs-function"> </span></span><code class="cpp"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">enum</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">class</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TokenType</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Operator</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Number</span></span></span><span class="hljs-function"> }; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">class</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Token</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">public</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Token</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Operator)</span></span></span></span> {} TokenType Type() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TokenType::Operator; } }; ‚Ä¶ TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } };</code> <br>   <code>ToString</code>   <code>TokenType</code>       ,   ,   .     . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_type_for_number_token) { Token numToken(<span class="hljs-number"><span class="hljs-number">1.2</span></span>); Assert::AreEqual(TokenType::Number, numToken.Type()); }</code> <br>   .   (constant ‚Üí scalar)   . <br> <br> <code class="cpp">class Token { public: Token(Operator) :m_type(TokenType::Operator) {} Token(double) :m_type(TokenType::Number) {} TokenType Type() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_type; } private: TokenType m_type; };</code> <br> ‚Ä¶ <s>       </s> . <s>       </s> .        .        . <br>    . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); }</code> <br>            . <br> <br> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} operator Operator() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_operator; } ‚Ä¶ Operator m_operator; };</code> <br>      . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_number_value_from_number_token) { Token token(<span class="hljs-number"><span class="hljs-number">1.23</span></span>); Assert::AreEqual&lt;double&gt;(<span class="hljs-number"><span class="hljs-number">1.23</span></span>, token); }</code> <br>          ,  ,       <code>union</code> .         . <br> <br> <b class="spoiler_title">Token</b> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_type; } operator Operator() const { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(m_type != TokenType::Operator) throw std::logic_error(<span class="hljs-string"><span class="hljs-string">"Should be operator token."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_operator; } operator double() const { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(m_type != TokenType::Number) throw std::logic_error(<span class="hljs-string"><span class="hljs-string">"Should be number token."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_number; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ToString(static_cast&lt;Operator&gt;(token)); default: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Unknown token."</span></span>; } }</code> <br> <br>  ,    ,      ,    .       .    . <br> <br> <i>          .</i>               .            .       . <br>        : <br> <br> <code class="cpp"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(expr[<span class="hljs-number"><span class="hljs-number">0</span></span>] &gt;= <span class="hljs-string"><span class="hljs-string">'0'</span></span> &amp;&amp; expr[<span class="hljs-number"><span class="hljs-number">0</span></span>] &lt;= <span class="hljs-string"><span class="hljs-string">'9'</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ (double) expr[<span class="hljs-number"><span class="hljs-number">0</span></span>] - <span class="hljs-string"><span class="hljs-string">'0'</span></span> }; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ static_cast&lt;Operator&gt;(expr[<span class="hljs-number"><span class="hljs-number">0</span></span>]) };</code> <br>      ,   . <br> <br> ‚Ä¶ <s>          .</s> <i>              .</i> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"12.34"</span></span>); AssertRange::AreEqual({ <span class="hljs-number"><span class="hljs-number">12.34</span></span> }, tokens); }</code> <br> ,     <code>C</code>   ,  <code>isdigit</code> , ,       <code>atof</code> ,    ,      <code>wchar_t</code> .  (expression ‚Üí <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">)</span></span>.         . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { const wchar_t *current = expr.c_str(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!*current) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{}; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(iswdigit(*current)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ _wtof(current) }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ static_cast&lt;Operator&gt;(*current) }; }</code> <br>         .      . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"+12.34"</span></span>); AssertRange::AreEqual({ Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">12.34</span></span>) }, tokens); }</code> <br>   ,        .  ,     .     .   <code>result</code> ,     . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!*current) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(iswdigit(*current)) { result.push_back(_wtof(current)); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { result.push_back(static_cast&lt;Operator&gt;(*current)); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> <br>      :   (<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ‚Üí <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>).     ,        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(*current) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(iswdigit(*current)) { wchar_t *<span class="hljs-keyword"><span class="hljs-keyword">end</span></span> = nullptr; result.push_back(wcstod(current, &amp;<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>)); current = <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> <br>  <code>wcstod</code>    ,   <code>_wtof</code> ,           .           ,              .  ,    . <br> <br> <s>           .</s>       . <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">" 1 + 12.34 "</span></span>); AssertRange::AreEqual({ Token(<span class="hljs-number"><span class="hljs-number">1.0</span></span>), Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">12.34</span></span>) }, tokens); }</code> <br>  (unconditional ‚Üí <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>)    ,    . <br> <br> <code class="cpp"> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(*current) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(iswdigit(*current)) { wchar_t *<span class="hljs-keyword"><span class="hljs-keyword">end</span></span> = nullptr; result.push_back(wcstod(current, &amp;<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>)); current = <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(*current == static_cast&lt;wchar_t&gt;(Operator::Plus)) { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { ++current; } }</code> <br>       .          .       <code>Detail</code>      .   <code>Tokenize</code>       . <br> <br> <code class="cpp">inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tokenizer.Result(); }</code> <br> <b class="spoiler_title"> Detail::Tokenizer</b> <code class="cpp">namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!EndOfExperssion()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(IsNumber()) { ScanNumber(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(IsOperator()) { ScanOperator(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { MoveNext(); } } } const Tokens &amp;Result() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_result; } private: bool EndOfExperssion() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_current == L<span class="hljs-string"><span class="hljs-string">'\0'</span></span>; } bool IsNumber() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> iswdigit(*m_current) != <span class="hljs-number"><span class="hljs-number">0</span></span>; } void ScanNumber() { wchar_t *<span class="hljs-keyword"><span class="hljs-keyword">end</span></span> = nullptr; m_result.push_back(wcstod(m_current, &amp;<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>)); m_current = <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; } bool IsOperator() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_current == static_cast&lt;wchar_t&gt;(Operator::Plus); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail</code> <br> <br>  ,      .      ,  , .       . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"1+2*3/(4-5)"</span></span>); AssertRange::AreEqual({ Token(<span class="hljs-number"><span class="hljs-number">1</span></span>), Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">2</span></span>), Token(Operator::Mul), Token(<span class="hljs-number"><span class="hljs-number">3</span></span>), Token(Operator::Div), Token(Operator::LParen), Token(<span class="hljs-number"><span class="hljs-number">4</span></span>), Token(Operator::Minus), Token(<span class="hljs-number"><span class="hljs-number">5</span></span>), Token(Operator::RParen) }, tokens); }</code> <br>      <code>Operator</code> ,    . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L<span class="hljs-string"><span class="hljs-string">'+'</span></span>, Minus = L<span class="hljs-string"><span class="hljs-string">'-'</span></span>, Mul = L<span class="hljs-string"><span class="hljs-string">'*'</span></span>, Div = L<span class="hljs-string"><span class="hljs-string">'/'</span></span>, LParen = L<span class="hljs-string"><span class="hljs-string">'('</span></span>, RParen = L<span class="hljs-string"><span class="hljs-string">')'</span></span>, };</code> <br>   .         <code>IsOperator</code>  <code>Tokenizer</code> . <br> <br> <code class="cpp"> bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> std::any_of(all.begin(), all.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(), [this](Operator o) {<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_current == static_cast&lt;wchar_t&gt;(o); }); }</code> <br>         .        . <br> <br> <b class="spoiler_title">Interpreter.h</b> <code class="cpp">#pragma once; #include &lt;vector&gt; #include &lt;wchar.h&gt; #include &lt;algorithm&gt; namespace Interpreter { enum class Operator : wchar_t { Plus = L<span class="hljs-string"><span class="hljs-string">'+'</span></span>, Minus = L<span class="hljs-string"><span class="hljs-string">'-'</span></span>, Mul = L<span class="hljs-string"><span class="hljs-string">'*'</span></span>, Div = L<span class="hljs-string"><span class="hljs-string">'/'</span></span>, LParen = L<span class="hljs-string"><span class="hljs-string">'('</span></span>, RParen = L<span class="hljs-string"><span class="hljs-string">')'</span></span>, }; inline std::wstring ToString(const Operator &amp;op) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ static_cast&lt;wchar_t&gt;(op) }; } enum class TokenType { Operator, Number }; inline std::wstring ToString(const TokenType &amp;<span class="hljs-built_in"><span class="hljs-built_in">type</span></span>) { switch(<span class="hljs-built_in"><span class="hljs-built_in">type</span></span>) { case TokenType::Operator: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> L<span class="hljs-string"><span class="hljs-string">"Operator"</span></span>; case TokenType::Number: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> L<span class="hljs-string"><span class="hljs-string">"Number"</span></span>; default: throw std::out_of_range(<span class="hljs-string"><span class="hljs-string">"TokenType"</span></span>); } } class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_type; } operator Operator() const { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(m_type != TokenType::Operator) throw std::logic_error(<span class="hljs-string"><span class="hljs-string">"Should be operator token."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_operator; } operator double() const { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(m_type != TokenType::Number) throw std::logic_error(<span class="hljs-string"><span class="hljs-string">"Should be number token."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_number; } friend inline bool operator==(const Token &amp;left, const Token &amp;right) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(left.m_type == right.m_type) { switch(left.m_type) { case Interpreter::TokenType::Operator: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> left.m_operator == right.m_operator; case Interpreter::TokenType::Number: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> left.m_number == right.m_number; default: throw std::out_of_range(<span class="hljs-string"><span class="hljs-string">"TokenType"</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ToString(static_cast&lt;Operator&gt;(token)); default: throw std::out_of_range(<span class="hljs-string"><span class="hljs-string">"TokenType"</span></span>); } } typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!EndOfExperssion()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(IsNumber()) { ScanNumber(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(IsOperator()) { ScanOperator(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { MoveNext(); } } } const Tokens &amp;Result() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_result; } private: bool EndOfExperssion() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_current == L<span class="hljs-string"><span class="hljs-string">'\0'</span></span>; } bool IsNumber() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> iswdigit(*m_current) != <span class="hljs-number"><span class="hljs-number">0</span></span>; } void ScanNumber() { wchar_t *<span class="hljs-keyword"><span class="hljs-keyword">end</span></span> = nullptr; m_result.push_back(wcstod(m_current, &amp;<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>)); m_current = <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; } bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> std::any_of(all.begin(), all.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(), [this](Operator o) {<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_current == static_cast&lt;wchar_t&gt;(o); }); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tokenizer.Result(); } } // namespace Lexer } // namespace Interpreter</code> <br> <br> <b class="spoiler_title">InterpreterTests.cpp</b> <code class="cpp">#include <span class="hljs-string"><span class="hljs-string">"stdafx.h"</span></span> #include <span class="hljs-string"><span class="hljs-string">"CppUnitTest.h"</span></span> #include <span class="hljs-string"><span class="hljs-string">"Interpreter.h"</span></span> namespace InterpreterTests { using namespace Microsoft::VisualStudio::CppUnitTestFramework; using namespace Interpreter; using namespace std; namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(expect)), distance(actualIter, <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(actual)), L<span class="hljs-string"><span class="hljs-string">"Size differs."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(; expectIter != <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(expect) &amp;&amp; actualIter != <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(actual); ++expectIter, ++actualIter) { auto message = L<span class="hljs-string"><span class="hljs-string">"Mismatch in position "</span></span> + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual&lt;T&gt;(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange TEST_CLASS(LexerTests) { public: TEST_METHOD(Should_return_empty_token_list_when_put_empty_expression) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">""</span></span>); Assert::IsTrue(tokens.empty()); } TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"+"</span></span>); AssertRange::AreEqual({ Operator::Plus }, tokens); } TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"1"</span></span>); AssertRange::AreEqual({ <span class="hljs-number"><span class="hljs-number">1.0</span></span> }, tokens); } TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"12.34"</span></span>); AssertRange::AreEqual({ <span class="hljs-number"><span class="hljs-number">12.34</span></span> }, tokens); } TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"+12.34"</span></span>); AssertRange::AreEqual({ Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">12.34</span></span>) }, tokens); } TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">" 1 + 12.34 "</span></span>); AssertRange::AreEqual({ Token(<span class="hljs-number"><span class="hljs-number">1.0</span></span>), Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">12.34</span></span>) }, tokens); } TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"1+2*3/(4-5)"</span></span>); AssertRange::AreEqual({ Token(<span class="hljs-number"><span class="hljs-number">1</span></span>), Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">2</span></span>), Token(Operator::Mul), Token(<span class="hljs-number"><span class="hljs-number">3</span></span>), Token(Operator::Div), Token(Operator::LParen), Token(<span class="hljs-number"><span class="hljs-number">4</span></span>), Token(Operator::Minus), Token(<span class="hljs-number"><span class="hljs-number">5</span></span>), Token(Operator::RParen) }, tokens); } }; TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } TEST_METHOD(Should_get_type_for_number_token) { Token numToken(<span class="hljs-number"><span class="hljs-number">1.2</span></span>); Assert::AreEqual(TokenType::Number, numToken.Type()); } TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); } TEST_METHOD(Should_get_number_value_from_number_token) { Token token(<span class="hljs-number"><span class="hljs-number">1.23</span></span>); Assert::AreEqual&lt;double&gt;(<span class="hljs-number"><span class="hljs-number">1.23</span></span>, token); } }; }</code> <br> <br> <a href="https://github.com/Unril/InterpreterTDD/releases/tag/%25D0%259A%25D0%25BE%25D0%25BD%25D0%25B5%25D1%2586_%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B2%25D0%25BE%25D0%25B9_%25D1%2587%25D0%25B0%25D1%2581%25D1%2582%25D0%25B8">    GitHub</a> .         ,  .      <span class="hljs-string"><span class="hljs-string">"__"</span></span>. <br> <br>   <a href="http://habrahabr.ru/post/232081/">    </a> .      ,      <a href="http://habrahabr.ru/post/232097/">    </a> .</code> </pre> <code><code>std::vector,      Tokens</code> .            . <br> <br> <code class="cpp">#pragma once; #include &lt;vector&gt; namespace Interpreter { struct Token {}; typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { inline Tokens Tokenize(std::string expr) { throw std::exception(); } } // namespace Lexer } // namespace Interpreter</code> <br>   ,  ,   , .   ,    ,    <a href="http://cleancoder.posterous.com/the-transformation-priority-premise">The Transformation Priority Premise (TPP)</a>   .    , ,    ,     ,        .            .     ,     ,      ,           .  ,  ,   (   )    ,  ,  .     ,  ,         .     ,   TPP          . <br> <br>   : <br> <br> ({} ‚Üí nil)     ,   . (nil ‚Üí constant)    . (constant ‚Üí constant+)      (        ,  ). (constant ‚Üí scalar)    ,  . (statement ‚Üí statements)    (break, continue, return  ). (unconditional ‚Üí if)       . (scalar ‚Üí array)  / . (array ‚Üí container)     . (statement ‚Üí recursion)   . (if ‚Üí while)    . (expression ‚Üí function)   . (variable ‚Üí assignment)   . <br>        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::string expr) { return{}; }</code> <br> ,         .     . <br> <br> <s>         </s> .           .           .               .            .       . <br>  ,  <code>std::string</code>  <code>std::wstring</code> .         ,      Unicode.     . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); }</code> <br>  <code>AssertRange</code> -   ,       <code>AreEqual</code> ,   ,  ,    . <br> <br> <b class="spoiler_title">AssertRange</b> <code class="cpp">namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange</code> <br> <br>         <code>Operator</code>    .          <code>wchar_t</code>   ,         ,      . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', }; typedef Operator Token;</code> <br>    ,   ,        <code>Assert</code> ,    <code>ToString</code> ,    . <br> <br> <b class="spoiler_title">std::wstring ToString(const Token &amp;)</b> <code class="cpp">inline std::wstring ToString(const Token &amp;token) { return{ static_cast&lt;wchar_t&gt;(token) }; }</code> <br> <br>    ,   ,        .  ,   (unconditional ‚Üí if). <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { if(expr.empty()) { return{}; } return{ static_cast&lt;Operator&gt;(expr[0]) }; }</code> <br> <s>         </s> . <s>          .</s>           . ‚Ä¶ <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); }</code> <br>     .   ,     ,   - .    , : <br> <br>        ,      <code>Token</code> .       <code>dynamic_cast</code>    ,   .  ,    ,      .      <code>std::function</code>        .        .  Boost.Any,  - .            . <br>   ,   .      -  .  ,      ,      . <br> <br> ‚Ä¶        .        .        .        . <br>             . <br> <br> <code class="cpp">enum class TokenType { Operator, Number }; class Token { public: Token(Operator) {} TokenType Type() const { return TokenType::Operator; } }; ‚Ä¶ TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } };</code> <br>   <code>ToString</code>   <code>TokenType</code>       ,   ,   .     . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); }</code> <br>   .   (constant ‚Üí scalar)   . <br> <br> <code class="cpp">class Token { public: Token(Operator) :m_type(TokenType::Operator) {} Token(double) :m_type(TokenType::Number) {} TokenType Type() const { return m_type; } private: TokenType m_type; };</code> <br> ‚Ä¶ <s>       </s> . <s>       </s> .        .        . <br>    . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); }</code> <br>            . <br> <br> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} operator Operator() const { return m_operator; } ‚Ä¶ Operator m_operator; };</code> <br>      . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); }</code> <br>          ,  ,       <code>union</code> .         . <br> <br> <b class="spoiler_title">Token</b> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: return "Unknown token."; } }</code> <br> <br>  ,    ,      ,    .       .    . <br> <br> <i>          .</i>               .            .       . <br>        : <br> <br> <code class="cpp"> if(expr[0] &gt;= '0' &amp;&amp; expr[0] &lt;= '9') { return{ (double) expr[0] - '0' }; } return{ static_cast&lt;Operator&gt;(expr[0]) };</code> <br>      ,   . <br> <br> ‚Ä¶ <s>          .</s> <i>              .</i> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); }</code> <br> ,     <code>C</code>   ,  <code>isdigit</code> , ,       <code>atof</code> ,    ,      <code>wchar_t</code> .  (expression ‚Üí function).         . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { const wchar_t *current = expr.c_str(); if(!*current) return{}; if(iswdigit(*current)) return{ _wtof(current) }; return{ static_cast&lt;Operator&gt;(*current) }; }</code> <br>         .      . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>   ,        .  ,     .     .   <code>result</code> ,     . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); if(!*current) return result; if(iswdigit(*current)) { result.push_back(_wtof(current)); } else { result.push_back(static_cast&lt;Operator&gt;(*current)); } return result; }</code> <br>      :   (if ‚Üí while).     ,        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } } return result; }</code> <br>  <code>wcstod</code>    ,   <code>_wtof</code> ,           .           ,              .  ,    . <br> <br> <s>           .</s>       . <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>  (unconditional ‚Üí if)    ,    . <br> <br> <code class="cpp"> while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else if(*current == static_cast&lt;wchar_t&gt;(Operator::Plus)) { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } else { ++current; } }</code> <br>       .          .       <code>Detail</code>      .   <code>Tokenize</code>       . <br> <br> <code class="cpp">inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); }</code> <br> <b class="spoiler_title"> Detail::Tokenizer</b> <code class="cpp">namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { return *m_current == static_cast&lt;wchar_t&gt;(Operator::Plus); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail</code> <br> <br>  ,      .      ,  , .       . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); }</code> <br>      <code>Operator</code> ,    . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', };</code> <br>   .         <code>IsOperator</code>  <code>Tokenizer</code> . <br> <br> <code class="cpp"> bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); }</code> <br>         .        . <br> <br> <b class="spoiler_title">Interpreter.h</b> <code class="cpp">#pragma once; #include &lt;vector&gt; #include &lt;wchar.h&gt; #include &lt;algorithm&gt; namespace Interpreter { enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', }; inline std::wstring ToString(const Operator &amp;op) { return{ static_cast&lt;wchar_t&gt;(op) }; } enum class TokenType { Operator, Number }; inline std::wstring ToString(const TokenType &amp;type) { switch(type) { case TokenType::Operator: return L"Operator"; case TokenType::Number: return L"Number"; default: throw std::out_of_range("TokenType"); } } class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } friend inline bool operator==(const Token &amp;left, const Token &amp;right) { if(left.m_type == right.m_type) { switch(left.m_type) { case Interpreter::TokenType::Operator: return left.m_operator == right.m_operator; case Interpreter::TokenType::Number: return left.m_number == right.m_number; default: throw std::out_of_range("TokenType"); } } return false; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: throw std::out_of_range("TokenType"); } } typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); } } // namespace Lexer } // namespace Interpreter</code> <br> <br> <b class="spoiler_title">InterpreterTests.cpp</b> <code class="cpp">#include "stdafx.h" #include "CppUnitTest.h" #include "Interpreter.h" namespace InterpreterTests { using namespace Microsoft::VisualStudio::CppUnitTestFramework; using namespace Interpreter; using namespace std; namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual&lt;T&gt;(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange TEST_CLASS(LexerTests) { public: TEST_METHOD(Should_return_empty_token_list_when_put_empty_expression) { Tokens tokens = Lexer::Tokenize(L""); Assert::IsTrue(tokens.empty()); } TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); } TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); } TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); } TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); } }; TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); } TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); } TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); } }; }</code> <br> <br> <a href="https://github.com/Unril/InterpreterTDD/releases/tag/%25D0%259A%25D0%25BE%25D0%25BD%25D0%25B5%25D1%2586_%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B2%25D0%25BE%25D0%25B9_%25D1%2587%25D0%25B0%25D1%2581%25D1%2582%25D0%25B8">    GitHub</a> .         ,  .      "__". <br> <br>   <a href="http://habrahabr.ru/post/232081/">    </a> .      ,      <a href="http://habrahabr.ru/post/232097/">    </a> .</code> <pre> <code class="hljs lua"><code>std::vector,      Tokens</code> .            . <br> <br> <code class="cpp">#pragma once; #include &lt;vector&gt; namespace Interpreter { struct Token {}; typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { inline Tokens Tokenize(std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> expr) { throw std::exception(); } } // namespace Lexer } // namespace Interpreter</code> <br>   ,  ,   , .   ,    ,    <a href="http://cleancoder.posterous.com/the-transformation-priority-premise">The Transformation Priority Premise (TPP)</a>   .    , ,    ,     ,        .            .     ,     ,      ,           .  ,  ,   (   )    ,  ,  .     ,  ,         .     ,   TPP          . <br> <br>   : <br> <br> ({} ‚Üí <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)     ,   . (<span class="hljs-literal"><span class="hljs-literal">nil</span></span> ‚Üí constant)    . (constant ‚Üí constant+)      (        ,  ). (constant ‚Üí scalar)    ,  . (statement ‚Üí statements)    (<span class="hljs-keyword"><span class="hljs-keyword">break</span></span>, continue, <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>  ). (unconditional ‚Üí <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>)       . (scalar ‚Üí array)  / . (array ‚Üí container)     . (statement ‚Üí recursion)   . (<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ‚Üí <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>)    . (expression ‚Üí <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">)</span></span>   . (variable ‚Üí assignment)   . <br>        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> expr) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{}; }</code> <br> ,         .     . <br> <br> <s>         </s> .           .           .               .            .       . <br>  ,  <code>std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span></code>  <code>std::wstring</code> .         ,      Unicode.     . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"+"</span></span>); AssertRange::AreEqual({ Operator::Plus }, tokens); }</code> <br>  <code>AssertRange</code> -   ,       <code>AreEqual</code> ,   ,  ,    . <br> <br> <b class="spoiler_title">AssertRange</b> <code class="cpp">namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(expect)), distance(actualIter, <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(actual)), L<span class="hljs-string"><span class="hljs-string">"Size differs."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(; expectIter != <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(expect) &amp;&amp; actualIter != <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(actual); ++expectIter, ++actualIter) { auto message = L<span class="hljs-string"><span class="hljs-string">"Mismatch in position "</span></span> + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange</code> <br> <br>         <code>Operator</code>    .          <code>wchar_t</code>   ,         ,      . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L<span class="hljs-string"><span class="hljs-string">'+'</span></span>, }; typedef Operator Token;</code> <br>    ,   ,        <code>Assert</code> ,    <code>ToString</code> ,    . <br> <br> <b class="spoiler_title">std::wstring ToString(const Token &amp;)</b> <code class="cpp">inline std::wstring ToString(const Token &amp;token) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ static_cast&lt;wchar_t&gt;(token) }; }</code> <br> <br>    ,   ,        .  ,   (unconditional ‚Üí <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>). <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(expr.empty()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{}; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ static_cast&lt;Operator&gt;(expr[<span class="hljs-number"><span class="hljs-number">0</span></span>]) }; }</code> <br> <s>         </s> . <s>          .</s>           . ‚Ä¶ <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"1"</span></span>); AssertRange::AreEqual({ <span class="hljs-number"><span class="hljs-number">1.0</span></span> }, tokens); }</code> <br>     .   ,     ,   - .    , : <br> <br>        ,      <code>Token</code> .       <code>dynamic_cast</code>    ,   .  ,    ,      .      <code>std::<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span></span></code><span class="hljs-function"><span class="hljs-function">        .        .  </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Boost.Any</span></span></span><span class="hljs-function">,  - .            . </span></span><br><span class="hljs-function"><span class="hljs-function">   ,   .      -  .  ,      ,      . </span></span><br><span class="hljs-function"><span class="hljs-function"> </span></span><br><span class="hljs-function"><span class="hljs-function"> ‚Ä¶        .        .        .        . </span></span><br><span class="hljs-function"><span class="hljs-function">             . </span></span><br><span class="hljs-function"><span class="hljs-function"> </span></span><br><span class="hljs-function"><span class="hljs-function"> </span></span><code class="cpp"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">enum</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">class</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TokenType</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Operator</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Number</span></span></span><span class="hljs-function"> }; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">class</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Token</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">public</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Token</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Operator)</span></span></span></span> {} TokenType Type() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TokenType::Operator; } }; ‚Ä¶ TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } };</code> <br>   <code>ToString</code>   <code>TokenType</code>       ,   ,   .     . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_type_for_number_token) { Token numToken(<span class="hljs-number"><span class="hljs-number">1.2</span></span>); Assert::AreEqual(TokenType::Number, numToken.Type()); }</code> <br>   .   (constant ‚Üí scalar)   . <br> <br> <code class="cpp">class Token { public: Token(Operator) :m_type(TokenType::Operator) {} Token(double) :m_type(TokenType::Number) {} TokenType Type() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_type; } private: TokenType m_type; };</code> <br> ‚Ä¶ <s>       </s> . <s>       </s> .        .        . <br>    . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); }</code> <br>            . <br> <br> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} operator Operator() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_operator; } ‚Ä¶ Operator m_operator; };</code> <br>      . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_number_value_from_number_token) { Token token(<span class="hljs-number"><span class="hljs-number">1.23</span></span>); Assert::AreEqual&lt;double&gt;(<span class="hljs-number"><span class="hljs-number">1.23</span></span>, token); }</code> <br>          ,  ,       <code>union</code> .         . <br> <br> <b class="spoiler_title">Token</b> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_type; } operator Operator() const { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(m_type != TokenType::Operator) throw std::logic_error(<span class="hljs-string"><span class="hljs-string">"Should be operator token."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_operator; } operator double() const { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(m_type != TokenType::Number) throw std::logic_error(<span class="hljs-string"><span class="hljs-string">"Should be number token."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_number; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ToString(static_cast&lt;Operator&gt;(token)); default: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Unknown token."</span></span>; } }</code> <br> <br>  ,    ,      ,    .       .    . <br> <br> <i>          .</i>               .            .       . <br>        : <br> <br> <code class="cpp"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(expr[<span class="hljs-number"><span class="hljs-number">0</span></span>] &gt;= <span class="hljs-string"><span class="hljs-string">'0'</span></span> &amp;&amp; expr[<span class="hljs-number"><span class="hljs-number">0</span></span>] &lt;= <span class="hljs-string"><span class="hljs-string">'9'</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ (double) expr[<span class="hljs-number"><span class="hljs-number">0</span></span>] - <span class="hljs-string"><span class="hljs-string">'0'</span></span> }; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ static_cast&lt;Operator&gt;(expr[<span class="hljs-number"><span class="hljs-number">0</span></span>]) };</code> <br>      ,   . <br> <br> ‚Ä¶ <s>          .</s> <i>              .</i> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"12.34"</span></span>); AssertRange::AreEqual({ <span class="hljs-number"><span class="hljs-number">12.34</span></span> }, tokens); }</code> <br> ,     <code>C</code>   ,  <code>isdigit</code> , ,       <code>atof</code> ,    ,      <code>wchar_t</code> .  (expression ‚Üí <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">)</span></span>.         . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { const wchar_t *current = expr.c_str(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!*current) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{}; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(iswdigit(*current)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ _wtof(current) }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ static_cast&lt;Operator&gt;(*current) }; }</code> <br>         .      . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"+12.34"</span></span>); AssertRange::AreEqual({ Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">12.34</span></span>) }, tokens); }</code> <br>   ,        .  ,     .     .   <code>result</code> ,     . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!*current) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(iswdigit(*current)) { result.push_back(_wtof(current)); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { result.push_back(static_cast&lt;Operator&gt;(*current)); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> <br>      :   (<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ‚Üí <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>).     ,        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(*current) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(iswdigit(*current)) { wchar_t *<span class="hljs-keyword"><span class="hljs-keyword">end</span></span> = nullptr; result.push_back(wcstod(current, &amp;<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>)); current = <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> <br>  <code>wcstod</code>    ,   <code>_wtof</code> ,           .           ,              .  ,    . <br> <br> <s>           .</s>       . <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">" 1 + 12.34 "</span></span>); AssertRange::AreEqual({ Token(<span class="hljs-number"><span class="hljs-number">1.0</span></span>), Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">12.34</span></span>) }, tokens); }</code> <br>  (unconditional ‚Üí <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>)    ,    . <br> <br> <code class="cpp"> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(*current) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(iswdigit(*current)) { wchar_t *<span class="hljs-keyword"><span class="hljs-keyword">end</span></span> = nullptr; result.push_back(wcstod(current, &amp;<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>)); current = <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(*current == static_cast&lt;wchar_t&gt;(Operator::Plus)) { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { ++current; } }</code> <br>       .          .       <code>Detail</code>      .   <code>Tokenize</code>       . <br> <br> <code class="cpp">inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tokenizer.Result(); }</code> <br> <b class="spoiler_title"> Detail::Tokenizer</b> <code class="cpp">namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!EndOfExperssion()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(IsNumber()) { ScanNumber(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(IsOperator()) { ScanOperator(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { MoveNext(); } } } const Tokens &amp;Result() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_result; } private: bool EndOfExperssion() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_current == L<span class="hljs-string"><span class="hljs-string">'\0'</span></span>; } bool IsNumber() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> iswdigit(*m_current) != <span class="hljs-number"><span class="hljs-number">0</span></span>; } void ScanNumber() { wchar_t *<span class="hljs-keyword"><span class="hljs-keyword">end</span></span> = nullptr; m_result.push_back(wcstod(m_current, &amp;<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>)); m_current = <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; } bool IsOperator() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_current == static_cast&lt;wchar_t&gt;(Operator::Plus); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail</code> <br> <br>  ,      .      ,  , .       . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"1+2*3/(4-5)"</span></span>); AssertRange::AreEqual({ Token(<span class="hljs-number"><span class="hljs-number">1</span></span>), Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">2</span></span>), Token(Operator::Mul), Token(<span class="hljs-number"><span class="hljs-number">3</span></span>), Token(Operator::Div), Token(Operator::LParen), Token(<span class="hljs-number"><span class="hljs-number">4</span></span>), Token(Operator::Minus), Token(<span class="hljs-number"><span class="hljs-number">5</span></span>), Token(Operator::RParen) }, tokens); }</code> <br>      <code>Operator</code> ,    . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L<span class="hljs-string"><span class="hljs-string">'+'</span></span>, Minus = L<span class="hljs-string"><span class="hljs-string">'-'</span></span>, Mul = L<span class="hljs-string"><span class="hljs-string">'*'</span></span>, Div = L<span class="hljs-string"><span class="hljs-string">'/'</span></span>, LParen = L<span class="hljs-string"><span class="hljs-string">'('</span></span>, RParen = L<span class="hljs-string"><span class="hljs-string">')'</span></span>, };</code> <br>   .         <code>IsOperator</code>  <code>Tokenizer</code> . <br> <br> <code class="cpp"> bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> std::any_of(all.begin(), all.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(), [this](Operator o) {<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_current == static_cast&lt;wchar_t&gt;(o); }); }</code> <br>         .        . <br> <br> <b class="spoiler_title">Interpreter.h</b> <code class="cpp">#pragma once; #include &lt;vector&gt; #include &lt;wchar.h&gt; #include &lt;algorithm&gt; namespace Interpreter { enum class Operator : wchar_t { Plus = L<span class="hljs-string"><span class="hljs-string">'+'</span></span>, Minus = L<span class="hljs-string"><span class="hljs-string">'-'</span></span>, Mul = L<span class="hljs-string"><span class="hljs-string">'*'</span></span>, Div = L<span class="hljs-string"><span class="hljs-string">'/'</span></span>, LParen = L<span class="hljs-string"><span class="hljs-string">'('</span></span>, RParen = L<span class="hljs-string"><span class="hljs-string">')'</span></span>, }; inline std::wstring ToString(const Operator &amp;op) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ static_cast&lt;wchar_t&gt;(op) }; } enum class TokenType { Operator, Number }; inline std::wstring ToString(const TokenType &amp;<span class="hljs-built_in"><span class="hljs-built_in">type</span></span>) { switch(<span class="hljs-built_in"><span class="hljs-built_in">type</span></span>) { case TokenType::Operator: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> L<span class="hljs-string"><span class="hljs-string">"Operator"</span></span>; case TokenType::Number: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> L<span class="hljs-string"><span class="hljs-string">"Number"</span></span>; default: throw std::out_of_range(<span class="hljs-string"><span class="hljs-string">"TokenType"</span></span>); } } class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_type; } operator Operator() const { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(m_type != TokenType::Operator) throw std::logic_error(<span class="hljs-string"><span class="hljs-string">"Should be operator token."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_operator; } operator double() const { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(m_type != TokenType::Number) throw std::logic_error(<span class="hljs-string"><span class="hljs-string">"Should be number token."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_number; } friend inline bool operator==(const Token &amp;left, const Token &amp;right) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(left.m_type == right.m_type) { switch(left.m_type) { case Interpreter::TokenType::Operator: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> left.m_operator == right.m_operator; case Interpreter::TokenType::Number: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> left.m_number == right.m_number; default: throw std::out_of_range(<span class="hljs-string"><span class="hljs-string">"TokenType"</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ToString(static_cast&lt;Operator&gt;(token)); default: throw std::out_of_range(<span class="hljs-string"><span class="hljs-string">"TokenType"</span></span>); } } typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!EndOfExperssion()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(IsNumber()) { ScanNumber(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(IsOperator()) { ScanOperator(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { MoveNext(); } } } const Tokens &amp;Result() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_result; } private: bool EndOfExperssion() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_current == L<span class="hljs-string"><span class="hljs-string">'\0'</span></span>; } bool IsNumber() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> iswdigit(*m_current) != <span class="hljs-number"><span class="hljs-number">0</span></span>; } void ScanNumber() { wchar_t *<span class="hljs-keyword"><span class="hljs-keyword">end</span></span> = nullptr; m_result.push_back(wcstod(m_current, &amp;<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>)); m_current = <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; } bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> std::any_of(all.begin(), all.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(), [this](Operator o) {<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_current == static_cast&lt;wchar_t&gt;(o); }); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tokenizer.Result(); } } // namespace Lexer } // namespace Interpreter</code> <br> <br> <b class="spoiler_title">InterpreterTests.cpp</b> <code class="cpp">#include <span class="hljs-string"><span class="hljs-string">"stdafx.h"</span></span> #include <span class="hljs-string"><span class="hljs-string">"CppUnitTest.h"</span></span> #include <span class="hljs-string"><span class="hljs-string">"Interpreter.h"</span></span> namespace InterpreterTests { using namespace Microsoft::VisualStudio::CppUnitTestFramework; using namespace Interpreter; using namespace std; namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(expect)), distance(actualIter, <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(actual)), L<span class="hljs-string"><span class="hljs-string">"Size differs."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(; expectIter != <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(expect) &amp;&amp; actualIter != <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(actual); ++expectIter, ++actualIter) { auto message = L<span class="hljs-string"><span class="hljs-string">"Mismatch in position "</span></span> + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual&lt;T&gt;(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange TEST_CLASS(LexerTests) { public: TEST_METHOD(Should_return_empty_token_list_when_put_empty_expression) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">""</span></span>); Assert::IsTrue(tokens.empty()); } TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"+"</span></span>); AssertRange::AreEqual({ Operator::Plus }, tokens); } TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"1"</span></span>); AssertRange::AreEqual({ <span class="hljs-number"><span class="hljs-number">1.0</span></span> }, tokens); } TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"12.34"</span></span>); AssertRange::AreEqual({ <span class="hljs-number"><span class="hljs-number">12.34</span></span> }, tokens); } TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"+12.34"</span></span>); AssertRange::AreEqual({ Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">12.34</span></span>) }, tokens); } TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">" 1 + 12.34 "</span></span>); AssertRange::AreEqual({ Token(<span class="hljs-number"><span class="hljs-number">1.0</span></span>), Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">12.34</span></span>) }, tokens); } TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"1+2*3/(4-5)"</span></span>); AssertRange::AreEqual({ Token(<span class="hljs-number"><span class="hljs-number">1</span></span>), Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">2</span></span>), Token(Operator::Mul), Token(<span class="hljs-number"><span class="hljs-number">3</span></span>), Token(Operator::Div), Token(Operator::LParen), Token(<span class="hljs-number"><span class="hljs-number">4</span></span>), Token(Operator::Minus), Token(<span class="hljs-number"><span class="hljs-number">5</span></span>), Token(Operator::RParen) }, tokens); } }; TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } TEST_METHOD(Should_get_type_for_number_token) { Token numToken(<span class="hljs-number"><span class="hljs-number">1.2</span></span>); Assert::AreEqual(TokenType::Number, numToken.Type()); } TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); } TEST_METHOD(Should_get_number_value_from_number_token) { Token token(<span class="hljs-number"><span class="hljs-number">1.23</span></span>); Assert::AreEqual&lt;double&gt;(<span class="hljs-number"><span class="hljs-number">1.23</span></span>, token); } }; }</code> <br> <br> <a href="https://github.com/Unril/InterpreterTDD/releases/tag/%25D0%259A%25D0%25BE%25D0%25BD%25D0%25B5%25D1%2586_%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B2%25D0%25BE%25D0%25B9_%25D1%2587%25D0%25B0%25D1%2581%25D1%2582%25D0%25B8">    GitHub</a> .         ,  .      <span class="hljs-string"><span class="hljs-string">"__"</span></span>. <br> <br>   <a href="http://habrahabr.ru/post/232081/">    </a> .      ,      <a href="http://habrahabr.ru/post/232097/">    </a> .</code> </pre> <code><code>std::vector,      Tokens</code> .            . <br> <br> <code class="cpp">#pragma once; #include &lt;vector&gt; namespace Interpreter { struct Token {}; typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { inline Tokens Tokenize(std::string expr) { throw std::exception(); } } // namespace Lexer } // namespace Interpreter</code> <br>   ,  ,   , .   ,    ,    <a href="http://cleancoder.posterous.com/the-transformation-priority-premise">The Transformation Priority Premise (TPP)</a>   .    , ,    ,     ,        .            .     ,     ,      ,           .  ,  ,   (   )    ,  ,  .     ,  ,         .     ,   TPP          . <br> <br>   : <br> <br> ({} ‚Üí nil)     ,   . (nil ‚Üí constant)    . (constant ‚Üí constant+)      (        ,  ). (constant ‚Üí scalar)    ,  . (statement ‚Üí statements)    (break, continue, return  ). (unconditional ‚Üí if)       . (scalar ‚Üí array)  / . (array ‚Üí container)     . (statement ‚Üí recursion)   . (if ‚Üí while)    . (expression ‚Üí function)   . (variable ‚Üí assignment)   . <br>        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::string expr) { return{}; }</code> <br> ,         .     . <br> <br> <s>         </s> .           .           .               .            .       . <br>  ,  <code>std::string</code>  <code>std::wstring</code> .         ,      Unicode.     . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); }</code> <br>  <code>AssertRange</code> -   ,       <code>AreEqual</code> ,   ,  ,    . <br> <br> <b class="spoiler_title">AssertRange</b> <code class="cpp">namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange</code> <br> <br>         <code>Operator</code>    .          <code>wchar_t</code>   ,         ,      . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', }; typedef Operator Token;</code> <br>    ,   ,        <code>Assert</code> ,    <code>ToString</code> ,    . <br> <br> <b class="spoiler_title">std::wstring ToString(const Token &amp;)</b> <code class="cpp">inline std::wstring ToString(const Token &amp;token) { return{ static_cast&lt;wchar_t&gt;(token) }; }</code> <br> <br>    ,   ,        .  ,   (unconditional ‚Üí if). <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { if(expr.empty()) { return{}; } return{ static_cast&lt;Operator&gt;(expr[0]) }; }</code> <br> <s>         </s> . <s>          .</s>           . ‚Ä¶ <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); }</code> <br>     .   ,     ,   - .    , : <br> <br>        ,      <code>Token</code> .       <code>dynamic_cast</code>    ,   .  ,    ,      .      <code>std::function</code>        .        .  Boost.Any,  - .            . <br>   ,   .      -  .  ,      ,      . <br> <br> ‚Ä¶        .        .        .        . <br>             . <br> <br> <code class="cpp">enum class TokenType { Operator, Number }; class Token { public: Token(Operator) {} TokenType Type() const { return TokenType::Operator; } }; ‚Ä¶ TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } };</code> <br>   <code>ToString</code>   <code>TokenType</code>       ,   ,   .     . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); }</code> <br>   .   (constant ‚Üí scalar)   . <br> <br> <code class="cpp">class Token { public: Token(Operator) :m_type(TokenType::Operator) {} Token(double) :m_type(TokenType::Number) {} TokenType Type() const { return m_type; } private: TokenType m_type; };</code> <br> ‚Ä¶ <s>       </s> . <s>       </s> .        .        . <br>    . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); }</code> <br>            . <br> <br> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} operator Operator() const { return m_operator; } ‚Ä¶ Operator m_operator; };</code> <br>      . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); }</code> <br>          ,  ,       <code>union</code> .         . <br> <br> <b class="spoiler_title">Token</b> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: return "Unknown token."; } }</code> <br> <br>  ,    ,      ,    .       .    . <br> <br> <i>          .</i>               .            .       . <br>        : <br> <br> <code class="cpp"> if(expr[0] &gt;= '0' &amp;&amp; expr[0] &lt;= '9') { return{ (double) expr[0] - '0' }; } return{ static_cast&lt;Operator&gt;(expr[0]) };</code> <br>      ,   . <br> <br> ‚Ä¶ <s>          .</s> <i>              .</i> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); }</code> <br> ,     <code>C</code>   ,  <code>isdigit</code> , ,       <code>atof</code> ,    ,      <code>wchar_t</code> .  (expression ‚Üí function).         . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { const wchar_t *current = expr.c_str(); if(!*current) return{}; if(iswdigit(*current)) return{ _wtof(current) }; return{ static_cast&lt;Operator&gt;(*current) }; }</code> <br>         .      . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>   ,        .  ,     .     .   <code>result</code> ,     . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); if(!*current) return result; if(iswdigit(*current)) { result.push_back(_wtof(current)); } else { result.push_back(static_cast&lt;Operator&gt;(*current)); } return result; }</code> <br>      :   (if ‚Üí while).     ,        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } } return result; }</code> <br>  <code>wcstod</code>    ,   <code>_wtof</code> ,           .           ,              .  ,    . <br> <br> <s>           .</s>       . <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>  (unconditional ‚Üí if)    ,    . <br> <br> <code class="cpp"> while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else if(*current == static_cast&lt;wchar_t&gt;(Operator::Plus)) { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } else { ++current; } }</code> <br>       .          .       <code>Detail</code>      .   <code>Tokenize</code>       . <br> <br> <code class="cpp">inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); }</code> <br> <b class="spoiler_title"> Detail::Tokenizer</b> <code class="cpp">namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { return *m_current == static_cast&lt;wchar_t&gt;(Operator::Plus); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail</code> <br> <br>  ,      .      ,  , .       . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); }</code> <br>      <code>Operator</code> ,    . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', };</code> <br>   .         <code>IsOperator</code>  <code>Tokenizer</code> . <br> <br> <code class="cpp"> bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); }</code> <br>         .        . <br> <br> <b class="spoiler_title">Interpreter.h</b> <code class="cpp">#pragma once; #include &lt;vector&gt; #include &lt;wchar.h&gt; #include &lt;algorithm&gt; namespace Interpreter { enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', }; inline std::wstring ToString(const Operator &amp;op) { return{ static_cast&lt;wchar_t&gt;(op) }; } enum class TokenType { Operator, Number }; inline std::wstring ToString(const TokenType &amp;type) { switch(type) { case TokenType::Operator: return L"Operator"; case TokenType::Number: return L"Number"; default: throw std::out_of_range("TokenType"); } } class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } friend inline bool operator==(const Token &amp;left, const Token &amp;right) { if(left.m_type == right.m_type) { switch(left.m_type) { case Interpreter::TokenType::Operator: return left.m_operator == right.m_operator; case Interpreter::TokenType::Number: return left.m_number == right.m_number; default: throw std::out_of_range("TokenType"); } } return false; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: throw std::out_of_range("TokenType"); } } typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); } } // namespace Lexer } // namespace Interpreter</code> <br> <br> <b class="spoiler_title">InterpreterTests.cpp</b> <code class="cpp">#include "stdafx.h" #include "CppUnitTest.h" #include "Interpreter.h" namespace InterpreterTests { using namespace Microsoft::VisualStudio::CppUnitTestFramework; using namespace Interpreter; using namespace std; namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual&lt;T&gt;(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange TEST_CLASS(LexerTests) { public: TEST_METHOD(Should_return_empty_token_list_when_put_empty_expression) { Tokens tokens = Lexer::Tokenize(L""); Assert::IsTrue(tokens.empty()); } TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); } TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); } TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); } TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); } }; TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); } TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); } TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); } }; }</code> <br> <br> <a href="https://github.com/Unril/InterpreterTDD/releases/tag/%25D0%259A%25D0%25BE%25D0%25BD%25D0%25B5%25D1%2586_%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B2%25D0%25BE%25D0%25B9_%25D1%2587%25D0%25B0%25D1%2581%25D1%2582%25D0%25B8">    GitHub</a> .         ,  .      "__". <br> <br>   <a href="http://habrahabr.ru/post/232081/">    </a> .      ,      <a href="http://habrahabr.ru/post/232097/">    </a> .</code> <pre> <code class="hljs lua"><code>std::vector,      Tokens</code> .            . <br> <br> <code class="cpp">#pragma once; #include &lt;vector&gt; namespace Interpreter { struct Token {}; typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { inline Tokens Tokenize(std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> expr) { throw std::exception(); } } // namespace Lexer } // namespace Interpreter</code> <br>   ,  ,   , .   ,    ,    <a href="http://cleancoder.posterous.com/the-transformation-priority-premise">The Transformation Priority Premise (TPP)</a>   .    , ,    ,     ,        .            .     ,     ,      ,           .  ,  ,   (   )    ,  ,  .     ,  ,         .     ,   TPP          . <br> <br>   : <br> <br> ({} ‚Üí <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)     ,   . (<span class="hljs-literal"><span class="hljs-literal">nil</span></span> ‚Üí constant)    . (constant ‚Üí constant+)      (        ,  ). (constant ‚Üí scalar)    ,  . (statement ‚Üí statements)    (<span class="hljs-keyword"><span class="hljs-keyword">break</span></span>, continue, <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>  ). (unconditional ‚Üí <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>)       . (scalar ‚Üí array)  / . (array ‚Üí container)     . (statement ‚Üí recursion)   . (<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ‚Üí <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>)    . (expression ‚Üí <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">)</span></span>   . (variable ‚Üí assignment)   . <br>        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> expr) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{}; }</code> <br> ,         .     . <br> <br> <s>         </s> .           .           .               .            .       . <br>  ,  <code>std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span></code>  <code>std::wstring</code> .         ,      Unicode.     . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"+"</span></span>); AssertRange::AreEqual({ Operator::Plus }, tokens); }</code> <br>  <code>AssertRange</code> -   ,       <code>AreEqual</code> ,   ,  ,    . <br> <br> <b class="spoiler_title">AssertRange</b> <code class="cpp">namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(expect)), distance(actualIter, <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(actual)), L<span class="hljs-string"><span class="hljs-string">"Size differs."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(; expectIter != <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(expect) &amp;&amp; actualIter != <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(actual); ++expectIter, ++actualIter) { auto message = L<span class="hljs-string"><span class="hljs-string">"Mismatch in position "</span></span> + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange</code> <br> <br>         <code>Operator</code>    .          <code>wchar_t</code>   ,         ,      . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L<span class="hljs-string"><span class="hljs-string">'+'</span></span>, }; typedef Operator Token;</code> <br>    ,   ,        <code>Assert</code> ,    <code>ToString</code> ,    . <br> <br> <b class="spoiler_title">std::wstring ToString(const Token &amp;)</b> <code class="cpp">inline std::wstring ToString(const Token &amp;token) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ static_cast&lt;wchar_t&gt;(token) }; }</code> <br> <br>    ,   ,        .  ,   (unconditional ‚Üí <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>). <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(expr.empty()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{}; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ static_cast&lt;Operator&gt;(expr[<span class="hljs-number"><span class="hljs-number">0</span></span>]) }; }</code> <br> <s>         </s> . <s>          .</s>           . ‚Ä¶ <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"1"</span></span>); AssertRange::AreEqual({ <span class="hljs-number"><span class="hljs-number">1.0</span></span> }, tokens); }</code> <br>     .   ,     ,   - .    , : <br> <br>        ,      <code>Token</code> .       <code>dynamic_cast</code>    ,   .  ,    ,      .      <code>std::<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span></span></code><span class="hljs-function"><span class="hljs-function">        .        .  </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Boost.Any</span></span></span><span class="hljs-function">,  - .            . </span></span><br><span class="hljs-function"><span class="hljs-function">   ,   .      -  .  ,      ,      . </span></span><br><span class="hljs-function"><span class="hljs-function"> </span></span><br><span class="hljs-function"><span class="hljs-function"> ‚Ä¶        .        .        .        . </span></span><br><span class="hljs-function"><span class="hljs-function">             . </span></span><br><span class="hljs-function"><span class="hljs-function"> </span></span><br><span class="hljs-function"><span class="hljs-function"> </span></span><code class="cpp"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">enum</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">class</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TokenType</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Operator</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Number</span></span></span><span class="hljs-function"> }; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">class</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Token</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">public</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Token</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Operator)</span></span></span></span> {} TokenType Type() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TokenType::Operator; } }; ‚Ä¶ TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } };</code> <br>   <code>ToString</code>   <code>TokenType</code>       ,   ,   .     . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_type_for_number_token) { Token numToken(<span class="hljs-number"><span class="hljs-number">1.2</span></span>); Assert::AreEqual(TokenType::Number, numToken.Type()); }</code> <br>   .   (constant ‚Üí scalar)   . <br> <br> <code class="cpp">class Token { public: Token(Operator) :m_type(TokenType::Operator) {} Token(double) :m_type(TokenType::Number) {} TokenType Type() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_type; } private: TokenType m_type; };</code> <br> ‚Ä¶ <s>       </s> . <s>       </s> .        .        . <br>    . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); }</code> <br>            . <br> <br> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} operator Operator() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_operator; } ‚Ä¶ Operator m_operator; };</code> <br>      . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_number_value_from_number_token) { Token token(<span class="hljs-number"><span class="hljs-number">1.23</span></span>); Assert::AreEqual&lt;double&gt;(<span class="hljs-number"><span class="hljs-number">1.23</span></span>, token); }</code> <br>          ,  ,       <code>union</code> .         . <br> <br> <b class="spoiler_title">Token</b> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_type; } operator Operator() const { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(m_type != TokenType::Operator) throw std::logic_error(<span class="hljs-string"><span class="hljs-string">"Should be operator token."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_operator; } operator double() const { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(m_type != TokenType::Number) throw std::logic_error(<span class="hljs-string"><span class="hljs-string">"Should be number token."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_number; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ToString(static_cast&lt;Operator&gt;(token)); default: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Unknown token."</span></span>; } }</code> <br> <br>  ,    ,      ,    .       .    . <br> <br> <i>          .</i>               .            .       . <br>        : <br> <br> <code class="cpp"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(expr[<span class="hljs-number"><span class="hljs-number">0</span></span>] &gt;= <span class="hljs-string"><span class="hljs-string">'0'</span></span> &amp;&amp; expr[<span class="hljs-number"><span class="hljs-number">0</span></span>] &lt;= <span class="hljs-string"><span class="hljs-string">'9'</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ (double) expr[<span class="hljs-number"><span class="hljs-number">0</span></span>] - <span class="hljs-string"><span class="hljs-string">'0'</span></span> }; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ static_cast&lt;Operator&gt;(expr[<span class="hljs-number"><span class="hljs-number">0</span></span>]) };</code> <br>      ,   . <br> <br> ‚Ä¶ <s>          .</s> <i>              .</i> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"12.34"</span></span>); AssertRange::AreEqual({ <span class="hljs-number"><span class="hljs-number">12.34</span></span> }, tokens); }</code> <br> ,     <code>C</code>   ,  <code>isdigit</code> , ,       <code>atof</code> ,    ,      <code>wchar_t</code> .  (expression ‚Üí <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">)</span></span>.         . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { const wchar_t *current = expr.c_str(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!*current) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{}; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(iswdigit(*current)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ _wtof(current) }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ static_cast&lt;Operator&gt;(*current) }; }</code> <br>         .      . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"+12.34"</span></span>); AssertRange::AreEqual({ Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">12.34</span></span>) }, tokens); }</code> <br>   ,        .  ,     .     .   <code>result</code> ,     . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!*current) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(iswdigit(*current)) { result.push_back(_wtof(current)); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { result.push_back(static_cast&lt;Operator&gt;(*current)); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> <br>      :   (<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ‚Üí <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>).     ,        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(*current) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(iswdigit(*current)) { wchar_t *<span class="hljs-keyword"><span class="hljs-keyword">end</span></span> = nullptr; result.push_back(wcstod(current, &amp;<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>)); current = <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> <br>  <code>wcstod</code>    ,   <code>_wtof</code> ,           .           ,              .  ,    . <br> <br> <s>           .</s>       . <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">" 1 + 12.34 "</span></span>); AssertRange::AreEqual({ Token(<span class="hljs-number"><span class="hljs-number">1.0</span></span>), Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">12.34</span></span>) }, tokens); }</code> <br>  (unconditional ‚Üí <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>)    ,    . <br> <br> <code class="cpp"> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(*current) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(iswdigit(*current)) { wchar_t *<span class="hljs-keyword"><span class="hljs-keyword">end</span></span> = nullptr; result.push_back(wcstod(current, &amp;<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>)); current = <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(*current == static_cast&lt;wchar_t&gt;(Operator::Plus)) { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { ++current; } }</code> <br>       .          .       <code>Detail</code>      .   <code>Tokenize</code>       . <br> <br> <code class="cpp">inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tokenizer.Result(); }</code> <br> <b class="spoiler_title"> Detail::Tokenizer</b> <code class="cpp">namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!EndOfExperssion()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(IsNumber()) { ScanNumber(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(IsOperator()) { ScanOperator(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { MoveNext(); } } } const Tokens &amp;Result() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_result; } private: bool EndOfExperssion() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_current == L<span class="hljs-string"><span class="hljs-string">'\0'</span></span>; } bool IsNumber() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> iswdigit(*m_current) != <span class="hljs-number"><span class="hljs-number">0</span></span>; } void ScanNumber() { wchar_t *<span class="hljs-keyword"><span class="hljs-keyword">end</span></span> = nullptr; m_result.push_back(wcstod(m_current, &amp;<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>)); m_current = <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; } bool IsOperator() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_current == static_cast&lt;wchar_t&gt;(Operator::Plus); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail</code> <br> <br>  ,      .      ,  , .       . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"1+2*3/(4-5)"</span></span>); AssertRange::AreEqual({ Token(<span class="hljs-number"><span class="hljs-number">1</span></span>), Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">2</span></span>), Token(Operator::Mul), Token(<span class="hljs-number"><span class="hljs-number">3</span></span>), Token(Operator::Div), Token(Operator::LParen), Token(<span class="hljs-number"><span class="hljs-number">4</span></span>), Token(Operator::Minus), Token(<span class="hljs-number"><span class="hljs-number">5</span></span>), Token(Operator::RParen) }, tokens); }</code> <br>      <code>Operator</code> ,    . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L<span class="hljs-string"><span class="hljs-string">'+'</span></span>, Minus = L<span class="hljs-string"><span class="hljs-string">'-'</span></span>, Mul = L<span class="hljs-string"><span class="hljs-string">'*'</span></span>, Div = L<span class="hljs-string"><span class="hljs-string">'/'</span></span>, LParen = L<span class="hljs-string"><span class="hljs-string">'('</span></span>, RParen = L<span class="hljs-string"><span class="hljs-string">')'</span></span>, };</code> <br>   .         <code>IsOperator</code>  <code>Tokenizer</code> . <br> <br> <code class="cpp"> bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> std::any_of(all.begin(), all.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(), [this](Operator o) {<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_current == static_cast&lt;wchar_t&gt;(o); }); }</code> <br>         .        . <br> <br> <b class="spoiler_title">Interpreter.h</b> <code class="cpp">#pragma once; #include &lt;vector&gt; #include &lt;wchar.h&gt; #include &lt;algorithm&gt; namespace Interpreter { enum class Operator : wchar_t { Plus = L<span class="hljs-string"><span class="hljs-string">'+'</span></span>, Minus = L<span class="hljs-string"><span class="hljs-string">'-'</span></span>, Mul = L<span class="hljs-string"><span class="hljs-string">'*'</span></span>, Div = L<span class="hljs-string"><span class="hljs-string">'/'</span></span>, LParen = L<span class="hljs-string"><span class="hljs-string">'('</span></span>, RParen = L<span class="hljs-string"><span class="hljs-string">')'</span></span>, }; inline std::wstring ToString(const Operator &amp;op) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ static_cast&lt;wchar_t&gt;(op) }; } enum class TokenType { Operator, Number }; inline std::wstring ToString(const TokenType &amp;<span class="hljs-built_in"><span class="hljs-built_in">type</span></span>) { switch(<span class="hljs-built_in"><span class="hljs-built_in">type</span></span>) { case TokenType::Operator: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> L<span class="hljs-string"><span class="hljs-string">"Operator"</span></span>; case TokenType::Number: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> L<span class="hljs-string"><span class="hljs-string">"Number"</span></span>; default: throw std::out_of_range(<span class="hljs-string"><span class="hljs-string">"TokenType"</span></span>); } } class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_type; } operator Operator() const { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(m_type != TokenType::Operator) throw std::logic_error(<span class="hljs-string"><span class="hljs-string">"Should be operator token."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_operator; } operator double() const { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(m_type != TokenType::Number) throw std::logic_error(<span class="hljs-string"><span class="hljs-string">"Should be number token."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_number; } friend inline bool operator==(const Token &amp;left, const Token &amp;right) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(left.m_type == right.m_type) { switch(left.m_type) { case Interpreter::TokenType::Operator: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> left.m_operator == right.m_operator; case Interpreter::TokenType::Number: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> left.m_number == right.m_number; default: throw std::out_of_range(<span class="hljs-string"><span class="hljs-string">"TokenType"</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ToString(static_cast&lt;Operator&gt;(token)); default: throw std::out_of_range(<span class="hljs-string"><span class="hljs-string">"TokenType"</span></span>); } } typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!EndOfExperssion()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(IsNumber()) { ScanNumber(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(IsOperator()) { ScanOperator(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { MoveNext(); } } } const Tokens &amp;Result() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_result; } private: bool EndOfExperssion() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_current == L<span class="hljs-string"><span class="hljs-string">'\0'</span></span>; } bool IsNumber() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> iswdigit(*m_current) != <span class="hljs-number"><span class="hljs-number">0</span></span>; } void ScanNumber() { wchar_t *<span class="hljs-keyword"><span class="hljs-keyword">end</span></span> = nullptr; m_result.push_back(wcstod(m_current, &amp;<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>)); m_current = <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; } bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> std::any_of(all.begin(), all.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(), [this](Operator o) {<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_current == static_cast&lt;wchar_t&gt;(o); }); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tokenizer.Result(); } } // namespace Lexer } // namespace Interpreter</code> <br> <br> <b class="spoiler_title">InterpreterTests.cpp</b> <code class="cpp">#include <span class="hljs-string"><span class="hljs-string">"stdafx.h"</span></span> #include <span class="hljs-string"><span class="hljs-string">"CppUnitTest.h"</span></span> #include <span class="hljs-string"><span class="hljs-string">"Interpreter.h"</span></span> namespace InterpreterTests { using namespace Microsoft::VisualStudio::CppUnitTestFramework; using namespace Interpreter; using namespace std; namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(expect)), distance(actualIter, <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(actual)), L<span class="hljs-string"><span class="hljs-string">"Size differs."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(; expectIter != <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(expect) &amp;&amp; actualIter != <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(actual); ++expectIter, ++actualIter) { auto message = L<span class="hljs-string"><span class="hljs-string">"Mismatch in position "</span></span> + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual&lt;T&gt;(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange TEST_CLASS(LexerTests) { public: TEST_METHOD(Should_return_empty_token_list_when_put_empty_expression) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">""</span></span>); Assert::IsTrue(tokens.empty()); } TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"+"</span></span>); AssertRange::AreEqual({ Operator::Plus }, tokens); } TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"1"</span></span>); AssertRange::AreEqual({ <span class="hljs-number"><span class="hljs-number">1.0</span></span> }, tokens); } TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"12.34"</span></span>); AssertRange::AreEqual({ <span class="hljs-number"><span class="hljs-number">12.34</span></span> }, tokens); } TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"+12.34"</span></span>); AssertRange::AreEqual({ Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">12.34</span></span>) }, tokens); } TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">" 1 + 12.34 "</span></span>); AssertRange::AreEqual({ Token(<span class="hljs-number"><span class="hljs-number">1.0</span></span>), Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">12.34</span></span>) }, tokens); } TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"1+2*3/(4-5)"</span></span>); AssertRange::AreEqual({ Token(<span class="hljs-number"><span class="hljs-number">1</span></span>), Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">2</span></span>), Token(Operator::Mul), Token(<span class="hljs-number"><span class="hljs-number">3</span></span>), Token(Operator::Div), Token(Operator::LParen), Token(<span class="hljs-number"><span class="hljs-number">4</span></span>), Token(Operator::Minus), Token(<span class="hljs-number"><span class="hljs-number">5</span></span>), Token(Operator::RParen) }, tokens); } }; TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } TEST_METHOD(Should_get_type_for_number_token) { Token numToken(<span class="hljs-number"><span class="hljs-number">1.2</span></span>); Assert::AreEqual(TokenType::Number, numToken.Type()); } TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); } TEST_METHOD(Should_get_number_value_from_number_token) { Token token(<span class="hljs-number"><span class="hljs-number">1.23</span></span>); Assert::AreEqual&lt;double&gt;(<span class="hljs-number"><span class="hljs-number">1.23</span></span>, token); } }; }</code> <br> <br> <a href="https://github.com/Unril/InterpreterTDD/releases/tag/%25D0%259A%25D0%25BE%25D0%25BD%25D0%25B5%25D1%2586_%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B2%25D0%25BE%25D0%25B9_%25D1%2587%25D0%25B0%25D1%2581%25D1%2582%25D0%25B8">    GitHub</a> .         ,  .      <span class="hljs-string"><span class="hljs-string">"__"</span></span>. <br> <br>   <a href="http://habrahabr.ru/post/232081/">    </a> .      ,      <a href="http://habrahabr.ru/post/232097/">    </a> .</code> </pre> <code><code>std::vector,      Tokens</code> .            . <br> <br> <code class="cpp">#pragma once; #include &lt;vector&gt; namespace Interpreter { struct Token {}; typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { inline Tokens Tokenize(std::string expr) { throw std::exception(); } } // namespace Lexer } // namespace Interpreter</code> <br>   ,  ,   , .   ,    ,    <a href="http://cleancoder.posterous.com/the-transformation-priority-premise">The Transformation Priority Premise (TPP)</a>   .    , ,    ,     ,        .            .     ,     ,      ,           .  ,  ,   (   )    ,  ,  .     ,  ,         .     ,   TPP          . <br> <br>   : <br> <br> ({} ‚Üí nil)     ,   . (nil ‚Üí constant)    . (constant ‚Üí constant+)      (        ,  ). (constant ‚Üí scalar)    ,  . (statement ‚Üí statements)    (break, continue, return  ). (unconditional ‚Üí if)       . (scalar ‚Üí array)  / . (array ‚Üí container)     . (statement ‚Üí recursion)   . (if ‚Üí while)    . (expression ‚Üí function)   . (variable ‚Üí assignment)   . <br>        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::string expr) { return{}; }</code> <br> ,         .     . <br> <br> <s>         </s> .           .           .               .            .       . <br>  ,  <code>std::string</code>  <code>std::wstring</code> .         ,      Unicode.     . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); }</code> <br>  <code>AssertRange</code> -   ,       <code>AreEqual</code> ,   ,  ,    . <br> <br> <b class="spoiler_title">AssertRange</b> <code class="cpp">namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange</code> <br> <br>         <code>Operator</code>    .          <code>wchar_t</code>   ,         ,      . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', }; typedef Operator Token;</code> <br>    ,   ,        <code>Assert</code> ,    <code>ToString</code> ,    . <br> <br> <b class="spoiler_title">std::wstring ToString(const Token &amp;)</b> <code class="cpp">inline std::wstring ToString(const Token &amp;token) { return{ static_cast&lt;wchar_t&gt;(token) }; }</code> <br> <br>    ,   ,        .  ,   (unconditional ‚Üí if). <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { if(expr.empty()) { return{}; } return{ static_cast&lt;Operator&gt;(expr[0]) }; }</code> <br> <s>         </s> . <s>          .</s>           . ‚Ä¶ <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); }</code> <br>     .   ,     ,   - .    , : <br> <br>        ,      <code>Token</code> .       <code>dynamic_cast</code>    ,   .  ,    ,      .      <code>std::function</code>        .        .  Boost.Any,  - .            . <br>   ,   .      -  .  ,      ,      . <br> <br> ‚Ä¶        .        .        .        . <br>             . <br> <br> <code class="cpp">enum class TokenType { Operator, Number }; class Token { public: Token(Operator) {} TokenType Type() const { return TokenType::Operator; } }; ‚Ä¶ TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } };</code> <br>   <code>ToString</code>   <code>TokenType</code>       ,   ,   .     . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); }</code> <br>   .   (constant ‚Üí scalar)   . <br> <br> <code class="cpp">class Token { public: Token(Operator) :m_type(TokenType::Operator) {} Token(double) :m_type(TokenType::Number) {} TokenType Type() const { return m_type; } private: TokenType m_type; };</code> <br> ‚Ä¶ <s>       </s> . <s>       </s> .        .        . <br>    . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); }</code> <br>            . <br> <br> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} operator Operator() const { return m_operator; } ‚Ä¶ Operator m_operator; };</code> <br>      . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); }</code> <br>          ,  ,       <code>union</code> .         . <br> <br> <b class="spoiler_title">Token</b> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: return "Unknown token."; } }</code> <br> <br>  ,    ,      ,    .       .    . <br> <br> <i>          .</i>               .            .       . <br>        : <br> <br> <code class="cpp"> if(expr[0] &gt;= '0' &amp;&amp; expr[0] &lt;= '9') { return{ (double) expr[0] - '0' }; } return{ static_cast&lt;Operator&gt;(expr[0]) };</code> <br>      ,   . <br> <br> ‚Ä¶ <s>          .</s> <i>              .</i> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); }</code> <br> ,     <code>C</code>   ,  <code>isdigit</code> , ,       <code>atof</code> ,    ,      <code>wchar_t</code> .  (expression ‚Üí function).         . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { const wchar_t *current = expr.c_str(); if(!*current) return{}; if(iswdigit(*current)) return{ _wtof(current) }; return{ static_cast&lt;Operator&gt;(*current) }; }</code> <br>         .      . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>   ,        .  ,     .     .   <code>result</code> ,     . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); if(!*current) return result; if(iswdigit(*current)) { result.push_back(_wtof(current)); } else { result.push_back(static_cast&lt;Operator&gt;(*current)); } return result; }</code> <br>      :   (if ‚Üí while).     ,        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } } return result; }</code> <br>  <code>wcstod</code>    ,   <code>_wtof</code> ,           .           ,              .  ,    . <br> <br> <s>           .</s>       . <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>  (unconditional ‚Üí if)    ,    . <br> <br> <code class="cpp"> while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else if(*current == static_cast&lt;wchar_t&gt;(Operator::Plus)) { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } else { ++current; } }</code> <br>       .          .       <code>Detail</code>      .   <code>Tokenize</code>       . <br> <br> <code class="cpp">inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); }</code> <br> <b class="spoiler_title"> Detail::Tokenizer</b> <code class="cpp">namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { return *m_current == static_cast&lt;wchar_t&gt;(Operator::Plus); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail</code> <br> <br>  ,      .      ,  , .       . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); }</code> <br>      <code>Operator</code> ,    . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', };</code> <br>   .         <code>IsOperator</code>  <code>Tokenizer</code> . <br> <br> <code class="cpp"> bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); }</code> <br>         .        . <br> <br> <b class="spoiler_title">Interpreter.h</b> <code class="cpp">#pragma once; #include &lt;vector&gt; #include &lt;wchar.h&gt; #include &lt;algorithm&gt; namespace Interpreter { enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', }; inline std::wstring ToString(const Operator &amp;op) { return{ static_cast&lt;wchar_t&gt;(op) }; } enum class TokenType { Operator, Number }; inline std::wstring ToString(const TokenType &amp;type) { switch(type) { case TokenType::Operator: return L"Operator"; case TokenType::Number: return L"Number"; default: throw std::out_of_range("TokenType"); } } class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } friend inline bool operator==(const Token &amp;left, const Token &amp;right) { if(left.m_type == right.m_type) { switch(left.m_type) { case Interpreter::TokenType::Operator: return left.m_operator == right.m_operator; case Interpreter::TokenType::Number: return left.m_number == right.m_number; default: throw std::out_of_range("TokenType"); } } return false; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: throw std::out_of_range("TokenType"); } } typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); } } // namespace Lexer } // namespace Interpreter</code> <br> <br> <b class="spoiler_title">InterpreterTests.cpp</b> <code class="cpp">#include "stdafx.h" #include "CppUnitTest.h" #include "Interpreter.h" namespace InterpreterTests { using namespace Microsoft::VisualStudio::CppUnitTestFramework; using namespace Interpreter; using namespace std; namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual&lt;T&gt;(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange TEST_CLASS(LexerTests) { public: TEST_METHOD(Should_return_empty_token_list_when_put_empty_expression) { Tokens tokens = Lexer::Tokenize(L""); Assert::IsTrue(tokens.empty()); } TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); } TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); } TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); } TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); } }; TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); } TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); } TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); } }; }</code> <br> <br> <a href="https://github.com/Unril/InterpreterTDD/releases/tag/%25D0%259A%25D0%25BE%25D0%25BD%25D0%25B5%25D1%2586_%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B2%25D0%25BE%25D0%25B9_%25D1%2587%25D0%25B0%25D1%2581%25D1%2582%25D0%25B8">    GitHub</a> .         ,  .      "__". <br> <br>   <a href="http://habrahabr.ru/post/232081/">    </a> .      ,      <a href="http://habrahabr.ru/post/232097/">    </a> .</code> <pre> <code class="hljs lua"><code>std::vector,      Tokens</code> .            . <br> <br> <code class="cpp">#pragma once; #include &lt;vector&gt; namespace Interpreter { struct Token {}; typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { inline Tokens Tokenize(std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> expr) { throw std::exception(); } } // namespace Lexer } // namespace Interpreter</code> <br>   ,  ,   , .   ,    ,    <a href="http://cleancoder.posterous.com/the-transformation-priority-premise">The Transformation Priority Premise (TPP)</a>   .    , ,    ,     ,        .            .     ,     ,      ,           .  ,  ,   (   )    ,  ,  .     ,  ,         .     ,   TPP          . <br> <br>   : <br> <br> ({} ‚Üí <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)     ,   . (<span class="hljs-literal"><span class="hljs-literal">nil</span></span> ‚Üí constant)    . (constant ‚Üí constant+)      (        ,  ). (constant ‚Üí scalar)    ,  . (statement ‚Üí statements)    (<span class="hljs-keyword"><span class="hljs-keyword">break</span></span>, continue, <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>  ). (unconditional ‚Üí <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>)       . (scalar ‚Üí array)  / . (array ‚Üí container)     . (statement ‚Üí recursion)   . (<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ‚Üí <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>)    . (expression ‚Üí <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">)</span></span>   . (variable ‚Üí assignment)   . <br>        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> expr) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{}; }</code> <br> ,         .     . <br> <br> <s>         </s> .           .           .               .            .       . <br>  ,  <code>std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span></code>  <code>std::wstring</code> .         ,      Unicode.     . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"+"</span></span>); AssertRange::AreEqual({ Operator::Plus }, tokens); }</code> <br>  <code>AssertRange</code> -   ,       <code>AreEqual</code> ,   ,  ,    . <br> <br> <b class="spoiler_title">AssertRange</b> <code class="cpp">namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(expect)), distance(actualIter, <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(actual)), L<span class="hljs-string"><span class="hljs-string">"Size differs."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(; expectIter != <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(expect) &amp;&amp; actualIter != <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(actual); ++expectIter, ++actualIter) { auto message = L<span class="hljs-string"><span class="hljs-string">"Mismatch in position "</span></span> + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange</code> <br> <br>         <code>Operator</code>    .          <code>wchar_t</code>   ,         ,      . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L<span class="hljs-string"><span class="hljs-string">'+'</span></span>, }; typedef Operator Token;</code> <br>    ,   ,        <code>Assert</code> ,    <code>ToString</code> ,    . <br> <br> <b class="spoiler_title">std::wstring ToString(const Token &amp;)</b> <code class="cpp">inline std::wstring ToString(const Token &amp;token) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ static_cast&lt;wchar_t&gt;(token) }; }</code> <br> <br>    ,   ,        .  ,   (unconditional ‚Üí <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>). <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(expr.empty()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{}; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ static_cast&lt;Operator&gt;(expr[<span class="hljs-number"><span class="hljs-number">0</span></span>]) }; }</code> <br> <s>         </s> . <s>          .</s>           . ‚Ä¶ <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"1"</span></span>); AssertRange::AreEqual({ <span class="hljs-number"><span class="hljs-number">1.0</span></span> }, tokens); }</code> <br>     .   ,     ,   - .    , : <br> <br>        ,      <code>Token</code> .       <code>dynamic_cast</code>    ,   .  ,    ,      .      <code>std::<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span></span></code><span class="hljs-function"><span class="hljs-function">        .        .  </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Boost.Any</span></span></span><span class="hljs-function">,  - .            . </span></span><br><span class="hljs-function"><span class="hljs-function">   ,   .      -  .  ,      ,      . </span></span><br><span class="hljs-function"><span class="hljs-function"> </span></span><br><span class="hljs-function"><span class="hljs-function"> ‚Ä¶        .        .        .        . </span></span><br><span class="hljs-function"><span class="hljs-function">             . </span></span><br><span class="hljs-function"><span class="hljs-function"> </span></span><br><span class="hljs-function"><span class="hljs-function"> </span></span><code class="cpp"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">enum</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">class</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TokenType</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Operator</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Number</span></span></span><span class="hljs-function"> }; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">class</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Token</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">public</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Token</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Operator)</span></span></span></span> {} TokenType Type() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TokenType::Operator; } }; ‚Ä¶ TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } };</code> <br>   <code>ToString</code>   <code>TokenType</code>       ,   ,   .     . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_type_for_number_token) { Token numToken(<span class="hljs-number"><span class="hljs-number">1.2</span></span>); Assert::AreEqual(TokenType::Number, numToken.Type()); }</code> <br>   .   (constant ‚Üí scalar)   . <br> <br> <code class="cpp">class Token { public: Token(Operator) :m_type(TokenType::Operator) {} Token(double) :m_type(TokenType::Number) {} TokenType Type() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_type; } private: TokenType m_type; };</code> <br> ‚Ä¶ <s>       </s> . <s>       </s> .        .        . <br>    . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); }</code> <br>            . <br> <br> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} operator Operator() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_operator; } ‚Ä¶ Operator m_operator; };</code> <br>      . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_number_value_from_number_token) { Token token(<span class="hljs-number"><span class="hljs-number">1.23</span></span>); Assert::AreEqual&lt;double&gt;(<span class="hljs-number"><span class="hljs-number">1.23</span></span>, token); }</code> <br>          ,  ,       <code>union</code> .         . <br> <br> <b class="spoiler_title">Token</b> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_type; } operator Operator() const { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(m_type != TokenType::Operator) throw std::logic_error(<span class="hljs-string"><span class="hljs-string">"Should be operator token."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_operator; } operator double() const { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(m_type != TokenType::Number) throw std::logic_error(<span class="hljs-string"><span class="hljs-string">"Should be number token."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_number; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ToString(static_cast&lt;Operator&gt;(token)); default: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Unknown token."</span></span>; } }</code> <br> <br>  ,    ,      ,    .       .    . <br> <br> <i>          .</i>               .            .       . <br>        : <br> <br> <code class="cpp"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(expr[<span class="hljs-number"><span class="hljs-number">0</span></span>] &gt;= <span class="hljs-string"><span class="hljs-string">'0'</span></span> &amp;&amp; expr[<span class="hljs-number"><span class="hljs-number">0</span></span>] &lt;= <span class="hljs-string"><span class="hljs-string">'9'</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ (double) expr[<span class="hljs-number"><span class="hljs-number">0</span></span>] - <span class="hljs-string"><span class="hljs-string">'0'</span></span> }; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ static_cast&lt;Operator&gt;(expr[<span class="hljs-number"><span class="hljs-number">0</span></span>]) };</code> <br>      ,   . <br> <br> ‚Ä¶ <s>          .</s> <i>              .</i> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"12.34"</span></span>); AssertRange::AreEqual({ <span class="hljs-number"><span class="hljs-number">12.34</span></span> }, tokens); }</code> <br> ,     <code>C</code>   ,  <code>isdigit</code> , ,       <code>atof</code> ,    ,      <code>wchar_t</code> .  (expression ‚Üí <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">)</span></span>.         . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { const wchar_t *current = expr.c_str(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!*current) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{}; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(iswdigit(*current)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ _wtof(current) }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ static_cast&lt;Operator&gt;(*current) }; }</code> <br>         .      . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"+12.34"</span></span>); AssertRange::AreEqual({ Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">12.34</span></span>) }, tokens); }</code> <br>   ,        .  ,     .     .   <code>result</code> ,     . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!*current) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(iswdigit(*current)) { result.push_back(_wtof(current)); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { result.push_back(static_cast&lt;Operator&gt;(*current)); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> <br>      :   (<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ‚Üí <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>).     ,        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(*current) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(iswdigit(*current)) { wchar_t *<span class="hljs-keyword"><span class="hljs-keyword">end</span></span> = nullptr; result.push_back(wcstod(current, &amp;<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>)); current = <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> <br>  <code>wcstod</code>    ,   <code>_wtof</code> ,           .           ,              .  ,    . <br> <br> <s>           .</s>       . <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">" 1 + 12.34 "</span></span>); AssertRange::AreEqual({ Token(<span class="hljs-number"><span class="hljs-number">1.0</span></span>), Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">12.34</span></span>) }, tokens); }</code> <br>  (unconditional ‚Üí <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>)    ,    . <br> <br> <code class="cpp"> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(*current) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(iswdigit(*current)) { wchar_t *<span class="hljs-keyword"><span class="hljs-keyword">end</span></span> = nullptr; result.push_back(wcstod(current, &amp;<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>)); current = <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(*current == static_cast&lt;wchar_t&gt;(Operator::Plus)) { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { ++current; } }</code> <br>       .          .       <code>Detail</code>      .   <code>Tokenize</code>       . <br> <br> <code class="cpp">inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tokenizer.Result(); }</code> <br> <b class="spoiler_title"> Detail::Tokenizer</b> <code class="cpp">namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!EndOfExperssion()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(IsNumber()) { ScanNumber(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(IsOperator()) { ScanOperator(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { MoveNext(); } } } const Tokens &amp;Result() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_result; } private: bool EndOfExperssion() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_current == L<span class="hljs-string"><span class="hljs-string">'\0'</span></span>; } bool IsNumber() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> iswdigit(*m_current) != <span class="hljs-number"><span class="hljs-number">0</span></span>; } void ScanNumber() { wchar_t *<span class="hljs-keyword"><span class="hljs-keyword">end</span></span> = nullptr; m_result.push_back(wcstod(m_current, &amp;<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>)); m_current = <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; } bool IsOperator() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_current == static_cast&lt;wchar_t&gt;(Operator::Plus); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail</code> <br> <br>  ,      .      ,  , .       . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"1+2*3/(4-5)"</span></span>); AssertRange::AreEqual({ Token(<span class="hljs-number"><span class="hljs-number">1</span></span>), Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">2</span></span>), Token(Operator::Mul), Token(<span class="hljs-number"><span class="hljs-number">3</span></span>), Token(Operator::Div), Token(Operator::LParen), Token(<span class="hljs-number"><span class="hljs-number">4</span></span>), Token(Operator::Minus), Token(<span class="hljs-number"><span class="hljs-number">5</span></span>), Token(Operator::RParen) }, tokens); }</code> <br>      <code>Operator</code> ,    . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L<span class="hljs-string"><span class="hljs-string">'+'</span></span>, Minus = L<span class="hljs-string"><span class="hljs-string">'-'</span></span>, Mul = L<span class="hljs-string"><span class="hljs-string">'*'</span></span>, Div = L<span class="hljs-string"><span class="hljs-string">'/'</span></span>, LParen = L<span class="hljs-string"><span class="hljs-string">'('</span></span>, RParen = L<span class="hljs-string"><span class="hljs-string">')'</span></span>, };</code> <br>   .         <code>IsOperator</code>  <code>Tokenizer</code> . <br> <br> <code class="cpp"> bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> std::any_of(all.begin(), all.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(), [this](Operator o) {<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_current == static_cast&lt;wchar_t&gt;(o); }); }</code> <br>         .        . <br> <br> <b class="spoiler_title">Interpreter.h</b> <code class="cpp">#pragma once; #include &lt;vector&gt; #include &lt;wchar.h&gt; #include &lt;algorithm&gt; namespace Interpreter { enum class Operator : wchar_t { Plus = L<span class="hljs-string"><span class="hljs-string">'+'</span></span>, Minus = L<span class="hljs-string"><span class="hljs-string">'-'</span></span>, Mul = L<span class="hljs-string"><span class="hljs-string">'*'</span></span>, Div = L<span class="hljs-string"><span class="hljs-string">'/'</span></span>, LParen = L<span class="hljs-string"><span class="hljs-string">'('</span></span>, RParen = L<span class="hljs-string"><span class="hljs-string">')'</span></span>, }; inline std::wstring ToString(const Operator &amp;op) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ static_cast&lt;wchar_t&gt;(op) }; } enum class TokenType { Operator, Number }; inline std::wstring ToString(const TokenType &amp;<span class="hljs-built_in"><span class="hljs-built_in">type</span></span>) { switch(<span class="hljs-built_in"><span class="hljs-built_in">type</span></span>) { case TokenType::Operator: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> L<span class="hljs-string"><span class="hljs-string">"Operator"</span></span>; case TokenType::Number: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> L<span class="hljs-string"><span class="hljs-string">"Number"</span></span>; default: throw std::out_of_range(<span class="hljs-string"><span class="hljs-string">"TokenType"</span></span>); } } class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_type; } operator Operator() const { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(m_type != TokenType::Operator) throw std::logic_error(<span class="hljs-string"><span class="hljs-string">"Should be operator token."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_operator; } operator double() const { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(m_type != TokenType::Number) throw std::logic_error(<span class="hljs-string"><span class="hljs-string">"Should be number token."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_number; } friend inline bool operator==(const Token &amp;left, const Token &amp;right) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(left.m_type == right.m_type) { switch(left.m_type) { case Interpreter::TokenType::Operator: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> left.m_operator == right.m_operator; case Interpreter::TokenType::Number: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> left.m_number == right.m_number; default: throw std::out_of_range(<span class="hljs-string"><span class="hljs-string">"TokenType"</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ToString(static_cast&lt;Operator&gt;(token)); default: throw std::out_of_range(<span class="hljs-string"><span class="hljs-string">"TokenType"</span></span>); } } typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!EndOfExperssion()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(IsNumber()) { ScanNumber(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(IsOperator()) { ScanOperator(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { MoveNext(); } } } const Tokens &amp;Result() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_result; } private: bool EndOfExperssion() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_current == L<span class="hljs-string"><span class="hljs-string">'\0'</span></span>; } bool IsNumber() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> iswdigit(*m_current) != <span class="hljs-number"><span class="hljs-number">0</span></span>; } void ScanNumber() { wchar_t *<span class="hljs-keyword"><span class="hljs-keyword">end</span></span> = nullptr; m_result.push_back(wcstod(m_current, &amp;<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>)); m_current = <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; } bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> std::any_of(all.begin(), all.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(), [this](Operator o) {<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_current == static_cast&lt;wchar_t&gt;(o); }); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tokenizer.Result(); } } // namespace Lexer } // namespace Interpreter</code> <br> <br> <b class="spoiler_title">InterpreterTests.cpp</b> <code class="cpp">#include <span class="hljs-string"><span class="hljs-string">"stdafx.h"</span></span> #include <span class="hljs-string"><span class="hljs-string">"CppUnitTest.h"</span></span> #include <span class="hljs-string"><span class="hljs-string">"Interpreter.h"</span></span> namespace InterpreterTests { using namespace Microsoft::VisualStudio::CppUnitTestFramework; using namespace Interpreter; using namespace std; namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(expect)), distance(actualIter, <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(actual)), L<span class="hljs-string"><span class="hljs-string">"Size differs."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(; expectIter != <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(expect) &amp;&amp; actualIter != <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(actual); ++expectIter, ++actualIter) { auto message = L<span class="hljs-string"><span class="hljs-string">"Mismatch in position "</span></span> + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual&lt;T&gt;(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange TEST_CLASS(LexerTests) { public: TEST_METHOD(Should_return_empty_token_list_when_put_empty_expression) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">""</span></span>); Assert::IsTrue(tokens.empty()); } TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"+"</span></span>); AssertRange::AreEqual({ Operator::Plus }, tokens); } TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"1"</span></span>); AssertRange::AreEqual({ <span class="hljs-number"><span class="hljs-number">1.0</span></span> }, tokens); } TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"12.34"</span></span>); AssertRange::AreEqual({ <span class="hljs-number"><span class="hljs-number">12.34</span></span> }, tokens); } TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"+12.34"</span></span>); AssertRange::AreEqual({ Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">12.34</span></span>) }, tokens); } TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">" 1 + 12.34 "</span></span>); AssertRange::AreEqual({ Token(<span class="hljs-number"><span class="hljs-number">1.0</span></span>), Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">12.34</span></span>) }, tokens); } TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"1+2*3/(4-5)"</span></span>); AssertRange::AreEqual({ Token(<span class="hljs-number"><span class="hljs-number">1</span></span>), Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">2</span></span>), Token(Operator::Mul), Token(<span class="hljs-number"><span class="hljs-number">3</span></span>), Token(Operator::Div), Token(Operator::LParen), Token(<span class="hljs-number"><span class="hljs-number">4</span></span>), Token(Operator::Minus), Token(<span class="hljs-number"><span class="hljs-number">5</span></span>), Token(Operator::RParen) }, tokens); } }; TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } TEST_METHOD(Should_get_type_for_number_token) { Token numToken(<span class="hljs-number"><span class="hljs-number">1.2</span></span>); Assert::AreEqual(TokenType::Number, numToken.Type()); } TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); } TEST_METHOD(Should_get_number_value_from_number_token) { Token token(<span class="hljs-number"><span class="hljs-number">1.23</span></span>); Assert::AreEqual&lt;double&gt;(<span class="hljs-number"><span class="hljs-number">1.23</span></span>, token); } }; }</code> <br> <br> <a href="https://github.com/Unril/InterpreterTDD/releases/tag/%25D0%259A%25D0%25BE%25D0%25BD%25D0%25B5%25D1%2586_%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B2%25D0%25BE%25D0%25B9_%25D1%2587%25D0%25B0%25D1%2581%25D1%2582%25D0%25B8">    GitHub</a> .         ,  .      <span class="hljs-string"><span class="hljs-string">"__"</span></span>. <br> <br>   <a href="http://habrahabr.ru/post/232081/">    </a> .      ,      <a href="http://habrahabr.ru/post/232097/">    </a> .</code> </pre> <code><code>std::vector,      Tokens</code> .            . <br> <br> <code class="cpp">#pragma once; #include &lt;vector&gt; namespace Interpreter { struct Token {}; typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { inline Tokens Tokenize(std::string expr) { throw std::exception(); } } // namespace Lexer } // namespace Interpreter</code> <br>   ,  ,   , .   ,    ,    <a href="http://cleancoder.posterous.com/the-transformation-priority-premise">The Transformation Priority Premise (TPP)</a>   .    , ,    ,     ,        .            .     ,     ,      ,           .  ,  ,   (   )    ,  ,  .     ,  ,         .     ,   TPP          . <br> <br>   : <br> <br> ({} ‚Üí nil)     ,   . (nil ‚Üí constant)    . (constant ‚Üí constant+)      (        ,  ). (constant ‚Üí scalar)    ,  . (statement ‚Üí statements)    (break, continue, return  ). (unconditional ‚Üí if)       . (scalar ‚Üí array)  / . (array ‚Üí container)     . (statement ‚Üí recursion)   . (if ‚Üí while)    . (expression ‚Üí function)   . (variable ‚Üí assignment)   . <br>        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::string expr) { return{}; }</code> <br> ,         .     . <br> <br> <s>         </s> .           .           .               .            .       . <br>  ,  <code>std::string</code>  <code>std::wstring</code> .         ,      Unicode.     . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); }</code> <br>  <code>AssertRange</code> -   ,       <code>AreEqual</code> ,   ,  ,    . <br> <br> <b class="spoiler_title">AssertRange</b> <code class="cpp">namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange</code> <br> <br>         <code>Operator</code>    .          <code>wchar_t</code>   ,         ,      . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', }; typedef Operator Token;</code> <br>    ,   ,        <code>Assert</code> ,    <code>ToString</code> ,    . <br> <br> <b class="spoiler_title">std::wstring ToString(const Token &amp;)</b> <code class="cpp">inline std::wstring ToString(const Token &amp;token) { return{ static_cast&lt;wchar_t&gt;(token) }; }</code> <br> <br>    ,   ,        .  ,   (unconditional ‚Üí if). <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { if(expr.empty()) { return{}; } return{ static_cast&lt;Operator&gt;(expr[0]) }; }</code> <br> <s>         </s> . <s>          .</s>           . ‚Ä¶ <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); }</code> <br>     .   ,     ,   - .    , : <br> <br>        ,      <code>Token</code> .       <code>dynamic_cast</code>    ,   .  ,    ,      .      <code>std::function</code>        .        .  Boost.Any,  - .            . <br>   ,   .      -  .  ,      ,      . <br> <br> ‚Ä¶        .        .        .        . <br>             . <br> <br> <code class="cpp">enum class TokenType { Operator, Number }; class Token { public: Token(Operator) {} TokenType Type() const { return TokenType::Operator; } }; ‚Ä¶ TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } };</code> <br>   <code>ToString</code>   <code>TokenType</code>       ,   ,   .     . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); }</code> <br>   .   (constant ‚Üí scalar)   . <br> <br> <code class="cpp">class Token { public: Token(Operator) :m_type(TokenType::Operator) {} Token(double) :m_type(TokenType::Number) {} TokenType Type() const { return m_type; } private: TokenType m_type; };</code> <br> ‚Ä¶ <s>       </s> . <s>       </s> .        .        . <br>    . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); }</code> <br>            . <br> <br> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} operator Operator() const { return m_operator; } ‚Ä¶ Operator m_operator; };</code> <br>      . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); }</code> <br>          ,  ,       <code>union</code> .         . <br> <br> <b class="spoiler_title">Token</b> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: return "Unknown token."; } }</code> <br> <br>  ,    ,      ,    .       .    . <br> <br> <i>          .</i>               .            .       . <br>        : <br> <br> <code class="cpp"> if(expr[0] &gt;= '0' &amp;&amp; expr[0] &lt;= '9') { return{ (double) expr[0] - '0' }; } return{ static_cast&lt;Operator&gt;(expr[0]) };</code> <br>      ,   . <br> <br> ‚Ä¶ <s>          .</s> <i>              .</i> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); }</code> <br> ,     <code>C</code>   ,  <code>isdigit</code> , ,       <code>atof</code> ,    ,      <code>wchar_t</code> .  (expression ‚Üí function).         . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { const wchar_t *current = expr.c_str(); if(!*current) return{}; if(iswdigit(*current)) return{ _wtof(current) }; return{ static_cast&lt;Operator&gt;(*current) }; }</code> <br>         .      . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>   ,        .  ,     .     .   <code>result</code> ,     . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); if(!*current) return result; if(iswdigit(*current)) { result.push_back(_wtof(current)); } else { result.push_back(static_cast&lt;Operator&gt;(*current)); } return result; }</code> <br>      :   (if ‚Üí while).     ,        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } } return result; }</code> <br>  <code>wcstod</code>    ,   <code>_wtof</code> ,           .           ,              .  ,    . <br> <br> <s>           .</s>       . <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>  (unconditional ‚Üí if)    ,    . <br> <br> <code class="cpp"> while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else if(*current == static_cast&lt;wchar_t&gt;(Operator::Plus)) { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } else { ++current; } }</code> <br>       .          .       <code>Detail</code>      .   <code>Tokenize</code>       . <br> <br> <code class="cpp">inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); }</code> <br> <b class="spoiler_title"> Detail::Tokenizer</b> <code class="cpp">namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { return *m_current == static_cast&lt;wchar_t&gt;(Operator::Plus); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail</code> <br> <br>  ,      .      ,  , .       . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); }</code> <br>      <code>Operator</code> ,    . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', };</code> <br>   .         <code>IsOperator</code>  <code>Tokenizer</code> . <br> <br> <code class="cpp"> bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); }</code> <br>         .        . <br> <br> <b class="spoiler_title">Interpreter.h</b> <code class="cpp">#pragma once; #include &lt;vector&gt; #include &lt;wchar.h&gt; #include &lt;algorithm&gt; namespace Interpreter { enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', }; inline std::wstring ToString(const Operator &amp;op) { return{ static_cast&lt;wchar_t&gt;(op) }; } enum class TokenType { Operator, Number }; inline std::wstring ToString(const TokenType &amp;type) { switch(type) { case TokenType::Operator: return L"Operator"; case TokenType::Number: return L"Number"; default: throw std::out_of_range("TokenType"); } } class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } friend inline bool operator==(const Token &amp;left, const Token &amp;right) { if(left.m_type == right.m_type) { switch(left.m_type) { case Interpreter::TokenType::Operator: return left.m_operator == right.m_operator; case Interpreter::TokenType::Number: return left.m_number == right.m_number; default: throw std::out_of_range("TokenType"); } } return false; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: throw std::out_of_range("TokenType"); } } typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); } } // namespace Lexer } // namespace Interpreter</code> <br> <br> <b class="spoiler_title">InterpreterTests.cpp</b> <code class="cpp">#include "stdafx.h" #include "CppUnitTest.h" #include "Interpreter.h" namespace InterpreterTests { using namespace Microsoft::VisualStudio::CppUnitTestFramework; using namespace Interpreter; using namespace std; namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual&lt;T&gt;(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange TEST_CLASS(LexerTests) { public: TEST_METHOD(Should_return_empty_token_list_when_put_empty_expression) { Tokens tokens = Lexer::Tokenize(L""); Assert::IsTrue(tokens.empty()); } TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); } TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); } TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); } TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); } }; TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); } TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); } TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); } }; }</code> <br> <br> <a href="https://github.com/Unril/InterpreterTDD/releases/tag/%25D0%259A%25D0%25BE%25D0%25BD%25D0%25B5%25D1%2586_%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B2%25D0%25BE%25D0%25B9_%25D1%2587%25D0%25B0%25D1%2581%25D1%2582%25D0%25B8">    GitHub</a> .         ,  .      "__". <br> <br>   <a href="http://habrahabr.ru/post/232081/">    </a> .      ,      <a href="http://habrahabr.ru/post/232097/">    </a> .</code> <ul><li> <code><s><code>std::vector,      Tokens</code> .            . <br> <br> <code class="cpp">#pragma once; #include &lt;vector&gt; namespace Interpreter { struct Token {}; typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { inline Tokens Tokenize(std::string expr) { throw std::exception(); } } // namespace Lexer } // namespace Interpreter</code> <br>   ,  ,   , .   ,    ,    <a href="http://cleancoder.posterous.com/the-transformation-priority-premise">The Transformation Priority Premise (TPP)</a>   .    , ,    ,     ,        .            .     ,     ,      ,           .  ,  ,   (   )    ,  ,  .     ,  ,         .     ,   TPP          . <br> <br>   : <br> <br> ({} ‚Üí nil)     ,   . (nil ‚Üí constant)    . (constant ‚Üí constant+)      (        ,  ). (constant ‚Üí scalar)    ,  . (statement ‚Üí statements)    (break, continue, return  ). (unconditional ‚Üí if)       . (scalar ‚Üí array)  / . (array ‚Üí container)     . (statement ‚Üí recursion)   . (if ‚Üí while)    . (expression ‚Üí function)   . (variable ‚Üí assignment)   . <br>        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::string expr) { return{}; }</code> <br> ,         .     . <br> <br> <s>         </s> .           .           .               .            .       . <br>  ,  <code>std::string</code>  <code>std::wstring</code> .         ,      Unicode.     . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); }</code> <br>  <code>AssertRange</code> -   ,       <code>AreEqual</code> ,   ,  ,    . <br> <br> <b class="spoiler_title">AssertRange</b> <code class="cpp">namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange</code> <br> <br>         <code>Operator</code>    .          <code>wchar_t</code>   ,         ,      . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', }; typedef Operator Token;</code> <br>    ,   ,        <code>Assert</code> ,    <code>ToString</code> ,    . <br> <br> <b class="spoiler_title">std::wstring ToString(const Token &amp;)</b> <code class="cpp">inline std::wstring ToString(const Token &amp;token) { return{ static_cast&lt;wchar_t&gt;(token) }; }</code> <br> <br>    ,   ,        .  ,   (unconditional ‚Üí if). <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { if(expr.empty()) { return{}; } return{ static_cast&lt;Operator&gt;(expr[0]) }; }</code> <br> <s>         </s> . <s>          .</s>           . ‚Ä¶ <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); }</code> <br>     .   ,     ,   - .    , : <br> <br>        ,      <code>Token</code> .       <code>dynamic_cast</code>    ,   .  ,    ,      .      <code>std::function</code>        .        .  Boost.Any,  - .            . <br>   ,   .      -  .  ,      ,      . <br> <br> ‚Ä¶        .        .        .        . <br>             . <br> <br> <code class="cpp">enum class TokenType { Operator, Number }; class Token { public: Token(Operator) {} TokenType Type() const { return TokenType::Operator; } }; ‚Ä¶ TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } };</code> <br>   <code>ToString</code>   <code>TokenType</code>       ,   ,   .     . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); }</code> <br>   .   (constant ‚Üí scalar)   . <br> <br> <code class="cpp">class Token { public: Token(Operator) :m_type(TokenType::Operator) {} Token(double) :m_type(TokenType::Number) {} TokenType Type() const { return m_type; } private: TokenType m_type; };</code> <br> ‚Ä¶ <s>       </s> . <s>       </s> .        .        . <br>    . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); }</code> <br>            . <br> <br> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} operator Operator() const { return m_operator; } ‚Ä¶ Operator m_operator; };</code> <br>      . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); }</code> <br>          ,  ,       <code>union</code> .         . <br> <br> <b class="spoiler_title">Token</b> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: return "Unknown token."; } }</code> <br> <br>  ,    ,      ,    .       .    . <br> <br> <i>          .</i>               .            .       . <br>        : <br> <br> <code class="cpp"> if(expr[0] &gt;= '0' &amp;&amp; expr[0] &lt;= '9') { return{ (double) expr[0] - '0' }; } return{ static_cast&lt;Operator&gt;(expr[0]) };</code> <br>      ,   . <br> <br> ‚Ä¶ <s>          .</s> <i>              .</i> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); }</code> <br> ,     <code>C</code>   ,  <code>isdigit</code> , ,       <code>atof</code> ,    ,      <code>wchar_t</code> .  (expression ‚Üí function).         . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { const wchar_t *current = expr.c_str(); if(!*current) return{}; if(iswdigit(*current)) return{ _wtof(current) }; return{ static_cast&lt;Operator&gt;(*current) }; }</code> <br>         .      . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>   ,        .  ,     .     .   <code>result</code> ,     . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); if(!*current) return result; if(iswdigit(*current)) { result.push_back(_wtof(current)); } else { result.push_back(static_cast&lt;Operator&gt;(*current)); } return result; }</code> <br>      :   (if ‚Üí while).     ,        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } } return result; }</code> <br>  <code>wcstod</code>    ,   <code>_wtof</code> ,           .           ,              .  ,    . <br> <br>            .       . <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>  (unconditional ‚Üí if)    ,    . <br> <br> <code class="cpp"> while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else if(*current == static_cast&lt;wchar_t&gt;(Operator::Plus)) { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } else { ++current; } }</code> <br>       .          .       <code>Detail</code>      .   <code>Tokenize</code>       . <br> <br> <code class="cpp">inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); }</code> <br> <b class="spoiler_title"> Detail::Tokenizer</b> <code class="cpp">namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { return *m_current == static_cast&lt;wchar_t&gt;(Operator::Plus); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail</code> <br> <br>  ,      .      ,  , .       . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); }</code> <br>      <code>Operator</code> ,    . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', };</code> <br>   .         <code>IsOperator</code>  <code>Tokenizer</code> . <br> <br> <code class="cpp"> bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); }</code> <br>         .        . <br> <br> <b class="spoiler_title">Interpreter.h</b> <code class="cpp">#pragma once; #include &lt;vector&gt; #include &lt;wchar.h&gt; #include &lt;algorithm&gt; namespace Interpreter { enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', }; inline std::wstring ToString(const Operator &amp;op) { return{ static_cast&lt;wchar_t&gt;(op) }; } enum class TokenType { Operator, Number }; inline std::wstring ToString(const TokenType &amp;type) { switch(type) { case TokenType::Operator: return L"Operator"; case TokenType::Number: return L"Number"; default: throw std::out_of_range("TokenType"); } } class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } friend inline bool operator==(const Token &amp;left, const Token &amp;right) { if(left.m_type == right.m_type) { switch(left.m_type) { case Interpreter::TokenType::Operator: return left.m_operator == right.m_operator; case Interpreter::TokenType::Number: return left.m_number == right.m_number; default: throw std::out_of_range("TokenType"); } } return false; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: throw std::out_of_range("TokenType"); } } typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); } } // namespace Lexer } // namespace Interpreter</code> <br> <br> <b class="spoiler_title">InterpreterTests.cpp</b> <code class="cpp">#include "stdafx.h" #include "CppUnitTest.h" #include "Interpreter.h" namespace InterpreterTests { using namespace Microsoft::VisualStudio::CppUnitTestFramework; using namespace Interpreter; using namespace std; namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual&lt;T&gt;(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange TEST_CLASS(LexerTests) { public: TEST_METHOD(Should_return_empty_token_list_when_put_empty_expression) { Tokens tokens = Lexer::Tokenize(L""); Assert::IsTrue(tokens.empty()); } TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); } TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); } TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); } TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); } }; TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); } TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); } TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); } }; }</code> <br> <br> <a href="https://github.com/Unril/InterpreterTDD/releases/tag/%25D0%259A%25D0%25BE%25D0%25BD%25D0%25B5%25D1%2586_%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B2%25D0%25BE%25D0%25B9_%25D1%2587%25D0%25B0%25D1%2581%25D1%2582%25D0%25B8">    GitHub</a> .         ,  .      "__". <br> <br>   <a href="http://habrahabr.ru/post/232081/">    </a> .      ,      <a href="http://habrahabr.ru/post/232097/">    </a> .</s></code> </li> <li> <code><code>std::vector,      Tokens</code> .            . <br> <br> <code class="cpp">#pragma once; #include &lt;vector&gt; namespace Interpreter { struct Token {}; typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { inline Tokens Tokenize(std::string expr) { throw std::exception(); } } // namespace Lexer } // namespace Interpreter</code> <br>   ,  ,   , .   ,    ,    <a href="http://cleancoder.posterous.com/the-transformation-priority-premise">The Transformation Priority Premise (TPP)</a>   .    , ,    ,     ,        .            .     ,     ,      ,           .  ,  ,   (   )    ,  ,  .     ,  ,         .     ,   TPP          . <br> <br>   : <br> <br> ({} ‚Üí nil)     ,   . (nil ‚Üí constant)    . (constant ‚Üí constant+)      (        ,  ). (constant ‚Üí scalar)    ,  . (statement ‚Üí statements)    (break, continue, return  ). (unconditional ‚Üí if)       . (scalar ‚Üí array)  / . (array ‚Üí container)     . (statement ‚Üí recursion)   . (if ‚Üí while)    . (expression ‚Üí function)   . (variable ‚Üí assignment)   . <br>        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::string expr) { return{}; }</code> <br> ,         .     . <br> <br> <s>         </s> .           .           .               .            .       . <br>  ,  <code>std::string</code>  <code>std::wstring</code> .         ,      Unicode.     . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); }</code> <br>  <code>AssertRange</code> -   ,       <code>AreEqual</code> ,   ,  ,    . <br> <br> <b class="spoiler_title">AssertRange</b> <code class="cpp">namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange</code> <br> <br>         <code>Operator</code>    .          <code>wchar_t</code>   ,         ,      . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', }; typedef Operator Token;</code> <br>    ,   ,        <code>Assert</code> ,    <code>ToString</code> ,    . <br> <br> <b class="spoiler_title">std::wstring ToString(const Token &amp;)</b> <code class="cpp">inline std::wstring ToString(const Token &amp;token) { return{ static_cast&lt;wchar_t&gt;(token) }; }</code> <br> <br>    ,   ,        .  ,   (unconditional ‚Üí if). <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { if(expr.empty()) { return{}; } return{ static_cast&lt;Operator&gt;(expr[0]) }; }</code> <br> <s>         </s> . <s>          .</s>           . ‚Ä¶ <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); }</code> <br>     .   ,     ,   - .    , : <br> <br>        ,      <code>Token</code> .       <code>dynamic_cast</code>    ,   .  ,    ,      .      <code>std::function</code>        .        .  Boost.Any,  - .            . <br>   ,   .      -  .  ,      ,      . <br> <br> ‚Ä¶        .        .        .        . <br>             . <br> <br> <code class="cpp">enum class TokenType { Operator, Number }; class Token { public: Token(Operator) {} TokenType Type() const { return TokenType::Operator; } }; ‚Ä¶ TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } };</code> <br>   <code>ToString</code>   <code>TokenType</code>       ,   ,   .     . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); }</code> <br>   .   (constant ‚Üí scalar)   . <br> <br> <code class="cpp">class Token { public: Token(Operator) :m_type(TokenType::Operator) {} Token(double) :m_type(TokenType::Number) {} TokenType Type() const { return m_type; } private: TokenType m_type; };</code> <br> ‚Ä¶ <s>       </s> . <s>       </s> .        .        . <br>    . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); }</code> <br>            . <br> <br> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} operator Operator() const { return m_operator; } ‚Ä¶ Operator m_operator; };</code> <br>      . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); }</code> <br>          ,  ,       <code>union</code> .         . <br> <br> <b class="spoiler_title">Token</b> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: return "Unknown token."; } }</code> <br> <br>  ,    ,      ,    .       .    . <br> <br> <i>          .</i>               .            .       . <br>        : <br> <br> <code class="cpp"> if(expr[0] &gt;= '0' &amp;&amp; expr[0] &lt;= '9') { return{ (double) expr[0] - '0' }; } return{ static_cast&lt;Operator&gt;(expr[0]) };</code> <br>      ,   . <br> <br> ‚Ä¶ <s>          .</s> <i>              .</i> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); }</code> <br> ,     <code>C</code>   ,  <code>isdigit</code> , ,       <code>atof</code> ,    ,      <code>wchar_t</code> .  (expression ‚Üí function).         . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { const wchar_t *current = expr.c_str(); if(!*current) return{}; if(iswdigit(*current)) return{ _wtof(current) }; return{ static_cast&lt;Operator&gt;(*current) }; }</code> <br>         .      . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>   ,        .  ,     .     .   <code>result</code> ,     . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); if(!*current) return result; if(iswdigit(*current)) { result.push_back(_wtof(current)); } else { result.push_back(static_cast&lt;Operator&gt;(*current)); } return result; }</code> <br>      :   (if ‚Üí while).     ,        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } } return result; }</code> <br>  <code>wcstod</code>    ,   <code>_wtof</code> ,           .           ,              .  ,    . <br> <br> <s>           .</s>       . <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>  (unconditional ‚Üí if)    ,    . <br> <br> <code class="cpp"> while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else if(*current == static_cast&lt;wchar_t&gt;(Operator::Plus)) { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } else { ++current; } }</code> <br>       .          .       <code>Detail</code>      .   <code>Tokenize</code>       . <br> <br> <code class="cpp">inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); }</code> <br> <b class="spoiler_title"> Detail::Tokenizer</b> <code class="cpp">namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { return *m_current == static_cast&lt;wchar_t&gt;(Operator::Plus); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail</code> <br> <br>  ,      .      ,  , .       . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); }</code> <br>      <code>Operator</code> ,    . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', };</code> <br>   .         <code>IsOperator</code>  <code>Tokenizer</code> . <br> <br> <code class="cpp"> bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); }</code> <br>         .        . <br> <br> <b class="spoiler_title">Interpreter.h</b> <code class="cpp">#pragma once; #include &lt;vector&gt; #include &lt;wchar.h&gt; #include &lt;algorithm&gt; namespace Interpreter { enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', }; inline std::wstring ToString(const Operator &amp;op) { return{ static_cast&lt;wchar_t&gt;(op) }; } enum class TokenType { Operator, Number }; inline std::wstring ToString(const TokenType &amp;type) { switch(type) { case TokenType::Operator: return L"Operator"; case TokenType::Number: return L"Number"; default: throw std::out_of_range("TokenType"); } } class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } friend inline bool operator==(const Token &amp;left, const Token &amp;right) { if(left.m_type == right.m_type) { switch(left.m_type) { case Interpreter::TokenType::Operator: return left.m_operator == right.m_operator; case Interpreter::TokenType::Number: return left.m_number == right.m_number; default: throw std::out_of_range("TokenType"); } } return false; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: throw std::out_of_range("TokenType"); } } typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); } } // namespace Lexer } // namespace Interpreter</code> <br> <br> <b class="spoiler_title">InterpreterTests.cpp</b> <code class="cpp">#include "stdafx.h" #include "CppUnitTest.h" #include "Interpreter.h" namespace InterpreterTests { using namespace Microsoft::VisualStudio::CppUnitTestFramework; using namespace Interpreter; using namespace std; namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual&lt;T&gt;(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange TEST_CLASS(LexerTests) { public: TEST_METHOD(Should_return_empty_token_list_when_put_empty_expression) { Tokens tokens = Lexer::Tokenize(L""); Assert::IsTrue(tokens.empty()); } TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); } TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); } TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); } TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); } }; TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); } TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); } TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); } }; }</code> <br> <br> <a href="https://github.com/Unril/InterpreterTDD/releases/tag/%25D0%259A%25D0%25BE%25D0%25BD%25D0%25B5%25D1%2586_%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B2%25D0%25BE%25D0%25B9_%25D1%2587%25D0%25B0%25D1%2581%25D1%2582%25D0%25B8">    GitHub</a> .         ,  .      "__". <br> <br>   <a href="http://habrahabr.ru/post/232081/">    </a> .      ,      <a href="http://habrahabr.ru/post/232097/">    </a> .</code> </li> </ul> <code><code>std::vector,      Tokens</code> .            . <br> <br> <code class="cpp">#pragma once; #include &lt;vector&gt; namespace Interpreter { struct Token {}; typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { inline Tokens Tokenize(std::string expr) { throw std::exception(); } } // namespace Lexer } // namespace Interpreter</code> <br>   ,  ,   , .   ,    ,    <a href="http://cleancoder.posterous.com/the-transformation-priority-premise">The Transformation Priority Premise (TPP)</a>   .    , ,    ,     ,        .            .     ,     ,      ,           .  ,  ,   (   )    ,  ,  .     ,  ,         .     ,   TPP          . <br> <br>   : <br> <br> ({} ‚Üí nil)     ,   . (nil ‚Üí constant)    . (constant ‚Üí constant+)      (        ,  ). (constant ‚Üí scalar)    ,  . (statement ‚Üí statements)    (break, continue, return  ). (unconditional ‚Üí if)       . (scalar ‚Üí array)  / . (array ‚Üí container)     . (statement ‚Üí recursion)   . (if ‚Üí while)    . (expression ‚Üí function)   . (variable ‚Üí assignment)   . <br>        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::string expr) { return{}; }</code> <br> ,         .     . <br> <br> <s>         </s> .           .           .               .            .       . <br>  ,  <code>std::string</code>  <code>std::wstring</code> .         ,      Unicode.     . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); }</code> <br>  <code>AssertRange</code> -   ,       <code>AreEqual</code> ,   ,  ,    . <br> <br> <b class="spoiler_title">AssertRange</b> <code class="cpp">namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange</code> <br> <br>         <code>Operator</code>    .          <code>wchar_t</code>   ,         ,      . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', }; typedef Operator Token;</code> <br>    ,   ,        <code>Assert</code> ,    <code>ToString</code> ,    . <br> <br> <b class="spoiler_title">std::wstring ToString(const Token &amp;)</b> <code class="cpp">inline std::wstring ToString(const Token &amp;token) { return{ static_cast&lt;wchar_t&gt;(token) }; }</code> <br> <br>    ,   ,        .  ,   (unconditional ‚Üí if). <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { if(expr.empty()) { return{}; } return{ static_cast&lt;Operator&gt;(expr[0]) }; }</code> <br> <s>         </s> . <s>          .</s>           . ‚Ä¶ <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); }</code> <br>     .   ,     ,   - .    , : <br> <br>        ,      <code>Token</code> .       <code>dynamic_cast</code>    ,   .  ,    ,      .      <code>std::function</code>        .        .  Boost.Any,  - .            . <br>   ,   .      -  .  ,      ,      . <br> <br> ‚Ä¶        .        .        .        . <br>             . <br> <br> <code class="cpp">enum class TokenType { Operator, Number }; class Token { public: Token(Operator) {} TokenType Type() const { return TokenType::Operator; } }; ‚Ä¶ TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } };</code> <br>   <code>ToString</code>   <code>TokenType</code>       ,   ,   .     . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); }</code> <br>   .   (constant ‚Üí scalar)   . <br> <br> <code class="cpp">class Token { public: Token(Operator) :m_type(TokenType::Operator) {} Token(double) :m_type(TokenType::Number) {} TokenType Type() const { return m_type; } private: TokenType m_type; };</code> <br> ‚Ä¶ <s>       </s> . <s>       </s> .        .        . <br>    . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); }</code> <br>            . <br> <br> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} operator Operator() const { return m_operator; } ‚Ä¶ Operator m_operator; };</code> <br>      . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); }</code> <br>          ,  ,       <code>union</code> .         . <br> <br> <b class="spoiler_title">Token</b> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: return "Unknown token."; } }</code> <br> <br>  ,    ,      ,    .       .    . <br> <br> <i>          .</i>               .            .       . <br>        : <br> <br> <code class="cpp"> if(expr[0] &gt;= '0' &amp;&amp; expr[0] &lt;= '9') { return{ (double) expr[0] - '0' }; } return{ static_cast&lt;Operator&gt;(expr[0]) };</code> <br>      ,   . <br> <br> ‚Ä¶ <s>          .</s> <i>              .</i> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); }</code> <br> ,     <code>C</code>   ,  <code>isdigit</code> , ,       <code>atof</code> ,    ,      <code>wchar_t</code> .  (expression ‚Üí function).         . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { const wchar_t *current = expr.c_str(); if(!*current) return{}; if(iswdigit(*current)) return{ _wtof(current) }; return{ static_cast&lt;Operator&gt;(*current) }; }</code> <br>         .      . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>   ,        .  ,     .     .   <code>result</code> ,     . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); if(!*current) return result; if(iswdigit(*current)) { result.push_back(_wtof(current)); } else { result.push_back(static_cast&lt;Operator&gt;(*current)); } return result; }</code> <br>      :   (if ‚Üí while).     ,        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } } return result; }</code> <br>  <code>wcstod</code>    ,   <code>_wtof</code> ,           .           ,              .  ,    . <br> <br> <s>           .</s>       . <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>  (unconditional ‚Üí if)    ,    . <br> <br> <code class="cpp"> while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else if(*current == static_cast&lt;wchar_t&gt;(Operator::Plus)) { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } else { ++current; } }</code> <br>       .          .       <code>Detail</code>      .   <code>Tokenize</code>       . <br> <br> <code class="cpp">inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); }</code> <br> <b class="spoiler_title"> Detail::Tokenizer</b> <code class="cpp">namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { return *m_current == static_cast&lt;wchar_t&gt;(Operator::Plus); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail</code> <br> <br>  ,      .      ,  , .       . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); }</code> <br>      <code>Operator</code> ,    . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', };</code> <br>   .         <code>IsOperator</code>  <code>Tokenizer</code> . <br> <br> <code class="cpp"> bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); }</code> <br>         .        . <br> <br> <b class="spoiler_title">Interpreter.h</b> <code class="cpp">#pragma once; #include &lt;vector&gt; #include &lt;wchar.h&gt; #include &lt;algorithm&gt; namespace Interpreter { enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', }; inline std::wstring ToString(const Operator &amp;op) { return{ static_cast&lt;wchar_t&gt;(op) }; } enum class TokenType { Operator, Number }; inline std::wstring ToString(const TokenType &amp;type) { switch(type) { case TokenType::Operator: return L"Operator"; case TokenType::Number: return L"Number"; default: throw std::out_of_range("TokenType"); } } class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } friend inline bool operator==(const Token &amp;left, const Token &amp;right) { if(left.m_type == right.m_type) { switch(left.m_type) { case Interpreter::TokenType::Operator: return left.m_operator == right.m_operator; case Interpreter::TokenType::Number: return left.m_number == right.m_number; default: throw std::out_of_range("TokenType"); } } return false; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: throw std::out_of_range("TokenType"); } } typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); } } // namespace Lexer } // namespace Interpreter</code> <br> <br> <b class="spoiler_title">InterpreterTests.cpp</b> <code class="cpp">#include "stdafx.h" #include "CppUnitTest.h" #include "Interpreter.h" namespace InterpreterTests { using namespace Microsoft::VisualStudio::CppUnitTestFramework; using namespace Interpreter; using namespace std; namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual&lt;T&gt;(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange TEST_CLASS(LexerTests) { public: TEST_METHOD(Should_return_empty_token_list_when_put_empty_expression) { Tokens tokens = Lexer::Tokenize(L""); Assert::IsTrue(tokens.empty()); } TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); } TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); } TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); } TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); } }; TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); } TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); } TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); } }; }</code> <br> <br> <a href="https://github.com/Unril/InterpreterTDD/releases/tag/%25D0%259A%25D0%25BE%25D0%25BD%25D0%25B5%25D1%2586_%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B2%25D0%25BE%25D0%25B9_%25D1%2587%25D0%25B0%25D1%2581%25D1%2582%25D0%25B8">    GitHub</a> .         ,  .      "__". <br> <br>   <a href="http://habrahabr.ru/post/232081/">    </a> .      ,      <a href="http://habrahabr.ru/post/232097/">    </a> .</code> <pre> <code class="hljs lua"><code>std::vector,      Tokens</code> .            . <br> <br> <code class="cpp">#pragma once; #include &lt;vector&gt; namespace Interpreter { struct Token {}; typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { inline Tokens Tokenize(std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> expr) { throw std::exception(); } } // namespace Lexer } // namespace Interpreter</code> <br>   ,  ,   , .   ,    ,    <a href="http://cleancoder.posterous.com/the-transformation-priority-premise">The Transformation Priority Premise (TPP)</a>   .    , ,    ,     ,        .            .     ,     ,      ,           .  ,  ,   (   )    ,  ,  .     ,  ,         .     ,   TPP          . <br> <br>   : <br> <br> ({} ‚Üí <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)     ,   . (<span class="hljs-literal"><span class="hljs-literal">nil</span></span> ‚Üí constant)    . (constant ‚Üí constant+)      (        ,  ). (constant ‚Üí scalar)    ,  . (statement ‚Üí statements)    (<span class="hljs-keyword"><span class="hljs-keyword">break</span></span>, continue, <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>  ). (unconditional ‚Üí <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>)       . (scalar ‚Üí array)  / . (array ‚Üí container)     . (statement ‚Üí recursion)   . (<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ‚Üí <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>)    . (expression ‚Üí <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">)</span></span>   . (variable ‚Üí assignment)   . <br>        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> expr) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{}; }</code> <br> ,         .     . <br> <br> <s>         </s> .           .           .               .            .       . <br>  ,  <code>std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span></code>  <code>std::wstring</code> .         ,      Unicode.     . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"+"</span></span>); AssertRange::AreEqual({ Operator::Plus }, tokens); }</code> <br>  <code>AssertRange</code> -   ,       <code>AreEqual</code> ,   ,  ,    . <br> <br> <b class="spoiler_title">AssertRange</b> <code class="cpp">namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(expect)), distance(actualIter, <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(actual)), L<span class="hljs-string"><span class="hljs-string">"Size differs."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(; expectIter != <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(expect) &amp;&amp; actualIter != <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(actual); ++expectIter, ++actualIter) { auto message = L<span class="hljs-string"><span class="hljs-string">"Mismatch in position "</span></span> + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange</code> <br> <br>         <code>Operator</code>    .          <code>wchar_t</code>   ,         ,      . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L<span class="hljs-string"><span class="hljs-string">'+'</span></span>, }; typedef Operator Token;</code> <br>    ,   ,        <code>Assert</code> ,    <code>ToString</code> ,    . <br> <br> <b class="spoiler_title">std::wstring ToString(const Token &amp;)</b> <code class="cpp">inline std::wstring ToString(const Token &amp;token) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ static_cast&lt;wchar_t&gt;(token) }; }</code> <br> <br>    ,   ,        .  ,   (unconditional ‚Üí <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>). <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(expr.empty()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{}; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ static_cast&lt;Operator&gt;(expr[<span class="hljs-number"><span class="hljs-number">0</span></span>]) }; }</code> <br> <s>         </s> . <s>          .</s>           . ‚Ä¶ <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"1"</span></span>); AssertRange::AreEqual({ <span class="hljs-number"><span class="hljs-number">1.0</span></span> }, tokens); }</code> <br>     .   ,     ,   - .    , : <br> <br>        ,      <code>Token</code> .       <code>dynamic_cast</code>    ,   .  ,    ,      .      <code>std::<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span></span></code><span class="hljs-function"><span class="hljs-function">        .        .  </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Boost.Any</span></span></span><span class="hljs-function">,  - .            . </span></span><br><span class="hljs-function"><span class="hljs-function">   ,   .      -  .  ,      ,      . </span></span><br><span class="hljs-function"><span class="hljs-function"> </span></span><br><span class="hljs-function"><span class="hljs-function"> ‚Ä¶        .        .        .        . </span></span><br><span class="hljs-function"><span class="hljs-function">             . </span></span><br><span class="hljs-function"><span class="hljs-function"> </span></span><br><span class="hljs-function"><span class="hljs-function"> </span></span><code class="cpp"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">enum</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">class</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TokenType</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Operator</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Number</span></span></span><span class="hljs-function"> }; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">class</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Token</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">public</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Token</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Operator)</span></span></span></span> {} TokenType Type() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TokenType::Operator; } }; ‚Ä¶ TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } };</code> <br>   <code>ToString</code>   <code>TokenType</code>       ,   ,   .     . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_type_for_number_token) { Token numToken(<span class="hljs-number"><span class="hljs-number">1.2</span></span>); Assert::AreEqual(TokenType::Number, numToken.Type()); }</code> <br>   .   (constant ‚Üí scalar)   . <br> <br> <code class="cpp">class Token { public: Token(Operator) :m_type(TokenType::Operator) {} Token(double) :m_type(TokenType::Number) {} TokenType Type() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_type; } private: TokenType m_type; };</code> <br> ‚Ä¶ <s>       </s> . <s>       </s> .        .        . <br>    . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); }</code> <br>            . <br> <br> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} operator Operator() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_operator; } ‚Ä¶ Operator m_operator; };</code> <br>      . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_number_value_from_number_token) { Token token(<span class="hljs-number"><span class="hljs-number">1.23</span></span>); Assert::AreEqual&lt;double&gt;(<span class="hljs-number"><span class="hljs-number">1.23</span></span>, token); }</code> <br>          ,  ,       <code>union</code> .         . <br> <br> <b class="spoiler_title">Token</b> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_type; } operator Operator() const { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(m_type != TokenType::Operator) throw std::logic_error(<span class="hljs-string"><span class="hljs-string">"Should be operator token."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_operator; } operator double() const { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(m_type != TokenType::Number) throw std::logic_error(<span class="hljs-string"><span class="hljs-string">"Should be number token."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_number; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ToString(static_cast&lt;Operator&gt;(token)); default: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Unknown token."</span></span>; } }</code> <br> <br>  ,    ,      ,    .       .    . <br> <br> <i>          .</i>               .            .       . <br>        : <br> <br> <code class="cpp"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(expr[<span class="hljs-number"><span class="hljs-number">0</span></span>] &gt;= <span class="hljs-string"><span class="hljs-string">'0'</span></span> &amp;&amp; expr[<span class="hljs-number"><span class="hljs-number">0</span></span>] &lt;= <span class="hljs-string"><span class="hljs-string">'9'</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ (double) expr[<span class="hljs-number"><span class="hljs-number">0</span></span>] - <span class="hljs-string"><span class="hljs-string">'0'</span></span> }; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ static_cast&lt;Operator&gt;(expr[<span class="hljs-number"><span class="hljs-number">0</span></span>]) };</code> <br>      ,   . <br> <br> ‚Ä¶ <s>          .</s> <i>              .</i> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"12.34"</span></span>); AssertRange::AreEqual({ <span class="hljs-number"><span class="hljs-number">12.34</span></span> }, tokens); }</code> <br> ,     <code>C</code>   ,  <code>isdigit</code> , ,       <code>atof</code> ,    ,      <code>wchar_t</code> .  (expression ‚Üí <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">)</span></span>.         . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { const wchar_t *current = expr.c_str(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!*current) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{}; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(iswdigit(*current)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ _wtof(current) }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ static_cast&lt;Operator&gt;(*current) }; }</code> <br>         .      . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"+12.34"</span></span>); AssertRange::AreEqual({ Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">12.34</span></span>) }, tokens); }</code> <br>   ,        .  ,     .     .   <code>result</code> ,     . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!*current) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(iswdigit(*current)) { result.push_back(_wtof(current)); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { result.push_back(static_cast&lt;Operator&gt;(*current)); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> <br>      :   (<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ‚Üí <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>).     ,        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(*current) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(iswdigit(*current)) { wchar_t *<span class="hljs-keyword"><span class="hljs-keyword">end</span></span> = nullptr; result.push_back(wcstod(current, &amp;<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>)); current = <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> <br>  <code>wcstod</code>    ,   <code>_wtof</code> ,           .           ,              .  ,    . <br> <br> <s>           .</s>       . <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">" 1 + 12.34 "</span></span>); AssertRange::AreEqual({ Token(<span class="hljs-number"><span class="hljs-number">1.0</span></span>), Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">12.34</span></span>) }, tokens); }</code> <br>  (unconditional ‚Üí <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>)    ,    . <br> <br> <code class="cpp"> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(*current) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(iswdigit(*current)) { wchar_t *<span class="hljs-keyword"><span class="hljs-keyword">end</span></span> = nullptr; result.push_back(wcstod(current, &amp;<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>)); current = <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(*current == static_cast&lt;wchar_t&gt;(Operator::Plus)) { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { ++current; } }</code> <br>       .          .       <code>Detail</code>      .   <code>Tokenize</code>       . <br> <br> <code class="cpp">inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tokenizer.Result(); }</code> <br> <b class="spoiler_title"> Detail::Tokenizer</b> <code class="cpp">namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!EndOfExperssion()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(IsNumber()) { ScanNumber(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(IsOperator()) { ScanOperator(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { MoveNext(); } } } const Tokens &amp;Result() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_result; } private: bool EndOfExperssion() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_current == L<span class="hljs-string"><span class="hljs-string">'\0'</span></span>; } bool IsNumber() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> iswdigit(*m_current) != <span class="hljs-number"><span class="hljs-number">0</span></span>; } void ScanNumber() { wchar_t *<span class="hljs-keyword"><span class="hljs-keyword">end</span></span> = nullptr; m_result.push_back(wcstod(m_current, &amp;<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>)); m_current = <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; } bool IsOperator() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_current == static_cast&lt;wchar_t&gt;(Operator::Plus); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail</code> <br> <br>  ,      .      ,  , .       . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"1+2*3/(4-5)"</span></span>); AssertRange::AreEqual({ Token(<span class="hljs-number"><span class="hljs-number">1</span></span>), Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">2</span></span>), Token(Operator::Mul), Token(<span class="hljs-number"><span class="hljs-number">3</span></span>), Token(Operator::Div), Token(Operator::LParen), Token(<span class="hljs-number"><span class="hljs-number">4</span></span>), Token(Operator::Minus), Token(<span class="hljs-number"><span class="hljs-number">5</span></span>), Token(Operator::RParen) }, tokens); }</code> <br>      <code>Operator</code> ,    . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L<span class="hljs-string"><span class="hljs-string">'+'</span></span>, Minus = L<span class="hljs-string"><span class="hljs-string">'-'</span></span>, Mul = L<span class="hljs-string"><span class="hljs-string">'*'</span></span>, Div = L<span class="hljs-string"><span class="hljs-string">'/'</span></span>, LParen = L<span class="hljs-string"><span class="hljs-string">'('</span></span>, RParen = L<span class="hljs-string"><span class="hljs-string">')'</span></span>, };</code> <br>   .         <code>IsOperator</code>  <code>Tokenizer</code> . <br> <br> <code class="cpp"> bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> std::any_of(all.begin(), all.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(), [this](Operator o) {<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_current == static_cast&lt;wchar_t&gt;(o); }); }</code> <br>         .        . <br> <br> <b class="spoiler_title">Interpreter.h</b> <code class="cpp">#pragma once; #include &lt;vector&gt; #include &lt;wchar.h&gt; #include &lt;algorithm&gt; namespace Interpreter { enum class Operator : wchar_t { Plus = L<span class="hljs-string"><span class="hljs-string">'+'</span></span>, Minus = L<span class="hljs-string"><span class="hljs-string">'-'</span></span>, Mul = L<span class="hljs-string"><span class="hljs-string">'*'</span></span>, Div = L<span class="hljs-string"><span class="hljs-string">'/'</span></span>, LParen = L<span class="hljs-string"><span class="hljs-string">'('</span></span>, RParen = L<span class="hljs-string"><span class="hljs-string">')'</span></span>, }; inline std::wstring ToString(const Operator &amp;op) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ static_cast&lt;wchar_t&gt;(op) }; } enum class TokenType { Operator, Number }; inline std::wstring ToString(const TokenType &amp;<span class="hljs-built_in"><span class="hljs-built_in">type</span></span>) { switch(<span class="hljs-built_in"><span class="hljs-built_in">type</span></span>) { case TokenType::Operator: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> L<span class="hljs-string"><span class="hljs-string">"Operator"</span></span>; case TokenType::Number: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> L<span class="hljs-string"><span class="hljs-string">"Number"</span></span>; default: throw std::out_of_range(<span class="hljs-string"><span class="hljs-string">"TokenType"</span></span>); } } class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_type; } operator Operator() const { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(m_type != TokenType::Operator) throw std::logic_error(<span class="hljs-string"><span class="hljs-string">"Should be operator token."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_operator; } operator double() const { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(m_type != TokenType::Number) throw std::logic_error(<span class="hljs-string"><span class="hljs-string">"Should be number token."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_number; } friend inline bool operator==(const Token &amp;left, const Token &amp;right) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(left.m_type == right.m_type) { switch(left.m_type) { case Interpreter::TokenType::Operator: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> left.m_operator == right.m_operator; case Interpreter::TokenType::Number: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> left.m_number == right.m_number; default: throw std::out_of_range(<span class="hljs-string"><span class="hljs-string">"TokenType"</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ToString(static_cast&lt;Operator&gt;(token)); default: throw std::out_of_range(<span class="hljs-string"><span class="hljs-string">"TokenType"</span></span>); } } typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!EndOfExperssion()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(IsNumber()) { ScanNumber(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(IsOperator()) { ScanOperator(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { MoveNext(); } } } const Tokens &amp;Result() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_result; } private: bool EndOfExperssion() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_current == L<span class="hljs-string"><span class="hljs-string">'\0'</span></span>; } bool IsNumber() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> iswdigit(*m_current) != <span class="hljs-number"><span class="hljs-number">0</span></span>; } void ScanNumber() { wchar_t *<span class="hljs-keyword"><span class="hljs-keyword">end</span></span> = nullptr; m_result.push_back(wcstod(m_current, &amp;<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>)); m_current = <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; } bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> std::any_of(all.begin(), all.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(), [this](Operator o) {<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_current == static_cast&lt;wchar_t&gt;(o); }); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tokenizer.Result(); } } // namespace Lexer } // namespace Interpreter</code> <br> <br> <b class="spoiler_title">InterpreterTests.cpp</b> <code class="cpp">#include <span class="hljs-string"><span class="hljs-string">"stdafx.h"</span></span> #include <span class="hljs-string"><span class="hljs-string">"CppUnitTest.h"</span></span> #include <span class="hljs-string"><span class="hljs-string">"Interpreter.h"</span></span> namespace InterpreterTests { using namespace Microsoft::VisualStudio::CppUnitTestFramework; using namespace Interpreter; using namespace std; namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(expect)), distance(actualIter, <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(actual)), L<span class="hljs-string"><span class="hljs-string">"Size differs."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(; expectIter != <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(expect) &amp;&amp; actualIter != <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(actual); ++expectIter, ++actualIter) { auto message = L<span class="hljs-string"><span class="hljs-string">"Mismatch in position "</span></span> + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual&lt;T&gt;(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange TEST_CLASS(LexerTests) { public: TEST_METHOD(Should_return_empty_token_list_when_put_empty_expression) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">""</span></span>); Assert::IsTrue(tokens.empty()); } TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"+"</span></span>); AssertRange::AreEqual({ Operator::Plus }, tokens); } TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"1"</span></span>); AssertRange::AreEqual({ <span class="hljs-number"><span class="hljs-number">1.0</span></span> }, tokens); } TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"12.34"</span></span>); AssertRange::AreEqual({ <span class="hljs-number"><span class="hljs-number">12.34</span></span> }, tokens); } TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"+12.34"</span></span>); AssertRange::AreEqual({ Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">12.34</span></span>) }, tokens); } TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">" 1 + 12.34 "</span></span>); AssertRange::AreEqual({ Token(<span class="hljs-number"><span class="hljs-number">1.0</span></span>), Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">12.34</span></span>) }, tokens); } TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"1+2*3/(4-5)"</span></span>); AssertRange::AreEqual({ Token(<span class="hljs-number"><span class="hljs-number">1</span></span>), Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">2</span></span>), Token(Operator::Mul), Token(<span class="hljs-number"><span class="hljs-number">3</span></span>), Token(Operator::Div), Token(Operator::LParen), Token(<span class="hljs-number"><span class="hljs-number">4</span></span>), Token(Operator::Minus), Token(<span class="hljs-number"><span class="hljs-number">5</span></span>), Token(Operator::RParen) }, tokens); } }; TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } TEST_METHOD(Should_get_type_for_number_token) { Token numToken(<span class="hljs-number"><span class="hljs-number">1.2</span></span>); Assert::AreEqual(TokenType::Number, numToken.Type()); } TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); } TEST_METHOD(Should_get_number_value_from_number_token) { Token token(<span class="hljs-number"><span class="hljs-number">1.23</span></span>); Assert::AreEqual&lt;double&gt;(<span class="hljs-number"><span class="hljs-number">1.23</span></span>, token); } }; }</code> <br> <br> <a href="https://github.com/Unril/InterpreterTDD/releases/tag/%25D0%259A%25D0%25BE%25D0%25BD%25D0%25B5%25D1%2586_%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B2%25D0%25BE%25D0%25B9_%25D1%2587%25D0%25B0%25D1%2581%25D1%2582%25D0%25B8">    GitHub</a> .         ,  .      <span class="hljs-string"><span class="hljs-string">"__"</span></span>. <br> <br>   <a href="http://habrahabr.ru/post/232081/">    </a> .      ,      <a href="http://habrahabr.ru/post/232097/">    </a> .</code> </pre> <code><code>std::vector,      Tokens</code> .            . <br> <br> <code class="cpp">#pragma once; #include &lt;vector&gt; namespace Interpreter { struct Token {}; typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { inline Tokens Tokenize(std::string expr) { throw std::exception(); } } // namespace Lexer } // namespace Interpreter</code> <br>   ,  ,   , .   ,    ,    <a href="http://cleancoder.posterous.com/the-transformation-priority-premise">The Transformation Priority Premise (TPP)</a>   .    , ,    ,     ,        .            .     ,     ,      ,           .  ,  ,   (   )    ,  ,  .     ,  ,         .     ,   TPP          . <br> <br>   : <br> <br> ({} ‚Üí nil)     ,   . (nil ‚Üí constant)    . (constant ‚Üí constant+)      (        ,  ). (constant ‚Üí scalar)    ,  . (statement ‚Üí statements)    (break, continue, return  ). (unconditional ‚Üí if)       . (scalar ‚Üí array)  / . (array ‚Üí container)     . (statement ‚Üí recursion)   . (if ‚Üí while)    . (expression ‚Üí function)   . (variable ‚Üí assignment)   . <br>        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::string expr) { return{}; }</code> <br> ,         .     . <br> <br> <s>         </s> .           .           .               .            .       . <br>  ,  <code>std::string</code>  <code>std::wstring</code> .         ,      Unicode.     . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); }</code> <br>  <code>AssertRange</code> -   ,       <code>AreEqual</code> ,   ,  ,    . <br> <br> <b class="spoiler_title">AssertRange</b> <code class="cpp">namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange</code> <br> <br>         <code>Operator</code>    .          <code>wchar_t</code>   ,         ,      . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', }; typedef Operator Token;</code> <br>    ,   ,        <code>Assert</code> ,    <code>ToString</code> ,    . <br> <br> <b class="spoiler_title">std::wstring ToString(const Token &amp;)</b> <code class="cpp">inline std::wstring ToString(const Token &amp;token) { return{ static_cast&lt;wchar_t&gt;(token) }; }</code> <br> <br>    ,   ,        .  ,   (unconditional ‚Üí if). <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { if(expr.empty()) { return{}; } return{ static_cast&lt;Operator&gt;(expr[0]) }; }</code> <br> <s>         </s> . <s>          .</s>           . ‚Ä¶ <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); }</code> <br>     .   ,     ,   - .    , : <br> <br>        ,      <code>Token</code> .       <code>dynamic_cast</code>    ,   .  ,    ,      .      <code>std::function</code>        .        .  Boost.Any,  - .            . <br>   ,   .      -  .  ,      ,      . <br> <br> ‚Ä¶        .        .        .        . <br>             . <br> <br> <code class="cpp">enum class TokenType { Operator, Number }; class Token { public: Token(Operator) {} TokenType Type() const { return TokenType::Operator; } }; ‚Ä¶ TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } };</code> <br>   <code>ToString</code>   <code>TokenType</code>       ,   ,   .     . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); }</code> <br>   .   (constant ‚Üí scalar)   . <br> <br> <code class="cpp">class Token { public: Token(Operator) :m_type(TokenType::Operator) {} Token(double) :m_type(TokenType::Number) {} TokenType Type() const { return m_type; } private: TokenType m_type; };</code> <br> ‚Ä¶ <s>       </s> . <s>       </s> .        .        . <br>    . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); }</code> <br>            . <br> <br> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} operator Operator() const { return m_operator; } ‚Ä¶ Operator m_operator; };</code> <br>      . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); }</code> <br>          ,  ,       <code>union</code> .         . <br> <br> <b class="spoiler_title">Token</b> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: return "Unknown token."; } }</code> <br> <br>  ,    ,      ,    .       .    . <br> <br> <i>          .</i>               .            .       . <br>        : <br> <br> <code class="cpp"> if(expr[0] &gt;= '0' &amp;&amp; expr[0] &lt;= '9') { return{ (double) expr[0] - '0' }; } return{ static_cast&lt;Operator&gt;(expr[0]) };</code> <br>      ,   . <br> <br> ‚Ä¶ <s>          .</s> <i>              .</i> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); }</code> <br> ,     <code>C</code>   ,  <code>isdigit</code> , ,       <code>atof</code> ,    ,      <code>wchar_t</code> .  (expression ‚Üí function).         . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { const wchar_t *current = expr.c_str(); if(!*current) return{}; if(iswdigit(*current)) return{ _wtof(current) }; return{ static_cast&lt;Operator&gt;(*current) }; }</code> <br>         .      . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>   ,        .  ,     .     .   <code>result</code> ,     . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); if(!*current) return result; if(iswdigit(*current)) { result.push_back(_wtof(current)); } else { result.push_back(static_cast&lt;Operator&gt;(*current)); } return result; }</code> <br>      :   (if ‚Üí while).     ,        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } } return result; }</code> <br>  <code>wcstod</code>    ,   <code>_wtof</code> ,           .           ,              .  ,    . <br> <br> <s>           .</s>       . <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>  (unconditional ‚Üí if)    ,    . <br> <br> <code class="cpp"> while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else if(*current == static_cast&lt;wchar_t&gt;(Operator::Plus)) { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } else { ++current; } }</code> <br>       .          .       <code>Detail</code>      .   <code>Tokenize</code>       . <br> <br> <code class="cpp">inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); }</code> <br> <b class="spoiler_title"> Detail::Tokenizer</b> <code class="cpp">namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { return *m_current == static_cast&lt;wchar_t&gt;(Operator::Plus); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail</code> <br> <br>  ,      .      ,  , .       . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); }</code> <br>      <code>Operator</code> ,    . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', };</code> <br>   .         <code>IsOperator</code>  <code>Tokenizer</code> . <br> <br> <code class="cpp"> bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); }</code> <br>         .        . <br> <br> <b class="spoiler_title">Interpreter.h</b> <code class="cpp">#pragma once; #include &lt;vector&gt; #include &lt;wchar.h&gt; #include &lt;algorithm&gt; namespace Interpreter { enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', }; inline std::wstring ToString(const Operator &amp;op) { return{ static_cast&lt;wchar_t&gt;(op) }; } enum class TokenType { Operator, Number }; inline std::wstring ToString(const TokenType &amp;type) { switch(type) { case TokenType::Operator: return L"Operator"; case TokenType::Number: return L"Number"; default: throw std::out_of_range("TokenType"); } } class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } friend inline bool operator==(const Token &amp;left, const Token &amp;right) { if(left.m_type == right.m_type) { switch(left.m_type) { case Interpreter::TokenType::Operator: return left.m_operator == right.m_operator; case Interpreter::TokenType::Number: return left.m_number == right.m_number; default: throw std::out_of_range("TokenType"); } } return false; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: throw std::out_of_range("TokenType"); } } typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); } } // namespace Lexer } // namespace Interpreter</code> <br> <br> <b class="spoiler_title">InterpreterTests.cpp</b> <code class="cpp">#include "stdafx.h" #include "CppUnitTest.h" #include "Interpreter.h" namespace InterpreterTests { using namespace Microsoft::VisualStudio::CppUnitTestFramework; using namespace Interpreter; using namespace std; namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual&lt;T&gt;(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange TEST_CLASS(LexerTests) { public: TEST_METHOD(Should_return_empty_token_list_when_put_empty_expression) { Tokens tokens = Lexer::Tokenize(L""); Assert::IsTrue(tokens.empty()); } TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); } TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); } TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); } TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); } }; TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); } TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); } TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); } }; }</code> <br> <br> <a href="https://github.com/Unril/InterpreterTDD/releases/tag/%25D0%259A%25D0%25BE%25D0%25BD%25D0%25B5%25D1%2586_%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B2%25D0%25BE%25D0%25B9_%25D1%2587%25D0%25B0%25D1%2581%25D1%2582%25D0%25B8">    GitHub</a> .         ,  .      "__". <br> <br>   <a href="http://habrahabr.ru/post/232081/">    </a> .      ,      <a href="http://habrahabr.ru/post/232097/">    </a> .</code> <pre> <code class="hljs lua"><code>std::vector,      Tokens</code> .            . <br> <br> <code class="cpp">#pragma once; #include &lt;vector&gt; namespace Interpreter { struct Token {}; typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { inline Tokens Tokenize(std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> expr) { throw std::exception(); } } // namespace Lexer } // namespace Interpreter</code> <br>   ,  ,   , .   ,    ,    <a href="http://cleancoder.posterous.com/the-transformation-priority-premise">The Transformation Priority Premise (TPP)</a>   .    , ,    ,     ,        .            .     ,     ,      ,           .  ,  ,   (   )    ,  ,  .     ,  ,         .     ,   TPP          . <br> <br>   : <br> <br> ({} ‚Üí <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)     ,   . (<span class="hljs-literal"><span class="hljs-literal">nil</span></span> ‚Üí constant)    . (constant ‚Üí constant+)      (        ,  ). (constant ‚Üí scalar)    ,  . (statement ‚Üí statements)    (<span class="hljs-keyword"><span class="hljs-keyword">break</span></span>, continue, <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>  ). (unconditional ‚Üí <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>)       . (scalar ‚Üí array)  / . (array ‚Üí container)     . (statement ‚Üí recursion)   . (<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ‚Üí <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>)    . (expression ‚Üí <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">)</span></span>   . (variable ‚Üí assignment)   . <br>        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> expr) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{}; }</code> <br> ,         .     . <br> <br> <s>         </s> .           .           .               .            .       . <br>  ,  <code>std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span></code>  <code>std::wstring</code> .         ,      Unicode.     . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"+"</span></span>); AssertRange::AreEqual({ Operator::Plus }, tokens); }</code> <br>  <code>AssertRange</code> -   ,       <code>AreEqual</code> ,   ,  ,    . <br> <br> <b class="spoiler_title">AssertRange</b> <code class="cpp">namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(expect)), distance(actualIter, <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(actual)), L<span class="hljs-string"><span class="hljs-string">"Size differs."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(; expectIter != <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(expect) &amp;&amp; actualIter != <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(actual); ++expectIter, ++actualIter) { auto message = L<span class="hljs-string"><span class="hljs-string">"Mismatch in position "</span></span> + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange</code> <br> <br>         <code>Operator</code>    .          <code>wchar_t</code>   ,         ,      . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L<span class="hljs-string"><span class="hljs-string">'+'</span></span>, }; typedef Operator Token;</code> <br>    ,   ,        <code>Assert</code> ,    <code>ToString</code> ,    . <br> <br> <b class="spoiler_title">std::wstring ToString(const Token &amp;)</b> <code class="cpp">inline std::wstring ToString(const Token &amp;token) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ static_cast&lt;wchar_t&gt;(token) }; }</code> <br> <br>    ,   ,        .  ,   (unconditional ‚Üí <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>). <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(expr.empty()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{}; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ static_cast&lt;Operator&gt;(expr[<span class="hljs-number"><span class="hljs-number">0</span></span>]) }; }</code> <br> <s>         </s> . <s>          .</s>           . ‚Ä¶ <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"1"</span></span>); AssertRange::AreEqual({ <span class="hljs-number"><span class="hljs-number">1.0</span></span> }, tokens); }</code> <br>     .   ,     ,   - .    , : <br> <br>        ,      <code>Token</code> .       <code>dynamic_cast</code>    ,   .  ,    ,      .      <code>std::<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span></span></code><span class="hljs-function"><span class="hljs-function">        .        .  </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Boost.Any</span></span></span><span class="hljs-function">,  - .            . </span></span><br><span class="hljs-function"><span class="hljs-function">   ,   .      -  .  ,      ,      . </span></span><br><span class="hljs-function"><span class="hljs-function"> </span></span><br><span class="hljs-function"><span class="hljs-function"> ‚Ä¶        .        .        .        . </span></span><br><span class="hljs-function"><span class="hljs-function">             . </span></span><br><span class="hljs-function"><span class="hljs-function"> </span></span><br><span class="hljs-function"><span class="hljs-function"> </span></span><code class="cpp"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">enum</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">class</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TokenType</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Operator</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Number</span></span></span><span class="hljs-function"> }; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">class</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Token</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">public</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Token</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Operator)</span></span></span></span> {} TokenType Type() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TokenType::Operator; } }; ‚Ä¶ TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } };</code> <br>   <code>ToString</code>   <code>TokenType</code>       ,   ,   .     . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_type_for_number_token) { Token numToken(<span class="hljs-number"><span class="hljs-number">1.2</span></span>); Assert::AreEqual(TokenType::Number, numToken.Type()); }</code> <br>   .   (constant ‚Üí scalar)   . <br> <br> <code class="cpp">class Token { public: Token(Operator) :m_type(TokenType::Operator) {} Token(double) :m_type(TokenType::Number) {} TokenType Type() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_type; } private: TokenType m_type; };</code> <br> ‚Ä¶ <s>       </s> . <s>       </s> .        .        . <br>    . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); }</code> <br>            . <br> <br> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} operator Operator() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_operator; } ‚Ä¶ Operator m_operator; };</code> <br>      . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_number_value_from_number_token) { Token token(<span class="hljs-number"><span class="hljs-number">1.23</span></span>); Assert::AreEqual&lt;double&gt;(<span class="hljs-number"><span class="hljs-number">1.23</span></span>, token); }</code> <br>          ,  ,       <code>union</code> .         . <br> <br> <b class="spoiler_title">Token</b> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_type; } operator Operator() const { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(m_type != TokenType::Operator) throw std::logic_error(<span class="hljs-string"><span class="hljs-string">"Should be operator token."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_operator; } operator double() const { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(m_type != TokenType::Number) throw std::logic_error(<span class="hljs-string"><span class="hljs-string">"Should be number token."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_number; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ToString(static_cast&lt;Operator&gt;(token)); default: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Unknown token."</span></span>; } }</code> <br> <br>  ,    ,      ,    .       .    . <br> <br> <i>          .</i>               .            .       . <br>        : <br> <br> <code class="cpp"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(expr[<span class="hljs-number"><span class="hljs-number">0</span></span>] &gt;= <span class="hljs-string"><span class="hljs-string">'0'</span></span> &amp;&amp; expr[<span class="hljs-number"><span class="hljs-number">0</span></span>] &lt;= <span class="hljs-string"><span class="hljs-string">'9'</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ (double) expr[<span class="hljs-number"><span class="hljs-number">0</span></span>] - <span class="hljs-string"><span class="hljs-string">'0'</span></span> }; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ static_cast&lt;Operator&gt;(expr[<span class="hljs-number"><span class="hljs-number">0</span></span>]) };</code> <br>      ,   . <br> <br> ‚Ä¶ <s>          .</s> <i>              .</i> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"12.34"</span></span>); AssertRange::AreEqual({ <span class="hljs-number"><span class="hljs-number">12.34</span></span> }, tokens); }</code> <br> ,     <code>C</code>   ,  <code>isdigit</code> , ,       <code>atof</code> ,    ,      <code>wchar_t</code> .  (expression ‚Üí <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">)</span></span>.         . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { const wchar_t *current = expr.c_str(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!*current) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{}; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(iswdigit(*current)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ _wtof(current) }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ static_cast&lt;Operator&gt;(*current) }; }</code> <br>         .      . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"+12.34"</span></span>); AssertRange::AreEqual({ Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">12.34</span></span>) }, tokens); }</code> <br>   ,        .  ,     .     .   <code>result</code> ,     . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!*current) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(iswdigit(*current)) { result.push_back(_wtof(current)); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { result.push_back(static_cast&lt;Operator&gt;(*current)); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> <br>      :   (<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ‚Üí <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>).     ,        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(*current) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(iswdigit(*current)) { wchar_t *<span class="hljs-keyword"><span class="hljs-keyword">end</span></span> = nullptr; result.push_back(wcstod(current, &amp;<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>)); current = <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> <br>  <code>wcstod</code>    ,   <code>_wtof</code> ,           .           ,              .  ,    . <br> <br> <s>           .</s>       . <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">" 1 + 12.34 "</span></span>); AssertRange::AreEqual({ Token(<span class="hljs-number"><span class="hljs-number">1.0</span></span>), Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">12.34</span></span>) }, tokens); }</code> <br>  (unconditional ‚Üí <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>)    ,    . <br> <br> <code class="cpp"> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(*current) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(iswdigit(*current)) { wchar_t *<span class="hljs-keyword"><span class="hljs-keyword">end</span></span> = nullptr; result.push_back(wcstod(current, &amp;<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>)); current = <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(*current == static_cast&lt;wchar_t&gt;(Operator::Plus)) { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { ++current; } }</code> <br>       .          .       <code>Detail</code>      .   <code>Tokenize</code>       . <br> <br> <code class="cpp">inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tokenizer.Result(); }</code> <br> <b class="spoiler_title"> Detail::Tokenizer</b> <code class="cpp">namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!EndOfExperssion()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(IsNumber()) { ScanNumber(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(IsOperator()) { ScanOperator(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { MoveNext(); } } } const Tokens &amp;Result() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_result; } private: bool EndOfExperssion() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_current == L<span class="hljs-string"><span class="hljs-string">'\0'</span></span>; } bool IsNumber() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> iswdigit(*m_current) != <span class="hljs-number"><span class="hljs-number">0</span></span>; } void ScanNumber() { wchar_t *<span class="hljs-keyword"><span class="hljs-keyword">end</span></span> = nullptr; m_result.push_back(wcstod(m_current, &amp;<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>)); m_current = <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; } bool IsOperator() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_current == static_cast&lt;wchar_t&gt;(Operator::Plus); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail</code> <br> <br>  ,      .      ,  , .       . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"1+2*3/(4-5)"</span></span>); AssertRange::AreEqual({ Token(<span class="hljs-number"><span class="hljs-number">1</span></span>), Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">2</span></span>), Token(Operator::Mul), Token(<span class="hljs-number"><span class="hljs-number">3</span></span>), Token(Operator::Div), Token(Operator::LParen), Token(<span class="hljs-number"><span class="hljs-number">4</span></span>), Token(Operator::Minus), Token(<span class="hljs-number"><span class="hljs-number">5</span></span>), Token(Operator::RParen) }, tokens); }</code> <br>      <code>Operator</code> ,    . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L<span class="hljs-string"><span class="hljs-string">'+'</span></span>, Minus = L<span class="hljs-string"><span class="hljs-string">'-'</span></span>, Mul = L<span class="hljs-string"><span class="hljs-string">'*'</span></span>, Div = L<span class="hljs-string"><span class="hljs-string">'/'</span></span>, LParen = L<span class="hljs-string"><span class="hljs-string">'('</span></span>, RParen = L<span class="hljs-string"><span class="hljs-string">')'</span></span>, };</code> <br>   .         <code>IsOperator</code>  <code>Tokenizer</code> . <br> <br> <code class="cpp"> bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> std::any_of(all.begin(), all.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(), [this](Operator o) {<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_current == static_cast&lt;wchar_t&gt;(o); }); }</code> <br>         .        . <br> <br> <b class="spoiler_title">Interpreter.h</b> <code class="cpp">#pragma once; #include &lt;vector&gt; #include &lt;wchar.h&gt; #include &lt;algorithm&gt; namespace Interpreter { enum class Operator : wchar_t { Plus = L<span class="hljs-string"><span class="hljs-string">'+'</span></span>, Minus = L<span class="hljs-string"><span class="hljs-string">'-'</span></span>, Mul = L<span class="hljs-string"><span class="hljs-string">'*'</span></span>, Div = L<span class="hljs-string"><span class="hljs-string">'/'</span></span>, LParen = L<span class="hljs-string"><span class="hljs-string">'('</span></span>, RParen = L<span class="hljs-string"><span class="hljs-string">')'</span></span>, }; inline std::wstring ToString(const Operator &amp;op) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ static_cast&lt;wchar_t&gt;(op) }; } enum class TokenType { Operator, Number }; inline std::wstring ToString(const TokenType &amp;<span class="hljs-built_in"><span class="hljs-built_in">type</span></span>) { switch(<span class="hljs-built_in"><span class="hljs-built_in">type</span></span>) { case TokenType::Operator: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> L<span class="hljs-string"><span class="hljs-string">"Operator"</span></span>; case TokenType::Number: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> L<span class="hljs-string"><span class="hljs-string">"Number"</span></span>; default: throw std::out_of_range(<span class="hljs-string"><span class="hljs-string">"TokenType"</span></span>); } } class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_type; } operator Operator() const { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(m_type != TokenType::Operator) throw std::logic_error(<span class="hljs-string"><span class="hljs-string">"Should be operator token."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_operator; } operator double() const { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(m_type != TokenType::Number) throw std::logic_error(<span class="hljs-string"><span class="hljs-string">"Should be number token."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_number; } friend inline bool operator==(const Token &amp;left, const Token &amp;right) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(left.m_type == right.m_type) { switch(left.m_type) { case Interpreter::TokenType::Operator: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> left.m_operator == right.m_operator; case Interpreter::TokenType::Number: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> left.m_number == right.m_number; default: throw std::out_of_range(<span class="hljs-string"><span class="hljs-string">"TokenType"</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ToString(static_cast&lt;Operator&gt;(token)); default: throw std::out_of_range(<span class="hljs-string"><span class="hljs-string">"TokenType"</span></span>); } } typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!EndOfExperssion()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(IsNumber()) { ScanNumber(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(IsOperator()) { ScanOperator(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { MoveNext(); } } } const Tokens &amp;Result() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_result; } private: bool EndOfExperssion() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_current == L<span class="hljs-string"><span class="hljs-string">'\0'</span></span>; } bool IsNumber() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> iswdigit(*m_current) != <span class="hljs-number"><span class="hljs-number">0</span></span>; } void ScanNumber() { wchar_t *<span class="hljs-keyword"><span class="hljs-keyword">end</span></span> = nullptr; m_result.push_back(wcstod(m_current, &amp;<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>)); m_current = <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; } bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> std::any_of(all.begin(), all.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(), [this](Operator o) {<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_current == static_cast&lt;wchar_t&gt;(o); }); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tokenizer.Result(); } } // namespace Lexer } // namespace Interpreter</code> <br> <br> <b class="spoiler_title">InterpreterTests.cpp</b> <code class="cpp">#include <span class="hljs-string"><span class="hljs-string">"stdafx.h"</span></span> #include <span class="hljs-string"><span class="hljs-string">"CppUnitTest.h"</span></span> #include <span class="hljs-string"><span class="hljs-string">"Interpreter.h"</span></span> namespace InterpreterTests { using namespace Microsoft::VisualStudio::CppUnitTestFramework; using namespace Interpreter; using namespace std; namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(expect)), distance(actualIter, <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(actual)), L<span class="hljs-string"><span class="hljs-string">"Size differs."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(; expectIter != <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(expect) &amp;&amp; actualIter != <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(actual); ++expectIter, ++actualIter) { auto message = L<span class="hljs-string"><span class="hljs-string">"Mismatch in position "</span></span> + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual&lt;T&gt;(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange TEST_CLASS(LexerTests) { public: TEST_METHOD(Should_return_empty_token_list_when_put_empty_expression) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">""</span></span>); Assert::IsTrue(tokens.empty()); } TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"+"</span></span>); AssertRange::AreEqual({ Operator::Plus }, tokens); } TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"1"</span></span>); AssertRange::AreEqual({ <span class="hljs-number"><span class="hljs-number">1.0</span></span> }, tokens); } TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"12.34"</span></span>); AssertRange::AreEqual({ <span class="hljs-number"><span class="hljs-number">12.34</span></span> }, tokens); } TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"+12.34"</span></span>); AssertRange::AreEqual({ Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">12.34</span></span>) }, tokens); } TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">" 1 + 12.34 "</span></span>); AssertRange::AreEqual({ Token(<span class="hljs-number"><span class="hljs-number">1.0</span></span>), Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">12.34</span></span>) }, tokens); } TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"1+2*3/(4-5)"</span></span>); AssertRange::AreEqual({ Token(<span class="hljs-number"><span class="hljs-number">1</span></span>), Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">2</span></span>), Token(Operator::Mul), Token(<span class="hljs-number"><span class="hljs-number">3</span></span>), Token(Operator::Div), Token(Operator::LParen), Token(<span class="hljs-number"><span class="hljs-number">4</span></span>), Token(Operator::Minus), Token(<span class="hljs-number"><span class="hljs-number">5</span></span>), Token(Operator::RParen) }, tokens); } }; TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } TEST_METHOD(Should_get_type_for_number_token) { Token numToken(<span class="hljs-number"><span class="hljs-number">1.2</span></span>); Assert::AreEqual(TokenType::Number, numToken.Type()); } TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); } TEST_METHOD(Should_get_number_value_from_number_token) { Token token(<span class="hljs-number"><span class="hljs-number">1.23</span></span>); Assert::AreEqual&lt;double&gt;(<span class="hljs-number"><span class="hljs-number">1.23</span></span>, token); } }; }</code> <br> <br> <a href="https://github.com/Unril/InterpreterTDD/releases/tag/%25D0%259A%25D0%25BE%25D0%25BD%25D0%25B5%25D1%2586_%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B2%25D0%25BE%25D0%25B9_%25D1%2587%25D0%25B0%25D1%2581%25D1%2582%25D0%25B8">    GitHub</a> .         ,  .      <span class="hljs-string"><span class="hljs-string">"__"</span></span>. <br> <br>   <a href="http://habrahabr.ru/post/232081/">    </a> .      ,      <a href="http://habrahabr.ru/post/232097/">    </a> .</code> </pre> <code><code>std::vector,      Tokens</code> .            . <br> <br> <code class="cpp">#pragma once; #include &lt;vector&gt; namespace Interpreter { struct Token {}; typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { inline Tokens Tokenize(std::string expr) { throw std::exception(); } } // namespace Lexer } // namespace Interpreter</code> <br>   ,  ,   , .   ,    ,    <a href="http://cleancoder.posterous.com/the-transformation-priority-premise">The Transformation Priority Premise (TPP)</a>   .    , ,    ,     ,        .            .     ,     ,      ,           .  ,  ,   (   )    ,  ,  .     ,  ,         .     ,   TPP          . <br> <br>   : <br> <br> ({} ‚Üí nil)     ,   . (nil ‚Üí constant)    . (constant ‚Üí constant+)      (        ,  ). (constant ‚Üí scalar)    ,  . (statement ‚Üí statements)    (break, continue, return  ). (unconditional ‚Üí if)       . (scalar ‚Üí array)  / . (array ‚Üí container)     . (statement ‚Üí recursion)   . (if ‚Üí while)    . (expression ‚Üí function)   . (variable ‚Üí assignment)   . <br>        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::string expr) { return{}; }</code> <br> ,         .     . <br> <br> <s>         </s> .           .           .               .            .       . <br>  ,  <code>std::string</code>  <code>std::wstring</code> .         ,      Unicode.     . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); }</code> <br>  <code>AssertRange</code> -   ,       <code>AreEqual</code> ,   ,  ,    . <br> <br> <b class="spoiler_title">AssertRange</b> <code class="cpp">namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange</code> <br> <br>         <code>Operator</code>    .          <code>wchar_t</code>   ,         ,      . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', }; typedef Operator Token;</code> <br>    ,   ,        <code>Assert</code> ,    <code>ToString</code> ,    . <br> <br> <b class="spoiler_title">std::wstring ToString(const Token &amp;)</b> <code class="cpp">inline std::wstring ToString(const Token &amp;token) { return{ static_cast&lt;wchar_t&gt;(token) }; }</code> <br> <br>    ,   ,        .  ,   (unconditional ‚Üí if). <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { if(expr.empty()) { return{}; } return{ static_cast&lt;Operator&gt;(expr[0]) }; }</code> <br> <s>         </s> . <s>          .</s>           . ‚Ä¶ <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); }</code> <br>     .   ,     ,   - .    , : <br> <br>        ,      <code>Token</code> .       <code>dynamic_cast</code>    ,   .  ,    ,      .      <code>std::function</code>        .        .  Boost.Any,  - .            . <br>   ,   .      -  .  ,      ,      . <br> <br> ‚Ä¶        .        .        .        . <br>             . <br> <br> <code class="cpp">enum class TokenType { Operator, Number }; class Token { public: Token(Operator) {} TokenType Type() const { return TokenType::Operator; } }; ‚Ä¶ TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } };</code> <br>   <code>ToString</code>   <code>TokenType</code>       ,   ,   .     . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); }</code> <br>   .   (constant ‚Üí scalar)   . <br> <br> <code class="cpp">class Token { public: Token(Operator) :m_type(TokenType::Operator) {} Token(double) :m_type(TokenType::Number) {} TokenType Type() const { return m_type; } private: TokenType m_type; };</code> <br> ‚Ä¶ <s>       </s> . <s>       </s> .        .        . <br>    . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); }</code> <br>            . <br> <br> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} operator Operator() const { return m_operator; } ‚Ä¶ Operator m_operator; };</code> <br>      . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); }</code> <br>          ,  ,       <code>union</code> .         . <br> <br> <b class="spoiler_title">Token</b> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: return "Unknown token."; } }</code> <br> <br>  ,    ,      ,    .       .    . <br> <br> <i>          .</i>               .            .       . <br>        : <br> <br> <code class="cpp"> if(expr[0] &gt;= '0' &amp;&amp; expr[0] &lt;= '9') { return{ (double) expr[0] - '0' }; } return{ static_cast&lt;Operator&gt;(expr[0]) };</code> <br>      ,   . <br> <br> ‚Ä¶ <s>          .</s> <i>              .</i> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); }</code> <br> ,     <code>C</code>   ,  <code>isdigit</code> , ,       <code>atof</code> ,    ,      <code>wchar_t</code> .  (expression ‚Üí function).         . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { const wchar_t *current = expr.c_str(); if(!*current) return{}; if(iswdigit(*current)) return{ _wtof(current) }; return{ static_cast&lt;Operator&gt;(*current) }; }</code> <br>         .      . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>   ,        .  ,     .     .   <code>result</code> ,     . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); if(!*current) return result; if(iswdigit(*current)) { result.push_back(_wtof(current)); } else { result.push_back(static_cast&lt;Operator&gt;(*current)); } return result; }</code> <br>      :   (if ‚Üí while).     ,        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } } return result; }</code> <br>  <code>wcstod</code>    ,   <code>_wtof</code> ,           .           ,              .  ,    . <br> <br> <s>           .</s>       . <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>  (unconditional ‚Üí if)    ,    . <br> <br> <code class="cpp"> while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else if(*current == static_cast&lt;wchar_t&gt;(Operator::Plus)) { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } else { ++current; } }</code> <br>       .          .       <code>Detail</code>      .   <code>Tokenize</code>       . <br> <br> <code class="cpp">inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); }</code> <br> <b class="spoiler_title"> Detail::Tokenizer</b> <code class="cpp">namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { return *m_current == static_cast&lt;wchar_t&gt;(Operator::Plus); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail</code> <br> <br>  ,      .      ,  , .       . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); }</code> <br>      <code>Operator</code> ,    . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', };</code> <br>   .         <code>IsOperator</code>  <code>Tokenizer</code> . <br> <br> <code class="cpp"> bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); }</code> <br>         .        . <br> <br> <b class="spoiler_title">Interpreter.h</b> <code class="cpp">#pragma once; #include &lt;vector&gt; #include &lt;wchar.h&gt; #include &lt;algorithm&gt; namespace Interpreter { enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', }; inline std::wstring ToString(const Operator &amp;op) { return{ static_cast&lt;wchar_t&gt;(op) }; } enum class TokenType { Operator, Number }; inline std::wstring ToString(const TokenType &amp;type) { switch(type) { case TokenType::Operator: return L"Operator"; case TokenType::Number: return L"Number"; default: throw std::out_of_range("TokenType"); } } class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } friend inline bool operator==(const Token &amp;left, const Token &amp;right) { if(left.m_type == right.m_type) { switch(left.m_type) { case Interpreter::TokenType::Operator: return left.m_operator == right.m_operator; case Interpreter::TokenType::Number: return left.m_number == right.m_number; default: throw std::out_of_range("TokenType"); } } return false; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: throw std::out_of_range("TokenType"); } } typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); } } // namespace Lexer } // namespace Interpreter</code> <br> <br> <b class="spoiler_title">InterpreterTests.cpp</b> <code class="cpp">#include "stdafx.h" #include "CppUnitTest.h" #include "Interpreter.h" namespace InterpreterTests { using namespace Microsoft::VisualStudio::CppUnitTestFramework; using namespace Interpreter; using namespace std; namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual&lt;T&gt;(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange TEST_CLASS(LexerTests) { public: TEST_METHOD(Should_return_empty_token_list_when_put_empty_expression) { Tokens tokens = Lexer::Tokenize(L""); Assert::IsTrue(tokens.empty()); } TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); } TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); } TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); } TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); } }; TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); } TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); } TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); } }; }</code> <br> <br> <a href="https://github.com/Unril/InterpreterTDD/releases/tag/%25D0%259A%25D0%25BE%25D0%25BD%25D0%25B5%25D1%2586_%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B2%25D0%25BE%25D0%25B9_%25D1%2587%25D0%25B0%25D1%2581%25D1%2582%25D0%25B8">    GitHub</a> .         ,  .      "__". <br> <br>   <a href="http://habrahabr.ru/post/232081/">    </a> .      ,      <a href="http://habrahabr.ru/post/232097/">    </a> .</code> <pre> <code class="hljs lua"><code>std::vector,      Tokens</code> .            . <br> <br> <code class="cpp">#pragma once; #include &lt;vector&gt; namespace Interpreter { struct Token {}; typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { inline Tokens Tokenize(std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> expr) { throw std::exception(); } } // namespace Lexer } // namespace Interpreter</code> <br>   ,  ,   , .   ,    ,    <a href="http://cleancoder.posterous.com/the-transformation-priority-premise">The Transformation Priority Premise (TPP)</a>   .    , ,    ,     ,        .            .     ,     ,      ,           .  ,  ,   (   )    ,  ,  .     ,  ,         .     ,   TPP          . <br> <br>   : <br> <br> ({} ‚Üí <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)     ,   . (<span class="hljs-literal"><span class="hljs-literal">nil</span></span> ‚Üí constant)    . (constant ‚Üí constant+)      (        ,  ). (constant ‚Üí scalar)    ,  . (statement ‚Üí statements)    (<span class="hljs-keyword"><span class="hljs-keyword">break</span></span>, continue, <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>  ). (unconditional ‚Üí <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>)       . (scalar ‚Üí array)  / . (array ‚Üí container)     . (statement ‚Üí recursion)   . (<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ‚Üí <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>)    . (expression ‚Üí <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">)</span></span>   . (variable ‚Üí assignment)   . <br>        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> expr) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{}; }</code> <br> ,         .     . <br> <br> <s>         </s> .           .           .               .            .       . <br>  ,  <code>std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span></code>  <code>std::wstring</code> .         ,      Unicode.     . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"+"</span></span>); AssertRange::AreEqual({ Operator::Plus }, tokens); }</code> <br>  <code>AssertRange</code> -   ,       <code>AreEqual</code> ,   ,  ,    . <br> <br> <b class="spoiler_title">AssertRange</b> <code class="cpp">namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(expect)), distance(actualIter, <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(actual)), L<span class="hljs-string"><span class="hljs-string">"Size differs."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(; expectIter != <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(expect) &amp;&amp; actualIter != <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(actual); ++expectIter, ++actualIter) { auto message = L<span class="hljs-string"><span class="hljs-string">"Mismatch in position "</span></span> + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange</code> <br> <br>         <code>Operator</code>    .          <code>wchar_t</code>   ,         ,      . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L<span class="hljs-string"><span class="hljs-string">'+'</span></span>, }; typedef Operator Token;</code> <br>    ,   ,        <code>Assert</code> ,    <code>ToString</code> ,    . <br> <br> <b class="spoiler_title">std::wstring ToString(const Token &amp;)</b> <code class="cpp">inline std::wstring ToString(const Token &amp;token) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ static_cast&lt;wchar_t&gt;(token) }; }</code> <br> <br>    ,   ,        .  ,   (unconditional ‚Üí <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>). <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(expr.empty()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{}; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ static_cast&lt;Operator&gt;(expr[<span class="hljs-number"><span class="hljs-number">0</span></span>]) }; }</code> <br> <s>         </s> . <s>          .</s>           . ‚Ä¶ <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"1"</span></span>); AssertRange::AreEqual({ <span class="hljs-number"><span class="hljs-number">1.0</span></span> }, tokens); }</code> <br>     .   ,     ,   - .    , : <br> <br>        ,      <code>Token</code> .       <code>dynamic_cast</code>    ,   .  ,    ,      .      <code>std::<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span></span></code><span class="hljs-function"><span class="hljs-function">        .        .  </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Boost.Any</span></span></span><span class="hljs-function">,  - .            . </span></span><br><span class="hljs-function"><span class="hljs-function">   ,   .      -  .  ,      ,      . </span></span><br><span class="hljs-function"><span class="hljs-function"> </span></span><br><span class="hljs-function"><span class="hljs-function"> ‚Ä¶        .        .        .        . </span></span><br><span class="hljs-function"><span class="hljs-function">             . </span></span><br><span class="hljs-function"><span class="hljs-function"> </span></span><br><span class="hljs-function"><span class="hljs-function"> </span></span><code class="cpp"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">enum</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">class</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TokenType</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Operator</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Number</span></span></span><span class="hljs-function"> }; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">class</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Token</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">public</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Token</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Operator)</span></span></span></span> {} TokenType Type() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TokenType::Operator; } }; ‚Ä¶ TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } };</code> <br>   <code>ToString</code>   <code>TokenType</code>       ,   ,   .     . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_type_for_number_token) { Token numToken(<span class="hljs-number"><span class="hljs-number">1.2</span></span>); Assert::AreEqual(TokenType::Number, numToken.Type()); }</code> <br>   .   (constant ‚Üí scalar)   . <br> <br> <code class="cpp">class Token { public: Token(Operator) :m_type(TokenType::Operator) {} Token(double) :m_type(TokenType::Number) {} TokenType Type() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_type; } private: TokenType m_type; };</code> <br> ‚Ä¶ <s>       </s> . <s>       </s> .        .        . <br>    . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); }</code> <br>            . <br> <br> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} operator Operator() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_operator; } ‚Ä¶ Operator m_operator; };</code> <br>      . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_number_value_from_number_token) { Token token(<span class="hljs-number"><span class="hljs-number">1.23</span></span>); Assert::AreEqual&lt;double&gt;(<span class="hljs-number"><span class="hljs-number">1.23</span></span>, token); }</code> <br>          ,  ,       <code>union</code> .         . <br> <br> <b class="spoiler_title">Token</b> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_type; } operator Operator() const { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(m_type != TokenType::Operator) throw std::logic_error(<span class="hljs-string"><span class="hljs-string">"Should be operator token."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_operator; } operator double() const { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(m_type != TokenType::Number) throw std::logic_error(<span class="hljs-string"><span class="hljs-string">"Should be number token."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_number; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ToString(static_cast&lt;Operator&gt;(token)); default: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Unknown token."</span></span>; } }</code> <br> <br>  ,    ,      ,    .       .    . <br> <br> <i>          .</i>               .            .       . <br>        : <br> <br> <code class="cpp"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(expr[<span class="hljs-number"><span class="hljs-number">0</span></span>] &gt;= <span class="hljs-string"><span class="hljs-string">'0'</span></span> &amp;&amp; expr[<span class="hljs-number"><span class="hljs-number">0</span></span>] &lt;= <span class="hljs-string"><span class="hljs-string">'9'</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ (double) expr[<span class="hljs-number"><span class="hljs-number">0</span></span>] - <span class="hljs-string"><span class="hljs-string">'0'</span></span> }; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ static_cast&lt;Operator&gt;(expr[<span class="hljs-number"><span class="hljs-number">0</span></span>]) };</code> <br>      ,   . <br> <br> ‚Ä¶ <s>          .</s> <i>              .</i> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"12.34"</span></span>); AssertRange::AreEqual({ <span class="hljs-number"><span class="hljs-number">12.34</span></span> }, tokens); }</code> <br> ,     <code>C</code>   ,  <code>isdigit</code> , ,       <code>atof</code> ,    ,      <code>wchar_t</code> .  (expression ‚Üí <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">)</span></span>.         . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { const wchar_t *current = expr.c_str(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!*current) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{}; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(iswdigit(*current)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ _wtof(current) }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ static_cast&lt;Operator&gt;(*current) }; }</code> <br>         .      . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"+12.34"</span></span>); AssertRange::AreEqual({ Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">12.34</span></span>) }, tokens); }</code> <br>   ,        .  ,     .     .   <code>result</code> ,     . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!*current) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(iswdigit(*current)) { result.push_back(_wtof(current)); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { result.push_back(static_cast&lt;Operator&gt;(*current)); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> <br>      :   (<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ‚Üí <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>).     ,        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(*current) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(iswdigit(*current)) { wchar_t *<span class="hljs-keyword"><span class="hljs-keyword">end</span></span> = nullptr; result.push_back(wcstod(current, &amp;<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>)); current = <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> <br>  <code>wcstod</code>    ,   <code>_wtof</code> ,           .           ,              .  ,    . <br> <br> <s>           .</s>       . <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">" 1 + 12.34 "</span></span>); AssertRange::AreEqual({ Token(<span class="hljs-number"><span class="hljs-number">1.0</span></span>), Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">12.34</span></span>) }, tokens); }</code> <br>  (unconditional ‚Üí <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>)    ,    . <br> <br> <code class="cpp"> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(*current) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(iswdigit(*current)) { wchar_t *<span class="hljs-keyword"><span class="hljs-keyword">end</span></span> = nullptr; result.push_back(wcstod(current, &amp;<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>)); current = <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(*current == static_cast&lt;wchar_t&gt;(Operator::Plus)) { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { ++current; } }</code> <br>       .          .       <code>Detail</code>      .   <code>Tokenize</code>       . <br> <br> <code class="cpp">inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tokenizer.Result(); }</code> <br> <b class="spoiler_title"> Detail::Tokenizer</b> <code class="cpp">namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!EndOfExperssion()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(IsNumber()) { ScanNumber(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(IsOperator()) { ScanOperator(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { MoveNext(); } } } const Tokens &amp;Result() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_result; } private: bool EndOfExperssion() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_current == L<span class="hljs-string"><span class="hljs-string">'\0'</span></span>; } bool IsNumber() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> iswdigit(*m_current) != <span class="hljs-number"><span class="hljs-number">0</span></span>; } void ScanNumber() { wchar_t *<span class="hljs-keyword"><span class="hljs-keyword">end</span></span> = nullptr; m_result.push_back(wcstod(m_current, &amp;<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>)); m_current = <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; } bool IsOperator() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_current == static_cast&lt;wchar_t&gt;(Operator::Plus); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail</code> <br> <br>  ,      .      ,  , .       . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"1+2*3/(4-5)"</span></span>); AssertRange::AreEqual({ Token(<span class="hljs-number"><span class="hljs-number">1</span></span>), Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">2</span></span>), Token(Operator::Mul), Token(<span class="hljs-number"><span class="hljs-number">3</span></span>), Token(Operator::Div), Token(Operator::LParen), Token(<span class="hljs-number"><span class="hljs-number">4</span></span>), Token(Operator::Minus), Token(<span class="hljs-number"><span class="hljs-number">5</span></span>), Token(Operator::RParen) }, tokens); }</code> <br>      <code>Operator</code> ,    . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L<span class="hljs-string"><span class="hljs-string">'+'</span></span>, Minus = L<span class="hljs-string"><span class="hljs-string">'-'</span></span>, Mul = L<span class="hljs-string"><span class="hljs-string">'*'</span></span>, Div = L<span class="hljs-string"><span class="hljs-string">'/'</span></span>, LParen = L<span class="hljs-string"><span class="hljs-string">'('</span></span>, RParen = L<span class="hljs-string"><span class="hljs-string">')'</span></span>, };</code> <br>   .         <code>IsOperator</code>  <code>Tokenizer</code> . <br> <br> <code class="cpp"> bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> std::any_of(all.begin(), all.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(), [this](Operator o) {<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_current == static_cast&lt;wchar_t&gt;(o); }); }</code> <br>         .        . <br> <br> <b class="spoiler_title">Interpreter.h</b> <code class="cpp">#pragma once; #include &lt;vector&gt; #include &lt;wchar.h&gt; #include &lt;algorithm&gt; namespace Interpreter { enum class Operator : wchar_t { Plus = L<span class="hljs-string"><span class="hljs-string">'+'</span></span>, Minus = L<span class="hljs-string"><span class="hljs-string">'-'</span></span>, Mul = L<span class="hljs-string"><span class="hljs-string">'*'</span></span>, Div = L<span class="hljs-string"><span class="hljs-string">'/'</span></span>, LParen = L<span class="hljs-string"><span class="hljs-string">'('</span></span>, RParen = L<span class="hljs-string"><span class="hljs-string">')'</span></span>, }; inline std::wstring ToString(const Operator &amp;op) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ static_cast&lt;wchar_t&gt;(op) }; } enum class TokenType { Operator, Number }; inline std::wstring ToString(const TokenType &amp;<span class="hljs-built_in"><span class="hljs-built_in">type</span></span>) { switch(<span class="hljs-built_in"><span class="hljs-built_in">type</span></span>) { case TokenType::Operator: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> L<span class="hljs-string"><span class="hljs-string">"Operator"</span></span>; case TokenType::Number: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> L<span class="hljs-string"><span class="hljs-string">"Number"</span></span>; default: throw std::out_of_range(<span class="hljs-string"><span class="hljs-string">"TokenType"</span></span>); } } class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_type; } operator Operator() const { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(m_type != TokenType::Operator) throw std::logic_error(<span class="hljs-string"><span class="hljs-string">"Should be operator token."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_operator; } operator double() const { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(m_type != TokenType::Number) throw std::logic_error(<span class="hljs-string"><span class="hljs-string">"Should be number token."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_number; } friend inline bool operator==(const Token &amp;left, const Token &amp;right) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(left.m_type == right.m_type) { switch(left.m_type) { case Interpreter::TokenType::Operator: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> left.m_operator == right.m_operator; case Interpreter::TokenType::Number: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> left.m_number == right.m_number; default: throw std::out_of_range(<span class="hljs-string"><span class="hljs-string">"TokenType"</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ToString(static_cast&lt;Operator&gt;(token)); default: throw std::out_of_range(<span class="hljs-string"><span class="hljs-string">"TokenType"</span></span>); } } typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!EndOfExperssion()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(IsNumber()) { ScanNumber(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(IsOperator()) { ScanOperator(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { MoveNext(); } } } const Tokens &amp;Result() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_result; } private: bool EndOfExperssion() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_current == L<span class="hljs-string"><span class="hljs-string">'\0'</span></span>; } bool IsNumber() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> iswdigit(*m_current) != <span class="hljs-number"><span class="hljs-number">0</span></span>; } void ScanNumber() { wchar_t *<span class="hljs-keyword"><span class="hljs-keyword">end</span></span> = nullptr; m_result.push_back(wcstod(m_current, &amp;<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>)); m_current = <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; } bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> std::any_of(all.begin(), all.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(), [this](Operator o) {<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_current == static_cast&lt;wchar_t&gt;(o); }); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tokenizer.Result(); } } // namespace Lexer } // namespace Interpreter</code> <br> <br> <b class="spoiler_title">InterpreterTests.cpp</b> <code class="cpp">#include <span class="hljs-string"><span class="hljs-string">"stdafx.h"</span></span> #include <span class="hljs-string"><span class="hljs-string">"CppUnitTest.h"</span></span> #include <span class="hljs-string"><span class="hljs-string">"Interpreter.h"</span></span> namespace InterpreterTests { using namespace Microsoft::VisualStudio::CppUnitTestFramework; using namespace Interpreter; using namespace std; namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(expect)), distance(actualIter, <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(actual)), L<span class="hljs-string"><span class="hljs-string">"Size differs."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(; expectIter != <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(expect) &amp;&amp; actualIter != <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(actual); ++expectIter, ++actualIter) { auto message = L<span class="hljs-string"><span class="hljs-string">"Mismatch in position "</span></span> + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual&lt;T&gt;(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange TEST_CLASS(LexerTests) { public: TEST_METHOD(Should_return_empty_token_list_when_put_empty_expression) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">""</span></span>); Assert::IsTrue(tokens.empty()); } TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"+"</span></span>); AssertRange::AreEqual({ Operator::Plus }, tokens); } TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"1"</span></span>); AssertRange::AreEqual({ <span class="hljs-number"><span class="hljs-number">1.0</span></span> }, tokens); } TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"12.34"</span></span>); AssertRange::AreEqual({ <span class="hljs-number"><span class="hljs-number">12.34</span></span> }, tokens); } TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"+12.34"</span></span>); AssertRange::AreEqual({ Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">12.34</span></span>) }, tokens); } TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">" 1 + 12.34 "</span></span>); AssertRange::AreEqual({ Token(<span class="hljs-number"><span class="hljs-number">1.0</span></span>), Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">12.34</span></span>) }, tokens); } TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"1+2*3/(4-5)"</span></span>); AssertRange::AreEqual({ Token(<span class="hljs-number"><span class="hljs-number">1</span></span>), Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">2</span></span>), Token(Operator::Mul), Token(<span class="hljs-number"><span class="hljs-number">3</span></span>), Token(Operator::Div), Token(Operator::LParen), Token(<span class="hljs-number"><span class="hljs-number">4</span></span>), Token(Operator::Minus), Token(<span class="hljs-number"><span class="hljs-number">5</span></span>), Token(Operator::RParen) }, tokens); } }; TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } TEST_METHOD(Should_get_type_for_number_token) { Token numToken(<span class="hljs-number"><span class="hljs-number">1.2</span></span>); Assert::AreEqual(TokenType::Number, numToken.Type()); } TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); } TEST_METHOD(Should_get_number_value_from_number_token) { Token token(<span class="hljs-number"><span class="hljs-number">1.23</span></span>); Assert::AreEqual&lt;double&gt;(<span class="hljs-number"><span class="hljs-number">1.23</span></span>, token); } }; }</code> <br> <br> <a href="https://github.com/Unril/InterpreterTDD/releases/tag/%25D0%259A%25D0%25BE%25D0%25BD%25D0%25B5%25D1%2586_%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B2%25D0%25BE%25D0%25B9_%25D1%2587%25D0%25B0%25D1%2581%25D1%2582%25D0%25B8">    GitHub</a> .         ,  .      <span class="hljs-string"><span class="hljs-string">"__"</span></span>. <br> <br>   <a href="http://habrahabr.ru/post/232081/">    </a> .      ,      <a href="http://habrahabr.ru/post/232097/">    </a> .</code> </pre> <code><code>std::vector,      Tokens</code> .            . <br> <br> <code class="cpp">#pragma once; #include &lt;vector&gt; namespace Interpreter { struct Token {}; typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { inline Tokens Tokenize(std::string expr) { throw std::exception(); } } // namespace Lexer } // namespace Interpreter</code> <br>   ,  ,   , .   ,    ,    <a href="http://cleancoder.posterous.com/the-transformation-priority-premise">The Transformation Priority Premise (TPP)</a>   .    , ,    ,     ,        .            .     ,     ,      ,           .  ,  ,   (   )    ,  ,  .     ,  ,         .     ,   TPP          . <br> <br>   : <br> <br> ({} ‚Üí nil)     ,   . (nil ‚Üí constant)    . (constant ‚Üí constant+)      (        ,  ). (constant ‚Üí scalar)    ,  . (statement ‚Üí statements)    (break, continue, return  ). (unconditional ‚Üí if)       . (scalar ‚Üí array)  / . (array ‚Üí container)     . (statement ‚Üí recursion)   . (if ‚Üí while)    . (expression ‚Üí function)   . (variable ‚Üí assignment)   . <br>        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::string expr) { return{}; }</code> <br> ,         .     . <br> <br> <s>         </s> .           .           .               .            .       . <br>  ,  <code>std::string</code>  <code>std::wstring</code> .         ,      Unicode.     . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); }</code> <br>  <code>AssertRange</code> -   ,       <code>AreEqual</code> ,   ,  ,    . <br> <br> <b class="spoiler_title">AssertRange</b> <code class="cpp">namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange</code> <br> <br>         <code>Operator</code>    .          <code>wchar_t</code>   ,         ,      . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', }; typedef Operator Token;</code> <br>    ,   ,        <code>Assert</code> ,    <code>ToString</code> ,    . <br> <br> <b class="spoiler_title">std::wstring ToString(const Token &amp;)</b> <code class="cpp">inline std::wstring ToString(const Token &amp;token) { return{ static_cast&lt;wchar_t&gt;(token) }; }</code> <br> <br>    ,   ,        .  ,   (unconditional ‚Üí if). <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { if(expr.empty()) { return{}; } return{ static_cast&lt;Operator&gt;(expr[0]) }; }</code> <br> <s>         </s> . <s>          .</s>           . ‚Ä¶ <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); }</code> <br>     .   ,     ,   - .    , : <br> <br>        ,      <code>Token</code> .       <code>dynamic_cast</code>    ,   .  ,    ,      .      <code>std::function</code>        .        .  Boost.Any,  - .            . <br>   ,   .      -  .  ,      ,      . <br> <br> ‚Ä¶        .        .        .        . <br>             . <br> <br> <code class="cpp">enum class TokenType { Operator, Number }; class Token { public: Token(Operator) {} TokenType Type() const { return TokenType::Operator; } }; ‚Ä¶ TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } };</code> <br>   <code>ToString</code>   <code>TokenType</code>       ,   ,   .     . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); }</code> <br>   .   (constant ‚Üí scalar)   . <br> <br> <code class="cpp">class Token { public: Token(Operator) :m_type(TokenType::Operator) {} Token(double) :m_type(TokenType::Number) {} TokenType Type() const { return m_type; } private: TokenType m_type; };</code> <br> ‚Ä¶ <s>       </s> . <s>       </s> .        .        . <br>    . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); }</code> <br>            . <br> <br> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} operator Operator() const { return m_operator; } ‚Ä¶ Operator m_operator; };</code> <br>      . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); }</code> <br>          ,  ,       <code>union</code> .         . <br> <br> <b class="spoiler_title">Token</b> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: return "Unknown token."; } }</code> <br> <br>  ,    ,      ,    .       .    . <br> <br> <i>          .</i>               .            .       . <br>        : <br> <br> <code class="cpp"> if(expr[0] &gt;= '0' &amp;&amp; expr[0] &lt;= '9') { return{ (double) expr[0] - '0' }; } return{ static_cast&lt;Operator&gt;(expr[0]) };</code> <br>      ,   . <br> <br> ‚Ä¶ <s>          .</s> <i>              .</i> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); }</code> <br> ,     <code>C</code>   ,  <code>isdigit</code> , ,       <code>atof</code> ,    ,      <code>wchar_t</code> .  (expression ‚Üí function).         . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { const wchar_t *current = expr.c_str(); if(!*current) return{}; if(iswdigit(*current)) return{ _wtof(current) }; return{ static_cast&lt;Operator&gt;(*current) }; }</code> <br>         .      . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>   ,        .  ,     .     .   <code>result</code> ,     . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); if(!*current) return result; if(iswdigit(*current)) { result.push_back(_wtof(current)); } else { result.push_back(static_cast&lt;Operator&gt;(*current)); } return result; }</code> <br>      :   (if ‚Üí while).     ,        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } } return result; }</code> <br>  <code>wcstod</code>    ,   <code>_wtof</code> ,           .           ,              .  ,    . <br> <br> <s>           .</s>       . <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>  (unconditional ‚Üí if)    ,    . <br> <br> <code class="cpp"> while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else if(*current == static_cast&lt;wchar_t&gt;(Operator::Plus)) { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } else { ++current; } }</code> <br>       .          .       <code>Detail</code>      .   <code>Tokenize</code>       . <br> <br> <code class="cpp">inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); }</code> <br> <b class="spoiler_title"> Detail::Tokenizer</b> <code class="cpp">namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { return *m_current == static_cast&lt;wchar_t&gt;(Operator::Plus); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail</code> <br> <br>  ,      .      ,  , .       . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); }</code> <br>      <code>Operator</code> ,    . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', };</code> <br>   .         <code>IsOperator</code>  <code>Tokenizer</code> . <br> <br> <code class="cpp"> bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); }</code> <br>         .        . <br> <br> <b class="spoiler_title">Interpreter.h</b> <code class="cpp">#pragma once; #include &lt;vector&gt; #include &lt;wchar.h&gt; #include &lt;algorithm&gt; namespace Interpreter { enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', }; inline std::wstring ToString(const Operator &amp;op) { return{ static_cast&lt;wchar_t&gt;(op) }; } enum class TokenType { Operator, Number }; inline std::wstring ToString(const TokenType &amp;type) { switch(type) { case TokenType::Operator: return L"Operator"; case TokenType::Number: return L"Number"; default: throw std::out_of_range("TokenType"); } } class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } friend inline bool operator==(const Token &amp;left, const Token &amp;right) { if(left.m_type == right.m_type) { switch(left.m_type) { case Interpreter::TokenType::Operator: return left.m_operator == right.m_operator; case Interpreter::TokenType::Number: return left.m_number == right.m_number; default: throw std::out_of_range("TokenType"); } } return false; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: throw std::out_of_range("TokenType"); } } typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); } } // namespace Lexer } // namespace Interpreter</code> <br> <br> <b class="spoiler_title">InterpreterTests.cpp</b> <code class="cpp">#include "stdafx.h" #include "CppUnitTest.h" #include "Interpreter.h" namespace InterpreterTests { using namespace Microsoft::VisualStudio::CppUnitTestFramework; using namespace Interpreter; using namespace std; namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual&lt;T&gt;(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange TEST_CLASS(LexerTests) { public: TEST_METHOD(Should_return_empty_token_list_when_put_empty_expression) { Tokens tokens = Lexer::Tokenize(L""); Assert::IsTrue(tokens.empty()); } TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); } TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); } TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); } TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); } }; TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); } TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); } TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); } }; }</code> <br> <br> <a href="https://github.com/Unril/InterpreterTDD/releases/tag/%25D0%259A%25D0%25BE%25D0%25BD%25D0%25B5%25D1%2586_%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B2%25D0%25BE%25D0%25B9_%25D1%2587%25D0%25B0%25D1%2581%25D1%2582%25D0%25B8">    GitHub</a> .         ,  .      "__". <br> <br>   <a href="http://habrahabr.ru/post/232081/">    </a> .      ,      <a href="http://habrahabr.ru/post/232097/">    </a> .</code> <div class="spoiler"> <code><b class="spoiler_title"><code>std::vector,      Tokens</code> .            . <br> <br> <code class="cpp">#pragma once; #include &lt;vector&gt; namespace Interpreter { struct Token {}; typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { inline Tokens Tokenize(std::string expr) { throw std::exception(); } } // namespace Lexer } // namespace Interpreter</code> <br>   ,  ,   , .   ,    ,    <a href="http://cleancoder.posterous.com/the-transformation-priority-premise">The Transformation Priority Premise (TPP)</a>   .    , ,    ,     ,        .            .     ,     ,      ,           .  ,  ,   (   )    ,  ,  .     ,  ,         .     ,   TPP          . <br> <br>   : <br> <br> ({} ‚Üí nil)     ,   . (nil ‚Üí constant)    . (constant ‚Üí constant+)      (        ,  ). (constant ‚Üí scalar)    ,  . (statement ‚Üí statements)    (break, continue, return  ). (unconditional ‚Üí if)       . (scalar ‚Üí array)  / . (array ‚Üí container)     . (statement ‚Üí recursion)   . (if ‚Üí while)    . (expression ‚Üí function)   . (variable ‚Üí assignment)   . <br>        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::string expr) { return{}; }</code> <br> ,         .     . <br> <br> <s>         </s> .           .           .               .            .       . <br>  ,  <code>std::string</code>  <code>std::wstring</code> .         ,      Unicode.     . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); }</code> <br>  <code>AssertRange</code> -   ,       <code>AreEqual</code> ,   ,  ,    . <br> <br> <b class="spoiler_title">AssertRange</b> <code class="cpp">namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange</code> <br> <br>         <code>Operator</code>    .          <code>wchar_t</code>   ,         ,      . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', }; typedef Operator Token;</code> <br>    ,   ,        <code>Assert</code> ,    <code>ToString</code> ,    . <br> <br> <b class="spoiler_title">std::wstring ToString(const Token &amp;)</b> <code class="cpp">inline std::wstring ToString(const Token &amp;token) { return{ static_cast&lt;wchar_t&gt;(token) }; }</code> <br> <br>    ,   ,        .  ,   (unconditional ‚Üí if). <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { if(expr.empty()) { return{}; } return{ static_cast&lt;Operator&gt;(expr[0]) }; }</code> <br> <s>         </s> . <s>          .</s>           . ‚Ä¶ <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); }</code> <br>     .   ,     ,   - .    , : <br> <br>        ,      <code>Token</code> .       <code>dynamic_cast</code>    ,   .  ,    ,      .      <code>std::function</code>        .        .  Boost.Any,  - .            . <br>   ,   .      -  .  ,      ,      . <br> <br> ‚Ä¶        .        .        .        . <br>             . <br> <br> <code class="cpp">enum class TokenType { Operator, Number }; class Token { public: Token(Operator) {} TokenType Type() const { return TokenType::Operator; } }; ‚Ä¶ TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } };</code> <br>   <code>ToString</code>   <code>TokenType</code>       ,   ,   .     . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); }</code> <br>   .   (constant ‚Üí scalar)   . <br> <br> <code class="cpp">class Token { public: Token(Operator) :m_type(TokenType::Operator) {} Token(double) :m_type(TokenType::Number) {} TokenType Type() const { return m_type; } private: TokenType m_type; };</code> <br> ‚Ä¶ <s>       </s> . <s>       </s> .        .        . <br>    . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); }</code> <br>            . <br> <br> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} operator Operator() const { return m_operator; } ‚Ä¶ Operator m_operator; };</code> <br>      . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); }</code> <br>          ,  ,       <code>union</code> .         . <br> <br> <b class="spoiler_title">Token</b> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: return "Unknown token."; } }</code> <br> <br>  ,    ,      ,    .       .    . <br> <br> <i>          .</i>               .            .       . <br>        : <br> <br> <code class="cpp"> if(expr[0] &gt;= '0' &amp;&amp; expr[0] &lt;= '9') { return{ (double) expr[0] - '0' }; } return{ static_cast&lt;Operator&gt;(expr[0]) };</code> <br>      ,   . <br> <br> ‚Ä¶ <s>          .</s> <i>              .</i> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); }</code> <br> ,     <code>C</code>   ,  <code>isdigit</code> , ,       <code>atof</code> ,    ,      <code>wchar_t</code> .  (expression ‚Üí function).         . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { const wchar_t *current = expr.c_str(); if(!*current) return{}; if(iswdigit(*current)) return{ _wtof(current) }; return{ static_cast&lt;Operator&gt;(*current) }; }</code> <br>         .      . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>   ,        .  ,     .     .   <code>result</code> ,     . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); if(!*current) return result; if(iswdigit(*current)) { result.push_back(_wtof(current)); } else { result.push_back(static_cast&lt;Operator&gt;(*current)); } return result; }</code> <br>      :   (if ‚Üí while).     ,        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } } return result; }</code> <br>  <code>wcstod</code>    ,   <code>_wtof</code> ,           .           ,              .  ,    . <br> <br> <s>           .</s>       . <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>  (unconditional ‚Üí if)    ,    . <br> <br> <code class="cpp"> while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else if(*current == static_cast&lt;wchar_t&gt;(Operator::Plus)) { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } else { ++current; } }</code> <br>       .          .       <code>Detail</code>      .   <code>Tokenize</code>       . <br> <br> <code class="cpp">inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); }</code> <br>  Detail::Tokenizer <code class="cpp">namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { return *m_current == static_cast&lt;wchar_t&gt;(Operator::Plus); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail</code> <br> <br>  ,      .      ,  , .       . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); }</code> <br>      <code>Operator</code> ,    . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', };</code> <br>   .         <code>IsOperator</code>  <code>Tokenizer</code> . <br> <br> <code class="cpp"> bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); }</code> <br>         .        . <br> <br> <b class="spoiler_title">Interpreter.h</b> <code class="cpp">#pragma once; #include &lt;vector&gt; #include &lt;wchar.h&gt; #include &lt;algorithm&gt; namespace Interpreter { enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', }; inline std::wstring ToString(const Operator &amp;op) { return{ static_cast&lt;wchar_t&gt;(op) }; } enum class TokenType { Operator, Number }; inline std::wstring ToString(const TokenType &amp;type) { switch(type) { case TokenType::Operator: return L"Operator"; case TokenType::Number: return L"Number"; default: throw std::out_of_range("TokenType"); } } class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } friend inline bool operator==(const Token &amp;left, const Token &amp;right) { if(left.m_type == right.m_type) { switch(left.m_type) { case Interpreter::TokenType::Operator: return left.m_operator == right.m_operator; case Interpreter::TokenType::Number: return left.m_number == right.m_number; default: throw std::out_of_range("TokenType"); } } return false; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: throw std::out_of_range("TokenType"); } } typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); } } // namespace Lexer } // namespace Interpreter</code> <br> <br> <b class="spoiler_title">InterpreterTests.cpp</b> <code class="cpp">#include "stdafx.h" #include "CppUnitTest.h" #include "Interpreter.h" namespace InterpreterTests { using namespace Microsoft::VisualStudio::CppUnitTestFramework; using namespace Interpreter; using namespace std; namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual&lt;T&gt;(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange TEST_CLASS(LexerTests) { public: TEST_METHOD(Should_return_empty_token_list_when_put_empty_expression) { Tokens tokens = Lexer::Tokenize(L""); Assert::IsTrue(tokens.empty()); } TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); } TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); } TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); } TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); } }; TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); } TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); } TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); } }; }</code> <br> <br> <a href="https://github.com/Unril/InterpreterTDD/releases/tag/%25D0%259A%25D0%25BE%25D0%25BD%25D0%25B5%25D1%2586_%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B2%25D0%25BE%25D0%25B9_%25D1%2587%25D0%25B0%25D1%2581%25D1%2582%25D0%25B8">    GitHub</a> .         ,  .      "__". <br> <br>   <a href="http://habrahabr.ru/post/232081/">    </a> .      ,      <a href="http://habrahabr.ru/post/232097/">    </a> .</b></code> <div class="spoiler_text"> <pre> <code class="hljs lua"><code>std::vector,      Tokens</code> .            . <br> <br> <code class="cpp">#pragma once; #include &lt;vector&gt; namespace Interpreter { struct Token {}; typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { inline Tokens Tokenize(std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> expr) { throw std::exception(); } } // namespace Lexer } // namespace Interpreter</code> <br>   ,  ,   , .   ,    ,    <a href="http://cleancoder.posterous.com/the-transformation-priority-premise">The Transformation Priority Premise (TPP)</a>   .    , ,    ,     ,        .            .     ,     ,      ,           .  ,  ,   (   )    ,  ,  .     ,  ,         .     ,   TPP          . <br> <br>   : <br> <br> ({} ‚Üí <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)     ,   . (<span class="hljs-literal"><span class="hljs-literal">nil</span></span> ‚Üí constant)    . (constant ‚Üí constant+)      (        ,  ). (constant ‚Üí scalar)    ,  . (statement ‚Üí statements)    (<span class="hljs-keyword"><span class="hljs-keyword">break</span></span>, continue, <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>  ). (unconditional ‚Üí <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>)       . (scalar ‚Üí array)  / . (array ‚Üí container)     . (statement ‚Üí recursion)   . (<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ‚Üí <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>)    . (expression ‚Üí <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">)</span></span>   . (variable ‚Üí assignment)   . <br>        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> expr) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{}; }</code> <br> ,         .     . <br> <br> <s>         </s> .           .           .               .            .       . <br>  ,  <code>std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span></code>  <code>std::wstring</code> .         ,      Unicode.     . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"+"</span></span>); AssertRange::AreEqual({ Operator::Plus }, tokens); }</code> <br>  <code>AssertRange</code> -   ,       <code>AreEqual</code> ,   ,  ,    . <br> <br> <b class="spoiler_title">AssertRange</b> <code class="cpp">namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(expect)), distance(actualIter, <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(actual)), L<span class="hljs-string"><span class="hljs-string">"Size differs."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(; expectIter != <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(expect) &amp;&amp; actualIter != <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(actual); ++expectIter, ++actualIter) { auto message = L<span class="hljs-string"><span class="hljs-string">"Mismatch in position "</span></span> + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange</code> <br> <br>         <code>Operator</code>    .          <code>wchar_t</code>   ,         ,      . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L<span class="hljs-string"><span class="hljs-string">'+'</span></span>, }; typedef Operator Token;</code> <br>    ,   ,        <code>Assert</code> ,    <code>ToString</code> ,    . <br> <br> <b class="spoiler_title">std::wstring ToString(const Token &amp;)</b> <code class="cpp">inline std::wstring ToString(const Token &amp;token) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ static_cast&lt;wchar_t&gt;(token) }; }</code> <br> <br>    ,   ,        .  ,   (unconditional ‚Üí <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>). <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(expr.empty()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{}; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ static_cast&lt;Operator&gt;(expr[<span class="hljs-number"><span class="hljs-number">0</span></span>]) }; }</code> <br> <s>         </s> . <s>          .</s>           . ‚Ä¶ <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"1"</span></span>); AssertRange::AreEqual({ <span class="hljs-number"><span class="hljs-number">1.0</span></span> }, tokens); }</code> <br>     .   ,     ,   - .    , : <br> <br>        ,      <code>Token</code> .       <code>dynamic_cast</code>    ,   .  ,    ,      .      <code>std::<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span></span></code><span class="hljs-function"><span class="hljs-function">        .        .  </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Boost.Any</span></span></span><span class="hljs-function">,  - .            . </span></span><br><span class="hljs-function"><span class="hljs-function">   ,   .      -  .  ,      ,      . </span></span><br><span class="hljs-function"><span class="hljs-function"> </span></span><br><span class="hljs-function"><span class="hljs-function"> ‚Ä¶        .        .        .        . </span></span><br><span class="hljs-function"><span class="hljs-function">             . </span></span><br><span class="hljs-function"><span class="hljs-function"> </span></span><br><span class="hljs-function"><span class="hljs-function"> </span></span><code class="cpp"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">enum</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">class</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TokenType</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Operator</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Number</span></span></span><span class="hljs-function"> }; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">class</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Token</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">public</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Token</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Operator)</span></span></span></span> {} TokenType Type() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TokenType::Operator; } }; ‚Ä¶ TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } };</code> <br>   <code>ToString</code>   <code>TokenType</code>       ,   ,   .     . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_type_for_number_token) { Token numToken(<span class="hljs-number"><span class="hljs-number">1.2</span></span>); Assert::AreEqual(TokenType::Number, numToken.Type()); }</code> <br>   .   (constant ‚Üí scalar)   . <br> <br> <code class="cpp">class Token { public: Token(Operator) :m_type(TokenType::Operator) {} Token(double) :m_type(TokenType::Number) {} TokenType Type() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_type; } private: TokenType m_type; };</code> <br> ‚Ä¶ <s>       </s> . <s>       </s> .        .        . <br>    . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); }</code> <br>            . <br> <br> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} operator Operator() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_operator; } ‚Ä¶ Operator m_operator; };</code> <br>      . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_number_value_from_number_token) { Token token(<span class="hljs-number"><span class="hljs-number">1.23</span></span>); Assert::AreEqual&lt;double&gt;(<span class="hljs-number"><span class="hljs-number">1.23</span></span>, token); }</code> <br>          ,  ,       <code>union</code> .         . <br> <br> <b class="spoiler_title">Token</b> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_type; } operator Operator() const { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(m_type != TokenType::Operator) throw std::logic_error(<span class="hljs-string"><span class="hljs-string">"Should be operator token."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_operator; } operator double() const { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(m_type != TokenType::Number) throw std::logic_error(<span class="hljs-string"><span class="hljs-string">"Should be number token."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_number; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ToString(static_cast&lt;Operator&gt;(token)); default: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Unknown token."</span></span>; } }</code> <br> <br>  ,    ,      ,    .       .    . <br> <br> <i>          .</i>               .            .       . <br>        : <br> <br> <code class="cpp"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(expr[<span class="hljs-number"><span class="hljs-number">0</span></span>] &gt;= <span class="hljs-string"><span class="hljs-string">'0'</span></span> &amp;&amp; expr[<span class="hljs-number"><span class="hljs-number">0</span></span>] &lt;= <span class="hljs-string"><span class="hljs-string">'9'</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ (double) expr[<span class="hljs-number"><span class="hljs-number">0</span></span>] - <span class="hljs-string"><span class="hljs-string">'0'</span></span> }; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ static_cast&lt;Operator&gt;(expr[<span class="hljs-number"><span class="hljs-number">0</span></span>]) };</code> <br>      ,   . <br> <br> ‚Ä¶ <s>          .</s> <i>              .</i> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"12.34"</span></span>); AssertRange::AreEqual({ <span class="hljs-number"><span class="hljs-number">12.34</span></span> }, tokens); }</code> <br> ,     <code>C</code>   ,  <code>isdigit</code> , ,       <code>atof</code> ,    ,      <code>wchar_t</code> .  (expression ‚Üí <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">)</span></span>.         . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { const wchar_t *current = expr.c_str(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!*current) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{}; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(iswdigit(*current)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ _wtof(current) }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ static_cast&lt;Operator&gt;(*current) }; }</code> <br>         .      . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"+12.34"</span></span>); AssertRange::AreEqual({ Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">12.34</span></span>) }, tokens); }</code> <br>   ,        .  ,     .     .   <code>result</code> ,     . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!*current) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(iswdigit(*current)) { result.push_back(_wtof(current)); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { result.push_back(static_cast&lt;Operator&gt;(*current)); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> <br>      :   (<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ‚Üí <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>).     ,        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(*current) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(iswdigit(*current)) { wchar_t *<span class="hljs-keyword"><span class="hljs-keyword">end</span></span> = nullptr; result.push_back(wcstod(current, &amp;<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>)); current = <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> <br>  <code>wcstod</code>    ,   <code>_wtof</code> ,           .           ,              .  ,    . <br> <br> <s>           .</s>       . <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">" 1 + 12.34 "</span></span>); AssertRange::AreEqual({ Token(<span class="hljs-number"><span class="hljs-number">1.0</span></span>), Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">12.34</span></span>) }, tokens); }</code> <br>  (unconditional ‚Üí <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>)    ,    . <br> <br> <code class="cpp"> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(*current) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(iswdigit(*current)) { wchar_t *<span class="hljs-keyword"><span class="hljs-keyword">end</span></span> = nullptr; result.push_back(wcstod(current, &amp;<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>)); current = <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(*current == static_cast&lt;wchar_t&gt;(Operator::Plus)) { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { ++current; } }</code> <br>       .          .       <code>Detail</code>      .   <code>Tokenize</code>       . <br> <br> <code class="cpp">inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tokenizer.Result(); }</code> <br> <b class="spoiler_title"> Detail::Tokenizer</b> <code class="cpp">namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!EndOfExperssion()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(IsNumber()) { ScanNumber(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(IsOperator()) { ScanOperator(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { MoveNext(); } } } const Tokens &amp;Result() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_result; } private: bool EndOfExperssion() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_current == L<span class="hljs-string"><span class="hljs-string">'\0'</span></span>; } bool IsNumber() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> iswdigit(*m_current) != <span class="hljs-number"><span class="hljs-number">0</span></span>; } void ScanNumber() { wchar_t *<span class="hljs-keyword"><span class="hljs-keyword">end</span></span> = nullptr; m_result.push_back(wcstod(m_current, &amp;<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>)); m_current = <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; } bool IsOperator() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_current == static_cast&lt;wchar_t&gt;(Operator::Plus); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail</code> <br> <br>  ,      .      ,  , .       . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"1+2*3/(4-5)"</span></span>); AssertRange::AreEqual({ Token(<span class="hljs-number"><span class="hljs-number">1</span></span>), Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">2</span></span>), Token(Operator::Mul), Token(<span class="hljs-number"><span class="hljs-number">3</span></span>), Token(Operator::Div), Token(Operator::LParen), Token(<span class="hljs-number"><span class="hljs-number">4</span></span>), Token(Operator::Minus), Token(<span class="hljs-number"><span class="hljs-number">5</span></span>), Token(Operator::RParen) }, tokens); }</code> <br>      <code>Operator</code> ,    . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L<span class="hljs-string"><span class="hljs-string">'+'</span></span>, Minus = L<span class="hljs-string"><span class="hljs-string">'-'</span></span>, Mul = L<span class="hljs-string"><span class="hljs-string">'*'</span></span>, Div = L<span class="hljs-string"><span class="hljs-string">'/'</span></span>, LParen = L<span class="hljs-string"><span class="hljs-string">'('</span></span>, RParen = L<span class="hljs-string"><span class="hljs-string">')'</span></span>, };</code> <br>   .         <code>IsOperator</code>  <code>Tokenizer</code> . <br> <br> <code class="cpp"> bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> std::any_of(all.begin(), all.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(), [this](Operator o) {<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_current == static_cast&lt;wchar_t&gt;(o); }); }</code> <br>         .        . <br> <br> <b class="spoiler_title">Interpreter.h</b> <code class="cpp">#pragma once; #include &lt;vector&gt; #include &lt;wchar.h&gt; #include &lt;algorithm&gt; namespace Interpreter { enum class Operator : wchar_t { Plus = L<span class="hljs-string"><span class="hljs-string">'+'</span></span>, Minus = L<span class="hljs-string"><span class="hljs-string">'-'</span></span>, Mul = L<span class="hljs-string"><span class="hljs-string">'*'</span></span>, Div = L<span class="hljs-string"><span class="hljs-string">'/'</span></span>, LParen = L<span class="hljs-string"><span class="hljs-string">'('</span></span>, RParen = L<span class="hljs-string"><span class="hljs-string">')'</span></span>, }; inline std::wstring ToString(const Operator &amp;op) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ static_cast&lt;wchar_t&gt;(op) }; } enum class TokenType { Operator, Number }; inline std::wstring ToString(const TokenType &amp;<span class="hljs-built_in"><span class="hljs-built_in">type</span></span>) { switch(<span class="hljs-built_in"><span class="hljs-built_in">type</span></span>) { case TokenType::Operator: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> L<span class="hljs-string"><span class="hljs-string">"Operator"</span></span>; case TokenType::Number: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> L<span class="hljs-string"><span class="hljs-string">"Number"</span></span>; default: throw std::out_of_range(<span class="hljs-string"><span class="hljs-string">"TokenType"</span></span>); } } class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_type; } operator Operator() const { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(m_type != TokenType::Operator) throw std::logic_error(<span class="hljs-string"><span class="hljs-string">"Should be operator token."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_operator; } operator double() const { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(m_type != TokenType::Number) throw std::logic_error(<span class="hljs-string"><span class="hljs-string">"Should be number token."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_number; } friend inline bool operator==(const Token &amp;left, const Token &amp;right) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(left.m_type == right.m_type) { switch(left.m_type) { case Interpreter::TokenType::Operator: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> left.m_operator == right.m_operator; case Interpreter::TokenType::Number: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> left.m_number == right.m_number; default: throw std::out_of_range(<span class="hljs-string"><span class="hljs-string">"TokenType"</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ToString(static_cast&lt;Operator&gt;(token)); default: throw std::out_of_range(<span class="hljs-string"><span class="hljs-string">"TokenType"</span></span>); } } typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!EndOfExperssion()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(IsNumber()) { ScanNumber(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(IsOperator()) { ScanOperator(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { MoveNext(); } } } const Tokens &amp;Result() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_result; } private: bool EndOfExperssion() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_current == L<span class="hljs-string"><span class="hljs-string">'\0'</span></span>; } bool IsNumber() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> iswdigit(*m_current) != <span class="hljs-number"><span class="hljs-number">0</span></span>; } void ScanNumber() { wchar_t *<span class="hljs-keyword"><span class="hljs-keyword">end</span></span> = nullptr; m_result.push_back(wcstod(m_current, &amp;<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>)); m_current = <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; } bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> std::any_of(all.begin(), all.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(), [this](Operator o) {<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_current == static_cast&lt;wchar_t&gt;(o); }); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tokenizer.Result(); } } // namespace Lexer } // namespace Interpreter</code> <br> <br> <b class="spoiler_title">InterpreterTests.cpp</b> <code class="cpp">#include <span class="hljs-string"><span class="hljs-string">"stdafx.h"</span></span> #include <span class="hljs-string"><span class="hljs-string">"CppUnitTest.h"</span></span> #include <span class="hljs-string"><span class="hljs-string">"Interpreter.h"</span></span> namespace InterpreterTests { using namespace Microsoft::VisualStudio::CppUnitTestFramework; using namespace Interpreter; using namespace std; namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(expect)), distance(actualIter, <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(actual)), L<span class="hljs-string"><span class="hljs-string">"Size differs."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(; expectIter != <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(expect) &amp;&amp; actualIter != <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(actual); ++expectIter, ++actualIter) { auto message = L<span class="hljs-string"><span class="hljs-string">"Mismatch in position "</span></span> + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual&lt;T&gt;(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange TEST_CLASS(LexerTests) { public: TEST_METHOD(Should_return_empty_token_list_when_put_empty_expression) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">""</span></span>); Assert::IsTrue(tokens.empty()); } TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"+"</span></span>); AssertRange::AreEqual({ Operator::Plus }, tokens); } TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"1"</span></span>); AssertRange::AreEqual({ <span class="hljs-number"><span class="hljs-number">1.0</span></span> }, tokens); } TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"12.34"</span></span>); AssertRange::AreEqual({ <span class="hljs-number"><span class="hljs-number">12.34</span></span> }, tokens); } TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"+12.34"</span></span>); AssertRange::AreEqual({ Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">12.34</span></span>) }, tokens); } TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">" 1 + 12.34 "</span></span>); AssertRange::AreEqual({ Token(<span class="hljs-number"><span class="hljs-number">1.0</span></span>), Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">12.34</span></span>) }, tokens); } TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"1+2*3/(4-5)"</span></span>); AssertRange::AreEqual({ Token(<span class="hljs-number"><span class="hljs-number">1</span></span>), Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">2</span></span>), Token(Operator::Mul), Token(<span class="hljs-number"><span class="hljs-number">3</span></span>), Token(Operator::Div), Token(Operator::LParen), Token(<span class="hljs-number"><span class="hljs-number">4</span></span>), Token(Operator::Minus), Token(<span class="hljs-number"><span class="hljs-number">5</span></span>), Token(Operator::RParen) }, tokens); } }; TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } TEST_METHOD(Should_get_type_for_number_token) { Token numToken(<span class="hljs-number"><span class="hljs-number">1.2</span></span>); Assert::AreEqual(TokenType::Number, numToken.Type()); } TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); } TEST_METHOD(Should_get_number_value_from_number_token) { Token token(<span class="hljs-number"><span class="hljs-number">1.23</span></span>); Assert::AreEqual&lt;double&gt;(<span class="hljs-number"><span class="hljs-number">1.23</span></span>, token); } }; }</code> <br> <br> <a href="https://github.com/Unril/InterpreterTDD/releases/tag/%25D0%259A%25D0%25BE%25D0%25BD%25D0%25B5%25D1%2586_%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B2%25D0%25BE%25D0%25B9_%25D1%2587%25D0%25B0%25D1%2581%25D1%2582%25D0%25B8">    GitHub</a> .         ,  .      <span class="hljs-string"><span class="hljs-string">"__"</span></span>. <br> <br>   <a href="http://habrahabr.ru/post/232081/">    </a> .      ,      <a href="http://habrahabr.ru/post/232097/">    </a> .</code> </pre> <code><code>std::vector,      Tokens</code> .            . <br> <br> <code class="cpp">#pragma once; #include &lt;vector&gt; namespace Interpreter { struct Token {}; typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { inline Tokens Tokenize(std::string expr) { throw std::exception(); } } // namespace Lexer } // namespace Interpreter</code> <br>   ,  ,   , .   ,    ,    <a href="http://cleancoder.posterous.com/the-transformation-priority-premise">The Transformation Priority Premise (TPP)</a>   .    , ,    ,     ,        .            .     ,     ,      ,           .  ,  ,   (   )    ,  ,  .     ,  ,         .     ,   TPP          . <br> <br>   : <br> <br> ({} ‚Üí nil)     ,   . (nil ‚Üí constant)    . (constant ‚Üí constant+)      (        ,  ). (constant ‚Üí scalar)    ,  . (statement ‚Üí statements)    (break, continue, return  ). (unconditional ‚Üí if)       . (scalar ‚Üí array)  / . (array ‚Üí container)     . (statement ‚Üí recursion)   . (if ‚Üí while)    . (expression ‚Üí function)   . (variable ‚Üí assignment)   . <br>        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::string expr) { return{}; }</code> <br> ,         .     . <br> <br> <s>         </s> .           .           .               .            .       . <br>  ,  <code>std::string</code>  <code>std::wstring</code> .         ,      Unicode.     . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); }</code> <br>  <code>AssertRange</code> -   ,       <code>AreEqual</code> ,   ,  ,    . <br> <br> <b class="spoiler_title">AssertRange</b> <code class="cpp">namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange</code> <br> <br>         <code>Operator</code>    .          <code>wchar_t</code>   ,         ,      . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', }; typedef Operator Token;</code> <br>    ,   ,        <code>Assert</code> ,    <code>ToString</code> ,    . <br> <br> <b class="spoiler_title">std::wstring ToString(const Token &amp;)</b> <code class="cpp">inline std::wstring ToString(const Token &amp;token) { return{ static_cast&lt;wchar_t&gt;(token) }; }</code> <br> <br>    ,   ,        .  ,   (unconditional ‚Üí if). <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { if(expr.empty()) { return{}; } return{ static_cast&lt;Operator&gt;(expr[0]) }; }</code> <br> <s>         </s> . <s>          .</s>           . ‚Ä¶ <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); }</code> <br>     .   ,     ,   - .    , : <br> <br>        ,      <code>Token</code> .       <code>dynamic_cast</code>    ,   .  ,    ,      .      <code>std::function</code>        .        .  Boost.Any,  - .            . <br>   ,   .      -  .  ,      ,      . <br> <br> ‚Ä¶        .        .        .        . <br>             . <br> <br> <code class="cpp">enum class TokenType { Operator, Number }; class Token { public: Token(Operator) {} TokenType Type() const { return TokenType::Operator; } }; ‚Ä¶ TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } };</code> <br>   <code>ToString</code>   <code>TokenType</code>       ,   ,   .     . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); }</code> <br>   .   (constant ‚Üí scalar)   . <br> <br> <code class="cpp">class Token { public: Token(Operator) :m_type(TokenType::Operator) {} Token(double) :m_type(TokenType::Number) {} TokenType Type() const { return m_type; } private: TokenType m_type; };</code> <br> ‚Ä¶ <s>       </s> . <s>       </s> .        .        . <br>    . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); }</code> <br>            . <br> <br> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} operator Operator() const { return m_operator; } ‚Ä¶ Operator m_operator; };</code> <br>      . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); }</code> <br>          ,  ,       <code>union</code> .         . <br> <br> <b class="spoiler_title">Token</b> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: return "Unknown token."; } }</code> <br> <br>  ,    ,      ,    .       .    . <br> <br> <i>          .</i>               .            .       . <br>        : <br> <br> <code class="cpp"> if(expr[0] &gt;= '0' &amp;&amp; expr[0] &lt;= '9') { return{ (double) expr[0] - '0' }; } return{ static_cast&lt;Operator&gt;(expr[0]) };</code> <br>      ,   . <br> <br> ‚Ä¶ <s>          .</s> <i>              .</i> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); }</code> <br> ,     <code>C</code>   ,  <code>isdigit</code> , ,       <code>atof</code> ,    ,      <code>wchar_t</code> .  (expression ‚Üí function).         . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { const wchar_t *current = expr.c_str(); if(!*current) return{}; if(iswdigit(*current)) return{ _wtof(current) }; return{ static_cast&lt;Operator&gt;(*current) }; }</code> <br>         .      . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>   ,        .  ,     .     .   <code>result</code> ,     . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); if(!*current) return result; if(iswdigit(*current)) { result.push_back(_wtof(current)); } else { result.push_back(static_cast&lt;Operator&gt;(*current)); } return result; }</code> <br>      :   (if ‚Üí while).     ,        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } } return result; }</code> <br>  <code>wcstod</code>    ,   <code>_wtof</code> ,           .           ,              .  ,    . <br> <br> <s>           .</s>       . <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>  (unconditional ‚Üí if)    ,    . <br> <br> <code class="cpp"> while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else if(*current == static_cast&lt;wchar_t&gt;(Operator::Plus)) { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } else { ++current; } }</code> <br>       .          .       <code>Detail</code>      .   <code>Tokenize</code>       . <br> <br> <code class="cpp">inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); }</code> <br> <b class="spoiler_title"> Detail::Tokenizer</b> <code class="cpp">namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { return *m_current == static_cast&lt;wchar_t&gt;(Operator::Plus); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail</code> <br> <br>  ,      .      ,  , .       . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); }</code> <br>      <code>Operator</code> ,    . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', };</code> <br>   .         <code>IsOperator</code>  <code>Tokenizer</code> . <br> <br> <code class="cpp"> bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); }</code> <br>         .        . <br> <br> <b class="spoiler_title">Interpreter.h</b> <code class="cpp">#pragma once; #include &lt;vector&gt; #include &lt;wchar.h&gt; #include &lt;algorithm&gt; namespace Interpreter { enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', }; inline std::wstring ToString(const Operator &amp;op) { return{ static_cast&lt;wchar_t&gt;(op) }; } enum class TokenType { Operator, Number }; inline std::wstring ToString(const TokenType &amp;type) { switch(type) { case TokenType::Operator: return L"Operator"; case TokenType::Number: return L"Number"; default: throw std::out_of_range("TokenType"); } } class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } friend inline bool operator==(const Token &amp;left, const Token &amp;right) { if(left.m_type == right.m_type) { switch(left.m_type) { case Interpreter::TokenType::Operator: return left.m_operator == right.m_operator; case Interpreter::TokenType::Number: return left.m_number == right.m_number; default: throw std::out_of_range("TokenType"); } } return false; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: throw std::out_of_range("TokenType"); } } typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); } } // namespace Lexer } // namespace Interpreter</code> <br> <br> <b class="spoiler_title">InterpreterTests.cpp</b> <code class="cpp">#include "stdafx.h" #include "CppUnitTest.h" #include "Interpreter.h" namespace InterpreterTests { using namespace Microsoft::VisualStudio::CppUnitTestFramework; using namespace Interpreter; using namespace std; namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual&lt;T&gt;(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange TEST_CLASS(LexerTests) { public: TEST_METHOD(Should_return_empty_token_list_when_put_empty_expression) { Tokens tokens = Lexer::Tokenize(L""); Assert::IsTrue(tokens.empty()); } TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); } TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); } TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); } TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); } }; TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); } TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); } TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); } }; }</code> <br> <br> <a href="https://github.com/Unril/InterpreterTDD/releases/tag/%25D0%259A%25D0%25BE%25D0%25BD%25D0%25B5%25D1%2586_%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B2%25D0%25BE%25D0%25B9_%25D1%2587%25D0%25B0%25D1%2581%25D1%2582%25D0%25B8">    GitHub</a> .         ,  .      "__". <br> <br>   <a href="http://habrahabr.ru/post/232081/">    </a> .      ,      <a href="http://habrahabr.ru/post/232097/">    </a> .</code> </div></div> <code><code>std::vector,      Tokens</code> .            . <br> <br> <code class="cpp">#pragma once; #include &lt;vector&gt; namespace Interpreter { struct Token {}; typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { inline Tokens Tokenize(std::string expr) { throw std::exception(); } } // namespace Lexer } // namespace Interpreter</code> <br>   ,  ,   , .   ,    ,    <a href="http://cleancoder.posterous.com/the-transformation-priority-premise">The Transformation Priority Premise (TPP)</a>   .    , ,    ,     ,        .            .     ,     ,      ,           .  ,  ,   (   )    ,  ,  .     ,  ,         .     ,   TPP          . <br> <br>   : <br> <br> ({} ‚Üí nil)     ,   . (nil ‚Üí constant)    . (constant ‚Üí constant+)      (        ,  ). (constant ‚Üí scalar)    ,  . (statement ‚Üí statements)    (break, continue, return  ). (unconditional ‚Üí if)       . (scalar ‚Üí array)  / . (array ‚Üí container)     . (statement ‚Üí recursion)   . (if ‚Üí while)    . (expression ‚Üí function)   . (variable ‚Üí assignment)   . <br>        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::string expr) { return{}; }</code> <br> ,         .     . <br> <br> <s>         </s> .           .           .               .            .       . <br>  ,  <code>std::string</code>  <code>std::wstring</code> .         ,      Unicode.     . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); }</code> <br>  <code>AssertRange</code> -   ,       <code>AreEqual</code> ,   ,  ,    . <br> <br> <b class="spoiler_title">AssertRange</b> <code class="cpp">namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange</code> <br> <br>         <code>Operator</code>    .          <code>wchar_t</code>   ,         ,      . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', }; typedef Operator Token;</code> <br>    ,   ,        <code>Assert</code> ,    <code>ToString</code> ,    . <br> <br> <b class="spoiler_title">std::wstring ToString(const Token &amp;)</b> <code class="cpp">inline std::wstring ToString(const Token &amp;token) { return{ static_cast&lt;wchar_t&gt;(token) }; }</code> <br> <br>    ,   ,        .  ,   (unconditional ‚Üí if). <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { if(expr.empty()) { return{}; } return{ static_cast&lt;Operator&gt;(expr[0]) }; }</code> <br> <s>         </s> . <s>          .</s>           . ‚Ä¶ <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); }</code> <br>     .   ,     ,   - .    , : <br> <br>        ,      <code>Token</code> .       <code>dynamic_cast</code>    ,   .  ,    ,      .      <code>std::function</code>        .        .  Boost.Any,  - .            . <br>   ,   .      -  .  ,      ,      . <br> <br> ‚Ä¶        .        .        .        . <br>             . <br> <br> <code class="cpp">enum class TokenType { Operator, Number }; class Token { public: Token(Operator) {} TokenType Type() const { return TokenType::Operator; } }; ‚Ä¶ TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } };</code> <br>   <code>ToString</code>   <code>TokenType</code>       ,   ,   .     . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); }</code> <br>   .   (constant ‚Üí scalar)   . <br> <br> <code class="cpp">class Token { public: Token(Operator) :m_type(TokenType::Operator) {} Token(double) :m_type(TokenType::Number) {} TokenType Type() const { return m_type; } private: TokenType m_type; };</code> <br> ‚Ä¶ <s>       </s> . <s>       </s> .        .        . <br>    . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); }</code> <br>            . <br> <br> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} operator Operator() const { return m_operator; } ‚Ä¶ Operator m_operator; };</code> <br>      . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); }</code> <br>          ,  ,       <code>union</code> .         . <br> <br> <b class="spoiler_title">Token</b> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: return "Unknown token."; } }</code> <br> <br>  ,    ,      ,    .       .    . <br> <br> <i>          .</i>               .            .       . <br>        : <br> <br> <code class="cpp"> if(expr[0] &gt;= '0' &amp;&amp; expr[0] &lt;= '9') { return{ (double) expr[0] - '0' }; } return{ static_cast&lt;Operator&gt;(expr[0]) };</code> <br>      ,   . <br> <br> ‚Ä¶ <s>          .</s> <i>              .</i> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); }</code> <br> ,     <code>C</code>   ,  <code>isdigit</code> , ,       <code>atof</code> ,    ,      <code>wchar_t</code> .  (expression ‚Üí function).         . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { const wchar_t *current = expr.c_str(); if(!*current) return{}; if(iswdigit(*current)) return{ _wtof(current) }; return{ static_cast&lt;Operator&gt;(*current) }; }</code> <br>         .      . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>   ,        .  ,     .     .   <code>result</code> ,     . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); if(!*current) return result; if(iswdigit(*current)) { result.push_back(_wtof(current)); } else { result.push_back(static_cast&lt;Operator&gt;(*current)); } return result; }</code> <br>      :   (if ‚Üí while).     ,        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } } return result; }</code> <br>  <code>wcstod</code>    ,   <code>_wtof</code> ,           .           ,              .  ,    . <br> <br> <s>           .</s>       . <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>  (unconditional ‚Üí if)    ,    . <br> <br> <code class="cpp"> while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else if(*current == static_cast&lt;wchar_t&gt;(Operator::Plus)) { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } else { ++current; } }</code> <br>       .          .       <code>Detail</code>      .   <code>Tokenize</code>       . <br> <br> <code class="cpp">inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); }</code> <br> <b class="spoiler_title"> Detail::Tokenizer</b> <code class="cpp">namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { return *m_current == static_cast&lt;wchar_t&gt;(Operator::Plus); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail</code> <br> <br>  ,      .      ,  , .       . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); }</code> <br>      <code>Operator</code> ,    . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', };</code> <br>   .         <code>IsOperator</code>  <code>Tokenizer</code> . <br> <br> <code class="cpp"> bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); }</code> <br>         .        . <br> <br> <b class="spoiler_title">Interpreter.h</b> <code class="cpp">#pragma once; #include &lt;vector&gt; #include &lt;wchar.h&gt; #include &lt;algorithm&gt; namespace Interpreter { enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', }; inline std::wstring ToString(const Operator &amp;op) { return{ static_cast&lt;wchar_t&gt;(op) }; } enum class TokenType { Operator, Number }; inline std::wstring ToString(const TokenType &amp;type) { switch(type) { case TokenType::Operator: return L"Operator"; case TokenType::Number: return L"Number"; default: throw std::out_of_range("TokenType"); } } class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } friend inline bool operator==(const Token &amp;left, const Token &amp;right) { if(left.m_type == right.m_type) { switch(left.m_type) { case Interpreter::TokenType::Operator: return left.m_operator == right.m_operator; case Interpreter::TokenType::Number: return left.m_number == right.m_number; default: throw std::out_of_range("TokenType"); } } return false; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: throw std::out_of_range("TokenType"); } } typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); } } // namespace Lexer } // namespace Interpreter</code> <br> <br> <b class="spoiler_title">InterpreterTests.cpp</b> <code class="cpp">#include "stdafx.h" #include "CppUnitTest.h" #include "Interpreter.h" namespace InterpreterTests { using namespace Microsoft::VisualStudio::CppUnitTestFramework; using namespace Interpreter; using namespace std; namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual&lt;T&gt;(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange TEST_CLASS(LexerTests) { public: TEST_METHOD(Should_return_empty_token_list_when_put_empty_expression) { Tokens tokens = Lexer::Tokenize(L""); Assert::IsTrue(tokens.empty()); } TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); } TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); } TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); } TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); } }; TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); } TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); } TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); } }; }</code> <br> <br> <a href="https://github.com/Unril/InterpreterTDD/releases/tag/%25D0%259A%25D0%25BE%25D0%25BD%25D0%25B5%25D1%2586_%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B2%25D0%25BE%25D0%25B9_%25D1%2587%25D0%25B0%25D1%2581%25D1%2582%25D0%25B8">    GitHub</a> .         ,  .      "__". <br> <br>   <a href="http://habrahabr.ru/post/232081/">    </a> .      ,      <a href="http://habrahabr.ru/post/232097/">    </a> .</code> <pre> <code class="hljs lua"><code>std::vector,      Tokens</code> .            . <br> <br> <code class="cpp">#pragma once; #include &lt;vector&gt; namespace Interpreter { struct Token {}; typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { inline Tokens Tokenize(std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> expr) { throw std::exception(); } } // namespace Lexer } // namespace Interpreter</code> <br>   ,  ,   , .   ,    ,    <a href="http://cleancoder.posterous.com/the-transformation-priority-premise">The Transformation Priority Premise (TPP)</a>   .    , ,    ,     ,        .            .     ,     ,      ,           .  ,  ,   (   )    ,  ,  .     ,  ,         .     ,   TPP          . <br> <br>   : <br> <br> ({} ‚Üí <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)     ,   . (<span class="hljs-literal"><span class="hljs-literal">nil</span></span> ‚Üí constant)    . (constant ‚Üí constant+)      (        ,  ). (constant ‚Üí scalar)    ,  . (statement ‚Üí statements)    (<span class="hljs-keyword"><span class="hljs-keyword">break</span></span>, continue, <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>  ). (unconditional ‚Üí <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>)       . (scalar ‚Üí array)  / . (array ‚Üí container)     . (statement ‚Üí recursion)   . (<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ‚Üí <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>)    . (expression ‚Üí <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">)</span></span>   . (variable ‚Üí assignment)   . <br>        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> expr) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{}; }</code> <br> ,         .     . <br> <br> <s>         </s> .           .           .               .            .       . <br>  ,  <code>std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span></code>  <code>std::wstring</code> .         ,      Unicode.     . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"+"</span></span>); AssertRange::AreEqual({ Operator::Plus }, tokens); }</code> <br>  <code>AssertRange</code> -   ,       <code>AreEqual</code> ,   ,  ,    . <br> <br> <b class="spoiler_title">AssertRange</b> <code class="cpp">namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(expect)), distance(actualIter, <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(actual)), L<span class="hljs-string"><span class="hljs-string">"Size differs."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(; expectIter != <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(expect) &amp;&amp; actualIter != <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(actual); ++expectIter, ++actualIter) { auto message = L<span class="hljs-string"><span class="hljs-string">"Mismatch in position "</span></span> + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange</code> <br> <br>         <code>Operator</code>    .          <code>wchar_t</code>   ,         ,      . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L<span class="hljs-string"><span class="hljs-string">'+'</span></span>, }; typedef Operator Token;</code> <br>    ,   ,        <code>Assert</code> ,    <code>ToString</code> ,    . <br> <br> <b class="spoiler_title">std::wstring ToString(const Token &amp;)</b> <code class="cpp">inline std::wstring ToString(const Token &amp;token) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ static_cast&lt;wchar_t&gt;(token) }; }</code> <br> <br>    ,   ,        .  ,   (unconditional ‚Üí <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>). <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(expr.empty()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{}; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ static_cast&lt;Operator&gt;(expr[<span class="hljs-number"><span class="hljs-number">0</span></span>]) }; }</code> <br> <s>         </s> . <s>          .</s>           . ‚Ä¶ <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"1"</span></span>); AssertRange::AreEqual({ <span class="hljs-number"><span class="hljs-number">1.0</span></span> }, tokens); }</code> <br>     .   ,     ,   - .    , : <br> <br>        ,      <code>Token</code> .       <code>dynamic_cast</code>    ,   .  ,    ,      .      <code>std::<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span></span></code><span class="hljs-function"><span class="hljs-function">        .        .  </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Boost.Any</span></span></span><span class="hljs-function">,  - .            . </span></span><br><span class="hljs-function"><span class="hljs-function">   ,   .      -  .  ,      ,      . </span></span><br><span class="hljs-function"><span class="hljs-function"> </span></span><br><span class="hljs-function"><span class="hljs-function"> ‚Ä¶        .        .        .        . </span></span><br><span class="hljs-function"><span class="hljs-function">             . </span></span><br><span class="hljs-function"><span class="hljs-function"> </span></span><br><span class="hljs-function"><span class="hljs-function"> </span></span><code class="cpp"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">enum</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">class</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TokenType</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Operator</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Number</span></span></span><span class="hljs-function"> }; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">class</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Token</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">public</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Token</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Operator)</span></span></span></span> {} TokenType Type() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TokenType::Operator; } }; ‚Ä¶ TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } };</code> <br>   <code>ToString</code>   <code>TokenType</code>       ,   ,   .     . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_type_for_number_token) { Token numToken(<span class="hljs-number"><span class="hljs-number">1.2</span></span>); Assert::AreEqual(TokenType::Number, numToken.Type()); }</code> <br>   .   (constant ‚Üí scalar)   . <br> <br> <code class="cpp">class Token { public: Token(Operator) :m_type(TokenType::Operator) {} Token(double) :m_type(TokenType::Number) {} TokenType Type() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_type; } private: TokenType m_type; };</code> <br> ‚Ä¶ <s>       </s> . <s>       </s> .        .        . <br>    . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); }</code> <br>            . <br> <br> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} operator Operator() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_operator; } ‚Ä¶ Operator m_operator; };</code> <br>      . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_number_value_from_number_token) { Token token(<span class="hljs-number"><span class="hljs-number">1.23</span></span>); Assert::AreEqual&lt;double&gt;(<span class="hljs-number"><span class="hljs-number">1.23</span></span>, token); }</code> <br>          ,  ,       <code>union</code> .         . <br> <br> <b class="spoiler_title">Token</b> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_type; } operator Operator() const { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(m_type != TokenType::Operator) throw std::logic_error(<span class="hljs-string"><span class="hljs-string">"Should be operator token."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_operator; } operator double() const { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(m_type != TokenType::Number) throw std::logic_error(<span class="hljs-string"><span class="hljs-string">"Should be number token."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_number; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ToString(static_cast&lt;Operator&gt;(token)); default: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Unknown token."</span></span>; } }</code> <br> <br>  ,    ,      ,    .       .    . <br> <br> <i>          .</i>               .            .       . <br>        : <br> <br> <code class="cpp"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(expr[<span class="hljs-number"><span class="hljs-number">0</span></span>] &gt;= <span class="hljs-string"><span class="hljs-string">'0'</span></span> &amp;&amp; expr[<span class="hljs-number"><span class="hljs-number">0</span></span>] &lt;= <span class="hljs-string"><span class="hljs-string">'9'</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ (double) expr[<span class="hljs-number"><span class="hljs-number">0</span></span>] - <span class="hljs-string"><span class="hljs-string">'0'</span></span> }; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ static_cast&lt;Operator&gt;(expr[<span class="hljs-number"><span class="hljs-number">0</span></span>]) };</code> <br>      ,   . <br> <br> ‚Ä¶ <s>          .</s> <i>              .</i> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"12.34"</span></span>); AssertRange::AreEqual({ <span class="hljs-number"><span class="hljs-number">12.34</span></span> }, tokens); }</code> <br> ,     <code>C</code>   ,  <code>isdigit</code> , ,       <code>atof</code> ,    ,      <code>wchar_t</code> .  (expression ‚Üí <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">)</span></span>.         . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { const wchar_t *current = expr.c_str(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!*current) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{}; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(iswdigit(*current)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ _wtof(current) }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ static_cast&lt;Operator&gt;(*current) }; }</code> <br>         .      . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"+12.34"</span></span>); AssertRange::AreEqual({ Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">12.34</span></span>) }, tokens); }</code> <br>   ,        .  ,     .     .   <code>result</code> ,     . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!*current) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(iswdigit(*current)) { result.push_back(_wtof(current)); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { result.push_back(static_cast&lt;Operator&gt;(*current)); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> <br>      :   (<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ‚Üí <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>).     ,        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(*current) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(iswdigit(*current)) { wchar_t *<span class="hljs-keyword"><span class="hljs-keyword">end</span></span> = nullptr; result.push_back(wcstod(current, &amp;<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>)); current = <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> <br>  <code>wcstod</code>    ,   <code>_wtof</code> ,           .           ,              .  ,    . <br> <br> <s>           .</s>       . <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">" 1 + 12.34 "</span></span>); AssertRange::AreEqual({ Token(<span class="hljs-number"><span class="hljs-number">1.0</span></span>), Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">12.34</span></span>) }, tokens); }</code> <br>  (unconditional ‚Üí <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>)    ,    . <br> <br> <code class="cpp"> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(*current) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(iswdigit(*current)) { wchar_t *<span class="hljs-keyword"><span class="hljs-keyword">end</span></span> = nullptr; result.push_back(wcstod(current, &amp;<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>)); current = <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(*current == static_cast&lt;wchar_t&gt;(Operator::Plus)) { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { ++current; } }</code> <br>       .          .       <code>Detail</code>      .   <code>Tokenize</code>       . <br> <br> <code class="cpp">inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tokenizer.Result(); }</code> <br> <b class="spoiler_title"> Detail::Tokenizer</b> <code class="cpp">namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!EndOfExperssion()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(IsNumber()) { ScanNumber(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(IsOperator()) { ScanOperator(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { MoveNext(); } } } const Tokens &amp;Result() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_result; } private: bool EndOfExperssion() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_current == L<span class="hljs-string"><span class="hljs-string">'\0'</span></span>; } bool IsNumber() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> iswdigit(*m_current) != <span class="hljs-number"><span class="hljs-number">0</span></span>; } void ScanNumber() { wchar_t *<span class="hljs-keyword"><span class="hljs-keyword">end</span></span> = nullptr; m_result.push_back(wcstod(m_current, &amp;<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>)); m_current = <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; } bool IsOperator() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_current == static_cast&lt;wchar_t&gt;(Operator::Plus); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail</code> <br> <br>  ,      .      ,  , .       . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"1+2*3/(4-5)"</span></span>); AssertRange::AreEqual({ Token(<span class="hljs-number"><span class="hljs-number">1</span></span>), Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">2</span></span>), Token(Operator::Mul), Token(<span class="hljs-number"><span class="hljs-number">3</span></span>), Token(Operator::Div), Token(Operator::LParen), Token(<span class="hljs-number"><span class="hljs-number">4</span></span>), Token(Operator::Minus), Token(<span class="hljs-number"><span class="hljs-number">5</span></span>), Token(Operator::RParen) }, tokens); }</code> <br>      <code>Operator</code> ,    . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L<span class="hljs-string"><span class="hljs-string">'+'</span></span>, Minus = L<span class="hljs-string"><span class="hljs-string">'-'</span></span>, Mul = L<span class="hljs-string"><span class="hljs-string">'*'</span></span>, Div = L<span class="hljs-string"><span class="hljs-string">'/'</span></span>, LParen = L<span class="hljs-string"><span class="hljs-string">'('</span></span>, RParen = L<span class="hljs-string"><span class="hljs-string">')'</span></span>, };</code> <br>   .         <code>IsOperator</code>  <code>Tokenizer</code> . <br> <br> <code class="cpp"> bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> std::any_of(all.begin(), all.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(), [this](Operator o) {<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_current == static_cast&lt;wchar_t&gt;(o); }); }</code> <br>         .        . <br> <br> <b class="spoiler_title">Interpreter.h</b> <code class="cpp">#pragma once; #include &lt;vector&gt; #include &lt;wchar.h&gt; #include &lt;algorithm&gt; namespace Interpreter { enum class Operator : wchar_t { Plus = L<span class="hljs-string"><span class="hljs-string">'+'</span></span>, Minus = L<span class="hljs-string"><span class="hljs-string">'-'</span></span>, Mul = L<span class="hljs-string"><span class="hljs-string">'*'</span></span>, Div = L<span class="hljs-string"><span class="hljs-string">'/'</span></span>, LParen = L<span class="hljs-string"><span class="hljs-string">'('</span></span>, RParen = L<span class="hljs-string"><span class="hljs-string">')'</span></span>, }; inline std::wstring ToString(const Operator &amp;op) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ static_cast&lt;wchar_t&gt;(op) }; } enum class TokenType { Operator, Number }; inline std::wstring ToString(const TokenType &amp;<span class="hljs-built_in"><span class="hljs-built_in">type</span></span>) { switch(<span class="hljs-built_in"><span class="hljs-built_in">type</span></span>) { case TokenType::Operator: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> L<span class="hljs-string"><span class="hljs-string">"Operator"</span></span>; case TokenType::Number: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> L<span class="hljs-string"><span class="hljs-string">"Number"</span></span>; default: throw std::out_of_range(<span class="hljs-string"><span class="hljs-string">"TokenType"</span></span>); } } class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_type; } operator Operator() const { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(m_type != TokenType::Operator) throw std::logic_error(<span class="hljs-string"><span class="hljs-string">"Should be operator token."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_operator; } operator double() const { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(m_type != TokenType::Number) throw std::logic_error(<span class="hljs-string"><span class="hljs-string">"Should be number token."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_number; } friend inline bool operator==(const Token &amp;left, const Token &amp;right) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(left.m_type == right.m_type) { switch(left.m_type) { case Interpreter::TokenType::Operator: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> left.m_operator == right.m_operator; case Interpreter::TokenType::Number: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> left.m_number == right.m_number; default: throw std::out_of_range(<span class="hljs-string"><span class="hljs-string">"TokenType"</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ToString(static_cast&lt;Operator&gt;(token)); default: throw std::out_of_range(<span class="hljs-string"><span class="hljs-string">"TokenType"</span></span>); } } typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!EndOfExperssion()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(IsNumber()) { ScanNumber(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(IsOperator()) { ScanOperator(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { MoveNext(); } } } const Tokens &amp;Result() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_result; } private: bool EndOfExperssion() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_current == L<span class="hljs-string"><span class="hljs-string">'\0'</span></span>; } bool IsNumber() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> iswdigit(*m_current) != <span class="hljs-number"><span class="hljs-number">0</span></span>; } void ScanNumber() { wchar_t *<span class="hljs-keyword"><span class="hljs-keyword">end</span></span> = nullptr; m_result.push_back(wcstod(m_current, &amp;<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>)); m_current = <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; } bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> std::any_of(all.begin(), all.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(), [this](Operator o) {<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_current == static_cast&lt;wchar_t&gt;(o); }); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tokenizer.Result(); } } // namespace Lexer } // namespace Interpreter</code> <br> <br> <b class="spoiler_title">InterpreterTests.cpp</b> <code class="cpp">#include <span class="hljs-string"><span class="hljs-string">"stdafx.h"</span></span> #include <span class="hljs-string"><span class="hljs-string">"CppUnitTest.h"</span></span> #include <span class="hljs-string"><span class="hljs-string">"Interpreter.h"</span></span> namespace InterpreterTests { using namespace Microsoft::VisualStudio::CppUnitTestFramework; using namespace Interpreter; using namespace std; namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(expect)), distance(actualIter, <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(actual)), L<span class="hljs-string"><span class="hljs-string">"Size differs."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(; expectIter != <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(expect) &amp;&amp; actualIter != <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(actual); ++expectIter, ++actualIter) { auto message = L<span class="hljs-string"><span class="hljs-string">"Mismatch in position "</span></span> + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual&lt;T&gt;(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange TEST_CLASS(LexerTests) { public: TEST_METHOD(Should_return_empty_token_list_when_put_empty_expression) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">""</span></span>); Assert::IsTrue(tokens.empty()); } TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"+"</span></span>); AssertRange::AreEqual({ Operator::Plus }, tokens); } TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"1"</span></span>); AssertRange::AreEqual({ <span class="hljs-number"><span class="hljs-number">1.0</span></span> }, tokens); } TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"12.34"</span></span>); AssertRange::AreEqual({ <span class="hljs-number"><span class="hljs-number">12.34</span></span> }, tokens); } TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"+12.34"</span></span>); AssertRange::AreEqual({ Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">12.34</span></span>) }, tokens); } TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">" 1 + 12.34 "</span></span>); AssertRange::AreEqual({ Token(<span class="hljs-number"><span class="hljs-number">1.0</span></span>), Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">12.34</span></span>) }, tokens); } TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"1+2*3/(4-5)"</span></span>); AssertRange::AreEqual({ Token(<span class="hljs-number"><span class="hljs-number">1</span></span>), Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">2</span></span>), Token(Operator::Mul), Token(<span class="hljs-number"><span class="hljs-number">3</span></span>), Token(Operator::Div), Token(Operator::LParen), Token(<span class="hljs-number"><span class="hljs-number">4</span></span>), Token(Operator::Minus), Token(<span class="hljs-number"><span class="hljs-number">5</span></span>), Token(Operator::RParen) }, tokens); } }; TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } TEST_METHOD(Should_get_type_for_number_token) { Token numToken(<span class="hljs-number"><span class="hljs-number">1.2</span></span>); Assert::AreEqual(TokenType::Number, numToken.Type()); } TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); } TEST_METHOD(Should_get_number_value_from_number_token) { Token token(<span class="hljs-number"><span class="hljs-number">1.23</span></span>); Assert::AreEqual&lt;double&gt;(<span class="hljs-number"><span class="hljs-number">1.23</span></span>, token); } }; }</code> <br> <br> <a href="https://github.com/Unril/InterpreterTDD/releases/tag/%25D0%259A%25D0%25BE%25D0%25BD%25D0%25B5%25D1%2586_%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B2%25D0%25BE%25D0%25B9_%25D1%2587%25D0%25B0%25D1%2581%25D1%2582%25D0%25B8">    GitHub</a> .         ,  .      <span class="hljs-string"><span class="hljs-string">"__"</span></span>. <br> <br>   <a href="http://habrahabr.ru/post/232081/">    </a> .      ,      <a href="http://habrahabr.ru/post/232097/">    </a> .</code> </pre> <code><code>std::vector,      Tokens</code> .            . <br> <br> <code class="cpp">#pragma once; #include &lt;vector&gt; namespace Interpreter { struct Token {}; typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { inline Tokens Tokenize(std::string expr) { throw std::exception(); } } // namespace Lexer } // namespace Interpreter</code> <br>   ,  ,   , .   ,    ,    <a href="http://cleancoder.posterous.com/the-transformation-priority-premise">The Transformation Priority Premise (TPP)</a>   .    , ,    ,     ,        .            .     ,     ,      ,           .  ,  ,   (   )    ,  ,  .     ,  ,         .     ,   TPP          . <br> <br>   : <br> <br> ({} ‚Üí nil)     ,   . (nil ‚Üí constant)    . (constant ‚Üí constant+)      (        ,  ). (constant ‚Üí scalar)    ,  . (statement ‚Üí statements)    (break, continue, return  ). (unconditional ‚Üí if)       . (scalar ‚Üí array)  / . (array ‚Üí container)     . (statement ‚Üí recursion)   . (if ‚Üí while)    . (expression ‚Üí function)   . (variable ‚Üí assignment)   . <br>        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::string expr) { return{}; }</code> <br> ,         .     . <br> <br> <s>         </s> .           .           .               .            .       . <br>  ,  <code>std::string</code>  <code>std::wstring</code> .         ,      Unicode.     . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); }</code> <br>  <code>AssertRange</code> -   ,       <code>AreEqual</code> ,   ,  ,    . <br> <br> <b class="spoiler_title">AssertRange</b> <code class="cpp">namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange</code> <br> <br>         <code>Operator</code>    .          <code>wchar_t</code>   ,         ,      . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', }; typedef Operator Token;</code> <br>    ,   ,        <code>Assert</code> ,    <code>ToString</code> ,    . <br> <br> <b class="spoiler_title">std::wstring ToString(const Token &amp;)</b> <code class="cpp">inline std::wstring ToString(const Token &amp;token) { return{ static_cast&lt;wchar_t&gt;(token) }; }</code> <br> <br>    ,   ,        .  ,   (unconditional ‚Üí if). <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { if(expr.empty()) { return{}; } return{ static_cast&lt;Operator&gt;(expr[0]) }; }</code> <br> <s>         </s> . <s>          .</s>           . ‚Ä¶ <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); }</code> <br>     .   ,     ,   - .    , : <br> <br>        ,      <code>Token</code> .       <code>dynamic_cast</code>    ,   .  ,    ,      .      <code>std::function</code>        .        .  Boost.Any,  - .            . <br>   ,   .      -  .  ,      ,      . <br> <br> ‚Ä¶        .        .        .        . <br>             . <br> <br> <code class="cpp">enum class TokenType { Operator, Number }; class Token { public: Token(Operator) {} TokenType Type() const { return TokenType::Operator; } }; ‚Ä¶ TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } };</code> <br>   <code>ToString</code>   <code>TokenType</code>       ,   ,   .     . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); }</code> <br>   .   (constant ‚Üí scalar)   . <br> <br> <code class="cpp">class Token { public: Token(Operator) :m_type(TokenType::Operator) {} Token(double) :m_type(TokenType::Number) {} TokenType Type() const { return m_type; } private: TokenType m_type; };</code> <br> ‚Ä¶ <s>       </s> . <s>       </s> .        .        . <br>    . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); }</code> <br>            . <br> <br> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} operator Operator() const { return m_operator; } ‚Ä¶ Operator m_operator; };</code> <br>      . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); }</code> <br>          ,  ,       <code>union</code> .         . <br> <br> <b class="spoiler_title">Token</b> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: return "Unknown token."; } }</code> <br> <br>  ,    ,      ,    .       .    . <br> <br> <i>          .</i>               .            .       . <br>        : <br> <br> <code class="cpp"> if(expr[0] &gt;= '0' &amp;&amp; expr[0] &lt;= '9') { return{ (double) expr[0] - '0' }; } return{ static_cast&lt;Operator&gt;(expr[0]) };</code> <br>      ,   . <br> <br> ‚Ä¶ <s>          .</s> <i>              .</i> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); }</code> <br> ,     <code>C</code>   ,  <code>isdigit</code> , ,       <code>atof</code> ,    ,      <code>wchar_t</code> .  (expression ‚Üí function).         . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { const wchar_t *current = expr.c_str(); if(!*current) return{}; if(iswdigit(*current)) return{ _wtof(current) }; return{ static_cast&lt;Operator&gt;(*current) }; }</code> <br>         .      . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>   ,        .  ,     .     .   <code>result</code> ,     . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); if(!*current) return result; if(iswdigit(*current)) { result.push_back(_wtof(current)); } else { result.push_back(static_cast&lt;Operator&gt;(*current)); } return result; }</code> <br>      :   (if ‚Üí while).     ,        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } } return result; }</code> <br>  <code>wcstod</code>    ,   <code>_wtof</code> ,           .           ,              .  ,    . <br> <br> <s>           .</s>       . <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>  (unconditional ‚Üí if)    ,    . <br> <br> <code class="cpp"> while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else if(*current == static_cast&lt;wchar_t&gt;(Operator::Plus)) { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } else { ++current; } }</code> <br>       .          .       <code>Detail</code>      .   <code>Tokenize</code>       . <br> <br> <code class="cpp">inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); }</code> <br> <b class="spoiler_title"> Detail::Tokenizer</b> <code class="cpp">namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { return *m_current == static_cast&lt;wchar_t&gt;(Operator::Plus); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail</code> <br> <br>  ,      .      ,  , .       . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); }</code> <br>      <code>Operator</code> ,    . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', };</code> <br>   .         <code>IsOperator</code>  <code>Tokenizer</code> . <br> <br> <code class="cpp"> bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); }</code> <br>         .        . <br> <br> <b class="spoiler_title">Interpreter.h</b> <code class="cpp">#pragma once; #include &lt;vector&gt; #include &lt;wchar.h&gt; #include &lt;algorithm&gt; namespace Interpreter { enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', }; inline std::wstring ToString(const Operator &amp;op) { return{ static_cast&lt;wchar_t&gt;(op) }; } enum class TokenType { Operator, Number }; inline std::wstring ToString(const TokenType &amp;type) { switch(type) { case TokenType::Operator: return L"Operator"; case TokenType::Number: return L"Number"; default: throw std::out_of_range("TokenType"); } } class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } friend inline bool operator==(const Token &amp;left, const Token &amp;right) { if(left.m_type == right.m_type) { switch(left.m_type) { case Interpreter::TokenType::Operator: return left.m_operator == right.m_operator; case Interpreter::TokenType::Number: return left.m_number == right.m_number; default: throw std::out_of_range("TokenType"); } } return false; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: throw std::out_of_range("TokenType"); } } typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); } } // namespace Lexer } // namespace Interpreter</code> <br> <br> <b class="spoiler_title">InterpreterTests.cpp</b> <code class="cpp">#include "stdafx.h" #include "CppUnitTest.h" #include "Interpreter.h" namespace InterpreterTests { using namespace Microsoft::VisualStudio::CppUnitTestFramework; using namespace Interpreter; using namespace std; namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual&lt;T&gt;(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange TEST_CLASS(LexerTests) { public: TEST_METHOD(Should_return_empty_token_list_when_put_empty_expression) { Tokens tokens = Lexer::Tokenize(L""); Assert::IsTrue(tokens.empty()); } TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); } TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); } TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); } TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); } }; TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); } TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); } TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); } }; }</code> <br> <br> <a href="https://github.com/Unril/InterpreterTDD/releases/tag/%25D0%259A%25D0%25BE%25D0%25BD%25D0%25B5%25D1%2586_%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B2%25D0%25BE%25D0%25B9_%25D1%2587%25D0%25B0%25D1%2581%25D1%2582%25D0%25B8">    GitHub</a> .         ,  .      "__". <br> <br>   <a href="http://habrahabr.ru/post/232081/">    </a> .      ,      <a href="http://habrahabr.ru/post/232097/">    </a> .</code> <pre> <code class="hljs lua"><code>std::vector,      Tokens</code> .            . <br> <br> <code class="cpp">#pragma once; #include &lt;vector&gt; namespace Interpreter { struct Token {}; typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { inline Tokens Tokenize(std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> expr) { throw std::exception(); } } // namespace Lexer } // namespace Interpreter</code> <br>   ,  ,   , .   ,    ,    <a href="http://cleancoder.posterous.com/the-transformation-priority-premise">The Transformation Priority Premise (TPP)</a>   .    , ,    ,     ,        .            .     ,     ,      ,           .  ,  ,   (   )    ,  ,  .     ,  ,         .     ,   TPP          . <br> <br>   : <br> <br> ({} ‚Üí <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)     ,   . (<span class="hljs-literal"><span class="hljs-literal">nil</span></span> ‚Üí constant)    . (constant ‚Üí constant+)      (        ,  ). (constant ‚Üí scalar)    ,  . (statement ‚Üí statements)    (<span class="hljs-keyword"><span class="hljs-keyword">break</span></span>, continue, <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>  ). (unconditional ‚Üí <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>)       . (scalar ‚Üí array)  / . (array ‚Üí container)     . (statement ‚Üí recursion)   . (<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ‚Üí <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>)    . (expression ‚Üí <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">)</span></span>   . (variable ‚Üí assignment)   . <br>        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> expr) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{}; }</code> <br> ,         .     . <br> <br> <s>         </s> .           .           .               .            .       . <br>  ,  <code>std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span></code>  <code>std::wstring</code> .         ,      Unicode.     . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"+"</span></span>); AssertRange::AreEqual({ Operator::Plus }, tokens); }</code> <br>  <code>AssertRange</code> -   ,       <code>AreEqual</code> ,   ,  ,    . <br> <br> <b class="spoiler_title">AssertRange</b> <code class="cpp">namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(expect)), distance(actualIter, <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(actual)), L<span class="hljs-string"><span class="hljs-string">"Size differs."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(; expectIter != <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(expect) &amp;&amp; actualIter != <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(actual); ++expectIter, ++actualIter) { auto message = L<span class="hljs-string"><span class="hljs-string">"Mismatch in position "</span></span> + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange</code> <br> <br>         <code>Operator</code>    .          <code>wchar_t</code>   ,         ,      . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L<span class="hljs-string"><span class="hljs-string">'+'</span></span>, }; typedef Operator Token;</code> <br>    ,   ,        <code>Assert</code> ,    <code>ToString</code> ,    . <br> <br> <b class="spoiler_title">std::wstring ToString(const Token &amp;)</b> <code class="cpp">inline std::wstring ToString(const Token &amp;token) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ static_cast&lt;wchar_t&gt;(token) }; }</code> <br> <br>    ,   ,        .  ,   (unconditional ‚Üí <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>). <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(expr.empty()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{}; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ static_cast&lt;Operator&gt;(expr[<span class="hljs-number"><span class="hljs-number">0</span></span>]) }; }</code> <br> <s>         </s> . <s>          .</s>           . ‚Ä¶ <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"1"</span></span>); AssertRange::AreEqual({ <span class="hljs-number"><span class="hljs-number">1.0</span></span> }, tokens); }</code> <br>     .   ,     ,   - .    , : <br> <br>        ,      <code>Token</code> .       <code>dynamic_cast</code>    ,   .  ,    ,      .      <code>std::<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span></span></code><span class="hljs-function"><span class="hljs-function">        .        .  </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Boost.Any</span></span></span><span class="hljs-function">,  - .            . </span></span><br><span class="hljs-function"><span class="hljs-function">   ,   .      -  .  ,      ,      . </span></span><br><span class="hljs-function"><span class="hljs-function"> </span></span><br><span class="hljs-function"><span class="hljs-function"> ‚Ä¶        .        .        .        . </span></span><br><span class="hljs-function"><span class="hljs-function">             . </span></span><br><span class="hljs-function"><span class="hljs-function"> </span></span><br><span class="hljs-function"><span class="hljs-function"> </span></span><code class="cpp"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">enum</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">class</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TokenType</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Operator</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Number</span></span></span><span class="hljs-function"> }; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">class</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Token</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">public</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Token</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Operator)</span></span></span></span> {} TokenType Type() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TokenType::Operator; } }; ‚Ä¶ TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } };</code> <br>   <code>ToString</code>   <code>TokenType</code>       ,   ,   .     . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_type_for_number_token) { Token numToken(<span class="hljs-number"><span class="hljs-number">1.2</span></span>); Assert::AreEqual(TokenType::Number, numToken.Type()); }</code> <br>   .   (constant ‚Üí scalar)   . <br> <br> <code class="cpp">class Token { public: Token(Operator) :m_type(TokenType::Operator) {} Token(double) :m_type(TokenType::Number) {} TokenType Type() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_type; } private: TokenType m_type; };</code> <br> ‚Ä¶ <s>       </s> . <s>       </s> .        .        . <br>    . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); }</code> <br>            . <br> <br> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} operator Operator() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_operator; } ‚Ä¶ Operator m_operator; };</code> <br>      . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_number_value_from_number_token) { Token token(<span class="hljs-number"><span class="hljs-number">1.23</span></span>); Assert::AreEqual&lt;double&gt;(<span class="hljs-number"><span class="hljs-number">1.23</span></span>, token); }</code> <br>          ,  ,       <code>union</code> .         . <br> <br> <b class="spoiler_title">Token</b> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_type; } operator Operator() const { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(m_type != TokenType::Operator) throw std::logic_error(<span class="hljs-string"><span class="hljs-string">"Should be operator token."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_operator; } operator double() const { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(m_type != TokenType::Number) throw std::logic_error(<span class="hljs-string"><span class="hljs-string">"Should be number token."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_number; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ToString(static_cast&lt;Operator&gt;(token)); default: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Unknown token."</span></span>; } }</code> <br> <br>  ,    ,      ,    .       .    . <br> <br> <i>          .</i>               .            .       . <br>        : <br> <br> <code class="cpp"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(expr[<span class="hljs-number"><span class="hljs-number">0</span></span>] &gt;= <span class="hljs-string"><span class="hljs-string">'0'</span></span> &amp;&amp; expr[<span class="hljs-number"><span class="hljs-number">0</span></span>] &lt;= <span class="hljs-string"><span class="hljs-string">'9'</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ (double) expr[<span class="hljs-number"><span class="hljs-number">0</span></span>] - <span class="hljs-string"><span class="hljs-string">'0'</span></span> }; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ static_cast&lt;Operator&gt;(expr[<span class="hljs-number"><span class="hljs-number">0</span></span>]) };</code> <br>      ,   . <br> <br> ‚Ä¶ <s>          .</s> <i>              .</i> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"12.34"</span></span>); AssertRange::AreEqual({ <span class="hljs-number"><span class="hljs-number">12.34</span></span> }, tokens); }</code> <br> ,     <code>C</code>   ,  <code>isdigit</code> , ,       <code>atof</code> ,    ,      <code>wchar_t</code> .  (expression ‚Üí <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">)</span></span>.         . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { const wchar_t *current = expr.c_str(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!*current) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{}; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(iswdigit(*current)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ _wtof(current) }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ static_cast&lt;Operator&gt;(*current) }; }</code> <br>         .      . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"+12.34"</span></span>); AssertRange::AreEqual({ Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">12.34</span></span>) }, tokens); }</code> <br>   ,        .  ,     .     .   <code>result</code> ,     . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!*current) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(iswdigit(*current)) { result.push_back(_wtof(current)); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { result.push_back(static_cast&lt;Operator&gt;(*current)); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> <br>      :   (<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ‚Üí <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>).     ,        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(*current) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(iswdigit(*current)) { wchar_t *<span class="hljs-keyword"><span class="hljs-keyword">end</span></span> = nullptr; result.push_back(wcstod(current, &amp;<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>)); current = <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> <br>  <code>wcstod</code>    ,   <code>_wtof</code> ,           .           ,              .  ,    . <br> <br> <s>           .</s>       . <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">" 1 + 12.34 "</span></span>); AssertRange::AreEqual({ Token(<span class="hljs-number"><span class="hljs-number">1.0</span></span>), Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">12.34</span></span>) }, tokens); }</code> <br>  (unconditional ‚Üí <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>)    ,    . <br> <br> <code class="cpp"> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(*current) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(iswdigit(*current)) { wchar_t *<span class="hljs-keyword"><span class="hljs-keyword">end</span></span> = nullptr; result.push_back(wcstod(current, &amp;<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>)); current = <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(*current == static_cast&lt;wchar_t&gt;(Operator::Plus)) { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { ++current; } }</code> <br>       .          .       <code>Detail</code>      .   <code>Tokenize</code>       . <br> <br> <code class="cpp">inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tokenizer.Result(); }</code> <br> <b class="spoiler_title"> Detail::Tokenizer</b> <code class="cpp">namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!EndOfExperssion()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(IsNumber()) { ScanNumber(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(IsOperator()) { ScanOperator(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { MoveNext(); } } } const Tokens &amp;Result() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_result; } private: bool EndOfExperssion() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_current == L<span class="hljs-string"><span class="hljs-string">'\0'</span></span>; } bool IsNumber() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> iswdigit(*m_current) != <span class="hljs-number"><span class="hljs-number">0</span></span>; } void ScanNumber() { wchar_t *<span class="hljs-keyword"><span class="hljs-keyword">end</span></span> = nullptr; m_result.push_back(wcstod(m_current, &amp;<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>)); m_current = <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; } bool IsOperator() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_current == static_cast&lt;wchar_t&gt;(Operator::Plus); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail</code> <br> <br>  ,      .      ,  , .       . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"1+2*3/(4-5)"</span></span>); AssertRange::AreEqual({ Token(<span class="hljs-number"><span class="hljs-number">1</span></span>), Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">2</span></span>), Token(Operator::Mul), Token(<span class="hljs-number"><span class="hljs-number">3</span></span>), Token(Operator::Div), Token(Operator::LParen), Token(<span class="hljs-number"><span class="hljs-number">4</span></span>), Token(Operator::Minus), Token(<span class="hljs-number"><span class="hljs-number">5</span></span>), Token(Operator::RParen) }, tokens); }</code> <br>      <code>Operator</code> ,    . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L<span class="hljs-string"><span class="hljs-string">'+'</span></span>, Minus = L<span class="hljs-string"><span class="hljs-string">'-'</span></span>, Mul = L<span class="hljs-string"><span class="hljs-string">'*'</span></span>, Div = L<span class="hljs-string"><span class="hljs-string">'/'</span></span>, LParen = L<span class="hljs-string"><span class="hljs-string">'('</span></span>, RParen = L<span class="hljs-string"><span class="hljs-string">')'</span></span>, };</code> <br>   .         <code>IsOperator</code>  <code>Tokenizer</code> . <br> <br> <code class="cpp"> bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> std::any_of(all.begin(), all.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(), [this](Operator o) {<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_current == static_cast&lt;wchar_t&gt;(o); }); }</code> <br>         .        . <br> <br> <b class="spoiler_title">Interpreter.h</b> <code class="cpp">#pragma once; #include &lt;vector&gt; #include &lt;wchar.h&gt; #include &lt;algorithm&gt; namespace Interpreter { enum class Operator : wchar_t { Plus = L<span class="hljs-string"><span class="hljs-string">'+'</span></span>, Minus = L<span class="hljs-string"><span class="hljs-string">'-'</span></span>, Mul = L<span class="hljs-string"><span class="hljs-string">'*'</span></span>, Div = L<span class="hljs-string"><span class="hljs-string">'/'</span></span>, LParen = L<span class="hljs-string"><span class="hljs-string">'('</span></span>, RParen = L<span class="hljs-string"><span class="hljs-string">')'</span></span>, }; inline std::wstring ToString(const Operator &amp;op) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ static_cast&lt;wchar_t&gt;(op) }; } enum class TokenType { Operator, Number }; inline std::wstring ToString(const TokenType &amp;<span class="hljs-built_in"><span class="hljs-built_in">type</span></span>) { switch(<span class="hljs-built_in"><span class="hljs-built_in">type</span></span>) { case TokenType::Operator: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> L<span class="hljs-string"><span class="hljs-string">"Operator"</span></span>; case TokenType::Number: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> L<span class="hljs-string"><span class="hljs-string">"Number"</span></span>; default: throw std::out_of_range(<span class="hljs-string"><span class="hljs-string">"TokenType"</span></span>); } } class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_type; } operator Operator() const { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(m_type != TokenType::Operator) throw std::logic_error(<span class="hljs-string"><span class="hljs-string">"Should be operator token."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_operator; } operator double() const { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(m_type != TokenType::Number) throw std::logic_error(<span class="hljs-string"><span class="hljs-string">"Should be number token."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_number; } friend inline bool operator==(const Token &amp;left, const Token &amp;right) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(left.m_type == right.m_type) { switch(left.m_type) { case Interpreter::TokenType::Operator: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> left.m_operator == right.m_operator; case Interpreter::TokenType::Number: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> left.m_number == right.m_number; default: throw std::out_of_range(<span class="hljs-string"><span class="hljs-string">"TokenType"</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ToString(static_cast&lt;Operator&gt;(token)); default: throw std::out_of_range(<span class="hljs-string"><span class="hljs-string">"TokenType"</span></span>); } } typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!EndOfExperssion()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(IsNumber()) { ScanNumber(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(IsOperator()) { ScanOperator(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { MoveNext(); } } } const Tokens &amp;Result() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_result; } private: bool EndOfExperssion() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_current == L<span class="hljs-string"><span class="hljs-string">'\0'</span></span>; } bool IsNumber() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> iswdigit(*m_current) != <span class="hljs-number"><span class="hljs-number">0</span></span>; } void ScanNumber() { wchar_t *<span class="hljs-keyword"><span class="hljs-keyword">end</span></span> = nullptr; m_result.push_back(wcstod(m_current, &amp;<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>)); m_current = <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; } bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> std::any_of(all.begin(), all.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(), [this](Operator o) {<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_current == static_cast&lt;wchar_t&gt;(o); }); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tokenizer.Result(); } } // namespace Lexer } // namespace Interpreter</code> <br> <br> <b class="spoiler_title">InterpreterTests.cpp</b> <code class="cpp">#include <span class="hljs-string"><span class="hljs-string">"stdafx.h"</span></span> #include <span class="hljs-string"><span class="hljs-string">"CppUnitTest.h"</span></span> #include <span class="hljs-string"><span class="hljs-string">"Interpreter.h"</span></span> namespace InterpreterTests { using namespace Microsoft::VisualStudio::CppUnitTestFramework; using namespace Interpreter; using namespace std; namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(expect)), distance(actualIter, <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(actual)), L<span class="hljs-string"><span class="hljs-string">"Size differs."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(; expectIter != <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(expect) &amp;&amp; actualIter != <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(actual); ++expectIter, ++actualIter) { auto message = L<span class="hljs-string"><span class="hljs-string">"Mismatch in position "</span></span> + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual&lt;T&gt;(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange TEST_CLASS(LexerTests) { public: TEST_METHOD(Should_return_empty_token_list_when_put_empty_expression) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">""</span></span>); Assert::IsTrue(tokens.empty()); } TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"+"</span></span>); AssertRange::AreEqual({ Operator::Plus }, tokens); } TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"1"</span></span>); AssertRange::AreEqual({ <span class="hljs-number"><span class="hljs-number">1.0</span></span> }, tokens); } TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"12.34"</span></span>); AssertRange::AreEqual({ <span class="hljs-number"><span class="hljs-number">12.34</span></span> }, tokens); } TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"+12.34"</span></span>); AssertRange::AreEqual({ Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">12.34</span></span>) }, tokens); } TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">" 1 + 12.34 "</span></span>); AssertRange::AreEqual({ Token(<span class="hljs-number"><span class="hljs-number">1.0</span></span>), Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">12.34</span></span>) }, tokens); } TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"1+2*3/(4-5)"</span></span>); AssertRange::AreEqual({ Token(<span class="hljs-number"><span class="hljs-number">1</span></span>), Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">2</span></span>), Token(Operator::Mul), Token(<span class="hljs-number"><span class="hljs-number">3</span></span>), Token(Operator::Div), Token(Operator::LParen), Token(<span class="hljs-number"><span class="hljs-number">4</span></span>), Token(Operator::Minus), Token(<span class="hljs-number"><span class="hljs-number">5</span></span>), Token(Operator::RParen) }, tokens); } }; TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } TEST_METHOD(Should_get_type_for_number_token) { Token numToken(<span class="hljs-number"><span class="hljs-number">1.2</span></span>); Assert::AreEqual(TokenType::Number, numToken.Type()); } TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); } TEST_METHOD(Should_get_number_value_from_number_token) { Token token(<span class="hljs-number"><span class="hljs-number">1.23</span></span>); Assert::AreEqual&lt;double&gt;(<span class="hljs-number"><span class="hljs-number">1.23</span></span>, token); } }; }</code> <br> <br> <a href="https://github.com/Unril/InterpreterTDD/releases/tag/%25D0%259A%25D0%25BE%25D0%25BD%25D0%25B5%25D1%2586_%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B2%25D0%25BE%25D0%25B9_%25D1%2587%25D0%25B0%25D1%2581%25D1%2582%25D0%25B8">    GitHub</a> .         ,  .      <span class="hljs-string"><span class="hljs-string">"__"</span></span>. <br> <br>   <a href="http://habrahabr.ru/post/232081/">    </a> .      ,      <a href="http://habrahabr.ru/post/232097/">    </a> .</code> </pre> <code><code>std::vector,      Tokens</code> .            . <br> <br> <code class="cpp">#pragma once; #include &lt;vector&gt; namespace Interpreter { struct Token {}; typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { inline Tokens Tokenize(std::string expr) { throw std::exception(); } } // namespace Lexer } // namespace Interpreter</code> <br>   ,  ,   , .   ,    ,    <a href="http://cleancoder.posterous.com/the-transformation-priority-premise">The Transformation Priority Premise (TPP)</a>   .    , ,    ,     ,        .            .     ,     ,      ,           .  ,  ,   (   )    ,  ,  .     ,  ,         .     ,   TPP          . <br> <br>   : <br> <br> ({} ‚Üí nil)     ,   . (nil ‚Üí constant)    . (constant ‚Üí constant+)      (        ,  ). (constant ‚Üí scalar)    ,  . (statement ‚Üí statements)    (break, continue, return  ). (unconditional ‚Üí if)       . (scalar ‚Üí array)  / . (array ‚Üí container)     . (statement ‚Üí recursion)   . (if ‚Üí while)    . (expression ‚Üí function)   . (variable ‚Üí assignment)   . <br>        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::string expr) { return{}; }</code> <br> ,         .     . <br> <br> <s>         </s> .           .           .               .            .       . <br>  ,  <code>std::string</code>  <code>std::wstring</code> .         ,      Unicode.     . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); }</code> <br>  <code>AssertRange</code> -   ,       <code>AreEqual</code> ,   ,  ,    . <br> <br> <b class="spoiler_title">AssertRange</b> <code class="cpp">namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange</code> <br> <br>         <code>Operator</code>    .          <code>wchar_t</code>   ,         ,      . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', }; typedef Operator Token;</code> <br>    ,   ,        <code>Assert</code> ,    <code>ToString</code> ,    . <br> <br> <b class="spoiler_title">std::wstring ToString(const Token &amp;)</b> <code class="cpp">inline std::wstring ToString(const Token &amp;token) { return{ static_cast&lt;wchar_t&gt;(token) }; }</code> <br> <br>    ,   ,        .  ,   (unconditional ‚Üí if). <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { if(expr.empty()) { return{}; } return{ static_cast&lt;Operator&gt;(expr[0]) }; }</code> <br> <s>         </s> . <s>          .</s>           . ‚Ä¶ <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); }</code> <br>     .   ,     ,   - .    , : <br> <br>        ,      <code>Token</code> .       <code>dynamic_cast</code>    ,   .  ,    ,      .      <code>std::function</code>        .        .  Boost.Any,  - .            . <br>   ,   .      -  .  ,      ,      . <br> <br> ‚Ä¶        .        .        .        . <br>             . <br> <br> <code class="cpp">enum class TokenType { Operator, Number }; class Token { public: Token(Operator) {} TokenType Type() const { return TokenType::Operator; } }; ‚Ä¶ TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } };</code> <br>   <code>ToString</code>   <code>TokenType</code>       ,   ,   .     . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); }</code> <br>   .   (constant ‚Üí scalar)   . <br> <br> <code class="cpp">class Token { public: Token(Operator) :m_type(TokenType::Operator) {} Token(double) :m_type(TokenType::Number) {} TokenType Type() const { return m_type; } private: TokenType m_type; };</code> <br> ‚Ä¶ <s>       </s> . <s>       </s> .        .        . <br>    . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); }</code> <br>            . <br> <br> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} operator Operator() const { return m_operator; } ‚Ä¶ Operator m_operator; };</code> <br>      . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); }</code> <br>          ,  ,       <code>union</code> .         . <br> <br> <b class="spoiler_title">Token</b> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: return "Unknown token."; } }</code> <br> <br>  ,    ,      ,    .       .    . <br> <br> <i>          .</i>               .            .       . <br>        : <br> <br> <code class="cpp"> if(expr[0] &gt;= '0' &amp;&amp; expr[0] &lt;= '9') { return{ (double) expr[0] - '0' }; } return{ static_cast&lt;Operator&gt;(expr[0]) };</code> <br>      ,   . <br> <br> ‚Ä¶ <s>          .</s> <i>              .</i> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); }</code> <br> ,     <code>C</code>   ,  <code>isdigit</code> , ,       <code>atof</code> ,    ,      <code>wchar_t</code> .  (expression ‚Üí function).         . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { const wchar_t *current = expr.c_str(); if(!*current) return{}; if(iswdigit(*current)) return{ _wtof(current) }; return{ static_cast&lt;Operator&gt;(*current) }; }</code> <br>         .      . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>   ,        .  ,     .     .   <code>result</code> ,     . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); if(!*current) return result; if(iswdigit(*current)) { result.push_back(_wtof(current)); } else { result.push_back(static_cast&lt;Operator&gt;(*current)); } return result; }</code> <br>      :   (if ‚Üí while).     ,        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } } return result; }</code> <br>  <code>wcstod</code>    ,   <code>_wtof</code> ,           .           ,              .  ,    . <br> <br> <s>           .</s>       . <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>  (unconditional ‚Üí if)    ,    . <br> <br> <code class="cpp"> while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else if(*current == static_cast&lt;wchar_t&gt;(Operator::Plus)) { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } else { ++current; } }</code> <br>       .          .       <code>Detail</code>      .   <code>Tokenize</code>       . <br> <br> <code class="cpp">inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); }</code> <br> <b class="spoiler_title"> Detail::Tokenizer</b> <code class="cpp">namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { return *m_current == static_cast&lt;wchar_t&gt;(Operator::Plus); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail</code> <br> <br>  ,      .      ,  , .       . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); }</code> <br>      <code>Operator</code> ,    . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', };</code> <br>   .         <code>IsOperator</code>  <code>Tokenizer</code> . <br> <br> <code class="cpp"> bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); }</code> <br>         .        . <br> <br> <b class="spoiler_title">Interpreter.h</b> <code class="cpp">#pragma once; #include &lt;vector&gt; #include &lt;wchar.h&gt; #include &lt;algorithm&gt; namespace Interpreter { enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', }; inline std::wstring ToString(const Operator &amp;op) { return{ static_cast&lt;wchar_t&gt;(op) }; } enum class TokenType { Operator, Number }; inline std::wstring ToString(const TokenType &amp;type) { switch(type) { case TokenType::Operator: return L"Operator"; case TokenType::Number: return L"Number"; default: throw std::out_of_range("TokenType"); } } class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } friend inline bool operator==(const Token &amp;left, const Token &amp;right) { if(left.m_type == right.m_type) { switch(left.m_type) { case Interpreter::TokenType::Operator: return left.m_operator == right.m_operator; case Interpreter::TokenType::Number: return left.m_number == right.m_number; default: throw std::out_of_range("TokenType"); } } return false; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: throw std::out_of_range("TokenType"); } } typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); } } // namespace Lexer } // namespace Interpreter</code> <br> <br> <b class="spoiler_title">InterpreterTests.cpp</b> <code class="cpp">#include "stdafx.h" #include "CppUnitTest.h" #include "Interpreter.h" namespace InterpreterTests { using namespace Microsoft::VisualStudio::CppUnitTestFramework; using namespace Interpreter; using namespace std; namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual&lt;T&gt;(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange TEST_CLASS(LexerTests) { public: TEST_METHOD(Should_return_empty_token_list_when_put_empty_expression) { Tokens tokens = Lexer::Tokenize(L""); Assert::IsTrue(tokens.empty()); } TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); } TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); } TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); } TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); } }; TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); } TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); } TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); } }; }</code> <br> <br> <a href="https://github.com/Unril/InterpreterTDD/releases/tag/%25D0%259A%25D0%25BE%25D0%25BD%25D0%25B5%25D1%2586_%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B2%25D0%25BE%25D0%25B9_%25D1%2587%25D0%25B0%25D1%2581%25D1%2582%25D0%25B8">    GitHub</a> .         ,  .      "__". <br> <br>   <a href="http://habrahabr.ru/post/232081/">    </a> .      ,      <a href="http://habrahabr.ru/post/232097/">    </a> .</code> <pre> <code class="hljs lua"><code>std::vector,      Tokens</code> .            . <br> <br> <code class="cpp">#pragma once; #include &lt;vector&gt; namespace Interpreter { struct Token {}; typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { inline Tokens Tokenize(std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> expr) { throw std::exception(); } } // namespace Lexer } // namespace Interpreter</code> <br>   ,  ,   , .   ,    ,    <a href="http://cleancoder.posterous.com/the-transformation-priority-premise">The Transformation Priority Premise (TPP)</a>   .    , ,    ,     ,        .            .     ,     ,      ,           .  ,  ,   (   )    ,  ,  .     ,  ,         .     ,   TPP          . <br> <br>   : <br> <br> ({} ‚Üí <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)     ,   . (<span class="hljs-literal"><span class="hljs-literal">nil</span></span> ‚Üí constant)    . (constant ‚Üí constant+)      (        ,  ). (constant ‚Üí scalar)    ,  . (statement ‚Üí statements)    (<span class="hljs-keyword"><span class="hljs-keyword">break</span></span>, continue, <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>  ). (unconditional ‚Üí <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>)       . (scalar ‚Üí array)  / . (array ‚Üí container)     . (statement ‚Üí recursion)   . (<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ‚Üí <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>)    . (expression ‚Üí <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">)</span></span>   . (variable ‚Üí assignment)   . <br>        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> expr) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{}; }</code> <br> ,         .     . <br> <br> <s>         </s> .           .           .               .            .       . <br>  ,  <code>std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span></code>  <code>std::wstring</code> .         ,      Unicode.     . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"+"</span></span>); AssertRange::AreEqual({ Operator::Plus }, tokens); }</code> <br>  <code>AssertRange</code> -   ,       <code>AreEqual</code> ,   ,  ,    . <br> <br> <b class="spoiler_title">AssertRange</b> <code class="cpp">namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(expect)), distance(actualIter, <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(actual)), L<span class="hljs-string"><span class="hljs-string">"Size differs."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(; expectIter != <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(expect) &amp;&amp; actualIter != <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(actual); ++expectIter, ++actualIter) { auto message = L<span class="hljs-string"><span class="hljs-string">"Mismatch in position "</span></span> + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange</code> <br> <br>         <code>Operator</code>    .          <code>wchar_t</code>   ,         ,      . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L<span class="hljs-string"><span class="hljs-string">'+'</span></span>, }; typedef Operator Token;</code> <br>    ,   ,        <code>Assert</code> ,    <code>ToString</code> ,    . <br> <br> <b class="spoiler_title">std::wstring ToString(const Token &amp;)</b> <code class="cpp">inline std::wstring ToString(const Token &amp;token) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ static_cast&lt;wchar_t&gt;(token) }; }</code> <br> <br>    ,   ,        .  ,   (unconditional ‚Üí <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>). <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(expr.empty()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{}; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ static_cast&lt;Operator&gt;(expr[<span class="hljs-number"><span class="hljs-number">0</span></span>]) }; }</code> <br> <s>         </s> . <s>          .</s>           . ‚Ä¶ <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"1"</span></span>); AssertRange::AreEqual({ <span class="hljs-number"><span class="hljs-number">1.0</span></span> }, tokens); }</code> <br>     .   ,     ,   - .    , : <br> <br>        ,      <code>Token</code> .       <code>dynamic_cast</code>    ,   .  ,    ,      .      <code>std::<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span></span></code><span class="hljs-function"><span class="hljs-function">        .        .  </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Boost.Any</span></span></span><span class="hljs-function">,  - .            . </span></span><br><span class="hljs-function"><span class="hljs-function">   ,   .      -  .  ,      ,      . </span></span><br><span class="hljs-function"><span class="hljs-function"> </span></span><br><span class="hljs-function"><span class="hljs-function"> ‚Ä¶        .        .        .        . </span></span><br><span class="hljs-function"><span class="hljs-function">             . </span></span><br><span class="hljs-function"><span class="hljs-function"> </span></span><br><span class="hljs-function"><span class="hljs-function"> </span></span><code class="cpp"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">enum</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">class</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TokenType</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Operator</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Number</span></span></span><span class="hljs-function"> }; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">class</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Token</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">public</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Token</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Operator)</span></span></span></span> {} TokenType Type() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TokenType::Operator; } }; ‚Ä¶ TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } };</code> <br>   <code>ToString</code>   <code>TokenType</code>       ,   ,   .     . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_type_for_number_token) { Token numToken(<span class="hljs-number"><span class="hljs-number">1.2</span></span>); Assert::AreEqual(TokenType::Number, numToken.Type()); }</code> <br>   .   (constant ‚Üí scalar)   . <br> <br> <code class="cpp">class Token { public: Token(Operator) :m_type(TokenType::Operator) {} Token(double) :m_type(TokenType::Number) {} TokenType Type() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_type; } private: TokenType m_type; };</code> <br> ‚Ä¶ <s>       </s> . <s>       </s> .        .        . <br>    . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); }</code> <br>            . <br> <br> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} operator Operator() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_operator; } ‚Ä¶ Operator m_operator; };</code> <br>      . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_number_value_from_number_token) { Token token(<span class="hljs-number"><span class="hljs-number">1.23</span></span>); Assert::AreEqual&lt;double&gt;(<span class="hljs-number"><span class="hljs-number">1.23</span></span>, token); }</code> <br>          ,  ,       <code>union</code> .         . <br> <br> <b class="spoiler_title">Token</b> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_type; } operator Operator() const { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(m_type != TokenType::Operator) throw std::logic_error(<span class="hljs-string"><span class="hljs-string">"Should be operator token."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_operator; } operator double() const { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(m_type != TokenType::Number) throw std::logic_error(<span class="hljs-string"><span class="hljs-string">"Should be number token."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_number; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ToString(static_cast&lt;Operator&gt;(token)); default: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Unknown token."</span></span>; } }</code> <br> <br>  ,    ,      ,    .       .    . <br> <br> <i>          .</i>               .            .       . <br>        : <br> <br> <code class="cpp"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(expr[<span class="hljs-number"><span class="hljs-number">0</span></span>] &gt;= <span class="hljs-string"><span class="hljs-string">'0'</span></span> &amp;&amp; expr[<span class="hljs-number"><span class="hljs-number">0</span></span>] &lt;= <span class="hljs-string"><span class="hljs-string">'9'</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ (double) expr[<span class="hljs-number"><span class="hljs-number">0</span></span>] - <span class="hljs-string"><span class="hljs-string">'0'</span></span> }; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ static_cast&lt;Operator&gt;(expr[<span class="hljs-number"><span class="hljs-number">0</span></span>]) };</code> <br>      ,   . <br> <br> ‚Ä¶ <s>          .</s> <i>              .</i> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"12.34"</span></span>); AssertRange::AreEqual({ <span class="hljs-number"><span class="hljs-number">12.34</span></span> }, tokens); }</code> <br> ,     <code>C</code>   ,  <code>isdigit</code> , ,       <code>atof</code> ,    ,      <code>wchar_t</code> .  (expression ‚Üí <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">)</span></span>.         . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { const wchar_t *current = expr.c_str(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!*current) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{}; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(iswdigit(*current)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ _wtof(current) }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ static_cast&lt;Operator&gt;(*current) }; }</code> <br>         .      . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"+12.34"</span></span>); AssertRange::AreEqual({ Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">12.34</span></span>) }, tokens); }</code> <br>   ,        .  ,     .     .   <code>result</code> ,     . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!*current) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(iswdigit(*current)) { result.push_back(_wtof(current)); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { result.push_back(static_cast&lt;Operator&gt;(*current)); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> <br>      :   (<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ‚Üí <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>).     ,        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(*current) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(iswdigit(*current)) { wchar_t *<span class="hljs-keyword"><span class="hljs-keyword">end</span></span> = nullptr; result.push_back(wcstod(current, &amp;<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>)); current = <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> <br>  <code>wcstod</code>    ,   <code>_wtof</code> ,           .           ,              .  ,    . <br> <br> <s>           .</s>       . <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">" 1 + 12.34 "</span></span>); AssertRange::AreEqual({ Token(<span class="hljs-number"><span class="hljs-number">1.0</span></span>), Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">12.34</span></span>) }, tokens); }</code> <br>  (unconditional ‚Üí <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>)    ,    . <br> <br> <code class="cpp"> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(*current) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(iswdigit(*current)) { wchar_t *<span class="hljs-keyword"><span class="hljs-keyword">end</span></span> = nullptr; result.push_back(wcstod(current, &amp;<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>)); current = <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(*current == static_cast&lt;wchar_t&gt;(Operator::Plus)) { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { ++current; } }</code> <br>       .          .       <code>Detail</code>      .   <code>Tokenize</code>       . <br> <br> <code class="cpp">inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tokenizer.Result(); }</code> <br> <b class="spoiler_title"> Detail::Tokenizer</b> <code class="cpp">namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!EndOfExperssion()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(IsNumber()) { ScanNumber(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(IsOperator()) { ScanOperator(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { MoveNext(); } } } const Tokens &amp;Result() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_result; } private: bool EndOfExperssion() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_current == L<span class="hljs-string"><span class="hljs-string">'\0'</span></span>; } bool IsNumber() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> iswdigit(*m_current) != <span class="hljs-number"><span class="hljs-number">0</span></span>; } void ScanNumber() { wchar_t *<span class="hljs-keyword"><span class="hljs-keyword">end</span></span> = nullptr; m_result.push_back(wcstod(m_current, &amp;<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>)); m_current = <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; } bool IsOperator() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_current == static_cast&lt;wchar_t&gt;(Operator::Plus); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail</code> <br> <br>  ,      .      ,  , .       . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"1+2*3/(4-5)"</span></span>); AssertRange::AreEqual({ Token(<span class="hljs-number"><span class="hljs-number">1</span></span>), Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">2</span></span>), Token(Operator::Mul), Token(<span class="hljs-number"><span class="hljs-number">3</span></span>), Token(Operator::Div), Token(Operator::LParen), Token(<span class="hljs-number"><span class="hljs-number">4</span></span>), Token(Operator::Minus), Token(<span class="hljs-number"><span class="hljs-number">5</span></span>), Token(Operator::RParen) }, tokens); }</code> <br>      <code>Operator</code> ,    . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L<span class="hljs-string"><span class="hljs-string">'+'</span></span>, Minus = L<span class="hljs-string"><span class="hljs-string">'-'</span></span>, Mul = L<span class="hljs-string"><span class="hljs-string">'*'</span></span>, Div = L<span class="hljs-string"><span class="hljs-string">'/'</span></span>, LParen = L<span class="hljs-string"><span class="hljs-string">'('</span></span>, RParen = L<span class="hljs-string"><span class="hljs-string">')'</span></span>, };</code> <br>   .         <code>IsOperator</code>  <code>Tokenizer</code> . <br> <br> <code class="cpp"> bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> std::any_of(all.begin(), all.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(), [this](Operator o) {<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_current == static_cast&lt;wchar_t&gt;(o); }); }</code> <br>         .        . <br> <br> <b class="spoiler_title">Interpreter.h</b> <code class="cpp">#pragma once; #include &lt;vector&gt; #include &lt;wchar.h&gt; #include &lt;algorithm&gt; namespace Interpreter { enum class Operator : wchar_t { Plus = L<span class="hljs-string"><span class="hljs-string">'+'</span></span>, Minus = L<span class="hljs-string"><span class="hljs-string">'-'</span></span>, Mul = L<span class="hljs-string"><span class="hljs-string">'*'</span></span>, Div = L<span class="hljs-string"><span class="hljs-string">'/'</span></span>, LParen = L<span class="hljs-string"><span class="hljs-string">'('</span></span>, RParen = L<span class="hljs-string"><span class="hljs-string">')'</span></span>, }; inline std::wstring ToString(const Operator &amp;op) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ static_cast&lt;wchar_t&gt;(op) }; } enum class TokenType { Operator, Number }; inline std::wstring ToString(const TokenType &amp;<span class="hljs-built_in"><span class="hljs-built_in">type</span></span>) { switch(<span class="hljs-built_in"><span class="hljs-built_in">type</span></span>) { case TokenType::Operator: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> L<span class="hljs-string"><span class="hljs-string">"Operator"</span></span>; case TokenType::Number: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> L<span class="hljs-string"><span class="hljs-string">"Number"</span></span>; default: throw std::out_of_range(<span class="hljs-string"><span class="hljs-string">"TokenType"</span></span>); } } class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_type; } operator Operator() const { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(m_type != TokenType::Operator) throw std::logic_error(<span class="hljs-string"><span class="hljs-string">"Should be operator token."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_operator; } operator double() const { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(m_type != TokenType::Number) throw std::logic_error(<span class="hljs-string"><span class="hljs-string">"Should be number token."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_number; } friend inline bool operator==(const Token &amp;left, const Token &amp;right) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(left.m_type == right.m_type) { switch(left.m_type) { case Interpreter::TokenType::Operator: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> left.m_operator == right.m_operator; case Interpreter::TokenType::Number: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> left.m_number == right.m_number; default: throw std::out_of_range(<span class="hljs-string"><span class="hljs-string">"TokenType"</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ToString(static_cast&lt;Operator&gt;(token)); default: throw std::out_of_range(<span class="hljs-string"><span class="hljs-string">"TokenType"</span></span>); } } typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!EndOfExperssion()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(IsNumber()) { ScanNumber(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(IsOperator()) { ScanOperator(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { MoveNext(); } } } const Tokens &amp;Result() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_result; } private: bool EndOfExperssion() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_current == L<span class="hljs-string"><span class="hljs-string">'\0'</span></span>; } bool IsNumber() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> iswdigit(*m_current) != <span class="hljs-number"><span class="hljs-number">0</span></span>; } void ScanNumber() { wchar_t *<span class="hljs-keyword"><span class="hljs-keyword">end</span></span> = nullptr; m_result.push_back(wcstod(m_current, &amp;<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>)); m_current = <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; } bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> std::any_of(all.begin(), all.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(), [this](Operator o) {<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_current == static_cast&lt;wchar_t&gt;(o); }); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tokenizer.Result(); } } // namespace Lexer } // namespace Interpreter</code> <br> <br> <b class="spoiler_title">InterpreterTests.cpp</b> <code class="cpp">#include <span class="hljs-string"><span class="hljs-string">"stdafx.h"</span></span> #include <span class="hljs-string"><span class="hljs-string">"CppUnitTest.h"</span></span> #include <span class="hljs-string"><span class="hljs-string">"Interpreter.h"</span></span> namespace InterpreterTests { using namespace Microsoft::VisualStudio::CppUnitTestFramework; using namespace Interpreter; using namespace std; namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(expect)), distance(actualIter, <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(actual)), L<span class="hljs-string"><span class="hljs-string">"Size differs."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(; expectIter != <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(expect) &amp;&amp; actualIter != <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(actual); ++expectIter, ++actualIter) { auto message = L<span class="hljs-string"><span class="hljs-string">"Mismatch in position "</span></span> + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual&lt;T&gt;(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange TEST_CLASS(LexerTests) { public: TEST_METHOD(Should_return_empty_token_list_when_put_empty_expression) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">""</span></span>); Assert::IsTrue(tokens.empty()); } TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"+"</span></span>); AssertRange::AreEqual({ Operator::Plus }, tokens); } TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"1"</span></span>); AssertRange::AreEqual({ <span class="hljs-number"><span class="hljs-number">1.0</span></span> }, tokens); } TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"12.34"</span></span>); AssertRange::AreEqual({ <span class="hljs-number"><span class="hljs-number">12.34</span></span> }, tokens); } TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"+12.34"</span></span>); AssertRange::AreEqual({ Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">12.34</span></span>) }, tokens); } TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">" 1 + 12.34 "</span></span>); AssertRange::AreEqual({ Token(<span class="hljs-number"><span class="hljs-number">1.0</span></span>), Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">12.34</span></span>) }, tokens); } TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"1+2*3/(4-5)"</span></span>); AssertRange::AreEqual({ Token(<span class="hljs-number"><span class="hljs-number">1</span></span>), Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">2</span></span>), Token(Operator::Mul), Token(<span class="hljs-number"><span class="hljs-number">3</span></span>), Token(Operator::Div), Token(Operator::LParen), Token(<span class="hljs-number"><span class="hljs-number">4</span></span>), Token(Operator::Minus), Token(<span class="hljs-number"><span class="hljs-number">5</span></span>), Token(Operator::RParen) }, tokens); } }; TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } TEST_METHOD(Should_get_type_for_number_token) { Token numToken(<span class="hljs-number"><span class="hljs-number">1.2</span></span>); Assert::AreEqual(TokenType::Number, numToken.Type()); } TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); } TEST_METHOD(Should_get_number_value_from_number_token) { Token token(<span class="hljs-number"><span class="hljs-number">1.23</span></span>); Assert::AreEqual&lt;double&gt;(<span class="hljs-number"><span class="hljs-number">1.23</span></span>, token); } }; }</code> <br> <br> <a href="https://github.com/Unril/InterpreterTDD/releases/tag/%25D0%259A%25D0%25BE%25D0%25BD%25D0%25B5%25D1%2586_%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B2%25D0%25BE%25D0%25B9_%25D1%2587%25D0%25B0%25D1%2581%25D1%2582%25D0%25B8">    GitHub</a> .         ,  .      <span class="hljs-string"><span class="hljs-string">"__"</span></span>. <br> <br>   <a href="http://habrahabr.ru/post/232081/">    </a> .      ,      <a href="http://habrahabr.ru/post/232097/">    </a> .</code> </pre> <code><code>std::vector,      Tokens</code> .            . <br> <br> <code class="cpp">#pragma once; #include &lt;vector&gt; namespace Interpreter { struct Token {}; typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { inline Tokens Tokenize(std::string expr) { throw std::exception(); } } // namespace Lexer } // namespace Interpreter</code> <br>   ,  ,   , .   ,    ,    <a href="http://cleancoder.posterous.com/the-transformation-priority-premise">The Transformation Priority Premise (TPP)</a>   .    , ,    ,     ,        .            .     ,     ,      ,           .  ,  ,   (   )    ,  ,  .     ,  ,         .     ,   TPP          . <br> <br>   : <br> <br> ({} ‚Üí nil)     ,   . (nil ‚Üí constant)    . (constant ‚Üí constant+)      (        ,  ). (constant ‚Üí scalar)    ,  . (statement ‚Üí statements)    (break, continue, return  ). (unconditional ‚Üí if)       . (scalar ‚Üí array)  / . (array ‚Üí container)     . (statement ‚Üí recursion)   . (if ‚Üí while)    . (expression ‚Üí function)   . (variable ‚Üí assignment)   . <br>        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::string expr) { return{}; }</code> <br> ,         .     . <br> <br> <s>         </s> .           .           .               .            .       . <br>  ,  <code>std::string</code>  <code>std::wstring</code> .         ,      Unicode.     . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); }</code> <br>  <code>AssertRange</code> -   ,       <code>AreEqual</code> ,   ,  ,    . <br> <br> <b class="spoiler_title">AssertRange</b> <code class="cpp">namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange</code> <br> <br>         <code>Operator</code>    .          <code>wchar_t</code>   ,         ,      . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', }; typedef Operator Token;</code> <br>    ,   ,        <code>Assert</code> ,    <code>ToString</code> ,    . <br> <br> <b class="spoiler_title">std::wstring ToString(const Token &amp;)</b> <code class="cpp">inline std::wstring ToString(const Token &amp;token) { return{ static_cast&lt;wchar_t&gt;(token) }; }</code> <br> <br>    ,   ,        .  ,   (unconditional ‚Üí if). <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { if(expr.empty()) { return{}; } return{ static_cast&lt;Operator&gt;(expr[0]) }; }</code> <br> <s>         </s> . <s>          .</s>           . ‚Ä¶ <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); }</code> <br>     .   ,     ,   - .    , : <br> <br>        ,      <code>Token</code> .       <code>dynamic_cast</code>    ,   .  ,    ,      .      <code>std::function</code>        .        .  Boost.Any,  - .            . <br>   ,   .      -  .  ,      ,      . <br> <br> ‚Ä¶        .        .        .        . <br>             . <br> <br> <code class="cpp">enum class TokenType { Operator, Number }; class Token { public: Token(Operator) {} TokenType Type() const { return TokenType::Operator; } }; ‚Ä¶ TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } };</code> <br>   <code>ToString</code>   <code>TokenType</code>       ,   ,   .     . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); }</code> <br>   .   (constant ‚Üí scalar)   . <br> <br> <code class="cpp">class Token { public: Token(Operator) :m_type(TokenType::Operator) {} Token(double) :m_type(TokenType::Number) {} TokenType Type() const { return m_type; } private: TokenType m_type; };</code> <br> ‚Ä¶ <s>       </s> . <s>       </s> .        .        . <br>    . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); }</code> <br>            . <br> <br> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} operator Operator() const { return m_operator; } ‚Ä¶ Operator m_operator; };</code> <br>      . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); }</code> <br>          ,  ,       <code>union</code> .         . <br> <br> <b class="spoiler_title">Token</b> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: return "Unknown token."; } }</code> <br> <br>  ,    ,      ,    .       .    . <br> <br> <i>          .</i>               .            .       . <br>        : <br> <br> <code class="cpp"> if(expr[0] &gt;= '0' &amp;&amp; expr[0] &lt;= '9') { return{ (double) expr[0] - '0' }; } return{ static_cast&lt;Operator&gt;(expr[0]) };</code> <br>      ,   . <br> <br> ‚Ä¶ <s>          .</s> <i>              .</i> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); }</code> <br> ,     <code>C</code>   ,  <code>isdigit</code> , ,       <code>atof</code> ,    ,      <code>wchar_t</code> .  (expression ‚Üí function).         . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { const wchar_t *current = expr.c_str(); if(!*current) return{}; if(iswdigit(*current)) return{ _wtof(current) }; return{ static_cast&lt;Operator&gt;(*current) }; }</code> <br>         .      . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>   ,        .  ,     .     .   <code>result</code> ,     . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); if(!*current) return result; if(iswdigit(*current)) { result.push_back(_wtof(current)); } else { result.push_back(static_cast&lt;Operator&gt;(*current)); } return result; }</code> <br>      :   (if ‚Üí while).     ,        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } } return result; }</code> <br>  <code>wcstod</code>    ,   <code>_wtof</code> ,           .           ,              .  ,    . <br> <br> <s>           .</s>       . <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>  (unconditional ‚Üí if)    ,    . <br> <br> <code class="cpp"> while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else if(*current == static_cast&lt;wchar_t&gt;(Operator::Plus)) { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } else { ++current; } }</code> <br>       .          .       <code>Detail</code>      .   <code>Tokenize</code>       . <br> <br> <code class="cpp">inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); }</code> <br> <b class="spoiler_title"> Detail::Tokenizer</b> <code class="cpp">namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { return *m_current == static_cast&lt;wchar_t&gt;(Operator::Plus); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail</code> <br> <br>  ,      .      ,  , .       . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); }</code> <br>      <code>Operator</code> ,    . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', };</code> <br>   .         <code>IsOperator</code>  <code>Tokenizer</code> . <br> <br> <code class="cpp"> bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); }</code> <br>         .        . <br> <br> <b class="spoiler_title">Interpreter.h</b> <code class="cpp">#pragma once; #include &lt;vector&gt; #include &lt;wchar.h&gt; #include &lt;algorithm&gt; namespace Interpreter { enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', }; inline std::wstring ToString(const Operator &amp;op) { return{ static_cast&lt;wchar_t&gt;(op) }; } enum class TokenType { Operator, Number }; inline std::wstring ToString(const TokenType &amp;type) { switch(type) { case TokenType::Operator: return L"Operator"; case TokenType::Number: return L"Number"; default: throw std::out_of_range("TokenType"); } } class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } friend inline bool operator==(const Token &amp;left, const Token &amp;right) { if(left.m_type == right.m_type) { switch(left.m_type) { case Interpreter::TokenType::Operator: return left.m_operator == right.m_operator; case Interpreter::TokenType::Number: return left.m_number == right.m_number; default: throw std::out_of_range("TokenType"); } } return false; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: throw std::out_of_range("TokenType"); } } typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); } } // namespace Lexer } // namespace Interpreter</code> <br> <br> <b class="spoiler_title">InterpreterTests.cpp</b> <code class="cpp">#include "stdafx.h" #include "CppUnitTest.h" #include "Interpreter.h" namespace InterpreterTests { using namespace Microsoft::VisualStudio::CppUnitTestFramework; using namespace Interpreter; using namespace std; namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual&lt;T&gt;(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange TEST_CLASS(LexerTests) { public: TEST_METHOD(Should_return_empty_token_list_when_put_empty_expression) { Tokens tokens = Lexer::Tokenize(L""); Assert::IsTrue(tokens.empty()); } TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); } TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); } TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); } TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); } }; TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); } TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); } TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); } }; }</code> <br> <br> <a href="https://github.com/Unril/InterpreterTDD/releases/tag/%25D0%259A%25D0%25BE%25D0%25BD%25D0%25B5%25D1%2586_%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B2%25D0%25BE%25D0%25B9_%25D1%2587%25D0%25B0%25D1%2581%25D1%2582%25D0%25B8">    GitHub</a> .         ,  .      "__". <br> <br>   <a href="http://habrahabr.ru/post/232081/">    </a> .      ,      <a href="http://habrahabr.ru/post/232097/">    </a> .</code> <div class="spoiler"> <code><b class="spoiler_title"><code>std::vector,      Tokens</code> .            . <br> <br> <code class="cpp">#pragma once; #include &lt;vector&gt; namespace Interpreter { struct Token {}; typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { inline Tokens Tokenize(std::string expr) { throw std::exception(); } } // namespace Lexer } // namespace Interpreter</code> <br>   ,  ,   , .   ,    ,    <a href="http://cleancoder.posterous.com/the-transformation-priority-premise">The Transformation Priority Premise (TPP)</a>   .    , ,    ,     ,        .            .     ,     ,      ,           .  ,  ,   (   )    ,  ,  .     ,  ,         .     ,   TPP          . <br> <br>   : <br> <br> ({} ‚Üí nil)     ,   . (nil ‚Üí constant)    . (constant ‚Üí constant+)      (        ,  ). (constant ‚Üí scalar)    ,  . (statement ‚Üí statements)    (break, continue, return  ). (unconditional ‚Üí if)       . (scalar ‚Üí array)  / . (array ‚Üí container)     . (statement ‚Üí recursion)   . (if ‚Üí while)    . (expression ‚Üí function)   . (variable ‚Üí assignment)   . <br>        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::string expr) { return{}; }</code> <br> ,         .     . <br> <br> <s>         </s> .           .           .               .            .       . <br>  ,  <code>std::string</code>  <code>std::wstring</code> .         ,      Unicode.     . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); }</code> <br>  <code>AssertRange</code> -   ,       <code>AreEqual</code> ,   ,  ,    . <br> <br> <b class="spoiler_title">AssertRange</b> <code class="cpp">namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange</code> <br> <br>         <code>Operator</code>    .          <code>wchar_t</code>   ,         ,      . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', }; typedef Operator Token;</code> <br>    ,   ,        <code>Assert</code> ,    <code>ToString</code> ,    . <br> <br> <b class="spoiler_title">std::wstring ToString(const Token &amp;)</b> <code class="cpp">inline std::wstring ToString(const Token &amp;token) { return{ static_cast&lt;wchar_t&gt;(token) }; }</code> <br> <br>    ,   ,        .  ,   (unconditional ‚Üí if). <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { if(expr.empty()) { return{}; } return{ static_cast&lt;Operator&gt;(expr[0]) }; }</code> <br> <s>         </s> . <s>          .</s>           . ‚Ä¶ <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); }</code> <br>     .   ,     ,   - .    , : <br> <br>        ,      <code>Token</code> .       <code>dynamic_cast</code>    ,   .  ,    ,      .      <code>std::function</code>        .        .  Boost.Any,  - .            . <br>   ,   .      -  .  ,      ,      . <br> <br> ‚Ä¶        .        .        .        . <br>             . <br> <br> <code class="cpp">enum class TokenType { Operator, Number }; class Token { public: Token(Operator) {} TokenType Type() const { return TokenType::Operator; } }; ‚Ä¶ TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } };</code> <br>   <code>ToString</code>   <code>TokenType</code>       ,   ,   .     . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); }</code> <br>   .   (constant ‚Üí scalar)   . <br> <br> <code class="cpp">class Token { public: Token(Operator) :m_type(TokenType::Operator) {} Token(double) :m_type(TokenType::Number) {} TokenType Type() const { return m_type; } private: TokenType m_type; };</code> <br> ‚Ä¶ <s>       </s> . <s>       </s> .        .        . <br>    . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); }</code> <br>            . <br> <br> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} operator Operator() const { return m_operator; } ‚Ä¶ Operator m_operator; };</code> <br>      . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); }</code> <br>          ,  ,       <code>union</code> .         . <br> <br> <b class="spoiler_title">Token</b> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: return "Unknown token."; } }</code> <br> <br>  ,    ,      ,    .       .    . <br> <br> <i>          .</i>               .            .       . <br>        : <br> <br> <code class="cpp"> if(expr[0] &gt;= '0' &amp;&amp; expr[0] &lt;= '9') { return{ (double) expr[0] - '0' }; } return{ static_cast&lt;Operator&gt;(expr[0]) };</code> <br>      ,   . <br> <br> ‚Ä¶ <s>          .</s> <i>              .</i> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); }</code> <br> ,     <code>C</code>   ,  <code>isdigit</code> , ,       <code>atof</code> ,    ,      <code>wchar_t</code> .  (expression ‚Üí function).         . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { const wchar_t *current = expr.c_str(); if(!*current) return{}; if(iswdigit(*current)) return{ _wtof(current) }; return{ static_cast&lt;Operator&gt;(*current) }; }</code> <br>         .      . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>   ,        .  ,     .     .   <code>result</code> ,     . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); if(!*current) return result; if(iswdigit(*current)) { result.push_back(_wtof(current)); } else { result.push_back(static_cast&lt;Operator&gt;(*current)); } return result; }</code> <br>      :   (if ‚Üí while).     ,        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } } return result; }</code> <br>  <code>wcstod</code>    ,   <code>_wtof</code> ,           .           ,              .  ,    . <br> <br> <s>           .</s>       . <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>  (unconditional ‚Üí if)    ,    . <br> <br> <code class="cpp"> while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else if(*current == static_cast&lt;wchar_t&gt;(Operator::Plus)) { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } else { ++current; } }</code> <br>       .          .       <code>Detail</code>      .   <code>Tokenize</code>       . <br> <br> <code class="cpp">inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); }</code> <br> <b class="spoiler_title"> Detail::Tokenizer</b> <code class="cpp">namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { return *m_current == static_cast&lt;wchar_t&gt;(Operator::Plus); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail</code> <br> <br>  ,      .      ,  , .       . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); }</code> <br>      <code>Operator</code> ,    . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', };</code> <br>   .         <code>IsOperator</code>  <code>Tokenizer</code> . <br> <br> <code class="cpp"> bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); }</code> <br>         .        . <br> <br> Interpreter.h <code class="cpp">#pragma once; #include &lt;vector&gt; #include &lt;wchar.h&gt; #include &lt;algorithm&gt; namespace Interpreter { enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', }; inline std::wstring ToString(const Operator &amp;op) { return{ static_cast&lt;wchar_t&gt;(op) }; } enum class TokenType { Operator, Number }; inline std::wstring ToString(const TokenType &amp;type) { switch(type) { case TokenType::Operator: return L"Operator"; case TokenType::Number: return L"Number"; default: throw std::out_of_range("TokenType"); } } class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } friend inline bool operator==(const Token &amp;left, const Token &amp;right) { if(left.m_type == right.m_type) { switch(left.m_type) { case Interpreter::TokenType::Operator: return left.m_operator == right.m_operator; case Interpreter::TokenType::Number: return left.m_number == right.m_number; default: throw std::out_of_range("TokenType"); } } return false; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: throw std::out_of_range("TokenType"); } } typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); } } // namespace Lexer } // namespace Interpreter</code> <br> <br> <b class="spoiler_title">InterpreterTests.cpp</b> <code class="cpp">#include "stdafx.h" #include "CppUnitTest.h" #include "Interpreter.h" namespace InterpreterTests { using namespace Microsoft::VisualStudio::CppUnitTestFramework; using namespace Interpreter; using namespace std; namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual&lt;T&gt;(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange TEST_CLASS(LexerTests) { public: TEST_METHOD(Should_return_empty_token_list_when_put_empty_expression) { Tokens tokens = Lexer::Tokenize(L""); Assert::IsTrue(tokens.empty()); } TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); } TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); } TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); } TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); } }; TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); } TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); } TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); } }; }</code> <br> <br> <a href="https://github.com/Unril/InterpreterTDD/releases/tag/%25D0%259A%25D0%25BE%25D0%25BD%25D0%25B5%25D1%2586_%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B2%25D0%25BE%25D0%25B9_%25D1%2587%25D0%25B0%25D1%2581%25D1%2582%25D0%25B8">    GitHub</a> .         ,  .      "__". <br> <br>   <a href="http://habrahabr.ru/post/232081/">    </a> .      ,      <a href="http://habrahabr.ru/post/232097/">    </a> .</b></code> <div class="spoiler_text"> <pre> <code class="hljs lua"><code>std::vector,      Tokens</code> .            . <br> <br> <code class="cpp">#pragma once; #include &lt;vector&gt; namespace Interpreter { struct Token {}; typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { inline Tokens Tokenize(std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> expr) { throw std::exception(); } } // namespace Lexer } // namespace Interpreter</code> <br>   ,  ,   , .   ,    ,    <a href="http://cleancoder.posterous.com/the-transformation-priority-premise">The Transformation Priority Premise (TPP)</a>   .    , ,    ,     ,        .            .     ,     ,      ,           .  ,  ,   (   )    ,  ,  .     ,  ,         .     ,   TPP          . <br> <br>   : <br> <br> ({} ‚Üí <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)     ,   . (<span class="hljs-literal"><span class="hljs-literal">nil</span></span> ‚Üí constant)    . (constant ‚Üí constant+)      (        ,  ). (constant ‚Üí scalar)    ,  . (statement ‚Üí statements)    (<span class="hljs-keyword"><span class="hljs-keyword">break</span></span>, continue, <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>  ). (unconditional ‚Üí <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>)       . (scalar ‚Üí array)  / . (array ‚Üí container)     . (statement ‚Üí recursion)   . (<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ‚Üí <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>)    . (expression ‚Üí <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">)</span></span>   . (variable ‚Üí assignment)   . <br>        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> expr) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{}; }</code> <br> ,         .     . <br> <br> <s>         </s> .           .           .               .            .       . <br>  ,  <code>std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span></code>  <code>std::wstring</code> .         ,      Unicode.     . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"+"</span></span>); AssertRange::AreEqual({ Operator::Plus }, tokens); }</code> <br>  <code>AssertRange</code> -   ,       <code>AreEqual</code> ,   ,  ,    . <br> <br> <b class="spoiler_title">AssertRange</b> <code class="cpp">namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(expect)), distance(actualIter, <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(actual)), L<span class="hljs-string"><span class="hljs-string">"Size differs."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(; expectIter != <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(expect) &amp;&amp; actualIter != <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(actual); ++expectIter, ++actualIter) { auto message = L<span class="hljs-string"><span class="hljs-string">"Mismatch in position "</span></span> + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange</code> <br> <br>         <code>Operator</code>    .          <code>wchar_t</code>   ,         ,      . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L<span class="hljs-string"><span class="hljs-string">'+'</span></span>, }; typedef Operator Token;</code> <br>    ,   ,        <code>Assert</code> ,    <code>ToString</code> ,    . <br> <br> <b class="spoiler_title">std::wstring ToString(const Token &amp;)</b> <code class="cpp">inline std::wstring ToString(const Token &amp;token) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ static_cast&lt;wchar_t&gt;(token) }; }</code> <br> <br>    ,   ,        .  ,   (unconditional ‚Üí <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>). <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(expr.empty()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{}; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ static_cast&lt;Operator&gt;(expr[<span class="hljs-number"><span class="hljs-number">0</span></span>]) }; }</code> <br> <s>         </s> . <s>          .</s>           . ‚Ä¶ <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"1"</span></span>); AssertRange::AreEqual({ <span class="hljs-number"><span class="hljs-number">1.0</span></span> }, tokens); }</code> <br>     .   ,     ,   - .    , : <br> <br>        ,      <code>Token</code> .       <code>dynamic_cast</code>    ,   .  ,    ,      .      <code>std::<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span></span></code><span class="hljs-function"><span class="hljs-function">        .        .  </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Boost.Any</span></span></span><span class="hljs-function">,  - .            . </span></span><br><span class="hljs-function"><span class="hljs-function">   ,   .      -  .  ,      ,      . </span></span><br><span class="hljs-function"><span class="hljs-function"> </span></span><br><span class="hljs-function"><span class="hljs-function"> ‚Ä¶        .        .        .        . </span></span><br><span class="hljs-function"><span class="hljs-function">             . </span></span><br><span class="hljs-function"><span class="hljs-function"> </span></span><br><span class="hljs-function"><span class="hljs-function"> </span></span><code class="cpp"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">enum</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">class</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TokenType</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Operator</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Number</span></span></span><span class="hljs-function"> }; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">class</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Token</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">public</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Token</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Operator)</span></span></span></span> {} TokenType Type() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TokenType::Operator; } }; ‚Ä¶ TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } };</code> <br>   <code>ToString</code>   <code>TokenType</code>       ,   ,   .     . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_type_for_number_token) { Token numToken(<span class="hljs-number"><span class="hljs-number">1.2</span></span>); Assert::AreEqual(TokenType::Number, numToken.Type()); }</code> <br>   .   (constant ‚Üí scalar)   . <br> <br> <code class="cpp">class Token { public: Token(Operator) :m_type(TokenType::Operator) {} Token(double) :m_type(TokenType::Number) {} TokenType Type() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_type; } private: TokenType m_type; };</code> <br> ‚Ä¶ <s>       </s> . <s>       </s> .        .        . <br>    . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); }</code> <br>            . <br> <br> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} operator Operator() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_operator; } ‚Ä¶ Operator m_operator; };</code> <br>      . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_number_value_from_number_token) { Token token(<span class="hljs-number"><span class="hljs-number">1.23</span></span>); Assert::AreEqual&lt;double&gt;(<span class="hljs-number"><span class="hljs-number">1.23</span></span>, token); }</code> <br>          ,  ,       <code>union</code> .         . <br> <br> <b class="spoiler_title">Token</b> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_type; } operator Operator() const { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(m_type != TokenType::Operator) throw std::logic_error(<span class="hljs-string"><span class="hljs-string">"Should be operator token."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_operator; } operator double() const { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(m_type != TokenType::Number) throw std::logic_error(<span class="hljs-string"><span class="hljs-string">"Should be number token."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_number; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ToString(static_cast&lt;Operator&gt;(token)); default: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Unknown token."</span></span>; } }</code> <br> <br>  ,    ,      ,    .       .    . <br> <br> <i>          .</i>               .            .       . <br>        : <br> <br> <code class="cpp"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(expr[<span class="hljs-number"><span class="hljs-number">0</span></span>] &gt;= <span class="hljs-string"><span class="hljs-string">'0'</span></span> &amp;&amp; expr[<span class="hljs-number"><span class="hljs-number">0</span></span>] &lt;= <span class="hljs-string"><span class="hljs-string">'9'</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ (double) expr[<span class="hljs-number"><span class="hljs-number">0</span></span>] - <span class="hljs-string"><span class="hljs-string">'0'</span></span> }; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ static_cast&lt;Operator&gt;(expr[<span class="hljs-number"><span class="hljs-number">0</span></span>]) };</code> <br>      ,   . <br> <br> ‚Ä¶ <s>          .</s> <i>              .</i> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"12.34"</span></span>); AssertRange::AreEqual({ <span class="hljs-number"><span class="hljs-number">12.34</span></span> }, tokens); }</code> <br> ,     <code>C</code>   ,  <code>isdigit</code> , ,       <code>atof</code> ,    ,      <code>wchar_t</code> .  (expression ‚Üí <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">)</span></span>.         . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { const wchar_t *current = expr.c_str(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!*current) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{}; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(iswdigit(*current)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ _wtof(current) }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ static_cast&lt;Operator&gt;(*current) }; }</code> <br>         .      . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"+12.34"</span></span>); AssertRange::AreEqual({ Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">12.34</span></span>) }, tokens); }</code> <br>   ,        .  ,     .     .   <code>result</code> ,     . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!*current) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(iswdigit(*current)) { result.push_back(_wtof(current)); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { result.push_back(static_cast&lt;Operator&gt;(*current)); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> <br>      :   (<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ‚Üí <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>).     ,        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(*current) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(iswdigit(*current)) { wchar_t *<span class="hljs-keyword"><span class="hljs-keyword">end</span></span> = nullptr; result.push_back(wcstod(current, &amp;<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>)); current = <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> <br>  <code>wcstod</code>    ,   <code>_wtof</code> ,           .           ,              .  ,    . <br> <br> <s>           .</s>       . <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">" 1 + 12.34 "</span></span>); AssertRange::AreEqual({ Token(<span class="hljs-number"><span class="hljs-number">1.0</span></span>), Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">12.34</span></span>) }, tokens); }</code> <br>  (unconditional ‚Üí <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>)    ,    . <br> <br> <code class="cpp"> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(*current) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(iswdigit(*current)) { wchar_t *<span class="hljs-keyword"><span class="hljs-keyword">end</span></span> = nullptr; result.push_back(wcstod(current, &amp;<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>)); current = <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(*current == static_cast&lt;wchar_t&gt;(Operator::Plus)) { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { ++current; } }</code> <br>       .          .       <code>Detail</code>      .   <code>Tokenize</code>       . <br> <br> <code class="cpp">inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tokenizer.Result(); }</code> <br> <b class="spoiler_title"> Detail::Tokenizer</b> <code class="cpp">namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!EndOfExperssion()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(IsNumber()) { ScanNumber(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(IsOperator()) { ScanOperator(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { MoveNext(); } } } const Tokens &amp;Result() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_result; } private: bool EndOfExperssion() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_current == L<span class="hljs-string"><span class="hljs-string">'\0'</span></span>; } bool IsNumber() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> iswdigit(*m_current) != <span class="hljs-number"><span class="hljs-number">0</span></span>; } void ScanNumber() { wchar_t *<span class="hljs-keyword"><span class="hljs-keyword">end</span></span> = nullptr; m_result.push_back(wcstod(m_current, &amp;<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>)); m_current = <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; } bool IsOperator() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_current == static_cast&lt;wchar_t&gt;(Operator::Plus); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail</code> <br> <br>  ,      .      ,  , .       . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"1+2*3/(4-5)"</span></span>); AssertRange::AreEqual({ Token(<span class="hljs-number"><span class="hljs-number">1</span></span>), Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">2</span></span>), Token(Operator::Mul), Token(<span class="hljs-number"><span class="hljs-number">3</span></span>), Token(Operator::Div), Token(Operator::LParen), Token(<span class="hljs-number"><span class="hljs-number">4</span></span>), Token(Operator::Minus), Token(<span class="hljs-number"><span class="hljs-number">5</span></span>), Token(Operator::RParen) }, tokens); }</code> <br>      <code>Operator</code> ,    . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L<span class="hljs-string"><span class="hljs-string">'+'</span></span>, Minus = L<span class="hljs-string"><span class="hljs-string">'-'</span></span>, Mul = L<span class="hljs-string"><span class="hljs-string">'*'</span></span>, Div = L<span class="hljs-string"><span class="hljs-string">'/'</span></span>, LParen = L<span class="hljs-string"><span class="hljs-string">'('</span></span>, RParen = L<span class="hljs-string"><span class="hljs-string">')'</span></span>, };</code> <br>   .         <code>IsOperator</code>  <code>Tokenizer</code> . <br> <br> <code class="cpp"> bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> std::any_of(all.begin(), all.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(), [this](Operator o) {<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_current == static_cast&lt;wchar_t&gt;(o); }); }</code> <br>         .        . <br> <br> <b class="spoiler_title">Interpreter.h</b> <code class="cpp">#pragma once; #include &lt;vector&gt; #include &lt;wchar.h&gt; #include &lt;algorithm&gt; namespace Interpreter { enum class Operator : wchar_t { Plus = L<span class="hljs-string"><span class="hljs-string">'+'</span></span>, Minus = L<span class="hljs-string"><span class="hljs-string">'-'</span></span>, Mul = L<span class="hljs-string"><span class="hljs-string">'*'</span></span>, Div = L<span class="hljs-string"><span class="hljs-string">'/'</span></span>, LParen = L<span class="hljs-string"><span class="hljs-string">'('</span></span>, RParen = L<span class="hljs-string"><span class="hljs-string">')'</span></span>, }; inline std::wstring ToString(const Operator &amp;op) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ static_cast&lt;wchar_t&gt;(op) }; } enum class TokenType { Operator, Number }; inline std::wstring ToString(const TokenType &amp;<span class="hljs-built_in"><span class="hljs-built_in">type</span></span>) { switch(<span class="hljs-built_in"><span class="hljs-built_in">type</span></span>) { case TokenType::Operator: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> L<span class="hljs-string"><span class="hljs-string">"Operator"</span></span>; case TokenType::Number: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> L<span class="hljs-string"><span class="hljs-string">"Number"</span></span>; default: throw std::out_of_range(<span class="hljs-string"><span class="hljs-string">"TokenType"</span></span>); } } class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_type; } operator Operator() const { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(m_type != TokenType::Operator) throw std::logic_error(<span class="hljs-string"><span class="hljs-string">"Should be operator token."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_operator; } operator double() const { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(m_type != TokenType::Number) throw std::logic_error(<span class="hljs-string"><span class="hljs-string">"Should be number token."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_number; } friend inline bool operator==(const Token &amp;left, const Token &amp;right) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(left.m_type == right.m_type) { switch(left.m_type) { case Interpreter::TokenType::Operator: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> left.m_operator == right.m_operator; case Interpreter::TokenType::Number: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> left.m_number == right.m_number; default: throw std::out_of_range(<span class="hljs-string"><span class="hljs-string">"TokenType"</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ToString(static_cast&lt;Operator&gt;(token)); default: throw std::out_of_range(<span class="hljs-string"><span class="hljs-string">"TokenType"</span></span>); } } typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!EndOfExperssion()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(IsNumber()) { ScanNumber(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(IsOperator()) { ScanOperator(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { MoveNext(); } } } const Tokens &amp;Result() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_result; } private: bool EndOfExperssion() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_current == L<span class="hljs-string"><span class="hljs-string">'\0'</span></span>; } bool IsNumber() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> iswdigit(*m_current) != <span class="hljs-number"><span class="hljs-number">0</span></span>; } void ScanNumber() { wchar_t *<span class="hljs-keyword"><span class="hljs-keyword">end</span></span> = nullptr; m_result.push_back(wcstod(m_current, &amp;<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>)); m_current = <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; } bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> std::any_of(all.begin(), all.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(), [this](Operator o) {<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_current == static_cast&lt;wchar_t&gt;(o); }); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tokenizer.Result(); } } // namespace Lexer } // namespace Interpreter</code> <br> <br> <b class="spoiler_title">InterpreterTests.cpp</b> <code class="cpp">#include <span class="hljs-string"><span class="hljs-string">"stdafx.h"</span></span> #include <span class="hljs-string"><span class="hljs-string">"CppUnitTest.h"</span></span> #include <span class="hljs-string"><span class="hljs-string">"Interpreter.h"</span></span> namespace InterpreterTests { using namespace Microsoft::VisualStudio::CppUnitTestFramework; using namespace Interpreter; using namespace std; namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(expect)), distance(actualIter, <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(actual)), L<span class="hljs-string"><span class="hljs-string">"Size differs."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(; expectIter != <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(expect) &amp;&amp; actualIter != <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(actual); ++expectIter, ++actualIter) { auto message = L<span class="hljs-string"><span class="hljs-string">"Mismatch in position "</span></span> + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual&lt;T&gt;(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange TEST_CLASS(LexerTests) { public: TEST_METHOD(Should_return_empty_token_list_when_put_empty_expression) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">""</span></span>); Assert::IsTrue(tokens.empty()); } TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"+"</span></span>); AssertRange::AreEqual({ Operator::Plus }, tokens); } TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"1"</span></span>); AssertRange::AreEqual({ <span class="hljs-number"><span class="hljs-number">1.0</span></span> }, tokens); } TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"12.34"</span></span>); AssertRange::AreEqual({ <span class="hljs-number"><span class="hljs-number">12.34</span></span> }, tokens); } TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"+12.34"</span></span>); AssertRange::AreEqual({ Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">12.34</span></span>) }, tokens); } TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">" 1 + 12.34 "</span></span>); AssertRange::AreEqual({ Token(<span class="hljs-number"><span class="hljs-number">1.0</span></span>), Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">12.34</span></span>) }, tokens); } TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"1+2*3/(4-5)"</span></span>); AssertRange::AreEqual({ Token(<span class="hljs-number"><span class="hljs-number">1</span></span>), Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">2</span></span>), Token(Operator::Mul), Token(<span class="hljs-number"><span class="hljs-number">3</span></span>), Token(Operator::Div), Token(Operator::LParen), Token(<span class="hljs-number"><span class="hljs-number">4</span></span>), Token(Operator::Minus), Token(<span class="hljs-number"><span class="hljs-number">5</span></span>), Token(Operator::RParen) }, tokens); } }; TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } TEST_METHOD(Should_get_type_for_number_token) { Token numToken(<span class="hljs-number"><span class="hljs-number">1.2</span></span>); Assert::AreEqual(TokenType::Number, numToken.Type()); } TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); } TEST_METHOD(Should_get_number_value_from_number_token) { Token token(<span class="hljs-number"><span class="hljs-number">1.23</span></span>); Assert::AreEqual&lt;double&gt;(<span class="hljs-number"><span class="hljs-number">1.23</span></span>, token); } }; }</code> <br> <br> <a href="https://github.com/Unril/InterpreterTDD/releases/tag/%25D0%259A%25D0%25BE%25D0%25BD%25D0%25B5%25D1%2586_%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B2%25D0%25BE%25D0%25B9_%25D1%2587%25D0%25B0%25D1%2581%25D1%2582%25D0%25B8">    GitHub</a> .         ,  .      <span class="hljs-string"><span class="hljs-string">"__"</span></span>. <br> <br>   <a href="http://habrahabr.ru/post/232081/">    </a> .      ,      <a href="http://habrahabr.ru/post/232097/">    </a> .</code> </pre> <code><code>std::vector,      Tokens</code> .            . <br> <br> <code class="cpp">#pragma once; #include &lt;vector&gt; namespace Interpreter { struct Token {}; typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { inline Tokens Tokenize(std::string expr) { throw std::exception(); } } // namespace Lexer } // namespace Interpreter</code> <br>   ,  ,   , .   ,    ,    <a href="http://cleancoder.posterous.com/the-transformation-priority-premise">The Transformation Priority Premise (TPP)</a>   .    , ,    ,     ,        .            .     ,     ,      ,           .  ,  ,   (   )    ,  ,  .     ,  ,         .     ,   TPP          . <br> <br>   : <br> <br> ({} ‚Üí nil)     ,   . (nil ‚Üí constant)    . (constant ‚Üí constant+)      (        ,  ). (constant ‚Üí scalar)    ,  . (statement ‚Üí statements)    (break, continue, return  ). (unconditional ‚Üí if)       . (scalar ‚Üí array)  / . (array ‚Üí container)     . (statement ‚Üí recursion)   . (if ‚Üí while)    . (expression ‚Üí function)   . (variable ‚Üí assignment)   . <br>        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::string expr) { return{}; }</code> <br> ,         .     . <br> <br> <s>         </s> .           .           .               .            .       . <br>  ,  <code>std::string</code>  <code>std::wstring</code> .         ,      Unicode.     . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); }</code> <br>  <code>AssertRange</code> -   ,       <code>AreEqual</code> ,   ,  ,    . <br> <br> <b class="spoiler_title">AssertRange</b> <code class="cpp">namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange</code> <br> <br>         <code>Operator</code>    .          <code>wchar_t</code>   ,         ,      . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', }; typedef Operator Token;</code> <br>    ,   ,        <code>Assert</code> ,    <code>ToString</code> ,    . <br> <br> <b class="spoiler_title">std::wstring ToString(const Token &amp;)</b> <code class="cpp">inline std::wstring ToString(const Token &amp;token) { return{ static_cast&lt;wchar_t&gt;(token) }; }</code> <br> <br>    ,   ,        .  ,   (unconditional ‚Üí if). <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { if(expr.empty()) { return{}; } return{ static_cast&lt;Operator&gt;(expr[0]) }; }</code> <br> <s>         </s> . <s>          .</s>           . ‚Ä¶ <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); }</code> <br>     .   ,     ,   - .    , : <br> <br>        ,      <code>Token</code> .       <code>dynamic_cast</code>    ,   .  ,    ,      .      <code>std::function</code>        .        .  Boost.Any,  - .            . <br>   ,   .      -  .  ,      ,      . <br> <br> ‚Ä¶        .        .        .        . <br>             . <br> <br> <code class="cpp">enum class TokenType { Operator, Number }; class Token { public: Token(Operator) {} TokenType Type() const { return TokenType::Operator; } }; ‚Ä¶ TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } };</code> <br>   <code>ToString</code>   <code>TokenType</code>       ,   ,   .     . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); }</code> <br>   .   (constant ‚Üí scalar)   . <br> <br> <code class="cpp">class Token { public: Token(Operator) :m_type(TokenType::Operator) {} Token(double) :m_type(TokenType::Number) {} TokenType Type() const { return m_type; } private: TokenType m_type; };</code> <br> ‚Ä¶ <s>       </s> . <s>       </s> .        .        . <br>    . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); }</code> <br>            . <br> <br> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} operator Operator() const { return m_operator; } ‚Ä¶ Operator m_operator; };</code> <br>      . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); }</code> <br>          ,  ,       <code>union</code> .         . <br> <br> <b class="spoiler_title">Token</b> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: return "Unknown token."; } }</code> <br> <br>  ,    ,      ,    .       .    . <br> <br> <i>          .</i>               .            .       . <br>        : <br> <br> <code class="cpp"> if(expr[0] &gt;= '0' &amp;&amp; expr[0] &lt;= '9') { return{ (double) expr[0] - '0' }; } return{ static_cast&lt;Operator&gt;(expr[0]) };</code> <br>      ,   . <br> <br> ‚Ä¶ <s>          .</s> <i>              .</i> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); }</code> <br> ,     <code>C</code>   ,  <code>isdigit</code> , ,       <code>atof</code> ,    ,      <code>wchar_t</code> .  (expression ‚Üí function).         . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { const wchar_t *current = expr.c_str(); if(!*current) return{}; if(iswdigit(*current)) return{ _wtof(current) }; return{ static_cast&lt;Operator&gt;(*current) }; }</code> <br>         .      . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>   ,        .  ,     .     .   <code>result</code> ,     . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); if(!*current) return result; if(iswdigit(*current)) { result.push_back(_wtof(current)); } else { result.push_back(static_cast&lt;Operator&gt;(*current)); } return result; }</code> <br>      :   (if ‚Üí while).     ,        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } } return result; }</code> <br>  <code>wcstod</code>    ,   <code>_wtof</code> ,           .           ,              .  ,    . <br> <br> <s>           .</s>       . <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>  (unconditional ‚Üí if)    ,    . <br> <br> <code class="cpp"> while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else if(*current == static_cast&lt;wchar_t&gt;(Operator::Plus)) { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } else { ++current; } }</code> <br>       .          .       <code>Detail</code>      .   <code>Tokenize</code>       . <br> <br> <code class="cpp">inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); }</code> <br> <b class="spoiler_title"> Detail::Tokenizer</b> <code class="cpp">namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { return *m_current == static_cast&lt;wchar_t&gt;(Operator::Plus); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail</code> <br> <br>  ,      .      ,  , .       . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); }</code> <br>      <code>Operator</code> ,    . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', };</code> <br>   .         <code>IsOperator</code>  <code>Tokenizer</code> . <br> <br> <code class="cpp"> bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); }</code> <br>         .        . <br> <br> <b class="spoiler_title">Interpreter.h</b> <code class="cpp">#pragma once; #include &lt;vector&gt; #include &lt;wchar.h&gt; #include &lt;algorithm&gt; namespace Interpreter { enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', }; inline std::wstring ToString(const Operator &amp;op) { return{ static_cast&lt;wchar_t&gt;(op) }; } enum class TokenType { Operator, Number }; inline std::wstring ToString(const TokenType &amp;type) { switch(type) { case TokenType::Operator: return L"Operator"; case TokenType::Number: return L"Number"; default: throw std::out_of_range("TokenType"); } } class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } friend inline bool operator==(const Token &amp;left, const Token &amp;right) { if(left.m_type == right.m_type) { switch(left.m_type) { case Interpreter::TokenType::Operator: return left.m_operator == right.m_operator; case Interpreter::TokenType::Number: return left.m_number == right.m_number; default: throw std::out_of_range("TokenType"); } } return false; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: throw std::out_of_range("TokenType"); } } typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); } } // namespace Lexer } // namespace Interpreter</code> <br> <br> <b class="spoiler_title">InterpreterTests.cpp</b> <code class="cpp">#include "stdafx.h" #include "CppUnitTest.h" #include "Interpreter.h" namespace InterpreterTests { using namespace Microsoft::VisualStudio::CppUnitTestFramework; using namespace Interpreter; using namespace std; namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual&lt;T&gt;(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange TEST_CLASS(LexerTests) { public: TEST_METHOD(Should_return_empty_token_list_when_put_empty_expression) { Tokens tokens = Lexer::Tokenize(L""); Assert::IsTrue(tokens.empty()); } TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); } TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); } TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); } TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); } }; TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); } TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); } TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); } }; }</code> <br> <br> <a href="https://github.com/Unril/InterpreterTDD/releases/tag/%25D0%259A%25D0%25BE%25D0%25BD%25D0%25B5%25D1%2586_%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B2%25D0%25BE%25D0%25B9_%25D1%2587%25D0%25B0%25D1%2581%25D1%2582%25D0%25B8">    GitHub</a> .         ,  .      "__". <br> <br>   <a href="http://habrahabr.ru/post/232081/">    </a> .      ,      <a href="http://habrahabr.ru/post/232097/">    </a> .</code> </div></div> <code><code>std::vector,      Tokens</code> .            . <br> <br> <code class="cpp">#pragma once; #include &lt;vector&gt; namespace Interpreter { struct Token {}; typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { inline Tokens Tokenize(std::string expr) { throw std::exception(); } } // namespace Lexer } // namespace Interpreter</code> <br>   ,  ,   , .   ,    ,    <a href="http://cleancoder.posterous.com/the-transformation-priority-premise">The Transformation Priority Premise (TPP)</a>   .    , ,    ,     ,        .            .     ,     ,      ,           .  ,  ,   (   )    ,  ,  .     ,  ,         .     ,   TPP          . <br> <br>   : <br> <br> ({} ‚Üí nil)     ,   . (nil ‚Üí constant)    . (constant ‚Üí constant+)      (        ,  ). (constant ‚Üí scalar)    ,  . (statement ‚Üí statements)    (break, continue, return  ). (unconditional ‚Üí if)       . (scalar ‚Üí array)  / . (array ‚Üí container)     . (statement ‚Üí recursion)   . (if ‚Üí while)    . (expression ‚Üí function)   . (variable ‚Üí assignment)   . <br>        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::string expr) { return{}; }</code> <br> ,         .     . <br> <br> <s>         </s> .           .           .               .            .       . <br>  ,  <code>std::string</code>  <code>std::wstring</code> .         ,      Unicode.     . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); }</code> <br>  <code>AssertRange</code> -   ,       <code>AreEqual</code> ,   ,  ,    . <br> <br> <b class="spoiler_title">AssertRange</b> <code class="cpp">namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange</code> <br> <br>         <code>Operator</code>    .          <code>wchar_t</code>   ,         ,      . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', }; typedef Operator Token;</code> <br>    ,   ,        <code>Assert</code> ,    <code>ToString</code> ,    . <br> <br> <b class="spoiler_title">std::wstring ToString(const Token &amp;)</b> <code class="cpp">inline std::wstring ToString(const Token &amp;token) { return{ static_cast&lt;wchar_t&gt;(token) }; }</code> <br> <br>    ,   ,        .  ,   (unconditional ‚Üí if). <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { if(expr.empty()) { return{}; } return{ static_cast&lt;Operator&gt;(expr[0]) }; }</code> <br> <s>         </s> . <s>          .</s>           . ‚Ä¶ <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); }</code> <br>     .   ,     ,   - .    , : <br> <br>        ,      <code>Token</code> .       <code>dynamic_cast</code>    ,   .  ,    ,      .      <code>std::function</code>        .        .  Boost.Any,  - .            . <br>   ,   .      -  .  ,      ,      . <br> <br> ‚Ä¶        .        .        .        . <br>             . <br> <br> <code class="cpp">enum class TokenType { Operator, Number }; class Token { public: Token(Operator) {} TokenType Type() const { return TokenType::Operator; } }; ‚Ä¶ TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } };</code> <br>   <code>ToString</code>   <code>TokenType</code>       ,   ,   .     . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); }</code> <br>   .   (constant ‚Üí scalar)   . <br> <br> <code class="cpp">class Token { public: Token(Operator) :m_type(TokenType::Operator) {} Token(double) :m_type(TokenType::Number) {} TokenType Type() const { return m_type; } private: TokenType m_type; };</code> <br> ‚Ä¶ <s>       </s> . <s>       </s> .        .        . <br>    . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); }</code> <br>            . <br> <br> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} operator Operator() const { return m_operator; } ‚Ä¶ Operator m_operator; };</code> <br>      . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); }</code> <br>          ,  ,       <code>union</code> .         . <br> <br> <b class="spoiler_title">Token</b> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: return "Unknown token."; } }</code> <br> <br>  ,    ,      ,    .       .    . <br> <br> <i>          .</i>               .            .       . <br>        : <br> <br> <code class="cpp"> if(expr[0] &gt;= '0' &amp;&amp; expr[0] &lt;= '9') { return{ (double) expr[0] - '0' }; } return{ static_cast&lt;Operator&gt;(expr[0]) };</code> <br>      ,   . <br> <br> ‚Ä¶ <s>          .</s> <i>              .</i> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); }</code> <br> ,     <code>C</code>   ,  <code>isdigit</code> , ,       <code>atof</code> ,    ,      <code>wchar_t</code> .  (expression ‚Üí function).         . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { const wchar_t *current = expr.c_str(); if(!*current) return{}; if(iswdigit(*current)) return{ _wtof(current) }; return{ static_cast&lt;Operator&gt;(*current) }; }</code> <br>         .      . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>   ,        .  ,     .     .   <code>result</code> ,     . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); if(!*current) return result; if(iswdigit(*current)) { result.push_back(_wtof(current)); } else { result.push_back(static_cast&lt;Operator&gt;(*current)); } return result; }</code> <br>      :   (if ‚Üí while).     ,        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } } return result; }</code> <br>  <code>wcstod</code>    ,   <code>_wtof</code> ,           .           ,              .  ,    . <br> <br> <s>           .</s>       . <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>  (unconditional ‚Üí if)    ,    . <br> <br> <code class="cpp"> while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else if(*current == static_cast&lt;wchar_t&gt;(Operator::Plus)) { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } else { ++current; } }</code> <br>       .          .       <code>Detail</code>      .   <code>Tokenize</code>       . <br> <br> <code class="cpp">inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); }</code> <br> <b class="spoiler_title"> Detail::Tokenizer</b> <code class="cpp">namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { return *m_current == static_cast&lt;wchar_t&gt;(Operator::Plus); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail</code> <br> <br>  ,      .      ,  , .       . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); }</code> <br>      <code>Operator</code> ,    . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', };</code> <br>   .         <code>IsOperator</code>  <code>Tokenizer</code> . <br> <br> <code class="cpp"> bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); }</code> <br>         .        . <br> <br> <b class="spoiler_title">Interpreter.h</b> <code class="cpp">#pragma once; #include &lt;vector&gt; #include &lt;wchar.h&gt; #include &lt;algorithm&gt; namespace Interpreter { enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', }; inline std::wstring ToString(const Operator &amp;op) { return{ static_cast&lt;wchar_t&gt;(op) }; } enum class TokenType { Operator, Number }; inline std::wstring ToString(const TokenType &amp;type) { switch(type) { case TokenType::Operator: return L"Operator"; case TokenType::Number: return L"Number"; default: throw std::out_of_range("TokenType"); } } class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } friend inline bool operator==(const Token &amp;left, const Token &amp;right) { if(left.m_type == right.m_type) { switch(left.m_type) { case Interpreter::TokenType::Operator: return left.m_operator == right.m_operator; case Interpreter::TokenType::Number: return left.m_number == right.m_number; default: throw std::out_of_range("TokenType"); } } return false; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: throw std::out_of_range("TokenType"); } } typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); } } // namespace Lexer } // namespace Interpreter</code> <br> <br> <b class="spoiler_title">InterpreterTests.cpp</b> <code class="cpp">#include "stdafx.h" #include "CppUnitTest.h" #include "Interpreter.h" namespace InterpreterTests { using namespace Microsoft::VisualStudio::CppUnitTestFramework; using namespace Interpreter; using namespace std; namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual&lt;T&gt;(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange TEST_CLASS(LexerTests) { public: TEST_METHOD(Should_return_empty_token_list_when_put_empty_expression) { Tokens tokens = Lexer::Tokenize(L""); Assert::IsTrue(tokens.empty()); } TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); } TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); } TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); } TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); } }; TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); } TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); } TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); } }; }</code> <br> <br> <a href="https://github.com/Unril/InterpreterTDD/releases/tag/%25D0%259A%25D0%25BE%25D0%25BD%25D0%25B5%25D1%2586_%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B2%25D0%25BE%25D0%25B9_%25D1%2587%25D0%25B0%25D1%2581%25D1%2582%25D0%25B8">    GitHub</a> .         ,  .      "__". <br> <br>   <a href="http://habrahabr.ru/post/232081/">    </a> .      ,      <a href="http://habrahabr.ru/post/232097/">    </a> .</code> <div class="spoiler"> <code><b class="spoiler_title"><code>std::vector,      Tokens</code> .            . <br> <br> <code class="cpp">#pragma once; #include &lt;vector&gt; namespace Interpreter { struct Token {}; typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { inline Tokens Tokenize(std::string expr) { throw std::exception(); } } // namespace Lexer } // namespace Interpreter</code> <br>   ,  ,   , .   ,    ,    <a href="http://cleancoder.posterous.com/the-transformation-priority-premise">The Transformation Priority Premise (TPP)</a>   .    , ,    ,     ,        .            .     ,     ,      ,           .  ,  ,   (   )    ,  ,  .     ,  ,         .     ,   TPP          . <br> <br>   : <br> <br> ({} ‚Üí nil)     ,   . (nil ‚Üí constant)    . (constant ‚Üí constant+)      (        ,  ). (constant ‚Üí scalar)    ,  . (statement ‚Üí statements)    (break, continue, return  ). (unconditional ‚Üí if)       . (scalar ‚Üí array)  / . (array ‚Üí container)     . (statement ‚Üí recursion)   . (if ‚Üí while)    . (expression ‚Üí function)   . (variable ‚Üí assignment)   . <br>        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::string expr) { return{}; }</code> <br> ,         .     . <br> <br> <s>         </s> .           .           .               .            .       . <br>  ,  <code>std::string</code>  <code>std::wstring</code> .         ,      Unicode.     . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); }</code> <br>  <code>AssertRange</code> -   ,       <code>AreEqual</code> ,   ,  ,    . <br> <br> <b class="spoiler_title">AssertRange</b> <code class="cpp">namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange</code> <br> <br>         <code>Operator</code>    .          <code>wchar_t</code>   ,         ,      . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', }; typedef Operator Token;</code> <br>    ,   ,        <code>Assert</code> ,    <code>ToString</code> ,    . <br> <br> <b class="spoiler_title">std::wstring ToString(const Token &amp;)</b> <code class="cpp">inline std::wstring ToString(const Token &amp;token) { return{ static_cast&lt;wchar_t&gt;(token) }; }</code> <br> <br>    ,   ,        .  ,   (unconditional ‚Üí if). <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { if(expr.empty()) { return{}; } return{ static_cast&lt;Operator&gt;(expr[0]) }; }</code> <br> <s>         </s> . <s>          .</s>           . ‚Ä¶ <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); }</code> <br>     .   ,     ,   - .    , : <br> <br>        ,      <code>Token</code> .       <code>dynamic_cast</code>    ,   .  ,    ,      .      <code>std::function</code>        .        .  Boost.Any,  - .            . <br>   ,   .      -  .  ,      ,      . <br> <br> ‚Ä¶        .        .        .        . <br>             . <br> <br> <code class="cpp">enum class TokenType { Operator, Number }; class Token { public: Token(Operator) {} TokenType Type() const { return TokenType::Operator; } }; ‚Ä¶ TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } };</code> <br>   <code>ToString</code>   <code>TokenType</code>       ,   ,   .     . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); }</code> <br>   .   (constant ‚Üí scalar)   . <br> <br> <code class="cpp">class Token { public: Token(Operator) :m_type(TokenType::Operator) {} Token(double) :m_type(TokenType::Number) {} TokenType Type() const { return m_type; } private: TokenType m_type; };</code> <br> ‚Ä¶ <s>       </s> . <s>       </s> .        .        . <br>    . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); }</code> <br>            . <br> <br> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} operator Operator() const { return m_operator; } ‚Ä¶ Operator m_operator; };</code> <br>      . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); }</code> <br>          ,  ,       <code>union</code> .         . <br> <br> <b class="spoiler_title">Token</b> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: return "Unknown token."; } }</code> <br> <br>  ,    ,      ,    .       .    . <br> <br> <i>          .</i>               .            .       . <br>        : <br> <br> <code class="cpp"> if(expr[0] &gt;= '0' &amp;&amp; expr[0] &lt;= '9') { return{ (double) expr[0] - '0' }; } return{ static_cast&lt;Operator&gt;(expr[0]) };</code> <br>      ,   . <br> <br> ‚Ä¶ <s>          .</s> <i>              .</i> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); }</code> <br> ,     <code>C</code>   ,  <code>isdigit</code> , ,       <code>atof</code> ,    ,      <code>wchar_t</code> .  (expression ‚Üí function).         . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { const wchar_t *current = expr.c_str(); if(!*current) return{}; if(iswdigit(*current)) return{ _wtof(current) }; return{ static_cast&lt;Operator&gt;(*current) }; }</code> <br>         .      . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>   ,        .  ,     .     .   <code>result</code> ,     . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); if(!*current) return result; if(iswdigit(*current)) { result.push_back(_wtof(current)); } else { result.push_back(static_cast&lt;Operator&gt;(*current)); } return result; }</code> <br>      :   (if ‚Üí while).     ,        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } } return result; }</code> <br>  <code>wcstod</code>    ,   <code>_wtof</code> ,           .           ,              .  ,    . <br> <br> <s>           .</s>       . <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>  (unconditional ‚Üí if)    ,    . <br> <br> <code class="cpp"> while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else if(*current == static_cast&lt;wchar_t&gt;(Operator::Plus)) { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } else { ++current; } }</code> <br>       .          .       <code>Detail</code>      .   <code>Tokenize</code>       . <br> <br> <code class="cpp">inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); }</code> <br> <b class="spoiler_title"> Detail::Tokenizer</b> <code class="cpp">namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { return *m_current == static_cast&lt;wchar_t&gt;(Operator::Plus); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail</code> <br> <br>  ,      .      ,  , .       . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); }</code> <br>      <code>Operator</code> ,    . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', };</code> <br>   .         <code>IsOperator</code>  <code>Tokenizer</code> . <br> <br> <code class="cpp"> bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); }</code> <br>         .        . <br> <br> <b class="spoiler_title">Interpreter.h</b> <code class="cpp">#pragma once; #include &lt;vector&gt; #include &lt;wchar.h&gt; #include &lt;algorithm&gt; namespace Interpreter { enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', }; inline std::wstring ToString(const Operator &amp;op) { return{ static_cast&lt;wchar_t&gt;(op) }; } enum class TokenType { Operator, Number }; inline std::wstring ToString(const TokenType &amp;type) { switch(type) { case TokenType::Operator: return L"Operator"; case TokenType::Number: return L"Number"; default: throw std::out_of_range("TokenType"); } } class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } friend inline bool operator==(const Token &amp;left, const Token &amp;right) { if(left.m_type == right.m_type) { switch(left.m_type) { case Interpreter::TokenType::Operator: return left.m_operator == right.m_operator; case Interpreter::TokenType::Number: return left.m_number == right.m_number; default: throw std::out_of_range("TokenType"); } } return false; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: throw std::out_of_range("TokenType"); } } typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); } } // namespace Lexer } // namespace Interpreter</code> <br> <br> InterpreterTests.cpp <code class="cpp">#include "stdafx.h" #include "CppUnitTest.h" #include "Interpreter.h" namespace InterpreterTests { using namespace Microsoft::VisualStudio::CppUnitTestFramework; using namespace Interpreter; using namespace std; namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual&lt;T&gt;(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange TEST_CLASS(LexerTests) { public: TEST_METHOD(Should_return_empty_token_list_when_put_empty_expression) { Tokens tokens = Lexer::Tokenize(L""); Assert::IsTrue(tokens.empty()); } TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); } TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); } TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); } TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); } }; TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); } TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); } TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); } }; }</code> <br> <br> <a href="https://github.com/Unril/InterpreterTDD/releases/tag/%25D0%259A%25D0%25BE%25D0%25BD%25D0%25B5%25D1%2586_%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B2%25D0%25BE%25D0%25B9_%25D1%2587%25D0%25B0%25D1%2581%25D1%2582%25D0%25B8">    GitHub</a> .         ,  .      "__". <br> <br>   <a href="http://habrahabr.ru/post/232081/">    </a> .      ,      <a href="http://habrahabr.ru/post/232097/">    </a> .</b></code> <div class="spoiler_text"> <pre> <code class="hljs lua"><code>std::vector,      Tokens</code> .            . <br> <br> <code class="cpp">#pragma once; #include &lt;vector&gt; namespace Interpreter { struct Token {}; typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { inline Tokens Tokenize(std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> expr) { throw std::exception(); } } // namespace Lexer } // namespace Interpreter</code> <br>   ,  ,   , .   ,    ,    <a href="http://cleancoder.posterous.com/the-transformation-priority-premise">The Transformation Priority Premise (TPP)</a>   .    , ,    ,     ,        .            .     ,     ,      ,           .  ,  ,   (   )    ,  ,  .     ,  ,         .     ,   TPP          . <br> <br>   : <br> <br> ({} ‚Üí <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)     ,   . (<span class="hljs-literal"><span class="hljs-literal">nil</span></span> ‚Üí constant)    . (constant ‚Üí constant+)      (        ,  ). (constant ‚Üí scalar)    ,  . (statement ‚Üí statements)    (<span class="hljs-keyword"><span class="hljs-keyword">break</span></span>, continue, <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>  ). (unconditional ‚Üí <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>)       . (scalar ‚Üí array)  / . (array ‚Üí container)     . (statement ‚Üí recursion)   . (<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ‚Üí <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>)    . (expression ‚Üí <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">)</span></span>   . (variable ‚Üí assignment)   . <br>        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> expr) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{}; }</code> <br> ,         .     . <br> <br> <s>         </s> .           .           .               .            .       . <br>  ,  <code>std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span></code>  <code>std::wstring</code> .         ,      Unicode.     . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"+"</span></span>); AssertRange::AreEqual({ Operator::Plus }, tokens); }</code> <br>  <code>AssertRange</code> -   ,       <code>AreEqual</code> ,   ,  ,    . <br> <br> <b class="spoiler_title">AssertRange</b> <code class="cpp">namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(expect)), distance(actualIter, <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(actual)), L<span class="hljs-string"><span class="hljs-string">"Size differs."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(; expectIter != <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(expect) &amp;&amp; actualIter != <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(actual); ++expectIter, ++actualIter) { auto message = L<span class="hljs-string"><span class="hljs-string">"Mismatch in position "</span></span> + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange</code> <br> <br>         <code>Operator</code>    .          <code>wchar_t</code>   ,         ,      . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L<span class="hljs-string"><span class="hljs-string">'+'</span></span>, }; typedef Operator Token;</code> <br>    ,   ,        <code>Assert</code> ,    <code>ToString</code> ,    . <br> <br> <b class="spoiler_title">std::wstring ToString(const Token &amp;)</b> <code class="cpp">inline std::wstring ToString(const Token &amp;token) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ static_cast&lt;wchar_t&gt;(token) }; }</code> <br> <br>    ,   ,        .  ,   (unconditional ‚Üí <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>). <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(expr.empty()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{}; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ static_cast&lt;Operator&gt;(expr[<span class="hljs-number"><span class="hljs-number">0</span></span>]) }; }</code> <br> <s>         </s> . <s>          .</s>           . ‚Ä¶ <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"1"</span></span>); AssertRange::AreEqual({ <span class="hljs-number"><span class="hljs-number">1.0</span></span> }, tokens); }</code> <br>     .   ,     ,   - .    , : <br> <br>        ,      <code>Token</code> .       <code>dynamic_cast</code>    ,   .  ,    ,      .      <code>std::<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span></span></code><span class="hljs-function"><span class="hljs-function">        .        .  </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Boost.Any</span></span></span><span class="hljs-function">,  - .            . </span></span><br><span class="hljs-function"><span class="hljs-function">   ,   .      -  .  ,      ,      . </span></span><br><span class="hljs-function"><span class="hljs-function"> </span></span><br><span class="hljs-function"><span class="hljs-function"> ‚Ä¶        .        .        .        . </span></span><br><span class="hljs-function"><span class="hljs-function">             . </span></span><br><span class="hljs-function"><span class="hljs-function"> </span></span><br><span class="hljs-function"><span class="hljs-function"> </span></span><code class="cpp"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">enum</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">class</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TokenType</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Operator</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Number</span></span></span><span class="hljs-function"> }; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">class</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Token</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">public</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Token</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Operator)</span></span></span></span> {} TokenType Type() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TokenType::Operator; } }; ‚Ä¶ TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } };</code> <br>   <code>ToString</code>   <code>TokenType</code>       ,   ,   .     . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_type_for_number_token) { Token numToken(<span class="hljs-number"><span class="hljs-number">1.2</span></span>); Assert::AreEqual(TokenType::Number, numToken.Type()); }</code> <br>   .   (constant ‚Üí scalar)   . <br> <br> <code class="cpp">class Token { public: Token(Operator) :m_type(TokenType::Operator) {} Token(double) :m_type(TokenType::Number) {} TokenType Type() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_type; } private: TokenType m_type; };</code> <br> ‚Ä¶ <s>       </s> . <s>       </s> .        .        . <br>    . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); }</code> <br>            . <br> <br> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} operator Operator() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_operator; } ‚Ä¶ Operator m_operator; };</code> <br>      . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_number_value_from_number_token) { Token token(<span class="hljs-number"><span class="hljs-number">1.23</span></span>); Assert::AreEqual&lt;double&gt;(<span class="hljs-number"><span class="hljs-number">1.23</span></span>, token); }</code> <br>          ,  ,       <code>union</code> .         . <br> <br> <b class="spoiler_title">Token</b> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_type; } operator Operator() const { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(m_type != TokenType::Operator) throw std::logic_error(<span class="hljs-string"><span class="hljs-string">"Should be operator token."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_operator; } operator double() const { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(m_type != TokenType::Number) throw std::logic_error(<span class="hljs-string"><span class="hljs-string">"Should be number token."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_number; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ToString(static_cast&lt;Operator&gt;(token)); default: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Unknown token."</span></span>; } }</code> <br> <br>  ,    ,      ,    .       .    . <br> <br> <i>          .</i>               .            .       . <br>        : <br> <br> <code class="cpp"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(expr[<span class="hljs-number"><span class="hljs-number">0</span></span>] &gt;= <span class="hljs-string"><span class="hljs-string">'0'</span></span> &amp;&amp; expr[<span class="hljs-number"><span class="hljs-number">0</span></span>] &lt;= <span class="hljs-string"><span class="hljs-string">'9'</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ (double) expr[<span class="hljs-number"><span class="hljs-number">0</span></span>] - <span class="hljs-string"><span class="hljs-string">'0'</span></span> }; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ static_cast&lt;Operator&gt;(expr[<span class="hljs-number"><span class="hljs-number">0</span></span>]) };</code> <br>      ,   . <br> <br> ‚Ä¶ <s>          .</s> <i>              .</i> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"12.34"</span></span>); AssertRange::AreEqual({ <span class="hljs-number"><span class="hljs-number">12.34</span></span> }, tokens); }</code> <br> ,     <code>C</code>   ,  <code>isdigit</code> , ,       <code>atof</code> ,    ,      <code>wchar_t</code> .  (expression ‚Üí <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">)</span></span>.         . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { const wchar_t *current = expr.c_str(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!*current) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{}; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(iswdigit(*current)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ _wtof(current) }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ static_cast&lt;Operator&gt;(*current) }; }</code> <br>         .      . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"+12.34"</span></span>); AssertRange::AreEqual({ Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">12.34</span></span>) }, tokens); }</code> <br>   ,        .  ,     .     .   <code>result</code> ,     . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!*current) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(iswdigit(*current)) { result.push_back(_wtof(current)); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { result.push_back(static_cast&lt;Operator&gt;(*current)); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> <br>      :   (<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ‚Üí <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>).     ,        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(*current) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(iswdigit(*current)) { wchar_t *<span class="hljs-keyword"><span class="hljs-keyword">end</span></span> = nullptr; result.push_back(wcstod(current, &amp;<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>)); current = <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> <br>  <code>wcstod</code>    ,   <code>_wtof</code> ,           .           ,              .  ,    . <br> <br> <s>           .</s>       . <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">" 1 + 12.34 "</span></span>); AssertRange::AreEqual({ Token(<span class="hljs-number"><span class="hljs-number">1.0</span></span>), Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">12.34</span></span>) }, tokens); }</code> <br>  (unconditional ‚Üí <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>)    ,    . <br> <br> <code class="cpp"> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(*current) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(iswdigit(*current)) { wchar_t *<span class="hljs-keyword"><span class="hljs-keyword">end</span></span> = nullptr; result.push_back(wcstod(current, &amp;<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>)); current = <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(*current == static_cast&lt;wchar_t&gt;(Operator::Plus)) { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { ++current; } }</code> <br>       .          .       <code>Detail</code>      .   <code>Tokenize</code>       . <br> <br> <code class="cpp">inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tokenizer.Result(); }</code> <br> <b class="spoiler_title"> Detail::Tokenizer</b> <code class="cpp">namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!EndOfExperssion()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(IsNumber()) { ScanNumber(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(IsOperator()) { ScanOperator(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { MoveNext(); } } } const Tokens &amp;Result() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_result; } private: bool EndOfExperssion() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_current == L<span class="hljs-string"><span class="hljs-string">'\0'</span></span>; } bool IsNumber() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> iswdigit(*m_current) != <span class="hljs-number"><span class="hljs-number">0</span></span>; } void ScanNumber() { wchar_t *<span class="hljs-keyword"><span class="hljs-keyword">end</span></span> = nullptr; m_result.push_back(wcstod(m_current, &amp;<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>)); m_current = <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; } bool IsOperator() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_current == static_cast&lt;wchar_t&gt;(Operator::Plus); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail</code> <br> <br>  ,      .      ,  , .       . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"1+2*3/(4-5)"</span></span>); AssertRange::AreEqual({ Token(<span class="hljs-number"><span class="hljs-number">1</span></span>), Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">2</span></span>), Token(Operator::Mul), Token(<span class="hljs-number"><span class="hljs-number">3</span></span>), Token(Operator::Div), Token(Operator::LParen), Token(<span class="hljs-number"><span class="hljs-number">4</span></span>), Token(Operator::Minus), Token(<span class="hljs-number"><span class="hljs-number">5</span></span>), Token(Operator::RParen) }, tokens); }</code> <br>      <code>Operator</code> ,    . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L<span class="hljs-string"><span class="hljs-string">'+'</span></span>, Minus = L<span class="hljs-string"><span class="hljs-string">'-'</span></span>, Mul = L<span class="hljs-string"><span class="hljs-string">'*'</span></span>, Div = L<span class="hljs-string"><span class="hljs-string">'/'</span></span>, LParen = L<span class="hljs-string"><span class="hljs-string">'('</span></span>, RParen = L<span class="hljs-string"><span class="hljs-string">')'</span></span>, };</code> <br>   .         <code>IsOperator</code>  <code>Tokenizer</code> . <br> <br> <code class="cpp"> bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> std::any_of(all.begin(), all.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(), [this](Operator o) {<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_current == static_cast&lt;wchar_t&gt;(o); }); }</code> <br>         .        . <br> <br> <b class="spoiler_title">Interpreter.h</b> <code class="cpp">#pragma once; #include &lt;vector&gt; #include &lt;wchar.h&gt; #include &lt;algorithm&gt; namespace Interpreter { enum class Operator : wchar_t { Plus = L<span class="hljs-string"><span class="hljs-string">'+'</span></span>, Minus = L<span class="hljs-string"><span class="hljs-string">'-'</span></span>, Mul = L<span class="hljs-string"><span class="hljs-string">'*'</span></span>, Div = L<span class="hljs-string"><span class="hljs-string">'/'</span></span>, LParen = L<span class="hljs-string"><span class="hljs-string">'('</span></span>, RParen = L<span class="hljs-string"><span class="hljs-string">')'</span></span>, }; inline std::wstring ToString(const Operator &amp;op) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{ static_cast&lt;wchar_t&gt;(op) }; } enum class TokenType { Operator, Number }; inline std::wstring ToString(const TokenType &amp;<span class="hljs-built_in"><span class="hljs-built_in">type</span></span>) { switch(<span class="hljs-built_in"><span class="hljs-built_in">type</span></span>) { case TokenType::Operator: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> L<span class="hljs-string"><span class="hljs-string">"Operator"</span></span>; case TokenType::Number: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> L<span class="hljs-string"><span class="hljs-string">"Number"</span></span>; default: throw std::out_of_range(<span class="hljs-string"><span class="hljs-string">"TokenType"</span></span>); } } class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_type; } operator Operator() const { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(m_type != TokenType::Operator) throw std::logic_error(<span class="hljs-string"><span class="hljs-string">"Should be operator token."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_operator; } operator double() const { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(m_type != TokenType::Number) throw std::logic_error(<span class="hljs-string"><span class="hljs-string">"Should be number token."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_number; } friend inline bool operator==(const Token &amp;left, const Token &amp;right) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(left.m_type == right.m_type) { switch(left.m_type) { case Interpreter::TokenType::Operator: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> left.m_operator == right.m_operator; case Interpreter::TokenType::Number: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> left.m_number == right.m_number; default: throw std::out_of_range(<span class="hljs-string"><span class="hljs-string">"TokenType"</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ToString(static_cast&lt;Operator&gt;(token)); default: throw std::out_of_range(<span class="hljs-string"><span class="hljs-string">"TokenType"</span></span>); } } typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!EndOfExperssion()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(IsNumber()) { ScanNumber(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(IsOperator()) { ScanOperator(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { MoveNext(); } } } const Tokens &amp;Result() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_result; } private: bool EndOfExperssion() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_current == L<span class="hljs-string"><span class="hljs-string">'\0'</span></span>; } bool IsNumber() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> iswdigit(*m_current) != <span class="hljs-number"><span class="hljs-number">0</span></span>; } void ScanNumber() { wchar_t *<span class="hljs-keyword"><span class="hljs-keyword">end</span></span> = nullptr; m_result.push_back(wcstod(m_current, &amp;<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>)); m_current = <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; } bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> std::any_of(all.begin(), all.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(), [this](Operator o) {<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_current == static_cast&lt;wchar_t&gt;(o); }); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tokenizer.Result(); } } // namespace Lexer } // namespace Interpreter</code> <br> <br> <b class="spoiler_title">InterpreterTests.cpp</b> <code class="cpp">#include <span class="hljs-string"><span class="hljs-string">"stdafx.h"</span></span> #include <span class="hljs-string"><span class="hljs-string">"CppUnitTest.h"</span></span> #include <span class="hljs-string"><span class="hljs-string">"Interpreter.h"</span></span> namespace InterpreterTests { using namespace Microsoft::VisualStudio::CppUnitTestFramework; using namespace Interpreter; using namespace std; namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(expect)), distance(actualIter, <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(actual)), L<span class="hljs-string"><span class="hljs-string">"Size differs."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(; expectIter != <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(expect) &amp;&amp; actualIter != <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(actual); ++expectIter, ++actualIter) { auto message = L<span class="hljs-string"><span class="hljs-string">"Mismatch in position "</span></span> + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual&lt;T&gt;(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange TEST_CLASS(LexerTests) { public: TEST_METHOD(Should_return_empty_token_list_when_put_empty_expression) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">""</span></span>); Assert::IsTrue(tokens.empty()); } TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"+"</span></span>); AssertRange::AreEqual({ Operator::Plus }, tokens); } TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"1"</span></span>); AssertRange::AreEqual({ <span class="hljs-number"><span class="hljs-number">1.0</span></span> }, tokens); } TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"12.34"</span></span>); AssertRange::AreEqual({ <span class="hljs-number"><span class="hljs-number">12.34</span></span> }, tokens); } TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"+12.34"</span></span>); AssertRange::AreEqual({ Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">12.34</span></span>) }, tokens); } TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">" 1 + 12.34 "</span></span>); AssertRange::AreEqual({ Token(<span class="hljs-number"><span class="hljs-number">1.0</span></span>), Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">12.34</span></span>) }, tokens); } TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L<span class="hljs-string"><span class="hljs-string">"1+2*3/(4-5)"</span></span>); AssertRange::AreEqual({ Token(<span class="hljs-number"><span class="hljs-number">1</span></span>), Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">2</span></span>), Token(Operator::Mul), Token(<span class="hljs-number"><span class="hljs-number">3</span></span>), Token(Operator::Div), Token(Operator::LParen), Token(<span class="hljs-number"><span class="hljs-number">4</span></span>), Token(Operator::Minus), Token(<span class="hljs-number"><span class="hljs-number">5</span></span>), Token(Operator::RParen) }, tokens); } }; TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } TEST_METHOD(Should_get_type_for_number_token) { Token numToken(<span class="hljs-number"><span class="hljs-number">1.2</span></span>); Assert::AreEqual(TokenType::Number, numToken.Type()); } TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); } TEST_METHOD(Should_get_number_value_from_number_token) { Token token(<span class="hljs-number"><span class="hljs-number">1.23</span></span>); Assert::AreEqual&lt;double&gt;(<span class="hljs-number"><span class="hljs-number">1.23</span></span>, token); } }; }</code> <br> <br> <a href="https://github.com/Unril/InterpreterTDD/releases/tag/%25D0%259A%25D0%25BE%25D0%25BD%25D0%25B5%25D1%2586_%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B2%25D0%25BE%25D0%25B9_%25D1%2587%25D0%25B0%25D1%2581%25D1%2582%25D0%25B8">    GitHub</a> .         ,  .      <span class="hljs-string"><span class="hljs-string">"__"</span></span>. <br> <br>   <a href="http://habrahabr.ru/post/232081/">    </a> .      ,      <a href="http://habrahabr.ru/post/232097/">    </a> .</code> </pre> <code><code>std::vector,      Tokens</code> .            . <br> <br> <code class="cpp">#pragma once; #include &lt;vector&gt; namespace Interpreter { struct Token {}; typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { inline Tokens Tokenize(std::string expr) { throw std::exception(); } } // namespace Lexer } // namespace Interpreter</code> <br>   ,  ,   , .   ,    ,    <a href="http://cleancoder.posterous.com/the-transformation-priority-premise">The Transformation Priority Premise (TPP)</a>   .    , ,    ,     ,        .            .     ,     ,      ,           .  ,  ,   (   )    ,  ,  .     ,  ,         .     ,   TPP          . <br> <br>   : <br> <br> ({} ‚Üí nil)     ,   . (nil ‚Üí constant)    . (constant ‚Üí constant+)      (        ,  ). (constant ‚Üí scalar)    ,  . (statement ‚Üí statements)    (break, continue, return  ). (unconditional ‚Üí if)       . (scalar ‚Üí array)  / . (array ‚Üí container)     . (statement ‚Üí recursion)   . (if ‚Üí while)    . (expression ‚Üí function)   . (variable ‚Üí assignment)   . <br>        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::string expr) { return{}; }</code> <br> ,         .     . <br> <br> <s>         </s> .           .           .               .            .       . <br>  ,  <code>std::string</code>  <code>std::wstring</code> .         ,      Unicode.     . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); }</code> <br>  <code>AssertRange</code> -   ,       <code>AreEqual</code> ,   ,  ,    . <br> <br> <b class="spoiler_title">AssertRange</b> <code class="cpp">namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange</code> <br> <br>         <code>Operator</code>    .          <code>wchar_t</code>   ,         ,      . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', }; typedef Operator Token;</code> <br>    ,   ,        <code>Assert</code> ,    <code>ToString</code> ,    . <br> <br> <b class="spoiler_title">std::wstring ToString(const Token &amp;)</b> <code class="cpp">inline std::wstring ToString(const Token &amp;token) { return{ static_cast&lt;wchar_t&gt;(token) }; }</code> <br> <br>    ,   ,        .  ,   (unconditional ‚Üí if). <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { if(expr.empty()) { return{}; } return{ static_cast&lt;Operator&gt;(expr[0]) }; }</code> <br> <s>         </s> . <s>          .</s>           . ‚Ä¶ <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); }</code> <br>     .   ,     ,   - .    , : <br> <br>        ,      <code>Token</code> .       <code>dynamic_cast</code>    ,   .  ,    ,      .      <code>std::function</code>        .        .  Boost.Any,  - .            . <br>   ,   .      -  .  ,      ,      . <br> <br> ‚Ä¶        .        .        .        . <br>             . <br> <br> <code class="cpp">enum class TokenType { Operator, Number }; class Token { public: Token(Operator) {} TokenType Type() const { return TokenType::Operator; } }; ‚Ä¶ TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } };</code> <br>   <code>ToString</code>   <code>TokenType</code>       ,   ,   .     . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); }</code> <br>   .   (constant ‚Üí scalar)   . <br> <br> <code class="cpp">class Token { public: Token(Operator) :m_type(TokenType::Operator) {} Token(double) :m_type(TokenType::Number) {} TokenType Type() const { return m_type; } private: TokenType m_type; };</code> <br> ‚Ä¶ <s>       </s> . <s>       </s> .        .        . <br>    . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); }</code> <br>            . <br> <br> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} operator Operator() const { return m_operator; } ‚Ä¶ Operator m_operator; };</code> <br>      . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); }</code> <br>          ,  ,       <code>union</code> .         . <br> <br> <b class="spoiler_title">Token</b> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: return "Unknown token."; } }</code> <br> <br>  ,    ,      ,    .       .    . <br> <br> <i>          .</i>               .            .       . <br>        : <br> <br> <code class="cpp"> if(expr[0] &gt;= '0' &amp;&amp; expr[0] &lt;= '9') { return{ (double) expr[0] - '0' }; } return{ static_cast&lt;Operator&gt;(expr[0]) };</code> <br>      ,   . <br> <br> ‚Ä¶ <s>          .</s> <i>              .</i> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); }</code> <br> ,     <code>C</code>   ,  <code>isdigit</code> , ,       <code>atof</code> ,    ,      <code>wchar_t</code> .  (expression ‚Üí function).         . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { const wchar_t *current = expr.c_str(); if(!*current) return{}; if(iswdigit(*current)) return{ _wtof(current) }; return{ static_cast&lt;Operator&gt;(*current) }; }</code> <br>         .      . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>   ,        .  ,     .     .   <code>result</code> ,     . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); if(!*current) return result; if(iswdigit(*current)) { result.push_back(_wtof(current)); } else { result.push_back(static_cast&lt;Operator&gt;(*current)); } return result; }</code> <br>      :   (if ‚Üí while).     ,        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } } return result; }</code> <br>  <code>wcstod</code>    ,   <code>_wtof</code> ,           .           ,              .  ,    . <br> <br> <s>           .</s>       . <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>  (unconditional ‚Üí if)    ,    . <br> <br> <code class="cpp"> while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else if(*current == static_cast&lt;wchar_t&gt;(Operator::Plus)) { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } else { ++current; } }</code> <br>       .          .       <code>Detail</code>      .   <code>Tokenize</code>       . <br> <br> <code class="cpp">inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); }</code> <br> <b class="spoiler_title"> Detail::Tokenizer</b> <code class="cpp">namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { return *m_current == static_cast&lt;wchar_t&gt;(Operator::Plus); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail</code> <br> <br>  ,      .      ,  , .       . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); }</code> <br>      <code>Operator</code> ,    . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', };</code> <br>   .         <code>IsOperator</code>  <code>Tokenizer</code> . <br> <br> <code class="cpp"> bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); }</code> <br>         .        . <br> <br> <b class="spoiler_title">Interpreter.h</b> <code class="cpp">#pragma once; #include &lt;vector&gt; #include &lt;wchar.h&gt; #include &lt;algorithm&gt; namespace Interpreter { enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', }; inline std::wstring ToString(const Operator &amp;op) { return{ static_cast&lt;wchar_t&gt;(op) }; } enum class TokenType { Operator, Number }; inline std::wstring ToString(const TokenType &amp;type) { switch(type) { case TokenType::Operator: return L"Operator"; case TokenType::Number: return L"Number"; default: throw std::out_of_range("TokenType"); } } class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } friend inline bool operator==(const Token &amp;left, const Token &amp;right) { if(left.m_type == right.m_type) { switch(left.m_type) { case Interpreter::TokenType::Operator: return left.m_operator == right.m_operator; case Interpreter::TokenType::Number: return left.m_number == right.m_number; default: throw std::out_of_range("TokenType"); } } return false; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: throw std::out_of_range("TokenType"); } } typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); } } // namespace Lexer } // namespace Interpreter</code> <br> <br> <b class="spoiler_title">InterpreterTests.cpp</b> <code class="cpp">#include "stdafx.h" #include "CppUnitTest.h" #include "Interpreter.h" namespace InterpreterTests { using namespace Microsoft::VisualStudio::CppUnitTestFramework; using namespace Interpreter; using namespace std; namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual&lt;T&gt;(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange TEST_CLASS(LexerTests) { public: TEST_METHOD(Should_return_empty_token_list_when_put_empty_expression) { Tokens tokens = Lexer::Tokenize(L""); Assert::IsTrue(tokens.empty()); } TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); } TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); } TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); } TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); } }; TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); } TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); } TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); } }; }</code> <br> <br> <a href="https://github.com/Unril/InterpreterTDD/releases/tag/%25D0%259A%25D0%25BE%25D0%25BD%25D0%25B5%25D1%2586_%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B2%25D0%25BE%25D0%25B9_%25D1%2587%25D0%25B0%25D1%2581%25D1%2582%25D0%25B8">    GitHub</a> .         ,  .      "__". <br> <br>   <a href="http://habrahabr.ru/post/232081/">    </a> .      ,      <a href="http://habrahabr.ru/post/232097/">    </a> .</code> </div></div> <code><code>std::vector,      Tokens</code> .            . <br> <br> <code class="cpp">#pragma once; #include &lt;vector&gt; namespace Interpreter { struct Token {}; typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { inline Tokens Tokenize(std::string expr) { throw std::exception(); } } // namespace Lexer } // namespace Interpreter</code> <br>   ,  ,   , .   ,    ,    <a href="http://cleancoder.posterous.com/the-transformation-priority-premise">The Transformation Priority Premise (TPP)</a>   .    , ,    ,     ,        .            .     ,     ,      ,           .  ,  ,   (   )    ,  ,  .     ,  ,         .     ,   TPP          . <br> <br>   : <br> <br> ({} ‚Üí nil)     ,   . (nil ‚Üí constant)    . (constant ‚Üí constant+)      (        ,  ). (constant ‚Üí scalar)    ,  . (statement ‚Üí statements)    (break, continue, return  ). (unconditional ‚Üí if)       . (scalar ‚Üí array)  / . (array ‚Üí container)     . (statement ‚Üí recursion)   . (if ‚Üí while)    . (expression ‚Üí function)   . (variable ‚Üí assignment)   . <br>        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::string expr) { return{}; }</code> <br> ,         .     . <br> <br> <s>         </s> .           .           .               .            .       . <br>  ,  <code>std::string</code>  <code>std::wstring</code> .         ,      Unicode.     . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); }</code> <br>  <code>AssertRange</code> -   ,       <code>AreEqual</code> ,   ,  ,    . <br> <br> <b class="spoiler_title">AssertRange</b> <code class="cpp">namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange</code> <br> <br>         <code>Operator</code>    .          <code>wchar_t</code>   ,         ,      . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', }; typedef Operator Token;</code> <br>    ,   ,        <code>Assert</code> ,    <code>ToString</code> ,    . <br> <br> <b class="spoiler_title">std::wstring ToString(const Token &amp;)</b> <code class="cpp">inline std::wstring ToString(const Token &amp;token) { return{ static_cast&lt;wchar_t&gt;(token) }; }</code> <br> <br>    ,   ,        .  ,   (unconditional ‚Üí if). <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { if(expr.empty()) { return{}; } return{ static_cast&lt;Operator&gt;(expr[0]) }; }</code> <br> <s>         </s> . <s>          .</s>           . ‚Ä¶ <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); }</code> <br>     .   ,     ,   - .    , : <br> <br>        ,      <code>Token</code> .       <code>dynamic_cast</code>    ,   .  ,    ,      .      <code>std::function</code>        .        .  Boost.Any,  - .            . <br>   ,   .      -  .  ,      ,      . <br> <br> ‚Ä¶        .        .        .        . <br>             . <br> <br> <code class="cpp">enum class TokenType { Operator, Number }; class Token { public: Token(Operator) {} TokenType Type() const { return TokenType::Operator; } }; ‚Ä¶ TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } };</code> <br>   <code>ToString</code>   <code>TokenType</code>       ,   ,   .     . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); }</code> <br>   .   (constant ‚Üí scalar)   . <br> <br> <code class="cpp">class Token { public: Token(Operator) :m_type(TokenType::Operator) {} Token(double) :m_type(TokenType::Number) {} TokenType Type() const { return m_type; } private: TokenType m_type; };</code> <br> ‚Ä¶ <s>       </s> . <s>       </s> .        .        . <br>    . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); }</code> <br>            . <br> <br> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} operator Operator() const { return m_operator; } ‚Ä¶ Operator m_operator; };</code> <br>      . <br> <br> <code class="cpp"> TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); }</code> <br>          ,  ,       <code>union</code> .         . <br> <br> <b class="spoiler_title">Token</b> <code class="cpp">class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: return "Unknown token."; } }</code> <br> <br>  ,    ,      ,    .       .    . <br> <br> <i>          .</i>               .            .       . <br>        : <br> <br> <code class="cpp"> if(expr[0] &gt;= '0' &amp;&amp; expr[0] &lt;= '9') { return{ (double) expr[0] - '0' }; } return{ static_cast&lt;Operator&gt;(expr[0]) };</code> <br>      ,   . <br> <br> ‚Ä¶ <s>          .</s> <i>              .</i> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); }</code> <br> ,     <code>C</code>   ,  <code>isdigit</code> , ,       <code>atof</code> ,    ,      <code>wchar_t</code> .  (expression ‚Üí function).         . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { const wchar_t *current = expr.c_str(); if(!*current) return{}; if(iswdigit(*current)) return{ _wtof(current) }; return{ static_cast&lt;Operator&gt;(*current) }; }</code> <br>         .      . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>   ,        .  ,     .     .   <code>result</code> ,     . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); if(!*current) return result; if(iswdigit(*current)) { result.push_back(_wtof(current)); } else { result.push_back(static_cast&lt;Operator&gt;(*current)); } return result; }</code> <br>      :   (if ‚Üí while).     ,        . <br> <br> <code class="cpp">inline Tokens Tokenize(std::wstring expr) { Tokens result; const wchar_t *current = expr.c_str(); while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } } return result; }</code> <br>  <code>wcstod</code>    ,   <code>_wtof</code> ,           .           ,              .  ,    . <br> <br> <s>           .</s>       . <br>   . <br> <br> <code class="cpp"> TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); }</code> <br>  (unconditional ‚Üí if)    ,    . <br> <br> <code class="cpp"> while(*current) { if(iswdigit(*current)) { wchar_t *end = nullptr; result.push_back(wcstod(current, &amp;end)); current = end; } else if(*current == static_cast&lt;wchar_t&gt;(Operator::Plus)) { result.push_back(static_cast&lt;Operator&gt;(*current)); ++current; } else { ++current; } }</code> <br>       .          .       <code>Detail</code>      .   <code>Tokenize</code>       . <br> <br> <code class="cpp">inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); }</code> <br> <b class="spoiler_title"> Detail::Tokenizer</b> <code class="cpp">namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { return *m_current == static_cast&lt;wchar_t&gt;(Operator::Plus); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail</code> <br> <br>  ,      .      ,  , .       . <br> <br> <code class="cpp"> TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); }</code> <br>      <code>Operator</code> ,    . <br> <br> <code class="cpp">enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', };</code> <br>   .         <code>IsOperator</code>  <code>Tokenizer</code> . <br> <br> <code class="cpp"> bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); }</code> <br>         .        . <br> <br> <b class="spoiler_title">Interpreter.h</b> <code class="cpp">#pragma once; #include &lt;vector&gt; #include &lt;wchar.h&gt; #include &lt;algorithm&gt; namespace Interpreter { enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', }; inline std::wstring ToString(const Operator &amp;op) { return{ static_cast&lt;wchar_t&gt;(op) }; } enum class TokenType { Operator, Number }; inline std::wstring ToString(const TokenType &amp;type) { switch(type) { case TokenType::Operator: return L"Operator"; case TokenType::Number: return L"Number"; default: throw std::out_of_range("TokenType"); } } class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) throw std::logic_error("Should be operator token."); return m_operator; } operator double() const { if(m_type != TokenType::Number) throw std::logic_error("Should be number token."); return m_number; } friend inline bool operator==(const Token &amp;left, const Token &amp;right) { if(left.m_type == right.m_type) { switch(left.m_type) { case Interpreter::TokenType::Operator: return left.m_operator == right.m_operator; case Interpreter::TokenType::Number: return left.m_number == right.m_number; default: throw std::out_of_range("TokenType"); } } return false; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: throw std::out_of_range("TokenType"); } } typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); } } // namespace Lexer } // namespace Interpreter</code> <br> <br> <b class="spoiler_title">InterpreterTests.cpp</b> <code class="cpp">#include "stdafx.h" #include "CppUnitTest.h" #include "Interpreter.h" namespace InterpreterTests { using namespace Microsoft::VisualStudio::CppUnitTestFramework; using namespace Interpreter; using namespace std; namespace AssertRange { template&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual&lt;T&gt;(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange TEST_CLASS(LexerTests) { public: TEST_METHOD(Should_return_empty_token_list_when_put_empty_expression) { Tokens tokens = Lexer::Tokenize(L""); Assert::IsTrue(tokens.empty()); } TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ Operator::Plus }, tokens); } TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ 1.0 }, tokens); } TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); } TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ Token(1.0), Token(Operator::Plus), Token(12.34) }, tokens); } TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Mul), Token(3), Token(Operator::Div), Token(Operator::LParen), Token(4), Token(Operator::Minus), Token(5), Token(Operator::RParen) }, tokens); } }; TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); } TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); } TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); } }; }</code> <br> <br> <a href="https://github.com/Unril/InterpreterTDD/releases/tag/%25D0%259A%25D0%25BE%25D0%25BD%25D0%25B5%25D1%2586_%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B2%25D0%25BE%25D0%25B9_%25D1%2587%25D0%25B0%25D1%2581%25D1%2582%25D0%25B8">    GitHub</a> .         ,  .      "__". <br> <br>   <a href="http://habrahabr.ru/post/232081/">    </a> .      ,      <a href="http://habrahabr.ru/post/232097/">    </a> .</code> </div><p>Source: <a href="https://habr.com/ru/post/231657/">https://habr.com/ru/post/231657/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../231641/index.html">How we did a social network for motorists</a></li>
<li><a href="../231645/index.html">E-commerce platform. Introduction. Part 1</a></li>
<li><a href="../231647/index.html">15 Hyper-V Security Principles</a></li>
<li><a href="../231653/index.html">Linux Mint 17 and DLNA</a></li>
<li><a href="../231655/index.html">September 17th, we invite you to the conference Fujitsu World Tour 2014</a></li>
<li><a href="../231665/index.html">Handling exceptions in asynchronous code when upgrading to .NET 4.5</a></li>
<li><a href="../231667/index.html">12 rules of good taste in business communication in English</a></li>
<li><a href="../231671/index.html">Gentleman's kit tester version ZeptoLab</a></li>
<li><a href="../231679/index.html">Literacy is not in decline</a></li>
<li><a href="../231685/index.html">PHPCI updated to version 1.3</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>