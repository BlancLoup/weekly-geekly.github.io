<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We study STM32 in practice. Part 1. Screen connection from Siemens C55</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Disclaimer! The authors do not guarantee the ultimate truth, in any case due to the inexperience in the new sphere. If you see a gross technical error...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We study STM32 in practice. Part 1. Screen connection from Siemens C55</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/storage2/a3b/a0b/a02/a3ba0ba022cbd403eef8f54b3e175d60.jpg"><br><br><blockquote>  <b><b><font color="red">Disclaimer!</font></b></b>  The authors do not guarantee the ultimate truth, in any case due to the inexperience in the new sphere.  If you see a gross technical error, we kindly ask you to report it as soon as possible! </blockquote><br><br>  Brought together somehow the fate of a novice programmer and novice electronics engineer together.  And they began to create.  They made a dozen small bear toys with <a href="http://soundexpressiongreetings.com/musical-greetings/recordable-sound-modules.html">recording sound modules</a> and realized that using single-function cards was not so fun.  And in the bright summer evenings they gathered and thought, what would make them so interesting?  Fate helped them a second time: they found an advertisement for the sale of the STM32VLDiscovery debugging board in Russia and a week later with shaking hands they unpacked the package and "blinked" the LEDs.  From the feeling of complete power over a tiny device, my eyes lit up and earned brains.  It was decided: to make an ‚Äúelectronic bracelet‚Äù with some interesting functionality, using the full potential of their new ‚Äútoy‚Äù ... <br><a name="habracut"></a><br>  The eyes lit up even more when we learned about the possible ways to use the STM32.  First of all, we thought about connecting all kinds of peripherals.  We had a seven-segment LCD on the hands of the Soviet watches.  They hooked up, wrote a timer, but could not calm down ... 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The next day, we went to a small shop at a service center and were stunned by the huge number of phones for analysis: 3 stands completely filled with various ‚Äúhits‚Äù among the cell phones of previous years.  A total of 80 rubles was bought by Siemens C55, which later became our donor. <br>  <b>Having scratched</b> through the case, we got IT: a monochrome LCD screen <b>LPH7999-4</b> with a resolution of 102 by 64 pixels.  It consists of, in fact, the LCD matrix and the <a href="https://dl.dropboxusercontent.com/u/12696741/habrahabr/PCF8812.pdf"><b>PCF8812</b></a> controller <a href="https://dl.dropboxusercontent.com/u/12696741/habrahabr/PCF8812.pdf">(link to the datasheet)</a> .  The controller also consists of DDRAM, in which pixel states (1 \ 0), I \ O-buffer, several current generators and logic elements are stored in the form of a table, bit by bit.  All actions with LCD occur directly with the controller through 8 legs VDD, SCK, MISO, DC, SS, GND, VOUT, RES, of which two are closed through the capacitor, and the rest are connected to the legs of our processor. <br><br>  At the same time, the thought passed through our heads: ‚ÄúWhat kind of incomprehensible designations are these and how can we manage this at all?‚Äù  With an expression of complete sadness and hopelessness, we began to google, constantly bumping into articles full of unknown terms.  As a result, after several days, new information has been added to our heads. <br><br><img src="https://habrastorage.org/storage2/488/3fb/455/4883fb4558f9cda124f75f2352e30c54.jpg"><br><img src="https://habrastorage.org/storage2/527/b27/9f1/527b279f15d31e5f12015bc9378c4201.jpg"><br><br><table><tbody><tr><td>  MOSI (or SIMO, SDO, DO, DOUT, SO, MTSR) <br>  Master Output Slave Input <br></td><td>  Master output, which must be connected to the Slave inputs </td></tr><tr><td>  MISO (or SOMI, SDI, DI, DIN, SI, MRST) <br>  Master Input Slave Output <br></td><td>  Master's input to which Slave's outputs go </td></tr><tr><td>  SCK (or SCLK, CLK) <br></td><td>  supplied clock frequency for "parsing" of bits from MISO \ MOSI </td></tr><tr><td>  SS (or CS) <br></td><td>  selection of the peripheral device with which we will work. <br>  If there are more than one device, then to work with a specific one, you need to turn OFF the jumper foot on the selected one and ON on all other devices. <br></td></tr></tbody></table><br><br>  So, to control our LCD, we need to use SPI, a standardized interface for communicating with peripherals.  To use it, you need to understand the principle of work and all the terminology associated with it, and in particular the names and purposes of all the legs. <br><br>  The SPI interface assumes that we have some ONE device that will control everything (Master) and a lot of controlled peripherals, such as sensors, LCD \ LCD, memory cards, ADC \ DAC, etc.  (Slave).  On our Master, we have to choose 3 legs for receiving / transmitting data and n legs-jumpers, where n is the number of connected peripheral devices.  On Slave devices, legs for receiving / sending are usually defined in advance (if this is, of course, not another processor) and are described in the corresponding datasheets. <br><br>  Let us consider an example of the work of transmitting and receiving data between an abstract Master and one abstract Slave device. <br>  <b><font color="red">Note!</font></b>  SPI is organized as follows: when transferring data from MOSI Master to MISO Slave, data is transferred simultaneously from MOSI Slave to MISO Master and vice versa.  Thus, the SCK signal is the same for MISO and MOSI, respectively, they work the same way. <br><br>  When transmitting one byte, the SCK and MOSI outputs are involved.  Our SCK output is clocked pulses (voltage drops from a logical zero to a logical one).  When transmitting a logical unit at the output voltage ~ 3.3V, when transmitting zero, respectively ~ 0V.  The duration of the state of logical zero and logical unit are equal and are set programmatically.  When transmitting one byte, each bit has a pulse.  Thus, at the SCK output, when transmitting a byte, we can see eight identical ‚Äúhumps‚Äù.  At the MOSI output, our information is transmitted directly.  For example, if we transmit 10000001, the signal will look like a big pit, and if 10011001, then a pit with a protrusion in the middle.  I think it‚Äôs clear how both outputs work separately now, but now we‚Äôll tell you how they are coordinated with each other. <br><br>  <u>In idle mode.</u>  The moment when nothing is transmitted, that is, in the interval between the transfer of bytes or before they begin to transmit when SPI is enabled.  It would be logical to assume that in the absence of any operations on both inputs would be 0. But no, in the idle mode on MOSI, the voltage of a logical unit, on SCK, is either a logical unit or zero.  This is the state of SCK we can choose for ourselves. <br><br>  <u>In transfer mode.</u>  Here we have to choose how the impulses of the SCK and MOSI ports will be matched.  To do this, you have to enter a few bad words: <br>  A front is a transition from one state to another, that is, a voltage jump from a logical one to a logical zero.  In the image of the pulse, these are vertical sticks. <br>  The front is growing and falling: growing - the transition from a logical zero to a logical one, a falling one - on the contrary, from a logical one to a logical zero. <br>  The front is also the front and rear: the front is the first jump that occurred after the idle mode, the rear edge is the second jump that occurred after the idle mode. <br><br>  The developer can choose for SCK the idle mode (logical one or zero) and the transfer mode (on the leading or trailing edge).  Total, there are 4 modes of operation: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/160/88d/360/16088d360fce4945ef82157815039377.jpg" align="left"><br>  <b>Mode 0 (00):</b> <br>  The idle mode is a logical zero. <br>  Transfer to the leading edge. <br>  Since we chose transmission on the leading edge, during the transition from the voltage of the logical zero to the voltage of the logical unit on the SCK, a bit will be transmitted to the MOSI. <br><br clear="all"><img src="https://habrastorage.org/getpro/habr/post_images/77a/0b0/6c4/77a0b06c42565c5b9acaf1dc699d4bb1.jpg" align="left"><br>  <b>Mode 1 (01):</b> <br>  The idle mode is a logical zero. <br>  Transfer on the falling edge. <br>  Since we chose the transmission on the falling edge, then the rising front comes first, then the voltage of a logical zero lasts for a while, then the falling falling front goes.  After that, a bit will be transmitted to MOSI. <br><br clear="all"><img src="https://habrastorage.org/getpro/habr/post_images/788/8cc/dba/7888ccdba2f44f55519fce762a725ce0.jpg" align="left"><br>  <b>Mode 2 (10):</b> <br>  Idle mode is a logical unit. <br>  Transfer to the leading edge. <br>  During transmission, an impulse is sent to SCK.  But it is not growing, as opposed to the two previous modes, but falling.  Since the voltage of the logical unit of voltage cannot be higher, the first impulse goes "down."  It was during this transition (after all, we chose the leading edge) that the bit is transmitted to MOSI. <br><br clear="all"><img src="https://habrastorage.org/getpro/habr/post_images/a60/ab0/1e2/a60ab01e2a55e953a7cf5379ac1b2a73.jpg" align="left"><br>  <b>Mode 3 (11):</b> <br>  Idle mode is a logical unit. <br>  Transfer on the falling edge. <br>  During transmission, the impulse goes to SCK, first falling down, then increasing.  At this time there is a transition to MOSI. <br><br clear="all">  Usually, the mode of operation is not indicated in datasheets, but it is easy to get if you study the behavior of MOSI \ MISO and SCK on any chart in the datasheet. <br><br><img src="https://habrastorage.org/storage2/404/89e/dff/40489edff0d814d0116e75b133874115.jpg"><br><br>  So what can we manage on our controller? <br>  First, we have the memory that the controller displays on the LCD matrix. <br>  Secondly, we have a memory carriage with coordinates X and Y <br>  Third, we have about a dozen different bits: <br><pre>  Bit PD - if 0, then the controller is on, if 1 - then the controller is in sleep mode
	 Bit V - if 0, then after the data is written, the carriage shifts by X by one, otherwise Y shift by 9 (that is, immediately after the recorded bar)
	 Bit H - if 0, then the mode is enabled to work with the usual set of instructions, if 1 - then with extended
	 Bits D and E are responsible for the display mode:
		 00 - all pixels are off
		 01 - all pixels are lit
		 10 - if the state of a pixel in memory is 1, then it is on, if it is 0, then it is off (normal mode)
		 11 - if the state of a pixel in memory is 1, then it is NOT lit, if 0, then it is lit (inversion)
	 Bits TC1 and TC0 are responsible for the LCD temperature coefficient.
		 00 - coefficient 0
		 01 - coefficient 1
		 10 - coefficient 2
		 11 - coefficient 3
	 Bits S1 and S0 are responsible for the internal power multiplier, i.e.  theoretically how many times the food, 
		 filed on VDD will be different from internal power
		 00 - twice as much
		 01 - three times more
		 10 - four times more
		 11 - five times bot
	 Bits Vop6-Vop0 responsible for the magnitude of the original internal voltage
	 The BS2-BS0 bits are responsible for the system offset.
</pre><br><br>  Now we give the possible commands for management.  Each of them is formed of exactly 8 bits: <br><table><tbody><tr><td>  <i>(in any mode of instructions)</i> </td></tr><tr><td>  set registers PD, V, H </td><td>  0 </td><td>  0 </td><td>  one </td><td>  0 </td><td>  0 </td><td>  PD </td><td>  V </td><td>  H </td></tr><tr><td>  <i>(in the usual set of instructions)</i> </td></tr><tr><td>  set registers D, E </td><td>  0 </td><td>  0 </td><td>  0 </td><td>  0 </td><td>  one </td><td>  D </td><td>  0 </td><td>  E </td></tr><tr><td>  set the X coordinate of the carriage ( <img src="https://habrastorage.org/storage2/236/524/8ef/2365248ef5b3ee5773dae18a7945538c.gif">  ) </td><td>  one </td><td>  X <sub>6</sub> </td><td>  X <sub>5</sub> </td><td>  X <sub>4</sub> </td><td>  X <sub>3</sub> </td><td>  X <sub>2</sub> </td><td>  X <sub>1</sub> </td><td>  X <sub>0</sub> </td></tr><tr><td>  set the Y coordinate of the carriage ( <img src="https://habrastorage.org/storage2/3b7/e11/670/3b7e116702b8183da38231205cc5107f.gif">  ) </td><td>  0 </td><td>  one </td><td>  0 </td><td>  0 </td><td>  Y <sub>3</sub> </td><td>  Y <sub>2</sub> </td><td>  Y <sub>1</sub> </td><td>  Y <sub>0</sub> </td></tr><tr><td>  <i>(in extended instruction set)</i> </td></tr><tr><td>  set TC register </td><td>  0 </td><td>  0 </td><td>  0 </td><td>  0 </td><td>  0 </td><td>  one </td><td>  TC <sub>1</sub> </td><td>  TC <sub>0</sub> </td></tr><tr><td>  set register S </td><td>  0 </td><td>  0 </td><td>  0 </td><td>  0 </td><td>  one </td><td>  0 </td><td>  S <sub>1</sub> </td><td>  S <sub>0</sub> </td></tr><tr><td>  set BS register </td><td>  0 </td><td>  0 </td><td>  0 </td><td>  one </td><td>  0 </td><td>  BS <sub>2</sub> </td><td>  BS <sub>1</sub> </td><td>  BS <sub>0</sub> </td></tr><tr><td>  set register V ( <img src="https://habrastorage.org/storage2/6ed/01b/cd2/6ed01bcd27d4561c118ce9801bfb3f61.gif">  ) </td><td>  1 <font color="white">V <sub>op <sub>5</sub></sub></font> </td><td>  V <sub>op <sub>6</sub></sub> </td><td>  V <sub>op <sub>5</sub></sub> </td><td>  V <sub>op <sub>4</sub></sub> </td><td>  V <sub>op <sub>3</sub></sub> </td><td>  V <sub>op <sub>2</sub></sub> </td><td>  V <sub>op <sub>1</sub></sub> </td><td>  V <sub>op <sub>0</sub></sub> </td></tr></tbody></table><br><br>  In order to correctly initialize the LCD, we must energize the VDD, disconnect it to the RES, wait 100 ¬µs and apply it to the RES again.  When the power to the RES is turned off, the controller goes into sleep mode, the RAM is not guaranteed to be cleared, many of the registers get their default value.  You can read more on page 14 in the <a href="https://dl.dropboxusercontent.com/u/12696741/habrahabr/PCF8812.pdf">datasheet on the controller</a> . <br>  After that, we need to turn off the SS (ie, ‚Äúchoose‚Äù the device for operation) and turn off the DC (ie, start sending commands) and send several initializing commands using SPI: <br><ol><li>  turn on the power, and at the same time set V = 0 and H = 1 </li><li>  select temperature coefficient TC = 11 </li><li>  set the maximum internally powered V <sub>op</sub> = 1111111 </li><li>  enable internal power factor S = 01 </li><li>  set the system offset BS = 011 </li><li>  enable normal instruction set mode H = 0, V = 0, PD = 0 </li><li>  select the normal display mode D = 1, E = 0 </li></ol><br>  After that, our display will light up and show us random pixels taken from non-RAM. <br>  Unfortunately, there is no MOSI on the controller (i.e. there is no feedback), so if the display does not show anything, then to make sure if at least SPI is working, after the above commands you need to measure the voltage on the 7th leg of the LCD. <br>  Experienced (and long) by clarified the following: if the display does not show anything, but there is voltage on the 7th leg, this means that the SPI works and that the display does not have enough internal voltage and needs to be increased using the V <sub>op</sub> and S registers , eg).  In our case, the display lights up at ~ 6V. <br><br><img src="https://habrastorage.org/storage2/a78/aa0/e5e/a78aa0e5e0ee6798bc5f6d3fb931b233.jpg"><br><br>  We studied the theory and now proceed to the implementation.  There are two ways to implement work with SPI: make everything handles with the help of controlling the legs of the processor (software spi) or use the hardware implementation (hardware spi), which is in our STM32.  For example, I see no reason to implement an interface using processor power, so I use hardware spi. <br><br>  The code will be written and debugged in CooCox IDE: <br><ol><li>  Launch CoIDE and create a new project. <br> <a href=""><img src="https://habrastorage.org/storage2/f7a/7fe/0c9/f7a7fe0c95762168ae92aad4b78d6aee.jpg"></a> <br></li><li>  Choose the GPIO modules we need (for controlling the legs), SPI (for controlling SPI), RCC <br> <a href=""><img src="https://habrastorage.org/storage2/5bd/a91/f00/5bda91f007aefb1b2da577f32e7b9ac5.jpg"></a> <br></li><li>  Let's write a small frame for our future program. <br><pre><code class="hljs cpp"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"stm32f10x_gpio.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"stm32f10x_rcc.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"stm32f10x_spi.h"</span></span></span><span class="hljs-meta"> void SPIInit(void) { } void GPIOInit(void) { } void LCDInit(void) { } int main() { SystemInit(); GPIOInit(); SPIInit(); LCDInit(); return 0; }</span></span></code> </pre> <br></li><li>  Let's start with filling GPIO.  To do this, using the datasheet on the STM32, we must find out where the legs of the ‚Äúiron‚Äù SPI are.  Our model is PA5 (SCK), PA6 (MISO), PA7 (MOSI).  These legs can be either regular legs or SPI legs, so we need to explicitly state the intended purpose and use them. <br></li><li>  Consider the remaining legs: <br><table><tbody><tr><td>  Vdd </td><td>  leg to connect power, connects to an arbitrary leg on the STM32 (in our case, on the LPH7999-4, the connection limit is up to 6.5V, and the STM32 produces 3.3V for each of its legs) </td></tr><tr><td>  VOUT </td><td>  output internal power, is connected to the earth screen through the capacitor x mF. </td></tr><tr><td>  GND </td><td>  land see VOUT </td></tr><tr><td>  Res </td><td>  leg to control controller reset, connects to arbitrary leg on STM32 </td></tr><tr><td>  DC </td><td>  the leg responsible for the mode of data transfer to the controller is connected to an arbitrary leg on the STM32.  If there is no voltage on the leg, the LCD controller interprets the received data as a command, and if it is, it is interpreted as a set of 8 pixels that will be written as a column in DDRAM relative to the location of the carriage. </td></tr><tr><td>  SS </td><td>  see above, connects to an arbitrary leg on STM32 </td></tr></tbody></table><br></li><li>  We solder SCK, MOSI to PA5 and PA7, and DC, VDD, RES and SS to arbitrary legs.  We have PB0, PB1, PB2, PB3, respectively. <br></li><li>  Write the code: <br><pre> <code class="hljs cpp"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SCK_Pin GPIO_Pin_5 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SCK_Pin_Port GPIOA #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MOSI_Pin GPIO_Pin_7 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MOSI_Pin_Port GPIOA #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DC_Pin GPIO_Pin_0 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DC_Pin_Port GPIOB #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> VDD_Pin GPIO_Pin_1 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> VDD_Pin_Port GPIOB #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> RST_Pin GPIO_Pin_2 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> RST_Pin_Port GPIOB #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SS_Pin GPIO_Pin_3 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SS_Pin_Port GPIOB void GPIOInit(void) { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//   (=)   A, B   SPI1 RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA | RCC_APB2Periph_GPIOB | RCC_APB2Periph_SPI1, ENABLE); GPIO_InitTypeDef PORT; //     PORT.GPIO_Pin = SCK_Pin | MOSI_Pin; //    (   4   ) PORT.GPIO_Speed = GPIO_Speed_2MHz; // (!)   .  -  " "  PORT.GPIO_Mode = GPIO_Mode_AF_PP; //      GPIO_Init(GPIOA, &amp;PORT); //     PORT.GPIO_Pin = DC_Pin | VDD_Pin | RST_Pin | SS_Pin; //   ( -  ) PORT.GPIO_Speed = GPIO_Speed_2MHz; //  - ,  PORT.GPIO_Mode = GPIO_Mode_Out_PP; //     B GPIO_Init(GPIOB, &amp;PORT); }</span></span></span></span></code> </pre><br>  Let's write auxiliary procedures for code readability: <br></li><li><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PowerOn</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { VDD_Pin_Port-&gt;ODR |= VDD_Pin; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PowerOff</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { VDD_Pin_Port-&gt;ODR &amp;= ~VDD_Pin; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ResetOn</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { RST_Pin_Port-&gt;ODR |= RST_Pin; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ResetOff</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { RST_Pin_Port-&gt;ODR &amp;= ~RST_Pin; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DCOn</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { DC_Pin_Port-&gt;ODR |= DC_Pin; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DCOff</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { DC_Pin_Port-&gt;ODR &amp;= ~DC_Pin; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SSOff</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { SS_Pin_Port-&gt;ODR &amp;= ~SS_Pin; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SSOn</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { SS_Pin_Port-&gt;ODR |= SS_Pin; }</code> </pre><br></li><li>  Now configure SPI: <br><pre> <code class="hljs ruby">void SPIInit(void) { SPI_InitTypeDef SPIConf; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> ,       SPIConf.SPI_Direction = SPI_Direction_1Line_Tx; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> ,    - Master SPIConf.SPI_Mode = SPI_Mode_Master; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    <span class="hljs-number"><span class="hljs-number">8</span></span>  (=<span class="hljs-number"><span class="hljs-number">1</span></span> ) SPIConf.SPI_DataSize = SPI_DataSize_8b; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  <span class="hljs-number"><span class="hljs-number">00</span></span> SPIConf.SPI_CPOL = SPI_CPOL_Low; SPIConf.SPI_CPHA = SPI_CPHA_1Edge; SPIConf.SPI_NSS = SPI_NSS_Soft; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    (  ,       ) SPIConf.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_2; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>      (..  ) SPIConf.SPI_FirstBit = SPI_FirstBit_MSB; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    SPI SPI_Init(SPI1, &amp;SPIConf); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  SPI1 SPI_Cmd(SPI1, ENABLE); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> SS = <span class="hljs-number"><span class="hljs-number">1</span></span> SPI_NSSInternalSoftwareConfig(SPI1, SPI_NSSInternalSoft_Set); }</code> </pre><br></li><li>  Write the function to send data via SPI <br><pre> <code class="hljs haskell"><span class="hljs-title"><span class="hljs-title">void</span></span> <span class="hljs-type"><span class="hljs-type">SPISend</span></span>(uint16_t <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class">) { </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SPI_I2S_SendData</span></span></span><span class="hljs-class">(</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SPI1</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">data</span></span></span><span class="hljs-class">); //   </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">while</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SPI_I2S_GetFlagStatus</span></span></span><span class="hljs-class">(</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SPI1</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SPI_I2S_FLAG_TXE</span></span></span><span class="hljs-class">) == </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">RESET</span></span></span><span class="hljs-class">); // ,     }</span></span></code> </pre><br></li><li>  Let's add initialization according to theory <br><pre> <code class="hljs ruby">void LCDInit(void) { SSOff(); DCOff(); PowerOn(); ResetOff(); ResetOn(); SPISend(<span class="hljs-number"><span class="hljs-number">0x21</span></span>); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  ,   ,   . . SPISend(0b1001); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>      SPISend(<span class="hljs-number"><span class="hljs-number">0xFF</span></span>); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     SPISend(<span class="hljs-number"><span class="hljs-number">0x06</span></span>); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   SPISend(<span class="hljs-number"><span class="hljs-number">0x13</span></span>); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  bias ( ) SPISend(<span class="hljs-number"><span class="hljs-number">0x20</span></span>); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> ...,     SPISend(0b110<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     }</code> </pre><br></li><li>  Project - Build (or F7) </li><li>  Flash - Program Download </li><li>  We look and rejoice: 3 </li></ol><br>  Here you can download the <a href="">finished project for CooCox.</a> <br><br><img src="https://habrastorage.org/storage2/a8d/bee/9cc/a8dbee9cccdb660291415f451c69cb43.jpg"><br><br>  Of course, to surprise in 2013 with the connected display to the ARM processor is difficult.  For us, as for beginner developers, this is the first step towards the realization of our project of a unique ‚Äúelectronic bracelet‚Äù. <br>  We do not dream of entering the market, we just want to gain experience, make a functional, stylish and long-lasting gadget for ourselves, and at the same time tell about our successes and failures here. <br><br>  Now our device is able to draw pictures on the screen, previously converted into an array of 8-bit "columns" using <a href="https://dl.dropboxusercontent.com/u/12696741/habrahabr/photo.py">this</a> Python <a href="https://dl.dropboxusercontent.com/u/12696741/habrahabr/photo.py">script</a> , requiring Python 2.7 and <a href="http://www.pythonware.com/products/pil/">PIL</a> . <br>  <b>Usage:</b> photo.py file24bit.bmp&gt; bytes.c <br><br>  Some illustrations were taken from <a href="http://easystm32.ru/interfaces/43-spi-interface-part-1">http://easystm32.ru/interfaces/43-spi-interface-part-1</a> <br><img src="https://habrastorage.org/storage2/09f/2f2/8dd/09f2f28dd61d754c323289e18c7cad56.jpg"><br></div><p>Source: <a href="https://habr.com/ru/post/188082/">https://habr.com/ru/post/188082/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../188068/index.html">Ilya</a></li>
<li><a href="../188072/index.html">Google programmer won the NSA award, and then said that this organization needs to be abolished</a></li>
<li><a href="../188074/index.html">This year, Google has already removed 100 million "pirated" links from issuing</a></li>
<li><a href="../188076/index.html">Simple-Science - Simple Experiments (Digest # 26)</a></li>
<li><a href="../188080/index.html">Overview of Embedded USB Hub with ST-Lab E-110 Card Reader</a></li>
<li><a href="../188086/index.html">HackPoint. The experience of self-organization of the provincial hackathon from scratch</a></li>
<li><a href="../188088/index.html">Container java-server code with the support of a permanent connection</a></li>
<li><a href="../188090/index.html">Creating TMG Internet traffic reports based on MS Reporting Services</a></li>
<li><a href="../188092/index.html">Android component from scratch</a></li>
<li><a href="../188094/index.html">Order in the photo and video archives using the technique and a pair of scripts</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>