<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>What is memory leak in android, how to check the program for their absence and how to prevent them from appearing</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In this article for beginner android developers, I will try to talk about what ‚Äúmemory leaks‚Äù in android are, why you should think about them on moder...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>What is memory leak in android, how to check the program for their absence and how to prevent them from appearing</h1><div class="post__text post__text-html js-mediator-article">  In this article for beginner android developers, I will try to talk about what ‚Äúmemory leaks‚Äù in android are, why you should think about them on modern devices that allocate 192MB per application, how to quickly find and fix these leaks in an unfamiliar application and on What you need to pay special attention when developing any application. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/fbb/3f3/010/fbb3f301061d4c8ca6319e541662e722.png"></div><br>  The ultimate goal of this article is to answer a simple question: <br>  <b>Where to click to find out which line in the application to fix?</b> <br><br><a name="habracut"></a><h3>  What is a "memory leak"? </h3><br>  To begin with, what is called a "memory leak".  In the strict sense, an object can be called a memory leak, if it continues to exist in memory even after all references to it are lost.  The problem immediately arises with this definition: the memory for all objects that you create is allocated with the participation of the garbage collector, and the garbage collector remembers all the objects created, regardless of whether you have a link to the object or not. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In fact, the garbage collector is extremely primitive (in fact, no - but the principle of operation is really simple): there is a graph in which every existing object is a vertex, and the link from any object to any other object is an edge.  Some vertices on this graph are special.  These are garbage collection roots - those entities that are created by the system and continue to exist, regardless of whether other objects refer to them or not.  If and only if there is any path on the graph from this object to any root, the object will not be destroyed by the garbage collector. <br><br>  This is the problem - if the object is not destroyed, then there is a chain of links from the root to this object (or, if such a chain does not exist, the object will be destroyed during the next garbage collection). And this means that no object can be a leak memory in the strict sense of the term.  In fact, even the fact that the garbage collector itself stores a link to each existing object in the system is already enough. <br><br>  Attempts to get a ‚Äúclean‚Äù memory leak in java were <a href="http://stackoverflow.com/questions/6470651/creating-a-memory-leak-with-java">made repeatedly</a> and, of course, continue to be made, but none of the ways can make the garbage collector forget the reference to the object without releasing the memory.  There are memory leaks associated with the allocation of memory by native code (JNI), but in this article we will not consider them. <br><br>  Conclusion: <b>you can lose all references to the object you are interested in, but the garbage collector remembers.</b> <br><br>  So, the definition of "memory leak" in the strict sense does not suit us.  Therefore, we will further understand the memory leak as an object that continues to exist after it should be destroyed. <br><br>  Next, I will show a few of the most common cases of memory leaks, show you how to detect them and how to avoid them.  If you learn to fix these typical memory leaks, then with a probability of 99.9%, there will be no memory leaks in your application that you should worry about. <br><br>  But, before proceeding to the description of these common mistakes, you need to answer the main question: is it necessary to correct these mistakes at all?  The application works ... <br><br><h3>  Why waste time fixing memory leaks? </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/files/ec3/7d0/b6c/ec37d0b6c11648b88ee79b3d50140391.png"></div><br>  Applications do not fall for a long time already because you forgot to squeeze resources into the drawable-ldpi folder.  Preparing to write this article, I conducted a simple experiment: I took one of the running applications, and added a memory leak to it in such a way that none of the created activity was ever unloaded from memory (began adding them to the static list).  I opened the app and started shouting the screens, waiting for the app to finally fall on my Nexus 5. Finally, after 5 minutes and 55 screens, the app dropped.  The irony is that, according to Google Analytics, the user usually visits 3 screens per session. <br><br>  So do you need to worry about memory leaks if the user can simply not notice them?  Yes, and there are three reasons why. <br><br>  <b>First</b> , if something doesn‚Äôt work in your application, it can lead to very serious and hard-to-debug problems. <br><br>  For example, you have developed an application for a social network.  In this application, you can exchange messages between users, where there is a timer on the messaging screen, which makes a request to the server every 10 seconds to receive new messages, but you forgot to turn this timer off when you exit the screen.  What does this lead to visually?  Yes to anything.  You will not notice that the application is doing something wrong.  But at the same time, the application will continue to send a request to the server every 10 seconds.  Even after you exit the application.  Even after you turn off the screen (behavior may vary from phone).  If a user enters the screens of communication with three different friends, within an hour you will receive 1000 unnecessary requests to the server and one user very angry with your application, which heavily consumes the battery.  These are the results I got with the test application on the phone with the screen off. <br><br>  You can argue that this is not a memory leak, but just a non-disabled timer and this is a completely different error.  It does not matter.  It is important that by checking your application for memory leaks, you will find other errors.  When we check the application for memory leaks, we want to find all the objects that exist, but should not exist.  Finding such objects, we immediately understand what extra operations continue to be performed. <br><br>  <b>Secondly</b> , not all applications consume little memory, and not all phones allocate a lot of memory. <br><br>  Remember the application, which fell only after 5 minutes and 55 screens are not unloaded?  So for the same application, I receive 1-2 reports of a fall every week with an OutOfMemoryException (mostly from devices up to 4.0; the application has 50,000 installations).  And this is despite the fact that there are no memory leaks in the application.  Therefore, even now you can pretty much spoil your karma by laying out an application with memory leaks, especially if your application consumes a lot of memory.  As usual in the android world, from the brilliant future separates us from the harsh present. <br><br>  <b>Thirdly</b> , a man should be able to do everything!  (I promised that all 3 reasons would be serious) <br><br>  Now that I, hopefully, have convinced you of the need to catch memory leaks, let's consider the main reasons for their occurrence. <br><br><h3>  Never save references to activity (view, fragment, service) in static variables </h3><br>  One of the first questions that every novice developer faces is how to transfer an object from one activity to the next.  The simplest and most incorrect decision that I occasionally have to see is the recording of the first activity in a static variable and accessing this variable from the second activity.  This is a very unfortunate approach.  Not only because it instantly causes a memory leak (a static variable will continue to exist as long as the application exists, and the activity to which it refers will never be unloaded).  This approach can also lead to a situation where you will exchange information with the wrong screen, because a screen that is invisible to the user can be destroyed and recreated at any time only when the user returns to it. <br><br>  Why is leakage activity such a big problem?  The fact is that if the garbage collector does not collect the activity, then it will not collect all the view and fragment, and with it all the other objects located on the activity.  Including pictures will not be released.  Therefore, the leakage of any activity is usually the largest memory leak that may be in your application. <br><br>  Never write links to activity in static variables.  Use the <a href="http://stackoverflow.com/questions/2139134/how-to-send-an-object-from-one-android-activity-to-another-using-intents">transfer of objects through the Intent</a> , or generally transfer not the object, but the object's id (if you have a database from which this id can then be retrieved). <br><br>  This item also applies to any objects whose lifetime is directly or indirectly controlled by android.  Those.  to view, fragment, service, etc .. <br><br>  <b>View and fragment objects contain a link to the activity in which they are located, so if one single view leaks, everything will flow away at once - the activity and all the views in it, and with them all drawables and everything that any element has There is a link from the screen!</b> <br><br><h3>  Be careful when you transfer the reference to the activity (view, fragment, service) to other objects. </h3><br>  Consider a simple example: your application for a social network displays the last name, first name and rating of the current user on each screen of the application.  An object with a current user profile exists from the moment you log in to the moment you log out of it, and all the screens of your application access the same object for information.  This object also periodically updates data from the server, since the rating can change frequently.  It is necessary that the object with the profile notifies the current activity about updating the rating.  How to achieve this?  Very simple: <br><br><pre><code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onResume</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onResume(); currentUser.addOnUserUpdateListener(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }</code> </pre> <br>  How to achieve a memory leak in this situation?  Also very easy!  Just forget to unsubscribe from notifications in the onPause method: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onPause</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onPause(); <span class="hljs-comment"><span class="hljs-comment">/*           */</span></span> currentUser.removeOnUserUpdateListener(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }</code> </pre><br>  Because of such a memory leak, the activity will continue to update the interface each time the profile is updated, even after the screen is no longer visible to the user.  Worse, in this way the screen can sign 2, 3 or more times on the same notification.  This can lead to visible interface brakes when the profile is updated ‚Äî and not just on this screen. <br><br>  What to do to avoid this error? <br><br>  <b>First</b> , of course, you should always carefully monitor the fact that you unsubscribed from all notifications when the activity left for the background. <br><br>  <b>Secondly</b> , you should periodically check your application for memory leaks. <br><br>  <b>Thirdly</b> , there is an alternative approach to the problem: you can save not links to objects, but <a href="http://docs.oracle.com/javase/7/docs/api/java/lang/ref/WeakReference.html">weak links</a> .  This is especially useful for the heirs of the View class - because they have no onPause method and it is not entirely clear at what point they should unsubscribe from the notification.  Weak references are not considered garbage collector as a relationship between objects, so an object to which only weak references exist will be destroyed, and the link will no longer refer to the object and will accept null.  In order not to bother with weak links that are not very convenient to use, you can use approximately the following template class: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Observer</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">I</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> ArrayList&lt;I&gt; strongListeners = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;I&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> ArrayList&lt;WeakReference&lt;I&gt;&gt; weakListeners = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;WeakReference&lt;I&gt;&gt;(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addStrongListener</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(I listener)</span></span></span><span class="hljs-function"> </span></span>{ strongListeners.add(listener); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addWeakListener</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(I listener)</span></span></span><span class="hljs-function"> </span></span>{ weakListeners.add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WeakReference&lt;I&gt;(listener)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">removeListener</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(I listener)</span></span></span><span class="hljs-function"> </span></span>{ strongListeners.remove(listener); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; weakListeners.size(); ++i) { WeakReference&lt;I&gt; ref = weakListeners.get(i); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ref.get() == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> || ref.get() == listener) { weakListeners.remove(i--); } } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> List&lt;I&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getListeners</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ ArrayList&lt;I&gt; activeListeners = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;I&gt;(); activeListeners.addAll(strongListeners); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; weakListeners.size(); ++i) { WeakReference&lt;I&gt; ref = weakListeners.get(i); I listener = ref.get(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (listener == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { weakListeners.remove(i--); <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } activeListeners.add(listener); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> activeListeners; } }</code> </pre><br>  Which will work something like this: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">User</span></span></span><span class="hljs-class"> </span></span>{ ... <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OnUserUpdateListener</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onUserUpdate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Observer&lt;OnUserUpdateListener&gt; updateObserver = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Observer&lt;OnUserUpdateListener&gt;(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Observer&lt;OnUserUpdateListener&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getUpdateObserver</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> updateObserver; } } ... <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onFinishInflate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onFinishInflate(); <span class="hljs-comment"><span class="hljs-comment">/*        */</span></span> currentUser.getUpdateObserver().addWeakListener(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } <span class="hljs-comment"><span class="hljs-comment">/* ...        */</span></span> ...</code> </pre><br>  Yes, you can get extra updates of this view.  But often this is the lesser of evils.  And, in any case, you will not receive a memory leak. <br><br>  There is only one subtlety when using the addWeakListener method: an object that you add must be referenced by someone.  Otherwise, the garbage collector will destroy this object before it receives its first notification: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">/*   ! */</span></span> currentUser.getUpdateObserver().addWeakListener(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> OnUserUpdateListener() { <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onUserUpdate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> } });</code> </pre><br><h3>  Timers and threads that are not canceled when leaving the screen </h3><br>  I have already mentioned this problem above: so, you have developed an application for a social network.  In this application, you can exchange messages between users, and you add a timer to the messaging screen, which makes a request to the server every 10 seconds to receive new messages, but you forgot to turn off this timer when you exit the screen: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HandlerActivity</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Activity</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Handler mainLoopHandler = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Handler(Looper.getMainLooper()); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Runnable queryServerRunnable = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Runnable() { <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> QueryServerTask().execute(); mainLoopHandler.postDelayed(queryServerRunnable, <span class="hljs-number"><span class="hljs-number">10000</span></span>); } }; <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onResume</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onResume(); mainLoopHandler.post(queryServerRunnable); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onPause</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onPause(); <span class="hljs-comment"><span class="hljs-comment">/*             */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* mainLoopHandler.removeCallbacks(queryServerRunnable); */</span></span> } ... }</code> </pre><br>  Unfortunately, this problem is difficult to avoid.  The only two tips you can give are the same as in the previous paragraph: be careful and periodically check the application for memory leaks.  You can also use the <a href="http://stackoverflow.com/a/13493726/333278">approach</a> similar to the previous paragraph <a href="http://stackoverflow.com/a/13493726/333278">using weak links</a> . <br><br><h3>  Never save links to fragment in activity or another fragment. </h3><br>  I have seen this mistake so many times.  Activity stores links to 5-6 launched fragments even though only 1 is always visible on the screen. One fragment stores a link to another fragment.  Fragments that are visible on the screen at different times communicate with each other via direct cached links.  FragmentManager in such applications most often plays a rudimentary role - at the right time it replaces the contents of the container with the necessary fragment, and the fragments themselves are not added to the back stack (adding a fragment to which you have a direct link, in back stack, sooner or later that the fragment will be unloaded from memory; after returning to this fragment, a new one will be created, and your link will continue to refer to the existing fragment, but invisible to the user. <br><br>  This is a very bad approach for a variety of reasons. <br><br>  <b>First,</b> if you keep direct links to 5-6 fragments in the activity, then this is the same as if you stored links to 5-6 activity.  The entire interface, all pictures and all logic 5 unused fragments cannot be unloaded from memory while the activity is running. <br><br>  <b>Secondly,</b> these fragments become extremely difficult to reuse.  Try to move the fragment to another place of the program, provided that it must be necessarily launched in the same activity with fragments, x, y and z, which you do not need to transfer. <br><br>  Treat fragments like activity.  Make them as modular as possible, communicate between fragments only through activity and fragmentManager.  This may seem like an overly complex system: why try so hard when you can just pass the link?  But, in fact, this approach will make your program better and easier. <br><br>  On this topic there is a great official article from Google: <a href="http://developer.android.com/training/basics/fragments/communicating.html">"Communicating with Other Fragments"</a> .  Re-read this article and never save pointers to fragments again. <br><br><h3>  Generalized rule </h3><br>  After reading the previous four points, you may have noticed that they are almost the same.  All this is a special case of one general rule. <br><br>  <b>All memory leaks appear if and only if you save a link to an object with a short life cycle (short-lived object) in an object with a long life cycle (long-lived object).</b> <br><br>  Keep this in mind and always be sensitive to such situations. <br><br>  This rule does not have a nice short name such as KISS, YAGNI or RTFM, but it applies to all languages ‚Äã‚Äãwith the garbage collector and all objects, not just the activity in android. <br><br>  Now that I, hopefully, have shown the main sources of memory leaks, let's finally move on to identifying them in the working application. <br><br><h3>  Where to click to find out which line in the application to fix? </h3><br>  So, you know how to avoid memory leaks, but this does not protect you from typos, bugs and projects that you wrote before you learned how to avoid memory leaks. <br><br>  In order to determine the presence and source of memory leaks in the application, you need a little time and <a href="http://www.eclipse.org/mat/">MAT</a> .  If you have never used MAT before, <a href="http://www.eclipse.org/mat/downloads.php">install it as a plugin for eclipse</a> , open the DDMS perspective and find the ‚ÄúDump HPROF file‚Äù button.  Pressing this button will open the memory dump of the selected application.  If you are using Android Studio, the process will be a bit more complicated, since at the moment MAT still does not exist as a plugin for Android Studio.  Put MAT as a separate program and use the <a href="http://stackoverflow.com/questions/24547555/how-to-analyze-memory-using-android-studio">stackoverflow</a> instruction. <br><br>  <b>Perform the following steps:</b> <br><br><ol><li>  Install the application on the device connected to the computer and use it in such a way as to appear on each screen at least once.  If one screen can be opened with different parameters, try to open it with all possible combinations of parameters.  In general - go around the entire application, as if you were checking it before release.  After you have gone through all the screens, press the back button until you exit the application.  Do not press the home button - your task is to complete all running activities, and not just hide them. </li><li>  Press the Cause GC button several times.  If you do not do this, the objects that are to be destroyed by the garbage collector will be visible in the dump, but have not yet been destroyed. </li><li>  Make a memory dump of the application by clicking on the "Dump HPROF file" button. </li><li>  In the window that opens, make an OQL query: "SELECT * FROM instanceof android.app.Activity" <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/0e3/2c4/d03/0e32c4d03a9e447eab6b543fe7364f48.png"></div><br>  The list of results must be empty.  If there is at least one element in the list, then this element is your memory leak.  In the screenshot you see just such an element - HandlerActivity: this is a memory leak.  Follow steps 8-10 for each item in the list. </li><li>  Perform similar queries for successors of Fragment: "SELECT * FROM instanceof android.app.Fragment".     , ,      ‚Äî   .       8-10. </li><li>  histogram. ,   histogram,   ,   OQL ,   histogram  ,   .         package name (   com.examples.typicalleaks)      objects (       ).  ,         , 0       .     .     ‚Äî   ,       Calculate Precise Retained Size.     Retained Heap        Retained Heap,   10000. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/983/7d1/df8/9837d1df8f2841e9afbb87e84895b249.png"></div><br>        ,     ,   .     ‚Äî    ,     ,           . ,     6   Example    Example[].   ‚Äî  Example  enum,             .   HandlerActivity  HandlerActivity$1 (  ,    HandlerActivity.java) ‚Äî      .      ,   list objects,   8-10       . </li><li>             ‚Äî !       . </li><li>          Merge Shortest Paths to GC Roots ‚Äî exclude all phantom/weak/soft etc. references. </li><li>  .       : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/32f/b27/9a0/32fb279a03a744da873d991b269aa16f.png"></div><br>         .    ‚Äî   . ,   ‚Äî  ,        .           .      :       ,          .  Those.    ,   mMessages  MessageQueue     Message,    callback,    HandlerActivity$1,      HandlerActivity   this$0.  ,    HandlerActivity   Runnable,    HandlerActivity.java,      Handler    post  postDelayed.     ,     ,         Open Source File. </li><li>     ,             ,      .        Handler.removeCallbacks(Runnable r)   onPause HandlerActivity. </li><li>  ,       ,     1,  ,     . </li></ol><br><br><h3>  Conclusion </h3><br> <b>              , ,   99.9%,       .</b> <br><br>        .      ,      .  ,   uuid     ‚Äî  ,         . <br><br><div class="spoiler"> <b class="spoiler_title"> </b> <div class="spoiler_text"><ol><li> Investigating Your RAM Usage <br> <a href="https://developer.android.com/tools/debugging/debugging-memory.html">https://developer.android.com/tools/debugging/debugging-memory.html</a> </li><li> Java Performance blog <br> <a href="http://kohlerm.blogspot.ru/2009/07/eclipse-memory-analyzer-10-useful.html">http://kohlerm.blogspot.ru/2009/07/eclipse-memory-analyzer-10-useful.html</a> </li><li> Avoiding memory leaks <br> <a href="http://android-developers.blogspot.co.uk/2009/01/avoiding-memory-leaks.html">http://android-developers.blogspot.co.uk/2009/01/avoiding-memory-leaks.html</a> </li><li> Memory Analysis for Android Applications <br> <a href="http://android-developers.blogspot.ru/2011/03/memory-analysis-for-android.html">http://android-developers.blogspot.ru/2011/03/memory-analysis-for-android.html</a> </li><li> Detecting a Memory Leak <br> <a href="http://blog.crowdint.com/2013/10/02/fixing-memory-leaks-in-android-applications.html">http://blog.crowdint.com/2013/10/02/fixing-memory-leaks-in-android-applications.html</a> </li><li> DEBUGGING MEMORY LEAKS ON ANDROID FOR BEGINNERS: PROGRAMMATIC HEAP DUMPING <br> <a href="http://novoda.com/blog/memory-debugging-on-android-part-1">http://novoda.com/blog/memory-debugging-on-android-part-1</a> </li><li> How To Identify If Your App is Leaking Memory <br> <a href="http://www.littleeye.co/blog/2013/04/24/identify-memory-leaks-android-apps/">http://www.littleeye.co/blog/2013/04/24/identify-memory-leaks-android-apps/</a> </li><li> Fixing an Android Memory Leak <br> <a href="http://therockncoder.blogspot.ru/2012/09/fixing-android-memory-leak.html">http://therockncoder.blogspot.ru/2012/09/fixing-android-memory-leak.html</a> </li><li> Managing Your App's Memory <br> <a href="https://developer.android.com/training/articles/memory.html">https://developer.android.com/training/articles/memory.html</a> </li><li> HUNTING YOUR LEAKS: MEMORY MANAGEMENT IN ANDROID <br> <a href="http://www.raizlabs.com/dev/2014/03/wrangling-dalvik-memory-management-in-android-part-1-of-2/">http://www.raizlabs.com/dev/2014/03/wrangling-dalvik-memory-management-in-android-part-1-of-2/</a> <br> <a href="http://www.raizlabs.com/dev/2014/04/hunting-your-leaks-memory-management-in-android-part-2-of-2/">http://www.raizlabs.com/dev/2014/04/hunting-your-leaks-memory-management-in-android-part-2-of-2/</a> </li><li> How to discover memory usage of my application in Android <br> <a href="http://stackoverflow.com/questions/2298208/how-to-discover-memory-usage-of-my-application-in-android/2299813">http://stackoverflow.com/questions/2298208/how-to-discover-memory-usage-of-my-application-in-android/2299813#2299813</a> </li></ol></div></div></div><p>Source: <a href="https://habr.com/ru/post/243537/">https://habr.com/ru/post/243537/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../243523/index.html">When is a string not a string?</a></li>
<li><a href="../243527/index.html">November 21 - online conference - about the new Visual Studio 2015 and other announcements of Connect ();</a></li>
<li><a href="../243529/index.html">Through thorns to Unity3D</a></li>
<li><a href="../243531/index.html">How to remove a bucket with 400 million files on Amazon S3</a></li>
<li><a href="../243535/index.html">Ultrastar He6 - the world's first helium HDD with a capacity of 6 TB</a></li>
<li><a href="../243541/index.html">Reveal for everyone!</a></li>
<li><a href="../243543/index.html">High-quality interface JIRA-plugin using the AUI Framework</a></li>
<li><a href="../243545/index.html">SPA-architecture for CRM-systems: part 1</a></li>
<li><a href="../243547/index.html">Python Meetup 10/31/14: asynchrony and soft skills</a></li>
<li><a href="../243551/index.html">PDP Recovery 11/04</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>