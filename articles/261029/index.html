<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Tail recursion in C ++ using 64-bit variables - Part 2</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the last note, I talked about problems with recursion in the Fibonacci function when using 64-bit variables as its arguments and compiling code usi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Tail recursion in C ++ using 64-bit variables - Part 2</h1><div class="post__text post__text-html js-mediator-article">  In the last <a href="http://habrahabr.ru/company/pvs-studio/blog/261027/">note,</a> I talked about problems with recursion in the Fibonacci function when using 64-bit variables as its arguments and compiling code using Microsoft Visual C ++.  It turned out that the compiler includes tail recursion when 32-bit variables are used, but does not do this when switching to 64-bit ones.  Just in case, I remind you that tail recursion is an optimization made by the compiler, in which some types of tail calls are converted into unconditional jumps.  <a href="http://www.viva64.com/go.php%3Furl%3D1598">Learn more about tail recursion</a> . <br><a name="habracut"></a><br>  I decided that the problem lies in the Visual C ++ compiler itself and is apparently explained by the presence of a bug in it. <br><br>  Fibonacci series of large integers are rarely computed, but this is a very good example to demonstrate how tail calls are implemented. <br><br>  The results did not please me, and, following the advice of some readers (in the comments on this blog and on the <a href="http://www.viva64.com/go.php%3Furl%3D1596">Reddit</a> and <a href="http://www.viva64.com/go.php%3Furl%3D1594">StackOverflow</a> sites), I decided to sort out the problem and see how other compilers behave. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Let's take the same Visual Studio project that was used in the last post and which I posted on <a href="http://www.viva64.com/go.php%3Furl%3D1599">GitHub</a> .  This was the Fibonacci function: <br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> ULONG64; <span class="hljs-function"><span class="hljs-function">ULONG64 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fib_tail_x64</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ULONG64 n, ULONG64 res, ULONG64 next)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fib_tail_x64(n - <span class="hljs-number"><span class="hljs-number">1</span></span>, next, res + next); }</code> </pre> <br>  As you must remember, when compiling this code in release mode (which is usually needed to get tail recursion due to the optimization <i>/ Ox</i> command) for the <b>Win32</b> platform, tail tail recursion did not work: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0ed/0e6/e5b/0ed0e6e5bb548af44335758564dc3515.png" alt="Picture 2"><br><br>  Tail recursion does not work!  Assembly code is terrible due to the included frame pointers <br><br>  There is, however, one thing that I did not try to try (and if to be honest, I simply forgot).  This is the choice of <i>the solution platform</i> for building the project.  In Visual Studio, a <b>Win32</b> configuration that compiles a solution using the x86 processor instructions is the default configuration.  In the above fragment of the assembler code, you can see that the registers used are <i>EAX</i> , <i>EBX</i> , etc.  - are registers of a 32-bit processor, in accordance with the selected configuration. <br><br>  If we switch the configuration to <i>x64</i> , build and run the project, we get the following assembly code: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/188/9f1/b93/1889f1b9384373846f6ded094652ce3f.png" alt="Picture 3"><br><br>  The tail recursion appeared !!! <br><br>  Such a surprise!  The tail recursion worked when using x64 registers ( <i>RAX</i> , <i>RDX</i> , etc.), and the assembler code became much shorter and cleaner! <br><br>  Summarizing all the above about tail calls, you can create the following visual table: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b57/6f3/96a/b576f396a65542ab7763277c79019359.png" alt="Picture 9"><br><br>  It turns out that the problem manifests itself only when we use <i>x64</i> variables, and we choose <i>x86</i> as the target platform. <br><br>  Honestly, at this stage I was not so sure about the presence of a bug in the MS compiler, therefore, still dissatisfied with the results, I decided to repeat the experiment with another compiler. <br><br>  This time I decided to switch to another operating system and work with Clang, based on <a href="http://www.viva64.com/go.php%3Furl%3D1600">LLVM</a> and installed on my Macbook as part of Xcode. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c31/c1a/88b/c31c1a88b8cdf7a4890aa466786c33c6.png" alt="Picture 4"><br><br>  Terminal - clang version <br><br>  To view the generated assembler code, I used the handy <a href="http://www.viva64.com/go.php%3Furl%3D1601">Hopper Disassembler</a> utility, available for both OS X and Linux (but, as I understand it, it can also work with the <i>gdb</i> debugger). <br><br>  I exactly repeated the same experiment.  The following picture shows the first version of the generated assembler: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bbb/f29/0e7/bbbf290e73eb30d4ed213450d365d3b0.png" alt="Picture 5"><br><br>  The tail recursion is clearly present here: the JNE instruction (Jump Not Equal, transition by inequality) is only a conditional transition, when the ZF flag (‚Äúzero‚Äù flag) is set to 0. The red arrow in the picture indicates the address where the transition occurs if the condition is true.  The attentive observer must have already noticed that this code was not compiled for 32-bit processors: the assembler registers used are actually 64-bit ( <i>RBD</i> , <i>RDI</i> , etc.). <br><br>  However, now our goal is to make sure that tail recursion will still work when choosing a 32-bit platform as the target. <br><br>  The compiler can be forced to generate a 32-bit code using the <i>-m32</i> key.  After rebuilding the solution in 32-bit mode, I got the following: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1ab/388/c5f/1ab388c5fa49a2d402dd88a0157a2bcb.png" alt="Picture 6"><br><br>  Tail recursion enabled! <br><br>  Hooray!!!  By the type of registers used, we can conclude that the executable module is built just for the architecture we specified, and in the last line you can see an unexpected result: <b>tail recursion worked in 32-bit mode !!!!!</b> <br><br><h2>  EDIT 1 </h2><br>  As I understood, many users failed to reproduce the problem (see comments below, as well as on <a href="http://www.viva64.com/go.php%3Furl%3D1602">Reddit</a> ).  I continued to experiment with compiler optimization settings, adjusting some parameters.  In <b>release</b> mode, the configuration of the default optimization settings is as follows: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b4d/f3c/d88/b4df3cd8874f01139438f8fb795d540d.png" alt="Picture 7"><br><br>  Default optimization settings <br><br>  After several attempts, I changed the <i>'Whole Program Optimization'</i> setting from <b>/ GL</b> (on) to No (off).  I also changed the <i>'Omit Frame Pointers'</i> parameter because  I was told that with the included frame pointers, the generated assembler code for x86 is much longer and uglier (besides, we could have saved a few ticks, avoiding cache misses).  <a href="http://www.viva64.com/go.php%3Furl%3D1603">StackOverflow</a> has a detailed explanation of how to disable frame pointers. <br><br>  Anyway, when I recompiled the solution under <b>Win32</b> with all the changes described above, I got an unexpected result: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4ef/842/8e9/4ef8428e9892af2b0b01e2d1b9777ef7.png" alt="Picture 8"><br><br>  X86 tail recursion - triggered when 'Whole Program Optimization' is turned off <br><br><h2>  EDIT 2 </h2><br>  Several people wrote that, regardless of the setting of the WPO ( <a href="http://www.viva64.com/go.php%3Furl%3D1604">Whole Program Optimization</a> ) parameter, they did not experience any problems with tail recursion.  This at first puzzled me, but then I realized that I did not take into account one important detail - namely, the method of calling the Fibonacci function from <i>main</i> .  Until now, the function call in my code to test the Fibonacci function in x64 mode was as follows: <br><pre> <code class="cpp hljs">ULONG64 res = fib_tail_x64(<span class="hljs-number"><span class="hljs-number">40</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre> <br>  So far so good, there is nothing special about this code ‚Äî I simply pass literals as arguments to the function. <br><br>  And what if instead of them we will pass variables or pointers to a function?  Let's try: <br><pre> <code class="cpp hljs">ULONG64 a = <span class="hljs-number"><span class="hljs-number">40</span></span>; ULONG64 res = fib_tail_x64(a, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre> <br>  Although the code does not seem to have changed much, calling the function <i>fib_tail_x64</i> using variables enables tail recursion independently of <i>WPO</i> (provided that we use the optimization key&gt; = <i>/ O2</i> ).  One <a href="http://www.viva64.com/go.php%3Furl%3D1605">reader on Reddit</a> pointed out that an indirect function call through pointers (regardless of the use of literals) will give exactly the same result: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> a = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; ULONG64 res = <span class="hljs-number"><span class="hljs-number">0</span></span>; ULONG64(*ptr)(ULONG64 n, ULONG64 res, ULONG64 next) = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a) { ptr = &amp;fib_tail_x64; } res = ptr(<span class="hljs-number"><span class="hljs-number">40</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre> <br><h2>  Final conclusions </h2><br>  Although I initially sinned to have a bug in the Visual C ++ compiler that caused the tail recursion to be turned off, in the end, it turned out that this was not the case.  The assembler codes generated by the VC ++ and Clang compilers for <i>x86</i> platforms are very similar to each other.  As a <b>first</b> conclusion, I decided that <u>it is imperative to turn off the</u> <b><i><u>'Whole Program Optimization'</u></i></b> <u>parameter</u> <u><i>if and only when a direct call to the x64 recursive function occurs, whose literals are passed as arguments</i></u> <i>.</i> <br><br>  After the <b>second</b> check, it turned out that some users did not experience the problem even when they called the function directly, using variables, or indirectly through function pointers. <br><br>  I would be glad to hear any thoughts from someone from the team working on the Visual C ++ compiler on the causes of this " <i>problem</i> ." <br><br>  That's all, thank you for your attention!  To stay in touch with me, write to the mail through the <a href="http://www.viva64.com/go.php%3Furl%3D1606">Contact-</a> form or subscribe to the page on Twitter! <br><br>  See you soon! </div><p>Source: <a href="https://habr.com/ru/post/261029/">https://habr.com/ru/post/261029/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../261013/index.html">Adobe fixed critical flash player vulnerability</a></li>
<li><a href="../261017/index.html">Unity 5 uNet is a new network subsystem. Study on authoritarian architecture</a></li>
<li><a href="../261019/index.html">The importance of controlling the output of the serializing API</a></li>
<li><a href="../261023/index.html">Create a simple UI5 ‚Äã‚Äãapplication in a web development environment</a></li>
<li><a href="../261027/index.html">Tail recursion in C ++ using 64-bit variables - Part 1</a></li>
<li><a href="../261031/index.html">Reactive extensions</a></li>
<li><a href="../261033/index.html">Turing's Cathedral: the origin of the digital universe</a></li>
<li><a href="../261035/index.html">MiTM Mobile Contest: How Mobile Phone Broke on PHDays V</a></li>
<li><a href="../261039/index.html">Inside the antivirus for Virusday sites - Part 1</a></li>
<li><a href="../261041/index.html">Children's camp: Bisectral-Pythagorean triangles, brain reprogramming, radar detector and breaking handcuffs</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>