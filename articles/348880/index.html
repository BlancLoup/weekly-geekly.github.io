<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Use for simple tests inheritance, polymorphism and patterns? Why not‚Ä¶</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="C ++ language is complicated. But its complexity stems from the complexity of the tasks that are solved with C ++. Every feature that was added in C +...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Use for simple tests inheritance, polymorphism and patterns? Why not‚Ä¶</h1><div class="post__text post__text-html js-mediator-article">  C ++ language is complicated.  But its complexity stems from the complexity of the tasks that are solved with C ++.  Every feature that was added in C ++ was added for a reason, but in order to give an opportunity to cope with a problem.  Well, the combination of existing features in C ++ makes the language an extremely powerful tool.  This article is devoted to a specific example of how this happens in practice. <br><br>  I would also add that one of the powerful incentives for writing this article was that very often voluminous <s>flames of</s> discussion on the topic ‚ÄúOOP is not needed‚Äù and, especially, ‚Äúgeneric templates in practice are almost never needed.‚Äù  I, as far from being a young programmer who started in the 1990s with tools, in which there was no OOP or generic templates, it is strange to encounter such points of view.  But, the further, the more often you come across them.  Especially from adherents of new programming languages, like Go or Rust. <br><br>  It is difficult to say what caused it.  Maybe people have overfed the PLO (and this is how it was) ... Maybe the tasks over the past several decades have changed a lot (and this is the case) ... Maybe it‚Äôs just "that‚Äôs the generation has grown‚Äù ... Anyway, you can try real life example to show that everything is not so straightforward ¬©. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      So, what will be discussed? <br><a name="habracut"></a><br>  <b>Upd.</b>  <b>Advance disclaimer.</b>  An article on C ++.  Code examples are given in C ++.  Therefore, if you do not transfer C ++ or do not know C ++ sufficiently, then please refrain from comments like ‚Äúsheets of unreadable code‚Äù.  Constructive such comments do not carry and they are unlikely to be useful to anyone. <br><br><h1>  The essence of the task </h1><br>  We recently released a new version of our OpenSource framework, where we added a <a href="https://habrahabr.ru/post/348680/">new feature called deadletter handlers</a> .  And this new feature needed to be tested.  Quite simple tests.  In one test, it was necessary to check that the programmer could install the deadletter handler, in the other that the user could cancel the deadletter handler. <br><br>  The tests are simple, but they have one difficulty: it was necessary to check the same functionality in different conditions.  Well, for example, the deadletter handler can be hanged on a message from different types of mailboxes.  The message on which the deadletter handler hangs can be a regular, immutable message, it can be a regular mutable message, it can be a signal (I will explain: regular messages are different from signals, therefore message delivery is different from signal delivery).  The deadletter handler itself can be represented as a pointer to the class of the agent method, as well as the lambda function. <br><br>  And since the code implementing deadletter handlers in SObjectizer makes extensive use of templates, in order to check the correctness of the templates, it was necessary to cover all reasonable combinations of these conditions in the tests. <br><br>  Let me explain for those who are not very familiar with the features of C ++: if, for example, the template function is not called anywhere in the code, some compilers (like old versions of Visual C ++) do not always check the source code of this function for the presence of elementary errors.  Therefore, in order to be sure that everything is normal with the template implementation, it is necessary that the template function or class be instantiated explicitly or implicitly.  This is most reliably achieved through the explicit use of a template function / class in a test. <br><br><h1>  Possible solution "in the forehead" </h1><br>  Of course, there is a very simple solution, which is to create your own class for each test case and perform all the relevant actions within this class. <br><br>  So, for a combination of MPMC-mbox +, a normal, immutable message + a pointer to a method would result in the following class: <br><br><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mpmc_message_pfn_test_case_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">state_t</span></span> st_test{<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> mbox_; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">test_message</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">message_t</span></span> {}; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">mpmc_message_pfn_test_case_t</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">context_t</span></span> ctx) : so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span>{<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(ctx)} , mbox_{so_environment().create_mbox()} {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">so_define_agent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> &gt;&gt;= st_test; so_subscribe_deadletter_handler(mbox_, &amp;<span class="hljs-keyword"><span class="hljs-keyword">mpmc_message_pfn_test_case_t</span></span>::on_deadletter); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">so_evt_start</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ so_5::send&lt;test_message&gt;(mbox_); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_deadletter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">mhood_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;test_message&gt;)</span></span></span><span class="hljs-function"> </span></span>{ so_deregister_agent_coop_normally(); } };</code> </pre> <br>  And for the MPMC-mbox + combination, the usual immiable message + lambda function would require a very similar class, but with a few changes: <br><br><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mpmc_message_lambda_test_case_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">state_t</span></span> st_test{<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> mbox_; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">test_message</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">message_t</span></span> {}; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">mpmc_message_lambda_test_case_t</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">context_t</span></span> ctx) : so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span>{<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(ctx)} , mbox_{so_environment().create_mbox()} {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">so_define_agent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> &gt;&gt;= st_test; so_subscribe_deadletter_handler(mbox_, [<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>](<span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;test_message&gt;) { so_deregister_agent_coop_normally(); }); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">so_evt_start</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ so_5::send&lt;test_message&gt;(mbox_); } };</code> </pre> <br>  Whereas for the case of direct_mbox +, the usual mutable message + lambda, the change function would take more, but the code would still be quite similar: <br><br><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">direct_mutable_message_lambda_test_case_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">state_t</span></span> st_test{<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">test_message</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">message_t</span></span> {}; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">direct_mutable_message_lambda_test_case_t</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">context_t</span></span> ctx) : so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span>{<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(ctx)} {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">so_define_agent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> &gt;&gt;= st_test; so_subscribe_deadletter_handler(so_direct_mbox(), [<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>](<span class="hljs-keyword"><span class="hljs-keyword">mutable_mhood_t</span></span>&lt;test_message&gt;) { so_deregister_agent_coop_normally(); }); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">so_evt_start</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ so_5::send&lt;so_5::mutable_msg&lt;test_message&gt;&gt;(*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } };</code> </pre> <br>  I hope the idea is clear. <br><br>  A total of such classes would need ten pieces.  What immediately discouraged the desire to move in this direction.  Since  in such quantity copy-paste is very easy to make a mistake.  By the way, when these tests just appeared, a couple of possible test cases were forgotten.  But when they remembered this, the forgotten combinations were literally added in just a few lines to the corresponding tests.  But if I had to create a separate class for each test case, then to eliminate the initial miscalculation would require more code and attention. <br><br><h1>  Another way </h1><br>  Since I have a hard point about copy-paste in the code and for good reason, I chose a different path.  Through the use of templates.  And, in one place, template templates.  What then was added and inheritance with polymorphism.  But let's start with a simple test, in which only templates are enough. <br><br><h2>  Simple test (only templates are used) </h2><br>  So, we have three factors that need to be combined with each other.  Two of them ‚Äî the mbox type and the message / signal type ‚Äî are easily represented as a template parameter.  Not just with the third: what exactly is the deadletter handler - a pointer to a function or lambda.  Well, okay.  The goal is not to get rid of copy-paste at all.  The goal is to do the bare minimum necessary. <br><br>  Therefore, two template classes were made.  The first is for the case when the deadletter handler is implemented with a pointer to the method: <br><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Mbox_Case, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Msg_Type &gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pfn_test_case_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Mbox_Case m_mbox_holder; <span class="hljs-keyword"><span class="hljs-keyword">state_t</span></span> st_test{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-string"><span class="hljs-string">"test"</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">pfn_test_case_t</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">context_t</span></span> ctx ) : so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(ctx) ) , m_mbox_holder( *self_ptr() ) {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">so_define_agent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> &gt;&gt;= st_test; so_subscribe_deadletter_handler( m_mbox_holder.mbox(), &amp;<span class="hljs-keyword"><span class="hljs-keyword">pfn_test_case_t</span></span>::on_deadletter ); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">so_evt_start</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ so_5::send&lt;Msg_Type&gt;( m_mbox_holder.mbox() ); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_deadletter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">mhood_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;Msg_Type&gt; )</span></span></span><span class="hljs-function"> </span></span>{ so_deregister_agent_coop_normally(); } };</code> </pre> <br>  The second is for the case of the lambda function: <br><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Mbox_Case, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Msg_Type &gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">lambda_test_case_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Mbox_Case m_mbox_holder; <span class="hljs-keyword"><span class="hljs-keyword">state_t</span></span> st_test{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-string"><span class="hljs-string">"test"</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">lambda_test_case_t</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">context_t</span></span> ctx ) : so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(ctx) ) , m_mbox_holder( *self_ptr() ) {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">so_define_agent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> &gt;&gt;= st_test; so_subscribe_deadletter_handler( m_mbox_holder.mbox(), [<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>](<span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;Msg_Type&gt;) { so_deregister_agent_coop_normally(); } ); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">so_evt_start</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ so_5::send&lt;Msg_Type&gt;( m_mbox_holder.mbox() ); } };</code> </pre> <br>  You may notice that these template classes are very similar to those code examples that were shown above.  Only for a simple test that checks the installation of a deadletter handler, now only two classes are enough.  Not ten. <br><br>  I hope with the parameter of the template called Msg_Type everything is clear.  This will be the type of message or signal that the test agent should send and receive.  In the test for this purpose the following definitions will be used: <br><br><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">test_message</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">message_t</span></span> {}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">test_signal</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">signal_t</span></span> {};</code> </pre> <br>  Well, when instantiating the pfn_test_case_t and lambda_test_case_t templates, test_message, so_5 :: mutable_msg &lt;test_message&gt; and test_signal will be used.  It's all simple. <br><br>  But with the Mbox_Case parameter a bit more complicated (although, if you know C ++ well, then there is nothing complicated there at all).  This parameter determines which mbox should be used in the test case: MPMC-mbox, which should be created specially, or direct_mbox, which each agent already has. <br><br>  In our tests, two very simple types are used as Mbox_Case: <br><br><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">direct_mbox_case_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> &amp; m_owner; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">direct_mbox_case_t</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> &amp; owner ) : m_owner(owner) {} <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> &amp; mbox() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_owner.so_direct_mbox(); } }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mpmc_mbox_case_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> m_mbox; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">mpmc_mbox_case_t</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> &amp; owner ) : m_mbox( owner.so_environment().create_mbox() ) {} <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> &amp; mbox() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_mbox; } };</code> </pre> <br>  An instance of the class direct_mbox_case_t retains a link to the agent in order to return the direct_mbox of this agent in its mbox () method.  And an instance of the class mpmc_mbox_case_t in its constructor creates an instance of MPMC-mbox-a and returns a reference to it in its mbox () method. <br><br>  It turns out that when, for example, the pfn_test_case_t class is parameterized by direct_mbox_case_t, a reference to the pfn_test_case_t instance itself is stored in pfn_test_case :: m_mbox_holder and the agent itself is returned by calling m_mbox_holder.mbox (). <br><br>  And when pfn_test_case_t is parametrized by mpmc_mbox_case_t, then in pfn_test_case_t :: m_mbox_holder there is an instance of a separate MPMC-mbox, which is created when constructing an instance of pfn_test_case_t. <br><br>  Well, the same thing happens for lambda_test_case_t. <br><br>  So, we get the opportunity to create such combinations for test cases: <br><br> <code>pfn_test_case_t&lt;direct_mbox_case_t, test_message&gt;; <br> pfn_test_case_t&lt;direct_mbox_case_t, so_5::mutable_msg&lt;test_message&gt;&gt;; <br> pfn_test_case_t&lt;direct_mbox_case_t, test_signal&gt;; <br> pfn_test_case_t&lt;mpmc_mbox_case_t, test_message&gt;; <br> pfn_test_case_t&lt;mpmc_mbox_case_t, test_signal&gt;; <br> lambda_test_case_t&lt;direct_mbox_case_t, test_message&gt;; <br> lambda_test_case_t&lt;direct_mbox_case_t, so_5::mutable_msg&lt;test_message&gt;&gt;; <br> ...</code> <br> <br>  More about the Mbox_Case parameter.  We use classes.  Although it was possible to parameterize test classes and a function that would return mbox_t.  Those.  could be done like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mbox_maker_t</span></span> = so_5::<span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> (*)(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> &amp;); so_5::<span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> mpmc_mbox_maker(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> &amp; agent) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> agent.so_environment().create_mbox(); } so_5::<span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> direct_mbox_maker(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> &amp; agent) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> agent.so_direct_mbox(); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">mbox_maker_t</span></span> Mbox_Case, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Msg_Type &gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pfn_test_case_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> m_mbox; <span class="hljs-keyword"><span class="hljs-keyword">state_t</span></span> st_test{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-string"><span class="hljs-string">"test"</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">pfn_test_case_t</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">context_t</span></span> ctx ) : so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(ctx) ) , m_mbox( Mbox_Case(*self_ptr()) ) {} ... }; ... <span class="hljs-keyword"><span class="hljs-keyword">pfn_test_case_t</span></span>&lt;direct_mbox_maker, test_message&gt;; ... <span class="hljs-keyword"><span class="hljs-keyword">lambda_test_case_t</span></span>&lt;mpmc_mbox_maker, test_signal&gt;;</code> </pre><br>  Basically, it would not change anything.  But the first thing that came to mind was precisely the classes, and they went into implementation. <br><br><h3>  And where is the pattern template? </h3><br>  But the template templates, which was mentioned above, will be needed only to slightly simplify the procedure for creating test agents.  In general, one could easily manage without him and write something like: <br><br><pre> <code class="hljs cpp">env.introduce_coop([](so_5::<span class="hljs-keyword"><span class="hljs-keyword">coop_t</span></span> coop) { coop.make_agent&lt; <span class="hljs-keyword"><span class="hljs-keyword">pfn_test_case_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">direct_mbox_case_t</span></span>, test_message&gt;&gt;(); }); env.introduce_coop([](so_5::<span class="hljs-keyword"><span class="hljs-keyword">coop_t</span></span> coop) { coop.make_agent&lt; <span class="hljs-keyword"><span class="hljs-keyword">pfn_test_case_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">direct_mbox_case_t</span></span>, so_5::mutable_msg&lt;test_message&gt;&gt;&gt;(); }); env.introduce_coop([](so_5::<span class="hljs-keyword"><span class="hljs-keyword">coop_t</span></span> coop) { coop.make_agent&lt; <span class="hljs-keyword"><span class="hljs-keyword">pfn_test_case_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">direct_mbox_case_t</span></span>, test_signal&gt;&gt;(); });</code> </pre> <br>  But it is better to introduce an auxiliary template function: <br><br><pre> <code class="hljs markdown">template<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">typename</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Mbox_Case</span></span></span></span><span class="xml"><span class="hljs-tag">, </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">typename</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Msg_Type</span></span></span></span><span class="xml"><span class="hljs-tag">, </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">template</span></span></span></span><span class="xml"><span class="hljs-tag"> &lt;</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span></span><span class="xml"><span class="hljs-tag">, </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> class Test<span class="hljs-emphasis"><span class="hljs-emphasis">_Agent &gt; void introduce_</span></span>test<span class="hljs-emphasis"><span class="hljs-emphasis">_agent( so_</span></span>5::environment<span class="hljs-emphasis"><span class="hljs-emphasis">_t &amp; env ) { env.introduce_</span></span>coop( [<span class="hljs-string"><span class="hljs-string">&amp;</span></span>](<span class="hljs-link"><span class="hljs-link"> so_5::coop_t &amp; coop </span></span>) { coop.make<span class="hljs-emphasis"><span class="hljs-emphasis">_agent&lt; Test_</span></span>Agent<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Mbox_Case,</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Msg_Type</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> &gt;(); } ); }</code> </pre> <br>  And then reduce the amount of work and make the test creation code more readable: <br><br><pre>  introduce_test_agent &lt;direct_mbox_case_t, test_message, pfn_test_case_t&gt; (env);
 introduce_test_agent &lt;direct_mbox_case_t, so_5 :: mutable_msg &lt;test_message&gt;, pfn_test_case_t&gt; (env);
 introduce_test_agent &lt;direct_mbox_case_t, test_signal, pfn_test_case_t&gt; (env); </pre><br>  And now, create_test_agent is already the ‚Äútemplate template‚Äù, i.e.  template function, one of the template parameters of which is another template. <br><br><h2>  More difficult test in which inheritance with polymorphism is required </h2><br>  The test analyzed above was very simple, it was enough to send only one message, so the test agents in it were simple.  But the next test, verifying that the user can cancel the deadletter handler, is already more complicated.  In order to deal with it for a start, let's see how the agent should work for the test case (for simplicity, we take only the usual, immutable test_message message for now): <br><br><ul><li>  the agent should start, hang up the deadletter handler for the test_message message; </li><li>  after that, the agent should send itself a test_message message to verify that the deadletter handler really is; </li><li>  when test_message arrives at the deadletter handler, the agent must cancel the deadletter handler, after which he sends himself test_message again, followed by a special signal, finish; </li><li>  if the agent again receives test_message in the deadletter handler, then the test fails; </li><li>  if the agent receives only finish without repeated test_message, then the test is successfully passed and the agent can be stopped. </li></ul><br>  Again, to make it easier to deal with the subsequent code, let us show how an agent written ‚Äúhead on‚Äù for a particular test case would look like.  The simplest option is with direct_mbox and the usual immutable test_message message: <br><br><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">finish</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">signal_t</span></span> {}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">test_case_specific_agent_t</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">state_t</span></span> st_test{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m_deadletters{ <span class="hljs-number"><span class="hljs-number">0</span></span> }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">deadletter_handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">mhood_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;test_message&gt;)</span></span></span><span class="hljs-function"> </span></span>{ ensure_or_die( <span class="hljs-number"><span class="hljs-number">0</span></span> == m_deadletters, <span class="hljs-string"><span class="hljs-string">"m_deadletters must be 0"</span></span> ); ++m_deadletters; so_unsubscribe_deadletter_handler&lt;test_message&gt;(so_direct_mbox()); so_5::send&lt;test_message&gt;(*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); so_5::send&lt;finish&gt;(*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">test_case_specific_agent_t</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">context_t</span></span> ctx ) : so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(ctx)) {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">so_define_agent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> &gt;&gt;= st_test; so_subscribe_deadletter_handler( so_direct_mbox(), &amp;<span class="hljs-keyword"><span class="hljs-keyword">test_case_specific_agent_t</span></span>::deadletter_handler); st_test.event([<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>](<span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;finish&gt;) { so_deregister_agent_coop_normally(); }); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">so_evt_start</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ so_5::send&lt;test_message&gt;(*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } };</code> </pre> <br>  Those.  there is an entry count in the deadletter_handler (m_deadletters attribute with a zero initial value).  Inside the deadletter_handler () this counter is checked for zero and incremented.  If deadletter_handler () is called again, the test will fail. <br><br>  The deadletter_handler method sends two messages.  The first should be ignored.  The second should lead to the completion of the test (subscription to the finish signal goes to so_define_agent). <br><br>  Well, the very first test_message is sent to so_evt_start.  Those.  at the start of the agent. <br><br>  However, this is not a template class.  Yes, and sharpened for a specific test script.  How to make a template out of it that could be parameterized with two parameters Mbox_Case and Msg_Type, as in the previous simple test? <br><br><h3>  The obvious solution (not the most interesting) </h3><br>  The obvious solution would be to take the classes pfn_test_case_t and lambda_test_case_t from a simple test and simply remake each of them into a new work logic. <br><br>  But this solution cannot be called good for the obvious reason: too much duplicate code turns out to be in each of the classes.  Accordingly, if we make a mistake in the first implementation, then it automatically extends to both classes, but its elimination requires modification of not one class, but both.  Also, if it is necessary to change the logic of behavior, then it will also be necessary to modify both classes, and not one.  (And the logic of the work had to be changed, because the more complex logic was originally used, but in the process of writing the article it became clear what could be done much simpler. This change in logic turned out to be elementary and there was no need to redo two classes independent from each other.) <br><br><h3>  Less obvious solution (with inheritance and polymorphism) </h3><br>  So, we need to move the common parts from pfn_test_case_t and lambda_test_case_t to some common class.  And since  agent classes in SObjectizer should be inherited from so_5 :: agent_t, then most likely this general class will be basic for both pfn_test_case_t and lambda_test_case_t. <br><br>  But will it be one class?  Let's get a look. <br><br>  You can pay attention to the fact that in the demo test_case_specific_agent_t there are both pieces of code that depend on the template parameters, and pieces of code that do not depend on the template parameters.  Let's say that the presence of the st_test state and the signal handler finish do not depend on the template parameters.  But the installation and cancellation of the deadletter handler, sending a test message - depend. <br><br>  This gives us the opportunity to break the common code into two parts.  The first part will not be template.  To implement this part, we need the following class: <br><br><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">nontemplate_basic_part_t</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">state_t</span></span> st_test{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-string"><span class="hljs-string">"test"</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m_deadletters{ <span class="hljs-number"><span class="hljs-number">0</span></span> }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">actual_deadletter_handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ ensure_or_die( <span class="hljs-number"><span class="hljs-number">0</span></span> == m_deadletters, <span class="hljs-string"><span class="hljs-string">"m_deadletters must be 0"</span></span> ); ++m_deadletters; do_next_step(); so_5::send&lt;finish&gt;(*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do_next_step</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">nontemplate_basic_part_t</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">context_t</span></span> ctx ) : so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(ctx) ) {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">so_define_agent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> &gt;&gt;= st_test; st_test.event( [<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>](<span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;finish&gt;) { so_deregister_agent_coop_normally(); } ); } };</code> </pre> <br>  You can see that a large part of the applied logic of the test agent is concentrated here.  And there is nothing that depends on the template parameter. <br><br>  However, already in nontemplate_basic_part_t, you need to perform two actions that depend on Msg_Type - this is canceling the deadletter handler and sending another instance of Msg_Type.  Inside nontemplate_basic_part_t, we know where and when these actions should be performed, but we cannot perform them. <br><br>  Therefore, we delegate the execution of these actions to the heir through the pure virtual method do_next_step (), which must be redefined in one of the heir classes. <br><br>  The heir of the same, in which do_next_step () is defined, will be a template class of the following form: <br><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Mbox_Case, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Msg_Type &gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">template_basic_part_t</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">nontemplate_basic_part_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Mbox_Case m_mbox_holder; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do_next_step</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ so_drop_deadletter_handler&lt; Msg_Type &gt;( m_mbox_holder.mbox() ); so_5::send&lt; Msg_Type &gt;( *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> ); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">template_basic_part_t</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">context_t</span></span> ctx ) : <span class="hljs-keyword"><span class="hljs-keyword">nontemplate_basic_part_t</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(ctx) ) , m_mbox_holder( *self_ptr() ) {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">so_evt_start</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ so_5::send&lt;Msg_Type&gt;( m_mbox_holder.mbox() ); } };</code> </pre> <br>  Here we already see the usual trick with the mbox_holder attribute of type Mbox_Case.  And also we see the implementation of the virtual methods do_next_step (cancellation of the deadletter handler and sending the second instance of Msg_Type) and so_evt_start (sending the first instance of Msg_Type). <br><br>  It turns out that nontemplate_basic_part_t and template_basic_part_t already contain 95% of the functionality needed by the test agent.  All that remains is to do pfn_test_case_t and lambda_test_case_t in which the deadletter handler of the desired type would be installed. <br><br>  This is how it will look like: <br><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Mbox_Case, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Msg_Type &gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pfn_test_case_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template_basic_part_t</span></span>&lt; Mbox_Case, Msg_Type &gt; { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">base_type_t</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">template_basic_part_t</span></span>&lt; Mbox_Case, Msg_Type &gt;; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">base_type_t</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">base_type_t</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">so_define_agent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">base_type_t</span></span>::so_define_agent(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;so_subscribe_deadletter_handler( <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;m_mbox_holder.mbox(), &amp;<span class="hljs-keyword"><span class="hljs-keyword">pfn_test_case_t</span></span>::on_deadletter ); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_deadletter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( so_5::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">mhood_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;Msg_Type&gt; )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;actual_deadletter_handler(); } }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Mbox_Case, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Msg_Type &gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">lambda_test_case_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template_basic_part_t</span></span>&lt; Mbox_Case, Msg_Type &gt; { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">base_type_t</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">template_basic_part_t</span></span>&lt; Mbox_Case, Msg_Type &gt;; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">base_type_t</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">base_type_t</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">so_define_agent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">base_type_t</span></span>::so_define_agent(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;so_subscribe_deadletter_handler( <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;m_mbox_holder.mbox(), [<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>](so_5::<span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;Msg_Type&gt;) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;actual_deadletter_handler(); } ); } };</code> </pre> <br>  There is simply classical inheritance with overlapping of the virtual method of the ancestor in order to extend its behavior: in so_define_agent (), so_define_agent () is first called from the base class, after which the deadletter handler of the proper form is set. <br><br>  So in the end it turns out the good old OOP, with inheritance (implementation) and polymorphism.  Yes, and plentifully flavored with generalized programming. <br><br><h2>  Disclaimer </h2><br>  I do not want readers to get the feeling that the described approach is the only correct one in this situation.  And that could not be done differently.  Surely it was possible.  And, for certain, even in this approach something could be made even simpler and more concise.  In the end, what was shown in the article was written literally on the knee in half an hour, checked, corrected and forgotten.  And then once again fixed and forgotten again.  What personally convinces me is that this approach to the implementation of tests is quite justified. <br><br>  The meaning of the article should have been to show how the possibilities, which some developers consider to be too complex and which they are trying to stay away from, can make their lives literally out of the blue. <br><br>  If you have a desire to express your ‚Äúphi‚Äù about the style of the code, please read <a href="https://habrahabr.ru/post/348880/">this comment first</a> .  I hope this will allow you to understand that in the C ++ world, the attitude to the used notations is much more loyal than in other languages.  And that this is more a dispute about tastes. <br><br><h1>  Something like a conclusion </h1><br>  OOP is just a tool.  Not a religion, not a disease.  Just a tool.  Somewhere it is appropriate, somewhere not.  Say, if you need to make a complex and large library, then OOP may be useful to you.  If you make a small and simple application, it may not be useful.  And maybe the opposite.  It all depends on the subject area, and on your knowledge and experience.  Well, from religious bias, of course. <br><br>  Similarly with generalized programming.  This is just a tool.  No one forces you to use it when it is not needed. <br><br>  But personally it is not very convenient for me when the set of tools available to me is intentionally limited.  Either by removing the PLO (or turning the PLO into some kind of pathetic similarity).  Either by removing the jeniric templates.  Even worse when there is neither one nor the other.  Since these tools were created to simplify the work of the programmer.  It is strange to refuse them voluntarily. <br><br>  Well, C ++, with all its flaws, is good because it allows you to use both.  Yes, even in various combinations.  Another question is how to learn how to use one and the other (and a bunch of C ++ features) in place and in moderation.  But that's another story ... :) </div><p>Source: <a href="https://habr.com/ru/post/348880/">https://habr.com/ru/post/348880/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../348870/index.html">Express assessment of the complexity of the algorithm (+ analysis of the problem with Joker 2017 and DotNext 2017 Moscow)</a></li>
<li><a href="../348872/index.html">Unmanned cars. Intel Expert Answers</a></li>
<li><a href="../348874/index.html">A guide for the practitioner how to read scientific articles on programming languages</a></li>
<li><a href="../348876/index.html">Payment system in 50 lines of code, really?</a></li>
<li><a href="../348878/index.html">New online software for developers</a></li>
<li><a href="../348882/index.html">Market as a stereotype regarding segment, need, supply</a></li>
<li><a href="../348884/index.html">KODOS: stay alive</a></li>
<li><a href="../348886/index.html">See the world through the eyes of animals: new horizons of eytreking</a></li>
<li><a href="../348890/index.html">Regular expressions: no magic</a></li>
<li><a href="../348892/index.html">Information Security Recommendations for Small and Medium Business (SMB)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>