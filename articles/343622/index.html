<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Eight C ++ 17 features that every developer should use</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="We‚Äôll talk about eight handy changes that affect your everyday code. Four changes concern the language itself, and four more - its standard library. 
...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Eight C ++ 17 features that every developer should use</h1><div class="post__text post__text-html js-mediator-article"><p>  We‚Äôll talk about eight handy changes that affect your everyday code.  Four changes concern the language itself, and four more - its standard library. </p><br><blockquote>  You may also be interested in the article <a href="https://habrahabr.ru/post/182920/">Ten C ++ 11 Features, which every C ++ developer should use</a> </blockquote><a name="habracut"></a><br><h2 id="blagodarnosti">  Thanks </h2><br><p>  I took some examples from the reports at conferences of the <a href="http://cpp-russia.ru/">Russian C ++ User Group</a> - for this many thanks to its organizers and speakers!  I took examples from: </p><br><ul><li>  <a href="http://cpp-russia.ru/%3Fpage_id%3D1253">Anton Polukhin.</a>  <a href="http://cpp-russia.ru/%3Fpage_id%3D1253">C ++ 17 (C ++ SIBERIA 2016)</a> </li><li>  <a href="https://www.youtube.com/watch%3Fv%3DI0oerm0MYQY">Alexander Fokin.</a>  <a href="https://www.youtube.com/watch%3Fv%3DI0oerm0MYQY">C ++ 17, which we deserve (C ++ SIBERIA 2017)</a> </li></ul><br><h2 id="1-dekompoziciya-pri-obyavlenii-angl-structural-bindings">  1. Decomposition at the announcement (structural bindings) </h2><br><ul><li>  use decomposition when declaring variables: auto [a, b, c] = std :: tuple (32, "hello" s, 13.9) <br><ul><li>  return a structure or a tuple from a function instead of assigning out parameters </li></ul></li></ul><br><p> It is convenient to decompose <code>std::pair</code> , <code>std::tuple</code> and structures using the new syntax: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;string&gt; struct BookInfo { std::string title; // In UTF-8 int yearPublished = 0; }; BookInfo readBookInfo(); int main() { //      title  year,     auto [title, year] = readBookInfo(); }</span></span></span></span></code> </pre> <br><p>  In C ++ 17, there are restrictions on decomposition when declaring: </p><br><ul><li>  types of decomposable elements cannot be explicitly specified </li><li>  cannot use nested decomposition of the form <code>auto [title, [header, content]] = ...</code> </li></ul><br><p>  Decomposition in the declaration, in principle, can decompose any class - it is enough to write a hint once by specializing <code>tuple_element</code> , <code>tuple_size</code> and <code>get</code> .  Read more in the article <a href="https://blog.tartanllama.xyz/structured-bindings/">Adding C ++ 17 structured bindings support to your classes (blog.tartanllama.xyz)</a> </p><br><p>  Decomposition during declaration works well in <code>std::map&lt;&gt;</code> and <code>std::unordered_map&lt;&gt;</code> containers with the old <code>.insert()</code> method and two new methods: </p><br><ul><li>  The <a href="http://en.cppreference.com/w/cpp/container/map/try_emplace">try_emplace</a> method performs insertion if and only if the specified key is not yet in the container. <br><ul><li>  If the specified key is already in the container, nothing happens: in particular, the rvalue values ‚Äã‚Äãare not moved </li></ul></li><li>  The <a href="http://en.cppreference.com/w/cpp/container/map/insert_or_assign">insert_or_assign</a> method either inserts or assigns the value of an existing element. </li></ul><br><p>  An example of a decomposition with try_emplace and a key-value decomposition when traversing a map: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;string&gt; #include &lt;map&gt; #include &lt;cassert&gt; #include &lt;iostream&gt; int main() { std::map&lt;std::string, std::string&gt; map; auto [iterator1, succeed1] = map.try_emplace("key", "abc"); auto [iterator2, succeed2] = map.try_emplace("key", "cde"); auto [iterator3, succeed3] = map.try_emplace("another_key", "cde"); assert(succeed1); assert(!succeed2); assert(succeed3); //    key  value   range-based for for (auto&amp;&amp; [key, value] : map) { std::cout &lt;&lt; key &lt;&lt; ": " &lt;&lt; value &lt;&lt; "\n"; } }</span></span></span></span></code> </pre> <br><h2 id="2-avtomaticheskiy-vyvod-parametrov-shablonov">  2. Automatic output of template parameters </h2><br><p>  Key rules: </p><br><ul><li>  functions of the form <code>std::make_pair</code> no longer needed: feel free to write <code>std::pair{10, "hello"s}</code> expressions, the compiler itself will output the type </li><li>  template RAII of the form <code>std::lock_guard&lt;std::mutex&gt; guard(mutex);</code>  become shorter: <code>std::lock_guard guard(mutex);</code> </li><li>  the <code>std::make_unique</code> and <code>std::make_shared</code> are still needed </li></ul><br><p>  You can create your own hints for automatic display of template parameters: see <a href="http://en.cppreference.com/w/cpp/language/class_template_argument_deduction">Automatic_deduction_guides</a> </p><br><p>  An interesting feature: the constructor from <code>initializer_list&lt;&gt;</code> skipped for a list of one element.  For some JSON libraries (such as json_spirit) this can be fatal.  Do not play with recursive types and STL containers! </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;vector&gt; #include &lt;type_traits&gt; #include &lt;cassert&gt; int main() { std::vector v{std::vector{1, 2}}; //  vector&lt;int&gt;,   vector&lt;vector&lt;int&gt;&gt; static_assert(std::is_same_v&lt;std::vector&lt;int&gt;, decltype(v)&gt;); //    assert(v.size() == 2); }</span></span></span></span></code> </pre> <br><h2 id="3-obyavlenie-vlozhennyh-prostranstv-imyon">  3. Declaring nested namespaces </h2><br><p>  Avoid nesting of namespaces, and if not avoided, then declare them like this: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> product::account::details { <span class="hljs-comment"><span class="hljs-comment">// ...   ... }</span></span></code> </pre> <br><h2 id="4-atributy-nodiscard-fallthrough-maybe_unused">  4. Attributes nodiscard, fallthrough, maybe_unused </h2><br><p>  Key rules: </p><br><ul><li>  terminate all case blocks, except the last, with either the <code>[[fallthrough]]</code> attribute or the <code>break;</code> instruction <code>break;</code> </li><li>  use <code>[[nodiscard]]</code> for functions returning an error code or owning a pointer (whether smart or not) </li><li>  use <code>[[maybe_unused]]</code> for variables that are only needed for checking in assert </li></ul><br><blockquote>  For more information about attributes, see the article <a href="https://medium.com/%40sshambir/%25D0%25BA%25D0%25B0%25D0%25BA-%25D0%25BF%25D0%25BE%25D0%25BB%25D1%258C%25D0%25B7%25D0%25BE%25D0%25B2%25D0%25B0%25D1%2582%25D1%258C%25D1%2581%25D1%258F-%25D0%25B0%25D1%2582%25D1%2580%25D0%25B8%25D0%25B1%25D1%2583%25D1%2582%25D0%25B0%25D0%25BC%25D0%25B8-%25D0%25B8%25D0%25B7-c-17-622a6b53225a">How to use attributes from C ++ 17</a> .  There will be brief excerpts. </blockquote><p>  In C ++, you have to add break after each case to the switch constructs, and even an experienced developer can easily forget about this.  The fallthrough attribute comes to the rescue, which can be pasted to an empty instruction.  In fact, the attribute is attached to the case following the empty instruction. </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">option</span></span></span><span class="hljs-class"> {</span></span> A, B, C }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">choice</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(option value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (value) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> option::A: <span class="hljs-comment"><span class="hljs-comment">// ... case option::B: // warning: unannotated fall-through between // switch labels // ... [[fallthrough]]; case option::C: // no warning // ... break; } }</span></span></code> </pre> <br><p>  To take advantage of the attribute, the warning <code>-Wimplicit-fallthrough</code> should be included in GCC and Clang.  After enabling this option, each case that does not have a fallthrough attribute will generate a warning. </p><br><p>  In projects with high performance requirements, you can practice avoiding the emission of exceptions (at least in some components).  In such cases, an operation execution error is reported by the return code returned from the function.  However, it is very easy to forget to check this code. </p><br><pre> <code class="cpp hljs">[[nodiscard]] <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;Bitmap&gt; LoadArrowBitmap() { <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// warning: ignoring return value of function declared // with warn_unused_result attribute LoadArrowBitmap(); }</span></span></code> </pre> <br><p>  If you use, for example, your own class of errors, you can specify the attribute once in its declaration. </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> [[</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">nodiscard</span></span></span><span class="hljs-class">]] </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">error_code</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> }; <span class="hljs-function"><span class="hljs-function">error_code </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// warning: ignoring return value of function declared // with warn_unused_result attribute bar(); }</span></span></code> </pre> <br><p>  Sometimes programmers create a variable that is used only in the debug version to store the error code of the called function.  Perhaps this is just a code design error, and the return value should always be processed.  However: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// !  ! auto result = DoSystemCall(); (void)result; //    unused variable assert(result &gt;= 0); //   [[maybe_unused]] auto result = DoSystemCall(); assert(result &gt;= 0);</span></span></code> </pre> <br><h2 id="5-klass-string_view-dlya-parametrov-strok">  5. Class string_view for string parameters </h2><br><p>  Rules: </p><br><ul><li>  in the parameters of all functions and methods instead of <code>const string&amp;</code> try to accept non-possessing <code>string_view</code> by value <br><ul><li>  return from the functions and methods owning the <code>string</code> , as before </li></ul></li><li>  be careful with returning the string_view from a function: this can lead to a hanging link problem (dangling pointers) </li></ul><br><blockquote>  For more information on why string_view is best applied only to parameters, see <a href="https://medium.com/%40sshambir/std-string-view-%25D0%25BA%25D0%25BE%25D0%25BD%25D1%2581%25D1%2582%25D1%2580%25D1%2583%25D0%25B8%25D1%2580%25D1%2583%25D0%25B5%25D1%2582%25D1%2581%25D1%258F-%25D0%25B8%25D0%25B7-%25D0%25B2%25D1%2580%25D0%25B5%25D0%25BC%25D0%25B5%25D0%25BD%25D0%25BD%25D1%258B%25D1%2585-%25D1%258D%25D0%25BA%25D0%25B7%25D0%25B5%25D0%25BC%25D0%25BF%25D0%25BB%25D1%258F%25D1%2580%25D0%25BE%25D0%25B2-%25D1%2581%25D1%2582%25D1%2580%25D0%25BE%25D0%25BA-3453e7d3a75b">std :: string_view is constructed from temporary instances of strings.</a> </blockquote><p>  The <code>string_view</code> class <code>string_view</code> good because it is easily constructed from both <code>std::string</code> and <code>const char*</code> without additional memory allocation.  It also has constexpr support and repeats the std :: string interface.  But there is a minus: for <code>string_view</code> presence of a null character at the end is not guaranteed. </p><br><h2 id="6-klassy-optional-i-variant">  6. Classes optional and variant </h2><br><p>  The use of <code>optional&lt;&gt;</code> and <code>variant&lt;&gt;</code> so wide that I will not even try to fully describe them in this article.  Key rules: </p><br><ul><li>  prefer <code>optional&lt;T&gt;</code> instead of <code>unique_ptr&lt;T&gt;</code> for the composition of an object T whose lifetime is shorter than the owner‚Äôs lifetime <br><ul><li>  for PIMPL, use <code>unique_ptr&lt;Impl&gt;</code> , because the definition of Impl is hidden in the class implementation file </li></ul></li><li>  use variant type instead of enum or polymorphic classes in a situation where states, such as license status, cannot be described by enum constants due to the presence of additional data in each of the states </li><li>  use variant type instead of enum in a situation where data, such as an error code in an exception, must be processed in all variants, and incomplete variant processing should result in a compilation error </li><li>  use variant type instead of any wherever possible </li><li>  optional can be used to compose an object whose lifetime is shorter than the owner's lifetime </li><li>  do not use <code>optional</code> for error handling: it does not carry any information about the error <br><ul><li>  to return the value or error, you can write your class <code>Expected&lt;Value, Error&gt;</code> , based on <code>boost::variant&lt;...&gt;</code> </li><li>  but you can not write and take ready: <a href="https://github.com/martinmoene/expected-lite">github.com/martinmoene/expected-lite</a> </li></ul></li></ul><br><p>  Sample code with optional: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// nullopt -     nullopt_t,   //  optional ( nullptr  ) std::optional&lt;int&gt; optValue = std::nullopt; // ...  optValue ... //   ,  -1 const int valueOrFallback = optValue.value_or(-1);</span></span></code> </pre> <br><ul><li>  optional has <code>operator*</code> and <code>operator-&gt;</code> , as well as the convenience method <code>.value_or(const T &amp;defaultValue)</code> </li><li>  optional has a value method, which, unlike <code>operator*</code> , throws an exception <code>std::bad_optional_access</code> when there is no value </li><li>  optional has comparison operators ‚Äú==‚Äù, ‚Äú! =‚Äù, ‚Äú&lt;‚Äù, ‚Äú&lt;=‚Äù, ‚Äú&gt;‚Äù, ‚Äú&gt; =‚Äù, while <code>std::nullopt</code> less than any valid value </li><li>  optional has an explicit conversion operator to bool </li></ul><br><p>  Example code with variant: here we use variant to store one of several states in the case when different states may have different data </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AnonymousUserState</span></span></span><span class="hljs-class"> {</span></span> }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TrialUserState</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> userId; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> username; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SubscribedUserState</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> userId; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> username; Timestamp expirationDate; LicenseType licenceType; }; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UserState = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::variant&lt; AnonymousUserState, TrialUserState, SubscribedUserState &gt;;</code> </pre> <br><p>  The variant advantage in its approach to memory management: data is stored in fields of type variant type without additional allocations of memory.  This makes the size of the variant type dependent on the types that make it up.  So a size table on 32-bit processors may look like (but this is not accurate): </p><br><p><img src="https://habrastorage.org/webt/v6/5l/lr/v65llrodbzhpdr5kj0kxa0-3sj8.png" alt="Illustration"></p><br><h2 id="7-ispolzuyte-funkcii-stdsize-stddata-stdbegin-stdend">  7. Use the functions std :: size, std :: data, std :: begin, std :: end </h2><br><ul><li>  use <a href="http://en.cppreference.com/w/cpp/iterator/size">std :: size</a> to measure the length of the C-style array <br><ul><li>  this function works with arrays and with STL containers, but will generate a compilation error when you try to pass a normal pointer to it </li></ul></li><li>  use <a href="http://en.cppreference.com/w/cpp/iterator/data">std :: data</a> to get a variable pointer to the beginning of a string, array, or <code>std::vector&lt;&gt;</code> <br><ul><li>  Previously, to obtain such a pointer, we used the expression <code>&amp;text[0]</code> , but it has undefined behavior on empty lines. </li></ul></li></ul><br><p>  It may be better to rely on the GSL library (C ++ Core Guidelines Support Library) for byte manipulations. </p><br><h2 id="8-ispolzuyte-stdfilesystem">  8. Use std :: filesystem </h2><br><p>  Key rules: </p><br><ul><li>  pass <code>std::filesystem::path</code> instead of strings in all parameters that imply the path </li><li>  be careful with the <code>canonical</code> function: perhaps you meant the <a href="http://en.cppreference.com/w/cpp/filesystem/path/lexically_normal">lexically_normal</a> method <br><ul><li>  canonical handles symbolic links, but lexically_normal does not </li><li>  canonical requires a path to exist, but lexically_normal does not </li><li>  on Windows, an attempt to glue together a path that is too-too-long and a ".." and then apply canonical may fail: Boost throws an exception because the path to the file is too long </li></ul></li><li>  be careful with the <code>relative</code> function: perhaps you meant <a href="http://en.cppreference.com/w/cpp/filesystem/path/lexically_normal">lexically_relative</a> </li><li>  try to use noexcept versions of functions (with an error code) if the error is acceptable to you <br><ul><li>  for example, use the noexcept version of the <a href="http://en.cppreference.com/w/cpp/filesystem/exists">exists</a> function, otherwise you will get exceptions for some network paths! </li></ul></li><li>  do not use boost :: filesystem </li></ul><br><p>  What is bad boost :: filesystem?  It turns out that he has several design problems: </p><br><ul><li>  Boost has not solved the problem of 2038;  more precisely, this task was shifted to time_t, but in Linux it is still 32-bit! <br><ul><li>  there is a great article on that topic <a href="https://habrahabr.ru/company/pvs-studio/blog/328054/">2038: only 21 years left</a> </li></ul></li><li>  the STL version of the filesystem has all the means to work with encodings </li></ul><br><p>  Any experienced programmer knows the difference in processing paths between Windows and UNIX systems: </p><br><ul><li>  in Windows, paths are accepted as UTF-16 strings (or even UCS-2 strings, i.e., surrogate pairs in paths should be avoided!), the often used wchar_t type represents a 2-byte character in UTF-16 encoding, and backslash ‚Äú\‚Äù </li><li>  in UNIX, paths are accepted as UTF-8 strings, rarely used wchar_t represents a 4-byte character in UCS32 encoding, and the path separator is the forward slash ‚Äú/‚Äù </li></ul><br><p>  Of course, filesystem abstracts from such differences and makes it easy to work with both platform-specific strings and universal UTF-8: </p><br><ul><li>  To get the UTF-8 version of the path, use the <a href="http://en.cppreference.com/w/cpp/filesystem/path/string">u8string</a> method <a href="http://en.cppreference.com/w/cpp/filesystem/path/string">.</a> </li><li>  to construct a path from a UTF-8 string, use the free function <a href="http://en.cppreference.com/w/cpp/filesystem/path/u8path">u8path</a> </li><li>  do not use the <code>std::filesystem::path</code> constructor from <code>std::string</code> - on Windows, the constructor considers the OS encoding as the input encoding! </li></ul><br><h2 id="bonusnoe-pravilo-prekratite-pereizobretat-clamp-int_to_string-i-string_to_int">  Bonus rule: stop reinventing clamp, int_to_string and string_to_int </h2><br><p>  The <a href="http://en.cppreference.com/w/cpp/algorithm/clamp">std :: clamp</a> function complements the min and max functions.  It cuts off the meaning from above and below.  A similar function <code>boost::clamp</code> is available in earlier versions of C ++. </p><br><p>  The rule "do not reinvent the clamp" can be summarized: in any large project, avoid duplicating small functions and expressions for rounding, clipping values, etc.  - just add it to your library once. </p><br><p>  A similar rule works for string processing tasks.  Do you have your own little library for strings and parsing?  Does it have parsing or number formatting?  If so, replace your implementation with calls <a href="http://en.cppreference.com/w/cpp/utility/to_chars">to_chars</a> and <a href="http://en.cppreference.com/w/cpp/utility/from_chars">from_chars</a> </p><br><p>  The <code>to_chars</code> and <code>from_chars</code> support error handling.  They return two values: </p><br><ul><li>  the first is of type <code>char*</code> or <code>const char*</code> respectively, and points to the first code unit (i.e. char or wchar_t) that could not be processed </li><li>  the second is of type <code>std::error_code</code> and reports detailed error information suitable for throwing an exception std :: system_error </li></ul><br><p>  Since in the application code, the error response method may differ, you should place the to_chars and from_chars calls inside your libraries and utility classes. </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;utility&gt; //    ,     0 // (   atoi,      ) template&lt;class T&gt; T atoi_17(std::string_view str) { T res{}; std::from_chars(str.data(), str.data() + str.size(), res); return res; }</span></span></span></span></code> </pre> </div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/343622/">https://habr.com/ru/post/343622/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../343604/index.html">We teach the machine to understand the human genes</a></li>
<li><a href="../343610/index.html">PHP 7.2.0 released</a></li>
<li><a href="../343612/index.html">About creating payloads for different platforms using msfvenom</a></li>
<li><a href="../343614/index.html">Learn CSS Grid in 5 minutes</a></li>
<li><a href="../343616/index.html">Another Telegram-bot for video surveillance</a></li>
<li><a href="../343624/index.html">Lambda the ripper</a></li>
<li><a href="../343628/index.html">DevDay about microservices. Record the best reports</a></li>
<li><a href="../343630/index.html">Indie developer started phone tech support, and that's what happened</a></li>
<li><a href="../343632/index.html">How much does a CRM system cost?</a></li>
<li><a href="../343634/index.html">Announcement of the meeting WordPress Meetup # 4 in Kharkov</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>