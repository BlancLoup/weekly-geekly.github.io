<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Journey into the world of corporate service tires on IBM WebSphere ESB</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This article wants to open a cycle dedicated to IBM WebSphere ESB (hereinafter - ESB) in the context of development for this product. And, first of al...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Journey into the world of corporate service tires on IBM WebSphere ESB</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/f8d/95a/896/f8d95a8960b5adaf07a56189ee1e6817.png" alt="image" align="left">  This article wants to open a cycle dedicated to IBM WebSphere ESB (hereinafter - ESB) in the context of development for this product.  And, first of all, you will have to get acquainted with technologies of this kind. <br>  Enterprise service bus (enterprise service bus) - middleware, providing centralized and unified event-oriented messaging between different information systems on the principles of service-oriented architecture. <br>  Of course, it is possible and without special software (perhaps, something common still needs to be developed) to build a corporate system based on this approach, and what will be the result, call the service bus.  But the IBM product has not only a ready-made device for centralized messaging and control of this process, but also a full range of capabilities for developing flexible service-oriented applications specifically for ESB.  In summary, the following features and benefits of IBM WebSphere ESB can be highlighted: <br><ul><li>  The order and uniformity of architectural relationships </li><li>  Centralized management </li><li>  Server side application configuration </li><li>  Implementing the Service Component Architecture (SCA) technology in the spirit of the principles of service-oriented architecture </li><li>  Protocol independence of the developed code </li><li>  Extensive bus and application configuration options </li></ul><a name="habracut"></a><br>  In this case, the ESB provides transactional control, data conversion, security and guaranteed message delivery.  Access to all services through a single point allows you to configure the communication of services centrally.  You can also manage failed events centrally for mass error handling. <br>  The classic ESB build topology is a cluster that provides horizontal scalability and fault tolerance.  According to official recommendations, increasing the number of cluster members increases productivity more efficiently than increasing server capacity in a stand-alone topology.  In addition, the cluster can be rebooted (or part of it can fail) without stopping the service. <br>  Usually, ESB is used as a service layer in IBM BPM, but it may well play a leading role in building a model of interaction between corporate systems as a powerful integration machine (meaning ESB as an add-on over IBM WebSphere Application Server). <br>  This, in essence, is required from the ESB, since it is a ‚Äúservice collection point‚Äù - if you need a service that will work with other services (perhaps external), then the integration between these services is most logical to do on the ESB.  For external or heterogeneous services, a ‚Äúwrapper‚Äù can be made an ESB service.  We will slightly illustrate the convenience of using ‚Äúsingle housing‚Äù for services: <br><br>  <b>Order</b> <br>  The larger the system, the more important it is order and uniformity.  If we are talking about a complex of large enterprise systems, then we can definitely call it a large-size system.  Of course, you can always find an administrator who has in his head the interaction scheme of hundreds of servers, or a bunch of volumes of unrelated documentation for each software module, which describes what and how it interacts. <br><img src="https://habrastorage.org/getpro/habr/post_images/428/b61/835/428b618352580f2773b56e2ae8fc282c.png" alt="image"><br>  But it is much easier to have a service (ESB), which allows you to conduct all the interaction through yourself.  With this approach, part of the interaction architecture in any subsystem is already clear - there is no mess in the connections between systems, servers and applications: everything is connected with the ESB and the ESB is connected with everything. <br><img src="https://habrastorage.org/getpro/habr/post_images/9fe/1f6/b43/9fe1f6b43a2c62797695f5ac5f5dfae0.png" alt="image"><br><br>  <b>Centralized management</b> <br>  It is always more convenient to configure systems centrally - whether it is configuration, adaptation to server relocation, fault tolerance, load balancing, error handling or monitoring and analytics. <br><img src="https://habrastorage.org/getpro/habr/post_images/d4e/66a/d54/d4e66ad54751964c75b43d3f9bf8ba47.png" alt="image" align="right"><br>  For example, when moving a database server, you do not need to climb into the configuration of all existing application servers, and in setting up specific applications in particular, it is enough to have one environment variable in the ESB, which indicates the database address, and then the changes will need to be done at just one point. <br>  Or, if one of the external systems was unavailable for a long time, and no request to it should be lost, you can use the service of handling failed events to ‚Äúthrow in‚Äù the failed messages when it is convenient. <br>  If you need to adjust the number of simultaneous requests to a system, or monitor these requests, analyze the load, look for bottlenecks - you need to go to the messaging control center - to the console of the ESB server. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>Server side configuration</b> <br>  ‚ÄúSingle housing‚Äù for services, in terms of configuration, allows to achieve several useful goals.  First, it is configuration reuse (similar to code and module reuse, which is so useful in SOA), since different modules and applications can use the same database connection parameters, resources, authentication parameters, environment variables, etc. . <br><img src="https://habrastorage.org/getpro/habr/post_images/e43/0d6/558/e430d65586b2cdd80d94693eb914647f.png" alt="image" align="right"><br>  Secondly, when configuring on the server side, it is the application environment that can influence it in many ways, which allows you to transfer applications between different circuits (test and productive), tune and even fix bugs without making changes to the application. <br><br>  If you use all these advantages, applications get the capabilities of a true chameleon - they are so flexible that they become part of the environment in which they work, and at the same time they bring in their important functionality. <br><br>  But the flexibility of applications for IBM WebSphere ESB is not limited to their work environment.  Development opportunities make a huge contribution to this.  Since systems not only need to have where to run, but still need to develop and refine, these interesting points should not be overlooked: <br><br>  <b>SCA</b> <br>  This architecture is based on the principle that the component provides its functionality as a service available to other components.  Within one module, the components are program blocks (java code) that fully implement some functionality described by the corresponding interface.  The component execution logic is implemented by linking them into a structure by interfaces and references (Partner Reference). <br><img src="https://habrastorage.org/getpro/habr/post_images/2a9/357/4a2/2a93574a2b577b8e78673d1bd5f37a30.png" alt="image"><br>  This module structure is very convenient to develop, test, develop, modify and maintain.  The atomicity of the functional implemented in the components allows you to operate on the components as a whole, without going down to the code level.  On the other hand, it is logically necessary due to the implementation of component implementations in a transactional context. <br>  Each component has an interface (s), the implementation of which it provides.  Thus, interconnecting the components, there is no need to know their internal features - it is enough that they implement the necessary interfaces. <br>  Through this architecture, it is also possible to solve all the tasks that require parallel work, without ‚Äúmanual‚Äù flow control (for example, you can make asynchronous calls to several components with a delayed response). <br>  Non-java-components, for example, types Export and Import, allow you to provide services for external use or use external services, respectively;  The Mediation Flow component provides low-level access to messages exchanged between other components and allows for various transformations when working with heterogeneous interfaces. <br>  In addition to interfaces, the IBM business object framework provides very useful features.  Business objects (BO), represented by xsd-schemes, are used as objects for data transmission in interfaces, both between components, and for communication between modules.  They are directly integrated, for example, into the wsdl scheme for describing web services.  That is, for example, if module "A" provides its functionality as a web service, module "B" to use it is enough to connect the interface and ready-made BOs, and it will be able to fully work with such a service without creating any additional java -objects for data transfer.  BO is also convenient to use when exchanging data from a database, if this data is used by other components (this, of course, goes against the ‚ÄúDAO‚Äù pattern, but eliminates unnecessary java-objects and data rewriting operations ‚Äúback and forth‚Äù). <br><br>  <b>Protocol-Independent Software Code</b> <br>  As you can see, the protocol-independent code is achieved by using the Export and Import components.  Since the connection with these components goes through interfaces and references, the program code is completely independent of the protocol used for interaction.  The same functionality can be made accessible by any traffic using any number of supported protocols and any desired interfaces.  The following figure shows the addition of SCA-bound export to a component that already provides its interface as HTTP, JMS, and Web service. <br><img src="https://habrastorage.org/getpro/habr/post_images/635/669/e6f/635669e6fcbe2975a34ac7f687630d41.png" alt="image"><br>  The convenience is obvious - flexibility, versatility, code reuse, speed of development and modification. <br>  By the way, SCA binding uses a special protocol and is intended for communication between modules within a single server / cluster.  Interaction through this binding is less resource intensive and faster than other protocols. <br><br>  <b>Configuration</b> <br>  Configuring the server and applications is done through the IBM console server. <br>  In ESB, as in IBM WebSphere in general, there are quite a few specific features and artifacts.  For example, using the same imports and exports, you can configure the end-points of the corresponding services on the fly.  For service calls, you can customize policy sets with various rules (for example, you can install support for the WS-AT mechanism, which allows you to call a web service in the same transaction the client works in; but transactionality is already a topic for a full article) set authentication parameters, connect certificates and so on. <br>  Through the configuration, you can configure some mechanisms for automatic response to exceptional situations (for example, automatic repetition of component execution in case of errors).  You can set up component tracing on the fly or change logging levels.  Also available is a service for managing failed events that can be consciously used for mass error handling. <br>  Well, of course, you can configure a lot of other things according to the Java2EE specification, which, sometimes quite strictly, is implemented in the IBM Application Server. <br><br>  All of the above claims ESB as a convenient, powerful and flexible integration apparatus, though not always easy to learn.  In the future, you just need to learn how to use it. <br><br>  <i>The following images were used in the article: <a href="">1</a> <a href="">2</a> <a href="">3</a> <a href="">4</a> <a href="">5</a></i> </div><p>Source: <a href="https://habr.com/ru/post/191600/">https://habr.com/ru/post/191600/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../191590/index.html">ROI Initiative Digest</a></li>
<li><a href="../191592/index.html">VKontakte Node JS SDK</a></li>
<li><a href="../191594/index.html">Sonar principles and underwater acoustics: how, why and why</a></li>
<li><a href="../191596/index.html">Solving the transport problem with a genetic algorithm as part of SOA</a></li>
<li><a href="../191598/index.html">How to make such an ERP system so that users do not run IT in reports</a></li>
<li><a href="../191602/index.html">Older OS: IBM VM / 370</a></li>
<li><a href="../191604/index.html">Experience in writing refactoring</a></li>
<li><a href="../191606/index.html">A short comparison of VHDL and Verilog to help beginners with FPGAs</a></li>
<li><a href="../191608/index.html">And let's really block the government access to the sites?</a></li>
<li><a href="../191610/index.html">Icelandic Innovation Center</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>