<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Windows clean WinAPI. Or just about the difficult</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Disclaimer 

 It would seem that WinAPI is a thing of the past. It has long been a huge number of cross-platform frameworks, Windows not only on deskt...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Windows clean WinAPI. Or just about the difficult</h1><div class="post__text post__text-html js-mediator-article">  <i>Disclaimer</i> <br><br>  It would seem that WinAPI is a thing of the past.  It has long been a huge number of cross-platform frameworks, Windows not only on desktops, but Microsoft themselves don‚Äôt like applications that use this monster in their store.  In addition to this, articles on how to create windows on WinAPI, not only here, but also all over the Internet, amount to thousands of pre-schoolers and above.  This whole process has already been disassembled, not even by atoms, but by subatomic particles.  What could be simpler and clearer?  And then I still ... <br><br>  But not everything is as simple as it seems. <br><a name="habracut"></a><br><h4>  Why about WinAPI now? </h4><br>  At one point, studying the offal of one of the games in a very good <a href="https://sourceforge.net/p/fceultra/code/HEAD/tree/">NES emulator</a> , I thought: It seems to be a good emulsion, and in the debugger there is no such simple thing as navigating the keyboard buttons, which is in any normal debugger. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Here I knowingly gave a link to the repository, because  it is clear that the guys are faced with a problem, which will be discussed below, but did not solve it. <br><br>  What am I talking about?  But <a href="">about this</a> piece of code: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> WM_KEYDOWN: MessageBox(hwndDlg,<span class="hljs-string"><span class="hljs-string">"Die!"</span></span>,<span class="hljs-string"><span class="hljs-string">"I'm dead!"</span></span>,MB_YESNO|MB_ICONINFORMATION); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>;</code> </pre> <br>  Thus, the authors wanted to add support for the keyboard, but the harsh reality of the depths of the dialog box architecture in Windows harshly curbed such initiative.  Those who used the emulator and debugger in it, at least once saw this message? <br>  What is the problem? <br><br>  The answer is: you can not do that! <br><br>  And, returning to the original question about WinAPI: a lot of popular, and not so much, projects continue to use it even now, because  It‚Äôs better than many things to do on a pure API (here you can endlessly give analogies like comparing high-level languages ‚Äã‚Äãand assembler, but this is not about that now).  And why is it so little?  Just use and that's it. <br><br><h4>  About the problem </h4><br>  Dialog boxes make it easier to work with the GUI, at the same time making it impossible for us to do something on our own.  For example, the WM_KEYDOWN / WM_KEYUP messages coming into the window procedure are ‚Äúeaten up‚Äù in the depths of DefDlgProc, taking on such things as: Tab navigation, Esc key processing, Enter key, etc.  In addition, the dialogues do not need to be created manually: it‚Äôs easier, in fact, to jot down buttons, lists, in the resource editor, call CreateDialog / DialogBox in WinMain and everything is ready. <br><br>  Getting around such minor annoyances is simple.  There are at least two completely legal ways: <br><br><ol><li>  Create your own class via <a href="https://msdn.microsoft.com/ru-ru/ms633587">RegisterClassEx</a> and grab WM_KEYDOWN in the class handling procedure, redirect to the dialog handling procedure.  Yes Yes!  You can create dialogs with your own class, and the built-in VS editor even allows you to set the class name for the dialog.  But who knows about it and uses it? <br>  The minus is obvious: You need to register another class, have more procedure on 1 CALLBACK, the essence of which will be only in the translation of a pair of messages.  In addition, we will not know <b>where</b> to broadcast them, and will have to make crutches. </li><li>  Use the built-in accelerator mechanism.  And we do not even have to change the code of the dialogue procedure!  Well, except to add one line to switch / case, but more on that below. </li></ol><br><h4>  Tutorials? </h4><br>  I‚Äôm not afraid to say that <i>all</i> tutorials on creating windows through WinAPI start with such a straightforward code, denoting it as the "message processing cycle" (I‚Äôll leave out the details of preparing the window class and other binding): <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (GetMessage(&amp;msg, <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>)) { TranslateMessage(&amp;msg); DispatchMessage(&amp;msg); }</code> </pre> <br>  Here everything is really simple: <br><br><ol><li>  GetMessage () snatches the next message from the queue, and the <i>key point</i> : it blocks the stream if the queue is empty. </li><li>  TranslateMessage () from WM_KEYDOWN / WM_KEYUP generates WM_CHAR / WM_SYSCHAR messages (they are needed if someone wants to make their own text editor). </li><li>  DispatchMessage () sends a message to the window procedure (if one exists). </li></ol><br>  Let's start with the fact that this code is dangerous to use, and <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms644936(v%3Dvs.85).aspx">here's why</a> .  Note the footnote: <br><blockquote>  Because the return value can be nonzero, zero, or -1, avoid code like this: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (GetMessage( lpMsg, hWnd, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>)) ...</code> </pre> </blockquote>  And below is an example of the correct cycle. <br><br>  <i>It should be said that in the VS templates for Win32 applications, it was written just such an <b>incorrect</b> cycle.</i>  <i>And it is very sad.</i>  <i>After all, few people will delve into what the authors themselves have done, because this is a priori correct.</i>  <i>And the wrong code is multiplied along with bugs that are very difficult to catch.</i> <br><br>  After this code snippet, as a rule, there is a story about accelerators, and a couple of new lines are added (taking into account the remark in MSDN, I suggest writing the right cycle right away): <br><br><pre> <code class="cpp hljs">HACCEL hAccel = LoadAccelerators(hInstance, MAKEINTRESOURCE(IDR_ACCELERATOR)); BOOL bRet = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ( bRet = GetMessage(&amp;msg, <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( <span class="hljs-number"><span class="hljs-number">-1</span></span> == bRet ) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( !TranslateAccelerator(msg.hwnd, hAccel, &amp;msg) ) { TranslateMessage(&amp;msg); DispatchMessage(&amp;msg); } }</code> </pre> <br>  This option I have seen most often.  And he ( <i>ta-dam</i> ) is wrong again! <br><br>  First about what has changed (then about the problems of this code): <br><br>  The first line of resources loads a table of keys, when clicked, a WM_COMMAND message will be generated with the corresponding command id. <br><br>  Actually, TranslateAccelerator does this: if it sees the WM_KEYDOWN and the key code that is in this list, then (again, the key moment) will generate the WM_COMMAND message (MAKEWPARAM (id, 1)) and send it to the appropriate window for the handle specified in the first argument processing procedure. <br><br>  From the last phrase, I think, it became clear what the problem of the previous code is. <br>  Let me explain: GetMessage snatches messages for ALL objects of the type ‚Äúwindow‚Äù (which also includes children: buttons, lists, etc.), and TranslateAccelerator will send the generated WM_COMMAND to where?  Correct: back to button / list, etc.  But we process WM_COMMAND in our procedure, which means we are interested in getting it in it. <br><br>  It is clear that TranslateAccelerator should be called for our newly created window: <br><br><pre> <code class="cpp hljs">HWND hMainWnd = CreateWindow(...); HACCEL hAccel = LoadAccelerators(hInstance, MAKEINTRESOURCE(IDR_ACCELERATOR)); BOOL bRet = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (bRet = GetMessage(&amp;msg, <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( <span class="hljs-number"><span class="hljs-number">-1</span></span> == bRet ) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( !TranslateAccelerator(hMainWnd, hAccel, &amp;msg) ) { TranslateMessage(&amp;msg); DispatchMessage(&amp;msg); } }</code> </pre> <br>  And everything seems to be good and wonderful now: we have disassembled everything in detail and everything should work perfectly. <br><br>  And no again.  :-) This will work correctly as long as we have exactly one window - ours.  As soon as a modeless new window (dialog) appears, all the keys that will be pressed in it are translated into WM_COMMAND and sent to?  And again, right: in our main window. <br><br>  At this stage, I propose not to crush the crutches to address this impasse, but I propose to consider things that are less common (or almost never occur) in tutorials. <br><br><h4>  IsDialogMessage </h4><br>  By the name of this function, you might think that it for some reason determines whether this message is related to dialogue or not.  But, first, why do we need to know this?  And secondly, what should we do next with this information? <br><br>  In fact, it makes a little more than the name implies.  Namely: <br><br><ul><li>  Navigates through the child controls with Tab / Shift + Tab / up / down / right / left.  Plus something else, but this is enough for us </li><li>  By clicking on the ESC forms WM_COMMAND (IDCANCEL) </li><li>  Clicking on Enter generates WM_COMMAND (IDOK) or pressing the current default button. </li><li>  Toggle buttons by default (the frame for such buttons is slightly brighter than the others) </li><li>  Well, and still different things that make it easier for the user to work with the dialogue </li></ul><br>  What does she give us?  First, we don‚Äôt have to think about navigating inside the window.  And so we will do everything.  <i>By the way, Tab navigation can be done by adding the WS_EX_CONTROLPARENT style to our main window, but this is clumsy and not so functional</i> . <br><br>  Secondly, it will make life easier for us on all the other points listed in the list (and even a little more). <br><br>  In general, it is used somewhere in the bowels of Windows to make <b>modal dialogs</b> work, and given to programmers to invoke it for non-modal dialogs.  However, we can use <a href="https://msdn.microsoft.com/en-us/library/ms909636.aspx">it anywhere</a> : <br><blockquote>  Although it is a mode of dialog boxes, it allows you to use the dialog box. </blockquote>  Those.  Now, if we issue a loop like this: <br><br><pre> <code class="cpp hljs">HWND hMainWnd = CreateWindow(...); HACCEL hAccel = LoadAccelerators(hInstance, MAKEINTRESOURCE(IDR_ACCELERATOR)); BOOL bRet = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (bRet = GetMessage(&amp;msg, <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( <span class="hljs-number"><span class="hljs-number">-1</span></span> == bRet ) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( !TranslateAccelerator(hMainWnd, hAccel, &amp;msg) ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( !IsDialogMessage(hMainWnd, &amp;msg) ) { TranslateMessage(&amp;msg); DispatchMessage(&amp;msg); } } }</code> </pre> <br>  Then our window will have navigation, as in the native Windows dialog.  But now we got two flaws: <br><br><ol><li>  This code will also work well with only <b>one (non-modal) window</b> ; </li><li>  Having received all the advantages of interactive navigation, we lose the charms in the form of WM_KEYDOWN / WM_KEYUP messages (only for the window itself, and not for the child controls); </li></ol><br>  And at this stage in general, all the tutorials end and the questions begin: <a href="https://stackoverflow.com/questions/7230877/how-to-handle-keyboard-events-in-a-winapi-standard-dialog">How to handle the keyboard events in a winapi standard dialog?</a> <a href="https://stackoverflow.com/questions/7230877/how-to-handle-keyboard-events-in-a-winapi-standard-dialog"><br></a>  This is the first link in Google, but believe me: thousands of them.  About the proposed solutions (the best of which is to create your own class of dialogs, as I wrote above, before <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/bb773183(v%3Dvs.85).aspx">subclassing</a> and RegisterHotKey. Somewhere I even saw the ‚Äúbest‚Äù of ways: using Windows Hooks). <br><br>  It's time to talk about what is not in the tutorials and answers. <br><br>  As a rule (as a rule! If someone wants more, you can register your class for dialogs and work like that. And if someone is interested, I can add this article) WM_KEYDOWN want when they want to process a click on a key that performs the function regardless of the selected control in the window - i.e.  a kind of common function for all this particular dialogue.  And if so, then why not take advantage of the rich features that WinAPI itself offers us: <b>TranslateAccelerator</b> . <br><br>  Everywhere they use <b>exactly one</b> accelerator table, and only for the main window.  Well, really: the GetMessage-loop is one, which means the table is one.  Where else to put them? <br><br>  In fact, the GetMessage-loop can be <b>nested</b> .  Let's look at the <a href="https://msdn.microsoft.com/ru-ru/library/ms910659.aspx">PostQuitMessage</a> description <a href="https://msdn.microsoft.com/ru-ru/library/ms910659.aspx">again</a> : <br><blockquote>  The PostQuitMessage function posts a message and a message queue;  The function simply indicates that it is a thread. </blockquote>  And GetMessage: <br><blockquote>  If the function retrieves the WM_QUIT message, the return value is zero. </blockquote>  Thus, the exit from the GetMessage-loop will be realized if we call PostQuitMessage in the window procedure.  What does it mean? <br><br>  We can create our own similar cycle for <b>each <i>non-modal</i></b> window in our program.  In this case, DialogBoxParam does not suit us, because  it turns its own cycle and we cannot influence it.  However, if we create a dialog through CreateDialogBoxParam or a window through CreateWindow, then we can spin another cycle.  At the same time, in <i>each</i> such window and dialog we should call PostQuitMessage: <br><br><pre> <code class="cpp hljs">HWND hMainWnd = CreateWindow(...); HACCEL hAccel = LoadAccelerators(hInstance, MAKEINTRESOURCE(IDR_ACCELERATOR)); BOOL bRet = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (bRet = GetMessage(&amp;msg, <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( <span class="hljs-number"><span class="hljs-number">-1</span></span> == bRet ) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( !TranslateAccelerator(hMainWnd, hAccel, &amp;msg) ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( !IsDialogMessage(hMainWnd, &amp;msg) ) { TranslateMessage(&amp;msg); DispatchMessage(&amp;msg); } } } <span class="hljs-comment"><span class="hljs-comment">// .... LRESULT CALLBACK WndProc(HWND hwnd, UINT umsg, WPARAM wparam, LPARAM lparam) { switch( umsg ) { case WM_MYMESSAGE: { HWND hDlg = CreateDialog(hInstance, MAKEINTRESOURCE(IDD_MYDIALOG), hwnd, MyDialogBoxProc); HACCEL hAccel = LoadAccelerators(hInstance, MAKEINTRESOURCE(IDR_ACCELERATOR_FOR_MY_DIALOG)); BOOL bRet = 0, fSavedEnabledState = IsWindowEnabled(hwnd); EnableWindow(hwnd, FALSE); // disable parent window, as dialog window is modal while (bRet = GetMessage(&amp;msg, nullptr, 0, 0)) { if ( -1 == bRet ) break; if ( !TranslateAccelerator(hDlg, hAccel, &amp;msg) ) { if ( !IsDialogMessage(hDlg, &amp;msg) ) { TranslateMessage(&amp;msg); DispatchMessage(&amp;msg); } } } EnableWindow(hwnd, fSavedEnabledState); // enable parent window. Dialog was closed break; } } } INT_PTR CALLBACK MyDlgProc(HWND hwnd, UINT umsg, WPARAM wparam, LPARAM lparam) { switch(umsg) { case WM_CLOSE: { // EndDialog( hwnd, 0 ); -- DONT DO THAT! // EndDialog is valid ONLY for Modal Dialogs, created with DialogBox(Param) DestroyWindow( hwnd ); break; } case WM_DESTROY: { PostQuitMessage( 0 ); break; } // .... } return 0; }</span></span></code> </pre><br>  Please note: now for each new window in our program we can add our <b>own</b> accelerator table to the processing.  WM_QUIT will grab GetMessage from the loop for the dialog, and the outer loop will not even see it.  Why it happens? <br><br>  The fact is that the outer loop "got up" on the call to DispatchMessage, which called our procedure, which rotates its own <i>inner</i> loop GetMessage with the same DispatchMessage.  Classic nested call (in this case, DispatchMessage).  Therefore, the outer loop will not receive WM_QUIT and will not end at this stage.  Everything will work slim. <br><br>  But there are some drawbacks here: <br>  Each such cycle will process messages <i>only for its own window</i> .  About others, we do not know here.  So, if another cycle appears somewhere, then all the other windows will not receive the necessary processing of their messages by the TranslateAccelerator / IsDialogMessage pair. <br><br>  Well, it's time to take into account all these comments and finally write the correct processing of all messages from all windows of our program.  I want to note that the case for one stream is considered below.  Since  each thread has its own message queue, then for each thread you have to create your own structures.  This is done by quite trivial changes in the code. <br><br><h3>  Make beautiful </h3><br>  Since  the correct formulation of the problem is half the solution, then you first need to correct this very task itself. <br><br>  First, it would be logical that only the <i>active</i> window receives messages.  Those.  for an inactive window, we will not broadcast accelerators and transmit messages to IsDialogMessage. <br><br>  Secondly, if the accelerator table is not set for the window, then there is nothing to broadcast, we will simply give the message to IsDialogMessage. <br><br>  Let's create a simple std :: map, which will map the window handle to the accelerator table handle.  Like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>&lt;HWND,HACCEL&gt; l_mAccelTable;</code> </pre> <br>  And as windows are created, we will add new windows to it with a handle to our favorite table (or zero if such processing is not required). <br><br>  Like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">BOOL </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddAccelerators</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(HWND hWnd, HACCEL hAccel)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( IsWindow( hWnd ) ) { l_mAccelTable[ hWnd ] = hAccel; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TRUE; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> FALSE; } <span class="hljs-function"><span class="hljs-function">BOOL </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddAccelerators</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(HWND hWnd, LPCTSTR accel)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> AddAccelerators( hWnd, LoadAccelerators( hInstance, accel ) ); } <span class="hljs-function"><span class="hljs-function">BOOL </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddAccelerators</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(HWND hWnd, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> accel)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> AddAccelerators( hWnd, MAKEINTRESOURCE( accel ) ); } <span class="hljs-function"><span class="hljs-function">BOOL </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddAccelerators</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(HWND hWnd)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> AddAccelerators( hWnd, HACCEL( <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> ) ); }</code> </pre><br>  Well, after closing the window to delete.  Like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DelAccel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(HWND hWnd)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>&lt;HWND, HACCEL&gt;::iterator me = l_mAccelTable.find( hWnd ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( me != l_mAccelTable.end() ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( me-&gt;second ) { DestroyAcceleratorTable( me-&gt;second ); } l_mAccelTable.erase( me ); } }</code> </pre><br>  Now, how to create a new dialog / window, call AddAccelerators (hNewDialog, IDR_MY_ACCEL_TABLE).  How to close: DelAccel (hNewDialog). <br><br>  We have a list of windows with the necessary descriptors.  We modify our main message loop a bit: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ... HWND hMainWnd = CreateWindow(...); AddAccelerators(hMainWnd, IDR_ACCELERATOR); BOOL bRet = 0; while (bRet = GetMessage(&amp;msg, nullptr, 0, 0)) { if ( -1 == bRet ) break; if ( !HandleAccelArray( GetActiveWindow(), msg ) ) { TranslateMessage(&amp;msg); DispatchMessage(&amp;msg); } } // ...</span></span></code> </pre><br>  Much better!  What is there in HandleAccelArray and why is there GetActiveWindow ()? <br><br>  A bit of theory: <br><br>  There are two functions that return the active window <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms633505(v%3Dvs.85).aspx">handle GetForegroundWindow</a> and <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms646292(v%3Dvs.85).aspx">GetActiveWindow</a> .  The difference of the first from the second is quite intelligibly described in the description of the second: <br><blockquote>  It is the queuing of the message queue.  Otherwise, the return value is NULL. </blockquote>  If the first one returns the handle of any window in the system, then the last one is the one <b>that uses the message queue of our stream</b> .  Since  we are only interested in the windows of our stream (which means those that will get into our message queue), then we take the last one. <br><br>  So, HandleAccelArray, guided by the handle transferred to it on the active window, searches for this window in our map, and if it is there, it sends this message to the translation into TranslateAccelerator, and then (if the first one did not see the right one) in IsDialogMessage.  If the last one did not process the message, then return FALSE to follow the standard TranslateMessage / DispatchMessage procedure. <br><br>  Looks like that: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">BOOL </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleAccelWindow</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">map</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;HWND,HACCEL&gt;::const_iterator mh, MSG &amp; msg)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> HWND &amp; hWnd = mh-&gt;first; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> HACCEL &amp; hAccel = mh-&gt;second; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( !TranslateAccelerator( hWnd, hAccel, &amp;msg ) ) { <span class="hljs-comment"><span class="hljs-comment">// message not for TranslateAccelerator. Try it with IsDialogMessage if ( !IsDialogMessage( hWnd, &amp;msg ) ) { // so, do default stuff return FALSE; } } // ok, message translated. Say to message-loop, to get next message return TRUE; } BOOL HandleAccelArray( HWND hActive, MSG &amp; msg ) { if ( !hActive ) return FALSE; // no active window. Nothing to do std::map&lt;HWND, HACCEL&gt;::const_iterator mh = l_mAccelTable.find( hActive ); if ( mh != l_mAccelTable.end() ) { // Got it! Try to translate this message for the active window return HandleAccelWindow( mh, msg ); } return FALSE; }</span></span></code> </pre> <br>  Now each child window has the right to add itself a favorite accelerator table and calmly catch and process WM_COMMAND with the necessary code. <br><br><h4>  And what about another line in the WM_COMMAND handler code? </h4><br>  The description in TranslateAccelerator reads as follows: <br><blockquote>  The wise parameter of the WM_COMMAND or the WM_SYSCOMMAND message contains the value of 1. </blockquote>  Usually the WM_COMMAND processing code looks like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>( HIWORD( wParam ) ) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> BN_CLICKED: <span class="hljs-comment"><span class="hljs-comment">// command from buttons/menus { switch( LOWORD( wParam ) ) { case IDC_BUTTON1: DoButton1Stuff(); break; case IDC_BUTTON2: DoButton2Stuff(); break; // ... } break; } }</span></span></code> </pre><br>  Now you can write this: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>( HIWORD( wParam ) ) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-comment"><span class="hljs-comment">// accelerator case BN_CLICKED: // command from buttons/menus { switch( LOWORD( wParam ) ) { case IDC_BUTTON1: DoButton1Stuff(); break; case IDC_BUTTON2: DoButton2Stuff(); break; // ... } break; } }</span></span></code> </pre><br>  And now, returning to the same fceux, adding <b>just one line</b> to the command processing code from the buttons, we get what we want: control the debager from the keyboard.  Just add a small wrapper around the main message loop and a new accelerator table with the necessary matches VK_KEY =&gt; IDC_DEBUGGER_BUTTON. <br><br>  <i>PS: Few people know, but you can create <a href="https://msdn.microsoft.com/ru-ru/library/windows/desktop/ms646365(v%3Dvs.85).aspx">your own accelerator table</a> , and now apply it directly on the fly.</i> <br><br>  <i>PPS: Because</i>  <i>DialogBox / DialogBoxParam turns its own cycle, then when you call a dialogue through them, accelerators will not work and our cycle (or cycles) will be "idle".</i> <br><br>  <i>PPPS: After calling HandleAccelWindow, the l_mAccelTable map may change, because</i>  <i>TranslateAccelerator or IsDialogMessage call DispatchMessage, and there can be AddAccelerators or DelAccel in our handlers!</i>  <i>Therefore, it is better not to touch it after this function.</i> <br><br>  Feel the code <a href="https://github.com/loginsinex/TestAccelUI">here</a> .  The basis was taken from the code generated from the standard template MS VS 2017. </div><p>Source: <a href="https://habr.com/ru/post/352096/">https://habr.com/ru/post/352096/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../352084/index.html">Marvin Minsky "The Emotion Machine": Chapter 2 "We want to create a machine that would be proud of us"</a></li>
<li><a href="../352086/index.html">Full list of intrinsic functions in HotSpot in JDK 7, 8, 9 and 10</a></li>
<li><a href="../352088/index.html">Inversion of control in iOS</a></li>
<li><a href="../352090/index.html">Alan Kay: How I would teach Computer Science 101</a></li>
<li><a href="../352092/index.html">Sample code organization for a complex Angular project</a></li>
<li><a href="../352098/index.html">What is the difference between product and product? Opinions of managers of Yandex services</a></li>
<li><a href="../352100/index.html">Wesbos tells how to use the new React Context API (subtitles)</a></li>
<li><a href="../352102/index.html">When in the accounting replaced the printer. "We must all reconnect"</a></li>
<li><a href="../352104/index.html">Aether Management Console: How to Deploy Corporate Security</a></li>
<li><a href="../352106/index.html">Some nuances of moving to Cyprus</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>