<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Texturing, or what you need to know to become an artist on surfaces. Part 4. Models, normals and sweep</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Models, normals and sweep 
 In my humble opinion, the texture artist should be responsible for the scan. Not for the scan itself (it should be done by...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Texturing, or what you need to know to become an artist on surfaces. Part 4. Models, normals and sweep</h1><div class="post__text post__text-html js-mediator-article"><h2>  Models, normals and sweep </h2><br>  In my humble opinion, the texture artist should be responsible for the scan.  Not for the scan itself (it should be done by 3D artists or even individual UV specialists), but its styling.  It must determine how the islands should be located, how they should be turned, and how much they can be pulled in a given situation, depending on the requirements. <br><br>  It is the texture artist (and later, on the surfaces) should determine the scale (scale) of the islands (more on that later). <br><br>  In this section, we consider models, sweep and normals.  Create textures for the first full-fledged model (albeit a simple one) and configure it in the Unreal Engine 4. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Attention.  It is assumed that by this time you have understood the normal map, and why it is needed.  Because in this tutor we will talk about it very often. <br><br>  <b>Part 1. Pixel</b> <a href="https://habr.com/ru/post/458342/">here</a> . <br>  <b>Part 2. Masks and textures are</b> <a href="https://habr.com/ru/post/458470/">here</a> . <br>  <b>Part 3. PBR and Materials</b> <a href="https://habr.com/ru/post/458696/">here</a> . <br>  <b>Part 4. Models, normals and sweep</b> - you read it. <br><a name="habracut"></a><br><h3>  Models and PBR.  Practice </h3><br>  I will not tell you how to create models or how to clean / build a grid.  This information can be obtained from a variety of courses that are both freely available and for a fee.  Our task now is to sort out the specific limitations in the structures of the models for games and what solutions there are at the moment. <br><br>  But first we will over texture the model, and for one look at it the first constraint.  We will work on this shop: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f69/836/6f5/f698366f526f3ddfb79bad00947b28b6.jpg" alt="image"><br><br>  To do this, we will need to download the mesh itself and the normal map prepared in advance for it (I will explain in more detail below why we prepared it).  Link <a href="https://1drv.ms/u/s!AixRcURcuiiag44XXWFtIxndmrEYwA%3Fe%3DRKN2Ek">here</a> . <br><br>  I would also like to make its base wooden, and its legs metal.  Well, a little mud to throw mud.  Accordingly, we will need 2 materials: <br><br><ol><li>  tree </li><li>  treated metal. </li></ol><br>  We will not put the dirt into a separate material, but use the generator in the Substance Painter and create the dirt inside the program. <br><br>  Let's start the practice and create a standard project, indicate the shop, textures and run it: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e15/86a/714/e1586a71474e80d115e811d25beec3a8.jpg" alt="image"><br><br>  Please note that this time we will need to specify the Normal Map Format - OpenGL.  I already wrote in the last part that normal maps are read in different ways by different programs.  And this card was generated for programs that use OpenGL. <br><br>  We had loaded 9 textures + main mesh. <br><br>  Now we will not make any layers and folders, but let's consider the shop as close as possible.  We are especially interested in the edges of the object: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/727/af3/c70/727af3c704cedafec83900006c2256bf.jpg" alt="image"><br><br>  I selected for example one side of the bench.  Now she is the most perfect.  That is, the two sides came together in one edge and created an ideal angle.  No matter how much we bring this joint, it will always be perfectly smooth.  In reality, the ideal angles do not exist, and even a razor blade with a proper increase will be rounded.  That is why the ribs look now not cinematic.  Such models look very weak, and when we see them in the game, we immediately feel all the weakness of the visual image, even if we don‚Äôt notice these angles in the models directly. <br><br>  <b>This is the first limitation of the model.</b> <br><br>  Previously, when video card resources did not allow processing millions of vertices in one frame, the solution was in the textures of normal maps.  They indicated how the light should begin to reflect so that it would appear as if these boundaries have a rounding.  Specifically to this shop, this normal map looks like this: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5cb/2fc/c42/5cb2fcc427286f1072b45110ec1d3f07.jpg" alt="image"><br><br>  Even just looking at a set of parameters in the form of this map, you can feel how the normal map will smooth out the corners. <br><br>  Now let's specify this normal map as the main map (that is, it will always be attached to the result, as the lowest layer without a mask).  To do this, we need to open the basic object texture settings and specify our texture in the parameters of the normal maps: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c3a/2f5/c63/c3a2f5c6337fe9291804e6254216f445.jpg" alt="image"><br><br>  And we look at the result: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d08/cb9/a5a/d08cb9a5a29f0990d91a42a8bdfe20b1.jpg" alt="image"><br><br>  This is the first most well-known and frequently used method of dealing with sharp edges - bake chamfer normal maps.  That is, the model is still tough, but the normal map at its faces begins to distort the light, which creates the illusion of a beautiful soft chamfer.  On the Internet you can find a lot of information on how to do it.  For simple objects like this bench, you can not make high-poly models (and not bake it accordingly), but generate a normal map with chamfers in the programs.  For example, the <a href="https://www.foundry.com/products/modo">Modo</a> program can do this.  Our bench has a normal map generated in Modo. <br><br>  But let's skip chamfering and continue texturing the bench. <br><br><div class="spoiler">  <b class="spoiler_title">If normals are concave</b> <div class="spoiler_text">  If your chamfers didn‚Äôt become as smooth as mine, and the hollows got an illusion, then when creating a project in Substance Painter you forgot to change the display format of the normal from DirectX to OpenGL. </div></div><br>  Now we will create 2 folders for layers, create and transfer them to each of the 1st layer and paste all texture maps into each layer.  Do not forget about naming, so as not to be confused: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/672/6ba/82a/6726ba82a6369f58c1341ac2d089c043.jpg" alt="image"><br><br>  Now the hierarchy of layers is not important to us, since these materials (metal and wood) will not intersect with each other - we will not have a situation when metal begins to appear through the tree and vice versa.  But we still need masks, so now we need to limit the visibility of layers on different islands, so now add black masks to both folders: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a9b/5f3/b9d/a9b5f3b9d35349d26e5f3acf7840a78e.jpg" alt="image"><br><br>  And now let us point out which islands of the scans we should have white on the masks, and which - black.  To do this, select the mask and switch to island selection mode: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/662/c0c/bbf/662c0cbbf97956bd3d2d53c6722bf465.jpg" alt="image"><br><br>  Click on the model on the main bench (if you select the tree mask) and get the following result: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3bd/69f/df3/3bd69fdf36b0a85114b1c30bc01cc245.jpg" alt="image"><br><br>  As you can see in the screenshot, the mask has been updated, and now there is a huge white stripe on it, which is located on the site of the island.  Thus paint the entire bench around: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f5e/343/42d/f5e34342def3e7b82f902c8bea142f52.jpg" alt="image"><br><br>  The material of the tree itself was not the most successful, but our goal now is not to make everything as beautiful as possible, but to understand the principles of work. <br><br>  Do the same with the mask for the metal, noting the visible area with the islands of the legs.  Select the metal mask and specify the desired parts of the object: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c3c/d23/30d/c3cd2330d1339b8dd9c8d64db51d4e7a.jpg" alt="image"><br><br>  It is also necessary to climb into hard-to-reach places at the joints and mark the islands we need for both wood and metal: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c3b/e07/7d9/c3be077d95c7c558702b0d7569500f0e.jpg" alt="image"><br><br>  If you carefully examine the legs, you will notice the <b>second limitation of the model</b> . <br>  The sweep is not done correctly, and the pattern of steel between the sides of the legs is not consistent - its texture is directed in different directions, which is visually striking (the direction is indicated by arrows): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8b7/f85/d23/8b7f85d2332ee1cc035c4790dc6d9f21.jpg" alt="image"><br><br>  This is precisely a limitation that can be overcome by leveling the islands and stretching them.  Now the island on which the down arrow is drawn looks like this (highlighted in orange): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/431/cdd/fc1/431cddfc156a2a123d627a1a0dab9965.jpg" alt="image"><br><br>  In order to correct the problem, it is necessary that the island be straightened in one line: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/24c/db2/d1c/24cdb2d1cce6fc886e0ec4222b48951e.jpg" alt="image"><br><br>  Then we will solve this restriction, but we will have something else - a tie: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/74f/984/0e6/74f9840e63c6a6cdf2b5e0e32ce9bb04.jpg" alt="image"><br><br>  Drawstrings are not terrible, if they are not very noticeable, or the texture on them does not give them out.  But you need to be careful with them, and sometimes you have to put up with the fact that there may be inconsistencies of materials. <br><br>  In general, the problem of seams in objects is still not fully resolved.  In the future, we will look at other options for how to get rid of seams and even try really cool methods in the next section. <br><br>  <b>Scuffs on the bench</b> <br><br>  As we know, on all faces of all things, sooner or later, paint, or pieces of material, begins to split off.  There appears a large number of scratches and chips: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bc2/196/cf0/bc2196cf08e525de6ccdeab05edbf780.jpg" alt="image"><br><br>  So let's create a mask that will allow us to later display the same scuffs, scratches and chips under it. <br><br>  To do this, open the settings for the main texture (where we specified the normal map), there choose <b>Bake Mesh Maps</b> . <br><br>  In the window that appears, remove all unnecessary checkmarks, leaving only the Curvature and bake it by clicking on <b>Bake [additional name] Mesh Maps</b> : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/afa/54a/7a8/afa54a7a846d6c0a50a04a92e4cf9cf9.jpg" alt="image"><br><br>  When the texture is finished, it will be available in the shelf under the Project tag: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/92d/05d/c1e/92d05dc1e4ed625363dec2463020edbe.jpg" alt="image"><br><br>  And also this texture will automatically connect as the main Curvature parameter in the texture settings.  Remove it from there: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5d0/d62/075/5d0d620753afa7926d429a99b4c014a5.jpg" alt="image"><br><br>  If we create a new layer at the top of the hierarchy and set the resulting texture as the Base Color parameter, we will see the following result: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b6d/e4d/31f/b6de4d31f360c6586083eb9d4dc8701d.jpg" alt="image"><br><br>  Now we will delete this layer, since we needed it only for understanding. <br><br>  Next, create a folder, name it Folder Dirt and place it in a folder with a tree OVER layer with a tree.  In this folder, create a layer called LowLayer_Dirt, and on the folder itself create a black mask so that the layer does not overlap the result: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a2b/e34/130/a2be34130bd13543b622fdb2484aec0b.jpg" alt="image"><br><br>  We point out that the mud mask should consist of Fill effects in order to add the texture we created (curvature) and the additional ‚ÄúLevels‚Äù effect. <br><br>  Why do we need the ‚ÄúLevels‚Äù effect now?  You probably noticed that the face mask is too light?  Now we will need to trim the colors in such a way as to leave light white places on the edges, and make everything else completely black. <br><br>  The end result you should get is this: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a69/027/375/a69027375f4a983b49a4a7315b823912.jpg" alt="image"><br><br>  In this way, we have created a " <b>boundary of what is permitted</b> " for dirt.  Now it is necessary to limit the dirt itself.  To do this, apply a black mask on the layer itself LowLayer_Dirt.  After that add the Fill effect, and in it specify the Dirt4 mask, which is hidden under the Procedurals tag: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/921/f36/e5f/921f36e5fa0f773c302ca0d31e0dc542.jpg" alt="image"><br><br>  Above, in the screenshot, additional parameters of the Dirt 4 mask are outlined. The fact is that this is not a texture in the format in which we are used to representing it.  This is a random number generator according to certain rules.  In other words, a procedural texture, the pixels in which have the generated intensity.  You can play with the parameters, for example, twist the Balance and Contrast to achieve the desired result. Now change the Height parameter in the LowLayer_Dirt layer to -0.35 and look at the result: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1e9/a39/3ec/1e9a393ecfea54e41e0d129027363194.jpg" alt="image"><br><br>  I repeat.  Now our goal is not to perfect the perfect painting shops, and work with the basics and training work with masks. <br><br>  <b>And now homework</b> <br><br>  In general, we have now considered how to quickly apply masks for specific materials that do not intersect with each other.  As you can guess, to apply varnish on the tree - we need to create a layer in the folder with the tree.  But now we will not do this, but the task itself remains for homework: <br><br><ul><li>  varnish the tree </li><li>  create scratches on the lacquer (those scratches that are only visible at an angle, because they push the varnish, but do not damage the wood) </li><li>  create scratches under the varnish </li></ul><br>  Throw in the comments of your crafts - I wonder the same =) <br><br>  <b>Total</b> <br><br>  <b>We deconstructed how to texture models using masks.</b>  <b>How to apply dirt, chips and scratches.</b> <br><br>  So that in the future you have a simple idea of ‚Äã‚Äãhow this all works, remember the rule - one material - one folder for working with it.  So you can better control your masks and layers.  For example, placing a layer of dirt in the folder with the material you still control at the level of the folder mask the total area of ‚Äã‚Äãvisibility of this material, and now also the dirt on it (or the layer under it).  For example, in reality, under the texture (material) there may be another texture - plastic can hide under the metal spraying.  In this case, metal is the main layer, and plastic is an additional layer under the metal (although in the tutor above we have a layer with chips and placed above the tree, in fact it is a lower layer in the hierarchy. In other words, this is an error). <br><br>  Layers of materials, their hierarchy must be calculated before you start creating textures.  This is important, because incorrect layouts of the layers can ultimately lead to the fact that you have to start all over again and spend long hours trying to figure out why your texture displays only the metal layer. <br><br>  In general, on this we close the big topic of how to texture objects for games within the PBR.  Everything else is technology.  My task is to tell the essence, the basis of all this, so that you will not have further questions like ‚ÄúWhat is the difference between the Roughness map and Metallic and Normal map?‚Äù  How to do better and more efficiently? ‚Äù <br><br>  <b>We have examined several constraints that have solutions.</b> <br><br><ul><li>  Chamfer constraint. </li><li>  Restriction with the location of the islands. </li></ul><br>  Both limitations can be bypassed in one way or another.  In the first case, we create a normal map that simulates a bend, in the second case, we pull the islands and sacrifice details (create pulls) for the sake of the overall picture. <br><br>  In the second case, it is also necessary to remember about the directions of the islands - they need to be deployed in a coordinated manner, as is the direction of the pattern in the materials.  Otherwise, there will be difficulties described above. <br><br><h3>  Scan </h3><br>  Put aside for a while in the direction of Substance Painter.  Do not close the project, it will come in handy later when we export textures to the Unreal Engine 4. <br><br>  In this piece of tutorials, we consider the scanning of objects, the density of islands, and finally study the phenomenon of texel density. <br>  And start with texel. <br><br>  <b>Texel</b> <br><br>  Texel is a texture pixel (ba-dum-s). <br><br>  <b>The density of texel and islands</b> <br><br>  In order not to confuse the monitor pixel (the physical element of the real world, which is always fixed in size) with the texture pixel (the rendered square, which can change its size on the monitor screen and be distorted as a whole), the texture pixel was called texel (Texture and pixel). <br><br>  There is a fairly complete article on this topic <a href="https://www.artstation.com/artwork/qbOqP">here</a> .  And the translation is <a href="https://1drv.ms/u/s!AixRcURcuiiag44kywCMaxjQA83ptQ%3Fe%3D5Wm453">here</a> . <br><br>  However, we will once again consider this phenomenon, because in the future, if we do not realize the whole idea of ‚Äã‚Äãtexels, then it will be difficult for us to work further.  And even more so it will be difficult to become an artist on surfaces. <br><br>  From this point on, we begin to speak correctly - pixel and texel.  Pixel - monitor element.  Texel is a textural element. <br><br>  So, we repeat the traversed, texel - this is the imaginary unit of information display.  It exists only in numbers (an array of numbers from various channels), but to make it easier for us to work with the render parameters, textures were introduced as a visual substitute for arrays of numbers.  I think no one would be pleased to paint a spaceship with numbers alone, keeping in mind the idea that texel in row 8 and column 453 should be 1 value less than texel in row 284 and column 112.  Simply poke a brush in Photoshop. <br>  Renders (visualization systems) read these numbers and display them as squares (texels).  Displaying a texel as a square is conditional.  And it depends in particular on the density and tension of the islands of the sweep model. <br><br>  We'll talk about the density of the sweep islands a little later, and now we will discuss the tension of the islands. <br><br>  Imagine a piece of cloth (if it is difficult to imagine - take any piece of cloth that can be stretched).  At rest, the drawing (or material pattern) on it remains unchanged, as the manufacturer intended.  But if we begin to stretch the fabric, then the pattern will also begin to stretch.  The same effect occurs when we stretch (or compress) the model sweep island: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f80/705/a7d/f80705a7d35ed2a9dcfb195a0287ae98.jpg" alt="image"><br><br>  A scan of the left and right side is arranged like this: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/804/b27/e58/804b27e58c57df8723355a0f181ababf.jpg" alt="image"><br><br>  The example shows that having compressed the representation (island) of the left side, we stretched the texels in such a way that they are now displayed on the left side of the cube in the form of rectangular elongated sticks.  That is, the texel on the object depends on how the scan of this object is performed.  Often in 3D-editors of objects it is possible to trace how strongly the island of sweep is compressed or stretched.  For example, in <b>Autodesk Maya,</b> it looks like this: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/88b/7ed/eb7/88b7edeb730aefee4b0eecb0571b5704.jpg" alt="image"><br><br>  Where red shows a strong compression, and blue - stretching. <br><br>  <b>Island density</b> <br><br>  Isle sweep should be properly cracked without creating screeds.  More islands must be scaled to each other.  That is, the area occupied by the island must correspond to the area of ‚Äã‚Äãthe other island.  Otherwise, it turns out that one island with a real area of ‚Äã‚Äã20 sq. Cm will occupy 20% of the area of ‚Äã‚Äãtextural space, and an island with a real area of ‚Äã‚Äã100 sq. Cm will occupy 5% of the area of ‚Äã‚Äãtextural space.  And from here there will be a disagreement in displaying the number of texels on the island: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/570/f3e/b57/570f3eb57afa711d7e4b6cf26ade2221.jpg" alt="image"><br><br>  The island on the right side of the cube is very small and is able to display only 25 texels, on which it is located.  In this regard, the render increases texels according to the area of ‚Äã‚Äãthe island, and we see large squares. <br><br>  On the left, the island is very large - it covers a large piece of textural space and can accommodate more texels, which is what happened on the screen.  The upper side has an average size. <br><br>  That is, in order for the model to be properly textured - it is necessary to level the area of ‚Äã‚Äãall the islands so that they are equal in relation to each other: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2b1/457/9af/2b14579af43e7cf3845f4bbc2147317d.jpg" alt="image"><br><br>  Above is a picture from the article by Habrochanin <a href="https://habr.com/ru/users/osmandos/" class="user_link">Osmandos</a> .  His article is <a href="https://habr.com/ru/post/315146/">here</a> .  Recommended to read. <br><br>  <b>Texture size</b> <br><br>  If we return to our cube, we will see that texels on it (black and white squares, in this example) are very large (again, by convention. Imagine that in the current texture the squares are texels).  Even if we align all the islands, we still see black and white squares on the sides of the cube: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/741/046/443/74104644386e47e3269121b082329066.jpg" alt="image"><br><br>  This tells us that the current texture size is not high enough, so we see texels.  But is it? <br><br>  Imagine that the current texture (it is usually called the ‚Äúchecker‚Äù - the texture for checking the correct settings of the islands) has a dimension of 63 by 63 texels.  And now we see these texels, because the object is so close to our camera that the size of one texel takes up an area of ‚Äã‚Äã30x30 pixels of the monitor (conventionally). <br><br>  And if we move the cube away from the camera? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/885/ace/1e8/885ace1e84d3225314f75d318067dbff.jpg" alt="image"><br><br>  Now try to see texels on this cube? <br><br>  Now 1 texel is 1 pixel in size (but this is not accurate).  And the size of such a texture is ideal, because it allows you to display all of your texels, and also does not display anything extra and does not hide anything extra.  This is the perfect size for this distance. <br>  That is, the size of the textures depends very much on the area that the model scan takes and on the object's distance from the camera.  If the object is located at a sufficiently large distance from us - it makes no sense to give it 8k textures on the nail.  Even if you make textures for the film - no one will simply see the white strip on the girl‚Äôs marigold, whose hand occupies 3% of the screen area. <br><br>  <b>Total</b> <br><br>  It is important to understand the scale of the models and where they will be located relative to the camera in order to correctly build the dimensions of the textures.  Very often, I saw games from indie developers who neglected these simple rules, and as a result, their textures were not of the best quality. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Do not forget to align the islands relative to each other - this is important and greatly affects the perception. </font><font style="vertical-align: inherit;">If you open, for example, the game Fallout 4 and start a dialogue with some the NPS, you will notice that the quality of the texture on the clothes of the character is poor, and the face has a maximum texture size: </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/b0b/1a7/75e/b0b1a775e52247ca8946546f9092a96f.jpg" alt="image"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It is worth remembering that the games are often specifically understate the size of textures in performance needs. </font><font style="vertical-align: inherit;">And who looks at clothes when a character has such an interesting face with scars?</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Large texture sizes take up a lot of space (in memory, I mean). </font><font style="vertical-align: inherit;">Therefore, many developers make a difficult decision - what to cut and what to leave, if only the game does not slow down on your PC / console / phone. </font><font style="vertical-align: inherit;">However, we will come back to this question and consider the newest techniques that allow us to avoid such troubles.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Texture baking </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What is texture baking? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Texture baking is when a texture package begins to calculate the final result and save it into separate files, with which the model in the game engine is then painted.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Roughly speaking, in Substance Painter we apply layers after layers through masks and other tricks to achieve the final result. We are working on how the final model should look like by mixing various materials. But, if you notice - the harder your combination of layers, masks and materials will be, the harder it will be to process your changes to the program. The fact is that Substance Painter (Any other program for texturing) checks your every change and calculates ALL of the layers and channels you create (and I remind you that you can also add your channels to the layers for anything and everything ), which falls on texel.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And when we are satisfied with the result and are ready to upload it to the game engine, we ask Substance Painter to do the last calculations and create a texture with the parameters for the color of each pixel, and 3 additional textures with the parameters Metallic, Roughness and Normal Map. This will allow us not to unload tons of masks and additional materials into the game, not to force the engine to calculate everything anew, but simply to provide it with the finished result, which it will convert into textures for the model.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In general, with baking textures, we figured out. However, we need to see how the parameters are uploaded to the textures, so that we know how we can control which texture channels go to which data will go. This is important because in the image standards there are still only 4 channels. And we need to be able to choose which channel will go to which parameters, so that we can quickly connect them later. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now go back to Substance Painter, in our project, and start unloading the textures. To do this, open the window of texture unloading (File - Export textures): </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/d2d/9ad/036/d2d9ad036103cc213efd167def4b7fa2.jpg" alt="image"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is how it looks initially. If we expand the set of textures, we will see a list of files that will be uploaded as export: </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/4fa/fe3/d4e/4fafe3d4e459411c87a292953d15d6a3.jpg" alt="image"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As you can see, there are 4 texture files that should be exported, against the 9 files that we downloaded.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But we are not interested in them, as the default settings, but we need our own personal ones (or according to the standard of the studio in which you work). Therefore, we will go to the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Configuration</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> window </font><font style="vertical-align: inherit;">: </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/a30/c73/8db/a30c738db622da9ad5615ef6af6fd465.jpg" alt="image"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">First, we will create new presets and select them in order not to knock down the already ready ones: </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/5a4/7dc/353/5a47dc353614367c1874af2e2a994aaa.jpg" alt="image"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now let's look at the panel on the right: </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/52e/596/d99/52e596d992106e0ad66e8690f2f9afaa.jpg" alt="image"><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Input Maps</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is the list of channels that we used. Most of them have names, as they are used for PBR for specific purposes. There are 8 channels (from 0 to 7) that are editable, but Substance Painter does not know why they can be useful to you, so the channels have standard User0 - User7 names. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Converted Maps</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- This is a list of textures that depend on the type of render. For example, Normal Map depends on the engine. And we need to know which API the DirectX or OpenGL engine uses to select the correct normal map for it. Therefore, the Substance Painter selects these cards in a separate category, since the final result will depend on what you choose. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mesh Maps</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - those textures that you downloaded along with the object or generated while working on it. We loaded 9 textures. 8 of them belonged to layers (materials), and the 9th normal map for chamfers already belonged directly to the object. In addition to the normal map, we also created a Curvature map for applying chips on it. These maps refer specifically to the object and cannot be used as a basis for materials, therefore they are listed in a separate list.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now let's take a look at the texture creation panel: </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/f7e/ce7/f8c/f7ece7f8c70004995cdfd3ea59bc38d8.jpg" alt="image"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">These are the buttons that, by clicking on which you create 1 texture file (more precisely, prepare everything to create it). </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gray</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - creates a texture with one channel. In this channel we can place any of our settings - Roughness, metallic, specular, emissive. All those settings that work in the same channel. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RGB</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - creates texture with 3 connected channels. That is, it is intended for parameters such as color (BaseColor), the normal map. That is, for all parameters that use 3 channels to fully realize themselves. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R + G + B</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- creates a texture with 3 unrelated channels. </font><font style="vertical-align: inherit;">That is, we have a texture with three Gray - channels. </font><font style="vertical-align: inherit;">We can specify a parameter with 1 channel in each channel of the texture separately. </font><font style="vertical-align: inherit;">This is often used for ORM - (Occlusion-Roughness-Metallic). </font><font style="vertical-align: inherit;">That is, Ambient Occlusion is stored in the first channel, Roughness is stored in the second, Metallic in the third. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RGB + A</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - you guessed it - 3 connected channels and 1 unrelated. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R + G + B + A</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - four unrelated channels. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now, knowing this, think about how many files we need to unload all the information about how the final texture should look for an object. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Right, at least 3 textures:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> RGB - BaseColor </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> R + G + B - ORM </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> RGB - Normal Map </font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Click on the textures you want one by one, and you‚Äôll have the following list: </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/e70/9d6/673/e709d6673ed3be2d90c065ceb31212f2.jpg" alt="image"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Do not forget to correctly name the textures, otherwise we won‚Äôt figure out what and where. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now we need to specify which parameters in which channels will be stored. </font><font style="vertical-align: inherit;">To do this, simply transfer the parameters from Input Maps to the desired channels. </font><font style="vertical-align: inherit;">The normal map needs to be transferred to DirectX, since the UE4 uses this format for reading normals. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As a result, we will have the following set: </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/567/aaa/078/567aaa07857405711eb92bfec2c9989b.jpg" alt="image"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now we switch back to Export. </font><font style="vertical-align: inherit;">We are there:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Specify the path where to save. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Select the presets we created in the Config parameters. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Select texture type - Targa. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Click Export. </font></font></li></ul><br><img src="https://habrastorage.org/getpro/habr/post_images/807/2f7/27e/8072f727e92abb8b498ee328e5d1b512.jpg" alt="image"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And voila - the export of textures was a success. </font><font style="vertical-align: inherit;">Open the BC (BaseColor) texture in Photoshop and look at it: </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/3b0/64b/cb6/3b064bcb6d06e64624e91cb1e27da4a2.jpg" alt="image"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Do you remember how we created 2 different materials in different layers? </font><font style="vertical-align: inherit;">Substance Painter folded all the layers, calculated the result of the final version of the texture that will cover the object, and ‚Äúbaked‚Äù all the texels exactly the way you disguised them. </font><font style="vertical-align: inherit;">He did the same with Normal Map, Roughness and Metallic. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If we open the ORM map in Photoshop, switch to the channel display mode and select the last one (blue), we will see a baked Metallic map: </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/2a4/cd2/7f0/2a4cd27f099f8b25c176a26af2ac7fec.jpg" alt="image"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">With this map you can imagine where the islands should be metal and where not metal.</font></font><br><br>  <b>Total</b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> We learned how to create ready-made textures for the game engine. </font></font><br><br>  Important.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now we have learned how to bake textures, making the whole calculation of creating these textures in the Substance Painter. That is, we did everything to get ready-made textures, which we can now use in different engines (with a reservation for processing some PBR parameters). The disadvantage of this approach - if we need to radically change something - we have to go back to the program and redo the textures.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To calculate how to correctly display the color and light from texel - the video card needs to be calculated for each texel. </font><font style="vertical-align: inherit;">And it will not depend on how many pixels you have on the monitor. </font><font style="vertical-align: inherit;">It will depend on how many texels are used in the formation of the texture (in the interest we use the standard settings, it means that we use 1024 * 1024 texels). </font><font style="vertical-align: inherit;">That is, in order to display the texture correctly, the pinter needs to count each pixel and take into account all the layers you have created. </font><font style="vertical-align: inherit;">This is a laborious task, so earlier (and even now) PBR textures were created mainly in texturing software.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Unreal Engine 4 </font></font></h3><br>  And lastly, unload our object in UE4 and see our result.  I will not describe how to open UE4, how to create a project, how to install it at all, and what buttons to press.  For this there are very good courses from <a href="https://habr.com/ru/users/flakky/" class="user_link">Flakky</a> .  Courses are all located on his website <a href="https://uengine.ru/">uengine.ru</a> . <br><br>  Now we consider only the import of our shop and the resulting textures, the creation of a primitive shader and summarize. <br><br>  To begin, open the project and create a folder ‚ÄúBench‚Äù in it, in which we drop all our textures and object.  To import all the textures - just transfer them from the browser to the project.  They are imported without any problems and will not be asked for any additional settings.  As for the object, when importing it, the Unreal Engine will ask you to specify some settings.  In general, you do not need to change anything, except for 2 parameters.  They must be disabled: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0bd/322/550/0bd322550ad9a0a66bb0fa88b986bb6d.jpg" alt="image"><br><br>  These parameters are responsible for the import of textures, and they are stored separately. <br><br>  As a result, in our folder there are 3 textures and 1 object: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7d0/41c/057/7d041c057a1722892d1a8c9807584398.jpg" alt="image"><br><br>  Now, in any free space in the project browser, click RMB and select Material: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/82a/c97/f78/82ac97f781092cd42b6cedcc0ef26b85.jpg" alt="image"><br><br>  Call it M_Bench. <br><br>  Open it and drag all our textures into it.  We get this picture: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/33c/6c7/e76/33c6c7e7688f83bc64afb1698dc37f37.jpg" alt="image"><br><br>  These are Nodes containers that allow you to visualize the settings so that even a novice can work with them conveniently (thank you so much for the successful implementation of Epic Games nodes. Without Blueprints systems and nodes in particular, many people would have burned heads from numbers and code).  White pins (outputs and entrances) on the textures (nodes on the left) indicate that three channels are being fed at once.  But the red, green and blue - each channel separately.  The last grayish is the alpha channel, but it is not in our textures, so we will not use this pin.  On the right is a large node that takes parameters, sums them up and creates a complete material. <br><br>  The whole principle of the textures in Substance Painter is used here (and in any other game engine) - you specify which parameters are necessary for what, and the program gives the result.  In this case, Substance Painter took over most of the calculations, while the Unreal Engine simply adds Painter's finished results and creates a ready-made shader (material) that can be applied to the shop. <br><br>  It only remains for us to correctly connect the pins and ask the engine to calculate the result for us: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/251/58f/4cb/25158f4cb4ff278b7cb401a5ee5e0ab1.jpg" alt="image"><br><br>  And why I did not stick a red channel from the ORM texture in Ambient Occlusion?  I have already mentioned that AO is considered obsolete, since AO is often calculated in real time.  And in the material node there is a pin Ambient Occlusion, but it does not work.  It is not even taken into account.  Left here for some reason.  I assume that a sufficiently large amount of work is required to remove it. <br><br>  So.  We have the simplest shader (material) ready, and we can finally paint our shop.  To do this, open the shop in UE4 by clicking on it 2 times.  And drag the material from the project browser into the material slot: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/eeb/97d/a15/eeb97da159b888969a435eb7a7752e44.jpg" alt="image"><br><br>  Here you go.  Now you have received your first finished object. <br><br>  You can see the result yourself, but I will only summarize. <br><br>  <b>Total</b> <br><br>  In a very simple form, we learned how to create the first shaders in the UE4 engine.  You ask - why is it called Material, and not the shader in the engine itself?  It's easier to explain what kind of texture construction format this is - this is the material that is superimposed on the object, and the object becomes beautiful.  But the possibilities of shaders are much more (much, hundreds of times more) than just showing textures. <br><br>  <b>Offtop.</b>  <b>Chamfer problem solving</b> <br><br>  Above, I identified the problem with chamfers and how to solve it.  But there is a second method, which we will not fully consider in this part - it is creating chamfers on the model and aligning the normals so that the surface of the mesh creates the illusion of a beautiful chamfer.  This chamfer is created by aligning the normals of vertices (tangents).  And this method is even more economical for performance than the method with normal maps, and its level of beauty is prohibitively high compared to conventional chamfer texturing.  Here is an example of a door that stands in one of our game projects (not yet announced): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8de/231/5fb/8de2315fbaa8ae9875629aba3c5a5179.jpg" alt="image"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/76e/d12/0ff/76ed120fff2043d22b59fef7791cde46.jpg" alt="image"><br><br>  I ran across information about this topic only on English-language resources.  <a href="https://polycount.com/discussion/154664/a-short-explanation-about-custom-vertex-normals-tutorial/p1">Here</a> <br><br>  The advantage of this method is that we create a beautiful chamfer, while the number of vertices does not increase much, as hard edges are always 2 vertex at one point, and soft edges are 1 vertex and the number increases drawing triangles: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f1d/019/a92/f1d019a928ef3031aaaab1e15585d3c1.jpg" alt="image"><br><br>  It is worth remembering that we need a normal object map in 99% of cases to create chamfers.  A normal map for materials and some individual elements is a slightly different topic. <br><br>  <b>Total</b> <br><br>  Oooooh.  Well, that part turned out to be big.  But she was needed to completely cover the topic of standard texturing.  And on this we can stop. <br><br>  Well, the truth is, we have gone from a barely noticeable pixel element on your monitor to complex schemes of masks that determine the visibility of equally complex layers of materials.  The word pixel is finally broken into two - texel and pixel.  And they learned how to bake it and connect it in the game engine.  At this step, you can draw a <b>long bold line</b> and say that we have become very real texture artists.  Everything else - the beauty of chips on objects, the cinematographic nature of the visual presentation - this is all the accumulation of time and the constant desire to learn new techniques and methods. <br><br>  You can watch more lessons and improve your skill.  For example, in Substance Designer there is a huge anvil of generators, having created which, you can use as their generators of layers.  And all those masks that were for mud, can no longer be created manually, but implemented at the level of functions that will do everything beautifully for you. <br><br>  We must always remember that we consider the range of values ‚Äã‚Äãfrom 0 to 1. This is important because standard textures have 8 bits per channel, and HDR textures have wider channels (16 bits or more), which means that the range of numbers there is much greater than 0 to 255. But this is still a range from 0 to 1. <br><br>  And it would seem that everything is the limit.  We have achieved a high level of understanding how textures are created.  You can just drop everything and go to work as a texture artist at any company that shares modeling and texturing (as we do, for example). <br><br>  But is it?  Have we really reached the limit in texturing and it won't work out any better? <br>  Or where to grow? <br><br>  Yes!  And we still have one more splint, which will lead texturing to a new technological leap and, in my humble opinion, will be the next generation of texturing. </div><p>Source: <a href="https://habr.com/ru/post/458988/">https://habr.com/ru/post/458988/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../458972/index.html">News of the week: Yandex and Western intelligence agencies, FAS is fighting online casinos, the Ministry of Transport regulates the work of BlaBlaCar</a></li>
<li><a href="../45898/index.html">Netbooks are no longer cheap?</a></li>
<li><a href="../458982/index.html">Nginx Recipes: Convert from HTML to PDF</a></li>
<li><a href="../458984/index.html">How to create the first application for trading on the exchange: 3 initial steps</a></li>
<li><a href="../458986/index.html">PostgreSQL Recipes: Convert from HTML to PDF</a></li>
<li><a href="../45899/index.html">Who performs system testing in your team?</a></li>
<li><a href="../458990/index.html">Stop zealous with comments in code</a></li>
<li><a href="../458992/index.html">Attention for dummies and implementation in Keras</a></li>
<li><a href="../458996/index.html">User Inyerface - how not to torment the user</a></li>
<li><a href="../459/index.html">CyberPlat.com - Project Manager for the Promotion of Companies Holding on the Internet</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>