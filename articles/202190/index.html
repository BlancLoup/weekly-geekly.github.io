<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Lock-free data structures. Inside Memory management circuits</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="As I mentioned in my previous notes, the main difficulties in implementing lock-free data structures are the ABA-problem and memory removal. I share t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Lock-free data structures. Inside Memory management circuits</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/26b/c1b/103/26bc1b1037a51443f9a7b13abf61d253.png" align="right"><br>  As I mentioned in my previous notes, the main difficulties in implementing lock-free data structures are the ABA-problem and memory removal.  I share these two problems, although they are related: the fact is that there are algorithms that solve only one of them. <br>  In this article I will give an overview of safe memory reclamation methods known to me for lock-free containers.  I will demonstrate the use of this or that method on Michael-Scott's classic lock-free queue [MS98]. <br><br><a name="habracut"></a><br><br><h1>  Tagged pointers </h1><br>  A <i>tagged pointers</i> scheme was proposed by IBM to solve an ABA problem.  Perhaps this is the first known algorithm for solving this problem. <br>  According to this scheme, each pointer is an indivisible pair of the actual address of the memory cell and its tag - a 32-bit integer. <br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">tagged_ptr</span></span></span><span class="hljs-class"> {</span></span> T * ptr ; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> tag ; tagged_ptr(): ptr(<span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>), tag(<span class="hljs-number"><span class="hljs-number">0</span></span>) {} tagged_ptr( T * p ): ptr(p), tag(<span class="hljs-number"><span class="hljs-number">0</span></span>) {} tagged_ptr( T * p, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n ): ptr(p), tag(n) {} T * <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>-&gt;() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ptr; } };</code> </pre> <br>  The tag acts as a version number and is incremented with each CAS operation on a labeled pointer and is <i>never reset</i> , that is, it increases strictly.  When removing an item from a container, instead of physically deleting an item, it should be placed on some free-list of free-list items.  In this case, it is quite acceptable if the remote element that is in the free-list is addressed: the structures are lock-free, so while one thread deletes the element X, another thread can have a local copy of the labeled pointer to X and access the fields of the element .  Therefore, the free-list must be separate for each type T, moreover, in many cases it is unacceptable to call the T data type destructor when placing the element in the free-list (due to parallel access - during the operation of the destructor another thread can read the data of this element). <br>  The tagged pointer scheme has the following disadvantages: <br><ul><li>  The scheme is implemented on platforms on which there is an atomic primitive CAS over a double word (dwCAS).  For 32-bit modern platforms, this requirement is met, since dwCAS works with 64-bit words, and all modern architectures have a full set of 64-bit instructions.  But for a 64-bit mode, a 128-bit (or at least 96-bit) dwCAS is required, which is not implemented on all architectures. <br><div class="spoiler">  <b class="spoiler_title">Yes, you wrote nonsense, my dear!</b> <div class="spoiler_text">  Particularly sophisticated in the lock-free may argue that to implement tagged pointers it is not necessary to have a wide 128-bit (or 96-bit) CAS.  You can get by with 64-bit if you consider that modern processors use only 48 bits for addressing, the older 16 bits of the address are free and can be used to store the counter-tag.  Well, indeed, they can.  This is done in <code>boost.lockfree</code> . <br>  In this approach, there are two "but": <br><ul><li>  Who guarantees that in the future these older 16-bit addresses will not be involved?  As soon as another breakthrough comes in the field of memory chips and its volume will increase by an order of magnitude, vendors will immediately release new processors with fully 64-bit addressing </li><li>  Is 16 bits enough to hold a tag?  Studies have been conducted on this score, and the result of these studies is this: 16 bits is not enough, overflow is quite possible, which could potentially lead to an ABA problem.  But 32 bits is enough. <br>  Indeed, 16 bits are tag values ‚Äã‚Äã0‚Äì65535. In modern operating systems, the time slice allocated to the stream is about 300‚Äì500 thousand assembly instructions (taken from the internal correspondence of linux developers), and with an increase in processor performance this quantum can only grow.  It turns out that for one quantum it is quite possible to perform 65 thousand even such heavy operations as CAS (well, if it is not possible today, it will be possible already tomorrow).  Thus, with a 16-bit tag, we are completely at risk of getting an ABA-problem. </li></ul><br></div></div><br></li><li>  The free-list implementation is a lock-free stack or a lock-free queue, which makes a negative contribution to performance: at least one more call to CAS when retrieving an item from the free-list and adding to it.  On the other hand, the presence of a free-list can contribute to an increase in productivity, since if the free-list is not empty, then you should not contact the system, usually quite slow and synchronized memory allocation functions. </li><li>  Having a separate free-list for <i>each</i> data type can be an unaffordable luxury for some applications, as it can lead to inefficient use of memory.  For example, if the lock-free queue on average contains 10 items, but at the peak its size can reach 1 million, then the size of the free-list after reaching the peak will consistently be about 1 million. Often this behavior is unacceptable. </li></ul><br>  Thus, the tagged pointer scheme is an example of an algorithm that solves only an ABA problem and does not solve the problem of <i>freeing</i> memory. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The <a href="http://libcds.sourceforge.net/">libcds</a> library currently does not use tagged pointers to implement lock-free containers.  Despite the relative simplicity, this scheme can lead to an uncontrolled increase in memory consumption due to the presence of a free-list for each container object.  In libcds, I focused on lock-free algorithms with predictable memory consumption, without using dwCAS. <br>  A good example of using the tagged pointers scheme is the <code>boost.lockfree</code> library. <br><br><h2>  Example tagged pointers </h2><br>  Lovers of sheets (if any) - pseudocode <code>MSQueue</code> [MS98] with tagged pointer.  Yes, lock-free algorithms are very verbose! <br>  For simplicity, I omitted the use of <code>std:atomic</code> . <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">node</span></span></span><span class="hljs-class"> {</span></span> tagged_ptr next; T data; } ; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MSQueue</span></span></span><span class="hljs-class"> {</span></span> tagged_ptr&lt;T&gt; <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> m_Head; tagged_ptr&lt;T&gt; <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> m_Tail; FreeList m_FreeList; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: MSQueue() { <span class="hljs-comment"><span class="hljs-comment">//  dummy node // Head &amp; Tail   dummy node m_Head.ptr = m_Tail.ptr = new node(); } }; void enqueue( T const&amp; value ) { E1: node * pNode = m_FreeList.newNode(); E2: pNode‚Äì&gt;data = value; E3: pNode‚Äì&gt;next.ptr = nullptr; E4: for (;;) { E5: tagged_ptr&lt;T&gt; tail = m_Tail; E6: tagged_ptr&lt;T&gt; next = tail.ptr‚Äì&gt;next; E7: if tail == m_Tail { // Tail    ? E8: if next.ptr == nullptr { //       E9: if CAS(&amp;tail.ptr‚Äì&gt;next, next, tagged_ptr&lt;T&gt;(node, next.tag+1)) { // ,    E10: break; } E11: } else { // Tail      //   tail    E12: CAS(&amp;m_Tail, tail, tagged_ptr&lt;T&gt;(next.ptr, tail.tag+1)); } } } // end loop //   tail    E13: CAS(&amp;m_Tail, tail, tagged_ptr&lt;T&gt;(pNode, tail.tag+1)); } bool dequeue( T&amp; dest ) { D1: for (;;) { D2: tagged_ptr&lt;T&gt; head = m_Head; D3: tagged_ptr&lt;T&gt; tail = m_Tail; D4: tagged_ptr&lt;T&gt; next = head‚Äì&gt;next; // Head, tail  next ? D5: if ( head == m_Head ) { // Queue   tail  ? D6: if ( head.ptr == tail.ptr ) { //  ? D7: if (next.ptr == nullptr ) { //   D8: return false; } // Tail     //   tail D9: CAS(&amp;m_Tail, tail, tagged_ptr&lt;T&gt;(next.ptr, tail.tag+1&gt;)); D10: } else { // Tail  //    CAS,    //  dequeue   next D11: dest = next.ptr‚Äì&gt;data; //   head D12: if (CAS(&amp;m_Head, head, tagged_ptr&lt;T&gt;(next.ptr, head.tag+1)) D13: break // ,    } } } // end of loop //   dummy node D14: m_FreeList.add(head.ptr); D15: return true; //  ‚Äì  dest }</span></span></code> </pre><br><img src="https://habrastorage.org/getpro/habr/post_images/aa8/a2f/260/aa8a2f26019d7ef75d3fd450ee39c16f.jpg" align="right"><br>  Let's look closely at the algorithms of operations enqueue and dequeue.  On their example, you can see several standard techniques when building lock-free structures. <br><br>  It immediately draws attention to the fact that both methods contain loops ‚Äî the entire substantive part of the operations is repeated until it succeeds (or successful execution is impossible, for example, <code>dequeue</code> from an empty queue).  Such ‚Äúslotting‚Äù with the help of a cycle is a typical method of lock-free programming. <br><br>  The first element in the queue (pointed to by <code>m_Head</code> ) is a dummy node.  The presence of a dummy element ensures that the pointers to the beginning and end of the queue will never be <code>NULL</code> .  A sign of void queue is the condition <code>m_Head == m_Tail &amp;&amp; m_Tail-&gt;next == NULL</code> (lines D6-D8).  The last condition ( <code>m_Tail-&gt;next == NULL</code> ) is significant, because in the process of adding to the queue we <i>do not change</i> <code>m_Tail</code> , the line E9 only changes <code>m_Tail-&gt;next</code> .  Thus, at first glance, the <code>enqueue</code> method violates the queue structure.  In fact, changing the tail of <code>m_Tail</code> occurs in another method and / or another thread: the <code>enqueue</code> operation <code>enqueue</code> for the addition of an element (line E8) that <code>m_Tail</code> points to the last element (that is, <code>m_Tail-&gt;next == NULL</code> ), and if it is not so, trying to move the pointer to the end (line E12);  similarly, the <code>dequeue</code> operation <code>dequeue</code> before performing its ‚Äúimmediate duties‚Äù if it does not indicate the end of the queue (line D9).  This shows us a common approach in lock-free programming - mutual aid flows ( <i>helping</i> ): the algorithm of one operation is ‚Äúsmeared‚Äù across all container operations and one operation relies heavily on the fact that its work will be completed by the next call (possibly another) of operation in ( possible) another thread. <br><br>  Another fundamental observation: the operations store in the local variables the values ‚Äã‚Äãof the pointers that they need to work (lines E5-E6, D2-D4).  Then (lines E7, D5) the values ‚Äã‚Äãjust read are compared with the originals - a typical lock-free technique, redundant for noncompetitive programming: the original values ‚Äã‚Äãmay change in the time since reading.  In order for the compiler not to optimize access to shared data of the queue (and too ‚Äúsmart‚Äù compiler is able to completely remove the E7 or D5 comparison lines), <code>m_Head</code> and <code>m_Tail</code> must be declared in C ++ 11 as <code>atomic</code> (in pseudocode - <code>volatile</code> ).  In addition, recall that the CAS primitive checks the value of the target address with the given one, and if they are equal, changes the data on the target address to a new value.  Therefore, a local copy of the current value should always be specified for a CAS primitive;  calling <code>CAS(&amp;val, val, newVal)</code> will <i>almost</i> always succeed, which is an error for us. <br><br>  Now let's see <i>when</i> <code>dequeue</code> is copied in the <code>dequeue</code> method (line D11): <i>before</i> removing an item from the queue (line D12).  Given that the elimination of an element (promotion of <code>m_Head</code> in line D12) can be unsuccessful, data copying (D11) can be repeated.  From the point of view of C ++, this means that the data stored in the queue should not be too complicated, otherwise the overhead of the assignment operator in line D11 will be too large.  Accordingly, under high load conditions, the probability of failure of the CAS primitive increases.  Attempting to ‚Äúoptimize‚Äù the algorithm by moving the string D11 outside the cycle limits will result in an error: the <code>next</code> element can be removed by another thread.  Since the queue implementation in question is based on the tagged pointer scheme, in which elements are never deleted, such an ‚Äúoptimization‚Äù will result in the fact that we can return <i>incorrect</i> data (not those that were in the queue at the time of successful execution of the D12 line). <br><div class="spoiler">  <b class="spoiler_title">M &amp; S Queue Feature</b> <div class="spoiler_text">  In general, the <code>MSQueue</code> algorithm <code>MSQueue</code> interesting in that <code>m_Head</code> always points to a dummy node, and the first element of a non-empty queue is the element following <code>m_Head</code> .  With <code>dequeue</code> value of the first element is read from a non-empty queue, that is, <code>m_Head.next</code> , the dummy element is deleted, and the next element, that is, the one whose value we return, becomes the new dummy element (and new head).  It turns out that physically removing an element is possible only <i>after the next</i> <code>dequeue</code> <i>operation</i> . <br>  This feature can cause a lot of trouble if you want to use the intrusive version of the <code>cds::intrusive::MSQueue</code> . <br></div></div><br><br><a name="EBR"></a><br><h2>  Epoch-based reclamation </h2><br>  Frazer [Fra03] proposed a scheme based on <i>epochs</i> .  Delayed deletion is applied at a safe point in time, when there is complete confidence that none of the threads have references to the deleted item.  This guarantee is provided by <i>eras</i> : there is a global epoch of <code>nGlobalEpoch</code> , and each thread operates in its own local epoch of <code>nThreadEpoch</code> .  When entering a protected epoch-based code, the local epoch of the stream is incremented if it does not exceed the global epoch.  Once all threads have reached the global era, <code>nGlobalEpoch</code> incremented. <br><br>  Pseudocode scheme: <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   static atomic&lt;unsigned int&gt; m_nGlobalEpoch := 1 ; const EPOCH_COUNT = 3 ; // TLS data struct ThreadEpoch { //    unsigned int m_nThreadEpoch ; //      List&lt;void *&gt; m_arrRetired[ EPOCH_COUNT ] ; ThreadEpoch(): m_nThreadEpoch(1) {} void enter() { if ( m_nThreadEpoch &lt;= m_nGlobalEpoch ) m_nThreadEpoch = m_nGlobalEpoch + 1 ; } void exit() { if (     ,   m_nGlobalEpoch ) { ++m_nGlobalEpoch ;  (delete)  m_arrRetired[ (m_nGlobalEpoch ‚Äì 1) % EPOCH_COUNT ]   ; } } } ;</span></span></code> </pre><br>  The released lock-free elements of the container are placed in the thread-local list of the elements to be deleted <code>m_arrRetired[m_nThreadEpoch % EPOCH_COUNT]</code> .  As soon as all the streams have passed through the global <code>m_nGlobalEpoch</code> epoch, all lists of all streams of the <code>m_nGlobalEpoch ‚Äì 1</code> epoch can be freed, and the global epoch itself can be incremented. <br><div class="spoiler">  <b class="spoiler_title">UPD 2016</b> <div class="spoiler_text">  UPD 2016: thanks to <a href="https://habrahabr.ru/users/perfhunter/" class="user_link">perfhunter</a> for pointing out the error in this pseudocode: <br><br><blockquote>  Please correct a small error in the article ‚ÄúLock-free data structures.  Inside  Memory management schemes ‚Äù- in the‚Äú Epoch-based reclamation ‚Äùsection, in the exit () function, you need to replace m_arrRetired [(m_nGlobalEpoch - 2)% EPOCH_COUNT] with m_arrRetired [(m_nGlobalEpoch - 1)% EPOCH_COUNT].  At this moment, the local epoch for threads can be either m_nGlobalEpoch (for those threads that have already entered enter (), or m_nGlobalEpoch + 1 (for streams that are again included in the critical section), and the generation of m_nGlobalEpoch - 1 can be safely released. <br></blockquote><br></div></div><br><br>  Each container lock-free operation is enclosed in calls to <code>ThreadEpoch::enter()</code> and <code>ThreadEpoch::exit()</code> , which is very similar to the critical section: <br><pre> <code class="cpp hljs">lock_free_op( ‚Ä¶ ) { get_current_thread()-&gt;ThreadEpoch.enter() ; . . . <span class="hljs-comment"><span class="hljs-comment">// lock-free  . //    ‚Äú ‚Äù epoch-based , //     ,     ,   //  . . . . get_current_thread()-&gt;ThreadEpoch.exit() ; }</span></span></code> </pre><br>  The scheme is quite simple and protects local links (that is, links inside container operations) to elements of lock-free containers.  The scheme cannot provide protection for global links (from outside container operations), that is, the concept of iterators over the lock-free container elements is not implemented with the help of an epoch based scheme.  The disadvantage of this scheme is that <i>all</i> program threads must go to the next epoch, that is, turn to some lock-free container;  if at least one stream does not enter the next epoch, the removal of deferred pointers will not occur.  If the priority of flows is not the same, low-priority flows can cause an uncontrolled growth of the list of deferred items for removal of high-priority flows.  Thus, an epoch-based scheme can lead (and in the case of the collapse of one of the threads, it will necessarily lead) to unlimited memory consumption. <br><br>  The libcds library has no implementation of an epoch-based scheme.  Reason: I did not manage to build a sufficiently effective algorithm for determining whether all flows reached the global era.  Perhaps some of the readers will recommend a solution? .. <br><br><a name="HP"></a><br><h2>  Hazard pointer </h2><br><img src="http://habrastorage.org/getpro/habr/post_images/927/aba/0b1/927aba0b1bfcb77049461c406eddb737.jpg" align="right"><br>  The scheme is proposed by Michael [Mic02a, Mic03] and is designed to protect <i>local</i> references to the lock-free elements of the data structure.  Perhaps, it is the most well-known and detailed scheme of pending removal.  It is based only on atomic reading and writing and does not use ‚Äúheavy‚Äù synchronization primitives like CAS at all. <br>  The cornerstone of the scheme is the obligation to declare a pointer to the lock-free element of the container as hazardous within the lock-free operation of the data structure, that is, before working with the pointer to the element, we must place it in the <code>HP</code> hazard-pointer array of the current stream.  The <code>HP</code> array is private to the stream: only the stream owner is written to it, all threads can read (in the <code>Scan</code> procedure).  If you carefully analyze the operations of different lock-free containers, you will notice that the size of the <code>HP</code> array (the number of hazard-pointers to one stream) does not exceed 3 to 4, so the overhead of supporting the scheme is small. <br><div class="spoiler">  <b class="spoiler_title">Giant data structures</b> <div class="spoiler_text">  To be fair, it should be noted that there are ‚Äúgiant‚Äù data structures that require more than 64 hazard pointers.  As an example, skip-list ( <code>cds::container::SkipListMap</code> ) is a probabilistic data structure, in fact, a list of lists, with a variable height of each element.  Such containers are not very suitable for the Hazard Pointer schema, although libcds has a skip-list implementation for this schema. <br></div></div><br><br>  Hazard Pointers [Mic02] pseudo code: <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//  // P :   // K :  hazard pointer    // N :   hazard pointers = K*P // R : batch size, RN=Œ©(N), , R=2*N // Per-thread : //  Hazard Pouinter  //     - //    void * HP[K] //   dlist ( 0..R) unsigned dcount = 0; //      void* dlist[R]; //   //     dlist void RetireNode( void * node ) { dlist[dcount++] = node; //    ‚Äì    Scan if (dcount == R) Scan(); } //   //     dlist,    //  Hazard Pointer void Scan() { unsigned i; unsigned p=0; unsigned new_dcount = 0; // 0 .. N void * hptr, plist[N], new_dlist[N]; // Stage 1 ‚Äì    HP   //    plist   for (unsigned t=0; t &lt; P; ++t) { void ** pHPThread = get_thread_data(t)-&gt;HP ; for (i = 0; i &lt; K; ++i) { hptr = pHPThread[i]; if ( hptr != nullptr ) plist[p++] = hptr; } } // Stage 2 ‚Äì  hazard pointer' //       sort(plist); // Stage 3 ‚Äì  ,    hazard for ( i = 0; i &lt; R; ++i ) { //  dlist[i]    plist  Hazard Pointer' //  dlist[i]    if ( binary_search(dlist[i], plist)) new_dlist[new_dcount++] = dlist[i]; else free(dlist[i]); } // Stage 4 ‚Äì     . for (i = 0; i &lt; new_dcount; ++i ) dlist[i] = new_dlist[i]; dcount = new_dcount; }</span></span></code> </pre><br><br>  When the <code>RetireNode(pNode)</code> of the <code>pNode</code> lock-free element is <code>pNode</code> stream <code>j</code> places <code>pNode</code> in a local (for stream <code>j</code> ) list of <code>dlist</code> deferred (to be deleted) elements.  As soon as the size of the <code>dlist</code> reaches <b>R</b> ( <b>R is</b> comparable to <code>N = P*K</code> , but more than <b>N</b> ; for example, <code>R = 2N</code> ), the <code>Scan()</code> procedure is called, which deals with the removal of deferred elements.  The condition <code>R &gt; P*K</code> is essential: only if this condition is met, it is guaranteed that <code>Scan()</code> will be able to remove something from the array of pending data.  If this condition is violated, <code>Scan()</code> can remove nothing from the array, and we get an algorithm error ‚Äî the array is completely filled, but it cannot be reduced. <br><br>  <code>Scan()</code> consists of four stages. <br><ul><li>  First, prepare a <code>plist</code> array of current hazard-pointers, which includes all non- <code>null</code> hazard-pointers of all streams.  Only the first stage reads shared data ‚Äî arrays of <code>HP</code> streams ‚Äî the remaining stages work only with local data. </li><li>  Stage 2 sorts the <code>plist</code> array to optimize the subsequent search;  here you can also remove <code>plist</code> elements from <code>plist</code> . </li><li>  Stage 3 - deletion itself: all elements of the <code>dlist</code> array of the current stream are viewed.  If the <code>dlist[i]</code> element is in <code>plist</code> (that is, some thread is working with this pointer, declaring it as a hazard pointer), it cannot be deleted and it remains in the <code>dlist</code> (transferred to <code>new_dlist</code> ).  Otherwise, the <code>dlist[i]</code> element can be deleted - not a single thread works with it. </li><li>  Stage 4 copies the undeleted items from <code>new_dlist</code> to <code>dlist</code> .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Since </font></font><code>R &gt; N</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, the procedure </font></font><code>Scan()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">will necessarily reduce the size of the array </font></font><code>dlist</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, that is, some elements will be necessarily removed.</font></font></li></ul><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Declaring a pointer as a Hazard Pointer is usually done as follows: </font></font><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::atomic&lt;T *&gt; atomicPtr ; ‚Ä¶ T * localPtr ; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { localPtr = atomicPtr.load(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::memory_order_relaxed); HP[i] = localPtr ; } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ( localPtr != atomicPtr.load(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::memory_order_acquire));</code> </pre><br>     <code>atomicPtr</code>    <code>localPtr</code> (    )     <code>HP[i]</code>  <code>HP</code> hazard-  .    ,   ,    <code>atomicPtr</code> ,       ,      <code>atomicPtr</code>        <code>localPtr</code> .     ,       <code>HP</code>  (    hazard)  <code>atomicPtr</code> .      Hazard Pointer' (    hazard),        ,               . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The Hazard Pointer scheme (HP scheme) is analyzed in detail from the point of view of atomic C ++ 11 operations and memory ordering in [Tor08]. </font></font><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MSQueue performed by Hazard Pointer</font></font></b> <div class="spoiler_text"> Lock-free  - [MS98]   Hazard Pointer.    ‚Äú‚Äù ,   libcds: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MSQueue</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">node</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::atomic&lt;node *&gt; next ; T data; node(): next(<span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>) {} node( T <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; v): next(<span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>), data(v) {} }; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::atomic&lt;node *&gt; m_Head; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::atomic&lt;node *&gt; m_Tail; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: MSQueue() { node * p = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> node; m_Head.store( p, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::memory_order_release ); m_Tail.store( p, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::memory_order_release ); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">enqueue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( T </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; data )</span></span></span><span class="hljs-function"> </span></span>{ node * pNew = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> node( data ); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { node * t = m_Tail.load(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::memory_order_relaxed); <span class="hljs-comment"><span class="hljs-comment">//    hazard. HP ‚Äì thread-private  HP[0] = t; //  ,  m_Tail  ! if (t != m_Tail.load(std::memory_order_acquire) continue; node * next = t-&gt;next.load(std::memory_order_acquire); if (t != m_Tail) continue; if (next != nullptr) { // m_Tail     //  m_Tail m_Tail.compare_exchange_weak( t, next, std::memory_order_release); continue; } node * tmp = nullptr; if ( t-&gt;next.compare_exchange_strong( tmp, pNew, std::memory_order_release)) break; } m_Tail.compare_exchange_strong( t, pNew, std::memory_order_acq_rel ); HP[0] = nullptr; //  hazard pointer } bool dequeue(T&amp; dest) { while true { node * h = m_Head.load(std::memory_order_relaxed); //  Hazard Pointer HP[0] = h; // ,  m_Head   if (h != m_Head.load(std::memory_order_acquire)) continue; node * t = m_Tail.load(std::memory_order_relaxed); node * next = h-&gt;next.load(std::memory_order_acquire); // head-&gt;next    Hazard Pointer HP[1] = next; //  m_Head  ‚Äì    if (h != m_Head.load(std::memory_order_relaxed)) continue; if (next == nullptr) { //   HP[0] = nullptr; return false; } if (h == t) { //   enqueue ‚Äì  m_Tail m_Tail.compare_exchange_strong( t, next, std::memory_order_release); continue; } dest = next-&gt;data; if ( m_Head.compare_exchange_strong(h, next, std::memory_order_release)) break; } //  Hazard Pointers HP[0] = nullptr; HP[1] = nullptr; //       //    . RetireNode(h); } };</span></span></code> </pre><br></div></div><br><br>    Hazard Pointer ?       <i></i>  ?   ,    , ‚Äî .  :  hazard pointer'   <b>K</b> .       ‚Äì   hazard pointer ‚Äì , ,   ,  hazard-   .   ,         hazard-.  ‚Äì    [Har01].           ,   HP- . <br>  , HP- <i></i>      hazard-.        ,   .    libcds    ,    ,  ,    HP-.     ,    ‚Äî <i>Pass the Buck</i> , ‚Äî     Hazard Pointer,         hazard-.     . <br><br><h3>  Hazard Pointer  libcds </h3><br><img src="http://habrastorage.org/storage3/7a0/4c3/cb2/7a04c3cb2cae3f8ccb8443d828f8acc7.png"><br><br>       hazard pointer  libcds.   ‚Äì <i>Hazard Pointer Manager</i> ‚Äî   ,    libcds.dll/.so.     ‚Äî  <i>Thread HP Manager</i> , ‚Äî      HP hazard pointer'  <b>K</b>    ()  <i>Retired</i>  <b>R</b> .   <i>Thread HP Manager</i>   .     <b>P</b> .    libcds: <br><ul><li>   hazard- <code>K = 8</code> </li><li>   <code>P = 100</code> </li><li>    (  )  <code>R = 2 * K * P = 1600</code> . </li></ul><br><br>  libcds HP-     : <br><ul><li> <i></i> ‚Äì         (  <code>cds::gc::hzp</code> ).      (    <code>T</code>  ),      .      ,         (   ,  ¬´¬ª ‚Äì     . ,    ‚Äì   -,   ‚Äì   ¬´    ¬ª.    ,   , ‚Äì   ). </li><li> <i> </i> ‚Äì   ,     <code>cds::gc::hzp</code> .       (template) - ,     (-   type erasure).        </li><li> <i>  (API)</i> ‚Äì  <code>cds::gc::HP</code> .  ,    ( )  lock-free  libcds, ,   ( ,      )  <code>GC</code>  .      <code>cds::gc::HP</code> ‚Äì           . </li></ul><br><div class="spoiler"> <b class="spoiler_title">   </b> <div class="spoiler_text">     ¬´¬ª  ,      , ,  ?  :         (, retired)   : <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">retired_ptr</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">typedef</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(* fnDisposer )</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * )</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> * ptr ; <span class="hljs-comment"><span class="hljs-comment">//   fnDisposer pDisposer; // - retired_ptr( void * p, fnDisposer d): ptr(p), pDisposer(d) {} };</span></span></code> </pre><br>     ( <i>retired</i> )     .  <code>Scan()</code> HP-  <code>pDisposer(ptr)</code>  ¬´¬ª . <br>  <code>pDisposer</code>    .        . ,      : <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">make_disposer</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dispose</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * p )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> <span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;T *&gt;(p); } }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">retire_ptr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( T * p )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  p   arrRetired     // ,  arrRetired ‚Äì    arrRetired.push( retired_ptr( p, make_disposer&lt;T&gt;::dispose )); //    ‚Äì  scan if ( arrRetired.full() ) scan(); }</span></span></code> </pre><br>    ,  ,  , . <br></div></div><br><br>        HP-   libcds,      <code>main()</code>   <code>cds::gc::HP</code>      ,  ,   HP-,     <a href="http://habrahabr.ru/company/ifree/blog/196834/"> </a> .  ,      ,   <code>cds::gc::HP</code> .      API HP-. <br><br><div class="spoiler"> <b class="spoiler_title">API  cds::gc::HP</b> <div class="spoiler_text">    <code>cds::gc::HP</code> ‚Äì ,  ,      . <br><ul><li>  Constructor <br><pre> <code class="cpp hljs">HP(<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> nHazardPtrCount = <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> nMaxThreadCount = <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> nMaxRetiredPtrCount = <span class="hljs-number"><span class="hljs-number">0</span></span>, cds::gc::hzp::scan_type nScanType = cds::gc::hzp::inplace);</code> </pre><br> <code>nHazardPtrCount</code> ‚Äì   hazard pointer' ( <b>K</b> ) <br> <code>nMaxThreadCount</code> ‚Äì    ( <b>P</b> ) <br> <code>nMaxRetiredPtrCount</code> ‚Äì   retired- ( <code>R = 2KP</code> ) <br> <code>nScanType</code> ‚Äì  :  <code>cds::gc::hzp::classic</code> ,       <code>Scan</code> ;  <code>cds::gc::hzp::inplace</code>    <code>Scan()</code>   <code>new_dlist</code>     <code>dlist</code> (    ). <br><br>  ,   <code>cds::gc::HP</code>    .         ,        <code>cds::gc::HP</code>       Hazard Pointer,     ,  ,  . <br></li><li>     retired ( )   <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Disposer</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">typename</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">static</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">retire</span></span></span><span class="hljs-class">( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class"> * </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">p</span></span></span><span class="hljs-class"> ) ;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">retire</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( T * p, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> (* pFunc)(T *) )</span></span></span></span></code> </pre><br>  <code>Disposer</code> ( <code>pFunc</code> )    ().      : <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class"> {</span></span> ‚Ä¶ }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fooDisposer</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Foo * p )</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> p; } }; <span class="hljs-comment"><span class="hljs-comment">//   myDisposer    Foo Foo * p = new Foo ; cds::gc::HP::retire&lt;fooDisposer&gt;( p );</span></span></code> </pre><br></li><li><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">force_dispose</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>;</code> </pre><br>    <code>Scan()</code>  Hazard Pointer.  ,       ,    libcds   . <br></li></ul><br>  ,   <code>cds::gc::HP</code>    : <br><ul><li> <code>thread_gc</code> ‚Äì           (thread data),    Hazard Pointer.     ,   HP-  ,  ,     </li><li> <code>Guard</code> ‚Äì  hazard pointer </li><li> <code>template &lt;size_t Count&gt; GuardArray</code> ‚Äì  hazard pointer'.   HP-      hazard- .       ,      <code>Guard</code> </li></ul><br>  <code>Guard</code>  <code>GuardArray&lt;N&gt;</code>       Hazard Pointer,   .        . <br><br>  <code>Guard</code>  hazard-    API: <br><ul><li><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">protect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( CDS_ATOMIC::atomic&lt;T&gt; </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; toGuard )</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Func</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">protect</span></span></span><span class="hljs-class">( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CDS_ATOMIC</span></span></span><span class="hljs-class">:</span></span>:atomic&lt;T&gt; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; toGuard, Func f );</code> </pre><br>    ( <code>T</code> ‚Äì  )  hazard.     ,    :     <code>toGuard</code> ,  hazard pointer'   ,     . <br>   (  <code>Func</code> ) ,      hazard     <code>T *</code> ,      .    ,        (node),          (, <code>node</code>   <i></i>  ).  <code>Func</code>   : <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">functor</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-function">value_type * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( T * p )</span></span></span><span class="hljs-function"> </span></span>; };</code> </pre><br>    ,     hazard. <br></li><li><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-function">T * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">assign</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( T * p )</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Bitmask&gt; <span class="hljs-function"><span class="hljs-function">T * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">assign</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( cds::details::marked_ptr&lt;T, Bitmask&gt; p )</span></span></span></span>;</code> </pre><br>     p  hazard. ,    <code>protect</code> ,   , ‚Äî <code>p</code>    hazard-. <br>     <i></i>  <code>cds::details::marked_ptr</code> .  marked-   2-3  (  0   )     , ‚Äî     lock-free .     hazard-      (  <code>Bitmask</code> ). <br>   ,     hazard. <br></li><li><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-function">T * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>;</code> </pre><br>    hazard-.    . <br></li><li><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">copy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Guard </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; src )</span></span></span></span>;</code> </pre><br>   hazard-  <code>src</code>  <code>this</code> .    hazard-      . <br></li><li><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">clear</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>;</code> </pre><br>   hazard-.       <code>Guard</code> . <br></li></ul><br>  <code>GuardArray</code>   API,      : <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">protect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> nIndex, CDS_ATOMIC::atomic&lt;T&gt; </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; toGuard )</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Func</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">protect</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">size_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">nIndex</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CDS_ATOMIC</span></span></span><span class="hljs-class">:</span></span>:atomic&lt;T&gt; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; toGuard, Func f ) <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-function">T * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">assign</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> nIndex, T * p )</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Bitmask&gt; <span class="hljs-function"><span class="hljs-function">T * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">assign</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> nIndex, cds::details::marked_ptr&lt;T, Bitmask&gt; p )</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">copy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> nDestIndex, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> nSrcIndex )</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">copy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> nIndex, Guard </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; src )</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-function">T * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> nIndex)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">clear</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> nIndex)</span></span></span></span>;</code> </pre><br><br>     <code>CDS_ATOMIC</code> ‚Äì  ? <br>  ,      <code>std::atomic</code> .    ( ) C++11 <code>atomic</code> ,  <code>CDS_ATOMIC</code>  <code>std</code> .    ‚Äì  <code>cds::cxx11_atomics</code> ,  ,     libcds-  atomic.    libcds    <code>boost.atomic</code> ,  <code>CDS_ATOMIC</code>   <code>boost</code> . <br></div></div><br><br><h1> Hazard Pointer with Reference Counter </h1><br><img src="http://habrastorage.org/storage3/036/678/6e4/0366786e4530108f26e3ae9b8551bbad.jpg" align="right"><br>   Hazard Pointer  ,           lock-free .  , , ,    ,    :          hazard-. <br><div class="spoiler"> <b class="spoiler_title"></b> <div class="spoiler_text">   ,   HP-   .    -     HP-,   .      ,    (,  hazard-     ).   ,     hazard-,   ,        HP-  . <br><br>   ‚Äî    ¬´,   ,  ¬ª.   ,    ‚Äî  ,    .   ,   . <br></div></div><br>    ,    ,       (reference counting, RefCount).   Valois ‚Äì    lock-free  ‚Äî           .  RefCount-   ,    ‚Äì     ,      .  ,     RefCount-,    lock-free      fetch-and-add (,  <i></i>        ,   ‚Äì ). <br>       2005   [GPST05],    Hazard Pointer  RefCount :  Hazard Pointers         lock-free  ,   RefCount ‚Äì         .      HRC (Hazard pointer RefCounting). <br>  Hazard Pointers      /         ,     RefCounting-  .   ,          (-         , . [GPST05]).   Hazard Pointers         <i></i> lock-free ,  HRC        : <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CleanUpNode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Node * pNode)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TerminateNode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Node * pNode)</span></span></span></span>;</code> </pre><br>  <code>TerminateNode</code>    <code>pNode</code>      .  <code>CleanUpNode</code>   ,   ,   <code>pNode</code>    ¬´¬ª (   )   ,  ()    ;      RefCount-     ,   ,  <code>CleanUpNode</code>       : <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CleanUpNode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Node * pNode)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (all x where pNode-&gt;link[x] of node is reference-counted) { retry: node1 = DeRefLink(&amp;pNode-&gt;link[x]); <span class="hljs-comment"><span class="hljs-comment">//  HP if (node1 != NULL and !is_deleted( node1 )) { node2 = DeRefLink(node1-&gt;link[x]); //  HP //  ,       //    node1 CompareAndSwapRef(&amp;pNode-&gt;link[x],node1,node2); ReleaseRef(node2); //  HP ReleaseRef(node1); //  HP goto retry; //       ,   } ReleaseRef(node1); //  HP } }</span></span></code> </pre><br>      lock-free         (      C++)    HRC      lock-free  . , ,   <code>CleanUpNode</code>      ,       <i> </i> ,       .  lock-free ,     ,     MultiCAS       . <br>  ,    Hazard Pointers ,     .        <code>Scan</code>  Hazar Pointers (  ,        <code>CleanUpNode</code> ).     :    Hazard Pointers   ( <code>R &gt; N = P * K</code> ),   <code>Scan</code>   - (       ,   hazard-),    HRC   <code>Scan</code>    -       (  ‚Äì   ). ,    <code>Scan</code> ,    <code>CleanUpAll</code> :                 <code>CleanUpNode</code> ,       <code>Scan</code> . <br><div class="spoiler"> <b class="spoiler_title"> HRC-  libcds</b> <div class="spoiler_text"> UPD (2016 ):   libcds 2.0.0  HRC-      (   ,  ),   - ,             Hazard Pointer. <br><br>  libcds HRC-     HP-.   ‚Äì <code>cds::gc::HRC</code> . API     API <code>cds::gc::HP</code> .     namespace <code>cds::gc::hrc</code> . <br>   HRC- ‚Äì     ‚Äì    libcds.         ,           lock-free .        ,    ,     <i></i>   .   ‚Äì   ‚Äì  lock-free      :   -,  ,    .  ,      ,     HP-      ,      , ‚Äî       lock-free . <br>  , HRC-   libcds     HP-.     ,     ( )  HP-:    HRC-    2-3  ,  HP-.    ¬´¬ª,    :    -   <code>Scan</code> (, -  )    <code>CleanUpAll</code> ,    retired-. <br>   HRC-   libcds   HP-like ,       .      HRC-  HRC-based  HP-based       . <br></div></div><br><br><h1> Pass the Buck </h1><br><img src="http://habrastorage.org/storage3/879/42b/ca6/87942bca66df25ea999b60b4c7a8b302.jpg" align="right"><br>       lock-free  , Herlihy &amp; al   <i>Pass-the-Buck</i> (PTB,  ‚Äú ‚Äù) [HLM02, HLM05],      HP- .,      . <br>  ,   HP-, PTB-     (guarded,  hazard pointer  HP-). PTB-        (  hazard pointer').        (retired)    <code>Liberate</code> ‚Äî  <code>Scan</code>  HP-. <code>Liberate</code>   ,    .    HP-,   retired-    ,  PTB-          . <br>   guard' (hazard pointer'):       ,     retired-,   <i>hand-off</i> (‚Äú ‚Äù).      <code>Liberate</code> ,   retired-         guard',    retired-   hand-off guard'.    <code>Liberate</code> hand-off    ,  guard,    , ,         . <br><br>   [HLM05]     <code>Liberate</code> : wait-free  lock-free. Wait-free   dwCAS (CAS   ),       dwCAS   . Lock-free   ,       .   (guard'  retired-)     lock-free  <code>Liberate</code> ,   (,      retired-,        ).       ,     PTB-  ,     <code>Liberate</code> . <br><br>       ,     <code>Liberate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PTB-scheme, making it similar to the HP-scheme. </font><font style="vertical-align: inherit;">As a result, the implementation of PTB in libcds has become more similar to the variant of the HP scheme with an arbitrary number of hazard-pointers and a single array of retired-data. </font><font style="vertical-align: inherit;">This affected the performance slightly: a ‚Äúclean‚Äù HP scheme is still slightly faster than PTB, but PTB may be preferable due to the lack of restrictions on the number of guards.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Implementation in libcds</font></font></b> <div class="spoiler_text"> UPD (2016 ):   libcds 2.0.0     <code>cds::gc::DHP</code> ‚Äî  HP, ‚Äî       pass-the-buck    , ‚Äî   Hazard Pointer     . <br><br>   libcds PTB-   <code>cds::gc::PTB</code> ,     namespace <code>cds::gc::ptb</code> . API  <code>cds::gc::PTB</code>   <code>cds::gc:::HP</code> ,    .    : <br><pre> <code class="cpp hljs">PTB( <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> nLiberateThreshold = <span class="hljs-number"><span class="hljs-number">1024</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> nInitialThreadGuardCount = <span class="hljs-number"><span class="hljs-number">8</span></span> );</code> </pre><br><ul><li> <code>nLiberateThreshold</code> ‚Äî   <code>Liberate</code> .     retired-   ,  <code>Liberate</code> </li><li> <code>nInitialThreadGuardCount</code> ‚Äî   quard'    (,       libcds).      guard'    </li></ul><br></div></div><br><br><h1>  Conclusion </h1><br>          safe memory reclamation,       Hazard Pointer. HP-            lock-free  . <br><br>        lock-free  .      libcds,      ,    (attach)            <code>GC</code>    libcds.  ,  <code>Scan()</code> / <code>Liberate()</code>  . ‚Äî       . <br><br>        ‚Äî RCU,   HP-like , ‚Äî          . <br><br> UPD 2016:  <a href="https://habrahabr.ru/users/errandir/" class="user_link">Errandir</a>     ,    Hazard Pointer (     HP). <br><br><div class="spoiler"> <b class="spoiler_title"></b> <div class="spoiler_text"> [Fra03] Keir Fraser <a href="http://www.cl.cam.ac.uk/techreports/UCAM-CL-TR-579.pdf">Practical Lock Freedom</a> , 2004; technical report is based on a dissertation submitted September 2003 by K.Fraser for the degree of Doctor of Philosophy to the University of Cambridge, King's College <br><br> [GPST05] Anders Gidenstam, Marina Papatriantafilou, Hakan Sundell, Philippas Tsigas <a href="http://www.non-blocking.com/download/GidPST05_LockFreeGC_TR.pdf">Practical and Efficient Lock-Free Garbage Collection Based on Reference Counting</a> , Technical Report no. 2005-04 in Computer Science and Engineering at Chalmers University of Technology and Goteborg University, 2005 <br><br> [Har01] Timothy Harris <a href="http://research.microsoft.com/pubs/67089/2001-disc.pdf">A pragmatic implementation of Non-Blocking Linked List</a> , 2001 <br><br> [HLM02] M. Herlihy, V. Luchangco, and M. Moir <a href="http://cs.brown.edu/~mph/HerlihyLM02/smli_tr-2002-112.pdf">The repeat offender problem: A mechanism for supporting <br> dynamic-sized lockfree data structures</a> Technical Report TR-2002-112, Sun Microsystems <br> Laboratories, 2002. <br><br> [HLM05] M.Herlihy, V.Luchangco, P.Martin, and M.Moir <a href="http://secs.ceas.uc.edu/~paw/classes/ece975/sp2010/papers/herlihy-05.pdf">Nonblocing Memory Management Support for Dynamic-Sized Data Structure</a> , ACM Transactions on Computer Systems, Vol. 23, No. 2, May 2005, Pages 146‚Äì196. <br><br> [Mic02] Maged Michael <a href="http://www.research.ibm.com/people/m/michael/podc-2002.pdf">Safe Memory Reclamation for Dynamic Lock-Free Objects Using Atomic Reads and Writes</a> , 2002 <br><br> [Mic03] Maged Michael <a href="http://www.research.ibm.com/people/m/michael/ieeetpds-2004.pdf">Hazard Pointers: Safe Memory Reclamation for Lock-Free Objects</a> , 2003 <br><br> [MS98] Maged Michael, Michael Scott <a href="http://www.cs.rochester.edu/u/scott/papers/1996_PODC_queues.pdf">Simple, Fast and Practical Non-Bloking and Blocking Concurrent Queue Algorithms</a> , 1998 <br><br> [Tor08] Johan Torp <a href="http://www.johantorp.com/parallelism08_cpp_mm.pdf">The parallelism shift and C++'s memory model</a> , chapter 13, 2008 <br></div></div><br><br><div class="spoiler"> <b class="spoiler_title">Lock-free  </b> <div class="spoiler_text">  <a href="http://habrahabr.ru/company/ifree/blog/195770/">Start</a> <br> : <br><ul><li> <a href="http://habrahabr.ru/company/ifree/blog/195948/">   </a> </li><li> <a href="http://habrahabr.ru/company/ifree/blog/196548/">    </a> </li><li> <a href="http://habrahabr.ru/company/ifree/blog/197520/"> </a> </li></ul><br> : <br><ul><li> <a href="http://habrahabr.ru/company/ifree/blog/202190/">  </a> </li><li> <a href="http://habrahabr.ru/company/ifree/blog/206984/">RCU</a> </li><li> <a href="http://habrahabr.ru/company/ifree/blog/216013/"> </a> </li><li> <a href="http://habrahabr.ru/company/ifree/blog/219201/"> </a> </li><li> <a href="http://habrahabr.ru/post/230349/"> </a> </li><li> <a href="http://habrahabr.ru/post/250383/">Concurrent maps: </a> </li><li> <a href="http://habrahabr.ru/post/250523/">Concurrent maps: rehash, no rebuild</a> </li><li>  <a href="http://habrahabr.ru/post/250815/">Concurrent maps: skip list</a> </li><li> <a href="https://habrahabr.ru/post/251267/">Concurent maps: </a> </li><li>  <a href="https://habrahabr.ru/post/314948/">Iterators: multi-level array</a> </li><li> <a href="https://habrahabr.ru/post/317882/">Iterable list</a> </li></ul><br> : <br><ul><li> <a href="http://habrahabr.ru/company/ifree/blog/196834/">  libcds</a> </li></ul><br></div></div></div><p>Source: <a href="https://habr.com/ru/post/202190/">https://habr.com/ru/post/202190/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../202180/index.html">The Smithsonian Institution digitizes its exhibits by sharing 3D models</a></li>
<li><a href="../202182/index.html">The first stable version of the JVM-language from RedHat - Ceylon</a></li>
<li><a href="../202184/index.html">Airplane debugging? It is very easy!</a></li>
<li><a href="../202186/index.html">Remembering the past. About what they did 5 years ago</a></li>
<li><a href="../202188/index.html">HTML Purifier. Expanding opportunities</a></li>
<li><a href="../202192/index.html">Google won an 8-year lawsuit: now the Google Books project is free from the claims of the Authors Guild</a></li>
<li><a href="../202194/index.html">Chinese Hackspace: Chaihuo Make Space</a></li>
<li><a href="../202196/index.html">Samsung MultiScreen SDK beta</a></li>
<li><a href="../202202/index.html">Overview of Drupal Learning Materials</a></li>
<li><a href="../202204/index.html">How I trusted my intuition and was very stubborn</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>