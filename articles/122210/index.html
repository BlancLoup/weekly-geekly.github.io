<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Examining JOIN Performance in MySQL</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I think it‚Äôs no secret that JOIN is considered to be a rather expensive operation, and many novice programmers (who use MySQL) like to be intimidated,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Examining JOIN Performance in MySQL</h1><div class="post__text post__text-html js-mediator-article">  I think it‚Äôs no secret that JOIN is considered to be a rather expensive operation, and many novice programmers (who use MySQL) like to be intimidated, that JOIN is bad, and it‚Äôs best to do without them, if possible. <br><br>  Let's explore this issue in more detail and see if a JOIN is really bad, and when you should think about it at all. <br><a name="habracut"></a><br><h4>  What I will not write </h4><br>  To begin, I would like to immediately say that I will not do: <br><br>  - MySQL tuning: all settings are taken by default ( <font color="gray">including innodb_buffer_pool_size = 8 MB, etc.</font> ) <br>  - integration with programming languages: <font color="gray">all requests will be made via the MySQL <a href="http://www.sequelpro.com/">Sequel Pro</a> client, and time will be measured based on its readings</font> <br>  - obvious things, like joining when sampling 3 lines: <font color="gray">I don‚Äôt want to consider saving on matches, or not - we‚Äôll consider saving ten times rather than tens of percent</font> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Initial conditions </h4><br>  We will have two simple disgraceful <font color="gray">tables</font> (the <font color="gray">tables were made just for example and filled with random data</font> ): <br><br>  <b>Calls</b> - 10 million lines: <br><table><tbody><tr><td>  id </td><td>  INT PRIMARY KEY AUTO_INCREMENT </td></tr><tr><td>  user_id </td><td>  Int </td></tr><tr><td>  cost </td><td>  Int </td></tr><tr><td>  call_dt </td><td>  DATETIME </td></tr><tr><td>  tariff_id </td><td>  Int </td></tr></tbody></table><br>  <b>Users</b> - 100 thousand lines: <br><table><tbody><tr><td>  id </td><td>  INT PRIMARY KEY AUTO_INCREMENT </td></tr><tr><td>  birthdate </td><td>  DATE </td></tr><tr><td>  name </td><td>  VARCHAR (10) </td></tr><tr><td>  sex </td><td>  ENUM ('M', 'F') </td></tr></tbody></table><br><br>  The names, I think, speak for themselves, the indexes are only on the primary key (id).  Purely in principle, we could create some indexes that would help us fulfill those queries that we will explore, but our goal is different, namely, to investigate how fast the JOIN works. <br><br><h4>  Table types </h4><br>  For the purposes of the study, the <b>Calls</b> table was taken in two types - MyISAM and InnoDB, and the <b>Users</b> table, to which we are joining, three types - MyISAM, InnoDB and MEMORY <br><br><h4>  First blood </h4><br>  All tests were performed on my laptop, from MySQL version 5.5.9 on Mac OS X with default settings from MAMP.  All tables fit into memory completely, requests were run several times to make sure that everything gets into the cache. <br><br>  To begin with, let's just look at the speed of browsing rows in MyISAM and InnoDB by running such a query (remember that there are no indexes for price or user_id - we measure the speed of FULL SCAN in MySQL) <br><br><pre><code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">MAX</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">cost</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> calls <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> user_id = <span class="hljs-number"><span class="hljs-number">5000</span></span>; <span class="hljs-comment"><span class="hljs-comment">--  ‚Ññ1</span></span></code> </pre> <br>  And such a request: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">MAX</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">cost</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> calls; <span class="hljs-comment"><span class="hljs-comment">--  ‚Ññ2</span></span></code> </pre> <br><br>  Results (error less than 5%): <br><table><tbody><tr><th>  No </th><th>  InnoDB, ms </th><th>  MyISAM ms </th></tr><tr><td>  one </td><td>  5 360 </td><td>  862 </td></tr><tr><td>  2 </td><td>  5 390 </td><td>  1,150 </td></tr></tbody></table><br>  I don‚Äôt want to study in more detail why the aggregation samples in MyISAM are so affected by the number of WHERE lines that fell under the WHERE, but the fact remains that with full sequential table scans, MyISAM is 4.5 times faster than InnoDB.  Hence the opinion that InnoDB is a ‚Äúbrake‚Äù, and that MySQL itself (with MyISAM) is very smart. <br><br>  <b>Mini-output:</b> With full sequential browsing of MyISAM 5 times faster than InnoDB <br><br><h4>  JOIN </h4><br>  Let's now connect to the case the Users table - no wonder we created it. <br>  We will investigate requests for such a plan: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">MAX</span></span>(calls.cost) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> calls <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">users</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> calls.user_id = users.id <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> calls.cost &gt; %d <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> users.sex = <span class="hljs-string"><span class="hljs-string">'M'</span></span></code> </pre> <br>  The parameter for cost is chosen in such a way that a certain percentage of entries in the Calls table are selected. <br><br>  If we make the query given above, to the muscle, with the cost parameter, which will correspond to N% of rows, MySQL will make the join only in N% of cases, and it will not make JOIN for the rest (100-N)% of rows.  Here is a MySQL smart. <br><br>  Let's get to the test results with JOIN: <br><br><h4>  FULL SCAN + JOIN 0.1% of rows </h4><table><tbody><tr><th>  Users \ Calls </th><th>  InnoDB, ms (only JOIN, ms) </th><th>  MyISAM, ms (only JOIN, ms) </th></tr><tr><td>  InnoDB </td><td>  5,450 (~ 0) </td><td>  857 (~ 0) </td></tr><tr><td>  MyISAM </td><td>  5,450 (~ 0) </td><td>  937 (~ 100) </td></tr><tr><td>  MEMORY </td><td>  5,350 (~ 0) </td><td>  845 (~ 100) </td></tr></tbody></table><br>  So far, times differ very little from FULL SCAN.  It is understandable - after all, JOIN is made for a meager number of rows. <br><br><h4>  FULL SCAN + JOIN 1% of rows </h4><table><tbody><tr><th>  Users \ Calls </th><th>  InnoDB, ms (only JOIN, ms) </th><th>  MyISAM, ms (only JOIN, ms) </th></tr><tr><td>  InnoDB </td><td>  5,660 (300) </td><td>  999 (140) </td></tr><tr><td>  MyISAM </td><td>  6,530 (1,200) </td><td>  1,810 (950) </td></tr><tr><td>  MEMORY </td><td>  5,460 (100) </td><td>  911 (65) </td></tr></tbody></table><br>  Funny, yes?  Only 1% of the rows are jointed, and the results for MyISAM + MyISAM are 2 times more than for MyISAM + InnoDB.  Funny enough, the JOIN to InnoDB in this case is faster than the JOIN to MyISAM.  And we have not started testing this yet :)! <br><br><h4>  FULL SCAN + JOIN 10% of rows </h4><table><tbody><tr><th>  Users \ Calls </th><th>  InnoDB, ms </th><th>  MyISAM ms </th></tr><tr><td>  InnoDB </td><td>  7,230 (1,900) </td><td>  2 190 (990) </td></tr><tr><td>  MyISAM </td><td>  16,100 (8,800) </td><td>  10,200 (9,000) </td></tr><tr><td>  MEMORY </td><td>  6,080 (700) </td><td>  1,440 (580) </td></tr></tbody></table><br>  It‚Äôs a shame for the country (MyISAM), but what can I do ... It turns out that MyISAM is not that smart ... Or not?  Let's look at the results of the final testing. <br><br><h4>  FULL SCAN + JOIN 100% rows </h4><table><tbody><tr><th>  Users \ Calls </th><th>  InnoDB, ms </th><th>  MyISAM ms </th></tr><tr><td>  InnoDB </td><td>  18,000 (14,650) </td><td>  12,500 (11,655) </td></tr><tr><td>  MyISAM </td><td>  100,000 (96,650) </td><td>  91,600 (90,750) </td></tr><tr><td>  MEMORY </td><td>  10,500 (7,150) </td><td>  5,280 (4,435) </td></tr></tbody></table><br>  Pay attention to the monstrous (!) Sampling times with JOIN with MyISAM.  But InnoDB was pleasantly surprised - due to its architecture, the JOIN is not a very expensive operation for InnoDB.  To be honest, I was very surprised when I got such a result that the second fastest JOIN option is when InnoDB is joining MyISAM. <br><br>  Well, with MEMORY, I think everything is clear - MEMORY gives an overhead of 525% (4,435 ms) on a join over PK, InnoDB gives an overhead of 1,380% (11,655 ms), but I‚Äôm ashamed to say about MyISAM. <br><br><h4>  Replacing JOIN with IN (...) </h4><br>  A keen eye could notice that for our scenario (when we do JOIN to users, to weed out all women from the table of calls) there is a way without a JOIN, but with a simple enumeration of all user_id in IN (): <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> group_concat_max_len = <span class="hljs-number"><span class="hljs-number">10000000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">GROUP_CONCAT</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">users</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> sex = <span class="hljs-string"><span class="hljs-string">'M'</span></span>; <span class="hljs-comment"><span class="hljs-comment">--    50 ,  -   SELECT MAX(cost) FROM calls WHERE user_id IN(%s); -- %s   </span></span></code> </pre><br><br>  Such a query to a table of the MyISAM type will work for 3,730 ms, and to InnoDB - for 8,290 ms.  A keen eye may notice that this method is faster than the JOIN to MEMORY, although not by much.  This method is suitable if you have a very fast connection to MySQL (for example, a UNIX socket).  In other cases, IMHO, with such numbers of records, it is obvious that driving a huge amount of traffic between the MySQL server and the application server is not a good idea. <br><br>  You can make your own <b>conclusions</b> : if you need a lot of joining, and for some reason you need high performance, use a combination of MyISAM + InnoDB, or just InnoDB + InnoDB, if there are more than one join.  Well, if you are extreme, you can use MyISAM + MEMORY for maximum performance in all scenarios.  There is another option with MEMORY + MEMORY, but for a large number of records I would not do that;). <br><br>  <b>UPD:</b> I would like to thank the hombrauser <a href="http://habrahabr.ru/users/homm/" class="user_link">homm</a> for very useful comments, such <a href="http://habrahabr.ru/blogs/mysql/122210/">as this</a> .  In general, I highly recommend reading the comments, they explain a lot of things that for some reason were not obvious to the readers: <br>  - query cache is disabled <br>  - JOIN is done on the primary key <br>  - indexes on the table Calls are not created, because we do not set the task to optimize a particular query </div><p>Source: <a href="https://habr.com/ru/post/122210/">https://habr.com/ru/post/122210/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../122198/index.html">Group work with the project and task manager 42tasks.com. Visually</a></li>
<li><a href="../122199/index.html">20 years in Russia. Report from Skolkovo</a></li>
<li><a href="../122200/index.html">Experienced trivia-5, or "Group joy!"</a></li>
<li><a href="../122205/index.html">Brain computer interface. Part Three Weekdays</a></li>
<li><a href="../122209/index.html">Streaming is increasing in the US</a></li>
<li><a href="../122211/index.html">4 the lulz</a></li>
<li><a href="../122212/index.html">Apple has extended a lawsuit against Samsung</a></li>
<li><a href="../122214/index.html">Flash openly announced his friendship with regular telephony!</a></li>
<li><a href="../122215/index.html">Review of freely available and free IP PBXs (Asterisk, FreeSWITCH, SipXecs, Yate)</a></li>
<li><a href="../122216/index.html">Learning the L4 microkernel and writing the ‚ÄúHello world‚Äù application for the Xameleon system</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>