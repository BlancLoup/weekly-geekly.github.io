<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Clojure - sequences</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Clojure is a Lisp dialect, so it‚Äôs not at all surprising that the key to the language is given to working with lists. However, unlike traditional dial...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Clojure - sequences</h1><div class="post__text post__text-html js-mediator-article">  Clojure is a Lisp dialect, so it‚Äôs not at all surprising that the key to the language is given to working with lists.  However, unlike traditional dialects (CL or Scheme), instead of the classical dual-slot lists, Clojure uses the Sequence abstraction - ‚Äúlogical list‚Äù.  In fact, it is an interface that provides methods for working with immutable, lazy, and possibly infinite sequences.  This article describes the internal structure of these entities. <br><a name="habracut"></a><br><h2>  The essence of the sequences </h2><br>  Let's start with java-interfaces.  All structures in Clojure implement <a href="">clojure.lang.Seqable</a> : <br><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Seqable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-function">ISeq </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">seq</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; }</code> </pre> <br><br>  In its turn, <a href="">clojure.lang.ISeq is</a> defined as: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ISeq</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IPersistentCollection</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-function">Object </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">first</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">ISeq </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">next</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">ISeq </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">more</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">ISeq </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cons</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object o)</span></span></span></span>; }</code> </pre><br><br>  Here you can draw an analogy with <em>Iterable</em> , respectively, <em>ISeq</em> is a certain analogue of <em>Iterator</em> .  Their main difference is that <em>ISeq</em> objects <em>are</em> immutable: its methods return a new instance (maybe even of a different type) instead of changing the internal state of the object.  All sequences in Clojure are collections at the same time - they implement the inherited interface <a href="">clojure.lang.IPersistentCollection</a> , and through it <em>Seqable</em> : <br><br><pre> <code class="hljs java"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IPersistentCollection</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Seqable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">count</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">IPersistentCollection </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cons</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object o)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">IPersistentCollection </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">empty</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">equiv</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object o)</span></span></span></span>; }</code> </pre><br><br>  Here we see <em>count</em> - counting the number of elements.  For sequences, its complexity is obviously O (n).  The <em>empty</em> method returns an empty collection of the same type.  For sequences, returns <em>()</em> .  Well, the <em>cons</em> method adds a new element. <br><br>  To get <em>ISeq</em> objects, the <em>seq</em> function is provided in the language.  If the collection is empty, then <em>nil is</em> returned, if we have a <em>Seqable</em> object, then the <em>seq ()</em> method is called on it, otherwise a special wrapper (adapter) is created.  Wrappers are supported for arrays, iterators, java-collections (including <em>Map</em> ) and <em>CharSequence</em> objects (strings).  Add your type to this list does not work - it is "sewn" in the java code (even the protocols will not help).  Of course, you should not change arrays (or java-collections), if a sequence is created for them.  So, the exception of <em>ConcurrentModificationException is</em> simply thrown upwards. <br><br>  Clojure has only three basic functions for working with sequences: <br><ul><li>  <em>first</em> - take the first element of the sequence or <em>nil</em> if it is empty; </li><li>  <em>rest</em> - get the "tail", i.e.  a sequence without the first element; </li><li>  <em>cons</em> - create a new immutable <a href="http://en.wikipedia.org/wiki/Cons">cons cell</a> . </li></ul><br>  For adding new elements instead of <em>cons</em> , the <em>conj</em> function is usually used.  The difference between them is that the first one always creates a new cell of the simply linked list, but the result of the second one is specific for each specific type of collections ‚Äî the element is added to the most appropriate place.  For cons-cells this is the beginning of the list, for vectors - the end, for sets the order is not defined at all.  It is important to note that if we applied the <em>seq</em> collection, we lose information about its type: <br><br><pre> <code class="hljs perl">(conj [<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>] <span class="hljs-number"><span class="hljs-number">4</span></span>) ;=&gt; [<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span>] (conj (se<span class="hljs-string"><span class="hljs-string">q [1 2 3]</span></span>) <span class="hljs-number"><span class="hljs-number">4</span></span>) ;=&gt; <span class="hljs-string"><span class="hljs-string">'(4 1 2 3)</span></span></code> </pre><br><br>  Unfortunately, the names of the methods in the java-interfaces and the names of the functions do not always coincide: the function <em>conj</em> corresponds to the method <em>cons</em> , and <em>rest</em> to the method <em>more</em> .  On the other hand, you only need to know the names of the methods when writing your collections, and this occupation can hardly be attributed to the ordinary ones. <br><br>  All standard functions automatically call <em>seq</em> .  For example, if we write <em>(cons 1 [2 3])</em> , then the created cons cell will actually refer not to the vector itself <em>[1 2]</em> , but to the result <em>(seq [1 2])</em> .  The same trick is carried out with the work of the other functions (map, filter, etc.) - they all work with sequences, although they accept them as collection parameters. <br><br>  Actually, only lists and cons-cells directly implement <em>ISeq</em> : <br><br><pre> <code class="hljs swift">(seq? '(<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>)) ;=&gt; <span class="hljs-literal"><span class="hljs-literal">true</span></span> (seq? ()) ;=&gt; <span class="hljs-literal"><span class="hljs-literal">true</span></span> (seq? (cons <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)) ;=&gt; <span class="hljs-literal"><span class="hljs-literal">true</span></span> (seq? (cons <span class="hljs-number"><span class="hljs-number">1</span></span> [<span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>])) ;=&gt; <span class="hljs-literal"><span class="hljs-literal">true</span></span> (seq? [<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>]) ;=&gt; <span class="hljs-literal"><span class="hljs-literal">false</span></span> (seq? {:a :b}) ;=&gt; <span class="hljs-literal"><span class="hljs-literal">false</span></span> (seq? #{<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>}) ;=&gt; <span class="hljs-literal"><span class="hljs-literal">false</span></span> (seq? <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) ;=&gt; <span class="hljs-literal"><span class="hljs-literal">false</span></span></code> </pre><br><br>  Therefore, when iterating through the list, no temporary objects are created.  But when we go over the vector, then one temporary instance of <em>ISeq</em> is created for each element.  In fact, with version 1.1, things are a little different, but more on that below. <br><br>  There is the ‚Äúunknown‚Äù interface <a href="">clojure.lang.IndexedSeq</a> , which is implemented by sequences for arrays and strings.  It defines the <em>index ()</em> method to get the number of the current item (i.e. where the head is in the original collection). <br><br><pre> <code class="hljs pgsql">(.<span class="hljs-keyword"><span class="hljs-keyword">index</span></span> (rest (<span class="hljs-keyword"><span class="hljs-keyword">to</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">array</span></span> [<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span>]))) ;=&gt; <span class="hljs-number"><span class="hljs-number">1</span></span> (.<span class="hljs-keyword"><span class="hljs-keyword">index</span></span> (rest (rest (<span class="hljs-keyword"><span class="hljs-keyword">to</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">array</span></span> [<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span>]))) ;=&gt; <span class="hljs-number"><span class="hljs-number">2</span></span></code> </pre><br><br>  In practice, this interface is not used anywhere (undocumented feature).  However, it is really difficult to invent it.  By the way, the <em>clojure.lang.APersistenVector $ Seq</em> objects also implement it.  But the trouble is that now the <em>seq</em> for vectors returns instances of <em>clojure.lang.PersistentVector $ ChunkedSeq</em> , which no longer have such a dubious possibility. <br><br><h2>  Lazy sequences </h2><br>  An important feature of Clojure sequences is their potential laziness.  This means that at the current moment in time, not the entire sequence has been built, and its ‚Äútail‚Äù has not yet been created.  Clojure often uses this for I / O threading. <br><br>  Implementing laziness is quite simple.  There is a class <a href="">clojure.lang.LazySeq</a> (which, of course, implements <em>ISeq</em> ).  Objects of this class have a reference to a function (an <em>IFn</em> instance), which, when called, should return the new sequence itself (most likely also lazy, though not necessarily).  When any call to <em>LazySeq</em> methods <em>is</em> made, a synchronized call to the generating function is made, its result is saved, and the link to the function itself is reset (to allow the garbage collector to process it).  Obviously, there is no way to get an element of a lazy sequence without calculating all the previous ones.  If you need exactly this behavior - you can use the <a href="http://clojure.github.com/clojure/clojure.core-api.html">delay</a> macro. <br><br><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">nth</span></span> (<span class="hljs-name"><span class="hljs-name">map</span></span> #(<span class="hljs-name"><span class="hljs-name">print</span></span> % <span class="hljs-string"><span class="hljs-string">""</span></span>) (<span class="hljs-name"><span class="hljs-name">iterate</span></span> inc <span class="hljs-number"><span class="hljs-number">0</span></span>)) <span class="hljs-number"><span class="hljs-number">5</span></span>) <span class="hljs-comment"><span class="hljs-comment">;=&gt; 1 2 3 4 5 @(nth (map #(delay (print % "")) (iterate inc 0)) 5) ;=&gt; 5</span></span></code> </pre><br><br>  It is ridiculously easy to generate lazy sequences in your code.  It is enough to put the code that calls <em>cons</em> into the <a href="http://clojure.github.com/clojure/clojure.core-api.html">lazy-seq</a> macro.  But, in fact, even this is often not the case ‚Äî most standard functions (with very few exceptions) return precisely the lazy collections, doing all the dirty work for us.  There is truth and small nuances here. <br><br>  So, in its calculation, a lazy sequence actually turns into a simple, simply-connected list, and if you keep a reference to the first element, then there may be problems with memory.  Classic example: <br><br><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">def</span></span> all-odds (<span class="hljs-name"><span class="hljs-name">filter</span></span> odd? (<span class="hljs-name"><span class="hljs-name">range</span></span>))) (<span class="hljs-name"><span class="hljs-name">println</span></span> (<span class="hljs-name"><span class="hljs-name">nth</span></span> all-odds <span class="hljs-number"><span class="hljs-number">20000000</span></span>))</code> </pre><br><br>  Here we are trying to find the 20,000,000th odd number.  And it finds it, but here only all intermediate instances of <em>ISeq</em> remain in memory.  Correct solution: <br><br><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">defn</span></span> make-all-odds [] (<span class="hljs-name"><span class="hljs-name">filter</span></span> odd? (<span class="hljs-name"><span class="hljs-name">range</span></span>))) (<span class="hljs-name"><span class="hljs-name">println</span></span> (<span class="hljs-name"><span class="hljs-name">nth</span></span> (<span class="hljs-name"><span class="hljs-name">make-all-odds</span></span>) <span class="hljs-number"><span class="hljs-number">2000000</span></span>))</code> </pre><br><br>  The <em>rest</em> function never returns <em>nil</em> , instead it can return an empty sequence.  If we want to get <em>nil</em> , then we should use <em>next</em> . <br><br><pre> <code class="hljs php">(first <span class="hljs-string"><span class="hljs-string">'(1 2 3)) ;=&gt; 1 (rest '</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>)) ;=&gt; <span class="hljs-string"><span class="hljs-string">'(2 3) (rest '</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>)) ;=&gt; () (rest ()) ;=&gt; () (next <span class="hljs-string"><span class="hljs-string">'(1)) ;=&gt; nil (next ()) ;=&gt; nil</span></span></code> </pre><br><br>  This is done for more laziness.  In fact, if the sequence is lazy, then in general we do not know whether there are more elements in it or not.  To check this fact with the help of <em>next,</em> we need to calculate at least 2 first elements: we discard the first one, and by the presence of the second we will understand whether it is necessary to return <em>nil</em> .  Well, the calculation of 2 elements is clearly not what we usually need. <br><br>  If lazy behavior is not required, then the entire sequence can be fully computed using the <em>dorun</em> and <em>doall functions</em> .  The first returns the original sequence, the second returns nil. <br><br><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">dorun</span></span> (<span class="hljs-name"><span class="hljs-name">map</span></span> #(<span class="hljs-name"><span class="hljs-name">println</span></span> % <span class="hljs-string"><span class="hljs-string">""</span></span>) (<span class="hljs-name"><span class="hljs-name">range</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span>)))<span class="hljs-comment"><span class="hljs-comment">;=&gt; 1 2 3 4 5</span></span></code> </pre><br><br><h2>  Block sequences (chunked sequences) </h2><br>  Lazy collections are a very powerful tool, but in practice, we often process the entire collection as a whole, and <em>lazy-seq</em> introduces significant overhead.  Therefore, in version 1.1, an important optimization was done - chunked seqences.  The essence is simple - when processing lazy sequences, we are dealing not with individual elements, but with their groups.  In this case, a number of elements ‚Äúfor growth‚Äù are eagerly calculated. <br><br>  Guess what this code displays? <br><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">first</span></span> (<span class="hljs-name"><span class="hljs-name">map</span></span> #(<span class="hljs-name"><span class="hljs-name">print</span></span> % <span class="hljs-string"><span class="hljs-string">""</span></span>) (<span class="hljs-name"><span class="hljs-name">range</span></span> <span class="hljs-number"><span class="hljs-number">100</span></span>)))</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Answer</b> <div class="spoiler_text">  0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 </div></div><br><br>  So, Clojure defines a special interface <a href="">clojure.lang.IChunkedSeq</a> .  Describing the java-part of this mechanism does not make much sense, so I will omit it.  The interface implements only sequences for vectors.  Well, as we have seen, the result of the <em>range</em> function. <br><br>  The algorithm for processing such sequences: <br><ul><li>  check if the source is <em>IChunkedSeq</em> ( <em>chunked-seq</em> function <em>?</em> ); </li><li>  if not, then perform the normal version of the algorithm (elementwise processing); </li><li>  if yes, then take the first block from the sequence ( <em>chunk-first</em> function); </li><li>  we watch its size ( <em>chunk-size</em> function); </li><li>  we create a new block, we will place the generated elements there (the <em>chunk-buffer</em> function); </li><li>  we actually do useful work, we add elements to the block (the <em>chunk-append</em> function); </li><li>  we wrap our new block in ChunkedCons ( <em>chunk-cons</em> function). </li></ul><br><br>  For example, let's write our own implementation # (filter odd?%).  Simple option: <br><br><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">defn</span></span> filter-odd-1 [a] (<span class="hljs-name"><span class="hljs-name">lazy-seq</span></span> (<span class="hljs-name"><span class="hljs-name">when-let</span></span> [s (<span class="hljs-name"><span class="hljs-name">seq</span></span> a)] (<span class="hljs-name"><span class="hljs-name">let</span></span> [f (<span class="hljs-name"><span class="hljs-name">first</span></span> s) r (<span class="hljs-name"><span class="hljs-name">rest</span></span> s)] (<span class="hljs-name"><span class="hljs-name">if</span></span> (<span class="hljs-name"><span class="hljs-name">odd</span></span>? f) (<span class="hljs-name"><span class="hljs-name">cons</span></span> f (<span class="hljs-name"><span class="hljs-name">filter-odd-1</span></span> r)) (<span class="hljs-name"><span class="hljs-name">filter-odd-1</span></span> r))))))</code> </pre><br><br>  Extended version (with block support): <br><br><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">defn</span></span> filter-odd-2 [a] (<span class="hljs-name"><span class="hljs-name">lazy-seq</span></span> (<span class="hljs-name"><span class="hljs-name">when-let</span></span> [s (<span class="hljs-name"><span class="hljs-name">seq</span></span> a)] (<span class="hljs-name"><span class="hljs-name">if</span></span> (<span class="hljs-name"><span class="hljs-name">chunked-seq</span></span>? s) (<span class="hljs-name"><span class="hljs-name">let</span></span> [f (<span class="hljs-name"><span class="hljs-name">chunk-first</span></span> s) c (<span class="hljs-name"><span class="hljs-name">count</span></span> f) b (<span class="hljs-name"><span class="hljs-name">chunk-buffer</span></span> c)] (<span class="hljs-name"><span class="hljs-name">dotimes</span></span> [ic] (<span class="hljs-name"><span class="hljs-name">let</span></span> [x (<span class="hljs-name"><span class="hljs-name">nth</span></span> fi)] (<span class="hljs-name"><span class="hljs-name">when</span></span> (<span class="hljs-name"><span class="hljs-name">odd</span></span>? x) (<span class="hljs-name"><span class="hljs-name">chunk-append</span></span> bx)))) (<span class="hljs-name"><span class="hljs-name">chunk-cons</span></span> (<span class="hljs-name"><span class="hljs-name">chunk</span></span> b) (<span class="hljs-name"><span class="hljs-name">filter-odd-2</span></span> (<span class="hljs-name"><span class="hljs-name">chunk-rest</span></span> s)))) (<span class="hljs-name"><span class="hljs-name">let</span></span> [f (<span class="hljs-name"><span class="hljs-name">first</span></span> s) r (<span class="hljs-name"><span class="hljs-name">rest</span></span> s)] (<span class="hljs-name"><span class="hljs-name">if</span></span> (<span class="hljs-name"><span class="hljs-name">odd</span></span>? f) (<span class="hljs-name"><span class="hljs-name">cons</span></span> f (<span class="hljs-name"><span class="hljs-name">filter-odd-2</span></span> r)) (<span class="hljs-name"><span class="hljs-name">filter-odd-2</span></span> r)))))))</code> </pre><br><br>  Of course, the code has become a little bit more, and there is an obvious duplication on the face: we had to create two separate implementations.  But this is the price of speed.  Fortunately, most of the standard features already support the chunks to the full.  I note that the sequence can consist of blocks of different lengths (blocks are not glued together, but sometimes are cut down, as in the example above), and even be a mixture of ordinary elements and blocks. <br><br>  What if we want to turn an ordinary sequence into a block sequence?  You just need to convert it into a vector using the function <em>vec</em> .  The reverse is a little more complicated: <br><br><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">defn</span></span> seq1 [s] (<span class="hljs-name"><span class="hljs-name">lazy-seq</span></span> (<span class="hljs-name"><span class="hljs-name">when-let</span></span> [x (<span class="hljs-name"><span class="hljs-name">seq</span></span> s)] (<span class="hljs-name"><span class="hljs-name">cons</span></span> (<span class="hljs-name"><span class="hljs-name">first</span></span> x) (<span class="hljs-name"><span class="hljs-name">seq1</span></span> (<span class="hljs-name"><span class="hljs-name">rest</span></span> x)))))) (<span class="hljs-name"><span class="hljs-name">first</span></span> (<span class="hljs-name"><span class="hljs-name">map</span></span> println (<span class="hljs-name"><span class="hljs-name">seq1</span></span> (<span class="hljs-name"><span class="hljs-name">range</span></span> <span class="hljs-number"><span class="hljs-number">1000</span></span>)))) <span class="hljs-comment"><span class="hljs-comment">;=&gt; 1</span></span></code> </pre><br><div class="spoiler">  <b class="spoiler_title">Alternative solution</b> <div class="spoiler_text"><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">defn</span></span> seq1 [^clojure.lang.ISeq s] (<span class="hljs-name"><span class="hljs-name">reify</span></span> clojure.lang.ISeq (<span class="hljs-name"><span class="hljs-name">first</span></span> [_] (.first s)) (<span class="hljs-name"><span class="hljs-name">more</span></span> [_] (<span class="hljs-name"><span class="hljs-name">seq1</span></span> (.more s))) (<span class="hljs-name"><span class="hljs-name">next</span></span> [_] (<span class="hljs-name"><span class="hljs-name">let</span></span> [sn (.next s)] (<span class="hljs-name"><span class="hljs-name">and</span></span> sn (<span class="hljs-name"><span class="hljs-name">seq1</span></span> sn)))) (<span class="hljs-name"><span class="hljs-name">seq</span></span> [_] (<span class="hljs-name"><span class="hljs-name">let</span></span> [ss (.seq s)] (<span class="hljs-name"><span class="hljs-name">and</span></span> ss (<span class="hljs-name"><span class="hljs-name">seq1</span></span> ss)))) (<span class="hljs-name"><span class="hljs-name">count</span></span> [_] (.count s)) (<span class="hljs-name"><span class="hljs-name">cons</span></span> [_ o] (.cons so)) (<span class="hljs-name"><span class="hljs-name">empty</span></span> [_] (.empty s)) (<span class="hljs-name"><span class="hljs-name">equiv</span></span> [_ o] (.equiv so))))</code> </pre></div></div><br><br>  It is quite expected that the <em>reduce</em> function takes advantage of block sequences.  So, each block has a special method that performs convolution in a java-loop without creating temporary objects.  In general, <em>reduce</em> has other optimizations as well; anyone interested can check <a href="">clojure.core.protocols</a> . <br><br><h2>  Instead of conclusion </h2><br>  Clojure sequences are powerful and convenient.  Their undoubted plus is that one can often not even think about such ‚Äútrifles‚Äù as laziness or block processing - Clojure tries to do it for us. </div><p>Source: <a href="https://habr.com/ru/post/160235/">https://habr.com/ru/post/160235/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../160219/index.html">Big Data - why is it so fashionable?</a></li>
<li><a href="../160221/index.html">New York Police Confidential Documents Used as Confetti</a></li>
<li><a href="../160223/index.html">Acer Aspire V5 Touch Ultra Notebook Review</a></li>
<li><a href="../160225/index.html">Search engine sanctions</a></li>
<li><a href="../160231/index.html">Voynushka local scale, but with the strategy and mission, or test management for top managers</a></li>
<li><a href="../160237/index.html">Large file storage for a small company like this.</a></li>
<li><a href="../160239/index.html">Web Designer Training - An Employer's View</a></li>
<li><a href="../160241/index.html">Cambridge plans to open courses to counter the dangers of artificial intelligence</a></li>
<li><a href="../160247/index.html">Video review gaming laptop MSI GT70</a></li>
<li><a href="../160249/index.html">Hieroglyphics input methods</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>