<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Backup, Part 1: Purpose, Overview of Methods and Technologies</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Why do you need to make backup copies? After all, the equipment is very, very reliable, besides, there are ‚Äúclouds‚Äù that are more reliable than physic...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Backup, Part 1: Purpose, Overview of Methods and Technologies</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/658/945/c47/658945c47c79b468058bdfa05712bab1.jpg" alt="Backup? I don't need backup !!"></div><br>  Why do you need to make backup copies?  After all, the equipment is very, very reliable, besides, there are ‚Äúclouds‚Äù that are more reliable than physical servers: if properly configured, the ‚Äúcloud‚Äù server will easily survive the failure of the infrastructure physical server, and from the point of view of service users, there will be a small, barely noticeable leap in time service.  In addition, duplication of information often requires paying for ‚Äúextra‚Äù processor time, disk load, and network traffic. <br><a name="habracut"></a><br><blockquote>  The ideal program works fast, does not flow through the RAM, has no holes and does not exist. <br><br>  -Unknown </blockquote>  Since programs are still being written by protein developers, and the testing process is often absent, plus the delivery of programs rarely happens using the ‚Äúbest practices‚Äù (which are programs themselves, and therefore not ideal), system administrators often have to solve problems that sound like briefly, but succinctly: ‚Äúreturn, as it was,‚Äù ‚Äúbring the base to normal operation‚Äù, ‚Äúslowly work - roll back‚Äù, as well as my favorite ‚ÄúI don‚Äôt know what, but fix it‚Äù. <br><br>  In addition to logical errors that emerge as a result of negligent work by developers, or coincidences, as well as incomplete knowledge or misunderstanding of the minor features of building programs ‚Äî including connecting and systemic ones, including operating systems, drivers, and firmware ‚Äî there are also other errors.  For example, most developers rely on runtime, completely forgetting about the physical laws, which are still impossible to circumvent with programs.  This is the infinite reliability of the disk subsystem and in general of any storage subsystem (including RAM and processor cache!), And zero processing time on the processor, and no errors during transmission over the network and during processing on the processor, and network delays that are 0. Do not neglect the notorious deadline, because if you do not have time for it - there will be problems cleaner of the nuances of the network and the disk. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/getpro/habr/post_images/171/855/c4d/171855c4dfec286b3624dd27efeb71e6.jpg" alt="Chef, it's all gone! Based on the \ f Diamond Hand"><br><br>  How to deal with problems that arise in full growth and hang over valuable data?  Live developers have nothing to replace, and not the fact that it will be possible in the near future.  On the other hand, to fully prove that the program will work as intended, so far only a few projects have turned out, and it is not at all necessary to take and apply evidence to other, similar projects.  Also, such evidence takes a lot of time, and requires special skills and knowledge, and this practically minimizes the possibility of using them, taking into account the deadlines.  In addition, we still do not know how to ultra-fast, cheap and infinitely reliable technology for storing, processing and transmitting information.  Such technologies, if they exist, in the form of concepts, or - most often - only in fantastic books and films. <br><blockquote>  Good artists copy, great artists steal. <br><br>  ‚ÄîPablo Picasso. </blockquote>  The most successful solutions and surprisingly simple things usually occur where absolutely incompatible at first glance concepts, technologies, knowledge, and fields of science meet. <br><br>  For example, birds and planes have wings, but despite the functional similarity - the principle of operation in some modes is the same, and technical problems are solved in the same way: hollow bones, the use of durable and lightweight materials, etc. - the results are completely different, although very similar.  The best patterns that we see in our technology are also, for the most part, borrowed from nature: hermetic compartments in ships and submarines are a direct analogy to the ringed worms;  building raid arrays and checking data integrity - duplication of the DNA chain;  as well as paired organs, the independence of the work of various organs from the central nervous system (automatic heart work) and reflexes are autonomous systems on the Internet.  Of course, taking and applying ready-made solutions ‚Äúin the forehead‚Äù is fraught with problems, but who knows, maybe there are no other solutions. <br><blockquote>  To know where you fall - straws would spread! <br><br>  ‚ÄîBelarusian proverb </blockquote>  So backups are vital for those who wish: <br><br><ul><li>  Have the ability to restore the work of their systems with minimal downtime, and even without them </li><li>  It is safe to act, because in case of an error there is always the possibility of a rollback </li><li>  Minimize the effects of intentional data corruption. </li></ul><br><div class="spoiler">  <b class="spoiler_title">Here is a bit of theory.</b> <div class="spoiler_text"><blockquote>  Any classification is arbitrary.  Nature does not classify.  We classify it because it is more convenient for us.  And we classify according to the data that we take also arbitrarily. <br><br>  ‚ÄîJan Bryuler </blockquote>  Regardless of the physical storage method, logical data storage can be divided into 2 ways to access this data: block and file.  Such a division has recently become very blurry, since purely block, as well as purely file, logical storages do not exist.  However, for simplicity, we assume that they are. <br><br>  Block data storage implies that there is a physical device where data is recorded in some fixed chunks, blocks.  Access to the blocks goes to a certain address, each block has its own address within the device. <br><br>  A backup is usually made by copying data blocks.  To ensure data integrity at the time of copying, the recording of new blocks is suspended, as well as the modification of existing ones.  If you take an analogy from the ordinary world - the closest closet with the same numbered cells. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ac1/aa2/32f/ac1aa232faecb701dd3c82894239f34e.png" alt="Block data storage"><br><br>  File storage of data on the principle of a logical device is close to block and often organized on top.  Important differences are the existence of a storage hierarchy and intelligible names.  There is an abstraction in the form of a file - a named data area, as well as a directory - a special file that stores descriptions and access to other files.  Files can be supplied with additional metadata: creation time, access flags, etc.  They usually reserve it this way: they look for modified files, then copy them to another file storage structure identical in structure.  Data integrity is usually implemented by the absence of files to which it is written.  File metadata is backed up in the same way.  The closest analogy is a library in which there are sections with different books, and also there is a catalog with familiar names of books. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/752/454/8cc/7524548cc8ff235cf9284d49d1fab007.jpg" alt="File storage"><br><br>  Recently, another option has been described, from which, in principle, file storage began, and which has the same archaic features: object data storage. <br><br>  It differs from file storage in that it does not have more than one nesting (flat scheme), and file names, although human-readable, are still more suitable for processing by machines.  When backing up, object storages are most often treated like file storage, but occasionally there are other options. <br><blockquote>  - There are two types of system administrators, those who do not make backup copies, and those who already do. <br>  - In fact, there are three types: there are still those who verify that backups can be restored. <br><br>  -Unknown </blockquote>  You should also understand that the data backup process itself is carried out by programs, so all the same disadvantages as another program are inherent in it.  In order to remove (not exclude!) The dependence on the human factor, as well as the peculiarities - which individually do not greatly influence, but together can give a tangible effect - apply the so-called.  rule 3-2-1.  There are many options for deciphering it, but I prefer the following interpretation: you need to store 3 sets of the same data, 2 sets need to be stored in different formats, and 1 set must be stored in a geographically remote storage. <br><br>  Under the storage format should be understood as follows: <br><br><ul><li>  If there is a dependence on the physical method of storage - change the physical method. </li><li>  If there is a dependence on a logical storage method, we change the logical method. </li></ul><br>  To achieve the maximum effect of rule 3-2-1, it is recommended to change the storage format in both ways. <br><br>  From the point of view of backup readiness for its intended purpose - to restore functionality, - there are ‚Äúhot‚Äù and ‚Äúcold‚Äù backups.  Hot ones from cold ones differ only in one thing: they are immediately ready for work, while cold ones for recovery require some additional actions: decryption, retrieval from the archive, etc. <br><br>  Do not confuse hot and cold copies with online and offline copies, which imply physical isolation of data, and in fact are another sign of the classification of backup methods.  So offline copy - not connected directly to the system, where it needs to be restored - can be both hot and cold (in terms of readiness for restoration).  An online copy can be accessed directly where it needs to be restored, and most often is hot, but there are also cold ones. <br><br>  In addition, do not forget that the process of creating backups usually does not end with the creation of a single backup, and there may be a sufficiently large number of copies.  Therefore, it is necessary to distinguish between full backups, i.e.  those that are recoverable independently of other backups, as well as differential (incremental, differential, decremental, etc.) copies ‚Äî those that cannot be restored on their own and require prior restoration of one or more other backups. <br><br>  Differential incremental backups - an attempt to save the amount of space for storing backups.  Thus, only changed data from the previous backup is written to the backup. <br><br>  Differential decrements are created for the same purpose, but in a slightly different way: a full backup is made, but only the difference between the fresh copy and the previous one is actually stored. <br><br>  We should also consider the backup process on top of the storage, which supports the lack of storage of duplicates.  Thus, if you write full backups on top of it, only the difference between backups will actually be recorded, however, the process of restoring backups will be similar to restoring from a full copy and is completely transparent. <br><br><blockquote> Quis custodiet ipsos custodes? <br><br>  (Who will guard the guards themselves? - lat.) </blockquote><br><br>  It is very unpleasant when there are no backups, but it is much worse if the backup seems to be made, but during restoration it turns out that it cannot be restored, because: <br><br><ul><li>  The integrity of the source data was broken. </li><li>  Backup storage is damaged. </li><li>  Recovery works very slowly, you can not use data that is partially restored. </li></ul><br><br>  A well-designed backup process must take into account such comments, especially the first two. <br><br>  The integrity of the source data can be guaranteed in several ways.  The most commonly used are the following: a) creating file system nuggets at the block level, b) freezing the state of the file system, c) a particular block device with version storage, d) sequential recording of files or blocks.  Checksums are also used to ensure data validation during recovery. <br><br>  Storage damage can also be detected using checksums.  An additional method is the use of specialized devices, or file systems in which you cannot change the already recorded data, but you can add new ones. <br><br>  To speed up recovery, data recovery with multiple processes is used for recovery - provided that there is no bottleneck in the form of a slow network or a slow disk system.  In order to get around the situation with partially recovered data, you can split the backup process into relatively small subtasks, each of which is performed separately.  Thus, it becomes possible to consistently restore performance with the prediction of recovery time.  This problem most often lies in the organization plane (SLA), so we will not dwell on this in detail. <br><br><blockquote>  He knows a lot about spices not the one who adds them to every dish, but he who never adds anything extra to it. <br><br>  -AT.  Sinyavsky </blockquote><br><br>  The practice in terms of the software used by system administrators may vary, but the general principles are the same, one way or another, the same, in particular: <br><br><ul><li>  It is highly recommended to use ready-made solutions. </li><li>  Programs should work predictably, i.e.  There should be no undocumented features or bottlenecks. </li><li>  Setting up each program should be so simple that you don‚Äôt have to read the manual or the cheat sheet every time. </li><li>  If possible, the solution should be universal, since  servers in their hardware characteristics can vary very, very. </li></ul><br><br>  To make backups from block devices, there are the following common programs: <br><br><ul><li>  dd, familiar to veterans of system administration, here are similar programs (the same dd_rescue, for example). </li><li>  Embedded into some file systems are utility programs (utilities) that create a dump (dump) of the file system. </li><li>  Omnivorous utilities;  for example, partclone. </li><li>  Own, often proprietary, decisions;  for example, NortonGhost and later. </li></ul><br><br>  For file systems, the backup task is partially solved using the methods applicable for block devices, but the task can be solved more efficiently, for example: <br><br><ul><li>  Rsync, universal program and protocol for file system state synchronization. </li><li>  Built-in archiving tools (ZFS). </li><li>  Third-party archiving tools;  The most popular representative is tar.  There are others, for example, dar - the replacement of tar with a focus on modern systems. </li></ul><br>  We should also mention the software to ensure the consistency of data when creating backups.  Most often, the following options are used: <br><br><ul><li>  Mounting the file system in read-only mode (ReadOnly), or freezing the file system (freeze) - the method is restricted. </li><li>  Creating nuggets of file system or block device (LVM, ZFS). </li><li>  The use of third-party tools for the organization of the cast, even in cases where the previous paragraphs can not be provided for any reason (programs like hotcopy). </li><li>  The copying technique when changing (CopyOnWrite), however, it is most often tied to the used file system (BTRFS, ZFS). </li></ul><br></div></div><br>  So, for a small server, you need to provide a backup scheme that meets the following requirements: <br><br><ul><li>  Easy to use - no special additional actions are required when working, minimal steps to create and restore copies. </li><li>  Universal - works on both large and small servers;  This is important with the increase in the number of servers or scaling. </li><li>  It is installed by the package manager, or in one or two teams of the ‚Äúdownload and unpack‚Äù type. </li><li>  Stable - a standard or long-established storage format is used. </li><li>  Fast in work. </li></ul><br>  Applicants from those who more or less meet the requirements: <br><br><ul><li>  rdiff-backup </li><li>  rsnapshot </li><li>  burp </li><li>  duplicati </li><li>  duplicity </li><li>  deja dup </li><li>  dar </li><li>  zbackup </li><li>  restic </li><li>  borgbackup </li></ul><br><img src="https://habrastorage.org/getpro/habr/post_images/a62/7e9/237/a627e923770a18cff68471cb826ec2bd.jpg" alt="Procrustean bed"><br><br>  A virtual machine (based on XenServer) with the following characteristics will be used as a test bench: <br><br><ul><li>  4 cores 2.5 GHz, </li><li>  16 GB of RAM, </li><li>  50 GB hybrid storage (storage with caching on SSD in 20% of the size of a virtual disk) as a separate virtual disk without markup, </li><li>  200 Mbps channel to the Internet. </li></ul><br>  Almost the same machine will be used as the backup destination server, only with a 500 GB hard drive. <br><br>  The operating system is Centos 7 x64: the breakdown is standard, an additional partition will be used as a data source. <br><br>  As the source data, take a website on wordpress, with media files of 40 GB in size, and a database on mysql.  Since virtual servers differ greatly in their characteristics, as well as for better reproducibility, there are <br><br><div class="spoiler">  <b class="spoiler_title">server test results using sysbench.</b> <div class="spoiler_text">  sysbench --threads = 4 --time = 30 --cpu-max-prime = 20000 cpu run <br>  sysbench 1.1.0-18a9f86 (using bundled LuaJIT 2.1.0-beta3) <br>  Running the test with the following options: <br>  Number of threads: 4 <br>  Initializing random number generator from current time <br><br>  Prime numbers limit: 20000 <br><br>  Initializing worker threads ... <br><br>  Threads started! <br><br>  CPU speed: <br>  events per second: 836.69 <br><br>  Throughput: <br>  events / s (eps): 836.6908 <br>  time elapsed: 30.0039s <br>  total number of events: 25104 <br><br>  Latency (ms): <br>  min: 2.38 <br>  avg: 4.78 <br>  max: 22.39 <br>  95th percentile: 10.46 <br>  sum: 119923.64 <br><br>  Threads fairness: <br>  events (avg / stddev): 6276.0000 / 13.91 <br>  execution time (avg / stddev): 29.9809 / 0.01 <br><br>  sysbench --threads = 4 --time = 30 --memory-block-size = 1K --memory-scope = global --memory-total-size = 100G --memory-oper = read memory run <br>  sysbench 1.1.0-18a9f86 (using bundled LuaJIT 2.1.0-beta3) <br>  Running the test with the following options: <br>  Number of threads: 4 <br>  Initializing random number generator from current time <br><br>  Running memory speed test with the following options: <br>  block size: 1KiB <br>  total size: 102400MiB <br>  operation: read <br>  scope: global <br><br>  Initializing worker threads ... <br><br>  Threads started! <br><br>  Total operations: 50900446 (1696677.10 per second) <br><br>  49707.47 MiB transferred (1656.91 MiB / sec) <br><br>  Throughput: <br>  events / s (eps): 1696677.1017 <br>  time elapsed: 30.0001s <br>  total number of events: 50900446 <br><br>  Latency (ms): <br>  min: 0.00 <br>  avg: 0.00 <br>  max: 24.01 <br>  95th percentile: 0.00 <br>  sum: 39106.74 <br><br>  Threads fairness: <br>  events (avg / stddev): 12725111.5000 / 137775.15 <br>  execution time (avg / stddev): 9.7767 / 0.10 <br><br>  sysbench --threads = 4 --time = 30 --memory-block-size = 1K --memory-scope = global --memory-total-size = 100G --memory-oper = write memory run <br>  sysbench 1.1.0-18a9f86 (using bundled LuaJIT 2.1.0-beta3) <br>  Running the test with the following options: <br>  Number of threads: 4 <br>  Initializing random number generator from current time <br><br>  Running memory speed test with the following options: <br>  block size: 1KiB <br>  total size: 102400MiB <br>  operation: write <br>  scope: global <br><br>  Initializing worker threads ... <br><br>  Threads started! <br><br>  Total operations: 35910413 (1197008.62 per second) <br><br>  35068.76 MiB transferred (1168.95 MiB / sec) <br><br>  Throughput: <br>  events / s (eps): 1197008.6179 <br>  time elapsed: 30.0001s <br>  total number of events: 35910413 <br><br>  Latency (ms): <br>  min: 0.00 <br>  avg: 0.00 <br>  max: 16.90 <br>  95th percentile: 0.00 <br>  sum: 43604.83 <br><br>  Threads fairness: <br>  events (avg / stddev): 8977603.2500 / 233905.84 <br>  execution time (avg / stddev): 10.9012 / 0.41 <br><br>  sysbench --threads = 4 --file-test-mode = rndrw --time = 60 --file-block-size = 4K --file-total-size = 1G fileio run <br>  sysbench 1.1.0-18a9f86 (using bundled LuaJIT 2.1.0-beta3) <br>  Running the test with the following options: <br>  Number of threads: 4 <br>  Initializing random number generator from current time <br><br>  Extra file open flags: (none) <br>  128 files, 8MiB each <br>  1GiB total file size <br>  Block size 4KiB <br>  Number of IO requests: 0 <br>  Read / Write ratio for combined random IO test: 1.50 <br>  Periodic FSYNC enabled, calling fsync () each 100 requests. <br>  Calling fsync () at the end of test, Enabled. <br>  Using synchronous I / O mode <br>  Doing random r / w test <br>  Initializing worker threads ... <br><br>  Threads started! <br><br>  Throughput: <br>  read: IOPS = 3868.21 15.11 MiB / s (15.84 MB / s) <br>  write: IOPS = 2578.83 10.07 MiB / s (10.56 MB / s) <br>  fsync: IOPS = 8226.98 <br><br>  Latency (ms): <br>  min: 0.00 <br>  avg: 0.27 <br>  max: 18.01 <br>  95th percentile: 1.08 <br>  sum: 238469.45 <br></div></div><br>  This note begins a big <br><br><div class="spoiler">  <b class="spoiler_title">cycle of articles about backup</b> <div class="spoiler_text"><ol><li>  Backup, Part 1: Why do I need backup, review of methods, technologies </li><li>  Backup, part 2: Review and test rsync-based backup tools </li><li>  Backup, part 3: Review and test duplicity, duplicaty, deja dup </li><li>  Backup, part 4: zbackup, restic, borgbackup review and testing </li><li>  Backup, Part 5: Bacula and veeam backup for linux testing </li><li>  Backup Part 6: Comparing Backup Tools </li><li>  Backup, Part 7: Conclusions </li></ol><br></div></div></div><p>Source: <a href="https://habr.com/ru/post/449282/">https://habr.com/ru/post/449282/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../449270/index.html">Yandex has published an overview of the IT job market</a></li>
<li><a href="../449274/index.html">Large 7-segment neon display on the ESP8266</a></li>
<li><a href="../449276/index.html">Career change in 35. My experience and first successes</a></li>
<li><a href="../44928/index.html">US fired over 140,000 IT professionals</a></li>
<li><a href="../449280/index.html">How does the cloud gaming platform for b2b and b2c-clients. Solutions for great pictures and the last mile fight</a></li>
<li><a href="../449284/index.html">I sell onions online</a></li>
<li><a href="../449286/index.html">Make go GraphQL API</a></li>
<li><a href="../449288/index.html">Which team is needed to create a really good online store?</a></li>
<li><a href="../449290/index.html">How 3D scanning solves quality control tasks in production</a></li>
<li><a href="../449292/index.html">Review of the digital pen MT6081 - your notes immediately on the computer</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>