<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Hexapod-robot running ROS</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The hexapod robot is a platform that uses six legs to move. After watching a lot of videos on the Internet, it became clear that it is very interestin...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Hexapod-robot running ROS</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/0b7/7b3/2be/0b77b32bea9b7202cb072236124f8f69.jpg"><br><br>  The hexapod robot is a platform that uses six legs to move.  After watching a lot of videos on the Internet, it became clear that it is very interesting to watch the movement of such robots.  And then there was a desire to do something similar, but with a <a href="http://beagleboard.org/Products/BeagleBone%2520Black">BeagleBone Black</a> single-board computer (hereinafter referred to as BBB) on board, because there were no such projects yet.  Information about such robots was not easy to find, especially with regard to the software component.  For some time, it was not clear where to start, but it was soon decided to start with the manufacture of a robot constructor - the chassis and the electronic component, and then start programming what had happened. <br><a name="habracut"></a><br>  Having studied on Robocraft.ru some articles about the operating system for robots - ROS - it was decided to build the control on it, especially the BBB's power should have been enough for that.  In addition, ROS is a very promising direction in robotics with a variety of tools and ready-made solutions for development. <br><br><h4>  The choice of "iron" </h4><br>  As noted above, BeagleBone Black has become the brain of the system: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     <b><img src="https://habrastorage.org/getpro/habr/post_images/430/b6f/ff1/430b6fff10fe7af8451e499d8946b0cb.png"></b> <br><br>  BBB also supports Ubuntu, but with a core for the ARM architecture. <br><br>  The experimental mode, in which ROS for ARM is still working, did not affect the work process in any way, since tools that work stably on linux-arm were used. <br><br>  The next important part is the servo controller.  BBB has several PWM channels, but they are clearly not enough for 18 servos.  In addition, the PWM control will unnecessarily load the processor.  It is more logical to use ready-made servo controller with control through any interface.  The choice fell on the appropriate <a href="http://www.pololu.com/product/1354">Mini Maestro</a> 18-Channel USB Servo Controller: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4e3/ae3/75d/4e3ae375d1ded82058c51e1327a152ec.jpg"><br><br>  This controller has 18 channels for servo, UART and USB interface.  It is controlled through ‚Äúits‚Äù protocol, which includes setting the target angle of the servo, as well as its speed and acceleration, besides it has convenient calibration tools in the graphical environment. <br><br>  But quickly connecting the Mini Maestro to the BBB does not work, since the UART interface levels are different: 5 V and 3.3 V. The output was the use of an additional device - a logic level converter, which converts 3.3 V to 5 V and vice versa.  Such a thing came from Sparkfaun.com.  This is <a href="https://www.sparkfun.com/products/8745">BOB-08745</a> : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/736/0aa/4cd/7360aa4cd2090c5bf9b6e9609827ace5.jpg"><br><br>  Now you can easily connect the BBB and the controller so that they communicate on the UART. <br><br>  For future research, IMU wanted the robot to somehow feel itself in space.  IMU with accelerometer, magnetometer and gyroscope is also ordered on Pololu: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/319/bc2/768/319bc27680306b55e767ebd220c9ac86.jpg"><br><br>  This is a small <a href="http://www.pololu.com/product/1268">MinIMU-9 v2</a> board with two L3GD20 and LSM303DLHC chips, communicating with peripherals on the I2C interface.  MiniIMU is capable of working from 2.5V to 5.5V, so no converters are needed. <br><br>  On many videos, the hexapods were controlled by a gamepad from various consoles.  And for good reason.  With its many buttons and two ‚Äúanalog‚Äù knobs, the joystick becomes a convenient control device.  In ROS, there was a driver for a standard joystick and, in order to avoid connection problems, it was decided to purchase the original PS3 Dual Shock 3: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/540/618/f7d/540618f7dadeab515ebe03095e8c75ec.jpg"><br><br>  To connect via Bluetooth, obviously, a USB adapter was needed.  As a result, I had two of them, because one of them did not want to work with the existing driver (more on that later).  And MobileData UBT-206 - earned. <br><br>  For BBB communication with a desktop computer, the SSH protocol is used, which in turn uses, for example, Ethernet, Ethernet-over-USB (technology that allows to emulate an ethernet network via USB) or Wi-Fi.  Connecting the wires every time is not very convenient and another USB Wi-Fi adapter was added to get rid of it.  After reviewing which adapter is best for BBB, it became clear that the arm-linux kernel supports the rtl8192cu driver based on which a wide range of devices work.  The compact NetGear WNA1000M was chosen (in the picture together with the MobileData UBT-206): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1f1/e57/e67/1f1e57e67ed8064d85a5a4d5cff9dbbd.jpg"><br><img src="https://habrastorage.org/getpro/habr/post_images/1cb/d64/d1a/1cbd64d1a44c34ff995a90213b786297.jpg"><br><br>  Although many recommend using adapters with an external antenna, this one works quite stably. <br><br>  Well, in order to expand only one USB Host BBB connector, a USB hub is required.  I liked this one - MobileData HDH-700, because it has buttons-switches for each of the four devices: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e0b/d82/b64/e0bd82b64a4a20586a283d909f07f27f.jpg"><br><br>  The next item is the batteries of all the onboard devices.  Battery - Li-Po 2200mAh, consisting of two cans.  Together with it, two voltage stabilizers convert the battery voltage to the required 5V (for BBB and servo controller) and 6V (for servo drives).  Also, a low-charge alarm is installed on the battery, which squeaks when the battery voltage drops to its minimum. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2be/e10/1b7/2bee101b77dfbc1a6b98f389126cefd1.jpg"><br><br><h4>  The choice of design and servos </h4><br>  There are many designs of hexapods made from various materials.  I will not upload photos here, as they are easy to find on the Internet.  The classic version consists of three drives for each leg, which gives a sufficient degree of freedom.  Of course, you can do with two drives - but the movements will become more ‚Äújerky‚Äù. <br><br>  Different materials and manufacturing technology of parts of the suspension.  It can be printing on a 3d printer or laser cutting from plastic, plywood or metal sheets.  Since the 3d printer was not at hand and the strength of the printed parts leaves much to be desired, a metal construction was chosen, namely aluminum and duralumin.  Especially at work, I had access to a CNC milling machine, so it was decided to make parts from metal sheets by milling. <br><br>  The main example that has created its own design is <a href="http://www.lynxmotion.com/c-117-phoenix.aspx">Lynxmotion Phoenix</a> : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d76/ff6/2f2/d76ff62f25aed31a9e2fb5ad237a5bab.jpg"><br><br>  The creation was also greatly helped by the model with <a href="https://grabcad.com/library/hexapod-robot-1">GrabCAD</a> . <br><br>  One of the main parts of the robot are servos.  They must have sufficient torque and, for reliability, the gear should be chosen from the metal.  Such servi from well-known companies Hitec and Futaba cost about $ 20- $ 30.  Therefore, instead of the ‚Äúnot cheap‚Äù servo drives of the Hitec HS-645 / 485MG, Chinese were ordered, which are two times cheaper than the <a href="http://hobbyking.com/hobbyking/store/uh_viewItem.asp%3FidProduct%3D27556">Turnigy TGY-S901D</a> : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/aac/0da/a81/aac0daa81f9c5e936d4ef014871cdcac.jpg"><br><br>  When powered at 6V, they are able to cope with a maximum load of 12.5 kg / cm, which is enough for a robot with an estimated mass of 2 kg.  And the stock in the Chinese servah is necessary, since the quality of them leaves much to be desired.  Some of them work with extraneous sounds from the very beginning.  They also have a fairly large backlash and curved axes.  But for $ 10 apiece - this is acceptable. <br><br>  Aluminum disk fasteners on the shaft were purchased for servam to increase the strength and elasticity of the structure: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9f3/cce/433/9f3cce4335199bfba1244896928b4d7d.jpg"><br><br><h4>  Creating 3d models in SolidWorks and manufacturing parts </h4><br>  Thus, having decided on a basic set of component parts, I began to create a 3d drawing using SolidWorks.  Here's a render of what happened (I didn‚Äôt draw all the screws): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b70/f31/ca4/b70f31ca455b3826fb5019c1ab2c9eae.jpg"><br><br>  Separately, probably, it is worth stopping at some details and knots.  In addition to flat parts, of particular difficulty were the parts obtained by bending: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/11b/144/a6c/11b144a6ce873fccf98585743e00119e.jpg"><br><br>  A scan of these parts is obtained using a special tool in SolidWorks.  They are cut from a sheet of aluminum 2 mm, removed from the body of an unnecessary device.  It was flexible, so the aluminum grade was apparently suitable for this.  The problem to bend all the parts in the same way and exactly was solved with the help of a special tool, a vice and a hammer.  It turned out even better than I expected from the manual method of manufacturing. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/398/e50/f99/398e50f99adfeba099ee6234dec63011.jpg"><br><br>  The next item is the sleeves on the side of the servo opposite from the shaft.  Through these bushings the servos are mounted in the bottom of the frame. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bc1/eb0/8bb/bc1eb08bbf86922c69bd2a216642c824.jpg"><br><br>  Sleeves are necessary for uniform distribution of the load on the two plates of the frame, otherwise the servo shaft may be bent.  The sleeves are made on the same milling machine from caprolon - a polymer used in anti-friction parts. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f9d/a1e/d62/f9da1ed62552119249ea8288747c207e.jpg"><br><br>  And the last thing worth staying at is the details on the ends of the legs. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4bd/d4e/492/4bdd4e492b56a52090e2234dbbcaed50.jpg"><br><br>  They are printed on a 3D plastic ABS printer.  Next, rubber feet for instrument cases are glued into their round grooves.  The result is a complete part, contributing to increased friction of contact with the surface.  Without them, the ratio of inertia of the robot and the "tenacity" of the legs, leads to the slipping of the latter when walking and other actions on any flat surface. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9ed/ed1/6d9/9eded16d97032bc90de140a57d212c5e.jpg"><br><br>  The remaining flat parts are made of duralumin with a thickness of 2.2 mm. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/00b/45f/48c/00b45f48caee46174f554d8f3da7ccd8.jpg"><br><br><h4>  Build robot </h4><br>  The assembly took place in several stages.  This is due to the debugging of its individual parts.  At first, only chassis with a servo controller were assembled, and control was exercised from the amd64 desktop computer via USB.  Then there was a BBB with a hub, and last of all - a battery with stabilizers and IMU. <br><br>  In the photo - the various stages of assembly and the final result. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ca3/810/093/ca3810093f3e3cd6d601c48412c40fa4.jpg"><br><img src="https://habrastorage.org/getpro/habr/post_images/cc4/45b/4ca/cc445b4ca8594e256cf5e0b68a41ac4d.jpg"><br><img src="https://habrastorage.org/getpro/habr/post_images/f85/007/222/f85007222e24ded044a5f23b09aac223.jpg"><br><img src="https://habrastorage.org/getpro/habr/post_images/0b7/7b3/2be/0b77b32bea9b7202cb072236124f8f69.jpg"><br><br><h4>  Beaglebone </h4><br>  On the BBB installed Ubuntu 13.04 system from the finished <a href="http://www.armhf.com/boards/beaglebone-black/">image</a> .  Today this distribution is not available for download, but there is only the latest and LTS.  Kernel version 3.8. <br><br>  eMMC was stitched through a microSD card.  The easiest way to write an image to a USB flash drive is with Image Writer for Windows.  Instructions for the firmware can be found <a href="http://elinux.org/BeagleBoardUbuntu">here</a> . <br><br>  Now about the initialization of the UART in the BBB.  This is done through the Device Tree Compiler (DTC) and more details can be found <a href="http://hipstercircuits.com/enable-serialuarttty-on-beaglebone-black/">here</a> .  You can install on the BBB in this way: <br><br> <code>wget -c https://raw.github.com/RobertCNelson/tools/master/pkgs/dtc.sh <br> chmod +x dtc.sh <br> ./dtc.sh</code> <br> <br>  Taken <a href="http://eewiki.net/display/linuxonarm/BeagleBone">from here</a> . <br><br>  After Rx and Tx UART appeared on pins P9_11 and P9_13 (in the case of uart5), you can transfer data.  And in order to change the bitrate, the stty utility is used.  It is launched through a script, before starting work with the servo controller: <br><br> <code>stty -F /dev/ttyO4 cs8 115200</code> <br> <br>  On the controller, the speed is set via the <a href="http://www.pololu.com/product/1354/resources">Maestro Control Center</a> . <br><br>  To make the UART ‚Äústart up‚Äù every time you start the system, you should add a line <br> <code>sudo bash -c "echo enable-uart5 &gt; /sys/devices/bone_capemgr.*/slots"</code> <br>  in rc.local. <br><br>  As described above, IMU uses the I2C interface.  I2C on BBB works by default, no additional action is required to run it.  But before writing the ROS node for IMU, it was useful to verify that the interface was connected correctly using the i2c-tools utility for Linux.  Understanding I2C still helped <a href="http://www.youtube.com/watch%3Fv%3D8C2zk6B-eLU%26list%3DPLF4A1A7E09E5E260A">video</a> . <br><br>  A big problem was to make the bluetooth joystick work normally.  Connecting it was not difficult - all in accordance with the description of the <a href="http://wiki.ros.org/ps3joy%3Fdistro%3Dhydro">ps3joy</a> node and the <a href="http://wiki.ros.org/ps3joy/Tutorials/PairingJoystickAndBluetoothDongle">tutorial</a> to it.  Only the driver for the joystick, starting with version 3.5 of the kernel, began to receive events from a device with a low frequency: about 5 Hz.  This is not enough for normal control.  The problem is just mentioned <a href="http://answers.ros.org/question/102676/ps3joy-slow-output/%3Fanswer%3D118376">here</a> .  Therefore, having tried a bunch of other drivers, I found one worker for arm-linux.  This is a sixad driver.  But to make it to the BBB, it must be collected manually.  This was done for the Raspberry PI and is described in detail <a href="http://booting-rpi.blogspot.ro/2012/08/dualshock-3-and-raspberry-pi.html">here</a> .  When compiling for some reason, I got an error: <br><br> <code>error: ... was not declared in this scope</code> <br> <br>  It was resolved by adding a header unistd.h to each driver source file. <br><br>  After the driver is assembled and installed, the gamepad still did not connect right away.  This was decided by changing the bluetooth configuration: <br><br> <code>echo "DisablePlugins = input" &gt;&gt; /etc/bluetooth/main.conf</code> <br> <br>  After that, you could start the driver as a daemon and freely connect the joystick by pressing the PS3 button. <br><br>  USB Wi-Fi works out of the box.  In order for the client to connect to the router, you need to change the fields in / etc / network / interfaces: <br><br> <code>wpa-ssid "" <br> wpa-psk ""</code> <br> <br><h4>  Ros </h4><br>  For starters, ROS was installed on a desktop computer.  The version of the distribution kit of Hydro Desktop-Full, was installed without problems on Ubuntu 13.04.  On the "big" computer, it is convenient to debug the written nodes and the kinematic model in the ROS visualization tools.  In addition, the compilation is much faster than on the BBB.  Therefore, everything was developed on a computer, and then only transferred to the BBB and compiled there.  Unfortunately, cross-compiling for ROS is still a difficult task. <br><br>  For visualization there is a handy tool - <a href="http://wiki.ros.org/rviz">rviz</a> .  It was used to view the resulting model and how it behaves when driving.  To do this, there is a <a href="http://wiki.ros.org/joint_state_publisher%3Fdistro%3Dhydro">joint_state_publisher</a> - a package containing configuration tools and changing the position of the "joints" and a <a href="http://wiki.ros.org/robot_state_publisher">robot_state_publisher</a> - a package that translates the position of the robot in <a href="http://wiki.ros.org/tf">tf</a> .  The model itself is contained in the <a href="http://wiki.ros.org/urdf/XML/model">URDF</a> file.  It describes all the segments (links) and their joints, as well as their relative position.  For clarity, attached 3d models of parts in STL format.  But since the robot contains duplicate parts (legs), it is convenient to use the <a href="http://wiki.ros.org/xacro">XACRO</a> format (XML Macros), which is then converted to URDF.  The main advantages of XACRO: the presence of macros, mathematical operations and constants.  Thus, it is possible to minimize the code describing the model of the robot.  The figure shows the structure and visualization of the model in rviz. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f5e/927/a79/f5e927a79bbe5641b3d602546ff669ef.png"><br><img src="https://habrastorage.org/getpro/habr/post_images/ff0/456/84f/ff045684f662e75ec82193140a4ee1ff.png"><br><br>  When writing the basic nodes in C ++, the IDE Eclipse Kepler was used.  About the configuration of Eclipse can be read <a href="http://wiki.ros.org/IDEs">here</a> .  In general, before starting it is worthwhile to get acquainted with the <a href="http://wiki.ros.org/ROS/Tutorials">textbook</a> , <a href="http://wiki.ros.org/roscpp/Overview">roscpp</a> and <a href="http://wiki.ros.org/catkin/Tutorials">catkin</a> . <br><br><h4>  Software development </h4><br>  In this article the code of nodes will not be described, only their general structure and purpose will be presented.  Learn more about writing code in the next article. <br><br>  So, the general scheme of the structure of ROS nodes on the BBB (in ellipses - the name of the nodes, in the rectangles - the name of the topics): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3f0/628/603/3f0628603ae2ec916d8c07f0632b1940.png"><br><br>  <i>joy_node</i> is a complete <a href="http://wiki.ros.org/joy">package</a> that allows you to convert data from a standard Linux device file (/ dev / input / js) into ‚Äú <a href="http://docs.ros.org/api/sensor_msgs/html/msg/Joy.html">Joy</a> ‚Äù messages and translate them into ROS topics.  It will be useful to look in the <a href="http://wiki.ros.org/joy/Tutorials">tutorial</a> package.  Almost always they contain many answers to questions. <br><br>  <i>crab_teleop_joy</i> is the node that processes data from the joystick and converts it into messages to control the hexapod.  For example, from the position along the two axes of the ‚Äúanalog‚Äù handle, the course angle is calculated, and its distance from the center affects the stride length.  These values ‚Äã‚Äãare then used in the gait generator.  Also builds the logic of using certain combinations and sequences of keystrokes.  Received messages are transmitted further in three topics. <br><br>  <i>crab_leg_kinematics</i> is a service node.  Its purpose is to solve the inverse kinematics problem, that is, based on the coordinates of the end-effector (in my case, these are the tips of the legs), calculate the angles of the position of the joints (the angles of the servo drives).  The request to the service is formed in the form of six vectors of the target position of the tips of the legs, and the answer comes in the form of the 18 angles of the servos.  Written node using Kinematics and Dynamics Library ( <a href="http://www.orocos.org/kdl">KDL</a> ), which is integrated into ROS.  The node clients are crab_body_kinematics and crab_gait. <br><br>  <i>crab_body_kinematics</i> - calculates the vectors of the ends of the legs based on the URDF robot model and data from a message that contains the desired linear and angular deviations of the frame from the initial position, as well as the radius of the legs.  Also implemented are the lifting commands from the starting position (when the robot lies on the frame and the legs are folded) and return to the starting position. <br><br>  <i>crab_gait</i> is a node that generates position vectors for the ends of the legs for the implementation of two types of gait.  At the entrance there are messages containing commands about the type and state of the gait (to go / stand) and the values ‚Äã‚Äãof control: course and trot angles and step size.  The types of gait are tripod and ripple: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/29c/f8c/c42/29cf8cc422a44e96db7888f7de3bad11.gif"><br><br>  The tripod-type gait is faster, but at the same time the load on the central legs is greater than on the front and back, which has a bad effect on the lifespan of the serv. <br><br>  The control is carried out with the help of two ‚Äúanalog‚Äù joystick knobs: the left one - changing course while constantly ransacking (moving with ‚Äúcrab‚Äù), the right one ‚Äî changing course with changing yaw (moving back and forth and left-right). <br><br>  <i>crab_imu</i> - MinIMU-9 driver, assembled from parts of an Arduino <a href="https://github.com/pololu/minimu-9-ahrs-arduino">sketch</a> .  Contains an algorithm for calculating Euler angles based on data from MEMS sensors.  Also contains a simple P-regulator, forming effects, compensating for deviations in pitch and roll.  These impacts are transmitted through the topic move_body in crab_body_kinematics to set the desired position of the legs. <br><br>  <i>crab_maestro_controller</i> - the last driver node for the Mini Maestro.  At the entrance it has 18 angular positions of the servos, which it converts into the communication protocol of the servo controller over the UART. <br><br>  The structural diagram of the visualization is slightly different from the scheme of the robot system.  In the visualization, all the same nodes except for the crab_maestro_controller node, which are replaced by the crab_joint_publisher, joint_state_publisher, robot_state_publisher, and tf nodes. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1e0/fca/5d8/1e0fca5d84b8b6eddeeb4a5bda364f5a.png"><br><br>  About the latter was written above. <br><br>  <i>crab_joint_publisher</i> - converts messages intended for the controller into messages " <a href="http://docs.ros.org/api/sensor_msgs/html/msg/JointState.html">JointState</a> ", which are fed to the input joint_state_publisher. <br><br>  Now about some stages of development with video. <br><br>  First, all control of the hexapod was carried out from a computer.  The beginning was the test of inverse kinematics by drawing the circumference of one of the legs: <br><br><iframe width="560" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/3rkO14nn4eg%3Ffeature%3Doembed&amp;xid=17259,15700022,15700186,15700191,15700253&amp;usg=ALkJrhj2CJuMLEJEhDXEU6NHZB5mL_ROWw" frameborder="0" allowfullscreen=""></iframe><br><br>  Then collected parts of the control position and orientation of the body: <br><br><iframe width="560" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/RJ-zKuPNle4%3Ffeature%3Doembed&amp;xid=17259,15700022,15700186,15700191,15700253&amp;usg=ALkJrhjDQqsWcBELgmyDseU4oRK6wq6nTA" frameborder="0" allowfullscreen=""></iframe><br><br>  And the embodiment of this on this robot: <br><br><iframe width="560" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/iU8GSZwm9Uc%3Ffeature%3Doembed&amp;xid=17259,15700022,15700186,15700191,15700253&amp;usg=ALkJrhimF1OdUjS3_yMpQ8afRezPLFuC8w" frameborder="0" allowfullscreen=""></iframe><br><br>  After that, I started all this on the BBB and tested the IMU node: <br><br><iframe width="560" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/k-Qet1F_yA8%3Ffeature%3Doembed&amp;xid=17259,15700022,15700186,15700191,15700253&amp;usg=ALkJrhjdLahM0feFVLfge-xkSaiwC_p2Bw" frameborder="0" allowfullscreen=""></iframe><br><br>  Then the robot went ripple gait, controlled with a joystick: <br><br><iframe width="560" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/_YcTqrvvSBw%3Ffeature%3Doembed&amp;xid=17259,15700022,15700186,15700191,15700253&amp;usg=ALkJrhgHH3pYA1OmZnle12TFHKpTXKwP7g" frameborder="0" allowfullscreen=""></iframe><br><br>  And at the end of the possibility of a hexapod today: <br><br><iframe width="560" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/MAnXVhC6eX0%3Ffeature%3Doembed&amp;xid=17259,15700022,15700186,15700191,15700253&amp;usg=ALkJrhgzvg2O2zt9VgPqiY2OA_AA4VZrmQ" frameborder="0" allowfullscreen=""></iframe><br><br><h4>  Conclusion </h4><br>  Creating a hexapod was a very interesting process, and the ROS capabilities and BeagleBone Black performance allow you to add and improve the software component of the robot.  In this article, I wanted to show first of all the possibilities of convenient development using ROS, and also to pay attention to what tools were used to create the robot, without going into details.  At the initial stage, it was most difficult to figure out where to start and what means to use.  I hope this article will help to navigate in choosing the path of development. <br><br>  PS project sources on <a href="https://github.com/tuuzdu/crab_project">github</a> </div><p>Source: <a href="https://habr.com/ru/post/225845/">https://habr.com/ru/post/225845/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../225827/index.html">Learning to understand the art of programming</a></li>
<li><a href="../225829/index.html">The method of self-determination of the response time of the LCD monitor screen or TV</a></li>
<li><a href="../225831/index.html">Algorithm for finding the smallest covering capacity of a finite set of its subsets</a></li>
<li><a href="../225837/index.html">Notification during call pickup in Asterisk</a></li>
<li><a href="../225841/index.html">Swift programming language. Russian version</a></li>
<li><a href="../225847/index.html">ImEx.js will decorate your code</a></li>
<li><a href="../225849/index.html">Cisco has updated the product line of video communications equipment</a></li>
<li><a href="../225851/index.html">Phalcon Framework in production</a></li>
<li><a href="../225853/index.html">CoreMark processor rating</a></li>
<li><a href="../225855/index.html">Nokia and SEL introduced a new type of flexible OLED display.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>