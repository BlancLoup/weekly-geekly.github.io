<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Shake Detector for Android on RxJava</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 
 It all started with the fact that the task was set to cancel the last action in the application when shaking the device. But how to und...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Shake Detector for Android on RxJava</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/ed9/7ad/009/ed97ad009b704fa4a0191e43688854b5.jpg"><br><br><h1>  Introduction </h1><br>  It all started with the fact that the task was set to cancel the last action in the application when shaking the device.  But how to understand what happened this shaking?  After a couple of minutes of studying the issue, it became clear that we had to subscribe to events from the accelerometer and then try to somehow determine that the device had been shaken. <br>  Ready solutions were also found.  They were all quite similar, but in their pure form they did not suit me, and I wrote my own ‚Äúbicycle‚Äù.  It was a class that subscribed to events from the sensor and changed its state as they arrived.  Then a couple of times my colleagues and I twirled the gears of this bike, and as a result, it began to resemble something from Mad Max.  I promised that, as the free time will stand out, I will bring this outrage in order. <br><br>  And here, reading recently articles on RxJava, I remembered about this task.  ‚ÄúHmm,‚Äù I thought, ‚ÄúRxJava looks like a very suitable tool for this kind of problem.‚Äù  Without delay, he took and wrote a solution on RxJava.  The result struck me: all the logic took 8 (eight!) Lines!  I decided to share my experience with other developers.  So this article was born. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      I hope this simple example will help those who are thinking about using RxJava in their projects to make a decision. <br><br>  The article is aimed at readers with basic experience in developing for Android.  The source code of the finished application can be viewed on <a href="https://github.com/ArkadyGamza/ShakeDetector">GitHub</a> . <br><br>  Let's get started! <br><a name="habracut"></a><br><br><h1>  Project Setup </h1><br><h2>  We connect RxJava to the project </h2><br>  To connect RxJava, just add to build.gradle <br><br><pre><code class="hljs cs">dependencies { ... compile <span class="hljs-string"><span class="hljs-string">'io.reactivex:rxjava:1.1.3'</span></span> compile <span class="hljs-string"><span class="hljs-string">'io.reactivex:rxandroid:1.1.0'</span></span> }</code> </pre> <br><br>  Note: RxAndroid gives us a Scheduler that is tied to a UI thread. <br><br><h2>  We include support lambda </h2><br>  RxJava is best used with lambdas, without them the code becomes hard to read.  At the moment there are two options to enable lambda support in the Android project: use the Jack compiler from the Android N Developer Preview or use the Retrolambda library. <br>  In both cases, you must first make sure that JDK 8 is installed. Personally, I used Retrolambda. <br><br><h3>  Android N Developer Preview </h3><br>  To use Jack from the Android N Developer Preview, follow the instructions <a href="http://developer.android.com/intl/ru/preview/j8-jack.html">from here.</a> <br><br>  Add to build.gradle line: <br><pre> <code class="hljs objectivec">android { ... defaultConfig { ... jackOptions { enabled <span class="hljs-literal"><span class="hljs-literal">true</span></span> } } compileOptions { sourceCompatibility JavaVersion.VERSION_1_8 targetCompatibility JavaVersion.VERSION_1_8 } }</code> </pre><br><br><h3>  Retrolambda </h3><br>  To connect retrolambda follow the <a href="https://github.com/evant/gradle-retrolambda">instructions</a> from Evan Tatarka (eng. Evan Tatarka): <br><br><pre> <code class="hljs cs">buildscript { ... dependencies { classpath <span class="hljs-string"><span class="hljs-string">'me.tatarka:gradle-retrolambda:3.2.5'</span></span> } } apply plugin: <span class="hljs-string"><span class="hljs-string">'com.android.application'</span></span> apply plugin: <span class="hljs-string"><span class="hljs-string">'me.tatarka.retrolambda'</span></span> android { compileOptions { sourceCompatibility JavaVersion.VERSION_1_8 targetCompatibility JavaVersion.VERSION_1_8 } }</code> </pre><br><br>  Please note that in the original instructions it is recommended to connect the Maven Central repository.  In your project, most likely, jcenter is already used, since this repository is specified by default when creating a project in Android Studio.  It already contains the dependencies we need, and additionally connecting Maven Central is not required. <br><br><h1>  Observable </h1><br>  So, we have all the necessary tools connected to the project, we can begin development. <br><br>  When using RxJava, it all starts with getting <a href="http://reactivex.io/documentation/observable.html">Observable</a> . <br>  Let's write a factory that creates an Observable, subscribing to the events of a passed sensor using the <a href="http://reactivex.io/documentation/operators/create.html">Observable.create</a> method: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SensorEventObservableFactory</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Observable&lt;SensorEvent&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createSensorEventObservable</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NonNull Sensor sensor, @NonNull SensorManager sensorManager)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Observable.create(subscriber -&gt; { MainThreadSubscription.verifyMainThread(); SensorEventListener listener = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SensorEventListener() { <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onSensorChanged</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(SensorEvent event)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (subscriber.isUnsubscribed()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } subscriber.onNext(event); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onAccuracyChanged</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sensor sensor, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> accuracy)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// NO-OP } }; sensorManager.registerListener(listener, sensor, SensorManager.SENSOR_DELAY_GAME); // unregister listener in main thread when being unsubscribed subscriber.add(new MainThreadSubscription() { @Override protected void onUnsubscribe() { sensorManager.unregisterListener(listener); } }); }); } }</span></span></code> </pre><br><br>  Now we have a tool to convert events from any sensor into Observable.  But which sensor is best suited for our purposes?  In the screenshot below, the first chart displays the <a href="http://developer.android.com/reference/android/hardware/Sensor.html">readings of the TYPE_GRAVITY sensor</a> , the second chart <a href="http://developer.android.com/reference/android/hardware/Sensor.html">shows the TYPE_ACCELEROMETER</a> , and the third <a href="http://developer.android.com/reference/android/hardware/Sensor.html">shows the TYPE_LINEAR_ACCELERATION</a> .  It is seen that at first the device was turned smoothly, and then sharply shaken. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/d61/55d/e23/d6155de23e354cd4972b42276f12b9df.png"></div><br><br>  We are interested in sensor events with the type Sensor.TYPE_LINEAR_ACCELERATION.  It contains acceleration values ‚Äã‚Äãfrom which the component of terrestrial gravity has already been subtracted. <br><br>  Curiously, many solutions use Sensor.TYPE_ACCELEROMETER and apply high pass filtering to remove the gravitational component.  If you guess why - please share your knowledge in the comments. <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@NonNull</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Observable&lt;SensorEvent&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createAccelerationObservable</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NonNull Context context)</span></span></span><span class="hljs-function"> </span></span>{ SensorManager mSensorManager = (SensorManager) context.getSystemService(Context.SENSOR_SERVICE); List&lt;Sensor&gt; sensorList = mSensorManager.getSensorList(Sensor.TYPE_LINEAR_ACCELERATION); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sensorList == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> || sensorList.isEmpty()) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IllegalStateException(<span class="hljs-string"><span class="hljs-string">"Device has no linear acceleration sensor"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SensorEventObservableFactory.createSensorEventObservable(sensorList.get(<span class="hljs-number"><span class="hljs-number">0</span></span>), mSensorManager); }</code> </pre><br><br><h1>  Reactive magic </h1><br>  Now that we have an Observable with accelerometer events, we can use the full power of the RxJava operators. <br><br>  Let's see what the raw sequence of events looks like: <br><pre> <code class="java hljs">createAccelerationObservable(context) .subscribe(event -&gt; Log.d(TAG, formatTime(event) + <span class="hljs-string"><span class="hljs-string">" "</span></span> + Arrays.toString(event.values))); <span class="hljs-number"><span class="hljs-number">29.398</span></span> [<span class="hljs-number"><span class="hljs-number">0.0016835928</span></span>, <span class="hljs-number"><span class="hljs-number">0.014868498</span></span>, <span class="hljs-number"><span class="hljs-number">0.0038280487</span></span>] <span class="hljs-number"><span class="hljs-number">29.418</span></span> [-<span class="hljs-number"><span class="hljs-number">0.026405454</span></span>, -<span class="hljs-number"><span class="hljs-number">0.017675579</span></span>, <span class="hljs-number"><span class="hljs-number">0.024353027</span></span>] <span class="hljs-number"><span class="hljs-number">29.438</span></span> [-<span class="hljs-number"><span class="hljs-number">0.032944083</span></span>, -<span class="hljs-number"><span class="hljs-number">0.0029007196</span></span>, <span class="hljs-number"><span class="hljs-number">0.011956215</span></span>] <span class="hljs-number"><span class="hljs-number">29.458</span></span> [<span class="hljs-number"><span class="hljs-number">0.03226435</span></span>, <span class="hljs-number"><span class="hljs-number">0.022876084</span></span>, <span class="hljs-number"><span class="hljs-number">0.032211304</span></span>] <span class="hljs-number"><span class="hljs-number">29.478</span></span> [-<span class="hljs-number"><span class="hljs-number">0.0011371374</span></span>, <span class="hljs-number"><span class="hljs-number">0.022291958</span></span>, -<span class="hljs-number"><span class="hljs-number">0.054023743</span></span>]</code> </pre><br><br>  We see that every 20 milliseconds an event arrives from the sensor.  This frequency corresponds to the value of SensorManager.SENSOR_DELAY_GAME, which was sent as the samplingPeriodUs parameter during the registration of SensorEventListener. <br><br>  As a payload comes the value of acceleration in all three axes. <br>  We are only interested in the values ‚Äã‚Äãon the X axis. They correspond to the movement that we want to track.  Some solutions use acceleration values ‚Äã‚Äãalong all three axes, so they work, for example, when the device is placed on the table (significant acceleration along the Z axis when in contact with the table). <br>  Create a data class with values ‚Äã‚Äãof interest to us: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">XEvent</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> timestamp; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> x; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">XEvent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> timestamp, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.timestamp = timestamp; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x = x; } }</code> </pre><br><br>  We convert SensorEvent to XEvent and filter events for which the magnitude of the acceleration modulo exceeds a certain threshold: <br><pre> <code class="java hljs">createAccelerationObservable(context) .map(sensorEvent -&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> XEvent(sensorEvent.timestamp, sensorEvent.values[<span class="hljs-number"><span class="hljs-number">0</span></span>])) .filter(xEvent -&gt; Math.abs(xEvent.x) &gt; THRESHOLD) .subscribe(xEvent -&gt; Log.d(TAG, formatMsg(xEvent)));</code> </pre><br><br>  To see events in the log, you have to shake the device for the first time. <br><br>  In general, the process of debugging Shake Detection from the outside looks pretty funny: the developer is sitting and the phone is shaking all the time.  I do not know what others think about this :) <br><pre> <code class="java hljs"><span class="hljs-number"><span class="hljs-number">55.347</span></span> <span class="hljs-number"><span class="hljs-number">19.030302</span></span> <span class="hljs-number"><span class="hljs-number">55.367</span></span> <span class="hljs-number"><span class="hljs-number">13.084376</span></span> <span class="hljs-number"><span class="hljs-number">55.388</span></span> -<span class="hljs-number"><span class="hljs-number">15.775546</span></span> <span class="hljs-number"><span class="hljs-number">55.408</span></span> -<span class="hljs-number"><span class="hljs-number">14.443999</span></span></code> </pre><br><br>  Only events with significant acceleration along the X axis are left in the log. <br><br>  Now the most interesting: we track the moments when the acceleration has changed the sign.  Let's try to understand what this moment is.  For example, at first we accelerate the hand with the phone to the left, while acceleration has a negative projection on the X axis. Then we stop the hand - at this moment the projection on the X axis changes the sign to a positive one.  That is, on one stroke, there is one change of the sign of the projection. <br>  To do this, we first create a sliding window that will contain each event with an event preceding it: <br><pre> <code class="java hljs">createAccelerationObservable(context) .map(sensorEvent -&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> XEvent(sensorEvent.timestamp, sensorEvent.values[<span class="hljs-number"><span class="hljs-number">0</span></span>])) .filter(xEvent -&gt; Math.abs(xEvent.x) &gt; THRESHOLD) .buffer(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) .subscribe(buf -&gt; Log.d(TAG, getLogMsg(buf)));</code> </pre><br><br>  We look at the log: <br><pre> <code class="java hljs">[<span class="hljs-number"><span class="hljs-number">43.977</span></span> -<span class="hljs-number"><span class="hljs-number">15.497713</span></span>; <span class="hljs-number"><span class="hljs-number">44.017</span></span> <span class="hljs-number"><span class="hljs-number">21.000145</span></span>] [<span class="hljs-number"><span class="hljs-number">44.017</span></span> <span class="hljs-number"><span class="hljs-number">21.000145</span></span>; <span class="hljs-number"><span class="hljs-number">44.037</span></span> <span class="hljs-number"><span class="hljs-number">19.947767</span></span>] [<span class="hljs-number"><span class="hljs-number">44.037</span></span> <span class="hljs-number"><span class="hljs-number">19.947767</span></span>; <span class="hljs-number"><span class="hljs-number">44.057</span></span> <span class="hljs-number"><span class="hljs-number">19.836182</span></span>] [<span class="hljs-number"><span class="hljs-number">44.057</span></span> <span class="hljs-number"><span class="hljs-number">19.836182</span></span>; <span class="hljs-number"><span class="hljs-number">44.077</span></span> <span class="hljs-number"><span class="hljs-number">20.659754</span></span>] [<span class="hljs-number"><span class="hljs-number">44.077</span></span> <span class="hljs-number"><span class="hljs-number">20.659754</span></span>; <span class="hljs-number"><span class="hljs-number">44.098</span></span> -<span class="hljs-number"><span class="hljs-number">16.811298</span></span>] [<span class="hljs-number"><span class="hljs-number">44.098</span></span> -<span class="hljs-number"><span class="hljs-number">16.811298</span></span>; <span class="hljs-number"><span class="hljs-number">44.118</span></span> -<span class="hljs-number"><span class="hljs-number">15.6345</span></span></code> </pre><br><br>  Fine!  We see that each event is grouped with the previous one; now it is easy to filter out pairs of events with different acceleration signs: <br><pre> <code class="java hljs"> createAccelerationObservable(context) .map(sensorEvent -&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> XEvent(sensorEvent.timestamp, sensorEvent.values[<span class="hljs-number"><span class="hljs-number">0</span></span>])) .filter(xEvent -&gt; Math.abs(xEvent.x) &gt; THRESHOLD) .buffer(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) .filter(buf -&gt; buf.get(<span class="hljs-number"><span class="hljs-number">0</span></span>).x * buf.get(<span class="hljs-number"><span class="hljs-number">1</span></span>).x &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) .subscribe(buf -&gt; Log.d(TAG, getLogMsg(buf)));</code> </pre><br><br><pre> <code class="java hljs">[<span class="hljs-number"><span class="hljs-number">53.888</span></span> -<span class="hljs-number"><span class="hljs-number">16.762777</span></span>; <span class="hljs-number"><span class="hljs-number">53.928</span></span> <span class="hljs-number"><span class="hljs-number">20.83315</span></span>] [<span class="hljs-number"><span class="hljs-number">53.988</span></span> <span class="hljs-number"><span class="hljs-number">19.87952</span></span>; <span class="hljs-number"><span class="hljs-number">54.028</span></span> -<span class="hljs-number"><span class="hljs-number">16.735554</span></span>] [<span class="hljs-number"><span class="hljs-number">54.089</span></span> -<span class="hljs-number"><span class="hljs-number">16.46596</span></span>; <span class="hljs-number"><span class="hljs-number">54.109</span></span> <span class="hljs-number"><span class="hljs-number">21.682497</span></span>] [<span class="hljs-number"><span class="hljs-number">54.169</span></span> <span class="hljs-number"><span class="hljs-number">20.355597</span></span>; <span class="hljs-number"><span class="hljs-number">54.209</span></span> -<span class="hljs-number"><span class="hljs-number">16.634022</span></span>] [<span class="hljs-number"><span class="hljs-number">54.269</span></span> -<span class="hljs-number"><span class="hljs-number">16.122211</span></span>; <span class="hljs-number"><span class="hljs-number">54.309</span></span> <span class="hljs-number"><span class="hljs-number">21.806463</span></span>]</code> </pre><br><br>  Each event now corresponds to one stroke.  Only 4 operators, and we are already able to track the sharp movements!  But let's not stop, because if the detector triggers on one stroke, then false alarms are possible.  For example, the user was not going to shake the device, but simply shifted it into his other hand.  The solution is simple - you need to force the user to shake the device several times within a short period of time.  Enter the parameters SHAKES_COUNT = number of strokes and SHAKES_PERIOD = time interval for which it is necessary to have time to make the required number of strokes.  Experimentally it turned out that the comfort parameters are 3 strokes in 1 second.  Otherwise, random triggers are possible, or you just have to shake the phone very violently. <br><br>  So, we want to track the moment when 3 strokes occurred in one second. <br>  Note that we no longer need the acceleration values, leave only the time the event occurred, at the same time we translate the time from nanoseconds to seconds: <br><pre> <code class="java hljs">.map(buf -&gt; buf.get(<span class="hljs-number"><span class="hljs-number">1</span></span>).timestamp / <span class="hljs-number"><span class="hljs-number">1000000000f</span></span>)</code> </pre><br>  Then apply the already familiar technique with a sliding window.  For each event we will return an array containing this event and two previous ones: <br><pre> <code class="java hljs">.buffer(SHAKES_COUNT, <span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre><br>  And finally, we will leave only those triples of events that happened in 1 second: <br><pre> <code class="java hljs">.filter(buf -&gt; buf.get(SHAKES_COUNT - <span class="hljs-number"><span class="hljs-number">1</span></span>) - buf.get(<span class="hljs-number"><span class="hljs-number">0</span></span>) &lt; SHAKES_PERIOD)</code> </pre><br>  If the event passed the last filter, it means that the user waved the device 3 times in the last second. <br>  But suppose that our user is carried away and continues to shake the phone diligently.  Then we will receive events for each next wave, and we want to receive an event only for every 3 strokes.  A simple solution would be to ignore events for 1 second after the gesture was defined. <br><pre> <code class="java hljs">.throttleFirst(SHAKES_PERIOD, TimeUnit.SECONDS)</code> </pre><br>  Done!  Now the Observable obtained can be used where we want to wait for a shake event. <br><br>  Here is the final code for creating an Observable: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ShakeDetector</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> THRESHOLD = <span class="hljs-number"><span class="hljs-number">13</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> SHAKES_COUNT = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> SHAKES_PERIOD = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-meta"><span class="hljs-meta">@NonNull</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Observable&lt;?&gt; create(<span class="hljs-meta"><span class="hljs-meta">@NonNull</span></span> Context context) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> createAccelerationObservable(context) .map(sensorEvent -&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> XEvent(sensorEvent.timestamp, sensorEvent.values[<span class="hljs-number"><span class="hljs-number">0</span></span>])) .filter(xEvent -&gt; Math.abs(xEvent.x) &gt; THRESHOLD) .buffer(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) .filter(buf -&gt; buf.get(<span class="hljs-number"><span class="hljs-number">0</span></span>).x * buf.get(<span class="hljs-number"><span class="hljs-number">1</span></span>).x &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) .map(buf -&gt; buf.get(<span class="hljs-number"><span class="hljs-number">1</span></span>).timestamp / <span class="hljs-number"><span class="hljs-number">1000000000f</span></span>) .buffer(SHAKES_COUNT, <span class="hljs-number"><span class="hljs-number">1</span></span>) .filter(buf -&gt; buf.get(SHAKES_COUNT - <span class="hljs-number"><span class="hljs-number">1</span></span>) - buf.get(<span class="hljs-number"><span class="hljs-number">0</span></span>) &lt; SHAKES_PERIOD) .throttleFirst(SHAKES_PERIOD, TimeUnit.SECONDS); } <span class="hljs-meta"><span class="hljs-meta">@NonNull</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Observable&lt;SensorEvent&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createAccelerationObservable</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NonNull Context context)</span></span></span><span class="hljs-function"> </span></span>{ SensorManager mSensorManager = (SensorManager) context.getSystemService(Context.SENSOR_SERVICE); List&lt;Sensor&gt; sensorList = mSensorManager.getSensorList(Sensor.TYPE_LINEAR_ACCELERATION); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sensorList == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> || sensorList.isEmpty()) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IllegalStateException(<span class="hljs-string"><span class="hljs-string">"Device has no linear acceleration sensor"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SensorEventObservableFactory.createSensorEventObservable(sensorList.get(<span class="hljs-number"><span class="hljs-number">0</span></span>), mSensorManager); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">XEvent</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> timestamp; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> x; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">XEvent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> timestamp, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.timestamp = timestamp; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x = x; } } }</code> </pre><br><br><h1>  Using </h1><br>  In the example, I play the sound when an event occurs. <br>  In Activity, where we want to listen to shaking, add a field: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Observable&lt;?&gt; mShakeObservable;</code> </pre><br><br>  Initialize it to onCreate: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCreate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Bundle savedInstanceState)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mShakeObservable = ShakeDetector.create(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }</code> </pre><br><br>  Sign up for events in onResume: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onResume</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onResume(); mShakeSubscription = mShakeObservable.subscribe((object) -&gt; Utils.beep()); }</code> </pre><br><br>  And don't forget to unsubscribe in onPause: <br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onPause</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onPause(); mShakeSubscription.unsubscribe(); }</code> </pre><br><br><h1>  Conclusion </h1><br>  As you can see, we were able to write a solution in several lines that reliably determines the gesture we specified.  The code is compact, easy to read and maintain.  Compare with the solution without RxJava, say, <a href="https://github.com/square/seismic">Seismic</a> from Jake Wharton (Eng. Jake Wharton).  RxJava is a great tool, and if applied skillfully and to the point, you can get excellent results.  I hope that this article will push you to learn RxJava and apply reactive programming approaches in your projects. <br><br>  Be with you at <a href="http://stackoverflow.com/">stackoverflow.com</a> ! <br><br>  Arkady Gamza, Android Developer. </div><p>Source: <a href="https://habr.com/ru/post/304488/">https://habr.com/ru/post/304488/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../304474/index.html">How to level the Pyramid of death</a></li>
<li><a href="../304476/index.html">The base of free Github repositories is available through the interface BigQuery</a></li>
<li><a href="../304482/index.html">Cross-platform use of .Net classes from unmanaged code. Or analogue IDispatch on Linux</a></li>
<li><a href="../304484/index.html">VDI for all: VMware Horizon 7 specification</a></li>
<li><a href="../304486/index.html">iMessage in iOS 10: New Opportunities for Developers</a></li>
<li><a href="../304490/index.html">Why do video surveillance developers love retail more than production?</a></li>
<li><a href="../304492/index.html">Translation of C ++ project for development with unit testing / TDD</a></li>
<li><a href="../304496/index.html">Kodogenerator-based music generator</a></li>
<li><a href="../304502/index.html">Mathematical notation: Past and Future</a></li>
<li><a href="../304504/index.html">CRM communications</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>