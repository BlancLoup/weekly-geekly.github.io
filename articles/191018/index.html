<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Five pitfalls when using shared_ptr</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The shared_ptr class is a handy tool that can solve a lot of developer problems. However, in order not to make mistakes, you need to know his device p...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Five pitfalls when using shared_ptr</h1><div class="post__text post__text-html js-mediator-article">  The shared_ptr class is a handy tool that can solve a lot of developer problems.  However, in order not to make mistakes, you need to know his device perfectly.  I hope my article will be useful to those who are just starting to work with this tool. <br><br>  I will talk about the following: <br><ul><li>  what is cross-reference; </li><li>  what is dangerous unnamed shared_ptr; </li><li>  what dangers lurk when using shared_ptr in a multithreaded environment; </li><li>  what is important to remember when creating your own freeing function for shared_ptr; </li><li>  What are the features of using the enable_shared_from_this template? </li></ul><br><a name="habracut"></a><br>  The described problems take place for both boost :: shared_ptr and std :: shared_ptr.  At the end of the article you will find an application with full texts of programs written to demonstrate the described features (using the boost library as an example). <br><br><h4>  Cross reference </h4><br>  This problem is the most known and is related to the fact that the pointer shared_ptr is based on reference counting.  For an instance of an object that shared_ptr owns, a counter is created.  This counter is common to all shared_ptr pointing to this object. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/getpro/habr/post_images/ede/09d/f71/ede09df7175a46d8097a7613a576c9b3.png"><br><br>  When constructing a new object, an object with a counter is created and the value 1 is placed in it. When copying, the counter is incremented by 1. When the destructor is called (or when the pointer is replaced by assignment or reset), the counter is decreased by 1. <br><br>  Consider an example: <br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;Widget&gt; otherWidget; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;Widget&gt; a(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Widget); <span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;Widget&gt; b(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Widget); a-&gt;otherWidget = b; <span class="hljs-comment"><span class="hljs-comment">//         = 2 b-&gt;otherWidget = a; //         = 2 }</span></span></code> </pre> <br>  What happens when objects a and b leave the domain of definition?  In the destructor, references to objects will decrease.  Each object will have a counter = 1 (after all, a still points to b, and b to a).  Objects ‚Äúhold‚Äù each other and our application does not have access to them - these objects are ‚Äúlost‚Äù. <br>  To solve this problem, there is a weak_ptr.  One of the typical cases of creating cross-references is when one object owns a collection of other objects. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RootWidget</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">list</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;class Widget&gt; &gt; widgets; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RootWidget</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">parent</span></span></span><span class="hljs-class">;</span></span> };</code> </pre><br>  With this device, each Widget will prevent the removal of the RootWidget and vice versa. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/40b/36d/8a5/40b36d8a5d7ae9123fcffb6f1ce856de.png"><br><br>  In this case, you need to answer the question: ‚ÄúWho owns whom?‚Äù.  Obviously, it is RootWidget that owns Widget objects in this case, and not vice versa.  Therefore, you need to modify the example as follows: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span> weak_ptr&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RootWidget</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">parent</span></span></span><span class="hljs-class">;</span></span> };</code> </pre><br>  Weak links do not prevent the object from being deleted.  They can be converted to strong in two ways: <br><br>  1) shared_ptr constructor <br><pre> <code class="cpp hljs">weak_ptr&lt;Widget&gt; w = ‚Ä¶; <span class="hljs-comment"><span class="hljs-comment">//  ,    ,   shared_ptr    shared_ptr&lt;Widget&gt; p( w );</span></span></code> </pre><br>  2) Lock method <br><pre> <code class="cpp hljs">weak_ptr&lt;Widget&gt; w = ‚Ä¶; <span class="hljs-comment"><span class="hljs-comment">//  ,    ,  p    if( shared_ptr&lt;Widget&gt; p = w.lock() ) { //     ‚Äì     }</span></span></code> </pre><br>  <b>Conclusion:</b> <br>  In the case of ring references in the code, use weak_ptr to solve problems. <br><br><h4>  Unnamed pointers </h4><br>  The problem of nameless pointers relates to the question of ‚Äúsequence points‚Äù (sequence points) <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// shared_ptr,     foo -  foo( shared_ptr&lt;Widget&gt;(new Widget), bar() ); // shared_ptr,     foo   p shared_ptr&lt;Widget&gt; p(new Widget); foo( p, bar() );</span></span></code> </pre><br>  Of these two options, the documentation recommends that you always use the second ‚Äî give names to the pointers.  Consider an example where the bar function is defined like this: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::runtime_error(‚ÄúException from bar()‚Äù); }</code> </pre><br>  The fact is that in the first case, the design order is not defined.  It all depends on the specific compiler and compilation flags.  For example, this might happen like this: <br><ol><li>  new widget </li><li>  function call bar </li><li>  constructing shared_ptr </li><li>  function call foo </li></ol><br>  Surely, you can only be sure that the call to foo will be the last action, and the shared_ptr will be constructed after creating the object (new Widget).  However, there are no guarantees that it will be constructed immediately after the creation of the object. <br><br>  If an exception is generated during the second step (and in our example it will be generated), then Widget will be considered constructed, but shared_ptr will not own it yet.  As a result, the link to this object will be lost.  I checked this example on gcc 4.7.2.  The order of the call was such that shared_ptr + new, regardless of the compilation options, were not separated by a call to bar.  But relying on this behavior is not worth it - it is not guaranteed.  I would be grateful if the compiler prompts me, its version and compilation options, for which such code will lead to an error. <br><br>  Another way to bypass the anonymous problem shared_ptr is to use the functions make_shared or allocate_shared.  For our example, it would look like this: <br><br><pre> <code class="cpp hljs">foo( make_shared&lt;Widget&gt;(), bar() );</code> </pre><br>  This example looks even more succinctly than the original one, and also has a number of advantages in terms of memory allocation (efficiency issues will be left outside the article).  Let's call make_shared with any number of arguments.  For example, the following code will return shared_ptr on a string created through a constructor with one parameter. <br><br><pre> <code class="cpp hljs">make_shared&lt;<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt;(<span class="hljs-string"><span class="hljs-string">"shared string"</span></span>);</code> </pre><br>  <b>Conclusion:</b> <br>  Let's share the names of shared_ptr even if the code from this is less concise, or use to create objects <br>  the make_shared and allocate_shared functions. <br><br><h4>  The problem of using in different threads </h4><br>  Reference counting in shared_ptr is built using an atomic counter.  We safely use pointers to the same object from different streams.  In any case, we are not accustomed to worrying about reference counting (the thread safety of the object itself is another problem). <br><br>  Suppose we have a global shared_ptr: <br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;Widget&gt; globalSharedPtr(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Widget); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">read</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;Widget&gt; x = globalSharedPtr; <span class="hljs-comment"><span class="hljs-comment">//  -  Widget }</span></span></code> </pre><br>  Run the call to read from different threads and you will see that there are no problems in the code (as long as you are performing thread-safe operations for this class on Widget). <br><br>  Suppose there is another function: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">write</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ globalSharedPtr.reset( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Widget ); }</code> </pre><br>  The shared_ptr device is quite difficult, so I‚Äôll provide a code that will schematically help show the problem.  Of course, the real code looks different. <br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;T&gt;&amp; x) { A1: pointer = x.pointer; A2: counter = x.counter; A3: atomic_increment( *counter ); } <span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;T&gt;::reset(T* newObject) { B1: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( atomic_decrement( *counter ) == <span class="hljs-number"><span class="hljs-number">0</span></span> ) { B2: <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> pointer; B3: <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> counter; B4: } B5: pointer = newObject; B6: counter = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Counter; }</code> </pre><br>  Suppose the first thread began to copy globalSharedPtr (read), and the second thread calls reset for the same pointer instance (write).  The result may be the following: <br><ol><li>  Stream1 has just executed line A2, but has not yet moved to line A3 (atomic increment). </li><li>  Flow2 at this time reduced the counter on line B1, saw that after decreasing, the counter became zero and executed lines B2 and B3. </li><li>  Stream1 reaches line A3 and attempts to atomically increment a counter that is no longer there. </li></ol><br>  And it may be that stream1 on line A2 will have time to increase the counter before stream2 causes the objects to be deleted, but after stream2 has made the counter decrease.  Then we get a new shared_ptr pointing to the remote counter and object. <br><br>  You can write similar code: <br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;Widget&gt; globalSharedPtr(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Widget); <span class="hljs-keyword"><span class="hljs-keyword">mutex_t</span></span> globalSharedPtrMutex; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">resetGlobal</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Widget* x)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">write_lock_t</span></span> l(globalSharedPtrMutex); globalSharedPtr.reset( x ); } <span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;Widget&gt; getGlobal() { <span class="hljs-keyword"><span class="hljs-keyword">read_lock_t</span></span> l(globalSharedPtrMutex); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> globalSharedPtr; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">read</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;Widget&gt; x = getGlobal(); <span class="hljs-comment"><span class="hljs-comment">//    x    } void write() { resetGlobal( new Widget ); }</span></span></code> </pre><br>  Now, using such functions, you can safely work with this shared_ptr. <br><br>  <b>Conclusion:</b> if some instance of shared_ptr is available to different threads and can be modified, then you need to take care of synchronization of access to this instance of shared_ptr. <br><br><h4>  Singularities of the time of the destruction of the liberating functor for shared_ptr </h4><br>  This problem can occur only if you use your own exempting functor in combination with weak pointers (weak_ptr).  For example, you can create shared_ptr based on another shared_ptr by adding a new action before deleting (in fact, the ‚ÄúDecorator‚Äù template).  So you could get a pointer to work with the database, removing it from the pool of connections, and at the end of the client‚Äôs work with the pointer, bring it back to the pool. <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;Connection&gt; <span class="hljs-keyword"><span class="hljs-keyword">ptr_t</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ConnectionReleaser</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">list</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">ptr_t</span></span>&gt;&amp; whereToReturn; <span class="hljs-keyword"><span class="hljs-keyword">ptr_t</span></span> connectionToRelease; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: ConnectionReleaser(<span class="hljs-built_in"><span class="hljs-built_in">list</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">ptr_t</span></span>&gt;&amp; lst, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ptr_t</span></span>&amp; x):whereToReturn(lst), connectionToRelease(x) {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Connection*)</span></span></span><span class="hljs-function"> </span></span>{ whereToReturn.push_back( connectionToRelease ); <span class="hljs-comment"><span class="hljs-comment">//      connectionToRelease.reset(); } }; ptr_t getConnection() { ptr_t c( connectionList.back() ); connectionList.pop_back(); ptr_t r( c.get(), ConnectionReleaser( connectionList, c ) ); return r; }</span></span></code> </pre><br><img src="https://habrastorage.org/getpro/habr/post_images/e4a/6a3/5cb/e4a6a35cba7791ab4ee9bef6ff24d706.png"><br><br>  The problem is that the object passed as a liberating functor for shared_ptr will be destroyed only when all references to the object are destroyed - both strong (shared_ptr) and weak (weak_ptr).  Thus, if ConnectionReleaser does not take care of ‚Äúreleasing‚Äù the pointer passed to it (connectionToRelease), it will hold a strong link as long as at least one weak_ptr from shared_ptr created by the getConnection function exists.  This can lead to a rather unpleasant and unexpected behavior of your application. <br><br>  It is also possible that you use bind to create a liberating functor.  For example: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">releaseConnection</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">list</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ptr_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;&amp; whereToReturn, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ptr_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; connectionToRelease)</span></span></span><span class="hljs-function"> </span></span>{ whereToReturn.push_back( connectionToRelease ); <span class="hljs-comment"><span class="hljs-comment">//      connectionToRelease.reset(); } ptr_t getConnection() { ptr_t c( connectionList.back() ); connectionList.pop_back(); ptr_t r( c.get(), boost::bind(&amp;releaseConnection, boost::ref(connectionList), c) ); return r; }</span></span></code> </pre><br><br>  Remember that bind copies the arguments passed to it (except when using boost :: ref), and if there is shared_ptr among them, then it should also be cleared to avoid the problem already described. <br><br>  <b>Conclusion:</b> Perform in the release function all actions that must be performed when the last strong link is broken.  Drop all shared_ptr that are for some reason members of your functor.  If you use bind, do not forget that it copies the arguments passed to it. <br><br><h4>  Features of working with the enable_shared_from_this template </h4><br>  Sometimes you need to get shared_ptr from the methods of the object itself.  Attempting to create a new shared_ptr from this will lead to undefined behavior (most likely to crash the program), unlike intrusive_ptr, for which this is common practice.  To solve this problem, a mix-up class of enable_shared_from_this was invented. <br><br>  The enable_shared_from_this template is arranged as follows: inside the class there is a weak_ptr, which in the construction of shared_ptr contains a link to this most shared_ptr.  When you call the shared_from_this method of an object, the weak_ptr is converted to shared_ptr through the constructor.  Schematically, the template looks like this: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">enable_shared_from_this</span></span></span><span class="hljs-class"> {</span></span> weak_ptr&lt;T&gt; weak_this_; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;T&gt; shared_from_this() { <span class="hljs-comment"><span class="hljs-comment">//        shared_ptr shared_ptr&lt;T&gt; p( weak_this_ ); return p; } }; class Widget: public enable_shared_from_this&lt;Widget&gt; {};</span></span></code> </pre><br>  The shared_ptr constructor for this case looks like this: <br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>(T* object) { pointer = object; counter = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Counter; object-&gt;weak_this_ = *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; }</code> </pre><br>  It is important to understand that when constructing the weak_this_ object, it still does not indicate anything.  The correct link in it will appear only after the constructed object is passed to the constructor shared_ptr.  Any attempt to call shared_from_this from the constructor will result in a bad_weak_ptr exception. <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BadWidget</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> enable_shared_from_this&lt;BadWidget&gt; { BadWidget() { <span class="hljs-comment"><span class="hljs-comment">//   shared_from_this()   bad_weak_ptr cout &lt;&lt; shared_from_this() &lt;&lt; endl; } };</span></span></code> </pre><br>  The same consequences will result from an attempt to access the shared_from_this from the destructor, but for a different reason: at the time of the destruction of the object, it is already considered that it does not indicate any strong references (the counter is decremented). <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BadWidget</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> enable_shared_from_this&lt;BadWidget&gt; { ~BadWidget() { <span class="hljs-comment"><span class="hljs-comment">//   shared_from_this()   bad_weak_ptr cout &lt;&lt; shared_from_this() &lt;&lt; endl; } };</span></span></code> </pre><br>  With the second case (destructor) there is little that can be invented.  The only option is to take care not to call shared_from_this and make sure that the functions that the destructor does not do. <br><br>  With the first case, everything is a little easier.  Surely you have already decided that the only way for the existence of your object is shared_ptr, then it would be appropriate to move the object's constructor to the private part of the class and create a static method for creating shared_ptr of the type you need.  If, when initializing an object, you need to perform actions that require shared_from_this, then for this purpose you can select the logic in the init method. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GoodWidget</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> enable_shared_from_this&lt;GoodWidget&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; shared_from_this() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;GoodWidget&gt; create() { <span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;GoodWidget&gt; p(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GoodWidget); p-&gt;init(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p; } };</code> </pre><br>  <b>Conclusion:</b> <br>  Avoid calling (direct or indirect) shared_from_this from constructors and destructors.  In case for proper object initialization you need access to shared_from_this: create an init method, delegate object creation to a static method, and make it possible for objects to be created only using this method. <br><br><h4>  Conclusion </h4><br>  The article describes 5 features of using shared_ptr and provides general recommendations for avoiding potential problems. <br><br>  Although shared_ptr removes many problems from the developer, knowledge of the internal structure (albeit approximately) is necessary for competent use of shared_ptr.  I recommend carefully studying the shared_ptr device, as well as the classes associated with it.  Compliance with a set of simple rules can save the developer from unwanted problems. <br><br><h4>  Literature </h4><br><ul><li>  <a href="http://www.boost.org/doc/libs/1_54_0/libs/smart_ptr/shared_ptr.htm">Documentation boost.org</a> </li><li>  Scott Meyers <i>"More Effective C ++: 35 New Ways to Improve Your Programs and Designs"</i> </li></ul><br><br><h4>  application </h4><br>  The appendix contains the full texts of programs to illustrate the cases described in the article. <br><br><div class="spoiler">  <b class="spoiler_title">Demonstration of the ring link problem</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;string&gt; #include &lt;iostream&gt; #include &lt;boost/shared_ptr.hpp&gt; #include &lt;boost/weak_ptr.hpp&gt; class BadWidget { std::string name; boost::shared_ptr&lt;BadWidget&gt; otherWidget; public: BadWidget(const std::string&amp; n):name(n) { std::cout &lt;&lt; "BadWidget " &lt;&lt; name &lt;&lt; std::endl; } ~BadWidget() { std::cout &lt;&lt; "~BadWidget " &lt;&lt; name &lt;&lt; std::endl; } void setOther(const boost::shared_ptr&lt;BadWidget&gt;&amp; x) { otherWidget = x; std::cout &lt;&lt; name &lt;&lt; " now points to " &lt;&lt; x-&gt;name &lt;&lt; std::endl; } }; class GoodWidget { std::string name; boost::weak_ptr&lt;GoodWidget&gt; otherWidget; public: GoodWidget(const std::string&amp; n):name(n) { std::cout &lt;&lt; "GoodWidget " &lt;&lt; name &lt;&lt; std::endl; } ~GoodWidget() { std::cout &lt;&lt; "~GoodWidget " &lt;&lt; name &lt;&lt; std::endl; } void setOther(const boost::shared_ptr&lt;GoodWidget&gt;&amp; x) { otherWidget = x; std::cout &lt;&lt; name &lt;&lt; " now points to " &lt;&lt; x-&gt;name &lt;&lt; std::endl; } }; int main() { { //       std::cout &lt;&lt; "====== Example 3" &lt;&lt; std::endl; boost::shared_ptr&lt;BadWidget&gt; w1(new BadWidget("3_First")); boost::shared_ptr&lt;BadWidget&gt; w2(new BadWidget("3_Second")); w1-&gt;setOther( w2 ); w2-&gt;setOther( w1 ); } { //      weak_ptr      std::cout &lt;&lt; "====== Example 3" &lt;&lt; std::endl; boost::shared_ptr&lt;GoodWidget&gt; w1(new GoodWidget("4_First")); boost::shared_ptr&lt;GoodWidget&gt; w2(new GoodWidget("4_Second")); w1-&gt;setOther( w2 ); w2-&gt;setOther( w1 ); } return 0; }</span></span></span></span></code> </pre></div></div><br><div class="spoiler">  <b class="spoiler_title">Demonstrate the conversion of weak_ptr to shared_ptr</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #include &lt;boost/shared_ptr.hpp&gt; #include &lt;boost/weak_ptr.hpp&gt; class Widget {}; int main() { boost::weak_ptr&lt;Widget&gt; w; //    weak_ptr      //  lock    std::cout &lt;&lt; __LINE__ &lt;&lt; ": " &lt;&lt; w.lock().get() &lt;&lt; std::endl; //  shared_ptr       try { boost::shared_ptr&lt;Widget&gt; tmp ( w ); } catch (const boost::bad_weak_ptr&amp;) { std::cout &lt;&lt; __LINE__ &lt;&lt; ": bad_weak_ptr" &lt;&lt; std::endl; } boost::shared_ptr&lt;Widget&gt; p(new Widget); //   weak_ptr   w = p; //  lock    std::cout &lt;&lt; __LINE__ &lt;&lt; ": " &lt;&lt; w.lock().get() &lt;&lt; std::endl; //  shared_ptr       .    std::cout &lt;&lt; __LINE__ &lt;&lt; ": " &lt;&lt; boost::shared_ptr&lt;Widget&gt;( w ).get() &lt;&lt; std::endl; //   p.reset(); //    .  weak_ptr    //  lock     std::cout &lt;&lt; __LINE__ &lt;&lt; ": " &lt;&lt; w.lock().get() &lt;&lt; std::endl; //  shared_ptr        try { boost::shared_ptr&lt;Widget&gt; tmp ( w ); } catch (const boost::bad_weak_ptr&amp;) { std::cout &lt;&lt; __LINE__ &lt;&lt; ": bad_weak_ptr" &lt;&lt; std::endl; } return 0; }</span></span></span></span></code> </pre></div></div><br><div class="spoiler">  <b class="spoiler_title">Demonstration of multithreading problems for shared_ptr</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #include &lt;boost/thread.hpp&gt; #include &lt;boost/shared_ptr.hpp&gt; typedef boost::shared_mutex mutex_t; typedef boost::unique_lock&lt;mutex_t&gt; read_lock_t; typedef boost::shared_lock&lt;mutex_t&gt; write_lock_t; mutex_t globalMutex; boost::shared_ptr&lt;int&gt; globalPtr(new int(0)); const int readThreads = 10; const int maxOperations = 10000; boost::shared_ptr&lt;int&gt; getPtr() { //   ,     read_lock_t l(globalMutex); return globalPtr; } void resetPtr(const boost::shared_ptr&lt;int&gt;&amp; x) { //   ,     write_lock_t l(globalMutex); globalPtr = x; } void myRead() { for(int i = 0; i &lt; maxOperations; ++i) { boost::shared_ptr&lt;int&gt; p = getPtr(); } } void myWrite() { for(int i = 0; i &lt; maxOperations; ++i) { resetPtr( boost::shared_ptr&lt;int&gt;( new int(i)) ); } } int main() { boost::thread_group tg; tg.create_thread( &amp;myWrite ); for(int i = 0; i &lt; readThreads; ++i) { tg.create_thread( &amp;myRead ); } tg.join_all(); return 0; }</span></span></span></span></code> </pre></div></div><br><div class="spoiler">  <b class="spoiler_title">Demonstration of deleter + weak_ptr problem</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;string&gt; #include &lt;list&gt; #include &lt;iostream&gt; #include &lt;stdexcept&gt; #include &lt;boost/shared_ptr.hpp&gt; #include &lt;boost/weak_ptr.hpp&gt; #include &lt;boost/bind.hpp&gt; class Connection { std::string name; public: const std::string&amp; getName() const { return name; } explicit Connection(const std::string&amp; n):name(n) { std::cout &lt;&lt; "Connection " &lt;&lt; name &lt;&lt; std::endl; } ~Connection() { std::cout &lt;&lt; "~Connection " &lt;&lt; name &lt;&lt; std::endl; } }; typedef boost::shared_ptr&lt;Connection&gt; ptr_t; class ConnectionPool { std::list&lt;ptr_t&gt; connections; //         deleter (get1) class ConnectionReleaser { std::list&lt;ptr_t&gt;&amp; whereToReturn; ptr_t connectionToRelease; public: ConnectionReleaser(std::list&lt;ptr_t&gt;&amp; lst, const ptr_t&amp; x):whereToReturn(lst), connectionToRelease(x) {} void operator()(Connection*) { whereToReturn.push_back( connectionToRelease ); std::cout &lt;&lt; "get1: Returned connection " &lt;&lt; connectionToRelease-&gt;getName() &lt;&lt; " to the list" &lt;&lt; std::endl; //  .          connectionToRelease.reset(); } }; //         deleter (get2) static void releaseConnection(std::list&lt;ptr_t&gt;&amp; whereToReturn, ptr_t&amp; connectionToRelease) { whereToReturn.push_back( connectionToRelease ); std::cout &lt;&lt; "get2: Returned connection " &lt;&lt; connectionToRelease-&gt;getName() &lt;&lt; " to the list" &lt;&lt; std::endl; //            connectionToRelease.reset(); } ptr_t popConnection() { if( connections.empty() ) throw std::runtime_error("No connections left"); ptr_t w( connections.back() ); connections.pop_back(); return w; } public: ptr_t get1() { ptr_t w = popConnection(); std::cout &lt;&lt; "get1: Taken connection " &lt;&lt; w-&gt;getName() &lt;&lt; " from list" &lt;&lt; std::endl; ptr_t r( w.get(), ConnectionReleaser( connections, w ) ); return r; } ptr_t get2() { ptr_t w = popConnection(); std::cout &lt;&lt; "get2: Taken connection " &lt;&lt; w-&gt;getName() &lt;&lt; " from list" &lt;&lt; std::endl; ptr_t r( w.get(), boost::bind(&amp;releaseConnection, boost::ref(connections), w )); return r; } void add(const std::string&amp; name) { connections.push_back( ptr_t(new Connection(name)) ); } ConnectionPool() { std::cout &lt;&lt; "ConnectionPool" &lt;&lt; std::endl; } ~ConnectionPool() { std::cout &lt;&lt; "~ConnectionPool" &lt;&lt; std::endl; } }; int main() { boost::weak_ptr&lt;Connection&gt; weak1; boost::weak_ptr&lt;Connection&gt; weak2; { ConnectionPool cp; cp.add("One"); cp.add("Two"); ptr_t p1 = cp.get1(); weak1 = p1; ptr_t p2 = cp.get2(); weak2 = p2; } std::cout &lt;&lt; "Here the ConnectionPool is out of scope, but weak_ptrs are not" &lt;&lt; std::endl; return 0; }</span></span></span></span></code> </pre></div></div><br><div class="spoiler">  <b class="spoiler_title">Demonstrate problems with enable_shared_from_this</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #include &lt;boost/shared_ptr.hpp&gt; #include &lt;boost/enable_shared_from_this.hpp&gt; class BadWidget1: public boost::enable_shared_from_this&lt;BadWidget1&gt; { public: BadWidget1() { std::cout &lt;&lt; "Constructor" &lt;&lt; std::endl; std::cout &lt;&lt; shared_from_this() &lt;&lt; std::endl; } }; class BadWidget2: public boost::enable_shared_from_this&lt;BadWidget2&gt; { public: ~BadWidget2() { std::cout &lt;&lt; "Destructor" &lt;&lt; std::endl; std::cout &lt;&lt; shared_from_this() &lt;&lt; std::endl; } }; class GoodWidget: public boost::enable_shared_from_this&lt;GoodWidget&gt; { GoodWidget() {} void init() { std::cout &lt;&lt; "init()" &lt;&lt; std::endl; std::cout &lt;&lt; shared_from_this() &lt;&lt; std::endl; } public: static boost::shared_ptr&lt;GoodWidget&gt; create() { boost::shared_ptr&lt;GoodWidget&gt; p(new GoodWidget); p-&gt;init(); return p; } }; int main() { boost::shared_ptr&lt;GoodWidget&gt; good = GoodWidget::create(); try { boost::shared_ptr&lt;BadWidget1&gt; bad1(new BadWidget1); } catch( const boost::bad_weak_ptr&amp;) { std::cout &lt;&lt; "Caught bad_weak_ptr for BadWidget1" &lt;&lt; std::endl; } try { boost::shared_ptr&lt;BadWidget2&gt; bad2(new BadWidget2); //        terminate // .. ,           } catch( const boost::bad_weak_ptr&amp;) { std::cout &lt;&lt; "Caught bad_weak_ptr for BadWidget2" &lt;&lt; std::endl; } return 0; }</span></span></span></span></code> </pre></div></div></div><p>Source: <a href="https://habr.com/ru/post/191018/">https://habr.com/ru/post/191018/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../191004/index.html">Highscreen Alpha R review: Full HD, two batteries and other animals</a></li>
<li><a href="../191006/index.html">Chess on pure sed</a></li>
<li><a href="../191008/index.html">Tenders from the inside - customer's view</a></li>
<li><a href="../191010/index.html">Why study TDD is difficult and what to do about it. Part 1</a></li>
<li><a href="../191014/index.html">External components in 1C 8.2</a></li>
<li><a href="../191022/index.html">The concept of the Ministry of Communications and Mass Media: I want a substantive conversation</a></li>
<li><a href="../191024/index.html">Inforza - a new channel to attract customers for studios and agencies</a></li>
<li><a href="../191030/index.html">Analysis of all tasks and results of Yandex. Algorithm</a></li>
<li><a href="../191032/index.html">Python inside. Process structures</a></li>
<li><a href="../191044/index.html">Rootkit Avatar and HiddenFsReader</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>