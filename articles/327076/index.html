<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We increase the potential of the network storage abandoned by the manufacturer</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="During the operation of a smart device, users often face a number of problems that only the manufacturer can solve. The solution, it would seem, is ne...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We increase the potential of the network storage abandoned by the manufacturer</h1><div class="post__text post__text-html js-mediator-article"><p>  During the operation of a smart device, users often face a number of problems that only the manufacturer can solve.  The solution, it would seem, is near: we inform via official channels about the found bug, the manufacturer fixes, uploads new firmware, gives instructions for updating, updating and everyone is happy. </p><br><p>  In practice, everything is not so fabulous, and it is often difficult or even impossible to reach the manufacturer.  And it may be trite to end the period of support for this model of device, then no one will be sure to fix it. </p><br><p>  This story is about what you can do yourself, having the initial skills, desire and time to understand the process of updating the software for embedded devices. </p><br><p><img src="https://habrastorage.org/web/cb1/31f/59c/cb131f59c0c64daab79e78860492ccac.png" alt="image"></p><br><p>  For the impatient: in the end turned out to be a full-fledged device with the current version of the <a href="https://ru.wikipedia.org/wiki/Das_U-Boot">U-Boot</a> loader, <img src="https://habrastorage.org/web/fd0/813/f11/fd0813f117214f22becc7250d4e56ee5.png" alt="image">  <a href="https://wiki.debian.org/ru/DebianJessie">Debian jessie</a> and <img src="https://habrastorage.org/web/aab/f4c/99f/aabf4c99f2f5454a899d3bd5fbd60b80.png" alt="image">  <a href="http://www.openmediavault.org/">OpenMediaVault</a> on board. </p><a name="habracut"></a><br><p>  <strong>Content:</strong> </p><br><ol><li>  <a href="https://habr.com/ru/post/327076/">Device</a> <br><ul><li>  <a href="https://habr.com/ru/post/327076/">Glitches</a> </li><li>  <a href="https://habr.com/ru/post/327076/">Choosing an alternative OS</a> </li></ul></li><li>  <a href="https://habr.com/ru/post/327076/">Device preparation</a> <br><ul><li>  <a href="https://habr.com/ru/post/327076/">Extra iron</a> </li><li>  <a href="https://habr.com/ru/post/327076/">Converter connection</a> </li><li>  <a href="https://habr.com/ru/post/327076/">Trial run</a> </li></ul></li><li>  <a href="https://habr.com/ru/post/327076/">Build and update</a> <br><ul><li>  <a href="https://habr.com/ru/post/327076/">Loader</a> </li><li>  <a href="https://habr.com/ru/post/327076/">Root system (stage one)</a> </li><li>  <a href="https://habr.com/ru/post/327076/">Core</a> </li><li>  <a href="https://habr.com/ru/post/327076/">Initramfs</a> </li></ul></li><li>  <a href="https://habr.com/ru/post/327076/">Installation and Setup</a> <br><ul><li>  <a href="https://habr.com/ru/post/327076/">Loader environment variables</a> </li><li>  <a href="https://habr.com/ru/post/327076/">Root system (stage two)</a> </li><li>  <a href="https://habr.com/ru/post/327076/">Network configuration</a> </li><li>  <a href="https://habr.com/ru/post/327076/">Setting the fan and buttons</a> </li><li>  <a href="https://habr.com/ru/post/327076/">OMV installation</a> </li></ul></li><li>  <a href="https://habr.com/ru/post/327076/">Conclusion</a> </li></ol><br><br><h2 id="ustroystvo">  <strong>Device</strong> </h2><br><p>  Meet the test subject - <a href="http://www.dlink.ru/ru/products/120/1400.html">D-Link DNS-325</a> . </p><br><p><img src="https://habrastorage.org/web/376/742/c61/376742c61576458980de086e19aa761c.jpg" alt="image"></p><br><p>  The device has an ARM processor Marvell Kirkwood 88F6281 (EABI) architecture armel, 128MB NAND memory, 256MB RAM.  Equipped with two bays for HDD, network and USB connector on the rear panel. </p><br><p>  The thing is not very powerful, but even in the framework of home use, complaints have accumulated, with which further use with regular firmware has become unpleasant. </p><br><h4 id="glyuki">  <strong>Glitches</strong> </h4><br><p>  In descending order of importance: </p><br><ol><li><p>  Glitches UPnP AV media server.  A media server is set up in the storage, which indexes audio and video materials and distributes them via the <a href="https://ru.wikipedia.org/wiki/DLNA">DLNA</a> protocol.  The problem is that some files added to the hard disk are not automatically indexed and are not displayed when entering from a TV / other DLNA compatible device.  Manual switching of the media server mode helps, then the base is created from scratch, but it takes a couple of hours.  Not the best solution when you want to download and watch a movie. </p><br></li><li><p> A sudden waking up from the state of "sleep" in the middle of the night (the rustling of the disc, the fan noise) creates discomfort.  And not a line in the log about what kind of service task was launched.  Fan event only: <br> <code>Apr 20 03:55:09 Set Fan Speed To "LOW".</code> </p> <br></li><li><p>  Web interface.  There are hangs, dumps of the session, etc. </p><br></li><li><p>  Additions.  There are both <a href="http://www.dlink.ru/u/faq/98/1253.html">official</a> and <a href="http://dlink.vtverdohleb.org.ua/Add-On/">unofficial</a> .  The problem is that no one maintains the relevance of the software.  In this form of correcting errors and vulnerabilities, you should not wait either. </p><br></li><li><p>  The logging system is just awful.  Not only is it uninformative, but also with some mythical artifacts. </p><br></li><li><p>  Linux  As the basis of many <del>  modern coffee makers </del>  embedded devices, based on Linux.  This means that there are some issues of stability, vulnerabilities, etc. In the stock firmware, the Linux 2.6 kernel spins, and Linux 4.11 is already in the yard. </p><br></li><li>  Strange bug with usb printer.  The storage is equipped with a USB port for connecting flash drives, USB drives, printers and scanners.  And my USB printer was perfectly shared over the network, while inside it was installed 1 HDD for 2 TB.  As soon as I inserted a 3 TB HDD case, the printer stopped working.  After a series of tests with various combinations of different disks, I found out that it works with only one installed in the left case. </li></ol><br><h4 id="vybor-alternativnoy-os">  <strong>Choosing an alternative OS</strong> </h4><br><h4 id="alt-fhttpssourceforgenetprojectsalt-f">  <a href="https://sourceforge.net/projects/alt-f/">Alt-f</a> </h4><br><p>  The first that was found from the adapted alternatives was the open firmware Alt-F.  The functionality is not inferior to proprietary firmware, minimalistic web interface, updates are stable.  There is even support for plugins fun_plug. </p><br><h4 id="imagehttpshabrastorageorgwebbfd6621fbbfd6621fbd104aa6bef356951f824e1epng-freenashttpwwwfreenasorg-i-imagehttpshabrastorageorgweb56bd9da8f56bd9da8f9854670bb6751c12bc3c200png-nas4freehttpswwwnas4freeorg"><img src="https://habrastorage.org/web/bfd/662/1fb/bfd6621fbd104aa6bef356951f824e1e.png" alt="image">  <a href="http://www.freenas.org/">FreeNAS</a> and <img src="https://habrastorage.org/web/56b/d9d/a8f/56bd9da8f9854670bb6751c12bc3c200.png" alt="image">  <a href="https://www.nas4free.org/">NAS4Free</a> </h4><br><p>  Projects are interesting, but cumbersome.  Based on FreeBSD.  System requirements are too high. </p><br><p>  For example, the <a href="https://forums.freenas.org/index.php%3Fthreads/hardware-requirements.38929/">system requirements for FreeNAS 10 "Corral"</a> : </p><br><ul><li>  64-bit processor </li><li>  system with boot support via legacy BIOS or EFI </li><li>  8 GB RAM </li><li>  8 GB USB flash drive or other drive </li><li>  at least one data storage disk </li><li>  Ethernet port for network exchange </li></ul><br><p>  By the way, the recent release of FreeNAS 10 "Corral" was <a href="https://www.opennet.ru/opennews/art.shtml%3Fnum%3D46377">recalled</a> , incl.  and due to increased system requirements. </p><br><h4 id="imagehttpshabrastorageorgwebaabf4c99faabf4c99f2f5454a899d3bd5fbd60b80png-openmediavaulthttpwwwopenmediavaultorg"><img src="https://habrastorage.org/web/aab/f4c/99f/aabf4c99f2f5454a899d3bd5fbd60b80.png" alt="image">  <a href="http://www.openmediavault.org/">OpenMediaVault</a> </h4><br><p>  OMV is an open source NAS system.  It is an <a href="http://www.opennet.ru/opennews/art.shtml%3Fnum%3D40587">offshoot from FreeNAS</a> , but adapted for Debian Linux, as a result of which it is multiplatform.  In combination with relatively low system requirements, it makes itself the only suitable candidate.  The functionality is more than sufficient, extended by its plug-ins, but most importantly, a full-featured Debian gives access to the <a href="https://wiki.debian.org/ru/DebianRepository">repositories</a> , which means you can install anything by installing a couple of packages. </p><br><p>  For this model, there is an easy way <a href="http://www.nasdestruction.com/tutorial-installing-debian-squeeze-sabnzbd-sickbeard-couchpotato-headphones-d-link-dns-320-dns-325/">to start Debian using a hack with fun_plug</a> , but this is just a real-time extension, and you won‚Äôt be able to launch a Debian version older than Wheezy. </p><br><p>  Unfortunately, OMV does not have a ready-made Debian build with its package for the armel architecture.  Moreover, developers have so far recognized only i386 and amd64 assemblies as stable.  ARM experimental support: </p><br><blockquote>  Support for OpenMediaVault on Arm is experimental.  You must install the Debian Wheezy on you device. </blockquote><br><h2 id="podgotovka-ustroystva">  <strong>Device preparation</strong> </h2><br><p>  The built-in NAND memory is not suitable for our idea - it is too small.  There is no desire to store the system on the drives inserted into the storage.  It turns out the mixing of the brain device with peripheral components.  And if I want to change the disk or it will break? </p><br><p>  The only adequate option left is to install a USB flash drive, on which the entire system will be installed.  With this approach, it is easier to make backup copies of the system, and a flash drive in case of a breakdown is easy to replace. </p><br><p>  For USB devices, it was decided to take a separate <a href="https://www.amazon.com/s/field-keywords%3DUSB%2BNetwork%2BHub">USB Network Hub</a> , still one slot is not enough :) </p><br><h4 id="dopolnitelnoe-zhelezo">  <strong>Extra iron</strong> </h4><br><p>  To access the brain from the outside, there is a serial UART port on the board.  Instead of flashing the ROM with special programmers, you can connect to the contacts on the board and, via a special converter, communicate with the device via a terminal emulator. </p><br><p>  The topic of UART in embedded devices is quite extensive, who are interested, you can read a good overview article: <a href="https://geektimes.ru/post/253786/">https://geektimes.ru/post/253786/</a> </p><br><p>  The following components were selected and purchased: </p><br><ul><li>  USB Converter - UART to PL2303HX </li><li>  Wires "mother-mother" 20cm, 20 pcs. </li><li>  Plug the pin PLS-40 (DS1021-1x40), straight black </li><li>  SanDisk Ultra Fit USB 3.0 16GB </li></ul><br><h4 id="podklyuchenie-preobrazovatelya">  <strong>Converter connection</strong> </h4><br><div class="spoiler">  <b class="spoiler_title">We open the device, we get a fee</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/web/eb2/857/fd0/eb2857fd07e44f39b5e496b65505c84f.jpg" alt="image"></p></div></div><br><div class="spoiler">  <b class="spoiler_title">We are looking for a UART port (4 pins left)</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/web/a8d/594/7fd/a8d5947fd777469697f87c468796b48e.jpg" alt="image"></p></div></div><br><p>  Pinout such (in reverse order): {RXD, (empty), 3.3v, GND, TXD} </p><br><div class="spoiler">  <b class="spoiler_title">Solder the plug, insert the wires</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/web/af0/177/f27/af0177f278494d3f8d903f5dc83ed9be.jpg" alt="image"></p></div></div><br><div class="spoiler">  <b class="spoiler_title">Putting the body, leaving only the cover removed</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/web/1ad/4c2/25d/1ad4c225dd7543e1ac30bb6596bfe59c.jpg" alt="image"></p></div></div><br><p>  Now, in order to access the built-in microcomputer, you will not need to get a board - the wires have already been removed, it remains to remove the front cover of the network storage. </p><br><p>  Since this is a serial port, we connect them in series. </p><br><div class="spoiler">  <b class="spoiler_title">RX to TX, TX to RX</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/files/86b/c9d/f7d/86bc9df7dd344314be0763e2b7675938.png" alt="image"></p></div></div><br><p>  On this all the mechanical work with the equipment is finished. </p><br><h4 id="probnyy-zapusk">  <strong>Trial run</strong> </h4><br><p>  To communicate using the UART protocol, we will need: <br>  kwboot - utility to run the bootloader on the device "on the fly" <br>  minicom - terminal emulator for UART protocol </p><br><p>  Run minicom on the host system: </p><br><pre> <code class="bash hljs">ÔºÉ minicom -D /dev/ttyAMA0 -b 115200 -8</code> </pre> <br><p>  We connect the power supply, turn on the device, enjoy the output of the download log in the console: </p><br><div class="spoiler">  <b class="spoiler_title">Boot log</b> <div class="spoiler_text"><pre> <code class="bash hljs">** MARVELL BOARD: DB-88F6281A-BP LE U-Boot 1.1.4 (Jan 21 2011 - 09:42:39) Marvell version: 3.4.14.DNS-325.02 U-Boot code: 00600000 -&gt; 0067FFF0 BSS: -&gt; 006CEE80 Soc: MV88F6281 Rev 3 (DDR2) CPU running @ 1200Mhz L2 running @ 400Mhz SysClock = 400Mhz , TClock = 200Mhz DRAM CAS Latency = 5 tRP = 5 tRAS = 18 tRCD=6 DRAM CS[0] base 0x00000000 size 256MB DRAM Total size 256MB 16bit width Flash: 0 kB Addresses 8M - 0M are saved <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> the U-Boot usage. Mem malloc Initialization (8M - 7M): Done NAND:128 MB *** NAND <span class="hljs-built_in"><span class="hljs-built_in">read</span></span>: device 0 offset 0x100000, size 0x300000 load addr .... =a00000 3145728 bytes <span class="hljs-built_in"><span class="hljs-built_in">read</span></span>: OK NAND <span class="hljs-built_in"><span class="hljs-built_in">read</span></span>: device 0 offset 0x600000, size 0x300000 load addr .... =f00000 3145728 bytes <span class="hljs-built_in"><span class="hljs-built_in">read</span></span>: OK <span class="hljs-comment"><span class="hljs-comment">## Booting image at 00a00000 ... Image Name: Linux-2.6.31.8 Created: 2012-06-26 3:38:43 UTC Image Type: ARM Linux Kernel Image (uncompressed) Data Size: 2565784 Bytes = 2.4 MB Load Address: 00008000 Entry Point: 00008000 Verifying Checksum ... OK OK ## Loading Ramdisk Image at 00f00000 ... Image Name: Ramdisk Created: 2014-01-21 4:33:41 UTC Image Type: ARM Linux RAMDisk Image (gzip compressed) Data Size: 1581012 Bytes = 1.5 MB Load Address: 00e00000 Entry Point: 00e00000 Verifying Checksum ... OK Starting kernel ... Uncompressing Linux............................................................. **Linux version 2.6.31.8** (jack@swtest6) (gcc version 4.2.1) #8 Tue Jun 26 11:38:42 CPU: Feroceon 88FR131 [56251311] revision 1 (ARMv5TE), cr=00053977 CPU: VIVT data cache, VIVT instruction cache Machine: Feroceon-KW Using UBoot passing parameters structure Memory policy: ECC disabled, Data cache writeback Built 1 zonelists in Zone order, mobility grouping off. Total pages: 65024 Kernel command line: root=/dev/ram console=ttyS0,115200 :::DB88FXX81:egiga0:none PID hash table entries: 1024 (order: 10, 4096 bytes) Dentry cache hash table entries: 32768 (order: 5, 131072 bytes) Inode-cache hash table entries: 16384 (order: 4, 65536 bytes) Memory: 256MB = 256MB total Memory: 246528KB available (4828K code, 323K data, 136K init, 0K highmem) *** NAND device: Manufacturer ID: 0xec, Chip ID: 0xf1 (Samsung NAND 128MiB 3,3V 8-b) Scanning device for bad blocks Using static partition definition Creating 6 MTD partitions on "nand_mtd": 0x000000000000-0x000000100000 : "u-boot" 0x000000100000-0x000000600000 : "uImage" 0x000000600000-0x000000b00000 : "ramdisk" 0x000000b00000-0x000007100000 : "image" 0x000007100000-0x000007b00000 : "mini firmware" 0x000007b00000-0x000008000000 : "config"</span></span></code> </pre> </div></div><br><p>  If interested, here is the full conclusion: <br>  <a href="https://pastebin.com/6SRA6Qgq">https://pastebin.com/6SRA6Qgq</a> </p><br><h2 id="sborka-i-obnovlenie">  <strong>Build and update</strong> </h2><br><p>  All build actions will be performed on the main (host) system running Debian Stretch (amd64). </p><br><p>  We will collect and update: </p><br><ol><li>  <a href="https://ru.wikipedia.org/wiki/Das_U-Boot">Boot</a> Loader - <a href="https://ru.wikipedia.org/wiki/Das_U-Boot">U-Boot</a> </li><li>  Kernel - Linux Kernel 4.10 </li><li>  <a href="https://www.debian.org/releases/jessie/index.ru.html">Debian Jessie</a> root file system </li><li>  System initialization image - Initramfs </li></ol><br><p>  Basic assembly tools: </p><br><ol><li>  <a href="https://ru.wikipedia.org/wiki/%25D0%259A%25D1%2580%25D0%25BE%25D1%2581%25D1%2581-%25D0%25BA%25D0%25BE%25D0%25BC%25D0%25BF%25D0%25B8%25D0%25BB%25D1%258F%25D1%2582%25D0%25BE%25D1%2580">Cross compiler</a> for armel architecture.  In Debian, this is the <a href="https://packages.debian.org/stretch/gcc-arm-linux-gnueabi">gcc-arm-linux-gnueabi package.</a> </li><li>  Auxiliary utilities: <br><ul><li>  git - to download the necessary versions from the project repositories </li><li>  make - to execute build scripts </li><li>  debootstrap - for downloading the root filesystem </li><li>  mkimage is a utility for reformatting files in a format understandable to the loader </li><li>  BusyBox - a set of utilities for initial system initialization </li><li>  related dependencies and libraries. </li></ul></li></ol><br><h4 id="zagruzchik">  <strong>Loader</strong> </h4><br><p>  This device has a slightly truncated 2011 U-Boot boot loader installed.  We will update to the current stable version. </p><br><p>  Download: </p><br><pre> <code class="bash hljs">$ git <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> --branch v2017.05 git://git.denx.de/u-boot.git</code> </pre> <br><p>  Customize: </p><br><pre> <code class="bash hljs">$ <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> u-boot $ nano u-boot/include/configs/dns325.h</code> </pre> <br><p>  Add the lines: <br>  <code>#define CONFIG_CMD_BOOTZ</code> - to support the loading of the zImage kernel. <br>  <code>#define CONFIG_CMD_EXT4</code> - to support <a href="https://ru.wikipedia.org/wiki/Ext4">ext4</a> filesystems and related bootloader console commands. </p><br><pre> <code class="bash hljs">$ make dns325_defconfig ÔºÉ ÔºÉ configuration written to .config ÔºÉ $ make u-boot.kwb CROSS_COMPILE=arm-linux-gnueabi-</code> </pre> <br><p>  At this stage, you need to know how much this file weighs: </p><br><pre> <code class="bash hljs">$ <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span> <span class="hljs-string"><span class="hljs-string">"0x%x\n"</span></span> `<span class="hljs-built_in"><span class="hljs-built_in">stat</span></span> -c <span class="hljs-string"><span class="hljs-string">"%s"</span></span> u-boot.kwb` 0x7315c</code> </pre> <br><p>  We display the size of the image in hexadecimal number system (HEX), in this form it is useful when writing to NAND memory. </p><br><p>  You can write the resulting U-Boot image to NAND memory from a bootloader running in memory.  I decided not to do this from the current stock loader, as I first wanted to make sure that the new image was loaded on the hardware at all, and ext4 support was included earlier in the new boot image, so you can make a feint with your ears: copy this image to the USB flash drive and download from the same image with kwboot. </p><br><p>  There are several options for transferring the file to the memory of the minicomputer: via <a href="https://ru.wikipedia.org/wiki/Kermit_(%25D0%25BF%25D1%2580%25D0%25BE%25D1%2582%25D0%25BE%25D0%25BA%25D0%25BE%25D0%25BB)">Kermit</a> , via <a href="https://ru.wikipedia.org/wiki/TFTP">TFTP</a> , and also through physically connected drives (our choice). </p><br><p>  kwboot allows you to start the board with the bootloader transferred to it, without physically writing anything (RAM only) and ignoring NAND memory altogether.  This mechanism allows emergency loading of the device even when it has been corrupted due to NAND memory corruption or unsuccessful firmware. </p><br><p>  Turn off the device, run kwboot, press the power button.  The process of image uploading should go on and download should be interrupted. </p><br><div class="spoiler">  <b class="spoiler_title">Fill and load</b> <div class="spoiler_text"><pre> <code class="bash hljs">ÔºÉ tools/kwboot -p -b u-boot.kwb -B115200 -t /dev/ttyUSB0 Sending boot message. Please reboot the target.../ Sending boot image... 0 % [......................................................................] 1 % [......................................................................] 3 % [......................................................................] *** 96 % [......................................................................] 98 % [...........................................] [Type Ctrl-\ + c to quit] U-Boot 2017.05-dirty (May 10 2017 - 02:56:44 +0300) D-Link DNS-325 SoC: Kirkwood 88F6281_A1 DRAM: 256 MiB WARNING: Caches not enabled NAND: 128 MiB In: serial Out: serial Err: serial Net: egiga0 IDE: ide_preinit failed Hit any key to stop autoboot: 0 =&gt;</code> </pre> </div></div><br><p>  Loaded.  Next you need to write our <strong>u-boot.kwb</strong> image in the NAND area.  But in order to write it to NAND memory, you must first read it and write to RAM memory. </p><br><p>  Make an ext4 flash drive and give the partition the name "rootfs" (to mount the root file system by partition name): </p><br><pre> <code class="bash hljs">ÔºÉ mkfs.ext4 /dev/sdb1 ÔºÉ e2label /dev/sdb1 rootfs</code> </pre> <br><p>  Copy the file to the USB flash drive, insert the USB flash drive into the NAS and initialize it: </p><br><pre> <code class="bash hljs">=&gt; usb start starting USB... USB0: USB EHCI 1.00 scanning bus 0 <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> devices... 2 USB Device(s) found scanning usb <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> storage devices... 1 Storage Device(s) found</code> </pre> <br><p>  Write the image to memory.  The address (offset) does not matter, the main thing is not to go beyond the RAM).  In this case, will be 0x1000000. </p><br><pre> <code class="bash hljs">=&gt; ext4load usb 0:1 0x1000000 /u-boot.kwb 471388 bytes <span class="hljs-built_in"><span class="hljs-built_in">read</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> 77 ms (5.8 MiB/s)</code> </pre> <br><p>  Clear the NAND area where the boot loader is stored: </p><br><pre> <code class="bash hljs">=&gt; nand erase 0x000000 0x7315c NAND erase: device 0 offset 0x0, size 0x7315c Erasing at 0x60000 -- 100% complete. OK</code> </pre> <br><p>  (from the beginning of NAND memory to an offset equal to the size of the file, which we calculated earlier) </p><br><p>  Write the bootloader from the RAM memory area to the NAND memory area: </p><br><pre> <code class="bash hljs">=&gt; nand write 0x1000000 0x000000 0x7315c NAND write: device 0 offset 0x0, size 0x7315c 471388 bytes written: OK</code> </pre> <br><p>  0x1000000 - from where we read in RAM <br>  0x000000 - where we write to NAND <br>  0x73044 - size </p><br><p>  Everything, you can reboot and enjoy the launch of the new bootloader: </p><br><pre> <code class="bash hljs">U-Boot 2017.05-dirty (May 10 2017 - 02:56:44 +0300) D-Link DNS-325 SoC: Kirkwood 88F6281_A1 DRAM: 256 MiB WARNING: Caches not enabled NAND: 128 MiB In: serial Out: serial Err: serial Net: egiga0 IDE: ide_preinit failed Hit any key to stop autoboot: 0 =&gt;</code> </pre> <br><p>  If at this stage the device has turned around and refused to boot, for example, as I did at first (apparently, it was sealed when I entered the size of the bootloader image when writing from RAM memory to NAND), do not rush to panic.  You can also boot the device with kwboot and repeat the recording. </p><br><h4 id="kornevaya-sistema-etap-pervyy">  <strong>Root system (stage one)</strong> </h4><br><p>  Use the debootstrap tool.  Usually, the formation of rootfs for systems with a different architecture is done in 2 stages: downloading to the directory with the --foregin flag, and then setting up qemu and launching "debootstrap --second-stage" in it.  I did not want to mess around with qemu, and I decided to do the second stage right away on a working NAS. </p><br><p>  Download the contents to a USB flash drive (mounted on / mnt / usb /): </p><br><pre> <code class="bash hljs">ÔºÉ debootstrap --variant=minbase --foreign --arch=armel --include=dbus,nano jessie /mnt/usb/ http://ftp.ru.debian.org/debian/</code> </pre> <br><p>  Rename the init file so that the half-installed system does not start: </p><br><pre> <code class="bash hljs">ÔºÉ mv /mnt/usb/sbin/init /mnt/usb/sbin/init.bak</code> </pre> <br><p>  The first stage is ready. </p><br><h4 id="yadro">  <strong>Core</strong> </h4><br><p>  Perhaps the most difficult stage of all.  It is very important to configure the kernel so that all desired functions and programs work correctly.  Otherwise, it is easy to get some nasty error with strange symptoms. </p><br><p>  At first I was lucky to find a <a href="http://forum.doozan.com/read.php%3F2,12096">ready-made kernel for Kirkwood</a> , but it strongly refused to mount the flash drive in any of the modes (OHCI, EHCI), so I still had to assemble the kernel myself. </p><br><p>  Download: </p><br><pre> <code class="hljs ruby">$ git clone --branch v4.<span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-symbol"><span class="hljs-symbol">git:</span></span>/<span class="hljs-regexp"><span class="hljs-regexp">/git.kernel.org/pub</span></span><span class="hljs-regexp"><span class="hljs-regexp">/scm/linux</span></span><span class="hljs-regexp"><span class="hljs-regexp">/kernel/git</span></span><span class="hljs-regexp"><span class="hljs-regexp">/arm/arm</span></span>-soc.git</code> </pre> <br><p>  We load the preset config for our board (ARMv5).  In my case, this is mvebu_v5_defconfig. </p><br><pre> <code class="bash hljs">$ make ARCH=arm mvebu_v5_defconfig ÔºÉ ÔºÉ configuration written to .config ÔºÉ $ make ARCH=arm menuconfig</code> </pre> <br><p>  Customizable.  It is necessary to configure and check everything, ideally to study each parameter and decide whether it is needed or not.  I set the hostname, enabled initramfs / initrd, turned off sound and USB 3.0, turned off drivers for ext2 and ext3 (the ext4 driver can mount all earlier versions), included disk quotas, turned on support for Kirkwood, Marvell Orion.  Also included are <a href="https://galileo.mailstation.de/%3Fp%3D31">required parameters to support systemd</a> .  Most likely, there is something that I did not mention, for there are many settings.  Here is my kernel config: <a href="https://pastebin.com/MZrRXnXX">https://pastebin.com/MZrRXnXX</a> </p><br><p>  Many things can come out during installation, configuration, and operation of the system and OMV.  In this case, you can simply add the necessary lines, rebuild the kernel and replace the image on the flash drive. </p><br><p>  Assembly: </p><br><pre> <code class="bash hljs">$ make ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- -j5 zImage kirkwood-dns325.dtb</code> </pre> <br><p>  We got the zImage kernel itself and the kirkwood-dns325.dtb file.  The last file - <a href="https://en.wikipedia.org/wiki/Device_tree">Device Tree</a> - is needed for the correct operation of the kernel specifically with our board. </p><br><p>  Copy these files to the / boot directory on a flash drive: </p><br><pre> <code class="bash hljs">ÔºÉ cp arch/arm/boot/zImage arch/arm/boot/dts/kirkwood-dns325.dtb /mnt/usb/boot/</code> </pre> <br><h4 id="initramfs">  <strong>Initramfs</strong> </h4><br><p>  Next, we make a lightweight image that will be loaded into memory and initialize our system.  It is not necessary to do it at all, the loader can start the kernel directly with the root directory ( <code>root=</code> ).  However, it is useful, because in case of lack of access to the root file system, a console with a minimal set of commands will be available. </p><br><p>  The backbone of the image will be a BusyBox gentleman's set. </p><br><p>  Download: </p><br><pre> <code class="bash hljs">$ git <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> --branch 1_26_2 git://git.busybox.net/busybox/</code> </pre> <br><p>  Setup: </p><br><pre> <code class="bash hljs">$ make defconfig $ make menuconfig</code> </pre> <br><p>  The only thing that is better in the settings in addition is the static linking of the glibc library, so that you do not have to push it separately into the image. </p><br><div class="spoiler">  <b class="spoiler_title">Glibc static linking</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/web/f53/345/aba/f53345abac964fa6906f78c6fc817932.png" alt="image"></p></div></div><br><p>  Assembly: </p><br><pre> <code class="bash hljs">$ make ARCH=arm</code> </pre> <br><p>  Next, create the image structure, put the busybox in it: </p><br><pre> <code class="bash hljs">$ mkdir -p initramfs/{bin,sbin,etc,proc,sys,newroot,usr/{bin,sbin}} $ cp busybox/bin/bisybox initramfs/bin $ ln -s initramfs/bin/busybox initramfs/bin/sh</code> </pre> <br><p>  Next, you need to write an init script.  This is where all the magic of device initialization and the transfer of control to Debian will occur. </p><br><div class="spoiler">  <b class="spoiler_title">init script</b> <div class="spoiler_text"><pre> <code class="bash hljs"><span class="hljs-meta"><span class="hljs-meta">#!/bin/sh /bin/busybox --install -s #Mount things needed by this script mount -t proc proc /proc mount -t sysfs sysfs /sys #Disable kernel messages from popping onto the screen echo 0 &gt; /proc/sys/kernel/printk #Clear the screen clear #Create device nodes mknod /dev/null c 1 3 mknod /dev/tty c 5 0 #Pause bebore USB Storage init sleep 3 #Mount devices mdev -s #Defaults init="/sbin/init" #Mount the root device mount LABEL=rootfs /newroot #Check if $init exists and is executable if [ -h "/newroot/${init}" ] ; then #Unmount all other mounts so that the ram used by #the initramfs can be cleared after switch_root umount /sys /proc #Switch to the new root and execute init exec switch_root /newroot "${init}" fi #This will only be run if the exec above failed echo "Failed to switch_root, dropping to a shell" exec setsid sh exec &lt;"${console}" &gt;"${console}" 2&gt;&amp;1 exec sh</span></span></code> </pre> </div></div><br><p>  We pack and transform it into a format understandable for the U-Boot: </p><br><pre> <code class="bash hljs">$ <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> initramfs/ $ find . | cpio -H newc -o &gt; ../initramfs.cpio $ <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> .. $ cat initramfs.cpio | gzip &gt; initramfs.igz $ mkimage -n <span class="hljs-string"><span class="hljs-string">'uInitramfs'</span></span> -A arm -O linux -T ramdisk -C gzip -d initramfs.igz initramfs.uImage</code> </pre> <br><p>  Copy the initramfs: </p><br><pre> <code class="bash hljs">ÔºÉ cp initramfs.uImage /mnt/usb/boot/</code> </pre> <br><p>  With the assembly finished. </p><br><h2 id="ustanovka-i-nastroyka">  <strong>Installation and Setup</strong> </h2><br><h4 id="peremennye-okruzheniya-zagruzchika">  <strong>Loader environment variables</strong> </h4><br><p>  In the process of updating the bootloader, the configs got lost, you need to configure the boot of the new kernel, Initramfs, Device Tree, and also restore the network settings. </p><br><p>  Boot from the minicom, run on the device in the U-Boot console: </p><br><pre> <code class="bash hljs">=&gt; setenv console ttyS0,115200 =&gt; setenv bootargs console=<span class="hljs-variable"><span class="hljs-variable">${console}</span></span> =&gt; setenv bootcmd usb start; run load_kernel; run load_init; run load_dtree; run boot_system =&gt; setenv load_kernel ext4load usb 0:1 0x1000000 boot/zImage =&gt; setenv load_init ext4load usb 0:1 0x1800000 boot/initramfs.uImage =&gt; setenv load_dtree ext4load usb 0:1 0x2000000 boot/kirkwood-dns325.dtb =&gt; setenv boot_system bootz 0x1000000 0x1800000 0x2000000 =&gt; setenv ethaddr xx:xx:xx:xx:xx:xx =&gt; setenv ipaddr 192.168.0.32 =&gt; saveenv</code> </pre> <br><p>  Everything is very simple here: set the console parameters, load the kernel, prescribe where the files will be copied (ext4load) into memory and read from where (bootz).  We register ip and mac addresses (mac address can be viewed on the device label). </p><br><p>  We insert the flash drive in the NAS, reboot. </p><br><h4 id="kornevaya-sistema-etap-vtoroy">  <strong>Root system (stage two)</strong> </h4><br><p>  Having loaded, we get to BusyBox.  We can complete the formation of rootfs: </p><br><pre> <code class="bash hljs">ÔºÉ chroot /newroot ÔºÉ mv /sbin/init.bak /sbin/init ÔºÉ /debootstrap/debootstrap --second-stage ÔºÉ passwd</code> </pre> <br><p>  Reboot the device, log in as root.  From now on, we boot in full and work in Debian. </p><br><h4 id="nastroyka-seti">  <strong>Network configuration</strong> </h4><br><p>  Next you need to configure and enable the network. </p><br><pre> <code class="bash hljs">ÔºÉ touch /etc/systemd/network/wired.network ÔºÉ nano /etc/systemd/network/wired.network</code> </pre> <br><p>  We write a simple config for static ip on the wired interface eth0 <br>  [Match] <br>  Name = eth0 </p><br><p>  [Network] <br>  Address = 192.168.0.32 / 24 <br>  Gateway = 192.168.0.1 </p><br><p>  Enable and run network services </p><br><pre> <code class="bash hljs">ÔºÉ systemctl <span class="hljs-built_in"><span class="hljs-built_in">enable</span></span> systemd-networkd ÔºÉ systemctl <span class="hljs-built_in"><span class="hljs-built_in">enable</span></span> systemd-resolved ÔºÉ systemctl start systemd-networkd ÔºÉ systemctl start systemd-resolved</code> </pre> <br><p>  The network is. </p><br><h4 id="nastroyka-ventilyatora-i-knopok">  <strong>Setting the fan and buttons</strong> </h4><br><p>  Before doing high-load operations, it is necessary to set the fan for cooling.  Usually, the setting is simple: using the pwmconfig command, the CPU temperature sensor is located, the fan is located, they are connected and the boundary parameters of the activation of cooling modes are set. </p><br><p>  In the case of a home NAS, you should not do this, because the main share of heat is emitted by hard drives, not by the processor. </p><br><p>  The problem is this: fancontrol, a service that controls the fan, allows you to monitor only the sensors that are directly on the board.  This device has one fan and one temperature sensor. </p><br><p>  There is a way out: you can fool the fancontrol by forcing it to read information from the place we need.  To read data from the HDD, we use the smartmontools package. </p><br><p>  Install: </p><br><pre> <code class="bash hljs">ÔºÉ apt install fancontrol lm-sensors smartmontools</code> </pre> <br><p>  Configuring by default: </p><br><pre> <code class="bash hljs">ÔºÉ pwmconfig</code> </pre> <br><p>  Subtleties settings can be read, for example, <a href="http://dmzik.blogspot.ru/2013/05/fancontrol.html">here</a> . </p><br><p>  Next, open the config / etc / fancontrol, look at the contents.  The variable "FCTEMPS" is interesting - it sets the location of the temperature from which the device should correspond to: <br> <code>FCTEMPS=hwmon0/pwm1=hwmon1/temp1_input</code> </p> <br><p>  The path is relative, the file itself is generated in / sys / class / hwmon / hwmon1 / temp1_input.  Let's see in what format the information is stored: </p><br><pre> <code class="bash hljs">ÔºÉ cat /sys/class/hwmon/hwmon1/temp1_input 41500</code> </pre> <br><p>  The value in Celsius multiplied by 1000 (for accuracy).  So you need a file in which the temperature of the hard drives will be updated periodically.  The value is allowed one, and we can have 2 hard disks. So, we will take the maximum, write to the file. </p><br><p>  Let's write a small script: </p><br><pre> <code class="hljs mel">#!/bin/bash <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> sleep <span class="hljs-number"><span class="hljs-number">60</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> TEMP1=<span class="hljs-string"><span class="hljs-string">`smartctl -A /dev/disk/by-id/ata-Hitachi_HDS723030ALA640_MK0311YHG1ZGJA | grep Temperature_Celsius | awk '{print $10 "000"}'`</span></span> TEMP2=<span class="hljs-string"><span class="hljs-string">`smartctl -A /dev/disk/by-id/ata-WDC_WD2003FYYS-02W0B1_WD-WMAY05168428 | grep Temperature_Celsius | awk '{print $10 "000"}'`</span></span> echo $(( $TEMP1 &gt; $TEMP2 ? $TEMP1 : $TEMP2 )) &gt; /etc/temp_hdd done</code> </pre> <br><p>  Every minute SMART information is read from the HDD sensors, only the temperature value is extracted from all the information, and in the right format, the largest of the 2 is written to the / etc / temp_hdd file.  I specified the disks by id, because the letters of the disks / dev / sd [az] can change depending on the order and number of inserted physical disks. </p><br><p>  Write the script in /etc/temp_hdd.sh.  Next you need to somehow start it at startup.  For this, the file /etc/rc.local is just suitable. </p><br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Register right before the "exit 0" line </font></font><br> <code>/etc/temp_hdd.sh &amp;</code> </p> <br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Now the process will run at system startup and run in the background. </font></font></p><br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When there is a file with the current temperature, we will enter this in the config / etc / fancontrol, while setting the temperature limit values. </font><font style="vertical-align: inherit;">It turned out something like this:</font></font></p><br><pre> <code class="hljs pgsql"># <span class="hljs-keyword"><span class="hljs-keyword">Configuration</span></span> file <span class="hljs-keyword"><span class="hljs-keyword">generated</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> pwmconfig, changes will be lost <span class="hljs-type"><span class="hljs-type">INTERVAL</span></span>=<span class="hljs-number"><span class="hljs-number">10</span></span> DEVPATH=hwmon0=devices/platform/gpio_fan hwmon1=devices/platform/ocp@f1000000/f1011000.i2c/i2c<span class="hljs-number"><span class="hljs-number">-0</span></span>/<span class="hljs-number"><span class="hljs-number">0</span></span><span class="hljs-number"><span class="hljs-number">-0048</span></span> DEVNAME=hwmon0=gpio_fan hwmon1=lm75 FCTEMPS=hwmon0/pwm1=/etc/temp_hdd FCFANS= hwmon0/pwm1=hwmon0/fan1_input MINTEMP=hwmon0/pwm1=<span class="hljs-number"><span class="hljs-number">45</span></span> MAXTEMP=hwmon0/pwm1=<span class="hljs-number"><span class="hljs-number">55</span></span> MINSTART=hwmon0/pwm1=<span class="hljs-number"><span class="hljs-number">4</span></span> MINSTOP=hwmon0/pwm1=<span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre> <br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The reaction to the buttons is much easier to set up. </font><font style="vertical-align: inherit;">Install the esekeyd package and configure it:</font></font></p><br><pre> <code class="bash hljs">ÔºÉ apt install esekeyd ÔºÉ nano /etc/esekeyd.conf</code> </pre> <br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Put the command to shutdown and reboot: </font></font></p><br><pre> <code class="hljs javascript">POWER:<span class="hljs-regexp"><span class="hljs-regexp">/sbin/</span></span>shutdown -h now RESTART:<span class="hljs-regexp"><span class="hljs-regexp">/sbin/</span></span>reboot</code> </pre> <br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Save, reboot the device. </font><font style="vertical-align: inherit;">Now the main important areas of the system are installed and configured, the remaining actions will relate to additional software.</font></font></p><br><h4 id="ustanovka-omv"> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OMV installation</font></font></strong> </h4><br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Add the OMV repository and install the main package: </font></font></p><br><pre> <code class="bash hljs">ÔºÉ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"deb http://packages.openmediavault.org/public erasmus main"</span></span> &gt; /etc/apt/sources.list.d/openmediavault.list ÔºÉ apt update ÔºÉ apt install openmediavault-keyring ÔºÉ apt install openmediavault</code> </pre> <br><p>  apt     (  457), .          ,    . </p><br><p>   apt      collectd  nginx: </p><br><pre> <code class="hljs pgsql">dpkg: dependency problems prevent <span class="hljs-keyword"><span class="hljs-keyword">configuration</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> openmediavault: openmediavault <span class="hljs-keyword"><span class="hljs-keyword">depends</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> collectd (&gt;= <span class="hljs-number"><span class="hljs-number">5.1</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span>); however: Package collectd <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> configured yet. openmediavault <span class="hljs-keyword"><span class="hljs-keyword">depends</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> nginx (&gt;= <span class="hljs-number"><span class="hljs-number">1.6</span></span><span class="hljs-number"><span class="hljs-number">.2</span></span>); however: Package nginx <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> configured yet.</code> </pre> <br><p>  nginx     /etc/nginx/sites-available/default  <br> <code>listen [::]:80 default_server;</code> <br>       <a href="https://ru.wikipedia.org/wiki/IPv6">IPv6</a> . </p><br><p>  collectd     hostname  ip  /etc/hosts.  In our case <br> <code>127.0.1.1 dns325</code> </p> <br><p>  : </p><br><pre> <code class="bash hljs">ÔºÉ apt install -f</code> </pre> <br><p>      .   : </p><br><pre> <code class="bash hljs">ÔºÉ omv-initsystem</code> </pre> <br><p>  Everything!  .        192.168.0.32,     . </p><br><p><img src="https://habrastorage.org/web/5da/3ac/abf/5da3acabf21a48dfba54d284ccf69eb6.png" alt="image"></p><br><h4 id="zaklyuchenie">  <strong>Conclusion</strong> </h4><br><p>     ,    ,     USB . </p><br><p> ,          .        Linux.         . </p><br><p>      OpenMediaVault 3.x ("Erasmus"),       -.  ,     ,     OMV  ,        D-Link. </p><br><p>          .      ,           ,           ,     . </p><br><p>         :   ,      ,  -       .      DLNA ,    .    -,   ,     ,        nginx + FastCGI. </p><br><p> Enjoy Embedding! </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/327076/">https://habr.com/ru/post/327076/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../327066/index.html">Results of the second round of the Russian Code Cup 2017</a></li>
<li><a href="../327068/index.html">PHP 7 Virtual Machine</a></li>
<li><a href="../327070/index.html">‚ÄúWhy don't you just rewrite it in X?‚Äù</a></li>
<li><a href="../327072/index.html">Predict the popularity of articles on TJ</a></li>
<li><a href="../327074/index.html">Experience migrating applications from Unity3D to iOS sdk and SceneKit</a></li>
<li><a href="../327078/index.html">Investigation of the position of the eyes in more than 1,000,000 persons: the rule of the golden section or the rule of thirds?</a></li>
<li><a href="../327080/index.html">As I wrote a sentence to the standard C ++</a></li>
<li><a href="../327084/index.html">Classic and new internet marketing aids worth seeing</a></li>
<li><a href="../327086/index.html">Predictive analytics on the SCP platform</a></li>
<li><a href="../327088/index.html">How we built the cloud processing infrastructure for cross-product analytics</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>