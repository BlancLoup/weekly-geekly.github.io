<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Anti-interference coding using various codes</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This is a continuation of the article on noise-tolerant coding, which has been in draft for a very long time. In the last part there is nothing intere...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Anti-interference coding using various codes</h1><div class="post__text post__text-html js-mediator-article">  This is a continuation of the article on noise-tolerant coding, which has been in draft for a very long time.  In the last part there is nothing interesting from a practical point of view - only general information about why this is needed, where it is used, etc.  In this part some (most simple) codes will be considered for detecting and / or correcting errors.  So let's go. <br><a name="habracut"></a><br>  I tried to describe everything as easily as possible for a person who has never worked on coding information, and without any special mathematical formulas. <br><br>  When we transmit a message from the source to the receiver, an error may occur during data transmission (interference, equipment malfunction, etc.).  In order to detect and correct the error, error-correcting coding is applied, i.e.  encode the message so that the receiving party knows whether an error has occurred or not, and if it could correct the errors in case of their occurrence. <br><br>  In essence, coding is the addition to the source information of additional, verification, information.  For encoding, a <em>coder is</em> used on the transmitting side, and a <em>decoder</em> is used on the receiving side to receive the original message. <br>  <em>Code redundancy</em> is the amount of verification information in a message.  It is calculated by the formula: <br><blockquote>  <b>k / (i + k)</b> where <br>  k is the number of check bits, <br>  i is the number of information bits. <br></blockquote>  For example, we transfer 3 bits and add 1 check bit to them - the redundancy is 1 / (3 + 1) = 1/4 (25%). 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Parity code </h4><br>  Parity checking is a very simple method for detecting errors in a transmitted data packet.  With this code, we can not recover data, but we can detect only a single error. <br><br>  Each data packet has <em>one parity bit</em> , or the so-called <em>parity bit</em> .  This bit is set during the writing (or sending) of the data, and then calculated and compared during the reading (receiving) of the data.  It <em>is equal to the sum modulo 2 of</em> all data bits in the packet.  That is, the <em>number of units in the package will always be even</em> .  Changing this bit (for example, from 0 to 1) reports an error that has occurred. <br>  Below is the block diagram of the encoder for this code. <br><div style="text-align:center;"><img src="https://habrastorage.org/storage2/818/15a/e79/81815ae795a752b352c410302fae14f4.png"></div><br>  and and decoder <br><div style="text-align:center;"><img src="https://habrastorage.org/storage2/ae0/ebf/b6b/ae0ebfb6b21201d970e047beb962ab4a.png"></div><br><br>  Example: <br><blockquote>  Initial data: 1111 <br>  Data after coding: 1111 <b>0</b> (1 + 1 + 1 + 1 = 0 (mod 2)) <br>  Received data: 1 <b>0</b> 110 (second bit changed) <br>  As we see, the number of units in the received packet is odd, therefore, an error occurred during transmission. <br></blockquote><br>  As mentioned earlier, this method serves only to determine a single error.  In the case of a change in the state of two bits, it is possible that the calculation of the check bit coincides with the recorded one.  In this case, the system will not detect the error, and this is not good.  For example: <br><blockquote>  Initial data: 1111 <br>  Data after coding: 1111 <b>0</b> (1 + 1 + 1 + 1 = 0 (mod 2)) <br>  Received data: 1 <b>00</b> 10 (2 and 3 bits changed) <br>  In the received data, the number of units is even, and therefore the decoder will not detect an error. <br></blockquote><br>  Since about 90% of all irregular errors occur with just a single bit, parity checking is enough for most situations. <br><br><h4>  Hamming code </h4><br>  As mentioned in the previous part, <a href="http://ru.wikipedia.org/wiki/%25D0%25A5%25D1%258D%25D0%25BC%25D0%25BC%25D0%25B8%25D0%25BD%25D0%25B3,_%25D0%25A0%25D0%25B8%25D1%2587%25D0%25B0%25D1%2580%25D0%25B4_%25D0%25A3%25D1%258D%25D1%2581%25D0%25BB%25D0%25B8">Richard Hamming</a> did a lot for noise-tolerant coding.  In particular, he developed a code that provides detection and correction of single errors with the minimum possible number of additional check bits.  For each number of check characters, a special marking of the form (k, i) is used, where k is the number of characters in the message, i is the number of information characters in the message.  For example, there are codes (7, 4), (15, 11), (31, 26).  Each check character in a Hamming code represents a sum modulo 2 of some subsequence of data.  Let us consider at once with an example, when the number of information bits i in a block is 4 - this is a code (7.4), the number of check symbols is 3. Classically, these symbols are placed in positions equal to powers of two in ascending order: <br><blockquote>  first check bit at 2 <sup>0</sup> = 1; <br>  the second check bit for 2 <sup>1</sup> = 2; <br>  the third check bit is 2 <sup>2</sup> = 4; <br></blockquote><br>  but it is possible to place them at the end of the transmitted data block (but then the formula for calculating them will be different). <br>  Now let's calculate these check characters: <br><blockquote>  r1 = i1 + i2 + i4 <br>  r2 = i1 + i3 + i4 <br>  r3 = i2 + i3 + i4 <br></blockquote><br>  So, in the coded message we get the following: <br><blockquote>  <b>r1 r2</b> i1 <b>r3</b> i2 i3 i4 <br></blockquote><br>  In principle, the operation of this algorithm is discussed in great detail in the article <a href="http://habrahabr.ru/post/140611/">Hamming Code.</a>  <a href="http://habrahabr.ru/post/140611/">An example of how the algorithm works</a> , so I don‚Äôt see any point in describing in detail this article.  Instead, I will give the block diagram of the encoder: <br><img src="https://habrastorage.org/storage2/2b5/999/a34/2b5999a34ae1bfbd4c9e174399bd3056.png"><br>  and decoder <br><img src="https://habrastorage.org/storage2/b29/251/c29/b29251c295cbf6a6631001b9f0af4fb7.png"><br>  (maybe quite confusing, but it‚Äôs better not to draw) <br><br>  e0, e1, e2 are defined as functions depending on the bits k1 - k7 received by the decoder: <br><blockquote>  e0 = k1 + k3 + k5 + k7 mod 2 <br>  e1 = k2 + k3 + k6 + k7 mod 2 <br>  e2 = k4 + k5 + k6 + k7 mod 2 <br></blockquote><br>  The set of these values ‚Äã‚Äãof <b>e2e1e0</b> is a binary record of the position where an error occurred during data transfer.  The decoder calculates these values, and if all of them are not equal to <b>0</b> (that is, 000 does not work), then corrects the error. <br><br><h4>  Work codes </h4><br>  In the communication channel, apart from single errors caused by noise, there are often packet errors caused by impulse noise, fading, or fallout (during digital video recording).  At the same time, hundreds or even thousands of bits of information appear to be amazed.  It is clear that no interfering code will be able to cope with such an error.  To be able to deal with such errors, codes-products are used.  The principle of operation of such a code is shown in the figure: <br><img src="https://habrastorage.org/storage2/d44/61f/a74/d4461fa74d5bd4ec90e95ccba6fbab23.png"><br>  The transmitted information is encoded twice: in the external and internal coders.  A buffer is set between them, whose operation is shown in the figure: <br><img src="https://habrastorage.org/storage2/e32/360/f7f/e32360f7f20fe6c848b9ad6e3b205d27.png"><br>  Informational words pass through the first noise-tolerant coder, called external, because  he and the corresponding decoder are located on the edges of the noise-immune coding system.  Here, the check characters are added to them, and they, in turn, are buffered by columns, and displayed line by line.  This process is called <em>mixing</em> or <em>interleaving</em> . <br><br>  When lines are output from the buffer, the check characters of the internal code are added to them.  In this order, information is transmitted over a communication channel or recorded somewhere.  Let us agree that both the internal and external codes are Hamming codes with three verification symbols, that is, both can be corrected by one error in the code word (the number of ‚Äúcubes‚Äù in the figure is not critical - it is just a diagram).  At the receiving end there is exactly the same memory array (buffer) in which information is entered line by line, and displayed in columns.  If a packet error occurs (crosses in the figure in the third and fourth lines), it is distributed in small portions in the code words of the external code and can be corrected. <br><img src="https://habrastorage.org/storage2/365/8a9/1bc/3658a91bc4acd2942077ce27c3616e58.png"><br>  The purpose of the external code is clear - fix batch errors.  Why do we need an internal code?  The figure, except for the batch, shows a single error (fourth column, top row).  There are two errors in the code word located in the fourth column, and they cannot be corrected, because  external code is designed to correct one error.  To get out of this situation, you just need an internal code that corrects this single error.  The received data first passes the internal decoder, where single errors are corrected, then they are written to the buffer line by line, output in columns and fed to an external decoder, where the packet error occurs. <br><br>  The use of product codes increases the power of the error-correcting code many times with the addition of insignificant redundancy. <br><br>  <b>PS: I was engaged in this topic 3 years ago, when I wrote my graduation project, I might have missed something.</b>  <b>All corrections, comments, suggestions - please through private messages</b> </div><p>Source: <a href="https://habr.com/ru/post/111336/">https://habr.com/ru/post/111336/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../111329/index.html">Computer in the car "cheap" or CarPC "Siberian"</a></li>
<li><a href="../111330/index.html">Removing .NET programs from registration using the example of BEM</a></li>
<li><a href="../111331/index.html">Rake tutorial</a></li>
<li><a href="../111332/index.html">The emulator of the game "life" in the GLSL language</a></li>
<li><a href="../111333/index.html">Electronic forms via Microsoft InfoPath</a></li>
<li><a href="../111338/index.html">Online cinema</a></li>
<li><a href="../111339/index.html">Screenshot of a video player without black holes</a></li>
<li><a href="../111341/index.html">Review of Huawei E960 3G router</a></li>
<li><a href="../111343/index.html">Mac App Store - First Impressions</a></li>
<li><a href="../111345/index.html">Native interfaces in Qt</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>