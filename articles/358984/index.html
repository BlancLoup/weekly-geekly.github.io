<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How databases are arranged</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This is not to say that in this article you will find selected database introspection, but rather a story about databases from the very beginning, plu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How databases are arranged</h1><div class="post__text post__text-html js-mediator-article">  This is not to say that in this article you will find selected database introspection, but rather a story about databases from the very beginning, plus a slight digging into some details that <strong>Ilya Kosmodemyansky</strong> ( <a href="https://habrahabr.ru/users/hydrobiont/">@hydrobiont</a> ) seem important.  And there is every reason to believe that it is so. <br><br>  This article was not born of a good life.  Often, not even the novice developers, but also quite advanced ones, do not know some basic things - maybe they studied at the university a long time ago and have since forgotten, or they didn‚Äôt have to go into the theory, since they worked normally. <br><br>  However, <strong>theoretical knowledge is sometimes useful to refresh</strong> .  This we, including, and we will do. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/webt/xy/uo/qz/xyuoqzqdyze3xcvkawcbmkub1gi.jpeg"><br><br>  <strong>About the speaker:</strong> Ilya Kosmodemyansky CEO and consultant for Data Egret, PostgreSQL, Oracle, DB2 database specialist.  And besides, he is responsible for promoting Postgres technologies, speaking at conferences and telling people how to work with them. <br><br>  Below is the material on Ilya's report on <a href="http://ritfest.ru/moscow/2018">RIT ++</a> 2017, which was not associated with any particular database, but covered many basic aspects. <br><a name="habracut"></a><br><h2>  What does it need to know for? <br></h2><br>  <strong>Data storage and processing is the mission-critical task of</strong> any computer system. <br><br>  Even if you have already had a blog on text files on the Internet for 30 years, as some database creators have, this text file is actually a database, but very simple. <br><br>  <strong>Everyone is trying to invent a database</strong> .  One of the speakers at the conference said: ‚Äú20 years ago I wrote my database, I just didn‚Äôt know that it was her!‚Äù This trend in the world is very developed.  Everyone is trying to do that. <br><br>  To work with data <strong>database is a very handy thing</strong> .  Many databases are very old technologies.  They are being developed for the last half century, in the 70s there were already databases that worked according to similar principles as now. <br><br>  These <strong>databases are very well and thoughtfully written</strong> , so now we can choose a programming language and use a general user-friendly data processing interface.  Thus, it is possible to process data in a standardized way, without fear that they will be processed in a different way. <br><br>  It is useful to remember that <strong>programming languages ‚Äã‚Äãare changing</strong> : yesterday was Python 2, today is Python 3, tomorrow everyone ran to write on Go, the day after tomorrow on something else.  You may have a piece of code that emulates the work of manipulating data, which, in theory, the database should do, and you will not know what to do next. <br><br>  In most databases, the <strong>interface is very conservative</strong> .  If you take PostgreSQL or Oracle, then with some tambourines you can work even with very old versions from new programming languages ‚Äã‚Äã- well and great. <br><br>  But the task is not really the easiest.  If we begin to dig in the depths of how we do not ‚Äúbeat‚Äù the data, how quickly, efficiently and, most importantly, so that you can trust the result and process it, then it turns out that this is a difficult thing. <br><br>  If you try to write your own simple persistent storage, everything will just be the first 15 minutes.  Then locks and other things will begin, and at some point you will understand: ‚ÄúOh, why am I doing all this?‚Äù <br><br>  About this and talk. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/c4_5rqvmDFU" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2>  Levels of working with data <br></h2><br>  So, there are various levels of work with data: <br><br><ul><li>  <strong>The data access layer</strong> , which is convenient to use from programming languages; <br></li><li>  <strong>Storage layer</strong>  This is a separate layer, because usually it is convenient to store data in other ways than to use: efficiently in memory, level, fold to disk.  This is a schemaless question: a schema that is convenient to store is not convenient to access. <br></li><li>  ‚Äú <strong>Iron</strong> ‚Äù is the layer where the data lies, and there they are organized in a third way, because the disks are controlled by the operating system, and they communicate only through the driver.  In this level, we will not delve into much. <br></li></ul><br><img src="https://habrastorage.org/webt/ie/gg/mi/ieggmiashlis0jonnme7uartnim.jpeg"><br><br>  <strong>For the data access layer</strong> there are <strong>requirements</strong> that we are interested in fulfilling in order to make it convenient to work: <br><br><ol><li>  <strong>Universality</strong> , so that it is possible to request data using any technology. <br></li><li>  <strong>The optimality of</strong> this request.  The access method must be such that it is good and convenient to get data from the database. <br></li><li>  <strong>Parallelism</strong> , because now everything is scaled, different servers simultaneously access the database for the same data.  You need to do this in order to maximize the benefits of concurrency and more quickly process data in this way. <br></li></ol><br>  <strong>For the storage layer</strong> , it is still important to preserve the <strong>original concurrency</strong> so that all data is not beaten, overwritten, not truncated, etc. <br><br>  At the same time, they must be <strong>securely</strong> stored and reliably reproduced.  That is, if we have recorded something in the database, we must be sure that we will get it back. <br><br>  If you worked with old databases, for example, FoxPro, then you know that there often appear broken data.  In new databases, such as MongoDB, Cassandra and others, such problems also occur.  Maybe they simply are not always noticed, because there is a lot of data that is harder to notice. <br><br>  <strong>For hardware</strong> , reliability is really important.  This is a sort of assumption, since we will nevertheless speak about theoretical things.  In our model, if something got on the disk, then we think that everything is fine there.  How to replace a disk in RAID in time - this is for us admins.  We will not dive deep into this question, and practically we will not touch on how efficiently the store is physically organized. <br><br>  To solve these problems, there are some approaches that are very similar across different data sources - both new and classic. <br><br><img src="https://habrastorage.org/webt/yd/pa/mk/ydpamkipqtlxuis0ptuxhrbzfwi.jpeg"><br><br>  First of all, in order to provide universal and optimal <strong>access to data</strong> , there is a query language.  In most cases, this is <strong>SQL</strong> (why exactly it, we will discuss further), but now I just want to draw attention to the trend.  First there was SQL for a long time - of course, there were times before it, but, nevertheless, SQL dominated for a long time.  Then all sorts of Key-value-storage began to appear, which, they say, work without SQL and much better. <br><br>  Many Key-value-storage was mainly done to make it easier to follow data from a favorite programming language, and SQL does not fit well with a favorite programming language.  It is high-level, declarative, and we want objects, so there was an idea that <strong>SQL is not needed</strong> . <br><br>  But most of these technologies are now actually coming up with some kind of query language.  Hibernate is very developed its own query language, someone uses Lua.  Even those who have previously used Lua make their own SQL implementations.  So now the trend is this: <strong>SQL is returning again</strong> , because a convenient human-readable language for working with sets is still needed. <br><br>  Plus, the table view is still convenient.  In varying degrees, many databases still have labels, and this is not by accident - it is thus easier to optimize queries.  <strong>All optimization math is tied around relational algebra</strong> , and when you have SQL and tags, it‚Äôs much easier to work. <br><br>  <strong>In the storage layer</strong> there is such a thing as serialization.  When there is concurrency and competitive access, we need to ensure that this comes to the processor, to the disk in a more or less predictable manner.  This requires serialization algorithms that are implemented in the storage layer. <br><br>  Again, if something went wrong and the database fell, we need to quickly pick it up. <br><br><blockquote>  Do you think it is possible to write a 100% reliable fault-tolerant storage?  You probably know that the database only works reliably when there is a mechanism to quickly pick it up if it falls. <br></blockquote><br>  To do this, you need to recover, because, whatever you do, there will be a weak link somewhere and a very large overhead of synchronization.  We can make a hundred copies per hundred servers, and as a result, a power supply or some kind of switch will burn, and it will be bad and painful. <br><br>  <strong>For hardware</strong> , it is actually important that the database be well integrated with the OS, work productively, call the correct syscalls, and support all the kernel chips for quick work with the data. <br><br><h2>  Storage layer <br></h2><br>  Let's start with the storage layer.  Understanding how it works, well helps to understand what is happening at the higher layers. <br><br>  Storage layer provides: <br><br>  ‚úì <strong>Parallelism and efficiency.</strong> <br><br>  In other words, this is competitive access.  That is, when we try to benefit from concurrency, the problem of competitive access inevitably arises.  At the same time, we follow a single resource, which may be recorded incorrectly, beaten while recording and, God knows what else, it can happen. <br><br>  ‚úì <strong>Reliability: disaster recovery.</strong> <br><br>  The second problem is a sudden crash.  When reliability is ensured, this means that we not only maximally provided a disaster-proof solution, but it is also important that we are able to quickly recover if something happens. <br><br><h3>  Competitive Access <br></h3><br>  When I talk about integrity, foreign keys and so on, somehow grunts and say that all they check at the code level.  But as soon as you offer: ‚ÄúAnd let's take an example on your salary!  Your salary is transferred to you, but it did not come, ‚Äùfor some reason it becomes immediately clearer.  I do not know why, but immediately there is a sparkle in the eyes and an interest in the topic of foreign keys, constraints. <br><br>  Below is a code in a non-existent programming language. <br><br><pre><code class="javascript hljs">account_a { balance = <span class="hljs-number"><span class="hljs-number">1000</span></span>, curr = <span class="hljs-string"><span class="hljs-string">'RUR'</span></span> } send_money(account_a, account_b, <span class="hljs-number"><span class="hljs-number">100</span></span>); send_money(account_a, account_c, <span class="hljs-number"><span class="hljs-number">200</span></span>); account_a-&gt;balance = ???</code> </pre> <br>  Suppose we have a bank account with a balance of 1,000 rubles, and there are 2 functions.  How they are arranged inside is not important to us now, these functions transfer from account <em>a</em> to other bank accounts 100 and 200 rubles. <br><br>  Attention, the question: how much money will be in the result on the balance of the account <em>a</em> ?  Most likely, you will answer that 700. <br><br><h3>  Problems <br></h3><br>  This is where the problems with <strong>competitive access</strong> to data begin, because my language is invented, it‚Äôs not at all clear how it is implemented, whether these functions are performed at the same time and how they are arranged inside. <br><br>  We probably believe that the <strong>send_money ()</strong> operation is not an elementary action.  It is necessary to check the balance and where it is transferred, to perform control 1 and 2. These are not elementary operations that take some time.  therefore, the order of performing elementary operations inside them is important to us. <br><br>  In the sequence ‚Äúread the value on the balance sheet‚Äù, ‚Äúrecorded on another balance sheet‚Äù, the question is important - when did we read this balance?  If we do this at the same time, a conflict will arise.  Both functions are performed approximately in parallel: read the same value of balance, transferred money, each recorded its own. <br><br>  There may be a whole family of conflicts, as a result of which 800 rubles may appear on the balance sheet, 700 rubles, as it should be, or something will be beaten, and null on the balance sheet.  This, unfortunately, happens if you do not treat this with due attention.  How to deal with this, we'll talk. <br><br>  In theory, everything is simple - we can execute them one by one and everything will be fine.  In practice, these operations can be very much and doing them strictly consistently can be problematic. <br><br>  If you remember, several years ago there was a story when Sberbank dropped Oracle and card processing stopped.  They then asked for advice from the public and roughly determined how many logs the database wrote.  These are huge numbers and competitive issues. <br><br>  <strong>Performing operations strictly consistently is not a good idea</strong> for the simple reason that there are many operations, and we will not gain anything from concurrency.  You can, of course, break operations into groups that will not conflict with each other.  Such approaches also exist, but they are not very classic for modern databases. <br><br><img src="https://habrastorage.org/webt/zp/s5/sq/zps5sqtmt9hzplrlsyhu-awyepq.jpeg"><br><br>  There is one interesting story in the German rules of the road.  If the road narrows, then the rules prescribe to get to the end, and only after that <strong>rebuild one at a time</strong> , and the next car should pass.  All are rearranged strictly one after another - such a sign says so. <br><br>  This is a living example of possible serialization, when the public is very long accustomed to the fact that the rules must be followed.  I think that everyone who drives a car in Moscow understands how utopian this picture is. <br><br>  Basically, we need to do the same with the data that we write to the disk. <br><br><h3>  How to improve the situation? <br></h3><br>  ‚óè Operations must be independent of each other - <strong>isolation</strong> . <br><br>  In a purely theoretically controlled way, the operation must know what is happening outside.  There can be no such thing that as soon as one operation changed something, the result immediately became visible to the other.  There must be some rules. <br><br>  This is called transaction isolation.  In the simplest case, transactions do not know at all what is happening with the neighboring ones.  These actions are in themselves, within the limits of one function, there is no interaction outside, until it has ended. <br><br>  ‚óè The operation takes place on the principle of "all or nothing" - <strong>atomicity</strong> . <br><br>  That is, either the whole operation has passed, and then its result is recorded, or, if something went wrong, we should be able to return the status quo.  Such an operation must be recoverable, and if it is recoverable and isolated, then it is atomic.  This is an elementary operation, which, like the result, is not divisible.  It can not go half, but only entirely passes or does not pass entirely. <br><br>  ‚óè We need a mechanism to check that everything happened correctly - <strong>consistency</strong> . <br><br>  I asked how much money came out on the balance sheet in our example, and for some reason you said that 700. We all know that there is arithmetic, common sense, and the Criminal Code that monitors banks and accountants so that they do not do something unlawful.  The Criminal Code is one of the private versions of consistency.  If we talk about databases, there are many more of them: foreign keys, constraints, everything. <br><br><h2>  ACID transaction <br></h2><br>  Actions with data that have the properties of atomicity, consistency, isolation, and Durability are the definition of the ACID transaction. <br><br>  D - <strong>Durability</strong> is the very model I was talking about: if the data has already been written to disk, then we think that they are there, recorded reliably and will not go anywhere.  In fact, this is not the case, for example, the data must be backed up, but for our model it is not important. <br><br>  Sadly, these properties can only be secured using locks.  There are 3 main approaches to <strong>transaction scheduling</strong> : <br><br><ol><li>  Pessimistic sheduler; <br></li><li>  Optimistic sheduler; <br></li><li>  Hybrid sheduler and based on streamlining TimeStamp ongoing transaction. <br></li></ol><br>  <strong>A sheduler is a component that provides serialization</strong> and proper execution of a transaction. <br><br>  Everybody knows about the ordering of the TimeStamp: we are looking at the time of one transaction, the time of another transaction, who was the first to get up, and sneakers.  In fact, for most serious systems, this approach has a lot of problems, because, for a start, time on the server can go back, jump or go wrong - and we will come. <br><br>  There are different methods to improve this, but as a single transaction synchronization method, it does not work.  There are also vector clocks, Lamport clocks - probably heard such terms - but they also have their limitations. <br><br>  <strong>Optimistic approaches</strong> imply that we will not have conflicts such as what I described with a bank account.  But in real life they are not very successful, although there are implementations that help to carry out some operations with the help of optimistic options. <br><br>  As people working with databases, we are actually always pessimists.  We expect programmers to write bad code, the supplier will supply bad hardware, Marry Ivanna will pull the server out of the socket when the floor is cleaned - which is not possible! <br><br>  Therefore, we love the <strong>pessimistic</strong> sheduling of transactions, namely with the help of locks.  This is the only <strong>guaranteed</strong> way to ensure database integrity.  There are corresponding <strong>theorems</strong> that can be proved and demonstrated. <br><br>  We need efficient algorithms for taking and removing locks, because if we just block everything we need, we will most likely come to a very stupid version when we perform all operations strictly sequentially.  As we already know, this is not effective in terms of the utilization of parallelism, modern CPUs, the number of servers, etc. <br><br><h3>  Herbrand semantics <br></h3><br>  A small lyrical digression, which will help to understand what will happen next.  <a href="https://ru.wikipedia.org/wiki/%25D0%25AD%25D1%2580%25D0%25B1%25D1%2580%25D0%25B0%25D0%25BD,_%25D0%2596%25D0%25B0%25D0%25BA">Jacques Herbrand</a> is a French mathematician of the first half of the 20th century who, by the way, invented recursion.  He even invented in pre-computer times to designate transactions in the following way: <br><br><img src="https://habrastorage.org/webt/n4/rr/kn/n4rrknmrij2um0ixoxnobnquxoi.jpeg"><br><br>  Here <strong>S</strong> is from the word schedule.  The transaction schedule includes the operation - <strong>r</strong> (read - read) or <strong>w</strong> (write - write).  Still happens <strong>b</strong> (begin), <strong>with</strong> (commit), etc. <br><br>  What is convenient - we have 2 transactions (numbers 1 and 2).  One transaction simply reads data from some resource ( <strong>x</strong> ), and the second transaction also reads it, does some math based on these two readings <strong>x,</strong> and writes something to <strong>y</strong> . <br><br>  Very convenient - transactions consist of elementary actions ‚Äúread-write, read-write‚Äù.  We can make a final schedule, check it, whether there are conflicts in it, with the help of any clever mathematics, and thus ensure that everything will be good and complete. <br><br>  What is all this for? <br><br><h2>  Two phase locking <br></h2><br>  One of the fundamental algorithms in modern databases is the so-called two-phase blocking or <strong>2PL</strong> (Two Phase Locking). <br><br>  It is two-phase because it was noticed that in order to optimize the taking and unlocking of locks in the database, it is convenient to do it in 2 sessions: <br><br><ol><li>  First, we set locks for all resources that need to be read or written to a bunch of transactions that are currently in the database. <br></li><li>  Not a single lock is released until all necessary locks are set. <br></li></ol><br>  This allows for more efficient transaction management so that they do not wait. <br><br><img src="https://habrastorage.org/webt/5k/8y/gd/5k8ygdkxzdhtlbdsaf6ajpr5sug.jpeg"><br><br>  In Figure 3, the rulers denote transactions and the time of their execution.  It can be seen that the write operation in the first transaction of the resource <strong>x</strong> has a nonzero time, since the recording takes some time - until the disk turns, until the pages go there, etc. <br><br>  When it starts, there are no other transactions in this model, so the recording began and is being written.  But the second transaction must also read <strong>x</strong> .  This transaction cannot take a lock on reading <strong>x</strong> for the simple reason that <strong>x</strong> is being written by another transaction at this moment.  The line becomes dashed - this means that the transaction is waiting for a lock, which was set by transaction <em>t</em> <sub>1</sub> . <br><br>  As soon as transaction <em>t</em> <sub>2</sub> took all the locks that it needed in order for it to execute ‚Äî it still needs a lock on <strong>y</strong> and a lock on <strong>z</strong> ‚Äî only then can it begin to release them.  At this point, the next transaction is unblocked, which also runs to the end. <br><br>  This idea increases the efficiency of transactions and allows the same operations to be built in parallel only in such a way that elementary operations are blocked and waited only if they conflict. <br><br><blockquote>  I recommend the book Transactional Information Systems (Gerhard Weikum, Gottfried Vossen) - this is a fundamental textbook on transaction theory. <br></blockquote><br><h3>  What is bad in biphasic blocking? <br></h3><br>  Why can't it be so easy to solve the whole problem with all databases using one simple magic algorithm? <br><br>  ‚úì First, with such locks, deadlocks inevitably arise when it is not clear whether a chicken or an egg. <br><br>  One transaction needs a resource <strong>x</strong> , another <strong>y</strong> , they block it, and then they need to criss-cross the same resources, and it‚Äôs not clear who should release the lock first.  For this purpose, databases have special control systems for deadlock and so-called deadlock shooting.  Deadlock cannot be resolved in a peaceful way, but only by rolling back one of the transactions. <br><br>  Usually, the mathematics inside the deadlock detection is the deadlock graph, where the transaction ID is indicated on the vertices, and the directed edges indicate which one waits for a lock from which one.  On this graph, small subgraphs from one of these vertices stand out, it looks, for example, if a very large number of transactions are waiting for one transaction, then this transaction is nailed. <br><br>  But there are other beautiful mathematical approaches that you can look for on the topic of deadlock-detection. <br><br>  ‚úì The second point is <strong>slow</strong> - no one wants to wait for the lock. <br><br>  There are transactions that take up a resource for a long time, for example, some report considers it occupied a resource, and everyone else has to wait.  To avoid this, came up with some improvements, which will talk about later. <br><br>  ‚úì But in this way <strong>serialization is provided</strong> . <br><br>  Without biphasic blocking, there is no serialization.  That is, you need to figure out how to improve biphasic blocking in order to reduce the waiting time. <br><br><blockquote>  In any modern database, two-phase locking is the <strong>main way to ensure integrity and serialization,</strong> even if we are talking about versioned databases. <br></blockquote><br>  In fact, there are conflicts that 2PL cannot resolve in principle, and then one of the conflicting transactions is rolled back.  Usually, a mechanism is implemented in databases, when the database is waiting for some time and realizes that a certain transaction is waiting for a lock for too long, and that there is no way to resolve the conflict, the database simply kills the transaction.  This is quite a rare situation and the following algorithm allows to solve some of these conflicts. <br><br><h2>  MVCC - MultiVersion Concurrency Control <br></h2><br>  Data versioning is necessary not only to speed up, but also to solve some types of conflicts that may arise. <br><br>  ‚úì Intuitively everything is clear - in order not to wait for blocking, we take the previous version. <br><br>  If a resource is locked, we can look at its old version and start working with it.  If, for example, the lock was such that the transaction that blocked did not change anything on this resource, then we can continue the execution of the transaction.  If there was a change and a new, more recent version of the data appeared, our transaction will be forced to re-read them again. <br><br>  In any case, it is usually faster than waiting for a lock.  If you remember the old MS SQL Server and the old versions of DB2, a terrible thing, then there, if there were a lot of locks, then their escalation started - everything worked badly and it was hard to live with it. <br><br>  ‚úì All modern DBMS in one degree or another "version" <br><br>  Oracle, PostgreSQL, MySQL are all ‚Äúversioned‚Äù in fair form.  DB2 is a bit more original on this topic, it has its own mechanism - only one previous version is stored. <br><br><img src="https://habrastorage.org/webt/po/10/ty/po10tylw9umnnv3t2lxtvxwm8wq.jpeg"><br><br>  This schedule, which I painted earlier, but a little more complicated.  There are more transactions (3 pieces), more resources (there are <strong>z</strong> ) and 2 commits.  That is, both transactions end with a commit. <br><br>  As the mathematicians say in such cases: ‚ÄúIt is easy to notice ...‚Äù - I love it very much, especially when there is a formula on half the board.  Indeed, it is easy to see one thing here.  For homework, try to understand why this is easy to see. <br><br>  I'll tell you.  This schedule is never serialized for the simple reason that the operation <strong>r <sub>1</sub> (y)</strong> will cause a conflict, perhaps even deadlock, if the previous version of <strong>y is</strong> not available. <br><br>  That is, if the previous version of <strong>y</strong> is available here, then the transaction will normally end, there will be no problems.  If this version of <strong>y is</strong> not, then the operation will conflict. <br><br><h3>  How it works? <br></h3><br><img src="https://habrastorage.org/webt/tp/fw/ym/tpfwymegaki0jf-j0d7thv3xfym.jpeg"><br><br>  The diagram is more or less the same as biphasic blocking.  This is a kind of versioned transaction sheduling, that is, it is still a two-phase blocking algorithm, only multiversion. <br><br>  Another feature is added, such as the subscript - 0, 1, 2 - this is the version number. <br><br><ul><li>  When we went to execute transaction <em>t</em> <sub>1</sub> , there is a read <strong><em>x</em> <sub>0</sub></strong> , i.e.  the most original version. <br></li><li>  Further at <em>t</em> <sub>2,</sub> we begin to write <strong><em>y of a</em></strong> different version, because it was changed. <br></li><li>  In the transaction <em>t</em> <sub>1</sub> , which started earlier than we started writing <strong><em>y</em></strong> , the previous version <em>y</em> <sub>0</sub> is still visible, since <em>t</em> <sub>2</sub> has not finished yet, and we can calmly start working with it. <br></li><li>  Since transaction <em>t</em> <sub>1</sub> ends earlier than <em>w</em> <sub>2</sub> ( <em>y</em> <sub>2</sub> ), <em>y</em> will reread, and after that in transaction <em>t</em> <sub>2,</sub> normal operation is completed, and the other transaction just completes normally. <br></li></ul><br>  If you try to imagine that there are no previous versions, then long dotted lines will begin immediately.  When you need to read <em>y</em> , the solid line does not begin, but will be dashed, because <em>w</em> <sub>2</sub> ( <em>y</em> ) will wait for it to end <em>t</em> <sub>1</sub> .  Accordingly, the schedule will go wide and everything will be much slower. <br><br>  This is a big plus MVCC.  Multiversion is actually faster than blocking, it‚Äôs not just a marketing feature. <br><br>  And what if at the time of the transaction, which clearly has a non-zero duration, a failure occurs, for example, the hard disk collapses under the database or pulls the wires from the server? <br><br>  In fact, we are ready for this, because transactions are performed like this.  Consider an abstract database: <br><br><img src="https://habrastorage.org/webt/8v/xl/ub/8vxlubdwtn1mc29yqx2yzwjpkng.jpeg"><br><br>  There is a certain amount of memory that is socialized between different processes or threads in which client connections are processed.  The thread has its own memory, where the SQL query comes.  In this memory, the SQL query (or a query in another language) is precompiled, interpreted, rebuilt in some way. <br><br>  Then he goes for the data that he needs to read and change.  These data on a disk lie in a special way.  If you look deeper into storage, they are fixed pieces (pages) in PostgreSQL is 8Kb, in Oracle, you can use different sizes.  In different databases in different ways. <br><br>  This page is very convenient because there is a lot of different data in it (in fact, there are tuples in it) That is, there is a sign, and there are lines in it, these lines are packed into large pages. <br><br>  If the request requires data from one of the pages, it simply raises this page to its memory and all the workers, threads and database processes will have access to it.  If you need a lot, then he will raise a few.  They will be cached - it is convenient, productive - the memory is faster than the disks, all things. <br><br>  If you need to change at least one entry on at least one page, the whole page will be marked as so-called ‚Äúdirty‚Äù.  This is done because it is more convenient.  We drew <em>x</em> and <em>y</em> resources on the schematic ‚Äî here are the pages. <br><br>  In fact, the database can block at a more granular level, including a single entry.  But now we are talking about more theoretical things, and not about the intricacies of deep realization. <br><br>  Accordingly, the page is marked as ‚Äúdirty‚Äù, and we have a problem, which is that now the impression in memory is different from the one on the disk.  If we fall now, the memory is not persistent, we will lose information about the dirty pages. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Therefore, we need to do the following operation: somewhere on a piece of paper, write down what changes we have made, so that when we get up, read this piece of paper and, using information from it, restore the page to the state in which we brought it with this update. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Therefore, before the response from the transaction returns to the client again, it writes to the so-called Write Ahead Log. This is the same piece of paper that allows you to write quickly - the record in WAL is consistent, we don‚Äôt need to look for where to put this file into a huge data file. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We recorded information about the page in the log and then returned control - everything is fine. If at some point fell, then read back Write Ahead Log and using the information about these changes, we can finish the clean pages to the level of "dirty." Our database is new again.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> This allows you to perform the same recovery that we needed to provide, based on data storage problems, and allows you to recover for the most recent transaction, for the very last action that took place before Marna Ivanna pulled the server out of the socket. </font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This algorithm is called ARIES and in its present form it was made quite a long time ago. </font><font style="vertical-align: inherit;">The fundamental article on its device and method of recovery in relational databases was published by Mohan in 1992.</font></font><br></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Since then, the theory is not particularly added - Write Ahead Log has since remained Write Ahead Log. </font><font style="vertical-align: inherit;">They all use the concept of pages and the concept of change log entries. </font><font style="vertical-align: inherit;">The log can be differently named and located in different places:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> In MySQL, it is inside InnoDB, </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> In PostgreSQL, this is a separate directory, which finally in version 10 was called WAL instead of PGX-Log; </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> In Oracle, this is called Redo Log; </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> In DB2 - WAL. </font></font><br></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In principle, everything is more or less the same everywhere - in order to recover, we use WAL. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The important point is that all this would be very unproductive if we just wrote WAL from the beginning of time. </font><font style="vertical-align: inherit;">He would grow and grew, and then we would very long roll these changes into the database.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Checkpoint </font></font><br></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Therefore, in the last reincarnation of this algorithm, there is the idea of ‚Äã‚Äãthe so-called Checkpoint - periodically the database synchronizes the "dirty" pages to disk. </font><font style="vertical-align: inherit;">When we recover, you can just walk only to the previous Checkpoint. </font><font style="vertical-align: inherit;">Everything else is already synchronized, we, so to speak, notice to what point we recovered. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It's like in a computer game - people, when it passes, are saved periodically. </font><font style="vertical-align: inherit;">Or, as in Word, they periodically save their files so that the text does not go anywhere. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The database is able to do it all inside. </font><font style="vertical-align: inherit;">It is so arranged. </font><font style="vertical-align: inherit;">In addition, it speeds up the process a little bit, because sooner or later these pages should get onto the disk.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Data access </font></font><br></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">These very pages, of course, are good, but we need to get this data in some more human-readable form. The page model is convenient for storage and transactional algorithms, but not convenient for access. It is inconvenient to read the pages - bit by bit, therefore, an effective method of accessing the data in the pages is needed more convenient to a person. </font></font><br><br><img src="https://habrastorage.org/webt/cf/um/9g/cfum9gnnzegpspe_dio4---osjw.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There is a page on the disc, referring to Table </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bed and</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . The data on the disk does not know what label they refer to. Our optimizer knows about this, that is, the engine in the database that executes our query, written in our query language. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For example, if we consider traditional SQL, then usually such a thing will be called a query plan. Using sequential sequential scan, we will take pages from the table</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and from table </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - sometimes synchronously, sometimes in turn - depending on the implementation. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We will continue to impose on them, for example, JOIN, and with the result do something else, and then return the answer to the client.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What is convenient? Imagine an alternative: you are reading all this from your Python to your application, and these labels can be really huge, and the JOIN condition can exclude 90% of this data. You pull it into memory - there, respectively, go through them in cycles, sorting, returning. In fact, at each of these stages, the planner can decide how to make it more profitable. For example, it can choose a JOIN method, which can either consist entirely of cycles, or it can cache one table and attach another table to it, etc. Depending on the method, for example, you can not do full sequential scan, that is, do not read the entire table, and from the application, most likely you will have to read the entire data. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here everything is thought up to you and implemented effectively.</font></font><br><br><h1>  findings <br></h1><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SQL and the relational model are convenient</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> for optimization and for a human-readable representation, so there is </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no query language</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . The death of SQL as a technology is predicted for many years, but grandpa is very much alive. This is largely because of the easiest way to optimize and use algorithms on relational models using SQL. </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Store data more convenient pages</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . There are different databases: object, graph, document-oriented. Basically, these are all niche, non-universal products that are used for their own purposes. It‚Äôs not easy to simply put a huge amount of transactions on such a base so that they work in a universal form. Sheduling transactions, which we considered here, on objects looks much more complicated.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In fact, each transaction is a path by column. </font><font style="vertical-align: inherit;">Count can be very large. </font><font style="vertical-align: inherit;">To find conflicts, you need to deal with very heavy math on graphs - therefore, there are problems with shedling in the object model. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It is no coincidence that for so many years the database with the page model has dominated, and therefore everything happens as it does. </font><font style="vertical-align: inherit;">Is it good or bad, but this method has proven to be very effective.</font></font><br><br><blockquote> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No transaction in any way!</font></font></strong> <br></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Transactions, contrary to popular belief, this is </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">not a way to slow down</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . It is often considered that transactions are some kind of syntactic sugar in databases with SQL, which simply spoils everything and bibbles, in the sense that it slows down everything, because we are waiting for locks. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In fact, transactions are a method of acceleration, since they allow processing more data in parallel without conflicts, so that they do not fight, so that the operations are not performed strictly one after the other, but in parallel. </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This allows more efficient use of computing resources and time.</font></font></strong> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> In the words of the designer Tupolev, when he was accused of having pulled off any aircraft model: ‚ÄúAll airplanes are equally arranged - in order to fly, they need to have wings, fuselage and tail!‚Äù</font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">All databases inside are similar.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> They are either arranged equally to one degree or another, or they go there. NoSQL appeared - without transactions, without locks, without everything, it is absolutely not similar to any database. But we observe that gradually there appear locks, schemas, query language, optimization, etc. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In some even, probably, parallelism will soon appear, and this will be a great </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">victory for the forces of reason</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you look at modern Percona server, MariaDB, MySQL 8, you can see that they largely adopt theoretical foundations and now they are much more similar to classic databases in their structure.</font></font><br><br><blockquote>  , ,      ? <br><br>    ‚Ä¶   <a href="http://ritfest.ru/moscow/2018">++</a> ,   ,   <a href="http://www.highload.ru/siberia/">Highload++ Siberia</a> <b>  </b> ,  -     . <br><br> ,          : <br><br><ul><li> <b> </b>  <b> </b>   , <a href="http://www.highload.ru/siberia/2018/abstracts/3298">   Oracle  7-  18-</a> ,      . <br></li><li> <b> </b> (Altinity)  <b> </b> (Ivinco)   <a href="http://www.highload.ru/siberia/2018/abstracts/3718">   MySQL  ClickHouse   </a>    . <br></li><li> <b> </b> ()    <a href="http://www.highload.ru/siberia/2018/abstracts/3633">  LZ4</a> . <br></li></ul></blockquote></div><p>Source: <a href="https://habr.com/ru/post/358984/">https://habr.com/ru/post/358984/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../358972/index.html">Maraquia - ORM for MongoDB</a></li>
<li><a href="../358974/index.html">How update Rust 1.26 sped up my code more than three times</a></li>
<li><a href="../358976/index.html">Cofree Will Tear Us Apart</a></li>
<li><a href="../358978/index.html">The digest of fresh materials from the world of the frontend for the last week No. 315 (May 14 - 20, 2018)</a></li>
<li><a href="../358982/index.html">How do I want to invest in cryptocurrency or venture projects?</a></li>
<li><a href="../358986/index.html">How to train juniors inside the company: the experience of the company Lodoss Team</a></li>
<li><a href="../358988/index.html">Why we live inside space, but on the side of time. The difference in perception of time and space</a></li>
<li><a href="../358990/index.html">Announcement of the mitap of RubyRoars # 1 in Kharkov</a></li>
<li><a href="../358992/index.html">11 best fonts for programming</a></li>
<li><a href="../358994/index.html">Automatic accrual of fines according to the Unified State Automated Information System: fiction or reality?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>