<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Can bitcoins be calculated faster, easier or easier?</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="It all started with the fact that I decided to get acquainted with Bitcoins. I wanted to understand how they are mined. Articles about bitcoins and bl...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Can bitcoins be calculated faster, easier or easier?</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/files/cdc/697/eac/cdc697eacc7a4bf4907c3b8407279cf7.jpg"></div><br>  It all started with the fact that I decided to get acquainted with Bitcoins.  I wanted to understand how they are mined.  Articles about bitcoins and blockchains are often found recently, but such that with all the technical details, there are not many of them. <br><br>  The easiest way to understand all the details is to study open source.  I undertook to study the Verilog <a href="https://github.com/progranism/Open-Source-FPGA-Bitcoin-Miner">FPGA miner's</a> source code.  This is not the only such project, there are a few more examples on github, and all of them, albeit from different authors, seem to work along roughly the same lines.  It is possible that the author then all of them was originally the same, just different developers adapt the same code for different chips and different boards ... At least it seemed to me ... <br><br>  So I, having studied the source code of Verilog, adapted the project with github to the Mars Rover3 board based on the FPGA Altera MAX10, 50 thousand logical elements.  I was able to start my miner and even was able to start the process of calculating bitcoins, but I quit this business in half an hour because of the futility.  My FPGA miner is too slow in its current times.  Well, let. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Honestly, in this whole project I was not interested in the Bitcoins themselves (well, they, these money surrogates), but rather the mathematical side of the SHA256 algorithm.  That's what I would like to talk about.  I have conducted several experiments with the SHA256 algorithm, maybe the results of these experiments will seem interesting to you. <br><a name="habracut"></a><br>  The first thing I needed to do for my experiments was to write a ‚Äúclean‚Äù implementation of SHA256 on Verilog. <br><br>  In fact, there are many implementations of the SHA256 algorithm in Verilog, at least on the same <a href="http://opencores.org/projects">opencores.org</a> , at least on <a href="https://github.com/search%3Futf8%3D%25E2%259C%2593%26q%3Dsha256%2Blanguage%253AVerilog%26type%3DRepositories%26ref%3Dadvsearch%26l%3DVerilog%26l%3D">github.com</a> .  However, such implementations are not suitable for me for experiments.  Existing modules always have a pipeline structure, pipeline.  It would seem - this is correct.  Only with the presence of the pipeline, you can get a high speed of the algorithm.  The SHA256 algorithm consists of 64 processing steps, the so-called "rounds".  If the FPGA volume allows, it is possible to expand all 64 rounds into a single chain of operations: all the computation steps are performed in parallel in one cycle of the operating frequency.  Like this: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/4a1/9e7/d27/4a19e7d271e648fd855f90d34954c422.png"></div><br>  At the input of the algorithm, eight 32-bit state words of the SHA256 machine.  These are registers A, B, C, D, E, F, G, H. The input data itself, 512 bits, will be converted into coefficients W, which are mixed in at each round.  While new data words are being loaded into the registers of the first round, the second round continues to read the data loaded at the previous clock cycle, the third round continues to count what was loaded at the previous previous bar, and so on.  The final latency, that is, the delay of the result of the calculations will be just 64 clocks, but on the whole the pipeline / pipeline allows you to read the whole algorithm for 1 clock.  If the FPGA volume is small and does not allow to expand the whole chain of rounds, then it is shortened by half.  This is how it turns out to fit the project into an existing FPGA, but the computational rate naturally drops twice.  You can take an even less capacious FPGA and fit it there, but you will still have to shorten the pipeline and performance will suffer again.  As I understand it, the whole Bitcoin miner, in which two consecutive SHA256-transforms need about 80 thousand logical elements in Altera / Intel FPGAs.  But I was distracted ... <br><br>  So, I want to do a completely absurd thing - to write on Verilog the ‚Äúpure‚Äù function of the SHA256 algorithm without intermediate registers, to leave it without a pipeline.  The goal of this strange action is simple - to determine the actual amount of logic needed to calculate the SHA256 algorithm.  I need a simple combination circuit that feeds 512 data bits to the input (well, 256 bits of the initial state) and it gives 256 bits of the result. <br><br>  I wrote this Verilog module, somewhere I wrote something myself, borrowed something from other open sources.  My project is "sha256-test". <br><br><div class="spoiler">  <b class="spoiler_title">Here is a pure combination SHA256, not a single intermediate register</b> <div class="spoiler_text"><pre><code class="hljs mel">module e0 (x, y); input [<span class="hljs-number"><span class="hljs-number">31</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] x; output [<span class="hljs-number"><span class="hljs-number">31</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] y; assign y = {x[<span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>],x[<span class="hljs-number"><span class="hljs-number">31</span></span>:<span class="hljs-number"><span class="hljs-number">2</span></span>]} ^ {x[<span class="hljs-number"><span class="hljs-number">12</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>],x[<span class="hljs-number"><span class="hljs-number">31</span></span>:<span class="hljs-number"><span class="hljs-number">13</span></span>]} ^ {x[<span class="hljs-number"><span class="hljs-number">21</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>],x[<span class="hljs-number"><span class="hljs-number">31</span></span>:<span class="hljs-number"><span class="hljs-number">22</span></span>]}; endmodule module e1 (x, y); input [<span class="hljs-number"><span class="hljs-number">31</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] x; output [<span class="hljs-number"><span class="hljs-number">31</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] y; assign y = {x[<span class="hljs-number"><span class="hljs-number">5</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>],x[<span class="hljs-number"><span class="hljs-number">31</span></span>:<span class="hljs-number"><span class="hljs-number">6</span></span>]} ^ {x[<span class="hljs-number"><span class="hljs-number">10</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>],x[<span class="hljs-number"><span class="hljs-number">31</span></span>:<span class="hljs-number"><span class="hljs-number">11</span></span>]} ^ {x[<span class="hljs-number"><span class="hljs-number">24</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>],x[<span class="hljs-number"><span class="hljs-number">31</span></span>:<span class="hljs-number"><span class="hljs-number">25</span></span>]}; endmodule module ch (x, y, z, o); input [<span class="hljs-number"><span class="hljs-number">31</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] x, y, z; output [<span class="hljs-number"><span class="hljs-number">31</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] o; assign o = z ^ (x &amp; (y ^ z)); endmodule module maj (x, y, z, o); input [<span class="hljs-number"><span class="hljs-number">31</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] x, y, z; output [<span class="hljs-number"><span class="hljs-number">31</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] o; assign o = (x &amp; y) | (z &amp; (x | y)); endmodule module s0 (x, y); input [<span class="hljs-number"><span class="hljs-number">31</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] x; output [<span class="hljs-number"><span class="hljs-number">31</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] y; assign y[<span class="hljs-number"><span class="hljs-number">31</span></span>:<span class="hljs-number"><span class="hljs-number">29</span></span>] = x[<span class="hljs-number"><span class="hljs-number">6</span></span>:<span class="hljs-number"><span class="hljs-number">4</span></span>] ^ x[<span class="hljs-number"><span class="hljs-number">17</span></span>:<span class="hljs-number"><span class="hljs-number">15</span></span>]; assign y[<span class="hljs-number"><span class="hljs-number">28</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] = {x[<span class="hljs-number"><span class="hljs-number">3</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>], x[<span class="hljs-number"><span class="hljs-number">31</span></span>:<span class="hljs-number"><span class="hljs-number">7</span></span>]} ^ {x[<span class="hljs-number"><span class="hljs-number">14</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>],x[<span class="hljs-number"><span class="hljs-number">31</span></span>:<span class="hljs-number"><span class="hljs-number">18</span></span>]} ^ x[<span class="hljs-number"><span class="hljs-number">31</span></span>:<span class="hljs-number"><span class="hljs-number">3</span></span>]; endmodule module s1 (x, y); input [<span class="hljs-number"><span class="hljs-number">31</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] x; output [<span class="hljs-number"><span class="hljs-number">31</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] y; assign y[<span class="hljs-number"><span class="hljs-number">31</span></span>:<span class="hljs-number"><span class="hljs-number">22</span></span>] = x[<span class="hljs-number"><span class="hljs-number">16</span></span>:<span class="hljs-number"><span class="hljs-number">7</span></span>] ^ x[<span class="hljs-number"><span class="hljs-number">18</span></span>:<span class="hljs-number"><span class="hljs-number">9</span></span>]; assign y[<span class="hljs-number"><span class="hljs-number">21</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] = {x[<span class="hljs-number"><span class="hljs-number">6</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>],x[<span class="hljs-number"><span class="hljs-number">31</span></span>:<span class="hljs-number"><span class="hljs-number">17</span></span>]} ^ {x[<span class="hljs-number"><span class="hljs-number">8</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>],x[<span class="hljs-number"><span class="hljs-number">31</span></span>:<span class="hljs-number"><span class="hljs-number">19</span></span>]} ^ x[<span class="hljs-number"><span class="hljs-number">31</span></span>:<span class="hljs-number"><span class="hljs-number">10</span></span>]; endmodule module round (idx, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span>, k, w, out); input [<span class="hljs-number"><span class="hljs-number">7</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>]idx; input [<span class="hljs-number"><span class="hljs-number">255</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">in</span></span>; input [ <span class="hljs-number"><span class="hljs-number">31</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>]k; input [ <span class="hljs-number"><span class="hljs-number">31</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>]w; output [<span class="hljs-number"><span class="hljs-number">255</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>]out; always @(w) $display(<span class="hljs-string"><span class="hljs-string">"i=%dk=%8x w=%8x"</span></span>,idx,k,w); <span class="hljs-keyword"><span class="hljs-keyword">wire</span></span> [<span class="hljs-number"><span class="hljs-number">31</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>]a; assign a = <span class="hljs-keyword"><span class="hljs-keyword">in</span></span>[ <span class="hljs-number"><span class="hljs-number">31</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">wire</span></span> [<span class="hljs-number"><span class="hljs-number">31</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>]b; assign b = <span class="hljs-keyword"><span class="hljs-keyword">in</span></span>[ <span class="hljs-number"><span class="hljs-number">63</span></span>: <span class="hljs-number"><span class="hljs-number">32</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">wire</span></span> [<span class="hljs-number"><span class="hljs-number">31</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>]c; assign c = <span class="hljs-keyword"><span class="hljs-keyword">in</span></span>[ <span class="hljs-number"><span class="hljs-number">95</span></span>: <span class="hljs-number"><span class="hljs-number">64</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">wire</span></span> [<span class="hljs-number"><span class="hljs-number">31</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>]d; assign d = <span class="hljs-keyword"><span class="hljs-keyword">in</span></span>[<span class="hljs-number"><span class="hljs-number">127</span></span>: <span class="hljs-number"><span class="hljs-number">96</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">wire</span></span> [<span class="hljs-number"><span class="hljs-number">31</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>]e; assign e = <span class="hljs-keyword"><span class="hljs-keyword">in</span></span>[<span class="hljs-number"><span class="hljs-number">159</span></span>:<span class="hljs-number"><span class="hljs-number">128</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">wire</span></span> [<span class="hljs-number"><span class="hljs-number">31</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>]f; assign f = <span class="hljs-keyword"><span class="hljs-keyword">in</span></span>[<span class="hljs-number"><span class="hljs-number">191</span></span>:<span class="hljs-number"><span class="hljs-number">160</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">wire</span></span> [<span class="hljs-number"><span class="hljs-number">31</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>]g; assign g = <span class="hljs-keyword"><span class="hljs-keyword">in</span></span>[<span class="hljs-number"><span class="hljs-number">223</span></span>:<span class="hljs-number"><span class="hljs-number">192</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">wire</span></span> [<span class="hljs-number"><span class="hljs-number">31</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>]h; assign h = <span class="hljs-keyword"><span class="hljs-keyword">in</span></span>[<span class="hljs-number"><span class="hljs-number">255</span></span>:<span class="hljs-number"><span class="hljs-number">224</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">wire</span></span> [<span class="hljs-number"><span class="hljs-number">31</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>]e0_w; e0 e0_(a,e0_w); <span class="hljs-keyword"><span class="hljs-keyword">wire</span></span> [<span class="hljs-number"><span class="hljs-number">31</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>]e1_w; e1 e1_(e,e1_w); <span class="hljs-keyword"><span class="hljs-keyword">wire</span></span> [<span class="hljs-number"><span class="hljs-number">31</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>]ch_w; ch ch_(e,f,g,ch_w); <span class="hljs-keyword"><span class="hljs-keyword">wire</span></span> [<span class="hljs-number"><span class="hljs-number">31</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>]mj_w; maj maj_(a,b,c,mj_w); <span class="hljs-keyword"><span class="hljs-keyword">wire</span></span> [<span class="hljs-number"><span class="hljs-number">31</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>]t1; assign t1 = h+w+k+ch_w+e1_w; <span class="hljs-keyword"><span class="hljs-keyword">wire</span></span> [<span class="hljs-number"><span class="hljs-number">31</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>]t2; assign t2 = mj_w+e0_w; <span class="hljs-keyword"><span class="hljs-keyword">wire</span></span> [<span class="hljs-number"><span class="hljs-number">31</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>]a_; assign a_ = t1+t2; <span class="hljs-keyword"><span class="hljs-keyword">wire</span></span> [<span class="hljs-number"><span class="hljs-number">31</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>]d_; assign d_ = d+t1; assign out = { g,f,e,d_,c,b,a,a_ }; endmodule module sha256_transform( input <span class="hljs-keyword"><span class="hljs-keyword">wire</span></span> [<span class="hljs-number"><span class="hljs-number">255</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>]state_in, input <span class="hljs-keyword"><span class="hljs-keyword">wire</span></span> [<span class="hljs-number"><span class="hljs-number">511</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>]data_in, output <span class="hljs-keyword"><span class="hljs-keyword">wire</span></span> [<span class="hljs-number"><span class="hljs-number">255</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>]state_out ); localparam Ks = { <span class="hljs-number"><span class="hljs-number">32</span></span><span class="hljs-string"><span class="hljs-string">'h428a2f98, 32'</span></span>h71374491, <span class="hljs-number"><span class="hljs-number">32</span></span><span class="hljs-string"><span class="hljs-string">'hb5c0fbcf, 32'</span></span>he9b5dba5, <span class="hljs-number"><span class="hljs-number">32</span></span><span class="hljs-string"><span class="hljs-string">'h3956c25b, 32'</span></span>h59f111f1, <span class="hljs-number"><span class="hljs-number">32</span></span><span class="hljs-string"><span class="hljs-string">'h923f82a4, 32'</span></span>hab1c5ed5, <span class="hljs-number"><span class="hljs-number">32</span></span><span class="hljs-string"><span class="hljs-string">'hd807aa98, 32'</span></span>h12835b01, <span class="hljs-number"><span class="hljs-number">32</span></span><span class="hljs-string"><span class="hljs-string">'h243185be, 32'</span></span>h550c7dc3, <span class="hljs-number"><span class="hljs-number">32</span></span><span class="hljs-string"><span class="hljs-string">'h72be5d74, 32'</span></span>h80deb1fe, <span class="hljs-number"><span class="hljs-number">32</span></span><span class="hljs-string"><span class="hljs-string">'h9bdc06a7, 32'</span></span>hc19bf174, <span class="hljs-number"><span class="hljs-number">32</span></span><span class="hljs-string"><span class="hljs-string">'he49b69c1, 32'</span></span>hefbe4786, <span class="hljs-number"><span class="hljs-number">32</span></span><span class="hljs-string"><span class="hljs-string">'h0fc19dc6, 32'</span></span>h240ca1cc, <span class="hljs-number"><span class="hljs-number">32</span></span><span class="hljs-string"><span class="hljs-string">'h2de92c6f, 32'</span></span>h4a7484aa, <span class="hljs-number"><span class="hljs-number">32</span></span><span class="hljs-string"><span class="hljs-string">'h5cb0a9dc, 32'</span></span>h76f988da, <span class="hljs-number"><span class="hljs-number">32</span></span><span class="hljs-string"><span class="hljs-string">'h983e5152, 32'</span></span>ha831c66d, <span class="hljs-number"><span class="hljs-number">32</span></span><span class="hljs-string"><span class="hljs-string">'hb00327c8, 32'</span></span>hbf597fc7, <span class="hljs-number"><span class="hljs-number">32</span></span><span class="hljs-string"><span class="hljs-string">'hc6e00bf3, 32'</span></span>hd5a79147, <span class="hljs-number"><span class="hljs-number">32</span></span><span class="hljs-string"><span class="hljs-string">'h06ca6351, 32'</span></span>h14292967, <span class="hljs-number"><span class="hljs-number">32</span></span><span class="hljs-string"><span class="hljs-string">'h27b70a85, 32'</span></span>h2e1b2138, <span class="hljs-number"><span class="hljs-number">32</span></span><span class="hljs-string"><span class="hljs-string">'h4d2c6dfc, 32'</span></span>h53380d13, <span class="hljs-number"><span class="hljs-number">32</span></span><span class="hljs-string"><span class="hljs-string">'h650a7354, 32'</span></span>h766a0abb, <span class="hljs-number"><span class="hljs-number">32</span></span><span class="hljs-string"><span class="hljs-string">'h81c2c92e, 32'</span></span>h92722c85, <span class="hljs-number"><span class="hljs-number">32</span></span><span class="hljs-string"><span class="hljs-string">'ha2bfe8a1, 32'</span></span>ha81a664b, <span class="hljs-number"><span class="hljs-number">32</span></span><span class="hljs-string"><span class="hljs-string">'hc24b8b70, 32'</span></span>hc76c51a3, <span class="hljs-number"><span class="hljs-number">32</span></span><span class="hljs-string"><span class="hljs-string">'hd192e819, 32'</span></span>hd6990624, <span class="hljs-number"><span class="hljs-number">32</span></span><span class="hljs-string"><span class="hljs-string">'hf40e3585, 32'</span></span>h106aa070, <span class="hljs-number"><span class="hljs-number">32</span></span><span class="hljs-string"><span class="hljs-string">'h19a4c116, 32'</span></span>h1e376c08, <span class="hljs-number"><span class="hljs-number">32</span></span><span class="hljs-string"><span class="hljs-string">'h2748774c, 32'</span></span>h34b0bcb5, <span class="hljs-number"><span class="hljs-number">32</span></span><span class="hljs-string"><span class="hljs-string">'h391c0cb3, 32'</span></span>h4ed8aa4a, <span class="hljs-number"><span class="hljs-number">32</span></span><span class="hljs-string"><span class="hljs-string">'h5b9cca4f, 32'</span></span>h682e6ff3, <span class="hljs-number"><span class="hljs-number">32</span></span><span class="hljs-string"><span class="hljs-string">'h748f82ee, 32'</span></span>h78a5636f, <span class="hljs-number"><span class="hljs-number">32</span></span><span class="hljs-string"><span class="hljs-string">'h84c87814, 32'</span></span>h8cc70208, <span class="hljs-number"><span class="hljs-number">32</span></span><span class="hljs-string"><span class="hljs-string">'h90befffa, 32'</span></span>ha4506ceb, <span class="hljs-number"><span class="hljs-number">32</span></span><span class="hljs-string"><span class="hljs-string">'hbef9a3f7, 32'</span></span>hc67178f2}; genvar i; generate <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;<span class="hljs-number"><span class="hljs-number">64</span></span>; i=i+<span class="hljs-number"><span class="hljs-number">1</span></span>) begin : RND <span class="hljs-keyword"><span class="hljs-keyword">wire</span></span> [<span class="hljs-number"><span class="hljs-number">255</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] state; <span class="hljs-keyword"><span class="hljs-keyword">wire</span></span> [<span class="hljs-number"><span class="hljs-number">31</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>]W; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(i&lt;<span class="hljs-number"><span class="hljs-number">16</span></span>) begin assign W = data_in[i*<span class="hljs-number"><span class="hljs-number">32</span></span>+<span class="hljs-number"><span class="hljs-number">31</span></span>:i*<span class="hljs-number"><span class="hljs-number">32</span></span>]; end <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> begin <span class="hljs-keyword"><span class="hljs-keyword">wire</span></span> [<span class="hljs-number"><span class="hljs-number">31</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>]s0_w; s0 so_(RND[i<span class="hljs-number"><span class="hljs-number">-15</span></span>].W,s0_w); <span class="hljs-keyword"><span class="hljs-keyword">wire</span></span> [<span class="hljs-number"><span class="hljs-number">31</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>]s1_w; s1 s1_(RND[i<span class="hljs-number"><span class="hljs-number">-2</span></span>].W,s1_w); assign W = s1_w + RND[i - <span class="hljs-number"><span class="hljs-number">7</span></span>].W + s0_w + RND[i - <span class="hljs-number"><span class="hljs-number">16</span></span>].W; end <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(i == <span class="hljs-number"><span class="hljs-number">0</span></span>) round R ( .idx(i[<span class="hljs-number"><span class="hljs-number">7</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>]), .<span class="hljs-keyword"><span class="hljs-keyword">in</span></span>(state_in), .k( Ks[<span class="hljs-number"><span class="hljs-number">32</span></span>*(<span class="hljs-number"><span class="hljs-number">63</span></span>-i)+<span class="hljs-number"><span class="hljs-number">31</span></span>:<span class="hljs-number"><span class="hljs-number">32</span></span>*(<span class="hljs-number"><span class="hljs-number">63</span></span>-i)] ), .w(W), .out(state) ); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> round R ( .idx(i[<span class="hljs-number"><span class="hljs-number">7</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>]), .<span class="hljs-keyword"><span class="hljs-keyword">in</span></span>(RND[i<span class="hljs-number"><span class="hljs-number">-1</span></span>].state), .k( Ks[<span class="hljs-number"><span class="hljs-number">32</span></span>*(<span class="hljs-number"><span class="hljs-number">63</span></span>-i)+<span class="hljs-number"><span class="hljs-number">31</span></span>:<span class="hljs-number"><span class="hljs-number">32</span></span>*(<span class="hljs-number"><span class="hljs-number">63</span></span>-i)] ), .w(W), .out(state) ); end endgenerate <span class="hljs-keyword"><span class="hljs-keyword">wire</span></span> [<span class="hljs-number"><span class="hljs-number">31</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>]a; assign a = state_in[ <span class="hljs-number"><span class="hljs-number">31</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">wire</span></span> [<span class="hljs-number"><span class="hljs-number">31</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>]b; assign b = state_in[ <span class="hljs-number"><span class="hljs-number">63</span></span>: <span class="hljs-number"><span class="hljs-number">32</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">wire</span></span> [<span class="hljs-number"><span class="hljs-number">31</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>]c; assign c = state_in[ <span class="hljs-number"><span class="hljs-number">95</span></span>: <span class="hljs-number"><span class="hljs-number">64</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">wire</span></span> [<span class="hljs-number"><span class="hljs-number">31</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>]d; assign d = state_in[<span class="hljs-number"><span class="hljs-number">127</span></span>: <span class="hljs-number"><span class="hljs-number">96</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">wire</span></span> [<span class="hljs-number"><span class="hljs-number">31</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>]e; assign e = state_in[<span class="hljs-number"><span class="hljs-number">159</span></span>:<span class="hljs-number"><span class="hljs-number">128</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">wire</span></span> [<span class="hljs-number"><span class="hljs-number">31</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>]f; assign f = state_in[<span class="hljs-number"><span class="hljs-number">191</span></span>:<span class="hljs-number"><span class="hljs-number">160</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">wire</span></span> [<span class="hljs-number"><span class="hljs-number">31</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>]g; assign g = state_in[<span class="hljs-number"><span class="hljs-number">223</span></span>:<span class="hljs-number"><span class="hljs-number">192</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">wire</span></span> [<span class="hljs-number"><span class="hljs-number">31</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>]h; assign h = state_in[<span class="hljs-number"><span class="hljs-number">255</span></span>:<span class="hljs-number"><span class="hljs-number">224</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">wire</span></span> [<span class="hljs-number"><span class="hljs-number">31</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>]a1; assign a1 = RND[<span class="hljs-number"><span class="hljs-number">63</span></span>].state[ <span class="hljs-number"><span class="hljs-number">31</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">wire</span></span> [<span class="hljs-number"><span class="hljs-number">31</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>]b1; assign b1 = RND[<span class="hljs-number"><span class="hljs-number">63</span></span>].state[ <span class="hljs-number"><span class="hljs-number">63</span></span>: <span class="hljs-number"><span class="hljs-number">32</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">wire</span></span> [<span class="hljs-number"><span class="hljs-number">31</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>]c1; assign c1 = RND[<span class="hljs-number"><span class="hljs-number">63</span></span>].state[ <span class="hljs-number"><span class="hljs-number">95</span></span>: <span class="hljs-number"><span class="hljs-number">64</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">wire</span></span> [<span class="hljs-number"><span class="hljs-number">31</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>]d1; assign d1 = RND[<span class="hljs-number"><span class="hljs-number">63</span></span>].state[<span class="hljs-number"><span class="hljs-number">127</span></span>: <span class="hljs-number"><span class="hljs-number">96</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">wire</span></span> [<span class="hljs-number"><span class="hljs-number">31</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>]e1; assign e1 = RND[<span class="hljs-number"><span class="hljs-number">63</span></span>].state[<span class="hljs-number"><span class="hljs-number">159</span></span>:<span class="hljs-number"><span class="hljs-number">128</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">wire</span></span> [<span class="hljs-number"><span class="hljs-number">31</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>]f1; assign f1 = RND[<span class="hljs-number"><span class="hljs-number">63</span></span>].state[<span class="hljs-number"><span class="hljs-number">191</span></span>:<span class="hljs-number"><span class="hljs-number">160</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">wire</span></span> [<span class="hljs-number"><span class="hljs-number">31</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>]g1; assign g1 = RND[<span class="hljs-number"><span class="hljs-number">63</span></span>].state[<span class="hljs-number"><span class="hljs-number">223</span></span>:<span class="hljs-number"><span class="hljs-number">192</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">wire</span></span> [<span class="hljs-number"><span class="hljs-number">31</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>]h1; assign h1 = RND[<span class="hljs-number"><span class="hljs-number">63</span></span>].state[<span class="hljs-number"><span class="hljs-number">255</span></span>:<span class="hljs-number"><span class="hljs-number">224</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">wire</span></span> [<span class="hljs-number"><span class="hljs-number">31</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>]a2; assign a2 = a+a1; <span class="hljs-keyword"><span class="hljs-keyword">wire</span></span> [<span class="hljs-number"><span class="hljs-number">31</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>]b2; assign b2 = b+b1; <span class="hljs-keyword"><span class="hljs-keyword">wire</span></span> [<span class="hljs-number"><span class="hljs-number">31</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>]c2; assign c2 = c+c1; <span class="hljs-keyword"><span class="hljs-keyword">wire</span></span> [<span class="hljs-number"><span class="hljs-number">31</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>]d2; assign d2 = d+d1; <span class="hljs-keyword"><span class="hljs-keyword">wire</span></span> [<span class="hljs-number"><span class="hljs-number">31</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>]e2; assign e2 = e+e1; <span class="hljs-keyword"><span class="hljs-keyword">wire</span></span> [<span class="hljs-number"><span class="hljs-number">31</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>]f2; assign f2 = f+f1; <span class="hljs-keyword"><span class="hljs-keyword">wire</span></span> [<span class="hljs-number"><span class="hljs-number">31</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>]g2; assign g2 = g+g1; <span class="hljs-keyword"><span class="hljs-keyword">wire</span></span> [<span class="hljs-number"><span class="hljs-number">31</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>]h2; assign h2 = h+h1; assign state_out = {h2,g2,f2,e2,d2,c2,b2,a2}; endmodule</code> </pre> </div></div><br>  Naturally, you need to make sure that the module is working.  For this you need a simple testbench to submit to the input of some kind of data block and see the result. <br><br><div class="spoiler">  <b class="spoiler_title">Here is the testbench verilog</b> <div class="spoiler_text"><pre> <code class="hljs sql">`timescale 1ns/1ps module tb; initial <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> $<span class="hljs-keyword"><span class="hljs-keyword">dumpfile</span></span>(<span class="hljs-string"><span class="hljs-string">"tb.vcd"</span></span>); $dumpvars(0, tb); <span class="hljs-comment"><span class="hljs-comment">#100; $finish; end wire [511:0]data; assign data = 512'h66656463626139383736353433323130666564636261393837363534333231306665646362613938373635343332313066656463626139383736353433323130; wire [255:0]result; sha256_transform s( .state_in( 256'h5be0cd191f83d9ab9b05688c510e527fa54ff53a3c6ef372bb67ae856a09e667 ), .data_in(data), .state_out(result) ); endmodule</span></span></code> </pre></div></div><br>  I will compare with the answer that the function sha256_transform gives me, written in the C language (may I not give the C code? These implementations in C / C ++ are full).  Main result: <br><br><img src="https://habrastorage.org/files/05b/5ac/760/05b5ac76046748dfb8a14b68334e591e.png"><br><br>  I program in C / C ++ in Visual Studio, and I test Verilog with icarus verilog and gtkwave.  I am convinced that the answers are the same, so you can move on. <br><br>  Now you can insert the module into the FPGA and see how many logical elements such a function can occupy. <br><br>  We make such a project for FPGA: <br><br><pre> <code class="hljs mel">module sha256_test( input <span class="hljs-keyword"><span class="hljs-keyword">wire</span></span> clk, input <span class="hljs-keyword"><span class="hljs-keyword">wire</span></span> data, output <span class="hljs-keyword"><span class="hljs-keyword">wire</span></span> [<span class="hljs-number"><span class="hljs-number">255</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>]result ); reg [<span class="hljs-number"><span class="hljs-number">511</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>]d; always @(posedge clk) d &lt;= { d[<span class="hljs-number"><span class="hljs-number">510</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>],data }; sha256_transform s0( .state_in( <span class="hljs-number"><span class="hljs-number">256</span></span><span class="hljs-string"><span class="hljs-string">'h5be0cd191f83d9ab9b05688c510e527fa54ff53a3c6ef372bb67ae856a09e667 ), .data_in( d ), .state_out(result) ); endmodule</span></span></code> </pre><br>  Here it is assumed that the input data is pushed into one long register of 512 bits, which is fed as input to my ‚Äúclean‚Äù SHA256_transform.  All 256 output bits are output to the output pin of the FPGA chip. <br><br>  I compile, for FPGA Cyclone IV, and I see that this thing will take 30,103 gates. <br>  Well remember this number: <b>30103</b> ... <br><br>  Let's do the second experiment.  Project "sha256-eliminated". <br><br><pre> <code class="hljs java"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">module</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sha256_test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( input wire clk, input wire data, output wire [</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">255</span></span></span></span><span class="hljs-function"><span class="hljs-params">:</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">]result )</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">sha256_transform </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">s0</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( .state_in( </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">256</span></span></span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'h5be0cd191f83d9ab9b05688c510e527fa54ff53a3c6ef372bb67ae856a09e667 ), .data_in( 512'</span></span></span></span><span class="hljs-function"><span class="hljs-params">h66656463626139383736353433323130666564636261393837363534333231306665646362613938373635343332313066656463626139383736353433323130 )</span></span></span><span class="hljs-function">, .</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">state_out</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(result)</span></span></span><span class="hljs-function"> )</span></span>; endmodule</code> </pre><br>  Here, I do not submit input data to the FPGA from the outside, but simply set a constant, constant input signal for the sha256_transform module. <br><br>  Compile in FPGA.  Know how many logical elements will be involved in this case: <b>ZERO</b> . <br><br><img src="https://habrastorage.org/files/49e/e67/ff9/49ee67ff90c341a1905131ff79785c89.png"><br><br>  Altera environment (or already Intel? How to call correctly?) Quartus Prime optimizes all the device logic and since there are no registers and no input signals on which the result depended, the whole combinational function degenerates, the input parameters of the SHA256 module are calculated directly during compilation.  You can view the output signals on the FPGA pins.  The compiler immediately writes that some signals will be attached to the ground, and some to the VCC, to the supply voltage.  So the output will be the result calculated by the compiler itself: 0x56, 0x70, ... just like in my very first test example. <br><br>  This is where the thought comes from.  Since the compiler is so smart and can optimize the logic so well, why not consider only one output bit from sha256?  How much logic does it take to count only one result bit? <br><br>  Indeed.  Bitcoins are considered like this: there is a data block.  In the data block there is a variable field that can be changed - this is a nonce field, 32 bits.  The remaining data in the block is fixed.  We must change, iterate the nonce field so that the result of sha256 is ‚Äúspecial‚Äù, namely, that the high bits of the result of sha256-transform turn out to be zero. <br><br><img src="https://habrastorage.org/files/21b/b29/d85/21bb29d85a3249148921a7cb2f7822bc.png"><br><br>  Here we count sha256 once, then we increase nonce by one, again we count hash, then again and again.  Hundreds, thousands of times the same data block but a slightly different nonce field.  This calculates all the bits of the sha256 result, that is, all the output 256 bits.  Is it profitable energetically?  Is it beneficial for the number of logic elements involved? <br><br>  And what if you count only one of the higher bits of the result.  He think it is equally likely to be either zero or one.  If it turns out to be one, the remaining bits should not be counted.  Why waste precious energy on them? <br><br>  Having made this assumption, for some reason I immediately decided for myself that the number of logical elements for calculating only one bit of a hash should be 256 times less than for calculating all the bits of the result.  But I was wrong. <br><br>  To test this hypothesis, I decided to make a project for a quarter with a top module that looks like this: <br><br><pre> <code class="hljs mel">module sha256_test( input <span class="hljs-keyword"><span class="hljs-keyword">wire</span></span> clk, input <span class="hljs-keyword"><span class="hljs-keyword">wire</span></span> data, output <span class="hljs-keyword"><span class="hljs-keyword">wire</span></span> result ); reg [<span class="hljs-number"><span class="hljs-number">511</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>]d; always @(posedge clk) d &lt;= { d[<span class="hljs-number"><span class="hljs-number">510</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>],data }; <span class="hljs-keyword"><span class="hljs-keyword">wire</span></span> [<span class="hljs-number"><span class="hljs-number">255</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>]r; sha256_transform s0( .state_in( <span class="hljs-number"><span class="hljs-number">256</span></span><span class="hljs-string"><span class="hljs-string">'h5be0cd191f83d9ab9b05688c510e527fa54ff53a3c6ef372bb67ae856a09e667 ), .data_in( d ), .state_out(r) ); assign result = r[187]; // ,    endmodule</span></span></code> </pre><br>  Note that sta256_transform seems to compute the entire hash and the response will be in the signal wire [255: 0] r, however, the output of the Verilog module is only one bit, which assign result = r [187];  This will allow the compiler to effectively leave only the logic that is needed to calculate the desired bit.  The rest will be optimized and removed from the project. <br><br>  To conduct my experiment, I just need to fix the last but one line and recompile the project 256 times.  To facilitate such work I will write a script for the quarter: <br><br><pre> <code class="hljs mel">#!/usr/bin/tclsh <span class="hljs-keyword"><span class="hljs-keyword">proc</span></span> read_rpt { i frpt } { set fp [open <span class="hljs-string"><span class="hljs-string">"output_files/xxx.map.summary"</span></span> r] set file_data [read $fp] close $fp set data [split $file_data <span class="hljs-string"><span class="hljs-string">"\n"</span></span>] foreach line $data { set half [split $line <span class="hljs-string"><span class="hljs-string">":"</span></span>] set a [lindex $half <span class="hljs-number"><span class="hljs-number">0</span></span>] set b [lindex $half <span class="hljs-number"><span class="hljs-number">1</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> { $a == <span class="hljs-string"><span class="hljs-string">" Total combinational functions "</span></span> } { puts [<span class="hljs-keyword"><span class="hljs-keyword">format</span></span> <span class="hljs-string"><span class="hljs-string">"%d %s"</span></span> $i $b] puts $frpt [<span class="hljs-keyword"><span class="hljs-keyword">format</span></span> <span class="hljs-string"><span class="hljs-string">"%d %s"</span></span> $i $b] } } } <span class="hljs-keyword"><span class="hljs-keyword">proc</span></span> gen_sha256_src { i } { set fo [open <span class="hljs-string"><span class="hljs-string">"sha256_test.v"</span></span> <span class="hljs-string"><span class="hljs-string">"w"</span></span>] puts $fo <span class="hljs-string"><span class="hljs-string">"module sha256_test("</span></span> puts $fo <span class="hljs-string"><span class="hljs-string">" input wire clk,"</span></span> puts $fo <span class="hljs-string"><span class="hljs-string">" input wire data,"</span></span> puts $fo <span class="hljs-string"><span class="hljs-string">" output wire result"</span></span> puts $fo <span class="hljs-string"><span class="hljs-string">");"</span></span> puts $fo <span class="hljs-string"><span class="hljs-string">""</span></span> puts $fo <span class="hljs-string"><span class="hljs-string">"reg \[511:0]d;"</span></span> puts $fo <span class="hljs-string"><span class="hljs-string">"always @(posedge clk)"</span></span> puts $fo <span class="hljs-string"><span class="hljs-string">" d &lt;= { d\[510:0],data };"</span></span> puts $fo <span class="hljs-string"><span class="hljs-string">""</span></span> puts $fo <span class="hljs-string"><span class="hljs-string">"wire \[255:0]r;"</span></span> puts $fo <span class="hljs-string"><span class="hljs-string">"sha256_transform s0("</span></span> puts $fo <span class="hljs-string"><span class="hljs-string">" .state_in( 256'h5be0cd191f83d9ab9b05688c510e527fa54ff53a3c6ef372bb67ae856a09e667 ),"</span></span> puts $fo <span class="hljs-string"><span class="hljs-string">" .data_in( d ),"</span></span> puts $fo <span class="hljs-string"><span class="hljs-string">" .state_out(r)"</span></span> puts $fo <span class="hljs-string"><span class="hljs-string">" );"</span></span> puts $fo <span class="hljs-string"><span class="hljs-string">""</span></span> puts $fo <span class="hljs-string"><span class="hljs-string">"assign result = r\[$i];"</span></span> puts $fo <span class="hljs-string"><span class="hljs-string">""</span></span> puts $fo <span class="hljs-string"><span class="hljs-string">"endmodule"</span></span> close $fo } set frpt [open <span class="hljs-string"><span class="hljs-string">"rpt.txt"</span></span> <span class="hljs-string"><span class="hljs-string">"w"</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> {set i <span class="hljs-number"><span class="hljs-number">0</span></span>} {$i &lt; <span class="hljs-number"><span class="hljs-number">256</span></span>} {incr i} { gen_sha256_src $i <span class="hljs-keyword"><span class="hljs-keyword">exec</span></span> x.bat read_rpt $i $frpt } close $frpt exit</code> </pre><br>  This script re-creates the sha256_test.v module in the loop and each time outputs the next sha256 result to the output FPGA pin. <br><br>  I run the script for a couple of hours and voila.  There is a table of values.  Now we know exactly which bit from SHA256 is the easiest to calculate.  Here is a graph of the required number of logical elements of the sequence number of the calculated SHA256 bit: <br><br><img src="https://habrastorage.org/files/fef/958/524/fef958524ad74a668bf49d4d81590bd7.png"><br><br>  From here it becomes clear that it is easiest to calculate bit number 224. It requires <b>27204</b> logical elements.  This is actually almost 10% less than when calculating all 256 output bits. <br><br>  The graph in the form of a saw is explained by the fact that there are many adders in the SHA256 algorithm.  In the adder, each next most significant bit is more difficult to calculate than the previous one.  This is due to the transfer scheme, because adders consist of many full-adder blocks. <br><br>  Ghostly energy savings have already appeared.  I believe that every logical function eats energy.  The smaller the number of involved logical elements LE in the FPGA project, the lower the energy consumption.  The proposed algorithm is as follows: we consider one of the simplest bits, if it is zero, then we consider the following.  If it is one, then we do not spend energy and time and energy on the remaining bits in the same hash. <br><br>  Now another thought, also related to the compiler's capabilities to optimize the logic. <br><br>  Since when searching the nonce field, the main data of the block remains the same, it is logical and obvious that from cycle to cycle some calculations simply repeat and consider the same thing.  Question: how to estimate how much energy is lost there on repeated calculations? <br><br>  The experiment is simple.  For example, we put two sha256_transform modules side by side and feed them with the same input data, well, except for one bit.  We believe that these two modules consider neighboring nonce differing in one bit. <br><br><pre> <code class="hljs mel">module sha256_test( input <span class="hljs-keyword"><span class="hljs-keyword">wire</span></span> clk, input <span class="hljs-keyword"><span class="hljs-keyword">wire</span></span> data, output <span class="hljs-keyword"><span class="hljs-keyword">wire</span></span> [<span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>]result ); reg [<span class="hljs-number"><span class="hljs-number">511</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>]d; always @(posedge clk) d &lt;= { d[<span class="hljs-number"><span class="hljs-number">510</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>],data }; <span class="hljs-keyword"><span class="hljs-keyword">wire</span></span> [<span class="hljs-number"><span class="hljs-number">255</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>]r0; sha256_transform s0( .state_in( <span class="hljs-number"><span class="hljs-number">256</span></span><span class="hljs-string"><span class="hljs-string">'h5be0cd191f83d9ab9b05688c510e527fa54ff53a3c6ef372bb67ae856a09e667 ), .data_in( { 1'</span></span>b0, d[<span class="hljs-number"><span class="hljs-number">510</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] } ), .state_out(r0) ); <span class="hljs-keyword"><span class="hljs-keyword">wire</span></span> [<span class="hljs-number"><span class="hljs-number">255</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>]r1; sha256_transform s1( .state_in( <span class="hljs-number"><span class="hljs-number">256</span></span><span class="hljs-string"><span class="hljs-string">'h5be0cd191f83d9ab9b05688c510e527fa54ff53a3c6ef372bb67ae856a09e667 ), .data_in( { 1'</span></span>b1, d[<span class="hljs-number"><span class="hljs-number">510</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] } ), .state_out(r1) ); assign result = { r0[<span class="hljs-number"><span class="hljs-number">224</span></span>], r1[<span class="hljs-number"><span class="hljs-number">224</span></span>] }; endmodule</code> </pre><br>  Each of the modules s0 and s1 consider their hash from the same input data, only differ by one nonce bit.  From each I take only the ‚Äúeasiest‚Äù bit of the result, bit number 224. <br>  How much will such logic take in FPGA?  47.805 logical elements.  Since there are two modules, one takes 47805/2 = 23902. It turns out that starting to count two hashes at once is much more profitable than counting them in turn due to the fact that there are general calculations. <br><br>  And if you start counting at once 4 hashes and only 2 bits of different nonce fields?  It turns out 89009LE / 4 = 22252 LE / SHA256 <br><br>  And if you count 8 hashes?  It turns out 171418LE / 8 = 21427 LE / SHA256 <br><br>  Here you can compare the original number of 30103 logical elements on the full SHA256_transform with the output of 256 bits of the result and 21427 logical elements on the SHA256_transfrom with the output of one bit of the result (which can be used to predict the appropriateness of further calculations).  It seems to me that such methods can reduce the energy consumption of the miner somewhere by almost a third.  Well, a quarter ... I do not know how significant it is, but it seems that it is significant. <br><br>  There is another thought.  The main data in the block for calculation remain fixed and only the nonce field changes during the calculation of the hash.  If it were possible to quickly compile for the FPGA, then a significant part of the predictions could be performed at the compilation stage.  After all, I showed above how effectively the compiler calculates everything that can be calculated in advance.  Optimized logic with precalculations will be much or much smaller in volume than is required for a full calculator, hence, it will consume less energy. <br><br>  Somehow like this.  In fact, I myself am not completely sure of my research.  Maybe I do not take into account something or do not understand.  The proposed methods, of course, do not give a global breakthrough, but something that can save.  While this is all rather theoretical reasoning.  For the practical implementation of the "pure" SHA256 is not suitable - it will have too small a working frequency.  Enter the pipeline necessarily have to. <br><br>  There is another factor.  In real life, two consecutive SHA256_transforms are counted for Bitcoin.  In this case, my estimated gain in terms of the number of logical elements and the energy consumed will probably be not so significant. <br><br>  Sources of the bitcon miner project for the Mars Rover 3 board with FPGA Altera MAX10, 50K LE <a href="https://github.com/marsohod4you/btc-fpga-miner">here</a> .  Here in the research folder there are all the sources of my experiments with the SHA256 algorithm. <br><br>  <a href="https://marsohod.org/projects/proekty-dlya-platy-marsokhod3/340-miner-bitcoin">Description of the project miner for FPGA here</a> </div><p>Source: <a href="https://habr.com/ru/post/318174/">https://habr.com/ru/post/318174/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../318162/index.html">Smart home NooLite. Scenario number 1 - "Master of the house"</a></li>
<li><a href="../318164/index.html">Why Hackintosh is already relevant. Debunking Myths</a></li>
<li><a href="../318168/index.html">DotNext 2016 Moscow: Calm after a storm</a></li>
<li><a href="../318170/index.html">How ‚Äúinterface‚Äù differs from ‚Äúintermordia‚Äù: our approach to documenting and localizing software products</a></li>
<li><a href="../318172/index.html">Methbot advertising botnet brings $ 3- $ 5 million per day to its owners</a></li>
<li><a href="../318178/index.html">17 predictions for 2017: Microsoft researchers - what to expect in 2017 and in ten years</a></li>
<li><a href="../318180/index.html">Am I getting better?</a></li>
<li><a href="../318182/index.html">Why do vendors panic about hyper-convergence / webscale?</a></li>
<li><a href="../318184/index.html">Dynamic UPS: the story of an engineering upgrade is very much in the spirit of the times</a></li>
<li><a href="../318186/index.html">7 steps to software localization</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>