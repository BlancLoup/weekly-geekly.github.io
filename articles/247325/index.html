<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>A quick note about inheritance in Node.js</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In JavaScript, there are many different ways of inheritance, class and prototype, factory and through impurities, direct and indirect, as well as hybr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>A quick note about inheritance in Node.js</h1><div class="post__text post__text-html js-mediator-article"><img align="left" src="https://habrastorage.org/files/5e2/ef5/977/5e2ef5977a1b4ba7b65bdf67aa621d80.jpg">  In JavaScript, there are many different ways of inheritance, class and prototype, factory and through impurities, direct and indirect, as well as hybrids of several methods.  But Node.js has its own native method using <b>util.inherits</b> (ChildClass, ParentClass).  Until recently, I used the Nod method only for the built-in classes (when you need to make your successor for the EventEmitter, Readable / Writable Stream, Domain, Buffer, etc.), and for common domain modeling I used common practices for the entire JavaScript.  And here, for the first time, it took to implement its own hierarchy of system classes, not inheritors from the built-in, but not the domain classes, but the classes massively affected in the system code of the <a href="https://github.com/tshemsedinov/impress">Impress</a> application server.  And the simple use of util.inherits was somehow not enough, I looked for the article and didn‚Äôt find everything I needed, studied the examples of inheritance in the source code of the node itself, thought and made <a href="https://github.com/tshemsedinov/node-inheritance"><b>an example of the</b></a> native node inheritance as a memory and wrote this small note, so that she, I hope, will also help you.  Immediately I <b>warn you</b> that I don‚Äôt really like the implementation of the method call of the parent class from the method overridden in the child class because of the bulkiness, therefore, I welcome alternative ways and invite you to commit them to the repository or in the comments to this note. <br><br><a name="habracut"></a><br>  <b>Requirements for implementation:</b> <br><ul><li>  Using Node.js native inheritance util.inherits </li><li>  Definition of fields and methods to the class ancestor and in the class of the heir </li><li>  The ability to call the parent constructor from the child constructor </li><li>  Ability to override methods in child class </li><li>  The ability to call the method of the parent class from the overridden method in the child class </li></ul><br>  <b>Basic example</b> <br>  We have two classes connected by inheritance and call the parent class constructor from the child's constructor via ClassName.super_.apply (this, arguments).  Naturally, this call can be either at the beginning of the child, the constructor, or its end or in the middle.  The call can be wrapped in a condition, i.e.  we fully manage rollback to ancestor constructor functionality. <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> util = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'util'</span></span>); <span class="hljs-comment"><span class="hljs-comment">//   function ParentClass(par1, par2) { this.parentField1 = par1; this.parentField2 = par2; } function ChildClass(par1, par2) { ChildClass.super_.apply(this, arguments); this.childField1 = par1; this.childField2 = par2; } //  util.inherits(ChildClass, ParentClass); //        var obj = new ChildClass('Hello', 'World'); console.dir({ obj: obj }); /* : { obj: { parentField1: 'Hello', parentField2: 'World', childField1: 'Hello', childField2: 'World' } } */</span></span></code> </pre> <br>  <b>Advanced example</b> <br>  Here we define methods and properties both for the parent class and for the child class, through the prototype.  Let me remind you that these will be methods and properties of not generated instances, but of the classes themselves, i.e.  they will be visible in instances, but are contained in the prototypes.  From the output to the console, you can see that everything works as it should, conveniently and predictably. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> util = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'util'</span></span>); <span class="hljs-comment"><span class="hljs-comment">//    function ParentClass(par1, par2) { this.parentField1 = par1; this.parentField2 = par2; } //    ParentClass.prototype.parentMethod = function(par) { console.log('parentMethod("' + par + '")'); }; //    ParentClass.prototype.parentField = 'Parent field value'; //    function ChildClass(par1, par2) { ChildClass.super_.apply(this, arguments); this.childField1 = par1; this.childField2 = par2; } //  util.inherits(ChildClass, ParentClass); //    ChildClass.prototype.childMethod = function(par) { console.log('childMethod("' + par + '")'); }; //    ChildClass.prototype.childField = 'Child field value'; //      var parentClassInstance = new ParentClass('Marcus', 'Aurelius'); var childClassInstance = new ChildClass('Yuriy', 'Gagarin'); //   console.dir({ parentClassInstance: parentClassInstance, childClassInstance: childClassInstance }); console.dir({ objectFieldDefinedInParent: childClassInstance.parentField1, classFieldDefinedInParent: childClassInstance.parentField, objectFieldDefinedInChild: childClassInstance.childField1, classFieldDefinedInChild: childClassInstance.childField }); parentClassInstance.parentMethod('Cartesius'); childClassInstance.childMethod('von Leibniz'); /* : { parentClassInstance: { parentField1: 'Marcus', parentField2: 'Aurelius' }, childClassInstance: { parentField1: 'Yuriy', parentField2: 'Gagarin', childField1: 'Yuriy', childField2: 'Gagarin' } } { objectFieldDefinedInParent: 'Yuriy', classFieldDefinedInParent: 'Parent field value', objectFieldDefinedInChild: 'Yuriy', classFieldDefinedInChild: 'Child field value' } parentMethod("Cartesius") childMethod("von Leibniz") */</span></span></code> </pre><br>  <b>An example with overriding methods</b> <br>  Further more interesting, ParentClass has a method methodName and we need to redefine it at the successor of ChildClass with the ability to call the ancestor method from the new redefined implementation. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> util = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'util'</span></span>); <span class="hljs-comment"><span class="hljs-comment">//    function ParentClass(par1, par2) { this.parentField1 = par1; this.parentField2 = par2; } //    ParentClass.prototype.methodName = function(par) { console.log('Parent method implementation: methodName("' + par + '")'); }; //    function ChildClass(par1, par2) { ChildClass.super_.apply(this, arguments); this.childField1 = par1; this.childField2 = par2; } //  util.inherits(ChildClass, ParentClass); //      ChildClass.prototype.methodName = function(par) { //     ChildClass.super_.prototype.methodName.apply(this, arguments); //   console.log('Child method implementation: methodName("' + par + '")'); }; //     var childClassInstance = new ChildClass('Lev', 'Nikolayevich'); //   childClassInstance.methodName('Tolstoy'); /* : Parent method implementation: methodName("Tolstoy") Child method implementation: methodName("Tolstoy") */</span></span></code> </pre>  This construct for calling the parent class method is of course very cumbersome: ClassName.super_.prototype.methodName.apply (this, arguments) but I did not find another way for the native Nodal implementation of inheritance.  The only dubious improvement that occurred to me was given in the following example. <br><br>  <b>Alternative inheritance</b> <br>  In order to simplify the syntax of the ancestor method call, we will have to pay with performance and adding the override method to the base class Function, i.e.  for all functions in general (in the current context of the node, or inside the sandbox / sandbox, if all this happens inside the code running in a shielded memory context - the sandbox).  The call then becomes elegant: this.inherited (...) or you can use the universal option: this.inherited.apply (this, arguments), in which you do not need to substitute all the parameters by name into the call to the parent method. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> util = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'util'</span></span>); <span class="hljs-comment"><span class="hljs-comment">//     Function.prototype.override = function(fn) { var superFunction = this; return function() { this.inherited = superFunction; return fn.apply(this, arguments); }; }; //    function ParentClass(par1, par2) { this.parentField1 = par1; this.parentField2 = par2; } //    ParentClass.prototype.methodName = function(par) { console.log('Parent method implementation: methodName("' + par + '")'); }; //    function ChildClass(par1, par2) { ChildClass.super_.apply(this, arguments); this.childField1 = par1; this.childField2 = par2; } //  util.inherits(ChildClass, ParentClass); //      ChildClass.prototype.methodName = ParentClass.prototype.methodName.override(function(par) { //     this.inherited(par); //  this.inherited.apply(this, arguments); //   console.log('Child method implementation: methodName("' + par + '")'); }); //     var childClassInstance = new ChildClass('Lev', 'Nikolayevich'); //   childClassInstance.methodName('Tolstoy'); /* : Parent method implementation: methodName("Tolstoy") Child method implementation: methodName("Tolstoy") */</span></span></code> </pre><br>  <b>UPD: Best Option with Overriding Methods</b> <br>  Together with <a href="http://habrahabr.ru/users/xdenser/" class="user_link">xdenser</a> , the fastest and most concise version was found that does not use super_ and does not require apply. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> util = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'util'</span></span>); <span class="hljs-comment"><span class="hljs-comment">//     function override(child, fn) { child.prototype[fn.name] = fn; fn.inherited = child.super_.prototype[fn.name]; } //    function ParentClass(par1, par2) { this.parentField1 = par1; this.parentField2 = par2; } //    ParentClass.prototype.methodName = function(par) { console.log('Parent method implementation: methodName("' + par + '")'); console.dir({t1:this}) this.parentField3 = par; }; //    function ChildClass(par1, par2) { ChildClass.super_.call(this, par1, par2); this.childField1 = par1; this.childField2 = par2; } //  util.inherits(ChildClass, ParentClass); //      override(ChildClass, function methodName(par) { //     methodName.inherited.call(this, par); //   console.log('Child method implementation: methodName("' + par + '")'); this.childField3 = par; }); //     var childClassInstance = new ChildClass('Lev', 'Nikolayevich'); //   childClassInstance.methodName('Tolstoy'); /* : Parent method implementation: methodName("Tolstoy") Child method implementation: methodName("Tolstoy") */</span></span></code> </pre><br>  <b>Performance comparison</b> <br>  The preferred option is obvious, but still need to be measured.  Calling the ancestor class method on the same 10,000,000 call equipment: <ul><li>  ClassName.super_.prototype.methodName.apply (this, arguments);  <b>424 ms</b> </li><li>  Function.prototype.override (fn) and this.inherited (par);  <b>1972 ms</b> </li><li>  Function.prototype.override (fn) and this.inherited.apply (this, arguments);  <b>1800 ms</b> </li><li>  The last option is override (child, fn) and methodName.inherited.call (this, par);  <b>338 ms</b> </li></ul><br>  Repository with code examples and comments in Russian and English: <a href="https://github.com/tshemsedinov/node-inheritance">https://github.com/tshemsedinov/node-inheritance</a> </div><p>Source: <a href="https://habr.com/ru/post/247325/">https://habr.com/ru/post/247325/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../247315/index.html">DIY Turntable for 3D scanning and shooting photo-360</a></li>
<li><a href="../247317/index.html">Eleven content marketing articles that you might have missed in 2014</a></li>
<li><a href="../247319/index.html">Flexible Scrum development methodology</a></li>
<li><a href="../247321/index.html">Review of the most interesting materials on data analysis and machine learning ‚Ññ29 (December 29, 2014 - January 4, 2015)</a></li>
<li><a href="../247323/index.html">The digest of interesting materials from the world of web development and IT for the last week ‚Ññ141 (December 29, 2014 - January 4, 2015)</a></li>
<li><a href="../247329/index.html">Turn the Arduino into a full-fledged AVRISP programmer</a></li>
<li><a href="../247331/index.html">Asynchronous component initialization</a></li>
<li><a href="../247333/index.html">"Pixel gallop - part one" - basic concepts, stages of maturation, applied exercises</a></li>
<li><a href="../247337/index.html">ODROID-C1 - review and comparison with RPi</a></li>
<li><a href="../247339/index.html">Synchronization and storage of home photos / videos in the cloud</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>