<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Functional thinking. Part 3</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I drove up the third part of a series of articles on functional programming. Today we will talk about all types of this paradigm and show them using e...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Functional thinking. Part 3</h1><div class="post__text post__text-html js-mediator-article"><p>  I drove up the third part of a series of articles on functional programming.  Today we will talk about all types of this paradigm and show them using examples.  Learn more about primitive types, generic types, and much more under the cut! </p><br><p><img src="https://habrastorage.org/webt/7j/cd/7x/7jcd7xzdvnhpyxuebjvbzb1uiqs.jpeg"><a name="habracut"></a></p><br><ul><li>  <strong><a href="https://habr.com/company/microsoft/blog/415189/">First part</a></strong> </li><li>  <strong><a href="https://habr.com/company/microsoft/blog/420039/">The second part of</a></strong> </li><li>  <strong><a href="https://habr.com/company/microsoft/blog/422115/">The third part</a></strong> </li><li>  <strong><a href="https://habr.com/company/microsoft/blog/430620/">Fourth part</a></strong> </li></ul><br><p>  Now that we have some understanding of the functions, we will see how types interact with functions such as domain and range.  This article is just a review.  For deeper immersion in types there is a series of <a href="https://fsharpforfunandprofit.com/series/understanding-fsharp-types.html">"understanding F # types"</a> . </p><br><p> First we need to understand the type notation a little better.  We have seen the " <code>-&gt;</code> " arrow notation separating domain and range.  So the function signature always looks like this: </p><br><pre> <code class="plaintext hljs">val functionName : domain -&gt; range</code> </pre> <br><p>  Some more examples of functions: </p><br><pre> <code class="plaintext hljs">let intToString x = sprintf "x is %i" x //  int  string let stringToInt x = System.Int32.Parse(x)</code> </pre> <br><p>  If you execute this code in <a href="https://docs.microsoft.com/en-us/dotnet/fsharp/tutorials/fsharp-interactive/">an interactive window</a> , you can see the following signatures: </p><br><pre> <code class="plaintext hljs">val intToString : int -&gt; string val stringToInt : string -&gt; int</code> </pre> <br><p>  They mean: </p><br><ul><li>  <code>intToString</code> has a domain of type <code>int</code> , which is mapped to a range of type <code>string</code> . </li><li>  <code>stringToInt</code> has a domain of type <code>string</code> , which maps to the range of type <code>int</code> . </li></ul><br><h2>  Primitive types </h2><br><p>  There are expected primitive types: string, int, float, bool, char, byte, etc., as well as many other derivatives of the .NET type system. </p><br><p>  A couple more examples of functions with primitive types: </p><br><pre> <code class="plaintext hljs">let intToFloat x = float x // "float" -  int  float let intToBool x = (x = 2) // true  x  2 let stringToString x = x + " world"</code> </pre> <br><p>  and their signatures: </p><br><pre> <code class="plaintext hljs">val intToFloat : int -&gt; float val intToBool : int -&gt; bool val stringToString : string -&gt; string</code> </pre> <br><h2>  Type summary </h2><br><p>  In the previous examples, the F # compiler correctly defined the types of parameters and results.  But this is not always the case.  If you try to execute the following code, you will get a compilation error: </p><br><pre> <code class="plaintext hljs">let stringLength x = x.Length =&gt; error FS0072: Lookup on object of indeterminate type</code> </pre> <br><p>  The compiler does not know the type of the argument "x", and because of this does not know whether the "Length" is a valid method.  In most cases, this can be fixed by passing an "type annotation" to the F # compiler.  Then he will know which type to use.  In the revised version, we indicate that the type "x" is a string. </p><br><pre> <code class="plaintext hljs">let stringLength (x:string) = x.Length</code> </pre> <br><p>  The brackets around the <code>x:string</code> parameter are important.  If they are skipped, the compiler will decide that the string is the return value!  That is, an "open" colon is used to indicate the type of the return value, as shown in the following example. </p><br><pre> <code class="plaintext hljs">let stringLengthAsInt (x:string) :int = x.Length</code> </pre> <br><p>  We indicate that the <code>x</code> parameter is a string, and the return value is an integer. </p><br><h2>  Types of functions as parameters </h2><br><p>  A function that accepts other functions as parameters or returns a function is called <strong>a higher order function</strong> (the <strong>higher-order function is</strong> sometimes abbreviated to HOF).  They are used as an abstraction for setting as general a behavior as possible.  This type of function is very common in F #, most standard libraries use them. </p><br><p>  Consider the <code>evalWith5ThenAdd2</code> function, which takes a function as a parameter, and then calculates this function from 5 and adds 2 to the result: </p><br><pre> <code class="plaintext hljs">let evalWith5ThenAdd2 fn = fn 5 + 2 //   ,   fn(5) + 2</code> </pre> <br><p>  The signature of this function is as follows: </p><br><pre> <code class="plaintext hljs">val evalWith5ThenAdd2 : (int -&gt; int) -&gt; int</code> </pre> <br><p>  You can see that domain is <code>(int-&gt;int)</code> , and range is <code>int</code> .  What does it mean?  This means that the input parameter is not a simple value, but a function from the set of functions from <code>int</code> to <code>int</code> .  The output value is not a function, but simply an <code>int</code> . </p><br><p>  Let's try: </p><br><pre> <code class="plaintext hljs">let add1 x = x + 1 //  -  (int -&gt; int) evalWith5ThenAdd2 add1 //  </code> </pre> <br><p>  and get: </p><br><pre> <code class="plaintext hljs">val add1 : int -&gt; int val it : int = 8</code> </pre> <br><p>  " <code>add1</code> " is a function that maps an <code>int</code> to an <code>int</code> , as we can see from the signature.  It is a valid <code>evalWith5ThenAdd2</code> parameter, and its result is 8. </p><br><p>  By the way, the special word " <code>it</code> " is used to denote the last calculated value, in this case it is the result we were waiting for.  This is not a keyword, it is just a naming convention. </p><br><p>  Another case: </p><br><pre> <code class="plaintext hljs">let times3 x = x * 3 // -  (int -&gt; int) evalWith5ThenAdd2 times3 //  </code> </pre> <br><p>  gives: </p><br><pre> <code class="plaintext hljs">val times3 : int -&gt; int val it : int = 17</code> </pre> <br><p>  " <code>times3</code> " is also a function that maps an <code>int</code> to an <code>int</code> , as seen from the signature.  It is also a valid parameter for <code>evalWith5ThenAdd2</code> .  The result of the calculation is 17. </p><br><p>  Note that the input data is type sensitive.  If the function being passed uses <code>float</code> , not <code>int</code> , then nothing happens.  For example, if we have: </p><br><pre> <code class="plaintext hljs">let times3float x = x * 3.0 // -  (float-&gt;float) evalWith5ThenAdd2 times3float</code> </pre> <br><p>  The compiler, when trying to compile, will return an error: </p><br><pre> <code class="plaintext hljs">error FS0001: Type mismatch. Expecting a int -&gt; int but given a float -&gt; float</code> </pre> <br><p>  indicating that the input function must be a function of type <code>int-&gt;int</code> . </p><br><h3>  Functions as output </h3><br><p>  Value functions can also be the result of functions.  For example, the following function will generate an "adder" function that will add an input value. </p><br><pre> <code class="plaintext hljs">let adderGenerator numberToAdd = (+) numberToAdd</code> </pre> <br><p>  Its signature is: </p><br><pre> <code class="plaintext hljs">val adderGenerator : int -&gt; (int -&gt; int)</code> </pre> <br><p>  means that the generator accepts an <code>int</code> and creates a function ("adder") that matches the <code>ints</code> in <code>ints</code> .  Let's see how it works: </p><br><pre> <code class="plaintext hljs">let add1 = adderGenerator 1 let add2 = adderGenerator 2</code> </pre> <br><p>  Two adder functions are created.  The first creates a function that adds to input 1, the second adds 2. Note that the signatures are exactly what we expected. </p><br><pre> <code class="plaintext hljs">val add1 : (int -&gt; int) val add2 : (int -&gt; int)</code> </pre> <br><p>  Now you can use the generated functions as usual, they are no different from functions defined explicitly: </p><br><pre> <code class="plaintext hljs">add1 5 // val it : int = 6 add2 5 // val it : int = 7</code> </pre> <br><h3>  Using type annotations to limit function types </h3><br><p>  In the first example, we looked at the function: </p><br><pre> <code class="plaintext hljs">let evalWith5ThenAdd2 fn = fn 5 +2 &gt; val evalWith5ThenAdd2 : (int -&gt; int) -&gt; int</code> </pre> <br><p>  In this example, F # can infer that " <code>fn</code> " converts an <code>int</code> to an <code>int</code> , so its signature will be <code>int-&gt;int</code> . </p><br><p>  But what is the signature "fn" in the following case? </p><br><pre> <code class="plaintext hljs">let evalWith5 fn = fn 5</code> </pre> <br><p>  It is clear that " <code>fn</code> " is a kind of function that accepts an <code>int</code> , but what does it return?  The compiler cannot answer this question.  In such cases, if it is necessary to specify the type of the function, you can add an annotation type for the parameters of the functions, as well as for primitive types. </p><br><pre> <code class="plaintext hljs">let evalWith5AsInt (fn:int-&gt;int) = fn 5 let evalWith5AsFloat (fn:int-&gt;float) = fn 5</code> </pre> <br><p>  You can also define a return type. </p><br><pre> <code class="plaintext hljs">let evalWith5AsString fn :string = fn 5</code> </pre> <br><p>  Since  the main function returns a <code>string</code> , the function " <code>fn</code> " is also forced to return a <code>string</code> .  Thus, it is not required to explicitly specify the type " <code>fn</code> ". </p><br><h2>  Type "unit" </h2><br><p>  During the programming process, we sometimes want the function to do something without returning anything.  Consider the " <code>printInt</code> " function.  The function does not return anything.  It simply prints the string to the console as a side effect of the execution. </p><br><pre> <code class="plaintext hljs">let printInt x = printf "x is %i" x //   </code> </pre> <br><p>  What is its signature? </p><br><pre> <code class="plaintext hljs">val printInt : int -&gt; unit</code> </pre> <br><p>  What is a " <code>unit</code> "? </p><br><p>  Even if the function does not return values, it still needs a range.  In the world of mathematics there are no "void" functions.  Each function must return something, because the function is a display, and the display must display something! </p><br><p><img src="https://habrastorage.org/webt/3_/vt/vz/3_vtvz11kud3aikskqhciwc_q1a.png"></p><br><p>  So, in F #, functions like this return a special type of result called " <code>unit</code> ".  It contains only one value, denoted by " <code>()</code> ".  You might think that <code>unit</code> and <code>()</code> are something like "void" and "null" from C #, respectively.  But unlike them, <code>unit</code> is a real type, and <code>()</code> real value.  To verify this, it suffices to perform: </p><br><pre> <code class="plaintext hljs">let whatIsThis = ()</code> </pre> <br><p>  the following signature will be obtained: </p><br><pre> <code class="plaintext hljs">val whatIsThis : unit = ()</code> </pre> <br><p>  Which indicates that the " <code>whatIsThis</code> " label is of type <code>unit</code> and is associated with the value <code>()</code> . </p><br><p>  Now, returning to the " <code>printInt</code> " signature, you can understand the meaning of this entry: </p><br><pre> <code class="plaintext hljs">val printInt : int -&gt; unit</code> </pre> <br><p>  This signature says that <code>printInt</code> has a domain of <code>int</code> , which is converted to something that does not interest us. </p><br><h3>  Functions without parameters </h3><br><p>  Now that we understand a <code>unit</code> , can we predict its appearance in a different context?  For example, try to create a reusable function "hello world".  Since there is no input or output, we can expect the signature <code>unit -&gt; unit</code> .  We'll see: </p><br><pre> <code class="plaintext hljs">let printHello = printf "hello world" //   </code> </pre> <br><p>  Result: </p><br><pre> <code class="plaintext hljs">hello world val printHello : unit = ()</code> </pre> <br><p>  <em>Not exactly</em> what we expected.  "Hello world" was displayed immediately, and the result was not a function, but a simple value of type unit.  We can say that this is a simple value, because, as we saw earlier, it has a signature of the form: </p><br><pre> <code class="plaintext hljs">val aName: type = constant</code> </pre> <br><p>  In this example, we see that <code>printHello</code> really a <em>simple value</em> <code>()</code> .  This is not a function that we can call later. </p><br><p>  What is the difference between <code>printInt</code> and <code>printHello</code> ?  In the case of <code>printInt</code> value cannot be determined until we know the value of the parameter <code>x</code> , so the definition was a function.  In the case of <code>printHello</code> there are no parameters, so the right side can be defined in place.  And it was equal to <code>()</code> with a side effect in the form of console output. </p><br><p>  You can create a real reusable function without parameters, forcing the definition to have a <code>unit</code> argument to the argument: </p><br><pre> <code class="plaintext hljs">let printHelloFn () = printf "hello world" //   </code> </pre> <br><p>  Now its signature is: </p><br><pre> <code class="plaintext hljs">val printHelloFn : unit -&gt; unit</code> </pre> <br><p>  and to call it, we must pass <code>()</code> as a parameter: </p><br><pre> <code class="plaintext hljs">printHelloFn ()</code> </pre> <br><h3>  Strengthening unit types with the ignore function </h3><br><p>  In some cases, the compiler requires the <code>unit</code> type and complains.  For example, both of the following cases will cause a compiler error: </p><br><pre> <code class="plaintext hljs">do 1+1 // =&gt; FS0020: This expression should have type 'unit' let something = 2+2 // =&gt; FS0020: This expression should have type 'unit' "hello"</code> </pre> <br><p>  To help in these situations, there is a special function <code>ignore</code> , which accepts anything and returns a <code>unit</code> .  The correct version of this code could be: </p><br><pre> <code class="plaintext hljs">do (1+1 |&gt; ignore) // ok let something = 2+2 |&gt; ignore // ok "hello"</code> </pre> <br><h2>  Generic types </h2><br><p>  In most cases, if the type of the function parameter can be any type, we need to say something about it.  F # uses generics from .NET for such situations. </p><br><p>  For example, the following function converts a parameter to a string by adding some text: </p><br><pre> <code class="plaintext hljs">let onAStick x = x.ToString() + " on a stick"</code> </pre> <br><p>  No matter what type of parameter, all objects are able to <code>ToString()</code> . </p><br><p>  Signature: </p><br><pre> <code class="plaintext hljs">val onAStick : 'a -&gt; string</code> </pre> <br><p>  What kind of <code>'a</code> ?  In F #, this is a method of indicating a generic type that is unknown at the time of compilation.  An apostrophe before "a" means that the type is generic.  Equivalent to this signature in C #: </p><br><pre> <code class="plaintext hljs">string onAStick&lt;a&gt;(); //   string OnAStick&lt;TObject&gt;(); // F#-   'a    // C#'-   "TObject"  </code> </pre> <br><p>  It should be understood that this F # function still has strong typing, even with generic types.  It <em>does not</em> accept an <code>Object</code> parameter.  Strong typing is good because it allows you to preserve their type safety when composing functions. </p><br><p>  The same function is used for <code>int</code> , <code>float</code> and <code>string</code> . </p><br><pre> <code class="plaintext hljs">onAStick 22 onAStick 3.14159 onAStick "hello"</code> </pre> <br><p>  If there are two generalized parameters, the compiler will give them two different names: <code>'a</code> for the first, <code>'b</code> for the second, and so on.  For example: </p><br><pre> <code class="plaintext hljs">let concatString xy = x.ToString() + y.ToString()</code> </pre> <br><p>  In this signature there will be two generalized types: <code>'a</code> and <code>'b</code> : </p><br><pre> <code class="plaintext hljs">val concatString : 'a -&gt; 'b -&gt; string</code> </pre> <br><p>  On the other hand, the compiler recognizes when only one universal type is required.  In the following example, <code>x</code> and <code>y</code> must be of the same type: </p><br><pre> <code class="plaintext hljs">let isEqual xy = (x=y)</code> </pre> <br><p>  So, the function signature has the same generalized type for both parameters: </p><br><pre> <code class="plaintext hljs">val isEqual : 'a -&gt; 'a -&gt; bool</code> </pre> <br><p>  Generalized parameters are also very important when it comes to lists and other abstract structures, and we will see quite a lot of them in the following examples. </p><br><h2>  Other types </h2><br><p>  So far, only basic types have been discussed.  These types can be combined in various ways into more complex types.  A complete analysis of them will be later in <a href="https://fsharpforfunandprofit.com/series/understanding-fsharp-types.html">another series</a> , but in the meantime, and here we briefly analyze them, so that they can be recognized in function signatures. </p><br><ul><li>  <strong>Tuples (tuples)</strong> .  This is a pair, triple, etc., composed of other types.  For example, <code>("hello", 1)</code> is a tuple made on the basis of <code>string</code> and <code>int</code> .  A comma is the hallmark of a tuple; if a comma is seen somewhere in F #, it is almost guaranteed part of a tuple. <br>  In function signatures, tuples are written as ‚Äúworks‚Äù of the two types involved.  In this case, the tuple will be of type: </li></ul><br><pre> <code class="plaintext hljs">string * int // ("hello", 1)</code> </pre> <br><ul><li>  <strong>Collections</strong>  The most common of these are list (list), seq (sequence), and an array.  Lists and arrays have a fixed size, while sequences are potentially infinite (behind the scenes, sequences are the same <code>IEnumrable</code> ).  In function signatures, they have their own keywords: " <code>list</code> ", " <code>seq</code> ", and " <code>[]</code> " for arrays. </li></ul><br><pre> <code class="plaintext hljs">int list // List type  [1;2;3] string list // List type  ["a";"b";"c"] seq&lt;int&gt; // Seq type  seq{1..10} int [] // Array type  [|1;2;3|]</code> </pre> <br><ul><li>  <strong>Option (optional type)</strong> .  This is a simple wrapper over objects that may be missing.  There are two options: <code>Some</code> (when the value exists) and <code>None</code> (when there is no value).  In function signatures, they have their own " <code>option</code> " keyword: </li></ul><br><pre> <code class="plaintext hljs">int option // Some 1</code> </pre> <br><ul><li>  <strong>Marked unification (discriminated union)</strong> .  They are built from a variety of options of other types.  We saw some examples in <a href="https://fsharpforfunandprofit.com/posts/why-use-fsharp-intro/">"why use F #?"</a>  .  In function signatures, they are referenced by their type name; they do not have a special keyword. </li><li>  <strong>Record type (record)</strong> .  Types like database structures or rows, a set of named values.  We also saw some examples in <a href="https://fsharpforfunandprofit.com/posts/why-use-fsharp-intro/">"why use F #?"</a>  .  In function signatures, they are named for the type name, and also do not have their own keyword. </li></ul><br><h2>  Test your understanding of types </h2><br><p>  Here are a few expressions to test your understanding of function signatures.  To check, just run them in the interactive window! </p><br><pre> <code class="plaintext hljs">let testA = float 2 let testB x = float 2 let testC x = float 2 + x let testD x = x.ToString().Length let testE (x:float) = x.ToString().Length let testF x = printfn "%s" x let testG x = printfn "%f" x let testH = 2 * 2 |&gt; ignore let testI x = 2 * 2 |&gt; ignore let testJ (x:int) = 2 * 2 |&gt; ignore let testK = "hello" let testL() = "hello" let testM x = x=x let testN x = x 1 // :     x? let testO x:string = x 1 // :    :string ?</code> </pre> <br><h1>  Additional resources </h1><br><p>  For F #, there are many tutorials, including materials for those who come with C # or Java experience.  The following links may be helpful as you learn more about F #: </p><br><ul><li>  <a href="https://docs.microsoft.com/en-US/dotnet/fsharp/">F # Guide</a> </li><li>  <a href="https://swlaschin.gitbooks.io/fsharpforfunandprofit/content/">F # for Fun and Profit</a> </li><li>  <a href="https://en.wikibooks.org/wiki/F_Sharp_Programming">F # Wiki</a> </li><li>  <a href="https://learnxinyminutes.com/docs/fsharp/">Learn X in Y Minutes: F #</a> </li></ul><br><p>  Several other ways <a href="https://docs.microsoft.com/en-us/dotnet/fsharp/get-started/">to get started with learning F # are</a> also described. </p><br><p>  Finally, the F # community is very friendly to beginners.  There is a very active Slack chat, supported by the F # Software Foundation, with rooms for beginners that you <a href="http://foundation.fsharp.org/join">can freely join</a> .  We strongly recommend that you do this! </p><br><p>  Do not forget to visit the site of the <a href="http://fsharplang.ru/">Russian-speaking community F #</a> !  If you have any questions about learning the language, we will be happy to discuss them in chat rooms: </p><br><ul><li>  Room <code>#ru_general</code> in <a href="http://foundation.fsharp.org/join">Slack chat F # Software Foundation</a> </li><li>  <a href="https://t.me/Fsharp_chat">chat in Telegram</a> </li><li>  <a href="http://gitter.im/fsharplang_ru">chat in gitter</a> </li></ul><br><h2>  About authors of translation </h2><br><p>  Translated by <a href="https://habrahabr.ru/users/kleidemos/"><em>@kleidemos</em></a> <br><img src="https://habrastorage.org/getpro/habr/post_images/f95/c6d/92c/f95c6d92c5b1126b093792a43955aa43.png" width="56" height="56">  Translation and editorial changes are made by the efforts of the <a href="http://fsharplang.ru/">Russian-speaking community of F # -developers</a> .  We also thank <a href="https://habrahabr.ru/users/schvepsss/"><em>@schvepsss</em></a> and <a href="https://habr.com/users/shwars/"><em>@shwars</em></a> for preparing this article for publication. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/422115/">https://habr.com/ru/post/422115/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../422101/index.html">"Alice" teaches foreign languages</a></li>
<li><a href="../422103/index.html">Why a programmer should be able to write well</a></li>
<li><a href="../422107/index.html">Scale development: from startup to hundreds of engineers</a></li>
<li><a href="../422109/index.html">Firefox will block users by default.</a></li>
<li><a href="../422113/index.html">Fintech Digest: Central Bank will keep records of victims of hackers, Russians will get a credit rating, Yahoo Finance and crypt trading</a></li>
<li><a href="../422119/index.html">Toolkit indie game developer</a></li>
<li><a href="../422121/index.html">How to go to Germany to study and work on the example of my emigration</a></li>
<li><a href="../422123/index.html">How to stop the fayl and start conducting normal retrospectives</a></li>
<li><a href="../422125/index.html">SENS-Diagnosis. Biomarkers of protein aggregates</a></li>
<li><a href="../422127/index.html">Damn the mind. Sometimes</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>