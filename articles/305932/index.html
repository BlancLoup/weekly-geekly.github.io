<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Flume - manage data streams. Part 3</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hi, Habr! After a long pause, we finally return to parsing Apache Flume . In previous articles, we met Flume ( Part 1 ) and figured out how to configu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Flume - manage data streams. Part 3</h1><div class="post__text post__text-html js-mediator-article">  Hi, Habr!  After a long pause, we finally return to parsing <a href="https://flume.apache.org/">Apache Flume</a> .  In previous articles, we met Flume ( <a href="https://habrahabr.ru/company/dca/blog/280386/">Part 1</a> ) and figured out how to configure its main components ( <a href="https://habrahabr.ru/company/dca/blog/281933/">Part 2</a> ).  In this, the final part of the cycle, we will consider the following questions: <br><br><ul><li>  How to set up monitoring of node components. </li><li>  How to write your own implementation of the Flume component. </li><li>  Designing a complete transport network. </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/files/b36/9b7/812/b369b7812c754034b41ca2bac3c5a663.jpg"></div><a name="habracut"></a><br><h2>  Monitoring component state </h2><br>  So, we set up and run all the nodes, checked their performance - the data is successfully delivered to the destination.  But some time passes, we look at the result of the work of our transport network (for example, the folder with the files into which the data is packed) and we understand that a problem has arisen - since some time new files do not appear in our folder.  The next step seems obvious - open the logs, look for the cause.  The only trouble is that there may be a lot of nodes in our transport network, which means you need to manually view the logs of all the nodes, which, to put it mildly, is not very convenient.  When such problems arise, I would like to respond to them as quickly as possible, and even better - to avoid such critical situations at all. <br><br>  Flume components in the process of writing metrics that allow you to assess the status of the site.  Using the values ‚Äã‚Äãof these metrics, it is quite easy to determine that everything is not all right with the node. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      To store the counters and other attributes of its components, Flume uses <a href="https://docs.oracle.com/javase/7/docs/api/java/lang/management/ManagementFactory.html">java.lang.management.ManagementFactory</a> , registering its own bean classes for maintaining metrics.  All these classes are inherited from <a href="https://flume.apache.org/releases/content/1.4.0/apidocs/org/apache/flume/instrumentation/MonitoredCounterGroup.html">MonitoredCounterGroup</a> (for the curious, the <a href="">link to the source code</a> ). <br><br>  If you do not plan to develop your own components of Flume, then digging into the mechanism of maintaining metrics is completely optional, it is enough to figure out how to get them.  This can be done quite simply with the utilitarian class <a href="https://flume.apache.org/releases/content/1.4.0/apidocs/org/apache/flume/instrumentation/util/JMXPollUtil.html">JMXPollUtil</a> : <br><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> ru.test.flume.monitoring; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.Map; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.apache.flume.instrumentation.util.JMXPollUtil; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FlumeMetrics</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Map&lt;String, Map&lt;String, String&gt;&gt; getMetrics() { Map&lt;String, Map&lt;String, String&gt;&gt; metricsMap = JMXPollUtil.getAllMBeans(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> metricsMap; } }</code> </pre> <br>  As a result, you will get metrics grouped by node components that look like this: <br><br><div class="spoiler">  <b class="spoiler_title">Flume Component Metrics (JSON)</b> <div class="spoiler_text"><pre> <code class="javascript hljs">{ <span class="hljs-string"><span class="hljs-string">"SOURCE.my-source"</span></span>: { <span class="hljs-string"><span class="hljs-string">"EventReceivedCount"</span></span>: <span class="hljs-string"><span class="hljs-string">"567393607"</span></span>, <span class="hljs-string"><span class="hljs-string">"AppendBatchAcceptedCount"</span></span>: <span class="hljs-string"><span class="hljs-string">"5689696"</span></span>, <span class="hljs-string"><span class="hljs-string">"Type"</span></span>: <span class="hljs-string"><span class="hljs-string">"SOURCE"</span></span>, <span class="hljs-string"><span class="hljs-string">"EventAcceptedCount"</span></span>: <span class="hljs-string"><span class="hljs-string">"567393607"</span></span>, <span class="hljs-string"><span class="hljs-string">"AppendReceivedCount"</span></span>: <span class="hljs-string"><span class="hljs-string">"0"</span></span>, <span class="hljs-string"><span class="hljs-string">"StartTime"</span></span>: <span class="hljs-string"><span class="hljs-string">"1467797931288"</span></span>, <span class="hljs-string"><span class="hljs-string">"AppendAcceptedCount"</span></span>: <span class="hljs-string"><span class="hljs-string">"0"</span></span>, <span class="hljs-string"><span class="hljs-string">"OpenConnectionCount"</span></span>: <span class="hljs-string"><span class="hljs-string">"1"</span></span>, <span class="hljs-string"><span class="hljs-string">"AppendBatchReceivedCount"</span></span>: <span class="hljs-string"><span class="hljs-string">"5689696"</span></span>, <span class="hljs-string"><span class="hljs-string">"StopTime"</span></span>: <span class="hljs-string"><span class="hljs-string">"0"</span></span> }, <span class="hljs-string"><span class="hljs-string">"CHANNEL.my-channel"</span></span>: { <span class="hljs-string"><span class="hljs-string">"ChannelCapacity"</span></span>: <span class="hljs-string"><span class="hljs-string">"100000000"</span></span>, <span class="hljs-string"><span class="hljs-string">"ChannelFillPercentage"</span></span>: <span class="hljs-string"><span class="hljs-string">"5.0E-4"</span></span>, <span class="hljs-string"><span class="hljs-string">"Type"</span></span>: <span class="hljs-string"><span class="hljs-string">"CHANNEL"</span></span>, <span class="hljs-string"><span class="hljs-string">"ChannelSize"</span></span>: <span class="hljs-string"><span class="hljs-string">"500"</span></span>, <span class="hljs-string"><span class="hljs-string">"EventTakeSuccessCount"</span></span>: <span class="hljs-string"><span class="hljs-string">"567393374"</span></span>, <span class="hljs-string"><span class="hljs-string">"StartTime"</span></span>: <span class="hljs-string"><span class="hljs-string">"1467797930967"</span></span>, <span class="hljs-string"><span class="hljs-string">"EventTakeAttemptCount"</span></span>: <span class="hljs-string"><span class="hljs-string">"569291443"</span></span>, <span class="hljs-string"><span class="hljs-string">"EventPutSuccessCount"</span></span>: <span class="hljs-string"><span class="hljs-string">"567393607"</span></span>, <span class="hljs-string"><span class="hljs-string">"EventPutAttemptCount"</span></span>: <span class="hljs-string"><span class="hljs-string">"567393607"</span></span>, <span class="hljs-string"><span class="hljs-string">"StopTime"</span></span>: <span class="hljs-string"><span class="hljs-string">"0"</span></span> }, <span class="hljs-string"><span class="hljs-string">"SINK.my-sink"</span></span>: { <span class="hljs-string"><span class="hljs-string">"ConnectionCreatedCount"</span></span>: <span class="hljs-string"><span class="hljs-string">"1"</span></span>, <span class="hljs-string"><span class="hljs-string">"ConnectionClosedCount"</span></span>: <span class="hljs-string"><span class="hljs-string">"0"</span></span>, <span class="hljs-string"><span class="hljs-string">"Type"</span></span>: <span class="hljs-string"><span class="hljs-string">"SINK"</span></span>, <span class="hljs-string"><span class="hljs-string">"BatchCompleteCount"</span></span>: <span class="hljs-string"><span class="hljs-string">"2"</span></span>, <span class="hljs-string"><span class="hljs-string">"EventDrainAttemptCount"</span></span>: <span class="hljs-string"><span class="hljs-string">"567393374"</span></span>, <span class="hljs-string"><span class="hljs-string">"BatchEmptyCount"</span></span>: <span class="hljs-string"><span class="hljs-string">"959650"</span></span>, <span class="hljs-string"><span class="hljs-string">"StartTime"</span></span>: <span class="hljs-string"><span class="hljs-string">"1467797930968"</span></span>, <span class="hljs-string"><span class="hljs-string">"EventDrainSuccessCount"</span></span>: <span class="hljs-string"><span class="hljs-string">"567393374"</span></span>, <span class="hljs-string"><span class="hljs-string">"BatchUnderflowCount"</span></span>: <span class="hljs-string"><span class="hljs-string">"938419"</span></span>, <span class="hljs-string"><span class="hljs-string">"StopTime"</span></span>: <span class="hljs-string"><span class="hljs-string">"0"</span></span>, <span class="hljs-string"><span class="hljs-string">"ConnectionFailedCount"</span></span>: <span class="hljs-string"><span class="hljs-string">"0"</span></span> } }</code> </pre></div></div><br>  Metrics received, now you need to send them somewhere.  Here you can go two ways. <br><br><ol><li>  Use Flume features to provide metrics. </li><li>  Write your own implementation of processing metrics. </li></ol><br>  Flume provides an API that allows you to specify a monitoring method ‚Äî for this, the implementations of the <a href="https://flume.apache.org/releases/content/1.4.0/apidocs/org/apache/flume/instrumentation/MonitorService.html">MonitorService</a> interface are <a href="https://flume.apache.org/releases/content/1.4.0/apidocs/org/apache/flume/instrumentation/MonitorService.html">used</a> .  In order to enable monitoring, you must specify a class that implements <code>MonitorService</code> as a system property when the node is started (or in code). <br><pre> <code class="java hljs">java -Dflume.monitoring.type=org.apache.flume.instrumentation.http.HTTPMetricsServer ...</code> </pre> <br><pre> <code class="java hljs">System.setProperty(<span class="hljs-string"><span class="hljs-string">"flume.monitoring.type"</span></span>, <span class="hljs-string"><span class="hljs-string">"org.apache.flume.instrumentation.http.HTTPMetricsServer"</span></span>);</code> </pre> <br>  The <code>HTTPMetricsServer</code> class provides a standard way to monitor the status of a node.  It is a small web server that, upon request, provides a complete list of host metrics as JSON (as in the example above).  To specify the port on which this server will listen to requests, it is enough to add a parameter to the Flume configuration (by default, it uses port 41414): <br><br><pre> <code class="apache hljs"><span class="hljs-attribute"><span class="hljs-attribute">flume</span></span>.monitoring.port = 61509</code> </pre> <br>  The request to this server looks like this: <code>localhost:61509/metrics</code> . <br><br>  If this way of keeping track of metrics is not enough, then you have to go the second way and write your own implementation of <code>MonitorService</code> .  This is exactly what we did to monitor the state of our nodes with Graphite.  Below is a simple example of such an implementation. <br><br><div class="spoiler">  <b class="spoiler_title">FlumeGraphiteMonitor</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> ru.dmp.flume.monitoring; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> com.google.common.base.CaseFormat; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.HashSet; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.Map; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.Set; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.apache.flume.Context; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.apache.flume.instrumentation.MonitorService; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.apache.flume.instrumentation.util.JMXPollUtil; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FlumeGraphiteMonitor</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MonitorService</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   ,      Graphite private static final Set&lt;String&gt; EXCLUDED_METRICS = new HashSet&lt;String&gt;() {{ add("start-time"); add("stop-time"); }}; private volatile long period = 60 * 1000; //  , 1  private volatile boolean switcher = true; private Thread scheduler = new Thread(this::schedule); @Override public void configure(Context context) { //    -     } private void schedule() { while (switcher) { send(); synchronized (this) { try { wait(period); } catch (InterruptedException ex) {} } } } @Override public void start() { scheduler.start(); } @Override public void stop() { switcher = false; synchronized (this) { notifyAll(); } try { scheduler.join(); } catch (InterruptedException ex) {} } private void send() { Map&lt;String, Map&lt;String, String&gt;&gt; metricsMap = JMXPollUtil.getAllMBeans(); for (Map.Entry&lt;String, Map&lt;String, String&gt;&gt; e: metricsMap.entrySet()) { if (e.getValue() != null) { //     Flume    "flume" String group = "flume." + normalize(e.getKey().toLowerCase()) + "."; for (Map.Entry&lt;String, String&gt; metric : e.getValue().entrySet()) { try { Double value = Double.valueOf(metric.getValue()); String metricName = normalize(metric.getKey()); if (!EXCLUDED_METRICS.contains(metricName)) { String fullName = group + normalize(metric.getKey()); //      -  // Graphite.send(metricName, value); } } catch (NumberFormatException ex) { //   ,    } } } } } //    EventReceivedCount -&gt; event-received-count () private static String normalize(String str) { return CaseFormat.UPPER_CAMEL.to(CaseFormat.LOWER_UNDERSCORE, str).replaceAll("_", "-"); }</span></span></code> </pre></div></div><br>  As a result, we get a neat Graphite branch with all node metrics. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/cb6/b32/904/cb6b32904b6e4431b830f92360b38e99.png"></div><br>  Below are descriptions of graphs and metrics that we use for one of our services. <br><br><ol><li>  <b>The intensity of the sending service messages to the node Flume.</b>  The graph is not built according to the node metrics - these values ‚Äã‚Äãin Graphite send services that generate data and are the starting point of our transport system.  If your data sources do not allow tracking the sending of data to Flume, then similar graphs can be removed from the source (s) of the site. <br><br>  If the value on this graph drops to zero, then the client for some reason cannot send messages to Flume.  To diagnose who is to blame in such situations, we separately display a graph of errors that occur on the client side.  Accordingly, if it is non-zero, the problem is on the Flume node, the source cannot accept the data.  If the drop in intensity does not lead to an increase in the number of errors, then the problem is on the side of the service, he stopped sending messages. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/701/089/c6d/701089c6d4514cc2af53085599640610.png"></div><br></li><li>  <b>Node channel fullness.</b>  With this schedule, everything is simple - it should always be very close to zero.  If the channel does not have time to empty, then somewhere in our transport network there is a bottleneck and you need to look for nodes that do not have time to cope with the load.  Metrics on the chart: <br> <code>flume.channel.{CHANNEL-NAME}.channel-fill-percentage</code> <br> <br><div style="text-align:center;"><img src="https://habrastorage.org/files/4e3/2d4/1cd/4e32d41cd0414b6abd3fb970b3bf8def.png"></div><br></li><li>  <b>The intensity of the work of waste nodes.</b>  The expected indicators of stocks at this site are ‚Äúhow much they got, they sent so much‚Äù, since the events from the services are not duplicated in the channels.  Thus, the intensity of emptying the effluent should be the same as the intensity of sending data by customers.  Metrics on the chart: <br> <code>flume.sink.{SINK-NAME}.event-drain-success-count</code> <br> <br>  The drop in the intensity of any of the drains to zero indicates a potential problem at the next, receiving node.  As a result, the channel, devastated by the ‚Äúbroken‚Äù drain, will begin to fill.  It is also possible that the receiving nodes work normally, but simply do not have time to process the input data - in this case, the drain schedules will be non-zero, but the channels will be gradually filled. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/616/25f/5e4/61625f5e4e734a6abe6ee6ab7f11070a.png"></div></li></ol><br><br><h2>  Creating your own Flume components </h2><br>  Despite the fact that the set of standard Flume components is quite extensive, quite often there are situations that cannot be resolved with these standard components.  In this case, you can write your Flume component and use it in the nodes.  You can write your own implementation for any of the components of Flume - sink, source, channel, interceptor, etc. <br><br>  The first thing that caught my eye when examining Flume stocks is the lack of flexible flow for the file system.  Yes, there is a <a href="https://flume.apache.org/FlumeUserGuide.html">File-Roll Sink</a> , the capabilities of which were described in the <a href="https://habrahabr.ru/company/dca/blog/281933/">2nd part of the cycle</a> .  But this stock is completely deprived of the possibility to somehow influence the file name, which is not very convenient. <br><br>  We decided to develop our stock, which allows forming files in the local file system.  In developing the following considerations. <br><br><ul><li>  We have quite a lot of services with a relatively small load.  This means that in the end we will have quite a lot of disparate files - I would not want to configure a separate drain for each of them. <br><br></li><li>  Files must be rotated in time.  Moreover, for different data, the rotation period may differ (by rotation, it means "cutting data" into files by time - 15 minutes, an hour, etc.). <br><br></li><li>  Data from each service should be stored in a separate folder.  Moreover, one service can generate data for several subfolders. </li></ul><br>  Based on these theses, we came to the conclusion that the task of generating the file name is better left to the client (ie, data generating services), otherwise the flow configuration will be too cumbersome, and for each new ‚Äúclient‚Äù you will have to add a separate flow with individual settings . <br><br>  <font color="gray"><i><b>Note</b></i></font>  <font color="gray"><i>A comparison with the HDFS drain, which we discussed in the previous article, is relevant here.</i></font>  <font color="gray"><i>This drain allows you to perform very fine tuning of the rotation and file naming.</i></font>  <font color="gray"><i>But this flexibility of adjustment has a reverse side - for example, for files that rotate once every 15 and once every 30 minutes, you have to do different drains, even if in all other respects the parameters are identical.</i></font> <br><br>  So, the decision on the functionality of the file flow was taken as follows: <br><br><ul><li>  The name of the file to which the data should be recorded is determined by the client and transmits it in the header along with the event. <br><br></li><li>  The file name may contain subfolders. <br><br></li><li>  Files that are recorded by the drain are closed by a certain timeout when events stop coming for them. </li></ul><br>  Schematically, the data processing by this drain looks like this: <br><div style="text-align:center;"><img src="https://habrastorage.org/files/0a2/550/f74/0a2550f7465a4bfb889707f983c60a18.png"></div><br>  What it gave in the end: <br><br><ul><li>  There is no need to add stock for each new service or data type. <br><br></li><li>  Stoke is deprived of the costs of forming the file name (in the previous part we considered these costs on the example of HDFS drain) <br><br></li><li>  Since the file name is uniquely identified by one header, we can use the client side event grouping (this technique is also described in the second part of the cycle). </li></ul><br>  The source code of the file sink and an example of its configuration <a href="https://github.com/yakischik/flume-file-sink/tree/master">are laid out on GitHub</a> .  I think it makes no sense to analyze the process of developing this flow in detail, I will limit myself to a few theses: <br><br><ul><li>  The component is based on either an abstract class or a component interface (depending on whether you are developing - a sink, an interceptor, or something else). <br><br></li><li>  We make our own implementation - the easiest way is to take something from the ready-made Flume components as an example, since all the sources are available. <br><br></li><li>  When configuring, we specify not the reserved alias of the component (of the type 'avro' or 'logger'), but the entire class name. </li></ul><br><h2>  We design transport network </h2><br>  We considered the general methods of data management in the previous parts of the cycle - events can be divided between nodes, duplicated, choose the ‚Äúdirection of movement‚Äù using headers, etc.  Let us now try to use all these techniques in order to build a reliable transport network.  Suppose the task is as follows. <br><br><ol><li>  The data provider is a service running on several machines (it has several identical instances). <br><br></li><li>  The data generated by the service is heterogeneous - some of them need to be delivered in HDFS, some - in the file system to a certain log server. <br><br></li><li>  It is necessary to conduct in real time some non-atomic calculations associated with the data. </li></ol><br>  On condition 3 I‚Äôll dwell more  Suppose that the task is to count the unique users of the site for the last hour.  In this case, we cannot afford to parallelize the data stream from the machines or calculate this value separately on each web service - it is necessary to count the unique users by their cookies on a single data stream from all machines.  Otherwise, each instance will have its own set of unique users that cannot be ‚Äúpicked up and folded‚Äù to get the final result. <br><br>  <font color="gray"><i><b>Note</b></i></font>  <font color="gray"><i>Of course, the example is a bit far-fetched - this problem can be solved in other, more efficient ways.</i></font>  <font color="gray"><i>The essence of the example is reduced to the situation when you need to pass some data flow centrally through one handler and it is impossible to divide the load due to the nature of the task.</i></font> <br><br>  So, for the beginning let's prepare the client and end nodes: <br><div style="text-align:center;"><img src="https://habrastorage.org/files/0ba/ddf/6eb/0baddf6eb0ac464280ee48958d08e736.png"></div><br>  For each of the web services, we put our own individual node on the same machine as the web service.  This is done for the following reasons: <br><br><ul><li>  These nodes play the role of a buffer - if for some reason the delivery of events to other machines becomes impossible, these nodes will allow you to ‚Äúhold out‚Äù for some time without data loss due to the thick file channel. <br><br></li><li>  Reduced response time.  Of course, sending data to Flume should be done asynchronously - but during peak loads or a clogged network, a situation may arise when the background thread does not have time to send new events.  In this case, the queue for sending can grow greatly, mercilessly absorbing the memory of the service, which is not very good.  In the case where the node is located on the same machine as the service, these costs are significantly reduced. <br><br></li><li>  If the further processing logic changes and you decide to rebuild the transport network, then the changes will need to be made only in the configuration of the client node, and not the web service.  For him, everything will remain the same - ‚ÄúI send data to my site, then let him decide how to be‚Äù. </li></ul><br>  The question remains - how to deliver the data in such a way that nothing is lost if something breaks?  We have already taken a number of measures - data for HDFS and FS are written to several machines.  In this case, the data is not duplicated, but divided.  Thus, if one of the end machines fails, the entire load will go to the remainder.  The result of such a breakdown will be dysbalance on the recorded amount of data on different machines, but it is quite possible to live with this. <br><br>  To ensure greater stability, add a few intermediate Flume nodes that will deal directly with data distribution: <br><div style="text-align:center;"><img src="https://habrastorage.org/files/bdb/fc4/430/bdbfc44300124464b76edc264b103cf2.png"></div><br><br>  It turned out pretty weird web.  What's going on here: <br><br><ol><li>  The web service sends events to the client node. <br><br></li><li>  Each event has a header that indicates ‚Äúdestination‚Äù (for example, <b>dist = FS</b> or <b>dist = HDFS</b> ), as well as a <b>uniq</b> header with possible values ‚Äã‚Äãof 1 or 0. <br><br></li><li>  Each client node has 3 streams that equally empty the channel and evenly distribute the events between the three intermediate nodes - <b>Splitters</b> (so far without looking at the <b>dist</b> header). <br><br></li><li>  Each <b>Splitter</b> has several channels - for HDFS, FS, and a unique user counter.  The required channel is selected by the <b>dist</b> and <b>uniq</b> headers. <br><br></li><li>  Each of these channels on <b>Splitter</b> has several sinks that evenly distribute the events between the end machines (FS, HDFS or UNQ). </li></ol><br>  If everything is relatively simple with client nodes - they just divide the events between Splitters, then the structure of a single Splitter should be considered in more detail. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/15e/7a5/8d2/15e7a58d29634ec9960fa7b3e5a870e4.png"></div><br>  Here you can see that the end point for the data is determined using the <b>dist</b> header.  At the same time, the events for which unique users are counted do not depend on the <b>dist</b> header - they are oriented on the <b>uniq</b> header.  This means that some events can be duplicated in several channels, for example HDFS and UNQ. <br><br>  Earlier, I did not specifically indicate the direction from the Splitters to the UNQ nodes.  The point is that these nodes do not accept distributed data, like HDFS or FS.  Given the specifics of the task of counting unique users, the entire data stream must pass through only <b>one</b> machine.  A logical question - why do we need then 2 nodes to count unique users?  The answer is because if one node fails, there will be no one to replace it.  How can we be here - we cannot divide events between nodes, we cannot leave one alone too? <br><br>  Here, another Flume tool can help us, allowing the drains to work in a group on the principle ‚ÄúIf runoff 1 broke, use runoff 2‚Äù.  This component is called <a href="https://flume.apache.org/FlumeUserGuide.html">Failover Sink Processor</a> .  Its configuration is as follows: <br><br><pre> <code class="apache hljs"><span class="hljs-comment"><span class="hljs-comment">#        agent.sinks.sink-unq-1.type = avro agent.sinks.sink-unq-1.batch-size = 5000 agent.sinks.sink-unq-1.channel = memchannel agent.sinks.sink-unq-1.hostname = unq-counter-1.my-company.com agent.sinks.sink-unq-1.port = 50001 agent.sinks.sink-unq-2.type = avro agent.sinks.sink-unq-2.batch-size = 5000 agent.sinks.sink-unq-2.channel = memchannel agent.sinks.sink-unq-2.hostname = unq-counter-2.my-company.com agent.sinks.sink-unq-2.port = 50001 #     agent.sinkgroups = failover-group agent.sinkgroups.failover-group.sinks = sink-unq-1 sink-unq-2 #     failover agent.sinkgroups.failover-group.processor.type = failover #    -        agent.sinkgroups.failover-group.processor.priority.sink-unq-1 = 10 agent.sinkgroups.failover-group.processor.priority.sink-unq-2 = 1 #    -      () agent.sinkgroups.failover-group.processor.maxpenalty = 10000</span></span></code> </pre> <br>  The above setting group of threads allows you to use only one sink, but at the same time have a ‚Äúspare‚Äù in case of an accident.  Those.  as long as the high priority drain is working properly, low priority drains will be idle. <br><br>  Thus, the task is completed - the data is distributed between HDFS and FS, the counters of unique users work correctly.  In this case, the failure of any machine will not lead to data loss: <br><br><ol><li>  If a machine with a Web service breaks, this problem is solved by a balancer. <br><br></li><li>  If one of the Splitters fails, the load will be distributed among the rest. <br><br></li><li>  End nodes are also duplicated, the failure of one of them will not lead to stagnation or loss of data. <br><br></li><li>  The node for counting unique users has a ‚Äúdoubler‚Äù and in the event of a breakdown it will be replaced by it without disturbing the logic of data processing. </li></ol><br>  For such a scheme, scaling tasks are reduced to a simple change in the configuration of Flume nodes for the appropriate level of nodes (Client, Splitter, or Final): <br><br><ol><li>  New Web service instance - no configuration changes are required, it is simply installed along with the Flume client node. <br><br></li><li>  New Splitter - you only need to change the configuration of the client nodes by adding a new stock. <br><br></li><li>  New end node - you only need to change the configuration of Splitter'a, adding a new stock. </li></ol><br><h2>  Conclusion </h2><br>  This concludes the series of articles about Apache Flume.  We covered all the most popular of its components, figured out how to manage the flow of data and looked at an example of a complete transport network.  Nevertheless, the possibilities of Flume are not exhausted by all of this - in the standard package there are still quite a few components not considered by us that can make life much easier when solving certain tasks.  We hope that this series of articles has helped you to get acquainted with Flume and to get a fairly complete picture of it. <br><br>  Thanks for attention! </div><p>Source: <a href="https://habr.com/ru/post/305932/">https://habr.com/ru/post/305932/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../305918/index.html">Postfix Answering Machine</a></li>
<li><a href="../305920/index.html">Do IT marketing: why you need to visit hackathons</a></li>
<li><a href="../305922/index.html">The next requirement for the use of domestic encryption</a></li>
<li><a href="../305924/index.html">Creating your own graph processing application in Giraph</a></li>
<li><a href="../305926/index.html">How to think in SQL?</a></li>
<li><a href="../305934/index.html">"Hard time management." We talk about the book, Dan Kennedy</a></li>
<li><a href="../305936/index.html">UX Design: Flags and Switches in Forms</a></li>
<li><a href="../305940/index.html">Archiving as an answer to the ‚ÄúSpring package‚Äù</a></li>
<li><a href="../305944/index.html">Tale about a peasant, or how to change dusty "aglitskie" chipset coders</a></li>
<li><a href="../305948/index.html">Mobile UX-Design: How to correctly request user permissions</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>