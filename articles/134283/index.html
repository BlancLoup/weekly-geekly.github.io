<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Impressive Solids: making a game in C # under OpenGL, part II</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the first part of the development of the tetris-like game Impressive Solids, we implemented the main part of the gameplay, paying minimal attention...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Impressive Solids: making a game in C # under OpenGL, part II</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/7d6/111/da7/7d6111da7bf01986416a1ff754e492da.png" alt="Screenshot decorated game" align="left">  In the <a href="http://habrahabr.ru/blogs/gdev/133983/">first part of the</a> development of the tetris-like game Impressive Solids, we implemented the main part of the gameplay, paying minimal attention to the appearance of the application.  We almost did not use OpenGL, we just made it up that we painted a colored rectangle.  It is time to do the design, as well as to realize the scoring and storage of a record (high score).  Well, let's go further. <br><br><h3>  Picture this </h3><br>  Let's do the textures.  We need, first, to pull something on the background of the window, and second, to make nice-looking blocks (now these are just colored rectangles).  Understandably, you first need to make textures.  <a href="http://www.gimp.org/">GIMP</a> will help us in this.  If you do not want to engage in graphics, you can simply download the <a href="">archive with ready-made textures</a> and proceed to the next step. <br><br>  But first I will note one very important nuance.  <a href="http://www.opengl.org/wiki/NPOT_Texture">Prior to OpenGL 2.0,</a> each of the texture sizes had to be equal to a power of two (i.e. 64 √ó 64, 512 √ó 256; these are POT textures, from the English of power of two).  If textures of arbitrary size (NPOT textures) are not supported by a video card or a video card driver, such a texture will not work.  This is the case, for example, for Intel integrated graphics cards under Windows XP. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      To ensure that you are safe from this problem, the simplest and most convenient solution is to always use POT textures.  However, it is not always possible, and further, when we get to the output of the text, we will have to deal with this moment. <br><br><a name="habracut"></a>  So, create in GIMP an empty (white) image of 512 √ó 512, then: Filters ‚Üí Artistic ‚Üí Apply Canvas, then: Filters ‚Üí Map ‚Üí Make Seamless.  Everything background.png is ready. <br><br>  We will try to depict the blocks as marble balls, <a href="http://www.ehow.com/how_5695037_make-marbled-bubble-gimp.html">Daniel Ketchum will help</a> us in this.  Create a transparent image somewhere 300 √ó 300, make a round selection for the entire diameter of the canvas.  Tool Bucket Fill ‚Üí Pattern fill ‚Üí select the texture Marble # 1, fill the circle.  Next: Filters ‚Üí Distort ‚Üí Lens Distortion, turn Main to maximum, and Edge to minimum, OK.  Then: Filters ‚Üí Light and Shadow ‚Üí Lighting Effects, set the light so as to create the effect of a three-dimensional ball.  We crop so that there are no empty fields.  Scale to size 256 √ó 256.  Then with the help of Colors ‚Üí Colorize we make five different colors (we twist Hue) and save as 0.png, 1.png ... 4.png (remember that in the game model we decided to designate different colors of the blocks as an integer starting from zero). <br><br>  Now you need to add these files to the Visual C # Express / MonoDevelop project.  First, through the context menu, create a New Folder called textures, and in it - solids.  Through the file manager, put the background.png file in textures, and the 0.png files in textures / solids ... 4.png.  Through the context menu in the development environment, we add these files to the project in the appropriate folders. <br><br>  After that, it is necessary to open Properties for all * .png files in the project and set Build Action: Content;  Copy to Output Directory: Copy if newer. <br><br>  Enable textures in OpenGL.  OpenGL itself does not operate graphic files, you need your own means (this will help <code>System.Drawing.Bitmap</code> ) load the texture into memory, get a binary bitmap from it and transfer it to OpenGL, which will save the texture already in its memory.  In the future, the texture can be accessed through an integer handle (which must first be reserved). <br><br>  We encapsulate this mechanism in the form of a new class <code>Texture</code> . <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Drawing; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Drawing.Imaging; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> OpenTK.Graphics.OpenGL; <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">ImpressiveSolids</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Texture</span></span> : <span class="hljs-title"><span class="hljs-title">IDisposable</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> GlHandle { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Width { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Height { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Texture</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Bitmap Bitmap</span></span></span><span class="hljs-function">)</span></span> { GlHandle = GL.GenTexture(); Bind(); Width = Bitmap.Width; Height = Bitmap.Height; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> BitmapData = Bitmap.LockBits(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Rectangle(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, Bitmap.Width, Bitmap.Height), ImageLockMode.ReadOnly, System.Drawing.Imaging.PixelFormat.Format32bppArgb); GL.TexImage2D(TextureTarget.Texture2D, <span class="hljs-number"><span class="hljs-number">0</span></span>, PixelInternalFormat.Rgba, BitmapData.Width, BitmapData.Height, <span class="hljs-number"><span class="hljs-number">0</span></span>, OpenTK.Graphics.OpenGL.PixelFormat.Bgra, PixelType.UnsignedByte, BitmapData.Scan0); Bitmap.UnlockBits(BitmapData); GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMinFilter, (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)TextureMinFilter.Linear); GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMagFilter, (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)TextureMagFilter.Linear); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Bind</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { GL.BindTexture(TextureTarget.Texture2D, GlHandle); } <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">region</span></span></span><span class="hljs-meta"> Disposable private bool Disposed = false; public void Dispose() { Dispose(true); GC.SuppressFinalize(this); } protected virtual void Dispose(bool Disposing) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (!Disposed) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (Disposing) { GL.DeleteTexture(GlHandle); } Disposed = true; } } ~Texture() { Dispose(false); } #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endregion</span></span></span><span class="hljs-meta"> } }</span></span></code> </pre><br><br>  In the <code>Game</code> will load the textures. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Drawing; <span class="hljs-comment"><span class="hljs-comment">// . . . private Texture TextureBackground; private Texture[] ColorTextures = new Texture[ColorsCount]; public Game() : base(NominalWidth, NominalHeight, GraphicsMode.Default, "Impressive Solids") { VSync = VSyncMode.On; Keyboard.KeyDown += new EventHandler&lt;KeyboardKeyEventArgs&gt;(OnKeyDown); TextureBackground = new Texture(new Bitmap("textures/background.png")); for (var i = 0; i &lt; ColorsCount; i++) { ColorTextures[i] = new Texture(new Bitmap("textures/solids/" + i + ".png")); } }</span></span></code> </pre><br><br>  Change the rendering.  It is necessary to include textures in general, as well as transparency mode.  Then, before you specify the coordinates of the rectangle, you must select (bind) the corresponding texture.  Before each point (vertex) it is necessary to specify the corresponding coordinates of the texture (it is assumed that (1; 1) is the lower right corner of the texture). <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnLoad</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">EventArgs E</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">base</span></span>.OnLoad(E); GL.Enable(EnableCap.Texture2D); GL.Enable(EnableCap.Blend); GL.BlendFunc(BlendingFactorSrc.SrcAlpha, BlendingFactorDest.OneMinusSrcAlpha); New(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnRenderFrame</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">FrameEventArgs E</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// . . . GL.LoadMatrix(ref Modelview); RenderBackground(); for (var X = 0; X &lt; MapWidth; X++) { for (var Y = 0; Y &lt; MapHeight; Y++) { if (Map[X, Y] &gt;= 0) { RenderSolid(X, Y + ImpactFallOffset[X, Y], Map[X, Y]); } } } if (GameStateEnum.Fall == GameState) { for (var i = 0; i &lt; StickLength; i++) { RenderSolid(StickPosition.X + i, StickPosition.Y, StickColors[i]); } } SwapBuffers(); } private void RenderBackground() { TextureBackground.Bind(); GL.Color4(Color4.White); GL.Begin(BeginMode.Quads); GL.TexCoord2(0, 0); GL.Vertex2(0, 0); GL.TexCoord2((float)ClientRectangle.Width / TextureBackground.Width, 0); GL.Vertex2(ProjectionWidth, 0); GL.TexCoord2((float)ClientRectangle.Width / TextureBackground.Width, (float)ClientRectangle.Height / TextureBackground.Height); GL.Vertex2(ProjectionWidth, ProjectionHeight); GL.TexCoord2(0, (float)ClientRectangle.Height / TextureBackground.Height); GL.Vertex2(0, ProjectionHeight); GL.End(); } private void RenderSolid(float X, float Y, int Color) { ColorTextures[Color].Bind(); GL.Color4(Color4.White); GL.Begin(BeginMode.Quads); GL.TexCoord2(0, 0); GL.Vertex2(X * SolidSize, Y * SolidSize); GL.TexCoord2(1, 0); GL.Vertex2((X + 1) * SolidSize, Y * SolidSize); GL.TexCoord2(1, 1); GL.Vertex2((X + 1) * SolidSize, (Y + 1) * SolidSize); GL.TexCoord2(0, 1); GL.Vertex2(X * SolidSize, (Y + 1) * SolidSize); GL.End(); }</span></span></code> </pre><br><br>  The specified color colors, tints the texture, so we indicate white. <br><br>  Fine, textures work.  Commit: "Textured background and solids". <br><br><h3>  Main street </h3><br>  Now it is necessary to designate a glass.  Let it be just a black rectangle, over the background of the window, but behind the blocks. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RenderPipe</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { GL.Disable(EnableCap.Texture2D); GL.Color4(Color4.Black); GL.Begin(BeginMode.Quads); GL.Vertex2(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); GL.Vertex2(MapWidth * SolidSize, <span class="hljs-number"><span class="hljs-number">0</span></span>); GL.Vertex2(MapWidth * SolidSize, MapHeight * SolidSize); GL.Vertex2(<span class="hljs-number"><span class="hljs-number">0</span></span>, MapHeight * SolidSize); GL.End(); GL.Enable(EnableCap.Texture2D); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnRenderFrame</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">FrameEventArgs E</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// . . . RenderBackground(); RenderPipe(); // . . . }</span></span></code> </pre><br><br>  Let's position the glass.  Let it be on the left, with a small indent from the edges of the window.  To the right of the glass later we will place additional interface elements (score, etc.).  However, if the window is stretched in width, then let the glass slide to the right towards the center of the window, otherwise there will be too much empty space to the right.  Finally, we <code>NominalWidth</code> making the window smaller than <code>NominalWidth</code> √ó <code>NominalHeight</code> (this, however, will not work under the X window system). <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> NominalWidth = <span class="hljs-number"><span class="hljs-number">500</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> NominalHeight = <span class="hljs-number"><span class="hljs-number">500</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnResize</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">EventArgs E</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// . . . if (ClientSize.Width &lt; NominalWidth) { ClientSize = new Size(NominalWidth, ClientSize.Height); } if (ClientSize.Height &lt; NominalHeight) { ClientSize = new Size(ClientSize.Width, NominalHeight); } } protected override void OnRenderFrame(FrameEventArgs E) { // . . . RenderBackground(); var PipeMarginY = (ProjectionHeight - MapHeight * SolidSize) / 2f; var PipeMarginX = (NominalHeight - MapHeight * SolidSize) / 2f; var Overwidth = ProjectionWidth - ProjectionHeight * (float)NominalWidth / NominalHeight; if (Overwidth &gt; 0) { GL.Translate(Math.Min(Overwidth, (ProjectionWidth - MapWidth * SolidSize) / 2f), PipeMarginY, 0); } else { GL.Translate(PipeMarginX, PipeMarginY, 0); } RenderPipe(); // . . . }</span></span></code> </pre><br><br>  Commit: "Position and render pipe". <br><br><h3>  Writing on the Wall </h3><br>  What will be to the right of the glass?  Four elements: the next stick;  game status (there will be a message "Playing", "Paused" or "Game Over");  current account;  record score <br><br>  Most of this is text, so we need to learn how to draw text using OpenGL.  OpenGL itself is not able to do anything like that.  Often there are mentions that OpenTK has a convenient class <code>TextPrinter</code> for this purpose.  <a href="http://www.opentk.com/project/text">It was a long time</a> and not true.  Now the <a href="http://www.opentk.com/doc/graphics/how-to-render-text-using-opengl">recommended method for</a> displaying text is the following: make a bitmap with text (using <code>System.Drawing.Graphics.DrawString</code> or others) and drag it as a texture. <br><br>  Let's write our <code>TextRenderer</code> class, which will create a <code>Bitmap</code> and then <code>Texture</code> based on it.  But first you have to attend to the aforementioned problem of NPOT-dimensional textures, since we do not know in advance what size the dynamically created label will have.  The method is quite simple: if NPOT-textures are not supported, then when loading a picture, you need to make a POT-dimensional texture, as if with fields.  For example, if we load a 300 √ó 200 image, then we generate a 512 √ó 256 texture, on which our image will be in the upper left corner, and the rest of the space will be empty.  And when applying a texture, it will be necessary to take into account that the lower left corner of the picture has the coordinates not (1; 1), but (300/512; 200/256). <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Texture</span></span> : <span class="hljs-title"><span class="hljs-title">IDisposable</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> GlHandle { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Width { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Height { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">region</span></span></span><span class="hljs-meta"> NPOT private static bool? CalculatedSupportForNpot; public static bool NpotIsSupported { get { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (!CalculatedSupportForNpot.HasValue) { CalculatedSupportForNpot = false; int ExtensionsCount; GL.GetInteger(GetPName.NumExtensions, out ExtensionsCount); for (var i = 0; i &lt; ExtensionsCount; i++) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> ("GL_ARB_texture_non_power_of_two" == GL.GetString(StringName.Extensions, i)) { CalculatedSupportForNpot = true; break; } } } return CalculatedSupportForNpot.Value; } } public int PotWidth { get { return NpotIsSupported ? Width : (int)Math.Pow(2, Math.Ceiling(Math.Log(Width, 2))); } } public int PotHeight { get { return NpotIsSupported ? Height : (int)Math.Pow(2, Math.Ceiling(Math.Log(Height, 2))); } } #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endregion</span></span></span><span class="hljs-meta"> public Texture(Bitmap Bitmap) { // . . . var BitmapData = Bitmap.LockBits(new Rectangle(0, 0, Bitmap.Width, Bitmap.Height), ImageLockMode.ReadOnly, System.Drawing.Imaging.PixelFormat.Format32bppArgb); GL.TexImage2D(TextureTarget.Texture2D, 0, PixelInternalFormat.Rgba, PotWidth, PotHeight, 0, OpenTK.Graphics.OpenGL.PixelFormat.Bgra, PixelType.UnsignedByte, IntPtr.Zero); GL.TexSubImage2D(TextureTarget.Texture2D, 0, 0, 0, BitmapData.Width, BitmapData.Height, OpenTK.Graphics.OpenGL.PixelFormat.Bgra, PixelType.UnsignedByte, BitmapData.Scan0); Bitmap.UnlockBits(BitmapData); // . . . } // . . . }</span></span></code> </pre><br><br>  Now - <code>TextRenderer</code> .  The code seems long, but actually everything is simple.  Here we do four main things: we set the parameters of the text, measure its dimensions, draw the text into the texture and, finally, apply the texture to the transparent rectangle. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Drawing; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Drawing.Text; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> OpenTK.Graphics; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> OpenTK.Graphics.OpenGL; <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">ImpressiveSolids</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">TextRenderer</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Font FontValue; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> LabelValue; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> NeedToCalculateSize, NeedToRenderTexture; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Texture Texture; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> CalculatedWidth, CalculatedHeight; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Font Font { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> FontValue; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { FontValue = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; NeedToCalculateSize = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; NeedToRenderTexture = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Label { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> LabelValue; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> != LabelValue) { LabelValue = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; NeedToCalculateSize = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; NeedToRenderTexture = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Width { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (NeedToCalculateSize) { CalculateSize(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> CalculatedWidth; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Height { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (NeedToCalculateSize) { CalculateSize(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> CalculatedHeight; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Color4 Color = Color4.Black; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TextRenderer</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Font Font</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Font = Font; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TextRenderer</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Font Font, Color4 Color</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Font = Font; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Color = Color; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TextRenderer</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Font Font, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Label</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Font = Font; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Label = Label; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TextRenderer</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Font Font, Color4 Color, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Label</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Font = Font; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Color = Color; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Label = Label; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CalculateSize</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Bitmap = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Bitmap(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (Graphics Graphics = Graphics.FromImage(Bitmap)) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Measures = Graphics.MeasureString(Label, Font); CalculatedWidth = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)Math.Ceiling(Measures.Width); CalculatedHeight = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)Math.Ceiling(Measures.Height); } } NeedToCalculateSize = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Render</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((<span class="hljs-literal"><span class="hljs-literal">null</span></span> == Label) || (<span class="hljs-string"><span class="hljs-string">""</span></span> == Label)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (NeedToRenderTexture) { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Bitmap = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Bitmap(Width, Height)) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Rectangle = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Rectangle(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, Bitmap.Width, Bitmap.Height); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (Graphics Graphics = Graphics.FromImage(Bitmap)) { Graphics.Clear(System.Drawing.Color.Transparent); Graphics.TextRenderingHint = TextRenderingHint.AntiAliasGridFit; Graphics.DrawString(Label, Font, Brushes.White, Rectangle); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-literal"><span class="hljs-literal">null</span></span> != Texture) { Texture.Dispose(); } Texture = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Texture(Bitmap); } } NeedToRenderTexture = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } Texture.Bind(); GL.Color4(Color); GL.Begin(BeginMode.Quads); GL.TexCoord2(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); GL.Vertex2(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); GL.TexCoord2((<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)Texture.Width / Texture.PotWidth, <span class="hljs-number"><span class="hljs-number">0</span></span>); GL.Vertex2(Width, <span class="hljs-number"><span class="hljs-number">0</span></span>); GL.TexCoord2((<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)Texture.Width / Texture.PotWidth, (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)Texture.Height / Texture.PotHeight); GL.Vertex2(Width, Height); GL.TexCoord2(<span class="hljs-number"><span class="hljs-number">0</span></span>, (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)Texture.Height / Texture.PotHeight); GL.Vertex2(<span class="hljs-number"><span class="hljs-number">0</span></span>, Height); GL.End(); } } }</code> </pre><br><br>  Let's output something to the right of the glass. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Drawing.Text; <span class="hljs-comment"><span class="hljs-comment">// . . . private int Score; private int HighScore; private TextRenderer NextStickLabel, ScoreLabel, ScoreRenderer, HighScoreLabel, HighScoreRenderer, GameOverLabel, GameOverHint; public Game() // . . . var LabelFont = new Font(new FontFamily(GenericFontFamilies.SansSerif), 20, GraphicsUnit.Pixel); var LabelColor = Color4.SteelBlue; NextStickLabel = new TextRenderer(LabelFont, LabelColor, "Next"); ScoreLabel = new TextRenderer(LabelFont, LabelColor, "Score"); HighScoreLabel = new TextRenderer(LabelFont, LabelColor, "High score"); var ScoreFont = new Font(new FontFamily(GenericFontFamilies.SansSerif), 50, GraphicsUnit.Pixel); var ScoreColor = Color4.Tomato; ScoreRenderer = new TextRenderer(ScoreFont, ScoreColor); HighScoreRenderer = new TextRenderer(ScoreFont, ScoreColor); var GameStateFont = new Font(new FontFamily(GenericFontFamilies.SansSerif), 30, GraphicsUnit.Pixel); var GameStateColor = Color4.Tomato; GameOverLabel = new TextRenderer(GameStateFont, GameStateColor, "Game over"); var GameStateHintFont = new Font(new FontFamily(GenericFontFamilies.SansSerif), 25, GraphicsUnit.Pixel); var GameStateHintColor = Color4.SteelBlue; GameOverHint = new TextRenderer(GameStateHintFont, GameStateHintColor, "Press Enter"); } protected override void OnRenderFrame(FrameEventArgs E) { // . . . GL.Translate(MapWidth * SolidSize + PipeMarginX, 0, 0); NextStickLabel.Render(); // TODO   next stick GL.Translate(0, MapHeight * SolidSize / 4f, 0); if (GameStateEnum.GameOver == GameState) { GameOverLabel.Render(); GL.Translate(0, GameOverLabel.Height, 0); GameOverHint.Render(); GL.Translate(0, -GameOverLabel.Height, 0); } GL.Translate(0, MapHeight * SolidSize / 4f, 0); ScoreLabel.Render(); GL.Translate(0, ScoreLabel.Height, 0); ScoreRenderer.Label = Score.ToString(); ScoreRenderer.Render(); GL.Translate(0, -ScoreLabel.Height, 0); GL.Translate(0, MapHeight * SolidSize / 4f, 0); HighScoreLabel.Render(); GL.Translate(0, HighScoreLabel.Height, 0); HighScoreRenderer.Label = HighScore.ToString(); HighScoreRenderer.Render(); SwapBuffers(); }</span></span></code> </pre><br><br>  <code>MapHeight * SolidSize / 4f</code> is a quarter of the height of the glass, each time we descend below this distance to depict one of the four elements of the interface.  In addition, removing the inscription, we descend to its height below, and then do not forget to rise back to the starting point. <br><br>  Commit: "Text GUI". <br><br><h3>  Next </h3><br>  Let's display the next stick itself.  To begin, however, it is necessary to slightly change the model, because now we have the next stick generated at the moment of the start of the next move, but it is necessary that it be generated already on the current turn and stored somewhere. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] NextStickColors; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateNextStick</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; StickLength; i++) { StickColors[i] = NextStickColors[i]; NextStickColors[i] = Rand.Next(ColorsCount); } StickPosition.X = (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)Math.Floor((MapWidth - StickLength) / <span class="hljs-number"><span class="hljs-number">2</span></span>d); StickPosition.Y = <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">New</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// . . . StickColors = new int[StickLength]; NextStickColors = new int[StickLength]; GenerateNextStick(); GenerateNextStick(); // because 1st call makes current stick all zeros GameState = GameStateEnum.Fall; }</span></span></code> </pre><br><br>  To display, we use the <code>RenderSolid</code> method, everything is very simple. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnRenderFrame</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">FrameEventArgs E</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// . . . NextStickLabel.Render(); GL.Translate(0, NextStickLabel.Height, 0); RenderNextStick(); GL.Translate(0, -NextStickLabel.Height, 0); // . . . } public void RenderNextStick() { GL.Disable(EnableCap.Texture2D); GL.Color4(Color4.Black); GL.Begin(BeginMode.Quads); GL.Vertex2(0, 0); GL.Vertex2(StickLength * SolidSize, 0); GL.Vertex2(StickLength * SolidSize, SolidSize); GL.Vertex2(0, SolidSize); GL.End(); GL.Enable(EnableCap.Texture2D); for (var i = 0; i &lt; StickLength; i++) { RenderSolid(i, 0, NextStickColors[i]); } }</span></span></code> </pre><br><br>  Done, commit: "Render next stick." <br><br><h3>  The score </h3><br>  Let's take the points.  It is necessary to give more points for long lines, for the simultaneous destruction of several lines, for the sequential destruction of several lines within one turn.  It will interest players to build complex combinations, will add interest to the game. <br><br>  The formulas below are derived offhand, they, of course, will still need to be checked at the beta testing stage, to look at the player reviews. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> TotalDestroyedThisMove; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">New</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// . . . Score = 0; TotalDestroyedThisMove = 0; } protected override void OnUpdateFrame(FrameEventArgs E) { // . . . if (Destroyables.Count &gt; 0) { foreach (var Coords in Destroyables) { Map[(int)Coords.X, (int)Coords.Y] = -1; } Score += (int)Math.Ceiling(Destroyables.Count + Math.Pow(1.5, Destroyables.Count - 3) - 1) + TotalDestroyedThisMove; TotalDestroyedThisMove += Destroyables.Count; Stabilized = false; } // . . . GenerateNextStick(); TotalDestroyedThisMove = 0; GameState = GameStateEnum.Fall; // . . . }</span></span></code> </pre><br><br>  At the end of the game, we will update the record (if it is broken) and write to the file, and when you start the application, read the current record from the file. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.IO; <span class="hljs-comment"><span class="hljs-comment">// . . . private string HighScoreFilename; public Game() { // . . . var ConfigDirectory = Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData) + Path.DirectorySeparatorChar + "ImpressiveSolids"; if (!Directory.Exists(ConfigDirectory)) { Directory.CreateDirectory(ConfigDirectory); } HighScoreFilename = ConfigDirectory + Path.DirectorySeparatorChar + "HighScore.dat"; if (File.Exists(HighScoreFilename)) { using (var Stream = new FileStream(HighScoreFilename, FileMode.Open)) { using (var Reader = new BinaryReader(Stream)) { try { HighScore = Reader.ReadInt32(); } catch (IOException) { HighScore = 0; } } } } else { HighScore = 0; } } protected override void OnUpdateFrame(FrameEventArgs E) { // . . . if (GameOver) { GameState = GameStateEnum.GameOver; if (Score &gt; HighScore) { HighScore = Score; using (var Stream = new FileStream(HighScoreFilename, FileMode.Create)) { using (var Writer = new BinaryWriter(Stream)) { Writer.Write(HighScore); } } } } else { // . . . }</span></span></code> </pre><br><br>  Commit: ‚ÄúCalculating score, storing high score‚Äù. <br><br><h3>  Heaven can wait </h3><br>  Finally, we will make it possible to pause the game. <br><br>  A pause cannot be made as a state ( <code>GameStateEnum</code> ), because the game can be paused both during the fall of the stick ( <code>Fall</code> ) and during <code>Impact</code> , and from the pause the game should return to the state it was in. <br><br>  Therefore, we introduce an additional <code>Paused</code> flag and its processing in <code>OnUpdateFrame</code> , <code>OnKeyDown</code> , <code>OnRenderFrame</code> . <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> Paused; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> TextRenderer PauseLabel, UnpauseHint, PlayingGameLabel, PauseHint; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Game</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">// . . . var GameStateFont = new Font(new FontFamily(GenericFontFamilies.SansSerif), 30, GraphicsUnit.Pixel); var GameStateColor = Color4.Tomato; GameOverLabel = new TextRenderer(GameStateFont, GameStateColor, "Game over"); PauseLabel = new TextRenderer(GameStateFont, GameStateColor, "Pause"); PlayingGameLabel = new TextRenderer(GameStateFont, GameStateColor, "Playing"); var GameStateHintFont = new Font(new FontFamily(GenericFontFamilies.SansSerif), 25, GraphicsUnit.Pixel); var GameStateHintColor = Color4.SteelBlue; GameOverHint = new TextRenderer(GameStateHintFont, GameStateHintColor, "Press Enter"); UnpauseHint = new TextRenderer(GameStateHintFont, GameStateHintColor, "Press Space"); PauseHint = new TextRenderer(GameStateHintFont, GameStateHintColor, "Space pauses"); } protected override void OnLoad(EventArgs E) { base.OnLoad(E); GL.Enable(EnableCap.Texture2D); GL.Enable(EnableCap.Blend); GL.BlendFunc(BlendingFactorSrc.SrcAlpha, BlendingFactorDest.OneMinusSrcAlpha); New(); Paused = true; } protected override void OnUpdateFrame(FrameEventArgs E) { base.OnUpdateFrame(E); if (Paused) { return; } // . . . } protected void OnKeyDown(object Sender, KeyboardKeyEventArgs E) { if ((GameStateEnum.Fall == GameState) &amp;&amp; !Paused) { // . . . } if (((GameStateEnum.Fall == GameState) || (GameStateEnum.Impact == GameState)) &amp;&amp; (Key.Space == E.Key)) { Paused = !Paused; } } protected override void OnRenderFrame(FrameEventArgs E) { // . . . GL.Translate(0, MapHeight * SolidSize / 4f, 0); if (GameStateEnum.GameOver == GameState) { GameOverLabel.Render(); GL.Translate(0, GameOverLabel.Height, 0); GameOverHint.Render(); GL.Translate(0, -GameOverLabel.Height, 0); } else if (Paused) { PauseLabel.Render(); GL.Translate(0, PauseLabel.Height, 0); UnpauseHint.Render(); GL.Translate(0, -PauseLabel.Height, 0); } else { PlayingGameLabel.Render(); GL.Translate(0, PlayingGameLabel.Height, 0); PauseHint.Render(); GL.Translate(0, -PlayingGameLabel.Height, 0); } // . . . }</span></span></span></span></code> </pre><br><br>  A new game when starting the application is convenient (for the player) to start just in the pause state. <br><br>  We use the spacebar, not the Pause key, because the spacebar is more convenient and always remembered about it, unlike Pause, which many people don‚Äôt even know about.  In addition, problems arise with the latter, in particular, when using the Punto Switcher. <br><br>  Commit: "Pause". <br><br>  That's all for now.  Sure, in the game you can still finish a lot of small nuances and particulars.  Surely pop up bugs that need to be fixed.  All this I leave to the reader for independent study. <br><br>  The project is available on <del>  <a href="http://code.google.com/p/impressive-solids/">Google Project Hosting</a> </del>  <a href="https://bitbucket.org/denyspopov/impressive-solids">Bitbucket</a> , there you can see the final source code, download the archive with an executable file ready for launch. </div><p>Source: <a href="https://habr.com/ru/post/134283/">https://habr.com/ru/post/134283/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../134274/index.html">Cryptographic protection of DNS traffic</a></li>
<li><a href="../134275/index.html">Embedded Tweet. Now tweets can be inserted into your site</a></li>
<li><a href="../134277/index.html">Home Automation Kit - how do you see it?</a></li>
<li><a href="../134278/index.html">StartFellows is a free grant for Internet startups.</a></li>
<li><a href="../134281/index.html">Speed ‚Äã‚Äãtest a year later</a></li>
<li><a href="../134286/index.html">HTC Desire HD has been updated to Android 2.3.5 and Sense 3.0</a></li>
<li><a href="../134288/index.html">Bookbase - beta was born</a></li>
<li><a href="../134289/index.html">Development of cartographic mobile applications in C ++ / Qt, using Qt Mobility</a></li>
<li><a href="../134292/index.html">Winning the domino effect</a></li>
<li><a href="../134293/index.html">What if you look into the keyhole of the Election Commission?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>