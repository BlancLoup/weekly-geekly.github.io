<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We control the standard Sailfish OS player using voice commands</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Many people know and use such features of the Android operating system as Google Now and Google Assistant, which allow not only to receive useful info...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We control the standard Sailfish OS player using voice commands</h1><div class="post__text post__text-html js-mediator-article">  Many people know and use such features of the Android operating system as Google Now and Google Assistant, which allow not only to receive useful information in time and to search for something on the Internet, but also to control the device using voice commands.  Unfortunately, Sailfish OS (the operating system developed by the Finnish company Jolla and the Russian company Open Mobile Platform) does not provide such an opportunity out of the box.  As a result, it was decided to fill the lack of these amenities on their own.  One of the functions of the developed solution is the ability to control the music player using voice commands, the technical side of which will be discussed in this article. <br><a name="habracut"></a><br>  To implement recognition and execution of voice commands, you will need to go through four simple steps: <br><br><ol><li>  develop a system of commands </li><li>  realize speech recognition </li><li>  realize the identification and execution of commands </li><li>  add voice feedback. </li></ol><br>  It is assumed that, for a better understanding of the material, the reader already has a basic knowledge of C ++, JavaScript, Qt, QML and Linux and has familiarized himself with the <a href="https://sailfishos.org/wiki/Tutorial_-_Combining_C%252B%252B_with_QML">example of their interaction within the framework of Sailfish OS</a> .  It may also be useful to get acquainted with the <a href="https://www.youtube.com/watch%3Fv%3DaLMeu9ovuJs">lecture on related topics</a> held in the framework of the Sailfish OS Summer School in Innopolis in the summer of 2016, and other articles on the development of this platform that have already been published on Habr√©. <br><br><h3>  Development of a command system </h3><br>  Let us analyze a simple example, limited to five functions: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  launch of new music playback </li><li>  resume playing music </li><li>  pause music playback </li><li>  go to the next track </li><li>  go to the previous song. </li></ul><br>  To start a new playback, you need to check the presence of an open copy of the player (if necessary, create) and start playing music in a random order.  To activate, we will use the "Turn on the music" command. <br><br>  In the case of resuming and stopping playback, you need to check the status of the player and, if possible, start playback or pause it.  To resume playback, we will use the ‚ÄúPlay‚Äù command;  to pause - the commands "Pause" and "Stop". <br><br>  In the case of navigation through the compositions, the above principle of checking the status of the audio player applies.  To activate the forward navigation, use the commands ‚ÄúForward‚Äù, ‚ÄúNext‚Äù and ‚ÄúNext‚Äù;  to activate the navigation back - the command "Back" and "Previous". <br><br><h3>  Speech recognition </h3><br>  The process of recognition of voice commands is divided into three stages: <br><br><ol><li>  recording a voice command to a file </li><li>  command recognition on the server, </li><li>  identification commands on the device. </li></ol><br><h5>  Record voice command to file </h5><br>  At the beginning, you need to create a user interface to capture the voice command.  In order to simplify the example, we will begin and end the recording by pressing the button, since the implementation of the process of detecting the beginning and end of a voice command deserves a separate material. <br><br><pre><code class="javascript hljs">IconButton { property bool isRecording: <span class="hljs-literal"><span class="hljs-literal">false</span></span> width: Theme.iconSizeLarge height: Theme.iconSizeLarge icon.source: isRecording ? <span class="hljs-string"><span class="hljs-string">"image://theme/icon-m-search"</span></span> : <span class="hljs-string"><span class="hljs-string">"image://theme/icon-m-mic"</span></span> onClicked: { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isRecording) { isRecording = <span class="hljs-literal"><span class="hljs-literal">false</span></span> recorder.stopRecord() yandexSpeechKitHelper.recognizeQuery(recorder.getActualLocation()) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { isRecording = <span class="hljs-literal"><span class="hljs-literal">true</span></span> recorder.startRecord() } } }</code> </pre> <br>  From the code presented above, it is clear that the button uses standard size values ‚Äã‚Äãand standard icons (an interesting feature of Sailfish OS for unification of application interfaces) and has two states.  In the first state, when the recording is not made, after pressing the button, the voice command is recorded.  In the second state, when the command recording is active, after pressing the button, the recording stops and voice recognition begins. <br><br>  To record speech, we will use the <a href="http://doc.qt.io/qt-5/qaudiorecorder.html">QAudioRecorder</a> class, which provides a high-level interface for controlling the input audio stream, as well as <a href="http://doc.qt.io/qt-5/qaudioencodersettings.html">QAudioEncoderSettings</a> for setting the recording process. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Recorder</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> QObject { Q_OBJECT <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Recorder</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(QObject *parent = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">Q_INVOKABLE </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">startRecord</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">Q_INVOKABLE </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stopRecord</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">Q_INVOKABLE QUrl </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getActualLocation</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">Q_INVOKABLE </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isRecording</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: QAudioRecorder _audioRecorder; QAudioEncoderSettings _settings; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> _recording = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }; Recorder::Recorder(QObject *parent) : QObject(parent) { _settings.setCodec(<span class="hljs-string"><span class="hljs-string">"audio/PCM"</span></span>); _settings.setQuality(QMultimedia::NormalQuality); _audioRecorder.setEncodingSettings(_settings); _audioRecorder.setContainerFormat(<span class="hljs-string"><span class="hljs-string">"wav"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Recorder::startRecord() { _recording = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; _audioRecorder.record(); } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Recorder::stopRecord() { _recording = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; _audioRecorder.stop(); } QUrl Recorder::getActualLocation() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _audioRecorder.actualLocation(); } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> Recorder::isRecording() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _recording; }</code> </pre><br>  It specifies that the command will be recorded in wav format in normal quality, as well as methods for starting and ending recording are defined, to get the storage location of the audio file and the state of the recording process. <br><br><h5>  Team Recognition on the server </h5><br>  For broadcasting an audio file into text, the <a href="https://tech.yandex.ru/speechkit/cloud/">Yandex SpeechKit Cloud service</a> will be used.  All that is required to start working with it is to get a token in <a href="https://developer.tech.yandex.ru/">the developer‚Äôs office</a> .  <a href="https://tech.yandex.ru/speechkit/cloud/doc/intro/overview/concepts/about-docpage/">Service documentation is</a> quite detailed, so we will dwell only on private moments. <br><br>  The first step is to transfer the recorded command to the server. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> YandexSpeechKitHelper::recognizeQuery(QString path_to_file) { QFile *file = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> QFile(path_to_file); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (file-&gt;open(QIODevice::ReadOnly)) { QUrlQuery query; query.addQueryItem(<span class="hljs-string"><span class="hljs-string">"key"</span></span>, <span class="hljs-string"><span class="hljs-string">"API_KEY"</span></span>); query.addQueryItem(<span class="hljs-string"><span class="hljs-string">"uuid"</span></span>, _buildUniqID()); query.addQueryItem(<span class="hljs-string"><span class="hljs-string">"topic"</span></span>, <span class="hljs-string"><span class="hljs-string">"queries"</span></span>); <span class="hljs-function"><span class="hljs-function">QUrl </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">url</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"https://asr.yandex.net/asr_xml"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; url.setQuery(query); <span class="hljs-function"><span class="hljs-function">QNetworkRequest </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">request</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(url)</span></span></span></span>; request.setHeader(QNetworkRequest::ContentTypeHeader, <span class="hljs-string"><span class="hljs-string">"audio/x-wav"</span></span>); request.setHeader(QNetworkRequest::ContentLengthHeader, file-&gt;size()); _manager-&gt;post(request, file-&gt;readAll()); file-&gt;close(); } file-&gt;remove(); }</code> </pre><br>  Here a POST request to the Yandex server is formed, in which the received token is transmitted, the unique device ID (in this case, the MAC address of the WiFi module is used) and the type of request (‚Äúqueries‚Äù are used here, since voice interaction with the device is most often used) short and accurate commands).  In the request headers indicate the format of the audio file and its size, in the body - the content itself.  After sending the request to the server, the file is deleted as unnecessary. <br><br>  As a response, the SpeechKit Cloud server returns XML with recognition options and a degree of confidence in them.  We use the standard Qt tools to highlight the required information. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> YandexSpeechKitHelper::_parseResponce(QXmlStreamReader *element) { <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> idealConfidence = <span class="hljs-number"><span class="hljs-number">0</span></span>; QString idealQuery; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!element-&gt;atEnd()) { element-&gt;readNext(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (element-&gt;tokenType() != QXmlStreamReader::StartElement) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (element-&gt;name() != <span class="hljs-string"><span class="hljs-string">"variant"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; QXmlStreamAttribute attr = element-&gt;attributes().at(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (attr.value().toDouble() &gt; idealConfidence) { idealConfidence = attr.value().toDouble(); element-&gt;readNext(); idealQuery = element-&gt;text().toString(); } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (element-&gt;hasError()) qDebug() &lt;&lt; element-&gt;errorString(); <span class="hljs-function"><span class="hljs-function">emit </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">gotResponce</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(idealQuery)</span></span></span></span>; }</code> </pre><br>  Here the received answer is sequentially viewed and, for variant tags, the recognition accuracy indicators are checked.  If the new version is more correct, then it is saved, and the scan continues.  At the end of viewing the response, a signal is sent with the selected command text. <br><br><h5>  Identification commands on the device </h5><br>  Finally, it remains to identify the command.  At the end of the <i>YandexSpeechKitHelper :: _ parseResponce method</i> , as mentioned above, the <i>gotResponce</i> signal is <i>sent</i> , containing the command text.  Next, you need to process it in the QML-code of the program. <br><br><pre> <code class="javascript hljs">Connections { <span class="hljs-attr"><span class="hljs-attr">target</span></span>: yandexSpeechKitHelper onGotResponce: { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (query.toLowerCase()) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">" "</span></span>: dbusHelper.startMediaplayerIfNeed() mediaPlayer.shuffleAndPlay() <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span>: mediaPlayerControl.play() <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span>: mediaPlayerControl.pause() <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span>: mediaPlayerControl.next() <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span>: mediaPlayerControl.previous() <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: generateErrorMessage(query) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } }</code> </pre><br>  It uses the Connections element to process the incoming signal and compare the recognized command with the voice command patterns defined earlier. <br><br><h3>  Controlling a working player </h3><br>  If the audio player is open, then it is possible to interact with it through a <a href="https://specifications.freedesktop.org/mpris-spec/latest/index.html">standard DBus interface</a> , inherited from a big linux brother.  With it, you can navigate through the playlist, start or pause playback.  This is done using the QML element <a href="https://sailfishos.org/develop/docs/nemo-qml-plugin-dbus/qml-org-nemomobile-dbus-dbusinterface.html/">DBusInterface</a> . <br><br><pre> <code class="javascript hljs">DBusInterface { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: mediaPlayerControl service: <span class="hljs-string"><span class="hljs-string">"org.mpris.MediaPlayer2.jolla-mediaplayer"</span></span> iface: <span class="hljs-string"><span class="hljs-string">"org.mpris.MediaPlayer2.Player"</span></span> path: <span class="hljs-string"><span class="hljs-string">"/org/mpris/MediaPlayer2"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">play</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ call(<span class="hljs-string"><span class="hljs-string">"Play"</span></span>, <span class="hljs-literal"><span class="hljs-literal">undefined</span></span>) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pause</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ call(<span class="hljs-string"><span class="hljs-string">"Pause"</span></span>, <span class="hljs-literal"><span class="hljs-literal">undefined</span></span>) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">next</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ call(<span class="hljs-string"><span class="hljs-string">"Next"</span></span>, <span class="hljs-literal"><span class="hljs-literal">undefined</span></span>) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">previous</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ call(<span class="hljs-string"><span class="hljs-string">"Previous"</span></span>, <span class="hljs-literal"><span class="hljs-literal">undefined</span></span>) call(<span class="hljs-string"><span class="hljs-string">"Previous"</span></span>, <span class="hljs-literal"><span class="hljs-literal">undefined</span></span>) } }</code> </pre><br>  Using this element, the standard audio player's DBus interface is used by defining four basic functions.  The <i>undefined</i> parameter of the <i>call</i> function is passed if the DBus method takes no arguments. <br><br>  It should be noted that for the transition to the previous song, the Previous method is called twice, since its single call leads to the playback of the current song from the beginning. <br><br><h3>  Start playback from scratch </h3><br>  There is nothing complicated in managing a player already operating.  However, if there is a desire to start playing music when it is closed, there is a problem, since, by default, the functionality of launching a standard player with simultaneous playback of the entire collection is not provided. <br><br>  But do not forget that Sailfish OS is an open source operating system available for free modification.  As a result, this problem can be solved in two stages: <br><br><ul><li>  Extend the functions provided by the player through the DBus interface; </li><li>  Implement the launch of the player (if necessary) and start playback immediately after launch. </li></ul><br><h5>  Expansion of the functions of the standard audio player </h5><br>  The standard audio player, in addition to the <i>org.mpris.MediaPlayer2.Player</i> interface, provides the <i>com.jolla.mediaplayer.ui</i> interface, defined in the <i>/usr/share/jolla-mediaplayer/mediaplayer.qml</i> file.  From this it follows that it is possible to modify this file by adding the necessary function. <br><br><pre> <code class="javascript hljs">DBusAdaptor { <span class="hljs-attr"><span class="hljs-attr">service</span></span>: <span class="hljs-string"><span class="hljs-string">"com.jolla.mediaplayer"</span></span> path: <span class="hljs-string"><span class="hljs-string">"/com/jolla/mediaplayer/ui"</span></span> iface: <span class="hljs-string"><span class="hljs-string">"com.jolla.mediaplayer.ui"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">openUrl</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">arg</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (arg[<span class="hljs-number"><span class="hljs-number">0</span></span>] == <span class="hljs-literal"><span class="hljs-literal">undefined</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span> } AudioPlayer.playUrl(Qt.resolvedUrl(arg[<span class="hljs-number"><span class="hljs-number">0</span></span>])) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!pageStack.currentPage || pageStack.currentPage.objectName !== <span class="hljs-string"><span class="hljs-string">"PlayQueuePage"</span></span>) { root.pageStack.push(playQueuePage, {}, PageStackAction.Immediate) } activate() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">shuffleAndPlay</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ AudioPlayer.shuffleAndPlay(allSongModel, allSongModel.count) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!pageStack.currentPage || pageStack.currentPage.objectName !== <span class="hljs-string"><span class="hljs-string">"PlayQueuePage"</span></span>) { root.pageStack.push(playQueuePage, {}, PageStackAction.Immediate) } activate() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> } }</code> </pre><br>  Here the <a href="https://sailfishos.org/develop/docs/nemo-qml-plugin-dbus/qml-org-nemomobile-dbus-dbusadaptor.html/">DBusAdaptor</a> element used to provide the DBus interface was modified by adding the <i>shuffleAndPlay</i> method.  It uses the standard player functionality to start playback of all songs in a random order, provided by the c <i>om.jolla.mediaplayer</i> module, and the current playback queue is brought to the forefront. <br><br>  As part of the example, for simplicity, a simple modification of the system file was performed.  However, when distributing the program, such changes should be made in the form of patches using the <a href="">appropriate instructions</a> . <br><br>  Now from the developed program it is necessary to refer to the new method.  This is done with the help of the already familiar <a href="https://sailfishos.org/develop/docs/nemo-qml-plugin-dbus/qml-org-nemomobile-dbus-dbusinterface.html/">DBusInterface</a> element, in which you connect to the service defined above and call the function added to the player. <br><br><pre> <code class="javascript hljs">DBusInterface { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: mediaPlayer service: <span class="hljs-string"><span class="hljs-string">"com.jolla.mediaplayer"</span></span> iface: <span class="hljs-string"><span class="hljs-string">"com.jolla.mediaplayer.ui"</span></span> path: <span class="hljs-string"><span class="hljs-string">"/com/jolla/mediaplayer/ui"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">shuffleAndPlay</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ call(<span class="hljs-string"><span class="hljs-string">"shuffleAndPlay"</span></span>, <span class="hljs-literal"><span class="hljs-literal">undefined</span></span>) } }</code> </pre><br><h5>  Player launch if closed </h5><br>  Finally, the last thing left is to launch the audio player if it is closed.  Conventionally, the task can be divided into two stages: <br><br><ul><li>  directly launching the player, </li><li>  waiting to scan your music collection. </li></ul><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> DBusHelper::startMediaplayerIfNeed() { QDBusReply&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt; reply = QDBusConnection::sessionBus().interface()-&gt;isServiceRegistered(<span class="hljs-string"><span class="hljs-string">"com.jolla.mediaplayer"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!reply.value()) { QProcess process; process.start(<span class="hljs-string"><span class="hljs-string">"/bin/bash -c \"jolla-mediaplayer &amp;\""</span></span>); process.waitForFinished(); <span class="hljs-function"><span class="hljs-function">QDBusInterface </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">interface</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"com.jolla.mediaplayer"</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"/com/jolla/mediaplayer/ui"</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"com.jolla.mediaplayer.ui"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { QDBusReply&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt; reply = interface.call(<span class="hljs-string"><span class="hljs-string">"isSongsModelFinished"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (reply.isValid() &amp;&amp; reply.value()) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; QThread::sleep(<span class="hljs-number"><span class="hljs-number">1</span></span>); } } }</code> </pre><br>  From the code of the presented function, it can be seen that at the first stage, the availability of the necessary DBus service is checked.  If it is registered in the system, the function terminates and the transition to start playback is performed.  If the service is not found, then a new copy of the audio player is <a href="http://doc.qt.io/qt-5/qprocess.html">created</a> using <a href="http://doc.qt.io/qt-5/qprocess.html">QProcess</a> , with the expectation of its full launch.  In the second part of the function, using <a href="http://doc.qt.io/qt-5/qdbusinterface.html">QDBusInterface</a> , the flag of the end of scanning the music collection on the device is checked. <br><br>  It should be noted that two additional changes were made to the <i>/usr/share/jolla-mediaplayer/mediaplayer.qml</i> file to check the collection scan flag. <br><br>  First, the <i>GriloTrackerModel</i> element provided by the <i>com.jolla.mediaplayer</i> module was modified by adding a scan end flag. <br><br><pre> <code class="javascript hljs">GriloTrackerModel { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: allSongModel property bool isFinished: <span class="hljs-literal"><span class="hljs-literal">false</span></span> query: { <span class="hljs-comment"><span class="hljs-comment">//: placeholder string for albums without a known name //% "Unknown album" var unknownAlbum = qsTrId("mediaplayer-la-unknown-album") //: placeholder string to be shown for media without a known artist //% "Unknown artist" var unknownArtist = qsTrId("mediaplayer-la-unknown-artist") return AudioTrackerHelpers.getSongsQuery("", {"unknownArtist": unknownArtist, "unknownAlbum": unknownAlbum}) } onFinished: { isFinished = true var artList = fetchAlbumArts(3) if (artList[0]) { if (!artList[0].url || artList[0].url == "") { mediaPlayerCover.idleArtist = artList[0].author ? artList[0].author : "" mediaPlayerCover.idleSong = artList[0].title ? artList[0].title : "" } else { mediaPlayerCover.idle.largeAlbumArt = artList[0].url mediaPlayerCover.idle.leftSmallAlbumArt = artList[1] &amp;&amp; artList[1].url ? artList[1].url : "" mediaPlayerCover.idle.rightSmallAlbumArt = artList[2] &amp;&amp; artList[2].url ? artList[2].url : "" mediaPlayerCover.idle.sourcesReady = true } } } }</span></span></code> </pre><br>  Secondly, one more function was added that is available through the DBus interface <i>com.jolla.mediaplayer.ui</i> , which returns the value of the scan state flag of the collection of audio files. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isSongsModelFinished</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> allSongModel.isFinished }</code> </pre><br><h3>  Error Team Report </h3><br>  The final element of the example is a voice message about the wrong command.  To do this, we use the Yandex SpeechKit Cloud speech synthesis service. <br><br><pre> <code class="javascript hljs">Audio { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: audio } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">generateErrorMessage</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">query</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> message = <span class="hljs-string"><span class="hljs-string">".  "</span></span> + query + <span class="hljs-string"><span class="hljs-string">"  ."</span></span> audio.source = <span class="hljs-string"><span class="hljs-string">"https://tts.voicetech.yandex.net/generate?"</span></span> + <span class="hljs-string"><span class="hljs-string">"text=\""</span></span> + message + <span class="hljs-string"><span class="hljs-string">"\"&amp;"</span></span> + <span class="hljs-string"><span class="hljs-string">"format=mp3&amp;"</span></span> + <span class="hljs-string"><span class="hljs-string">"lang=ru-RU&amp;"</span></span> + <span class="hljs-string"><span class="hljs-string">"speaker=jane&amp;"</span></span> + <span class="hljs-string"><span class="hljs-string">"emotion=good&amp;"</span></span> + <span class="hljs-string"><span class="hljs-string">"key=API_KEY"</span></span> audio.play() }</code> </pre><br>  Here, an Audio object was created to play the generated speech and the <i>generateErrorMessage</i> function was declared to form a request to the Yandex server and start playback.  The request passes the following parameters: <br><br><ul><li>  <i>text</i> - text for the synthesis (message about the wrong voice command), </li><li>  <i>format</i> - the format of the returned file (mp3), </li><li>  <i>lang</i> - the language of the phrase (Russian) </li><li>  <i>speaker</i> - voice voice (female) </li><li>  <i>emotion</i> - emotional coloring of the voice (friendly), </li><li>  <i>key</i> - the <i>key</i> received at the beginning of the article. </li></ul><br><h3>  Conclusion </h3><br>  This article describes a simple example of controlling music playback in a standard Sailfish OS audio player using voice commands;  Basic knowledge of speech recognition and speech synthesis using Yandex SpeechKit Cloud using Qt tools, as well as the principles of interaction of programs with each other in Sailfish OS, are obtained and repeated.  This material can serve as a starting point for deeper research and experimentation in this operating system. <br><br>  An example of the above code can be viewed on the video: <br><iframe width="560" height="315" src="https://www.youtube.com/embed/0esju66Pkp0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br>  Posted by: Peter Vytovtov </div><p>Source: <a href="https://habr.com/ru/post/313680/">https://habr.com/ru/post/313680/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../313670/index.html">Go for the record: Chromium fifth check</a></li>
<li><a href="../313672/index.html">Lord of storage</a></li>
<li><a href="../313674/index.html">Secrets of Progressive Web Apps: Part 2</a></li>
<li><a href="../313676/index.html">Determine the user's location by IP and create a hit counter</a></li>
<li><a href="../313678/index.html">Cyber-grouping Sednit activities under a microscope - Part 2</a></li>
<li><a href="../313682/index.html">As I wrote the game for the contest, or the wonderful transformation of "Lines" into "Sea battle"</a></li>
<li><a href="../313684/index.html">Selection of useful materials on DevOps</a></li>
<li><a href="../313686/index.html">Comparison of logging libraries</a></li>
<li><a href="../313688/index.html">Two-factor authentication and open doors</a></li>
<li><a href="../313690/index.html">The cellars of the Tower of Babel, or the internationalization of databases with access through ORM</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>