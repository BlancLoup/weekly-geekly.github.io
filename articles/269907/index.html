<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Unpacked types of unions in Scala based on the Curry-Howard isomorphism</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Translator's note. The future version of Scala (‚ÄúDon Giovanni‚Äù) announced support for union types. Miles Sabin, widely known in narrow circles as the ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Unpacked types of unions in Scala based on the Curry-Howard isomorphism</h1><div class="post__text post__text-html js-mediator-article"> <i>Translator's note.</i>  <i>The future version of Scala (‚ÄúDon Giovanni‚Äù) <a href="http://www.scala-lang.org/news/roadmap-next">announced</a> support for union types.</i>  <i>Miles Sabin, widely known in narrow circles as the creator of Shapeless, demonstrates in <a href="http://milessabin.com/blog/2011/06/09/scala-union-types-curry-howard/">this</a> 2011 article how to create union types now.</i> <i><br></i>  <i><b>UPD</b> .</i>  <i>The approach presented in the article does not allow to get real types of union and, moreover, can significantly affect the compilation time.</i>  <i>The types of intersection ( <code>A with B</code> ) used in the article are also different from the classical ones because they do not have the commutative property.</i>  <i>Details about the Dotty pilot project, within the framework of which these and other problems will be solved, can be found in Dmitry Petrashko‚Äôs wonderful <a href="https://d-d.me/scalaworld2015/">presentation by</a> <a href="https://habrahabr.ru/users/darkdimius/" class="user_link">darkdimius</a> , the developer of the Scala compiler in EPFL.</i> <br><br>  Scala has a very expressive type system.  However, it does not include (at least as primitives) all desired elements.  There are several truly useful types that fall under this category - these are types of higher rank polymorphic functions and recursive structural types.  But I‚Äôll talk about them in more detail in the next posts, and today I‚Äôm going to show you how in Scala we can create union types.  In the course of the explanation, I will shed a little light on the Curry-Howard isomorphism and show how to use it for our purposes. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/427/70e/d92/42770ed92098475fac9f4632be73e3d5.jpg"></div><br><a name="habracut"></a><br>  So, to begin with, what is a type of union?  The type of association is in many ways what you expect from it: the union of two (or more, but I will confine myself to only two) types.  Values ‚Äã‚Äãof this type include all values ‚Äã‚Äãof each of the types being combined.  What this means will help us to clarify an example, but first we introduce a notation system.  For reasons that will soon become clear, I will write the union of types <code>T</code> and <code>U</code> using the OR operation symbol: <code>T ‚à® U</code>  Thus, the union of the <code>Int</code> and <code>String</code> types is written as <code>Int ‚à® String</code> .  Values ‚Äã‚Äãof this type of union include all values ‚Äã‚Äãof type <code>Int</code> and all values ‚Äã‚Äãof type <code>String</code> . 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      But what does this mean more specifically?  This means that if we were able to directly express such a type in Scala, then we could, for example, write this: <br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">size</span></span></span></span>(x: <span class="hljs-type"><span class="hljs-type">Int</span></span> ‚à® <span class="hljs-type"><span class="hljs-type">String</span></span>) = x <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> i: <span class="hljs-type"><span class="hljs-type">Int</span></span> =&gt; i <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> s: <span class="hljs-type"><span class="hljs-type">String</span></span> =&gt; s.length } size(<span class="hljs-number"><span class="hljs-number">23</span></span>) == <span class="hljs-number"><span class="hljs-number">23</span></span> <span class="hljs-comment"><span class="hljs-comment">// OK size("foo") == 3 // OK size(1.0) //  OK,  </span></span></code> </pre><br>  In other words, the <code>size</code> method can take arguments of type <code>Int</code> , or type <code>String</code> (including their subtypes <code>Null</code> and <code>Nothing</code> ), and no others. <br><br>  It is important to emphasize the difference between using this type of association and standard <code>Either</code> .  <code>Either</code> , known as the sum type, is an analogue of the union type in languages ‚Äã‚Äãthat do not support subtypes.  Rewriting our example using <code>Either</code> will give us: <br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">size</span></span></span></span>(x: <span class="hljs-type"><span class="hljs-type">Either</span></span>[<span class="hljs-type"><span class="hljs-type">Int</span></span>, <span class="hljs-type"><span class="hljs-type">String</span></span>]) = x <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">Left</span></span>(i) =&gt; i <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">Right</span></span>(s) =&gt; s.length } size(<span class="hljs-type"><span class="hljs-type">Left</span></span>(<span class="hljs-number"><span class="hljs-number">23</span></span>)) == <span class="hljs-number"><span class="hljs-number">23</span></span> <span class="hljs-comment"><span class="hljs-comment">// OK size(Right("foo")) == 3 // OK</span></span></code> </pre><br>  The <code>Either[Int, String]</code> type can model the type of the combination <code>Int ‚à® String</code> , since there is a correspondence (isomorphism) between them and their values.  However, it is absolutely clear that the <code>Either</code> type achieves this as an additional level of boxed representation, and not as an unboxed type system primitive.  Can we create something better than <code>Either</code> ?  Can we find a way to represent the types of unification in Scala without packaging and with all the expected static guarantees? <br><br>  It turns out that we can, but on the way to the result we need to make a detour through first-order logic using the <a href="https://en.wikipedia.org/wiki/Curry%25E2%2580%2593Howard_correspondence">Curry-Howard isomorphism</a> .  This isomorphism tells us that relationships between types in a type system can be viewed as an image of the relationship between statements in a logical system (and vice versa).  We can interpret this statement in different ways, depending on which type system we are talking about and which logical system we have chosen, but for our discussion I will ignore most of the details and focus on simple examples. <br><br>  We illustrate the Curry-Howard isomorphism in the context of a type system with subtypes as in Scala.  You can see that there is a correspondence between the types of intersection ( <code>A with B</code> ) and logical conjunction ( <code>A ‚àß B</code> );  between my hypothetical types of union ( <code>A ‚à® B</code> ) and logical disjunction (also <code>A ‚à® B</code> , which was hinted at above);  and between subtypes ( <code>A &lt;: B</code> ) and logical implication ( <code>A ‚áí B</code> ).  In the left column of the table below, we have subtype relationships performed in Scala (but in the case of union types, not expressed directly in the language), and in the right column we have logical formulas derived from relations between types on the left by simply replacing <code>with</code> <code>‚àß</code> and <code>&lt;:</code> <code>‚áí</code> .  In each case, such a replacement gives a logically correct formula. <br><table><tbody><tr><td>  (A with B) &lt;: A </td><td>  (A ‚àß B) ‚áí A </td></tr><tr><td>  (A with B) &lt;: B </td><td>  (A ‚àß B) ‚áí B </td></tr><tr><td>  A &lt;: (A ‚à® B) </td><td>  A ‚áí (A ‚à® B) </td></tr><tr><td>  B &lt;: (A ‚à® B) </td><td>  B ‚áí (A ‚à® B) </td></tr></tbody></table><br>  The essence of the Curry-Howard isomorphism is that the mechanical replacement process always maintains its correctness ‚Äî the correct type formula is always rewritten into the correct logical formula, and vice versa.  And this is done not only for conjunction, disjunction and implication.  We can also generalize correspondence to logical formulas including negation (the key operation in today's discussion) and quantifiers of generality and existence. <br><br>  What does the addition of a negative mean to us?  A conjunction of two types (i.e. <code>A with B</code> ) has values ‚Äã‚Äãthat are instances of both <code>A</code> and <code>B</code> at the same time.  Similarly, we can assume that the negation of type <code>A</code> (I will write it as <code>¬¨[A]</code> ) must have values ‚Äã‚Äãthat are not instances of type <code>A</code>  Negation also cannot be directly expressed in the Scala language, but what will we come to, assuming that this is not so? <br><br>  In such a case, we could use the Curry-Howard isomorphism and the <a href="https://ru.wikipedia.org/wiki/%25D0%2597%25D0%25B0%25D0%25BA%25D0%25BE%25D0%25BD%25D1%258B_%25D0%25B4%25D0%25B5_%25D0%259C%25D0%25BE%25D1%2580%25D0%25B3%25D0%25B0%25D0%25BD%25D0%25B0">De Morgan laws</a> to get a definition of union types from intersection and negation types.  Here's how it could turn out ... <br><br>  To begin with, let us recall the De Morgan equality: <br><pre> <code class="hljs">(A ‚à® B) ‚áî ¬¨(¬¨A ‚àß ¬¨B)</code> </pre><br>  Then apply the Curry-Howard isomorphism (using the equivalence operation <code>=:=</code> of the Scala language): <br><pre> <code class="scala hljs">(<span class="hljs-type"><span class="hljs-type">A</span></span> ‚à® <span class="hljs-type"><span class="hljs-type">B</span></span>) =:= ¬¨[¬¨[<span class="hljs-type"><span class="hljs-type">A</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> ¬¨[<span class="hljs-type"><span class="hljs-type">B</span></span>]]</code> </pre><br>  If we could only find a way to record this in Scala, then our goal would be achieved and we would have our types of union.  So can we express the type negation in Scala? <br><br>  Unfortunately, we can not.  But what we can do is convert all our types in such a way as to make possible the recording of the negation in the transformed context.  Then we need to find a way to make it all work in its original, non-transformed context. <br><br>  Some readers may have been a little surprised when I previously illustrated the Curry-Howard isomorphism using intersection types paired with conjunction, union types paired with disjunction, and subtype ratio paired with implication.  Usually, product types (product types), i.e.  <code>(A, B)</code> model a conjunction, sum types ( <code>Either[A, B]</code> ) model a disjunction, and function types model an implication.  If we rewrite our previous table using products, sums and functions, we get the following: <br><table><tbody><tr><td>  (A, B) =&gt; A </td><td>  (A ‚àß B) ‚áí A </td></tr><tr><td>  (A, B) =&gt; B </td><td>  (A ‚àß B) ‚áí B </td></tr><tr><td>  A =&gt; Either [A, B] </td><td>  A ‚áí (A ‚à® B) </td></tr><tr><td>  B =&gt; Either [A, B] </td><td>  B ‚áí (A ‚à® B) </td></tr></tbody></table><br>  In the left part, we no longer expect correctness in terms of the relationship of subtypes; instead, we need to follow the <a href="https://en.wikipedia.org/wiki/Parametricity">principle of parametricity</a> , which allows us to determine whether the type of function can be implemented based only on the signature of the function.  Obviously, all function signatures in the left column can be implemented.  For the first two cases, we have a pair <code>(A, B)</code> as an argument of our function, so we can easily get a value of type <code>A</code> or <code>B</code> from this pair using <code>_1</code> or <code>_2</code> : <br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> conj1: ((<span class="hljs-type"><span class="hljs-type">A</span></span>, <span class="hljs-type"><span class="hljs-type">B</span></span>)) =&gt; <span class="hljs-type"><span class="hljs-type">A</span></span> = p =&gt; p._1 <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> conj2: ((<span class="hljs-type"><span class="hljs-type">A</span></span>, <span class="hljs-type"><span class="hljs-type">B</span></span>)) =&gt; <span class="hljs-type"><span class="hljs-type">B</span></span> = p =&gt; p._2</code> </pre><br>  In the second and third cases, the arguments of the function are values ‚Äã‚Äãof type <code>A</code> and <code>B</code> respectively, so we can get the result of type <code>Either[A, B]</code> using the <code>Left[A]</code> and <code>Right[B]</code> constructors: <br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> disj1: <span class="hljs-type"><span class="hljs-type">A</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">Either</span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>, <span class="hljs-type"><span class="hljs-type">B</span></span>] = a =&gt; <span class="hljs-type"><span class="hljs-type">Left</span></span>(a) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> disj2: <span class="hljs-type"><span class="hljs-type">B</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">Either</span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>, <span class="hljs-type"><span class="hljs-type">B</span></span>] = b =&gt; <span class="hljs-type"><span class="hljs-type">Right</span></span>(b)</code> </pre><br>  It is in this form that the Curry-Howard isomorphism is usually expressed for languages ‚Äã‚Äãwithout subtypes.  However, join types, as well as intersection types, are inherently based on subtypes.  Therefore, the mapping considered does not help us in any way with the union.  But it can help us with the negation, which is the same missing piece of the puzzle. <br><br>  With or without subtypes, the lowest type (bottom type), represented in Scala as <code>Nothing</code> , is mapped to a logical false.  For example, all of the following equations are true: <br><table><tbody><tr><td>  A =&gt; Either [A, Nothing] </td><td>  A ‚áí (A ‚à® false) </td></tr><tr><td>  B =&gt; Either [Nothing, B] </td><td>  B ‚áí (false ‚à® B) </td></tr></tbody></table><br>  This follows from the fact that all the function signatures on the left are realizable, and the logical formulas on the right are correct (the <a href="http://james-iry.blogspot.ru/2011/05/why-eager-languages-dont-have-products.html">post by</a> James Airy explains why I don‚Äôt show the case of the matching works / conjunctions).  Now let's think about what corresponds to the function with the following signature: <br><pre> <code class="scala hljs"><span class="hljs-type"><span class="hljs-type">A</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">Nothing</span></span></code> </pre><br>  On the right logical side of the Curry-Howard isomorphism, this signature is mapped to the formula <code>A ‚áí false</code> , which is equivalent to <code>¬¨A</code> .  This seems quite intuitively reasonable - there are no <code>Nothing</code> values, therefore the <code>A =&gt; Nothing</code> signature cannot be implemented (except by throwing an exception, but in our case it is not allowed). <br><br>  Now let's see what happens if we use this signature as our type negation representation, <br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">¬¨</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">A</span></span></span><span class="hljs-class">] </span></span>= <span class="hljs-type"><span class="hljs-type">A</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">Nothing</span></span></code> </pre><br>  and apply it in the context of the laws of De Morgan to get the type of association: <br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">‚à®</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">U</span></span></span><span class="hljs-class">] </span></span>= ¬¨[¬¨[<span class="hljs-type"><span class="hljs-type">T</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> ¬¨[<span class="hljs-type"><span class="hljs-type">U</span></span>]]</code> </pre><br>  Now we can check our type using the Scala REPL: <br><pre> <code class="scala hljs">scala&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">¬¨</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">A</span></span></span><span class="hljs-class">] </span></span>= <span class="hljs-type"><span class="hljs-type">A</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">Nothing</span></span> defined <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">alias</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">$u00AC</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">scala&gt;</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">‚à®</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">U</span></span></span><span class="hljs-class">] </span></span>= ¬¨[¬¨[<span class="hljs-type"><span class="hljs-type">T</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> ¬¨[<span class="hljs-type"><span class="hljs-type">U</span></span>]] defined <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">alias</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">$u2228</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">scala&gt;</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">implicitly</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Int</span></span></span><span class="hljs-class"> &lt;:&lt; (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Int</span></span></span><span class="hljs-class"> ‚à® </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class">)] </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">&lt;console&gt;</span></span></span></span>:<span class="hljs-number"><span class="hljs-number">11</span></span>: error: <span class="hljs-type"><span class="hljs-type">Cannot</span></span> prove that <span class="hljs-type"><span class="hljs-type">Int</span></span> &lt;:&lt; ((<span class="hljs-type"><span class="hljs-type">Int</span></span>) =&gt; <span class="hljs-type"><span class="hljs-type">Nothing</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> (<span class="hljs-type"><span class="hljs-type">String</span></span>) =&gt; <span class="hljs-type"><span class="hljs-type">Nothing</span></span>) =&gt; <span class="hljs-type"><span class="hljs-type">Nothing</span></span>. implicitly[<span class="hljs-type"><span class="hljs-type">Int</span></span> &lt;:&lt; (<span class="hljs-type"><span class="hljs-type">Int</span></span> ‚à® <span class="hljs-type"><span class="hljs-type">String</span></span>)]</code> </pre><br>  The REPL shows us that the decision has not yet been fully received.  The <code>implicitly[Int &lt;:&lt; (Int ‚à® String)]</code> expression <code>implicitly[Int &lt;:&lt; (Int ‚à® String)]</code> asks the compiler if it can prove that <code>Int</code> is a subtype of <code>Int ‚à® String</code> , which should be true for the type of union. <br><br>  What went wrong?  The problem is that we converted the types on the right side of the operator <code>&lt;:&lt;</code> into function types to use the type negation given as <code>A =&gt; Nothing</code> .  This means that the type of union itself is a type of function.  But this is obviously not consistent with the fact that <code>Int</code> a subtype of a union type, which is shown by the error message from the REPL.  To eliminate the error, we must also convert the left part of the operator <code>&lt;:&lt;</code> to a type that would be a subtype of the type on the right side. <br><br>  What could be this transformation?  How about double denial? <br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">¬¨¬¨</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">A</span></span></span><span class="hljs-class">] </span></span>= ¬¨[¬¨[<span class="hljs-type"><span class="hljs-type">A</span></span>]]</code> </pre><br>  Let's see what the compiler will say to this: <br><pre> <code class="scala hljs">scala&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">¬¨¬¨</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">A</span></span></span><span class="hljs-class">] </span></span>= ¬¨[¬¨[<span class="hljs-type"><span class="hljs-type">A</span></span>]] defined <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">alias</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">$u00AC$u00AC</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">scala&gt;</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">implicitly</span></span></span><span class="hljs-class">[¬¨¬¨[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Int</span></span></span><span class="hljs-class">] </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">&lt;</span></span></span></span>:&lt; (<span class="hljs-type"><span class="hljs-type">Int</span></span> ‚à® <span class="hljs-type"><span class="hljs-type">String</span></span>)] res5: &lt;:&lt;[((<span class="hljs-type"><span class="hljs-type">Int</span></span>) =&gt; <span class="hljs-type"><span class="hljs-type">Nothing</span></span>) =&gt; <span class="hljs-type"><span class="hljs-type">Nothing</span></span>, ((<span class="hljs-type"><span class="hljs-type">Int</span></span>) =&gt; <span class="hljs-type"><span class="hljs-type">Nothing</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> (<span class="hljs-type"><span class="hljs-type">String</span></span>) =&gt; <span class="hljs-type"><span class="hljs-type">Nothing</span></span>) =&gt; <span class="hljs-type"><span class="hljs-type">Nothing</span></span>] = &lt;function1&gt; scala&gt; implicitly[¬¨¬¨[<span class="hljs-type"><span class="hljs-type">String</span></span>] &lt;:&lt; (<span class="hljs-type"><span class="hljs-type">Int</span></span> ‚à® <span class="hljs-type"><span class="hljs-type">String</span></span>)] res6: &lt;:&lt;[((<span class="hljs-type"><span class="hljs-type">String</span></span>) =&gt; <span class="hljs-type"><span class="hljs-type">Nothing</span></span>) =&gt; <span class="hljs-type"><span class="hljs-type">Nothing</span></span>, ((<span class="hljs-type"><span class="hljs-type">Int</span></span>) =&gt; <span class="hljs-type"><span class="hljs-type">Nothing</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> (<span class="hljs-type"><span class="hljs-type">String</span></span>) =&gt; <span class="hljs-type"><span class="hljs-type">Nothing</span></span>) =&gt; <span class="hljs-type"><span class="hljs-type">Nothing</span></span>] = &lt;function1&gt;</code> </pre><br>  Bingo!  Both <code>¬¨¬¨[Int]</code> and <code>¬¨¬¨[String]</code> are subtypes of <code>Int ‚à® String</code> ! <br><br>  Now we need to check that we do not just return a positive response every time: <br><pre> <code class="scala hljs">scala&gt; implicitly[¬¨¬¨[<span class="hljs-type"><span class="hljs-type">Double</span></span>] &lt;:&lt; (<span class="hljs-type"><span class="hljs-type">Int</span></span> ‚à® <span class="hljs-type"><span class="hljs-type">String</span></span>)] &lt;console&gt;:<span class="hljs-number"><span class="hljs-number">12</span></span>: error: <span class="hljs-type"><span class="hljs-type">Cannot</span></span> prove that ((<span class="hljs-type"><span class="hljs-type">Double</span></span>) =&gt; <span class="hljs-type"><span class="hljs-type">Nothing</span></span>) =&gt; <span class="hljs-type"><span class="hljs-type">Nothing</span></span> &lt;:&lt; ((<span class="hljs-type"><span class="hljs-type">Int</span></span>) =&gt; <span class="hljs-type"><span class="hljs-type">Nothing</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> (<span class="hljs-type"><span class="hljs-type">String</span></span>) =&gt; <span class="hljs-type"><span class="hljs-type">Nothing</span></span>) =&gt; <span class="hljs-type"><span class="hljs-type">Nothing</span></span>.</code> </pre><br>  So, we are almost finished, it remains to put the final touches.  The relationship of the subtypes that we have is isomorphic to what we want to get (since the type <code>¬¨¬¨[T]</code> is isomorphic to <code>T</code> ).  But so far we have no way to express the same relations with non-transformed types, which is exactly what we need. <br><br>  We can solve this problem by counting <code>¬¨[T]</code> , <code>¬¨¬¨[T]</code> and <code>T ‚à® U</code> phantom types and using them only to represent the required subtype relationships, rather than working directly with the values ‚Äã‚Äãof these types.  Here‚Äôs how it happens in our test case: <br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">size</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">T</span></span>](t: <span class="hljs-type"><span class="hljs-type">T</span></span>)(<span class="hljs-keyword"><span class="hljs-keyword">implicit</span></span> ev: (¬¨¬¨[<span class="hljs-type"><span class="hljs-type">T</span></span>] &lt;:&lt; (<span class="hljs-type"><span class="hljs-type">Int</span></span> ‚à® <span class="hljs-type"><span class="hljs-type">String</span></span>))) = t <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> i: <span class="hljs-type"><span class="hljs-type">Int</span></span> =&gt; i <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> s: <span class="hljs-type"><span class="hljs-type">String</span></span> =&gt; s.length }</code> </pre><br>  It uses a generic type constraint that requires the compiler to prove that any <code>T</code> outputted as a type argument to the <code>size</code> method satisfies that its double negation is a subtype of <code>Int ‚à® String</code> .  As the next REPL session shows, this condition is fulfilled only if <code>T</code> is an <code>Int</code> or <code>String</code> : <br><pre> <code class="scala hljs">scala&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">size</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">T</span></span>](t: <span class="hljs-type"><span class="hljs-type">T</span></span>)(<span class="hljs-keyword"><span class="hljs-keyword">implicit</span></span> ev: (¬¨¬¨[<span class="hljs-type"><span class="hljs-type">T</span></span>] &lt;:&lt; (<span class="hljs-type"><span class="hljs-type">Int</span></span> ‚à® <span class="hljs-type"><span class="hljs-type">String</span></span>))) = | t <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> { | <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> i: <span class="hljs-type"><span class="hljs-type">Int</span></span> =&gt; i | <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> s: <span class="hljs-type"><span class="hljs-type">String</span></span> =&gt; s.length | } size: [<span class="hljs-type"><span class="hljs-type">T</span></span>](t: <span class="hljs-type"><span class="hljs-type">T</span></span>)(<span class="hljs-keyword"><span class="hljs-keyword">implicit</span></span> ev: &lt;:&lt;[((<span class="hljs-type"><span class="hljs-type">T</span></span>) =&gt; <span class="hljs-type"><span class="hljs-type">Nothing</span></span>) =&gt; <span class="hljs-type"><span class="hljs-type">Nothing</span></span>, ((<span class="hljs-type"><span class="hljs-type">Int</span></span>) =&gt; <span class="hljs-type"><span class="hljs-type">Nothing</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> (<span class="hljs-type"><span class="hljs-type">String</span></span>) =&gt; <span class="hljs-type"><span class="hljs-type">Nothing</span></span>) =&gt; <span class="hljs-type"><span class="hljs-type">Nothing</span></span>])<span class="hljs-type"><span class="hljs-type">Int</span></span> scala&gt; size(<span class="hljs-number"><span class="hljs-number">23</span></span>) res8: <span class="hljs-type"><span class="hljs-type">Int</span></span> = <span class="hljs-number"><span class="hljs-number">23</span></span> scala&gt; size(<span class="hljs-string"><span class="hljs-string">"foo"</span></span>) res9: <span class="hljs-type"><span class="hljs-type">Int</span></span> = <span class="hljs-number"><span class="hljs-number">3</span></span> scala&gt; size(<span class="hljs-number"><span class="hljs-number">1.0</span></span>) &lt;console&gt;:<span class="hljs-number"><span class="hljs-number">13</span></span>: error: <span class="hljs-type"><span class="hljs-type">Cannot</span></span> prove that ((<span class="hljs-type"><span class="hljs-type">Double</span></span>) =&gt; <span class="hljs-type"><span class="hljs-type">Nothing</span></span>) =&gt; <span class="hljs-type"><span class="hljs-type">Nothing</span></span> &lt;:&lt; ((<span class="hljs-type"><span class="hljs-type">Int</span></span>) =&gt; <span class="hljs-type"><span class="hljs-type">Nothing</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> (<span class="hljs-type"><span class="hljs-type">String</span></span>) =&gt; <span class="hljs-type"><span class="hljs-type">Nothing</span></span>) =&gt; <span class="hljs-type"><span class="hljs-type">Nothing</span></span>.</code> </pre><br>  And now the last trick.  From the point of view of the syntax, the implicit parameter of the proof looks ugly and heavy, but we can fix it by transforming it into a context constraint of a parameter of type <code>T</code> : <br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">|‚à®|</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">U</span></span></span><span class="hljs-class">] </span></span>= { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Œª</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">X</span></span></span><span class="hljs-class">] </span></span>= ¬¨¬¨[<span class="hljs-type"><span class="hljs-type">X</span></span>] &lt;:&lt; (<span class="hljs-type"><span class="hljs-type">T</span></span> ‚à® <span class="hljs-type"><span class="hljs-type">U</span></span>) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">size</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">T</span></span>: (<span class="hljs-type"><span class="hljs-type">Int</span></span> |‚à®| <span class="hljs-type"><span class="hljs-type">String</span></span>)#Œª](t: <span class="hljs-type"><span class="hljs-type">T</span></span>) = t <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> i: <span class="hljs-type"><span class="hljs-type">Int</span></span> =&gt; i <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> s: <span class="hljs-type"><span class="hljs-type">String</span></span> =&gt; s.length }</code> </pre><br>  Done!  We got an unpacked, statically type-safe representation of Scala union types, without modifying the language itself! <br><br>  Naturally it would be better if Scala supported union types as primitives.  But at least the solution we got demonstrates that the Scala compiler has all the necessary information to do this.  It now remains to pester Martin and Adriaan to make the types of unions accessible directly. </div><p>Source: <a href="https://habr.com/ru/post/269907/">https://habr.com/ru/post/269907/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../269897/index.html">Automatic generation of microcontroller software code based on event-oriented model</a></li>
<li><a href="../269899/index.html">Lua 5.3 Reference Guide</a></li>
<li><a href="../269901/index.html">Pitfalls Entity Framework and Performance</a></li>
<li><a href="../269903/index.html">Create a REST service on Rust. Part 5: Handlers, Refactoring, and Macros</a></li>
<li><a href="../269905/index.html">How we lost and again found millions without testing A / B</a></li>
<li><a href="../269909/index.html">Errors are values</a></li>
<li><a href="../269915/index.html">Divide means multiply</a></li>
<li><a href="../269917/index.html">A library that helps bridge the conceptual gap between OOP and DB during testing using ORM - LinqTestable</a></li>
<li><a href="../269919/index.html">The digest of interesting materials for the mobile developer # 127 (October 26 - November 1)</a></li>
<li><a href="../269923/index.html">Immersion cooling reaches new heights: 250 kW per bitFury rack</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>