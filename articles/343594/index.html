<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>LLVM testing</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Continued. Start here . 

 Introduction 
 When a program reaches a certain size, it can be guaranteed that it is poorly specified and cannot be fully ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>LLVM testing</h1><div class="post__text post__text-html js-mediator-article">  Continued.  Start <a href="https://habrahabr.ru/post/343344/">here</a> . <br><br><h3>  Introduction </h3><br>  When a program reaches a certain size, it can be guaranteed that it is poorly specified and cannot be fully understood by one person.  This is confirmed many times a day by people who are poorly aware of each other‚Äôs work.  The program has many dependencies, including the compiler, the operating system, libraries, each of which contains its own bugs, and all this is updated from time to time.  Moreover, the software should usually work on several different platforms, each of which has its own characteristics.  Given the large number of opportunities for misbehavior, why at all can we expect our large program to work as expected?  One of the most important things is testing.  Thus, we can make sure that the software works as it should in any configuration and platform that is important for us, and when it does not work, there will be smart people who can trace and fix the problem. <br><a name="habracut"></a><br>  Today we will discuss testing LLVM.  In many ways, the compiler is a good test object. <br><br><ul><li>  Input format (source code) and output format (assembly code) are well understood and have independent specifications. </li><li>  Many compilers have an intermediate representation (IR), which is documented in itself and can be displayed and parsed, which makes it easier (although not always) internal testing. </li><li>  Often the compiler is one of the independent implementations of the specification, such as the C ++ standard, which allows for differential testing.  Even if many implementations are not available, we can often test the compiler by comparing with ourselves, comparing the output of various backends or various optimization modes. </li><li>  Compilers usually do not have network functions, concurrency, time dependencies, and always interact with the outside world in a very limited way.  Moreover, compilers are usually deterministic. </li><li>  Compilers usually do not work for a long time, and we do not need to worry about resource leaks and recovery after errors occur. </li></ul><br>  But on the other hand, compilers are not so easy to test: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  Compilers must be fast, and they are often written in an unsafe language, and have not enough asserts.  They use caching and lazy calculations when possible, which increases their complexity.  Moreover, the separation of compiler functions into many clear, independent small passes slows down the compiler, and tends to combine unrelated or loosely coupled functions, making the compiler more difficult to understand, test, and support. </li><li>  Invariants of the internal data structures of the compiler can be completely hellish and not fully documented. </li><li>  Some compilation algorithms are complex, and almost never the compiler implements textbook algorithms exactly, but with more or less differences. </li><li>  Compiler optimizations interact in a complex way. </li><li>  Compilers of unsafe languages ‚Äã‚Äãdo not have any obligations when compiling unspecified behavior, shifting responsibility for the absence of UB outside the compiler limits (and to the person who writes the tests for the compiler).  This complicates differential testing. </li><li>  Standards for correctness of compilers are very high, because a program that is incorrectly compiled is difficult to debug, and the compiler can quietly add vulnerabilities to any compiled code. </li></ul><br>  So, knowing these basic things, consider how LLVM is tested. <br><br><h3>  Modular and Regression Tests </h3><br>  The first line of defense of LLVM against bugs is a test suite that runs when a developer builds a ‚Äúcheck‚Äù target.  All of these tests must be completed before the developer commits the patch to LLVM (and, of course, many patches may include new tests).  On my fairly fast desktop, 19,267 tests pass in 96 seconds.  The number of tests that are run depends on which additional LLVM projects you have downloaded (compiler-rt, libcxx, etc.) and, to a lesser extent, on software that is automatically detected on your machine (i.e. bundles with OCaml will not be tested until OCaml is installed).  These tests should be quick, and developers can run them often, as mentioned <a href="http://llvm.org/docs/DeveloperPolicy.html">here</a> .  Additional tests are run when building targets such as check-all and check-clang. <br><br>  Some modular and regression tests work at the API level, they use <a href="https://github.com/google/googletest">Google Test</a> , a lightweight framework that provides C ++ macros to connect a test framework.  Here is an example test: <br><br><pre><code class="cpp hljs">TEST_F(MatchSelectPatternTest, FMinConstantZero) { parseAssembly( <span class="hljs-string"><span class="hljs-string">"define float @test(float %a) {\n"</span></span> <span class="hljs-string"><span class="hljs-string">" %1 = fcmp ole float %a, 0.0\n"</span></span> <span class="hljs-string"><span class="hljs-string">" %A = select i1 %1, float %a, float 0.0\n"</span></span> <span class="hljs-string"><span class="hljs-string">" ret float %A\n"</span></span> <span class="hljs-string"><span class="hljs-string">"}\n"</span></span>); <span class="hljs-comment"><span class="hljs-comment">// This shouldn't be matched, as %a could be -0.0. expectPattern({SPF_UNKNOWN, SPNB_NA, false}); }</span></span></code> </pre> <br>  The first argument of the macro TEST_F indicates the name of the collection of tests, and the second is the name of the specific test.  The methods parseAssembly () and expectPattern () call the LLVM API and check the result.  This example is taken from <a href="">ValueTrackingTest.cpp</a> .  A single file can contain many tests, speeding up the passage of tests due to the absence of fork / exec. <br><br>  Another infrastructure used by the LLVM quick test suite is <a href="http://llvm.org/docs/CommandGuide/lit.html">lit</a> , LLVM Integrated Tester.  lit is based on the shell, it executes the test commands, and concludes that the test passed successfully if all the commands completed successfully. <br><br>  Here is an example of a test for lit (I took it from the beginning of <a href="">this file</a> , which contains additional tests that do not matter now): <br><br><pre> <code class="cpp hljs">; RUN: opt &lt; %s -instcombine -S | FileCheck %s define i64 @test1(i64 %A, i32 %B) { %tmp12 = zext i32 %B to i64 %tmp3 = shl i64 %tmp12, <span class="hljs-number"><span class="hljs-number">32</span></span> %tmp5 = add i64 %tmp3, %A %tmp6 = <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> i64 %tmp5, <span class="hljs-number"><span class="hljs-number">123</span></span> ret i64 %tmp6 ; CHECK-LABEL: @test1( ; CHECK-NEXT: <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> i64 %A, <span class="hljs-number"><span class="hljs-number">123</span></span> ; CHECK-NEXT: ret i64 }</code> </pre> <br>  This test verifies that InstCombine, the passage of the peephole-optimization of the intermediate code level, can notice useless instructions: zext, shl and add are not needed here.  The CHECK-LABEL line finds the line from which the optimized code function starts, the first CHECK-NEXT checks that the instruction goes further and, the second CHECK-NEXT checks that the ret instruction goes further (thanks to Michael Kuperstein for a correct and timely explanation of this test). <br><br>  To run tests, the file is interpreted three times.  First, it is scanned, and it searches for lines that contain ‚ÄúRUN:‚Äù, and all relevant commands are executed.  Further, the file is interpreted by the opt utility, the LLVM IR optimizer, this happens because  lit replaced the% s variables with the name of the file being processed.  Since comments in the text LLVM IR begin with a semicolon, the lit directives are ignored by the optimizer.  The optimizer output is <a href="http://llvm.org/docs/CommandGuide/FileCheck.html">sent to FileCheck</a> utility, which parses the file again, searches for commands, such as CHECK and CHECK-NEXT, they force the utility to search for the string in its stdin, and return a non-zero exit code if any given string is not found (CHECK-LABEL is used to separate a file into a set of logically separate tests). <br><br>  An important strategic task of testing is to use coverage analysis tools to find parts of the code base that is not covered by tests.  <a href="http://llvm.org/reports/coverage/">Here</a> is a recent LLVM coverage report based on the launch of modular / regression tests.  This data is interesting enough to study them in more detail.  Let's take a look at the InstCombine coverage, which is generally very good ( <i><a href="http://llvm.org/reports/coverage/lib/Transforms/InstCombine/index.html">link</a> unavailable, unfortunately. Approx. Trans</i> .).  An interesting project for someone who wants to start working with LLVM is writing tests to cover non-tested parts of InstCombine.  For example, here's the first uncovered test code (highlighted in red) in InstCombineAndOrXor.cpp: <br><br><img src="https://habrastorage.org/webt/gp/4o/cs/gp4ocswp5y3epdxqskb-64jviy0.png"><br><br>  The comment tells us that it is looking for a conversion pass, and it should be fairly easy to write a test for this code.  Code that cannot be tested is dead, sometimes dead code should be deleted, in other cases, as in this example (from the same file), the code will not be dead only if a bug appears: <br><br><img src="https://habrastorage.org/webt/b2/nk/ke/b2nkke21kkloiqfo19o3carjj4c.png"><br><br>  Attempting to cover these lines is a good idea, but in this case you are trying to find a bug in LLVM, and not just improve the test suite.  It might be a good idea to teach the cover analysis tool not to tell us about strings marked as unreachable. <br><br><h3>  LLVM test suite </h3><br>  In contrast to regression / unit tests that are part of the LLVM repository and can be run quickly, the <a href="https://github.com/llvm-mirror/test-suite/">test suite</a> is external and takes more time.  It is not expected that developers will run these tests before a commit, however these tests are run automatically and often with LNT (see the next section).  The LLVM test suite contains entire programs that are compiled and run; this is not intended for any specific optimizations, but to confirm the quality and correctness of the generated code as a whole. <br><br>  For each benchmark, the test suite contains test input and the corresponding expected output.  Some parts of the test suite are external, meaning that there is support for invoking these tests, but the tests themselves are not part of the test suite and must be downloaded separately, usually due to non-free software being used. <br><br><h3>  Lnt </h3><br>  LNT (LLVM Nightly Test) does not contain any tests; it is a tool for aggregating and analyzing test results, focused on monitoring the quality of the code generated by the compiler.  Contains local utilities for running tests and validating results, as well as a server database and web frontend that makes it easy to view the results.  NTS results (Nightly Test Suite) are <a href="https://lnt.llvm.org/db_default/v4/nts/recent_activity">here</a> . <br><br><h3>  Buildbot </h3><br>  Linux / Windows BuiltBot and Darwin BuiltBot (I don‚Äôt know why there are two) are used to make sure that LLVM is configured, built, and passes modular / regression tests on a large number of different platforms and in various configurations.  BuildBot has the support of the blame team in order to find the problem commit and send a letter to its author. <br><br><h3>  Eclectic Testing Effort </h3><br>  Some testing efforts are undertaken outside the core of the LLVM community and are not systematic in terms of which version of LLVM is being tested.  These tests appeared thanks to the efforts of individual developers who wanted to try some special tool or technique.  For example, for a long time, my group tested Clang + LLVM using <a href="https://github.com/csmith-project/csmith">Csmith</a> and reported errors found (see the <a href="http://www.cs.utah.edu/~regehr/papers/pldi11-preprint.pdf">high-level description</a> ).  Sam Liedes <a href="http://lists.llvm.org/pipermail/llvm-dev/2014-December/079390.html">used afl-fuzz</a> to test Clang.  <a href="http://web.cs.ucdavis.edu/~su/emi-project/">Zhendong Su and his group</a> found a very impressive number of bugs.  <a href="http://web.ist.utl.pt/nuno.lopes/">Nuno Lopes</a> did an awesome test-based optimization test based on formal methods that I hope to write about in a short time. <br><br><h3>  Testing in the wild </h3><br>  The last level of testing, of course, is done by LLVM users, who sometimes cause crashes and improper compilations that other test methods have missed.  I often wanted to better understand the occurrence of compiler bugs.  The reasons for the incorrect compilation of a custom code can be difficult to identify, since it is difficult to reduce the code so as to identify the cause of the bug.  However, people use pseudo-random changes in the code during the debag process, cope with the problem due to randomness and soon forget about it. <br><br>  A great innovation would be the implementation of a translation validation scheme in LLVM that would use an SMT-solver to prove that the compiler output corresponds to the input.  There are many problems here, including unspecified behavior, and the fact that it is difficult to scale validation to large functions, which, in practice, cause compilation errors. <br><br><h3>  Alternate test oracles </h3><br>  A "test oracle" is a way to determine if a test has passed or not.  Simple oracles include checks like "compiler ended with code 0" or "compiled benchmark gave the expected output."  But so many interesting bugs will be missed, such as ‚Äúuse after release‚Äù, which did not cause the program to crash or overflow the whole (see p.7 of <a href="http://www.cs.utah.edu/~regehr/papers/overflow12.pdf">this article</a> with an example for GCC).  Bug detectors such as ASan, UBSan, and Valgrind can equip the program with oracles derived from the C and C ++ standards, giving many useful features for finding bugs.  To run LLVM under Valgrind with test case execution, pass -DLLVM_LIT_ARGS = "- v --vg" in CMake, but be prepared for the fact that Valgrind gives false positives that are difficult to eliminate.  To test LLVM with UBSan, pass DLLVM_USE_SANITIZER = Undefined to CMake.  This is great, but a lot of work is needed, as UBSan / ASan / MSan does not catch all instances of undefined behavior and also certain, but incorrect behavior, such as the overflow of an unsigned integer in GCC in the example above. <br><br><h3>  What happens if the test fails? </h3><br>  A broken commit can cause a drop in the test at any level.  Such a commit is either repaired (if it is not difficult), or rejected, if it has deep flaws or is undesirable in the light of new information provided by the fallen test.  This happens often to protect against frequent changes to a large and complex code base with many real users. <br><br>  When a test fails, and the problem is difficult to fix immediately, but it can be fixed, for example, when new features are completed, the test can be labeled XFAIL, or ‚Äúexpected failure‚Äù.  Such tests are taken into account by the testing tools separately, and do not fall into the total score of dropped tests, which must be fixed before the patch is accepted. <br><br><h3>  Conclusion </h3><br>  Testing a large, portable, widely used software system is a difficult task that involves a lot of work if we want to save LLVM users from bugs.  Of course, there are other very important things that are needed to preserve the high quality of the code: good design, code review, intermediate presentation semantics, static analysis, periodic reworking of problem areas. </div><p>Source: <a href="https://habr.com/ru/post/343594/">https://habr.com/ru/post/343594/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../343584/index.html">Telegram conference bot (Continued)</a></li>
<li><a href="../343586/index.html">How do you become professionals at ITMO University: Olympiad "I am a professional", the track "Photonics"</a></li>
<li><a href="../343588/index.html">Who in medicine ISPDN in accordance with the law, he does not laugh in a circus</a></li>
<li><a href="../343590/index.html">AlphaGo Zero completely on the fingers</a></li>
<li><a href="../343592/index.html">How we implemented DevOps: testing a production environment with Azure Web App</a></li>
<li><a href="../343596/index.html">Multi-channel attribution through Calltouch</a></li>
<li><a href="../343598/index.html">Why did I buy a Mac Mini (Late 2012) on the eve of 2018?</a></li>
<li><a href="../343600/index.html">Who and how much to keep pace with progress?</a></li>
<li><a href="../343604/index.html">We teach the machine to understand the human genes</a></li>
<li><a href="../343610/index.html">PHP 7.2.0 released</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>