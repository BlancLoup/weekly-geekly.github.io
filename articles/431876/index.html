<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Angular Application Optimization</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Angular is the most popular framework for developing single-page web applications, although this does not mean that Angular applications can contain o...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Angular Application Optimization</h1><div class="post__text post__text-html js-mediator-article">  Angular is the most popular framework for developing single-page web applications, although this does not mean that Angular applications can contain only one page.  With this framework, you can create sites consisting of dozens of pages.  The latest version of Angular, thanks to the efforts of the development team and the community of enthusiasts, is well optimized.  However, when it comes to a specific application, we must not forget about some things that affect its performance. <br><br> <a href="https://habr.com/company/ruvds/blog/431876/"><img src="https://habrastorage.org/webt/xj/pq/aj/xjpqajkqroo6_ovnkv7s5-iczig.png"></a> <br><br>  In the material, the translation of which we publish today, six directions of optimization of Angular-applications will be revealed. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">1. Lazy loading and optimization of the main bundle</font> </h2><br>  If the lazy loading is not used when preparing the production version of the application, then you will most likely see the following files in the <code>dist</code> folder. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="javascript hljs">polyfills.js scripts.js runtime.js styles.css main.js</code> </pre> <br>  The <code>polyfills.js</code> file allows <code>polyfills.js</code> to ensure the compatibility of an application written using the latest features of web technologies with various browsers. <br><br>  The <code>script.js</code> file contains the scripts described in the <code>scripts</code> section of the <code>angular.json</code> file.  Here is a simple example of such a section. <br><br><pre> <code class="javascript hljs"><span class="hljs-string"><span class="hljs-string">"scripts"</span></span>: [  <span class="hljs-string"><span class="hljs-string">"myScript.js"</span></span>, ]</code> </pre> <br>  The <code>runtime.js</code> file is a Webpack loader.  It contains the Webpack tools needed to download other files. <br><br>  The <code>styles.css</code> file contains styles declared in the <code>styles</code> section of the <code>angular.json</code> file.  Here is an example of this section. <br><br><pre> <code class="javascript hljs"><span class="hljs-string"><span class="hljs-string">"styles"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"src/styles.css"</span></span>, <span class="hljs-string"><span class="hljs-string">"src/my-custom.css"</span></span> ],</code> </pre> <br>  The <code>main.js</code> file stores all application code, including components (TS, HTML and CSS code), pipelines, directives, services, and imported modules (including third-party modules). <br><br>  As the application grows and <code>main.j</code> size of the <code>main.j</code> s file also <code>main.j</code> .  This can turn into a problem, because, in order to form a page, the browser, besides solving other data visualization tasks, needs to load and parse the <code>main.js</code> file.  If this file is large enough, its processing will be a difficult task not only for mobile, but also for desktop browsers. <br><br>  The easiest way to solve this problem is by dividing the application into several modules, with which the lazy loading technique is used.  With this approach, Angular generates a separate file for each module, which will not be loaded until it becomes necessary (usually, when a certain route is activated). <br><br>  In order to demonstrate the use of lazy loading techniques, two components were created - <code>app.component</code> and <code>second.component</code> .  Both of them are in the <code>app.module</code> module, lazy loading does not apply when working with them. <br><br>  The <code>app.component</code> component <code>app.component</code> extremely simple.  It displays two buttons, one of which is responsible for the transition to the <code>second.component</code> , and the second leads back to the <code>app.component</code> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/38f/ba1/6b9/38fba16b9ab19b462ac0e46a4c0d8aca.png"></div><br>  <i><font color="#999999">Component App</font></i> <br><br>  The <code>Second</code> component template contains a very large fragment of text with a volume of approximately 1 MB. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/020/de1/426/020de14260117543f978d87c9a89c23a.png"></div><br>  <i><font color="#999999">Second component</font></i> <br><br>  Since the lazy loading technique does not apply here, our application will have a large-sized <code>main.js</code> file containing the <code>app.component</code> and <code>second.component</code> . <br><br>  If you open the Chrome developer tools and look at the Network tab, you can estimate the size of the <code>main.js</code> file.  Namely, it is 1.3 MB. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0b2/bab/c5b/0b2babc5be0ab47b9254c1d8af87c8de.png"></div><br>  <i><font color="#999999">File Size Analysis with Chrome Developer Tools</font></i> <br><br>  The problem here is that most of the time when working with our project, the user will be on his main page, and not on some other one, so downloading all the code as a single file is not the best idea.  The code of the second component can be transferred to a separate module, which will be loaded only if the user navigates to the appropriate page.  This is reflected in a significant decrease in the <code>main.js</code> file, which gives a very quick first load of the main page of the site. <br><br>  When using the lazy loading technique, after the project build process is completed, a file like <code>4.386205799sfghe4.js</code> will be created.  This is where the code that does not load when the site first loads will be stored.  As a result, if you now open the site and analyze it, it turns out that the size of <code>main.js</code> is only 266 KB. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/721/d89/f54/721d89f544d30d37693de7d9cc190399.png"></div><br>  <i><font color="#999999">Reducing the size of main.js</font></i> <br><br>  A large additional file of 1 MB in size is loaded only after moving to the appropriate page. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b58/8ec/6cb/b588ec6cb1c63fb67623b561fde85860.png"></div><br>  <i><font color="#999999">Download additional file</font></i> <br><br>  We applied the lazy download, but we cannot say that this solution suits us completely.  The fact is that such an approach slows down the user's first transition to the page, for output of which a separate large file is needed.  Fortunately, Angular provides a means to solve this problem.  Namely, we are talking about technology <a href="https://angular.io/api/router/PreloadingStrategy">PreloadingStrategy</a> . <br><br>  Using it, we can tell the framework that, after the main module ( <code>main.js</code> file) has been loaded and processed, it would load, in the background, other modules.  As a result, when the user navigates to a page that previously needed to download a large file, it turns out that this file has already been downloaded.  Here is a sample code to preload all modules. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { PreloadAllModules, RouterModule } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@angular/router'</span></span>; RouterModule.forRoot( [ {   <span class="hljs-attr"><span class="hljs-attr">path</span></span>: <span class="hljs-string"><span class="hljs-string">'second'</span></span>,   <span class="hljs-attr"><span class="hljs-attr">loadChildren</span></span>: <span class="hljs-string"><span class="hljs-string">'./second/second.module#SecondModule'</span></span> } ], {<span class="hljs-attr"><span class="hljs-attr">preloadingStrategy</span></span>: PreloadAllModules})</code> </pre> <br>  When applying lazy loading when optimizing Angular applications, it is recommended to strive to break the project into as many modules as possible.  In addition, you need to pay attention to their preloading.  This will allow the <code>main.js</code> file to be small in size, which means faster loading and displaying of the project‚Äôs main page. <br><br><h2>  <font color="#3AC1EF">2. Analysis of bundles using Webpack Bundle Analyzer</font> </h2><br>  If even after dividing the project logic into multiple modules, it turns out that <code>main.js</code> is still too large (for small and medium-sized applications, the author of this material suggests to consider a large 1 MB file), you can continue to optimize the application using the Webpack Bundle Analyzer.  This npm package allows you to visualize the results of the Webpack work in the form of a tree structure that supports zooming the view.  In order to use the Webpack Bundle Analyzer, we will install it in the Angular project as a development dependency. <br><br><pre> <code class="javascript hljs">npm install --save-dev webpack-bundle-analyzer</code> </pre> <br>  Then we modify the <code>script</code> section of the <code>package.json</code> file, adding the following text to it. <br><br><pre> <code class="javascript hljs"><span class="hljs-string"><span class="hljs-string">"bundle-report"</span></span>: <span class="hljs-string"><span class="hljs-string">"ng build --prod --stats-json &amp;&amp; webpack-bundle-analyzer dist/stats.json"</span></span></code> </pre> <br>  Please note that the address of the <code>dist/stats.json</code> may be different in your project.  For example, if you have ready bundle files in the <code>dist/browser</code> folder, you will need to rewrite the above line like this: <code>dist/browser/stats.json</code> . <br><br>  Now run the analyzer. <br><br><pre> <code class="javascript hljs">npm run bundle-report</code> </pre> <br>  After executing this command, the production assembly of the application will be generated and the statistics for each bundle will be displayed.  Here is the result of the visualization of this data. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/198/4d2/5b1/1984d25b162761a21041333e2350bd00.png"></div><br>  <i><font color="#999999">Project analysis using Webpack Bundle Analyzer</font></i> <br><br>  Now you can analyze the composition of each bundle.  This is a very useful tool that allows you to identify dependencies, without which you can do. <br><br><h2>  <font color="#3AC1EF">3. Create several small modules for sharing</font> </h2><br>  Modules that share different parts of an application contribute to the implementation of the <a href="https://en.wikipedia.org/wiki/Don%2527t_repeat_yourself">DRY</a> principle, but sometimes even such modules, as the application develops, become more and more.  For example, if we have a certain <code>SharedModule</code> module containing many other modules, components, pipelines, importing such a module into <code>app.module</code> will increase the size of the <code>main.js</code> bundle, since such a move will not only lead to the import of what <code>main.js</code> needs, but also all that is in the <code>SharedModule</code> .  In order to avoid this situation, you can create another module, something like <code>HomeSharedModule</code> , designed to be shared by the main module and its components. <br><br>  The presence in the project of several modules intended for sharing is better than the presence of only one such module, usually having large dimensions. <br><br><h2>  <font color="#3AC1EF">4. Using lazy loading for images that are not visible on the page.</font> </h2><br>  When you first load the main page of the application, it may be that there are images on it that are not visible to the user (they are outside the viewing area).  In order to see them, you need to scroll the page.  But these invisible images are loaded when the page loads.  If there are a lot of them, it will affect the page loading speed.  In order to cope with this problem, you can apply a lazy loading technique to images, loading them only when the user gets to them.  There is one useful JS tool, <a href="https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API">Intersection Observer</a> , which makes it easy to implement lazy loading of images.  Moreover, in order to reuse, on the basis of it you can create an appropriate directive.  Details about this can be found <a href="https://blog.angularindepth.com/a-modern-solution-to-lazy-loading-using-intersection-observer-9280c149bbc">here</a> . <br><br><h2>  <font color="#3AC1EF">5. Using virtual scrolling for long lists</font> </h2><br>  In the seventh version of Angular there is the possibility of using <a href="https://material.angular.io/cdk/scrolling/overview">virtual scrolling</a> .  This technology loads elements into the DOM and unloads them based on how much of the list is visible to the user.  This greatly speeds up the work of applications that use long lists. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/943/62d/e27/94362de27756c8707fd5e7f3b5f31ba9.png"></div><br>  <i><font color="#999999">Only visible list items are displayed on the page.</font></i> <br><br><h2>  <font color="#3AC1EF">6. Use of FOUT strategy for working with fonts instead of FOIT strategy</font> </h2><br>  Many sites use non-standard fonts.  They usually look very attractive, but their use creates an additional load on the browser, as it has to download these fonts and prepare them for work.  When using non-standard fonts, say, downloaded from a third-party service like Google Fonts, the following two scenarios are possible: <br><br><ol><li>  The browser loads the font, processes it and only then displays the text.  Until the font is ready for use, the text typed in this font will be invisible.  This is called FOIT (Flash of invisible text). </li><li>  The browser initially displays text using a standard font, while performing the loading of the external font.  When this font is ready for use, the standard font changes to that particular font.  As a result, it turns out that the text on the page will be displayed in a standard font until a special font is loaded, after which the text will be displayed again, but in a new font.  This is called FOUT (Flash of unstyled text). </li></ol><br>  Most browsers use the FOIT strategy when working with non-standard fonts, the FOUT strategy is used only in Internet Explorer.  In order to use FOUT instead of FOIT, you can use the <code>font-display</code> descriptor for <code>@font-face</code> , and tell the browser whether we want the text to appear first in standard font, and then ours, or if we are satisfied with a certain invisibility period of the text .  If you are interested in the topic of fonts - take a look at <a href="https://www.malthemilthers.com/font-loading-strategy-acceptable-flash-of-invisible-text/">this</a> material.  In particular, here you can find information about the features of the work of the fonts and recommendations regarding the choice of the FOIT or FOUT strategy. <br><br><h2>  <font color="#3AC1EF">Results</font> </h2><br>  Here we looked at several techniques for optimizing Angular applications.  In fact, there are many more.  In particular, we are talking about server rendering, the use of service workers, AMP pages.  The expediency of optimization and the choice of its methods depend on the specific project - on its features and goals. <br><br>  <b>Dear readers!</b>  What approaches do you use to optimize Angular applications? <br><br> <a href="https://ruvds.com/ru-rub/"><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div><p>Source: <a href="https://habr.com/ru/post/431876/">https://habr.com/ru/post/431876/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../431864/index.html">PVS-Studio ROI: how not to lose millions (draft article)</a></li>
<li><a href="../431866/index.html">Programmers misconceptions about names - with examples</a></li>
<li><a href="../431870/index.html">Developer of interactive books with LEDs complained about the theft of ideas by Google employees</a></li>
<li><a href="../431872/index.html">JavaScript Guide, Part 9: ES7, ES8, and ES9 Features Overview</a></li>
<li><a href="../431874/index.html">Imba: JavaScript-compatible language for quick work with DOM</a></li>
<li><a href="../431878/index.html">Unknown javascript features</a></li>
<li><a href="../431880/index.html">Doom of SceneKit. Yandex experience with 3D graphics in iOS</a></li>
<li><a href="../431884/index.html">Microsoft has overtaken Apple by market capitalization: how did this happen?</a></li>
<li><a href="../431886/index.html">Al Lowy has posted his source code collection for Sierra products on eBay</a></li>
<li><a href="../431888/index.html">‚ÄúI think team ideas are the most important thing when developing a product‚Äù</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>