<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>STM32 + linux</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="To develop a control system for one piece of iron after a long search, I chose an ARM microcontroller of the STM32 family - STM32F103 (in the ‚Äúboneles...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>STM32 + linux</h1><div class="post__text post__text-html js-mediator-article">  To develop a control system for one piece of iron after a long search, I chose an ARM microcontroller of the STM32 family - STM32F103 (in the ‚Äúboneless‚Äù version).  And as a model for development and debugging - STM32P103 (there are fewer legs, but the core is the same).  ‚ÄúSuccess stories‚Äù I gradually laid out in my ZHshke, but now I decided to put everything together and tell about what it is - to program microcontrollers in Linux.  The project itself lies at <a href="https://sourceforge.net/projects/ircontroller/">sourceforge</a> . <br><br><a name="habracut"></a><br><br>  First of all I will touch on the general, and then I will go on to the details. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      So, in addition to the layout (or the finished device - when it is ready) you will need a JTAG adapter.  In my case, this is ST-LINK / V2.  Naturally, iron alone is not enough: you have to somehow somehow compile the code, and then also upload it to the controller.  For this, the gcc compiler for ARM (arm-none-eabi) and the utility for working with ST-LINK were installed (it is called stlink). <br><br>  As a sample, I took <a href="https://github.com/h0rr0rrdrag0n/stm32vldiscovery-linux-template">this project</a> .  <a href="https://www.olimex.com/Products/ARM/ST/STM32-P103/">From here</a> I downloaded simple demo projects and tried to compile the simplest one.  And the very first one turned out to be the standard Helloworld for the MC: blinking LED. <br><br>  I'll tell you right away what rake I ran into from the very beginning: I forgot about objcopy, without which getting a working code would be difficult.  After compiling the project, it is necessary to create a binary with this utility.  And do not throw out incomprehensible (and seemingly even unnecessary at first glance) goals from the Makefiles. <br><br>  I use Geany as a convenient IDE.  Since I have two monitors at work, it‚Äôs quite convenient to work: I have Geany with the code on one monitor, and a terminal on the second, where I run make and com (the terminal from tinyserial). <br><br>  I will not consider the whole Makefile, I will only pay attention to the fact that it should be changed: <br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre><code class="hljs swift"><span class="hljs-type"><span class="hljs-type">BIN</span></span>=testproject ‚Ä¶ <span class="hljs-type"><span class="hljs-type">STM32_LIBSRC</span></span>+=stm32_lib/misc.<span class="hljs-built_in"><span class="hljs-built_in">c</span></span> <span class="hljs-type"><span class="hljs-type">STM32_LIBSRC</span></span>+=stm32_lib/stm32f10x_adc.<span class="hljs-built_in"><span class="hljs-built_in">c</span></span> #~ <span class="hljs-type"><span class="hljs-type">STM32_LIBSRC</span></span>+=stm32_lib/stm32f10x_bkp.<span class="hljs-built_in"><span class="hljs-built_in">c</span></span> #~ <span class="hljs-type"><span class="hljs-type">STM32_LIBSRC</span></span>+=stm32_lib/stm32f10x_can.<span class="hljs-built_in"><span class="hljs-built_in">c</span></span> #~ <span class="hljs-type"><span class="hljs-type">STM32_LIBSRC</span></span>+=stm32_lib/stm32f10x_cec.<span class="hljs-built_in"><span class="hljs-built_in">c</span></span> #~ <span class="hljs-type"><span class="hljs-type">STM32_LIBSRC</span></span>+=stm32_lib/stm32f10x_crc.<span class="hljs-built_in"><span class="hljs-built_in">c</span></span> #~ <span class="hljs-type"><span class="hljs-type">STM32_LIBSRC</span></span>+=stm32_lib/stm32f10x_dac.<span class="hljs-built_in"><span class="hljs-built_in">c</span></span> #~ <span class="hljs-type"><span class="hljs-type">STM32_LIBSRC</span></span>+=stm32_lib/stm32f10x_dbgmcu.<span class="hljs-built_in"><span class="hljs-built_in">c</span></span> <span class="hljs-type"><span class="hljs-type">STM32_LIBSRC</span></span>+=stm32_lib/stm32f10x_dma.<span class="hljs-built_in"><span class="hljs-built_in">c</span></span> <span class="hljs-type"><span class="hljs-type">STM32_LIBSRC</span></span>+=stm32_lib/stm32f10x_exti.<span class="hljs-built_in"><span class="hljs-built_in">c</span></span> #~ <span class="hljs-type"><span class="hljs-type">STM32_LIBSRC</span></span>+=stm32_lib/stm32f10x_flash.<span class="hljs-built_in"><span class="hljs-built_in">c</span></span> #~ <span class="hljs-type"><span class="hljs-type">STM32_LIBSRC</span></span>+=stm32_lib/stm32f10x_fsmc.<span class="hljs-built_in"><span class="hljs-built_in">c</span></span> <span class="hljs-type"><span class="hljs-type">STM32_LIBSRC</span></span>+=stm32_lib/stm32f10x_gpio.<span class="hljs-built_in"><span class="hljs-built_in">c</span></span> #~ <span class="hljs-type"><span class="hljs-type">STM32_LIBSRC</span></span>+=stm32_lib/stm32f10x_i2c.<span class="hljs-built_in"><span class="hljs-built_in">c</span></span> #~ <span class="hljs-type"><span class="hljs-type">STM32_LIBSRC</span></span>+=stm32_lib/stm32f10x_it.<span class="hljs-built_in"><span class="hljs-built_in">c</span></span> #~ <span class="hljs-type"><span class="hljs-type">STM32_LIBSRC</span></span>+=stm32_lib/stm32f10x_iwdg.<span class="hljs-built_in"><span class="hljs-built_in">c</span></span> #~ <span class="hljs-type"><span class="hljs-type">STM32_LIBSRC</span></span>+=stm32_lib/stm32f10x_pwr.<span class="hljs-built_in"><span class="hljs-built_in">c</span></span> <span class="hljs-type"><span class="hljs-type">STM32_LIBSRC</span></span>+=stm32_lib/stm32f10x_rcc.<span class="hljs-built_in"><span class="hljs-built_in">c</span></span> #~ <span class="hljs-type"><span class="hljs-type">STM32_LIBSRC</span></span>+=stm32_lib/stm32f10x_rtc.<span class="hljs-built_in"><span class="hljs-built_in">c</span></span> #~ <span class="hljs-type"><span class="hljs-type">STM32_LIBSRC</span></span>+=stm32_lib/stm32f10x_sdio.<span class="hljs-built_in"><span class="hljs-built_in">c</span></span> #~ <span class="hljs-type"><span class="hljs-type">STM32_LIBSRC</span></span>+=stm32_lib/stm32f10x_spi.<span class="hljs-built_in"><span class="hljs-built_in">c</span></span> #~ <span class="hljs-type"><span class="hljs-type">STM32_LIBSRC</span></span>+=stm32_lib/stm32f10x_tim.<span class="hljs-built_in"><span class="hljs-built_in">c</span></span> <span class="hljs-type"><span class="hljs-type">STM32_LIBSRC</span></span>+=stm32_lib/stm32f10x_usart.<span class="hljs-built_in"><span class="hljs-built_in">c</span></span> #~ <span class="hljs-type"><span class="hljs-type">STM32_LIBSRC</span></span>+=stm32_lib/stm32f10x_wwdg.<span class="hljs-built_in"><span class="hljs-built_in">c</span></span> ‚Ä¶ <span class="hljs-type"><span class="hljs-type">SRC</span></span>=hw_config.<span class="hljs-built_in"><span class="hljs-built_in">c</span></span> main.<span class="hljs-built_in"><span class="hljs-built_in">c</span></span> leds.<span class="hljs-built_in"><span class="hljs-built_in">c</span></span> interrupts.<span class="hljs-built_in"><span class="hljs-built_in">c</span></span> usb_desc.<span class="hljs-built_in"><span class="hljs-built_in">c</span></span> usb_istr.<span class="hljs-built_in"><span class="hljs-built_in">c</span></span> \ usb_prop.<span class="hljs-built_in"><span class="hljs-built_in">c</span></span> usb_pwr.<span class="hljs-built_in"><span class="hljs-built_in">c</span></span> onewire.<span class="hljs-built_in"><span class="hljs-built_in">c</span></span> ‚Ä¶ #~ <span class="hljs-type"><span class="hljs-type">OBJ</span></span>+=stm32f10x_bkp.o #~ <span class="hljs-type"><span class="hljs-type">OBJ</span></span>+=stm32f10x_can.o #~ <span class="hljs-type"><span class="hljs-type">OBJ</span></span>+=stm32f10x_cec.o #~ <span class="hljs-type"><span class="hljs-type">OBJ</span></span>+=stm32f10x_crc.o #~ <span class="hljs-type"><span class="hljs-type">OBJ</span></span>+=stm32f10x_dac.o #~ <span class="hljs-type"><span class="hljs-type">OBJ</span></span>+=stm32f10x_dbgmcu.o <span class="hljs-type"><span class="hljs-type">OBJ</span></span>+=stm32f10x_dma.o <span class="hljs-type"><span class="hljs-type">OBJ</span></span>+=stm32f10x_exti.o #~ <span class="hljs-type"><span class="hljs-type">OBJ</span></span>+=stm32f10x_flash.o #~ <span class="hljs-type"><span class="hljs-type">OBJ</span></span>+=stm32f10x_fsmc.o <span class="hljs-type"><span class="hljs-type">OBJ</span></span>+=stm32f10x_gpio.o #~ <span class="hljs-type"><span class="hljs-type">OBJ</span></span>+=stm32f10x_i2c.o #~ <span class="hljs-type"><span class="hljs-type">OBJ</span></span>+=stm32f10x_it.o #~ <span class="hljs-type"><span class="hljs-type">OBJ</span></span>+=stm32f10x_iwdg.o #~ <span class="hljs-type"><span class="hljs-type">OBJ</span></span>+=stm32f10x_pwr.o <span class="hljs-type"><span class="hljs-type">OBJ</span></span>+=stm32f10x_rcc.o #~ <span class="hljs-type"><span class="hljs-type">OBJ</span></span>+=stm32f10x_rtc.o #~ <span class="hljs-type"><span class="hljs-type">OBJ</span></span>+=stm32f10x_sdio.o #~ <span class="hljs-type"><span class="hljs-type">OBJ</span></span>+=stm32f10x_spi.o #~ <span class="hljs-type"><span class="hljs-type">OBJ</span></span>+=stm32f10x_tim.o <span class="hljs-type"><span class="hljs-type">OBJ</span></span>+=stm32f10x_usart.o #~ <span class="hljs-type"><span class="hljs-type">OBJ</span></span>+=stm32f10x_wwdg.o</code> </pre> </div></div><br><ul><li>  BIN - the name of the resulting binary after compilation </li><li>  STM32_LIBSRC and OBJ contain the included STDPeriphLib library files that should not be used are commented out. </li><li>  SRC maintains a list of custom sources </li></ul><br><br>  After the code is written, run make.  If everything is in order, the $ (BIN) .bin file will appear in the current directory, which you need to write to the MKshka flash memory.  Writing is done with make load: this build target simply calls st-flash to flash the microcontroller. <br><br><h3>  USB </h3><br>  So, first of all, it is necessary to establish a connection between the computer and MKshki.  Considering the fact that there is no RS-232 in modern computers, I arrange the debug connection via USB.  However, in the ‚Äúbattle conditions‚Äù the team will receive the RS-232 from another controller, so I decided to immediately look towards the organization of the USB &lt;-&gt; RS-232 adapter emulator.  This approach is also convenient because you don‚Äôt have to bother with the extra code to interact with the device via USB (although this is elementary, but laziness is the same!).  And it's easy to debug: open the device / dev / ttyACM0 as a serial port with the help of any serial terminal emulator and ‚Äúcommunicate‚Äù.  Yes, I used tinyserial as a terminal emulator at first (as long as there is no software on the computer side). <br><br>  <a href="">From here</a> I downloaded the USB &lt;-&gt; RS-232 adapter emulator code.  Since I couldn‚Äôt immediately check the operation of the second side (RS-232) (I have nowhere to connect), the unused code for working with USART was temporarily commented. <br><br>  To work with USB, a library from STMicroelectronics is used.  If you don‚Äôt delve into the library‚Äôs codes, it's pretty simple: we need to redefine the descriptors for our hardware (usb_desc. [Ch] files) so that the computer recognizes it as a USB &lt;-&gt; RS-232 adapter, and also change the interrupt handlers to USB events (at a minimum - process the received data, and for transparent operation as an adapter, you will need to add USART interrupt handling to transfer the data received from there via USB). <br><br>  To send messages, we use something like a ring buffer, which will gradually be filled, and, if necessary, transferred via USB.  We will read the data in the ‚Äúnormal buffer‚Äù.  As long as I use only short commands, I did not bother with handling long parcels.  If they are, it will be necessary to complicate the interrupt handler for receiving data from USB. <br><br>  Since some commands (for example, reading the temperature from 1-wire sensors) take quite a long time, the handler of the commands received via USB only modifies the flags for such operations, and the main loop in main () processes these flags.  Operations that are performed quickly (working with the LED) are called directly from this function.  For debugging purposes, I added an ‚Äúecho‚Äù to the commands in the form of a brief decryption: <br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">usb_handle_command</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint16_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> cnt)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> command, *answer; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cnt; i++){ command = USB_Rx_Buffer[i]; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(command){ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> CMD_LED_ON: LED_On(); answer = (<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span>*)<span class="hljs-string"><span class="hljs-string">"On"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> CMD_LED_OFF: LED_Off(); answer = (<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span>*)<span class="hljs-string"><span class="hljs-string">"Off"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> CMD_LED_BLINK: LED_OnBlink(); answer = (<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span>*)<span class="hljs-string"><span class="hljs-string">"Blk"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> CMD_LED_DUTY_PLUS: LED_DutyPlus(); answer = (<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span>*)<span class="hljs-string"><span class="hljs-string">"Shn"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> CMD_LED_DUTY_MINUS: LED_DutyMinus(); answer = (<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span>*)<span class="hljs-string"><span class="hljs-string">"Fad"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> CMD_1W_GET_TEMP: FLAGS |= FLAG_READ_T; answer = (<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span>*)<span class="hljs-string"><span class="hljs-string">"Read T"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> CMD_1W_GET_DEV: FLAGS |= FLAG_GETDEV; answer = (<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span>*)<span class="hljs-string"><span class="hljs-string">"find devices"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> CMD_1W_PRNT_DEV: FLAGS |= FLAG_PRINTDEV; answer = (<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span>*)<span class="hljs-string"><span class="hljs-string">"Print devices"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> CMD_HALL_GET: FLAGS |= FLAG_PRINTHALL; answer = (<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span>*)<span class="hljs-string"><span class="hljs-string">"Print Hall"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> CMD_ADC_GET: FLAGS |= FLAG_PRINTADC; answer = (<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span>*)<span class="hljs-string"><span class="hljs-string">"Print ADC val"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: answer = (<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span>*)<span class="hljs-string"><span class="hljs-string">"Unk"</span></span>; } newline(); prnt(answer); newline(); } }</code> </pre></div></div><br><br>  That's it, now when I connect the layout to the computer via USB (and, actually, I always have it connected, because it is powered via USB) the device / dev / ttyACM0 appears, with which you can work as with a normal serial port.  For example, open it with a serial terminal (as I said above, I use tinyserial at first). <br><br><h3>  LED, button </h3><br>  Probably, it is traditional to ‚Äúflash the diode‚Äù at the beginning of the study of some new piece of hardware, so I will do the same.  And at the same time I will hang an interrupt on the ‚Äúuser button‚Äù, which will change the modes of the LED. <br><br>  Just blinking is not interesting: it is interesting to change the brightness.  For this, a simple "soft" ShIM is enough.  Set the SysTick timer for a period of 10¬µs.  Let's start two counters: one for the number of ‚Äúticks‚Äù during which the LED is on, and the second for the number of ‚Äúticks‚Äù during which the LED is off.  To change the brightness of the LED, I made the simplest eight-level scheme for changing the PWM duty cycle. <br>  It turned out this: <br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> LED_GetState(){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> led_state; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LED_Duty</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> duty)</span></span></span></span>{ duty_cycle = duty; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(led_state == LEDSTATE_BLINK) LED_OnBlink(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LED_DutyPlus</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(duty_cycle &lt; <span class="hljs-number"><span class="hljs-number">7</span></span>) duty_cycle++; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(led_state == LEDSTATE_BLINK) LED_OnBlink(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LED_DutyMinus</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(duty_cycle &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) duty_cycle--; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(led_state == LEDSTATE_BLINK) LED_OnBlink(); } <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> LED_GetBlinkState(<span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> *blink_on, <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> *blink_off){ *blink_on = led_blink_on; *blink_off = led_blink_off; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> led_state; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LED_On</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ led_state = LEDSTATE_ON; led_blink_on = <span class="hljs-number"><span class="hljs-number">0</span></span>; led_blink_off = <span class="hljs-number"><span class="hljs-number">0</span></span>; GPIO_ResetBits(GPIOC, GPIO_Pin_12); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LED_Off</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ led_state = LEDSTATE_OFF; GPIO_SetBits(GPIOC, GPIO_Pin_12); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LED_OnBlink</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ led_blink_off = <span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; duty_cycle; led_blink_on = <span class="hljs-number"><span class="hljs-number">0xff</span></span> - led_blink_off; led_ticks_on = <span class="hljs-number"><span class="hljs-number">0</span></span>; led_ticks_off = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(led_blink_off == <span class="hljs-number"><span class="hljs-number">0</span></span>){ LED_On(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(led_blink_on == <span class="hljs-number"><span class="hljs-number">0</span></span>) { LED_Off(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } led_state = LEDSTATE_BLINK; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LED_SysTick_Handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(led_state != LEDSTATE_BLINK) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(led_ticks_on == <span class="hljs-number"><span class="hljs-number">0</span></span>) GPIO_SetBits(GPIOC, GPIO_Pin_12); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(led_ticks_on &lt;= led_blink_on) { led_ticks_on++; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (led_ticks_off == <span class="hljs-number"><span class="hljs-number">0</span></span>){ GPIO_ResetBits(GPIOC, GPIO_Pin_12); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(led_ticks_off &lt;= led_blink_off){ led_ticks_off++; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } led_ticks_on = <span class="hljs-number"><span class="hljs-number">0</span></span>; led_ticks_off = <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre></div></div><br><br>  On the "custom button" I hung external interrupt: <br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="hljs pgsql"> // <span class="hljs-keyword"><span class="hljs-keyword">Enable</span></span> the BUTTON Clock RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, <span class="hljs-keyword"><span class="hljs-keyword">ENABLE</span></span>); RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, <span class="hljs-keyword"><span class="hljs-keyword">ENABLE</span></span>); // Configure Button pin <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">input</span></span> GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING; GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0; GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz; GPIO_Init(GPIOA, &amp;GPIO_InitStructure); // <span class="hljs-keyword"><span class="hljs-keyword">Connect</span></span> Button EXTI <span class="hljs-type"><span class="hljs-type">Line</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> Button GPIO Pin GPIO_EXTILineConfig(GPIO_PortSourceGPIOA, GPIO_PinSource0); // Configure Button EXTI <span class="hljs-type"><span class="hljs-type">line</span></span> EXTI_InitStructure.EXTI_Line = EXTI_Line0; EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt; EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Rising; EXTI_InitStructure.EXTI_LineCmd = <span class="hljs-keyword"><span class="hljs-keyword">ENABLE</span></span>; EXTI_Init(&amp;EXTI_InitStructure); // <span class="hljs-keyword"><span class="hljs-keyword">Enable</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> Button EXTI Interrupt <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> the lowest priority NVIC_InitStructure.NVIC_IRQChannel = EXTI0_IRQn; NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = <span class="hljs-number"><span class="hljs-number">0x0F</span></span>; NVIC_InitStructure.NVIC_IRQChannelSubPriority = <span class="hljs-number"><span class="hljs-number">0x0F</span></span>; NVIC_InitStructure.NVIC_IRQChannelCmd = <span class="hljs-keyword"><span class="hljs-keyword">ENABLE</span></span>; NVIC_Init(&amp;NVIC_InitStructure);</code> </pre></div></div><br>  And its handler is engaged in switching the LED to the continuous glow mode, if it blinked, or vice versa, to the blink mode, if it was glowing: <br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EXTI0_IRQHandler</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(EXTI_GetITStatus(EXTI_Line0) != RESET){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(LED_GetState() != LEDSTATE_BLINK) LED_OnBlink(); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> LED_On(); EXTI_ClearITPendingBit(EXTI_Line0); } }</code> </pre></div></div><br><br><h3>  1-wire </h3><br>  I pulled the code for working with 1-wire from <a href="http://we.easyelectronics.ru/blog/STM32/">easyelectronics.com</a> from <a href="http://we.easyelectronics.ru/blog/STM32/">somewhere</a> .  I changed it quite a bit.  First of all, I changed the search function for devices hanging on the bus (for some reason it did not work in the original, although the logic seemed to be quite clear and correct). <br><br>  In the example I stole, 1-wire worked via USART, and DMA was used for reading / writing.  I really liked this idea, so I used exactly this method (although it was possible to organize the 1-wire software protocol). <br><br>  The standard scheme for connecting 1-wire bus to a serial port implies the presence of a Schottky diode: <br><img src="https://habrastorage.org/getpro/geektimes/post_images/7cc/fb2/46b/7ccfb246b740fe45ed8e4480a1877393.png"><br>  However, I did not have such a diode.  But I saw that in addition to the push-pull mode, the foot responsible for USART_TX can be switched to open drain mode - in this case there will be no short circuit.  I used USART3 to work with 1-wire (while I indulge, I have enough legs, so I don‚Äôt need to do remap).  In the diagram, I saw that the legs of USART3 (PB10 and PB11) were already pulled to the ground through resistors of 10 kOhm, so I didn‚Äôt even need to solder a resistor: I just soldered a small handkerchief with sockets on the breadboard so that it was convenient to connect thermal sensors. <br><br>  I will not describe in detail the contents of the onewire.c file: this has already been done several times before me, and I will only touch directly on working with thermometers. <br><br>  To monitor the temperature of the warm (above -50 ¬∞ C) parts of the device, I decided to use simple DS18S20 sensors (the stated measurement accuracy is at least 0.5 ¬∞ C).  I connected the socket soldered to the breadboard to the right pins so that you can connect a couple of thermometers to the CK at the same time. <br><br>  Here, for example, what I get when working with thermometers: <br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="bash hljs">com /dev/ttyACM0 Ca <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span>, Cx modem lines status [STATUS]: RTS CTS DTR //  <span class="hljs-string"><span class="hljs-string">'c'</span></span> : find devices Found 2 devices //  <span class="hljs-string"><span class="hljs-string">'p'</span></span> : Print devices device 0: 0x10 0x7c 0xee 0x8f 0x02 0x08 0x00 0x1c device 1: 0x10 0xad 0xbc 0x8f 0x02 0x08 0x00 0xf9 //  <span class="hljs-string"><span class="hljs-string">'t'</span></span> : Read T Device 0: 0x3b 0x00 0x4b 0x46 0xff 0xff 0x08 0x10 0x39 Device 1: 0x3a 0x00 0x4b 0x46 0xff 0xff 0x0c 0x10 0x41</code> </pre></div></div><br><br>  For starters, I marked all the thermometers to know which one I had.  And after that I decided to see if their readings differ greatly.  Temperature - the first two bytes of the sensor response.  The seventh byte is the ‚Äúremainder‚Äù of the temperature conversion embedded in the ADC thermometer.  According to the documentation on the sensors, this residue helps to clarify the temperature value.  However, it turned out that the sense of it - as from a goat milk. <br><br>  In the process, the sensor heats up itself, which affects the measurement results.  Therefore, do not interrogate them too often.  In addition, the readings of the sensors differed from each other up to one and a half degrees!  This must be borne in mind: if you plan to use several sensors so that you can monitor the temperature difference between areas of something with an accuracy not worse than 0.5 ¬∞ C, you must first calibrate all the sensors.  And readings on the calibration formulas, and not the response of the sensors. <br><br>  The real error of the sensor sometimes exceeds 0.5 ¬∞ C, so it‚Äôs still better to assume that the sensor has an accuracy of 1 ¬∞ C. <br><br><h3>  Hall Sensor </h3><br>  Hall sensors I have analog - SS495A.  Sensor specifications can be found on the Internet.  Let me just say that in its normal state, the voltage on its output leg is about 2.5V (logical unit STM32), depending on the polarity and the external magnetic field, it will change its readings within 0..5V.  Considering that the output voltage can reach five volts, it is necessary to use not the usual, but ‚Äúfive-volt‚Äù (marked as FR in the specification) inputs of the controller. <br><br>  The magnets I have (especially for this sensor), when placing their working surface within 1 mm from the sensor ‚Äúmuzzle‚Äù (marked side), led to the appearance of zero voltage at its output.  Moreover, the level of logical zero appears in a rather small area along the coordinates in the parallel marked side of the sensor plane, i.e.  positioning accuracy is pretty decent. <br><br>  For the experiments I soldered one sensor on the breadboard.  The power supply connected it to 5V, and the signal output brought to the PC10 port, which does not burn if 5V is supplied to it.  In order not to constantly pull the port, I hung up an interrupt on it (by analogy with a button).  The interrupt handler simply sets the corresponding flag, and in the main loop, if this flag is set (ie, the magnet either appears or leaves the sensor's ‚Äúfield of view‚Äù), we check that we have PC10.  If there is zero (there is an MP), we write to the Magnet terminal, otherwise we write ‚Äúclear‚Äù.  You can also forcefully check whether there is a sensor or not by pressing ‚Äúh‚Äù in the terminal. <br><br><h3>  ADC </h3><br>  In addition to the "warm zones" I still need to measure the temperature in the cold (up to 75K above).  For this, platinum thermistors connected to the ADG506A analog switch will be used.  Well, of course, I wondered how bad the ‚Äúnative‚Äù ADC of the MKshka: could it be used to measure the temperature? <br><br>  There are plenty of examples of STM32 with ADC, I took an example from STDPeriphLib.  We will run the ADC in continuous conversion mode, and store the result in memory using DMA.  I set the conversion time to the largest (to be more precise), and for the time being, I‚Äôll hang the PB0 (ADC8) on the foot of the ADC: <br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="hljs pgsql"> // <span class="hljs-number"><span class="hljs-number">0.</span></span> Configure ADC8 (PB0) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> analog <span class="hljs-keyword"><span class="hljs-keyword">input</span></span> (clocking GPIOB sat <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> onewire.c) RCC_ADCCLKConfig(RCC_PCLK2_Div4); RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, <span class="hljs-keyword"><span class="hljs-keyword">ENABLE</span></span>); RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1 | RCC_APB2Periph_GPIOB, <span class="hljs-keyword"><span class="hljs-keyword">ENABLE</span></span>); GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN; GPIO_Init(GPIOB, &amp;GPIO_InitStructure); // <span class="hljs-number"><span class="hljs-number">1.</span></span> DMA <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> converted <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> (DMA1 clocking sat <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> at onewire.c) //RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, <span class="hljs-keyword"><span class="hljs-keyword">ENABLE</span></span>); DMA_DeInit(DMA1_Channel1); DMA_InitStructure.DMA_PeripheralBaseAddr = ADC1_DR_Address; DMA_InitStructure.DMA_MemoryBaseAddr = (uint32_t)&amp;ADC_value; DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC; DMA_InitStructure.DMA_BufferSize = <span class="hljs-number"><span class="hljs-number">1</span></span>; DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable; DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Disable; DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_HalfWord; DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_HalfWord; DMA_InitStructure.DMA_Mode = DMA_Mode_Circular; DMA_InitStructure.DMA_Priority = DMA_Priority_High; DMA_InitStructure.DMA_M2M = DMA_M2M_Disable; DMA_Init(DMA1_Channel1, &amp;DMA_InitStructure); DMA_Cmd(DMA1_Channel1, <span class="hljs-keyword"><span class="hljs-keyword">ENABLE</span></span>); // <span class="hljs-number"><span class="hljs-number">2.</span></span> ADC1 config ADC_InitStructure.ADC_Mode = ADC_Mode_Independent; ADC_InitStructure.ADC_ScanConvMode = <span class="hljs-keyword"><span class="hljs-keyword">ENABLE</span></span>; ADC_InitStructure.ADC_ContinuousConvMode = <span class="hljs-keyword"><span class="hljs-keyword">ENABLE</span></span>; ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None; ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right; ADC_InitStructure.ADC_NbrOfChannel = <span class="hljs-number"><span class="hljs-number">1</span></span>; ADC_Init(ADC1, &amp;ADC_InitStructure); // <span class="hljs-keyword"><span class="hljs-keyword">Connect</span></span> ADC <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> ADC8 (PB0), ADC_RegularChannelConfig(ADC1, ADC_Channel_8, <span class="hljs-number"><span class="hljs-number">1</span></span>, ADC_SampleTime_239Cycles5); // <span class="hljs-keyword"><span class="hljs-keyword">Enable</span></span> ADC1 DMA ADC_DMACmd(ADC1, <span class="hljs-keyword"><span class="hljs-keyword">ENABLE</span></span>); ADC_Cmd(ADC1, <span class="hljs-keyword"><span class="hljs-keyword">ENABLE</span></span>); // Calibration <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> ADC1 ADC_ResetCalibration(ADC1); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(ADC_GetResetCalibrationStatus(ADC1)); ADC_StartCalibration(ADC1); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(ADC_GetCalibrationStatus(ADC1)); ADC_SoftwareStartConvCmd(ADC1, <span class="hljs-keyword"><span class="hljs-keyword">ENABLE</span></span>); // turn <span class="hljs-keyword"><span class="hljs-keyword">conversion</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span></code> </pre></div></div><br><br>  To work with the switch, you need to configure five bits of the control port.  In order not to bathe with the conversion of bits, I simply took the first four bits of port C as the address, and the fifth bit as the key that includes the switch: <br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="hljs pgsql"> GPIO_InitStructure.GPIO_Pin = <span class="hljs-number"><span class="hljs-number">0x1f</span></span>; // first <span class="hljs-number"><span class="hljs-number">5</span></span> bits <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> PC0 // PC0..PC3 - analog channel address, PC4 - analog <span class="hljs-keyword"><span class="hljs-keyword">enable</span></span> switch GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; GPIO_Init(GPIOC, &amp;GPIO_InitStructure);</code> </pre></div></div><br><br>  There are no interruptions here, and in the interrupts.c file, it is necessary to add the setting of a new flag when a command (say, the 'a' command) arrives to display the voltage on the sensors.  In the main () add processing this flag: <br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-type"><span class="hljs-type">void</span></span> prntADC(){ uint32_t address; // addr = <span class="hljs-number"><span class="hljs-number">0</span></span>, EN = <span class="hljs-number"><span class="hljs-number">1</span></span> uint8_t *_2b = (uint8_t *) &amp;ADC_value; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(address = <span class="hljs-number"><span class="hljs-number">0x10</span></span>; address &lt; <span class="hljs-number"><span class="hljs-number">0x20</span></span>; address++){ // changhe channel address &amp; turn <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> switch GPIOC-&gt;BSRR = address; Delay(<span class="hljs-number"><span class="hljs-number">2</span></span>); // wait <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> AD <span class="hljs-keyword"><span class="hljs-keyword">conversion</span></span> prnt((uint8_t*)"Temperature "); printInt(address&amp;<span class="hljs-number"><span class="hljs-number">0x0f</span></span>); prnt((uint8_t*)" = "); printInt(_2b[<span class="hljs-number"><span class="hljs-number">1</span></span>]); printInt(_2b[<span class="hljs-number"><span class="hljs-number">0</span></span>]); newline(); // turn <span class="hljs-keyword"><span class="hljs-keyword">off</span></span> switch &amp; <span class="hljs-keyword"><span class="hljs-keyword">reset</span></span> bits GPIOC-&gt;BRR = (uint32_t)<span class="hljs-number"><span class="hljs-number">0x1f</span></span>; Delay(<span class="hljs-number"><span class="hljs-number">2</span></span>); } }</code> </pre></div></div><br>  When a command is received in a cycle, we start setting the required address on the switch, wait a couple of milliseconds for the ADC to work, and then output the resulting value.  Then turn off the switch and wait (just in case) a couple of milliseconds. <br><br>  On a separate layout I assembled a simple resistive voltage divider, connecting all the analog inputs of the switch with small-impedance (200..900 Ohm) resistors.  I connected ‚Äúground‚Äù to S1, and to S16 - + 3.3V from the STM32 model.  I powered up the chip with an old power supply from an external HDD (12V). <br><br>  In the STM32P103 layout, the reference voltage for the ADC is taken from the total power, so the accuracy is low: sometimes the values ‚Äã‚Äãfloat by as much as 20 units! <br><br>  Here, for example, what happened with two surveys: <br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="hljs objectivec"><span class="hljs-comment"><span class="hljs-comment">//  1 Temperature 0x00 = 0x00 0x00 Temperature 0x01 = 0x00 0x84 Temperature 0x02 = 0x00 0xaf Temperature 0x03 = 0x01 0xdb Temperature 0x04 = 0x03 0x10 Temperature 0x05 = 0x03 0xe4 Temperature 0x06 = 0x05 0xca Temperature 0x07 = 0x06 0x9b Temperature 0x08 = 0x07 0x4e Temperature 0x09 = 0x08 0xd6 Temperature 0x0a = 0x0a 0x04 Temperature 0x0b = 0x0a 0xb4 Temperature 0x0c = 0x0b 0xfc Temperature 0x0d = 0x0d 0xe0 Temperature 0x0e = 0x0e 0xb7 Temperature 0x0f = 0x0f 0xff //  2 Temperature 0x00 = 0x00 0x00 Temperature 0x01 = 0x00 0x7f Temperature 0x02 = 0x00 0xaf Temperature 0x03 = 0x01 0xdf Temperature 0x04 = 0x03 0x0f Temperature 0x05 = 0x03 0xe4 Temperature 0x06 = 0x05 0xcc Temperature 0x07 = 0x06 0x9d Temperature 0x08 = 0x07 0x5a Temperature 0x09 = 0x08 0xd6 Temperature 0x0a = 0x0a 0x01 Temperature 0x0b = 0x0a 0xb5 Temperature 0x0c = 0x0b 0xfc Temperature 0x0d = 0x0e 0x09 Temperature 0x0e = 0x0e 0xb0 Temperature 0x0f = 0x0f 0xec</span></span></code> </pre></div></div><br><br>  In general, it will be necessary either to try to add a stable source of reference voltage (and to feed the measured circuit from the same place), or to use an external ADC in general.  Given the low resistance of the sensors to be used, you still have to solder the amplifier. <br><br><h3>  Stepper motor </h3><br>  I haven‚Äôt finished messing around since  I suspect that when I install elements on a breadboard, nothing will ‚Äúfly up‚Äù from me.  Need to solder.  And I will probably do soldering only next year (I still need to buy radio components).  So far, only briefly tell you how I plan to manage the stepper motors. <br><br>  I will have sharks - 1.2 amps VSS42.  Manage such most conveniently using the driver SD - L6208.  When working on this chip, it is necessary to send only signals to control the direction of movement, a work enable signal and clock pulses.  The controller itself adjusts the PWM and sets the required voltages on the motor windings. <br><br>  I will point out the main things for now: <br><ul><li>  The PWM adjustment is performed by comparing the voltage drop across the Sense resistors with the reference voltage Vref.  Therefore, for the current I <sub>max</sub> and the resistance of the resistors R <sub>Sense,</sub> this drop can be calculated quite simply: <br>  <b>U <sub>ref</sub> = I <sub>max</sub> ¬∑ R <sub>Sense</sub></b> <br>  Those.  to set the current limit to 1.2A with R <sub>Sense</sub> = 0.33Ohm, you must set U <sub>ref</sub> = 0.4 V. In no case can you leave the legs V <sub>ref</sub> hanging in the air or pressed to the ground! </li><li>  Slow / Fast decay mode is important for conventional collector engines, while Fast decay is only needed in microstepping mode.  In general, if you don‚Äôt pervert, you just need to apply + 5V per leg of CONTROL.  On HALF / FULL, we also just serve + 5V and work in half-step mode.  We do the same with the RESET leg, if we don‚Äôt want to reset the phase counter (and we don‚Äôt need to reset it, if we honestly give 8 sync pulses to each step). </li><li>  The ENABLE input is also an output: if a trouble occurs with the L6208 driver (overheating, current surge), it automatically disconnects the voltage on the load, and ENABLE pulls it to the ground.  This means that it is possible to check whether an emergency has occurred, if the leg of the controller that controls the ENABLE port is activated in the open collector output mode. <br>  According to the STM32 specification, in the open collector mode, when a unit is applied to the port output, the transistor tightening the leg to the ground is simply locked.  If the output is zero, then the leg is tightened again. <br>  Thus, pulling the controller's leg to + 5V ( <b>FT</b> should be chosen leg) through, say, a five-kilohm resistor, and between it and ENABLE, sticking, say, a kilohm resistor (and <i>not forgetting to shunt the ENABLE leg with a capacitor to the ground</i> , otherwise you can burn the control controller ), you can enable / disable the desired engine, and check if there were any accidents (and for this you can hang up the periphery of the periphery on the falling front of the controller on the falling front). </li><li>  Conductors marked bold in the specification should be as short and wide as possible.  But at the same time, care must be taken to reduce parasitic capacitances and inductances. <br>  R <sub>Sense</sub> should be located as close as possible to the driver.  Not far from them should be C  and C‚ÇÇ capacitors (according to the specification): not only the comparison current flows through this circuit, but also the reverse induction current (therefore, by the way, <b>diodes cannot be included in this chain</b> ). <br>        <b></b>   C‚ÇÅ  ,             ( , ,  ,   ,      ). </li><li>     : <b>     </b> !       5        . <br> ,  ,   :  +5       .     , ,  ,         0.          .     .  ,  USB-,  ,  ... </li></ul></div><p>Source: <a href="https://habr.com/ru/post/161863/">https://habr.com/ru/post/161863/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../161853/index.html">The shortest overview of the mechanical keyboard Matias Tactile Pro 4.0</a></li>
<li><a href="../161855/index.html">Bitcoin has an official bank</a></li>
<li><a href="../161857/index.html">The need for proper goal setting</a></li>
<li><a href="../161859/index.html">Inferno Shell</a></li>
<li><a href="../161861/index.html">Evolution of Zeus. Part II</a></li>
<li><a href="../161865/index.html">Windows Store opened in Ukraine</a></li>
<li><a href="../161867/index.html">‚ÄúQuote‚Äù button for iOs</a></li>
<li><a href="../161875/index.html">Simple technique Parallax Scrolling</a></li>
<li><a href="../161877/index.html">Creating a link resolution plugin for PhpStorm (IntelliJ IDEA)</a></li>
<li><a href="../161879/index.html">Video: Mom first tests Windows 8, Ubuntu 12.10, Windows 1.0, Windows 3.1, Linux Mint Cinnamon 14, OSX 10.2, Elementary OS Luna, Kubuntu, Zorin OS 6.1, MS-DOS 6.22 and Microsoft Bob!</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>