<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Quick access to map by key row</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the article ‚ÄúString enum - string enum‚Äù I wrote about how to associate textual representations with the enum class - a good method but only if all ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Quick access to map by key row</h1><div class="post__text post__text-html js-mediator-article">  In the article <a href="http://habrahabr.ru/post/236403/">‚ÄúString enum - string enum‚Äù</a> I wrote about how to associate textual representations with the enum class - a good method but only if all elements are known in advance, but it often happens that the strings are certain identifiers and of course are not known in advance, and often will be added later and without rebuilding the program. <br><br>  Library requirements are all the same: <br><br><ul><li>  Cross-platform; </li><li>  Minimum dependencies; </li><li>  Read speed; </li><li>  Simple syntax; </li></ul>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Config example <br><pre><code class="javascript hljs">{ <span class="hljs-string"><span class="hljs-string">"objects"</span></span>: [ { <span class="hljs-string"><span class="hljs-string">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"object1"</span></span>, <span class="hljs-string"><span class="hljs-string">"events"</span></span>: { <span class="hljs-string"><span class="hljs-string">"event1"</span></span>:{ <span class="hljs-string"><span class="hljs-string">"give"</span></span>: {<span class="hljs-string"><span class="hljs-string">"object2"</span></span>: <span class="hljs-number"><span class="hljs-number">4</span></span>} }, } }, { <span class="hljs-string"><span class="hljs-string">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"object2"</span></span>, <span class="hljs-string"><span class="hljs-string">"events"</span></span>: { <span class="hljs-string"><span class="hljs-string">"event2"</span></span>:{ <span class="hljs-string"><span class="hljs-string">"give"</span></span>: {<span class="hljs-string"><span class="hljs-string">"object1"</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span>} }, }, { <span class="hljs-string"><span class="hljs-string">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"object3"</span></span>, <span class="hljs-string"><span class="hljs-string">"events"</span></span>: { <span class="hljs-string"><span class="hljs-string">"event3"</span></span>:{ <span class="hljs-string"><span class="hljs-string">"give"</span></span>: {<span class="hljs-string"><span class="hljs-string">"object3"</span></span>: <span class="hljs-number"><span class="hljs-number">4</span></span>} }, } },</code> </pre> <br><br>  The first and simplest idea that begs is: <br><pre> <code class="cpp hljs"> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>,script&gt; events;</code> </pre><br>  But again, if this is a high-loaded part of the program, then a search by map can be quite long, hashes can give the colisies something that you don‚Äôt want. <br><br>  The second idea to parse this config in 2 passes then on the 2nd pass object1, object2, object3 will be already known and it will be possible to write down directly pointers or links on them.  But if the dependencies are even more complex, then this approach may not work. <br><br>  I propose a way to significantly reduce runtime costs of such structures. <br><br><a name="habracut"></a><br>  The main idea is that each line readable from the config file will fit into a certain structure, and back we would get its unique number. <br>  The minimal implementation of this idea looks like this. <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StringCache</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _values.insert(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_pair(value, _values.size() + <span class="hljs-number"><span class="hljs-number">1</span></span>)).first-&gt;second; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">find</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> it =_values.find(value); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> it != _values.end() ? it-&gt;second : <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; _values; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; StringCache&lt;T&gt;::_values;</code> </pre><br>  The idea is simple there is such a line we give it an index, no, we create a new one <br><br>  Next, take care of type safety. <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ValueType</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StrongType</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">operator</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ValueType</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _value;} <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> == (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> StrongType &amp;other) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _value == other._value; } <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> != (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> StrongType &amp;other) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _value != other._value; } <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> &lt; (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> StrongType &amp;other) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _value &lt; other._value;; } <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> &gt; (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> StrongType &amp;other) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _value &gt; other._value; } <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> &lt;= (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> StrongType &amp;other) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _value &lt;= other._value; } <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> &gt;= (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> StrongType &amp;other) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _value &gt;= other._value; } <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">StrongType</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ValueType value)</span></span></span><span class="hljs-function">:_</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">value</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(value)</span></span></span><span class="hljs-function"> </span></span>{} <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: ValueType _value; };</code> </pre><br><br>  The idea is not new code peeped in boost but as I already wrote, a minimum of dependencies. <br><br>  further the most interesting <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ValueType</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">int</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StringCache</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_integral&lt;ValueType&gt;::value, <span class="hljs-string"><span class="hljs-string">"not integral type"</span></span>); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Type</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> StrongType&lt;T,ValueType&gt; { <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StringCache</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Type</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;value)</span></span></span><span class="hljs-function">:StrongType&lt;T,ValueType&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(StringCache::get(value))</span></span></span></span>{} <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Type</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ValueType value)</span></span></span><span class="hljs-function">:StrongType&lt;T,ValueType&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(value)</span></span></span></span>{} }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Type </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Type(_values.insert(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_pair(value, _values.size() + <span class="hljs-number"><span class="hljs-number">1</span></span>)).first-&gt;second); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Type </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">find</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;::const_iterator it =_values.find(value); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(it == _values.end()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Type(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Type(it-&gt;second); } <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function">&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">to_string</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Type &amp;type)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> empty; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;ValueType&gt;(type)&gt;=_values.size()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> empty; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp;it:_values) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(it.second == <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;ValueType&gt;(type)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> it.first; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> empty; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>,ValueType&gt; _values; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ValueType</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>,ValueType&gt; StringCache&lt;T,ValueType&gt;::_values;</code> </pre><br>  + f-i search index without creating a new <br>  and finally, the f-i to convert back to the string - it is slow and only suitable for logging or similar operations. <br><br>  Well, finally, an example of use along with performance evaluations <a href="http://ideone.com/93fdsO">http://ideone.com/93fdsO</a> <br><div class="spoiler">  <b class="spoiler_title">Full test code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #include &lt;chrono&gt; #include &lt;map&gt; #include &lt;unordered_map&gt; #include &lt;string&gt; #include &lt;random&gt; #include &lt;algorithm&gt; template &lt;class T, class ValueType&gt; class StrongType { public: inline explicit operator ValueType() const { return _value;} inline bool operator == (const StrongType &amp;other) const { return _value == other._value; } inline bool operator != (const StrongType &amp;other) const { return _value != other._value; } inline bool operator &lt; (const StrongType &amp;other) const { return _value &lt; other._value;; } inline bool operator &gt; (const StrongType &amp;other) const { return _value &gt; other._value; } inline bool operator &lt;= (const StrongType &amp;other) const { return _value &lt;= other._value; } inline bool operator &gt;= (const StrongType &amp;other) const { return _value &gt;= other._value; } protected: explicit StrongType(ValueType value):_value(value) {} private: ValueType _value; }; template &lt;class T, class ValueType = int&gt; class StringCache { public: static_assert(std::is_integral&lt;ValueType&gt;::value, "not integral type"); class Type: public StrongType&lt;T,ValueType&gt; { friend class StringCache; public: explicit operator bool() const { return static_cast&lt;ValueType&gt;(*this)!=0; } private: explicit Type(ValueType value):StrongType&lt;T,ValueType&gt;(value){} }; static Type get(const std::string &amp;value) { return Type(_values.insert(std::make_pair(value, _values.size() + 1)).first-&gt;second); } static Type find(const std::string &amp;value) { std::map&lt;std::string,int&gt;::const_iterator it =_values.find(value); if(it == _values.end()) return Type(0); else return Type(it-&gt;second); } static const std::string&amp; to_string(const Type &amp;type) { static const std::string empty; if(static_cast&lt;ValueType&gt;(type)&gt;=_values.size()) return empty; for(const auto &amp;it:_values) if(it.second == static_cast&lt;ValueType&gt;(type)) return it.first; return empty; } private: static std::map&lt;std::string,int&gt; _values; }; template &lt;class T, class ValueType&gt; std::map&lt;std::string,int&gt; StringCache&lt;T,ValueType&gt;::_values; class EventType:public StringCache&lt;EventType&gt;{}; class Script { public: Script(int val):_value(val) { } int execute() const { return _value; } private: int _value; }; class Object { public: int execute(const std::string &amp;id) const { auto it = _events.find(id); if(it!=_events.end()) { return it-&gt;second.execute(); } return 0; } void addevent(const std::string &amp;event, const Script &amp;script) { _events.insert(std::make_pair(event, script)); } private: std::map&lt;std::string, Script&gt; _events; }; class HashObject { public: int execute(const std::string &amp;id) const { auto it = _events.find(id); if(it!=_events.end()) { return it-&gt;second.execute(); } return 0; } void addevent(const std::string &amp;event, const Script &amp;script) { _events.insert(std::make_pair(event, script)); } private: std::unordered_map&lt;std::string, Script&gt; _events; }; class FastObject { public: int execute(EventType::Type id) const { auto it = _events.find(id); if(it!=_events.end()) { return it-&gt;second.execute(); } return 0; } void addevent(EventType::Type event, const Script &amp;script) { _events.insert(std::make_pair(event, script)); } private: std::map&lt;EventType::Type, Script&gt; _events; }; std::vector&lt;std::string&gt; eventIds= { "event00", "event01", "event02", "event03", "event04", "event05", "event06", "event07", "event08", "event09", "event00", "event11", "event12", "event13", "event14", "event15", "event16", "event17", "event18", "event19", "event20", "event21", "event22", "event23", "event24", "event25" }; int main(int argc, const char * argv[]) { std::random_device rd; std::default_random_engine engine(rd()); std::vector&lt;int&gt; ids{0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19}; std::vector&lt;Object&gt; objects; std::vector&lt;FastObject&gt; fast_objects; std::vector&lt;HashObject&gt; hash_objects; const static int max_objects = 1000; const static int iter_count = 1000; const static int repeat_count = 1; objects.reserve(max_objects); fast_objects.reserve(max_objects); hash_objects.reserve(max_objects); for(int i=0;i&lt;max_objects;++i) { std::shuffle(ids.begin(), ids.end(), engine); Object obj1; HashObject obj2; FastObject obj3; for(int j=0;j&lt;10;++j) //add first 10 elemtnts not all object has all events { obj1.addevent(eventIds[ids[j]], Script(j)); obj2.addevent(eventIds[ids[j]], Script(j)); obj3.addevent(EventType::get(eventIds[ids[j]]), Script(j)); } objects.push_back(obj1); hash_objects.push_back(obj2); fast_objects.push_back(obj3); } std::vector&lt;std::string&gt; events; events.reserve(eventIds.size()*iter_count); for(int i=0;i&lt;iter_count;++i) for(const auto &amp;it:eventIds) { events.push_back(it); } int ret1 = 0; int ret2 = 0; int ret3 = 0; std::chrono::high_resolution_clock::time_point t = std::chrono::high_resolution_clock::now(); for(int i=0;i&lt;repeat_count;++i) for(const auto &amp;event:events) { for(const auto &amp;object:objects) { ret1 += object.execute(event); } } auto duration = std::chrono::high_resolution_clock::now() - t; std::cout &lt;&lt; std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(duration).count() &lt;&lt; ":" &lt;&lt; ret1 &lt;&lt; std::endl; t = std::chrono::high_resolution_clock::now(); for(int i=0;i&lt;repeat_count;++i) for(const auto &amp;event:events) { for(const auto &amp;object:hash_objects) { ret2 += object.execute(event); } } duration = std::chrono::high_resolution_clock::now() - t; std::cout &lt;&lt; std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(duration).count() &lt;&lt; ":" &lt;&lt; ret2 &lt;&lt; std::endl; t = std::chrono::high_resolution_clock::now(); for(int i=0;i&lt;repeat_count;++i) for(const auto &amp;event:events) { EventType::Type eventId = EventType::find(event); if(eventId) //possible that no one has this id for(const auto &amp;object:fast_objects) { ret3 += object.execute(eventId); } } duration = std::chrono::high_resolution_clock::now() - t; std::cout &lt;&lt; std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(duration).count() &lt;&lt; ":" &lt;&lt; ret3 &lt;&lt; std::endl; return 0; }</span></span></span></span></code> </pre><br></div></div><br><br>  PS Yes, in most real-world problems, the value for the search is either taken from other variables or can be prepared in advance. <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EventId</span></span></span><span class="hljs-class">:</span></span><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> StringCache&lt;EventId:<span class="hljs-keyword"><span class="hljs-keyword">public</span></span>&gt;{}; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(something) { <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> EventId:Type event1Val = EventId:<span class="hljs-keyword"><span class="hljs-keyword">public</span></span>::find(<span class="hljs-string"><span class="hljs-string">"event1"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">map</span></span>.find(event1Val); }</code> </pre><br><br>  PPS this code, in contrast to the previous article, has not yet used this concept in real applications, so criticism and rac sentences are especially welcome. </div><p>Source: <a href="https://habr.com/ru/post/236697/">https://habr.com/ru/post/236697/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../236683/index.html">Some interesting and useful things for web developer # 28</a></li>
<li><a href="../236685/index.html">Reasons for failing to achieve goals</a></li>
<li><a href="../236687/index.html">Ice Bucket Challenge: engagement lessons</a></li>
<li><a href="../236689/index.html">Automatic optimization of algorithms using fast exponentiation of matrices</a></li>
<li><a href="../236693/index.html">Flight to Mars: non-Gomanov trajectory, aero braking and landing difficulties in a rarefied atmosphere</a></li>
<li><a href="../236699/index.html">Output video from multiple webcams on one page</a></li>
<li><a href="../236701/index.html">Available pre-order microcomputer Edison board for the Internet of things from Intel</a></li>
<li><a href="../236703/index.html">Modular Analog Synthesizers</a></li>
<li><a href="../236707/index.html">Using MagicalRecord when developing iOS applications</a></li>
<li><a href="../236709/index.html">With 1,000,000,000 a day in a year!</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>