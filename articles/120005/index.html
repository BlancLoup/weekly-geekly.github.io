<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Creating a programming language using LLVM. Part 2: Implementing Parser and AST</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Welcome to Chapter 2 of the tutorial "Creating a programming language with LLVM." In this chapter, we will see how to use the lexical analyzer created...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Creating a programming language using LLVM. Part 2: Implementing Parser and AST</h1><div class="post__text post__text-html js-mediator-article">  Welcome to Chapter 2 of the tutorial "Creating a programming language with LLVM."  In this chapter, we will see how to use the lexical analyzer created in <a href="http://habrahabr.ru/blogs/programming/119850/">Chapter 1</a> to build a complete <a href="http://ru.wikipedia.org/wiki/%25D0%259F%25D0%25B0%25D1%2580%25D1%2581%25D0%25B8%25D0%25BD%25D0%25B3">parser</a> for our Kaleidoscope language.  After we have the parser ready, we will build the <a href="http://ru.wikipedia.org/wiki/%25D0%2590%25D0%25B1%25D1%2581%25D1%2582%25D1%2580%25D0%25B0%25D0%25BA%25D1%2582%25D0%25BD%25D0%25BE%25D0%25B5_%25D1%2581%25D0%25B8%25D0%25BD%25D1%2582%25D0%25B0%25D0%25BA%25D1%2581%25D0%25B8%25D1%2587%25D0%25B5%25D1%2581%25D0%25BA%25D0%25BE%25D0%25B5_%25D0%25B4%25D0%25B5%25D1%2580%25D0%25B5%25D0%25B2%25D0%25BE">Abstract Syntax Tree (AST)</a> (Abstract Syntax Tree). <br><a name="habracut"></a><br>  We will develop the Kaleidoscope parser using the combination of <a href="http://ru.wikipedia.org/wiki/%25D0%259C%25D0%25B5%25D1%2582%25D0%25BE%25D0%25B4_%25D1%2580%25D0%25B5%25D0%25BA%25D1%2583%25D1%2580%25D1%2581%25D0%25B8%25D0%25B2%25D0%25BD%25D0%25BE%25D0%25B3%25D0%25BE_%25D1%2581%25D0%25BF%25D1%2583%25D1%2581%25D0%25BA%25D0%25B0">recursive descent</a> and <a href="http://en.wikipedia.org/wiki/Operator-precedence_parser">operator precedence</a> (the last for binary expressions and the first for everything else).  Before we move on to the parsing itself, let's talk about what we get at the output: Abstract Syntax Tree. <br><br><h1>  Abstract Syntax Tree (AST) </h1><br>  AST displays the program in such a way that for later stages of the compiler (for example, code generation) it is easily interpreted.  We need one object for each language construct.  In Kaleidoscope, we have expressions, prototypes, and functions.  Let's start with the expressions: <br><br><blockquote><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/// ExprAST -      . class ExprAST { public: virtual ~ExprAST() {} }; /// NumberExprAST -       (, "1.0"). class NumberExprAST : public ExprAST { double Val; public: NumberExprAST(double val) : Val(val) {} };</span></span></code> </pre> </blockquote><br>  The above code shows the definition of the base class ExprAST and its subclass that we use for numeric literals. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Now we will create only AST without various useful methods of working with it.  If necessary, you can, for example, quite easily add a virtual method of formatted code output.  Here are the node definitions for other AST expressions that we will use in Kaleidoscope: <br><br><blockquote><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/// VariableExprAST -      (, "a"). class VariableExprAST : public ExprAST { std::string Name; public: VariableExprAST(const std::string &amp;name) : Name(name) {} }; /// BinaryExprAST -      . class BinaryExprAST : public ExprAST { char Op; ExprAST *LHS, *RHS; public: BinaryExprAST(char op, ExprAST *lhs, ExprAST *rhs) : Op(op), LHS(lhs), RHS(rhs) {} }; /// CallExprAST -      . class CallExprAST : public ExprAST { std::string Callee; std::vector&lt;ExprAST*&gt; Args; public: CallExprAST(const std::string &amp;callee, std::vector&lt;ExprAST*&gt; &amp;args) : Callee(callee), Args(args) {} };</span></span></code> </pre></blockquote><br>  Everything is simple: the variable contains the name of the variable, the binary operator contains its opcode (for example, '+') and the left and right expressions (AST nodes), and the function calls contain the name of the function and a list of all the arguments.  One of the great things about AST is that it covers language features, regardless of the syntax of a programming language.  Please note that there are no controversial points about the priority of binary operators, lexical structure, etc. <br><br>  We have defined all nodes for expressions of our language.  It is not turing-complete, since it does not have a conditional control flow, we will fix this in the next section.  The following two things that we need are the interface of functions and the functions themselves: <br><br><blockquote><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/// PrototypeAST -    ""  , ///        (,  , ///    ). class PrototypeAST { std::string Name; std::vector&lt;std::string&gt; Args; public: PrototypeAST(const std::string &amp;name, const std::vector&lt;std::string&gt; &amp;args) : Name(name), Args(args) {} }; /// FunctionAST -     class FunctionAST { PrototypeAST *Proto; ExprAST *Body; public: FunctionAST(PrototypeAST *proto, ExprAST *body) : Proto(proto), Body(body) {} };</span></span></code> </pre></blockquote><br>  In Kaleidoscope, functions are typed only by the number of their arguments.  Since all values ‚Äã‚Äãare real double precision numbers, there is no point in storing the type of each argument anywhere.  In a real programming language, the class ‚ÄúExprAST‚Äù would probably contain another type field. <br><br>  Now we can finally talk about parsing expressions and functions in Kaleidoscope. <br><br><h1>  Parser base </h1><br>  Now that we have AST elements, we need to define a code parser in order to build it.  The idea here is that we want to parse something like ‚Äúx + y‚Äù (which is returned as three tokens with lexical parsing) to AST, which can be generated by something like this: <br><br><blockquote><pre> <code class="cpp hljs"> ExprAST *X = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> VariableExprAST(<span class="hljs-string"><span class="hljs-string">"x"</span></span>); ExprAST *Y = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> VariableExprAST(<span class="hljs-string"><span class="hljs-string">"y"</span></span>); ExprAST *Result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryExprAST(<span class="hljs-string"><span class="hljs-string">'+'</span></span>, X, Y);</code> </pre></blockquote><br>  Before doing this, we will define several auxiliary procedures: <br><br><blockquote><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/// CurTok/getNextToken -    . CurTok -   /// ,  . getNextToken     ///     CurTok. static int CurTok; static int getNextToken() { return CurTok = gettok(); }</span></span></code> </pre></blockquote><br>  This code implements the simplest token buffer on top of the lexical analyzer.  This allows us to look forward to a single token that will be returned by the lexical analyzer.  Each function in our parser will assume that CurTok is the current token to parse. <br><br><blockquote><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/// Error* -       . ExprAST *Error(const char *Str) { fprintf(stderr, "Error: %s\n", Str);return 0;} PrototypeAST *ErrorP(const char *Str) { Error(Str); return 0; } FunctionAST *ErrorF(const char *Str) { Error(Str); return 0; }</span></span></code> </pre></blockquote><br>  These are helper procedures that our parser will use to handle errors.  Correction of errors in our parser will be far from the best and not particularly user-friendly, but will be sufficient in the framework of this tutorial. <br><br>  With these support functions, we can implement the first part of our grammar: numeric literals. <br><br><h1>  Expression parsing </h1><br>  Let's start with the numeric literals, as with them the easiest.  For each grammar rule, we define a function that analyzes this rule.  For numeric literals, we have: <br><br><blockquote><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/// numberexpr ::= number static ExprAST *ParseNumberExpr() { ExprAST *Result = new NumberExprAST(NumVal); getNextToken(); //   return Result; }</span></span></code> </pre></blockquote><br>  The function is very simple: when calling, it expects the current token to be tok_number.  It creates a node <i>NumberExprAST</i> , passing it the value of the current number, moves the lexical analyzer to the next token and returns the created node. <br><br>  There are several interesting aspects.  The most important is that this function receives any tokens that match our grammar rule and returns the lexical analyzer buffer with the next token (which is not part of the grammar rule) ready for processing.  This is the standard way for parsing a recursive descent.  To better understand this, consider parsing the expression in parentheses: <br><br><blockquote><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/// parenexpr ::= '(' expression ')' static ExprAST *ParseParenExpr() { getNextToken(); //  (. ExprAST *V = ParseExpression(); if (!V) return 0; if (CurTok != ')') return Error("expected ')'"); getNextToken(); //  ). return V; }</span></span></code> </pre></blockquote><br>  This function illustrates a number of interesting things about the parser: <ol><li>  It shows how to use error procedures.  When called, the function expects the current token to be the '(' sign, but after parsing the subexpression, it is possible that there is no expected ')'.  For example, if the user enters "(4 x" instead of "(4)", then the analyzer should show an error. Since such errors may occur, the parser needs a way to indicate that they occurred: in our parser, if an error occurs, we return null. </li><li>  Another interesting aspect of this function is the use of recursion when calling <i>ParseExpression</i> (we will soon see that <i>ParseExpression</i> can call <i>ParseParenExpr</i> ).  This is a powerful mechanism, because it allows us to process recursive grammars and very easily cope with any rules of such grammars.  Please note that no AST nodes are built for parentheses.  The important role of brackets is to enable the parser to be grouped.  When the parser builds an AST, brackets are no longer needed. </li></ol>  The following grammatical rules are the handling of variable references and function calls: <br><br><blockquote><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/// identifierexpr /// ::= identifier /// ::= identifier '(' expression* ')' static ExprAST *ParseIdentifierExpr() { std::string IdName = IdentifierStr; getNextToken(); //  . if (CurTok != '(') //   . return new VariableExprAST(IdName); //  . getNextToken(); //  ( std::vector&lt;ExprAST*&gt; Args; if (CurTok != ')') { while (1) { ExprAST *Arg = ParseExpression(); if (!Arg) return 0; Args.push_back(Arg); if (CurTok == ')') break; if (CurTok != ',') return Error("Expected ')' or ',' in argument list"); getNextToken(); } } //  ')'. getNextToken(); return new CallExprAST(IdName, Args); }</span></span></code> </pre></blockquote><br>  This feature works the same as the previous ones.  (When called, it expects the current token to be tok_identifier).  It also uses recursion and error handling.  One interesting point is that she has to <i>look forward</i> to determine whether the current identifier is a reference to a variable or a function call.  This is a check, depending on whether the next token token is '(', causes either <i>VariableExprAST</i> or <i>CallExprAST</i> . <br><br>  Now that we have all the logic to parse the simplest expressions, we can define an auxiliary function to wrap it in one entry point.  We will call this class the expression ‚Äúprimary‚Äù for the reasons that will become clearer <a href="http://llvm.org/docs/tutorial/LangImpl6.html">by the end of the textbook</a> .  To parse an arbitrary primary expression, we must determine what the expression is: <br><br><blockquote><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/// primary /// ::= identifierexpr /// ::= numberexpr /// ::= parenexpr static ExprAST *ParsePrimary() { switch (CurTok) { default: return Error("unknown token when expecting an expression"); case tok_identifier: return ParseIdentifierExpr(); case tok_number: return ParseNumberExpr(); case '(': return ParseParenExpr(); } }</span></span></code> </pre></blockquote><br>  Now that we see the definition of this function, it becomes more obvious why we can assume any valid CurTok states in various functions.  It uses forward peeking to determine which kind of expression to check, and then the expression itself is analyzed in the appropriately called function. <br><br>  Now that basic expressions can be processed, we can work with binary expressions.  They are much more complicated. <br><br><h1>  Binary expression parsing </h1><br>  Binary expressions are much harder to make out because they are often ambiguous.  For example, for the string "x + y * z" the parser can parse either as "(x + y) * z" or as "x + (y * z)".  Knowing the basics of mathematics, we expect the second option, because "*" (multiplication) has a higher priority than "+" (addition). <br><br>  There are many possible solutions, but the most elegant and efficient way is to <a href="http://en.wikipedia.org/wiki/Operator-precedence_parser">parse the primacy (priority) of operators</a> .  This parsing technique uses recursion to prioritize operations.  First we need a priority table: <br><br><blockquote><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/// BinopPrecedence -      static std::map&lt;char, int&gt; BinopPrecedence; /// GetTokPrecedence -     . static int GetTokPrecedence() { if (!isascii(CurTok)) return -1; // ,     . int TokPrec = BinopPrecedence[CurTok]; if (TokPrec &lt;= 0) return -1; return TokPrec; } int main() { //     // 1 -  . BinopPrecedence['&lt;'] = 10; BinopPrecedence['+'] = 20; BinopPrecedence['-'] = 20; BinopPrecedence['*'] = 40; //  . ... }</span></span></code> </pre></blockquote><br>  Kaleidoscope will only support 4 binary operators (but it can obviously be extended by our brave and fearless reader).  The <i>GetTokPrecedence</i> function returns the priority of the current token, or -1 if the token is not a binary operator.  The presence of such a table makes it easy to add new operators and, of course, the algorithm does not depend on specific operators.  You can easily remove the priority table and make comparisons in the <i>GetTokPrecedence</i> function. <br><br>  Now we can start parsing binary expressions.  The main idea of ‚Äã‚Äãparsing the precedence of operators is to split an expression with potentially ambiguous binary operators into parts.  Consider, for example, the expression ‚Äúa + b + (c + d) * e * f + g‚Äù.  Operator Priority Parser treats it as a stream of primary expressions separated by binary operators.  Thus, during the initial parsing, the leading primary expression ‚Äúa‚Äù is first parsed, and it will see the pairs [+, b] [+, (c + d)] [*, e] [*, f] and [+, g ].  Pay attention to the brackets: the parser does not need to worry about nested expressions like (c + d). <br><br>  To begin with, an expression is a primary expression, potentially followed by a sequence of pairs [binop, primaryexpr]: <br><br><blockquote><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/// expression /// ::= primary binoprhs /// static ExprAST *ParseExpression() { ExprAST *LHS = ParsePrimary(); if (!LHS) return 0; return ParseBinOpRHS(0, LHS); }</span></span></code> </pre></blockquote><br>  <i>ParseBinOpRHS</i> is a function that analyzes the sequence of pairs.  It takes priority and a pointer to the expression to analyze.  Note that ‚Äúx‚Äù is an absolutely valid expression: thus, ‚Äúbinoprhs‚Äù may be empty, in which case the function returns an expression that was passed to it.  In our example above, the code sends the expression ‚Äúa‚Äù to <i>ParseBinOpRHS</i> and the current token ‚Äú+‚Äù. <br><br>  The priority value transmitted in ParseBinOpRHS indicates the <i>minimum priority of operators</i> necessary for it to be accepted.  For example, if the current pair in the stream [+, x] and priority 40 is transmitted in ParseBinOpRHS, it will not accept tokens (since the priority of "+" is only 20).  Therefore, ParseBinOpRHS starts with: <br><br><blockquote><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/// binoprhs /// ::= ('+' primary)* static ExprAST *ParseBinOpRHS(int ExprPrec, ExprAST *LHS) { //    ,    while (1) { int TokPrec = GetTokPrecedence(); //           , //  ,    if (TokPrec &lt; ExprPrec) return LHS;</span></span></code> </pre></blockquote><br>  This code takes the priority of the current token and checks how low it is.  Since we have defined invalid tokens that have a priority of -1, an implicit check occurs that determines when the stream of pairs ends.  If this test is successfully passed, we know that the token is exactly a binary operator and that it will be included in the expression: <br><br><blockquote><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ,  ,    . int BinOp = CurTok; getNextToken(); //    //       ExprAST *RHS = ParsePrimary(); if (!RHS) return 0;</span></span></code> </pre></blockquote><br>  Thus, this code gets (and remembers) the binary operator, and then analyzes the primary expression that follows it.  He creates pairs, the first of which in our example would be [+, b]. <br><br>  Now that we have parsed the left side of the expression and one pair from the RHS sequence, we have to decide how to link the expression.  In particular, we can have both "(a + b) binop unparsed" and "a + (b binop unparsed)" (where binop is a binary operator, unparsed is an unparsed part).  To determine, we look forward to another ‚Äúbinop‚Äù (binary operator) to determine its priority and compare it with the priority of BinOp (which in this case is ‚Äú+‚Äù): <br><br><blockquote><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">//  BinOp   RHS  ,    RHS, //      RHS  LHS. int NextPrec = GetTokPrecedence(); if (TokPrec &lt; NextPrec) {</span></span></code> </pre></blockquote><br>  If the priority of the binary operator to the right of ‚ÄúRHS‚Äù is less than or equal to the priority of our current operator, then we know that we have the case "(a + b) binop ...".  In our example, the current "+" operator and the next "+" operator have the same priority.  Therefore, we will create an AST node for ‚Äúa + b‚Äù, and then continue parsing: <br><br><blockquote><pre> <code class="cpp hljs"> ...     ... } <span class="hljs-comment"><span class="hljs-comment">//  LHS/RHS. LHS = new BinaryExprAST(BinOp, LHS, RHS); } }</span></span></code> </pre></blockquote><br>  In our example, ‚Äúa + b +‚Äù will be returned as ‚Äú(a + b)‚Äù and the next iteration of the loop will be executed, with ‚Äú+‚Äù as the current token.  This part will be accepted further, as you remember, should be parsed "(c + d)" as the primary expression, that is, the current pair will be [+, (c + d)].  Then an expression with "*" as a binary operator will be obtained.  In this case, the priority "*" is higher than the priority "+", so the above conditional construction will be executed. <br><br>  The most important question here for the left part will be ‚Äúhow to disassemble the right part in full in this condition‚Äù?  In particular, in order to correctly construct an AST for our example, it must receive the full expression "(c + d) * e * f" as the variable of the RHS expression.  The code for this is surprisingly simple (the code from the above two blocks is duplicated for context): <br><br><blockquote><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">//  BinOp   RHS  ,    RHS, //      RHS  LHS. int NextPrec = GetTokPrecedence(); if (TokPrec &lt; NextPrec) {</span></span></code> </pre> <pre> <code class="cpp hljs"> RHS = ParseBinOpRHS(TokPrec+<span class="hljs-number"><span class="hljs-number">1</span></span>, RHS); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (RHS == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <pre> <code class="cpp hljs"> } <span class="hljs-comment"><span class="hljs-comment">//  LHS/RHS. LHS = new BinaryExprAST(BinOp, LHS, RHS); } }</span></span></code> </pre></blockquote><br>  At the moment, we know that the binary operator on the right side of our primary expression has higher priority than the binary operator that is currently being parsed.  Thus, we know that any sequences of pairs of operators having a higher priority than the "+" must be disassembled together and returned as "RHS".  To do this, we recursively call the ParseBinOpRHS function with the ‚ÄúTokPrec + 1‚Äù parameter as the minimum priority necessary to continue.  In our long-suffering example, this will cause the AST node to return to "(c + d) * e * f" as RHS, which then becomes the right side for the expression with '+'. <br><br>  Finally, on the next iteration of the while loop, the "+ g" part is analyzed and added to the AST.  With this small code snippet (14 lines), we correctly handle any binary expressions with an elegant parsing method.  It was just a quick review of the code, so I recommend you try it with a few examples to see how it works. <br><br>  This completes the processing of expressions.  At the moment, we can already indicate to the analyzer an arbitrary stream of tokens and construct an expression from it, dwelling on the first token that is not part of the expression.  Now we need to deal with the declaration of functions, etc. <br><br><h1>  Parsing everything else </h1><br>  The next thing we lack is the processing of the function prototypes.  In Kaleidoscope, they are used both to declare "external" (extern) functions, and to declare the body of functions.  The code for this part of the parsing will be straightforward and not very interesting (after you have gone through the expression parsing): <br><br><blockquote><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/// prototype /// ::= id '(' id* ')' static PrototypeAST *ParsePrototype() { if (CurTok != tok_identifier) return ErrorP("Expected function name in prototype"); std::string FnName = IdentifierStr; getNextToken(); if (CurTok != '(') return ErrorP("Expected '(' in prototype"); //    . std::vector&lt;std::string&gt; ArgNames; while (getNextToken() == tok_identifier) ArgNames.push_back(IdentifierStr); if (CurTok != ')') return ErrorP("Expected ')' in prototype"); //  . getNextToken(); //  ')'. return new PrototypeAST(FnName, ArgNames); }</span></span></code> </pre></blockquote><br>  Given the simplicity of the function declaration, the function body will contain a prototype + expression: <br><br><blockquote><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/// definition ::= 'def' prototype expression static FunctionAST *ParseDefinition() { getNextToken(); //  def. PrototypeAST *Proto = ParsePrototype(); if (Proto == 0) return 0; if (ExprAST *E = ParseExpression()) return new FunctionAST(Proto, E); return 0; }</span></span></code> </pre></blockquote><br><br>  In addition, extern support is needed to declare functions like sin and cos, as well as to support the premature declaration of user-defined functions.  'extern' will consist only of a prototype without a body: <br><br><blockquote><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/// external ::= 'extern' prototype static PrototypeAST *ParseExtern() { getNextToken(); //  extern. return ParsePrototype(); }</span></span></code> </pre></blockquote><br>  Finally, we need to allow the user to enter arbitrary top-level expressions and calculate them on the fly.  We will process them, defining for them anonymous nullary (without arguments) functions: <br><br><blockquote><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/// toplevelexpr ::= expression static FunctionAST *ParseTopLevelExpr() { if (ExprAST *E = ParseExpression()) { //   . PrototypeAST *Proto = new PrototypeAST("", std::vector&lt;std::string&gt;()); return new FunctionAST(Proto, E); } return 0; }</span></span></code> </pre></blockquote><br>  Now that we have all the parts, let's create a small control program that will allow us to try out all the code that we wrote! <br><br><h1>  Control program </h1><br>  The control program simply calls the parsing cyclically.  There is nothing interesting here, see the section ‚ÄúTop level parsing‚Äù in the full code below. <br><br><blockquote><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/// top ::= definition | external | expression | ';' static void MainLoop() { while (1) { fprintf(stderr, "ready&gt; "); switch (CurTok) { case tok_eof: return; case ';': getNextToken(); break; //  ';'  . case tok_def: HandleDefinition(); break; case tok_extern: HandleExtern(); break; default: HandleTopLevelExpression(); break; } } }</span></span></code> </pre></blockquote><br>  The most interesting part of this code is that we ignore high-level semicolons.  You ask why?  The main reason is that if you enter ‚Äú4 + 5‚Äù on the command line, the parser does not know that this is the end, will you continue to enter text. ,      ¬´def foo ...¬ª,    4 +5 ‚Äî     ,      "* 6",  .         ¬´4+5;¬ª    ,    . <br><br><h1>  findings </h1><br>     400    (240      ),       ,        AST.     Kaleidoscope       ,    .    : <br><br><blockquote> <code>$ <b>./a.out</b> <br> ready&gt; <b>def foo(xy) x+foo(y, 4.0);</b> <br> Parsed a function definition. <br> ready&gt; <b>def foo(xy) x+yy;</b> <br> Parsed a function definition. <br> Parsed a top-level expr <br> ready&gt; <b>def foo(xy) x+y );</b> <br> Parsed a function definition. <br> Error: unknown token when expecting an expression <br> ready&gt; <b>extern sin(a);</b> <br> ready&gt; Parsed an extern <br> ready&gt; <b>^D</b> <br> $ <br></code> </blockquote><br>      .      AST,    ,  ..     ,  AST  LLVM Intermediate Representation (IR) ( ). <br><br><h1>    </h1><br>          . ,    :    LLVM  -  . (,  ,   C  C++).     : <br><br><blockquote> <code>#  <br> g++ -g -O3 toy.cpp <br> #  <br> ./a.out <br></code> </blockquote><br> ,   : <br><br><blockquote><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;string&gt; #include &lt;map&gt; #include &lt;vector&gt; //===----------------------------------------------------------------------===// // Lexer ( ) //===----------------------------------------------------------------------===// //     [0-255],   , //       enum Token { tok_eof = -1, //  ( ) tok_def = -2, tok_extern = -3, //  ( : , ) tok_identifier = -4, tok_number = -5 }; static std::string IdentifierStr; // ,  tok_identifier static double NumVal; // ,  tok_number /// gettok -       . static int gettok() { static int LastChar = ' '; //  . while (isspace(LastChar)) LastChar = getchar(); if (isalpha(LastChar)) { // : [a-zA-Z][a-zA-Z0-9]* IdentifierStr = LastChar; while (isalnum((LastChar = getchar()))) IdentifierStr += LastChar; if (IdentifierStr == "def") return tok_def; if (IdentifierStr == "extern") return tok_extern; return tok_identifier; } if (isdigit(LastChar) || LastChar == '.') { // : [0-9.]+ std::string NumStr; do { NumStr += LastChar; LastChar = getchar(); } while (isdigit(LastChar) || LastChar == '.'); NumVal = strtod(NumStr.c_str(), 0); return tok_number; } if (LastChar == '#') { //     do LastChar = getchar(); while (LastChar != EOF &amp;&amp; LastChar != '\n' &amp;&amp; LastChar != '\r'); if (LastChar != EOF) return gettok(); } //   . if (LastChar == EOF) return tok_eof; //         ASCII int ThisChar = LastChar; LastChar = getchar(); return ThisChar; } //===----------------------------------------------------------------------===// // Abstract Syntax Tree (     ) //===----------------------------------------------------------------------===// /// ExprAST -      . class ExprAST { public: virtual ~ExprAST() {} }; /// NumberExprAST -       (, "1.0"). class NumberExprAST : public ExprAST { double Val; public: NumberExprAST(double val) : Val(val) {} }; /// VariableExprAST -      (, "a"). class VariableExprAST : public ExprAST { std::string Name; public: VariableExprAST(const std::string &amp;name) : Name(name) {} }; /// BinaryExprAST -      . class BinaryExprAST : public ExprAST { char Op; ExprAST *LHS, *RHS; public: BinaryExprAST(char op, ExprAST *lhs, ExprAST *rhs) : Op(op), LHS(lhs), RHS(rhs) {} }; /// CallExprAST -      . class CallExprAST : public ExprAST { std::string Callee; std::vector&lt;ExprAST*&gt; Args; public: CallExprAST(const std::string &amp;callee, std::vector&lt;ExprAST*&gt; &amp;args) : Callee(callee), Args(args) {} }; /// PrototypeAST -    ""  , ///        (,  , ///    ). class PrototypeAST { std::string Name; std::vector&lt;std::string&gt; Args; public: PrototypeAST(const std::string &amp;name, const std::vector&lt;std::string&gt; &amp;args) : Name(name), Args(args) {} }; /// FunctionAST -     class FunctionAST { PrototypeAST *Proto; ExprAST *Body; public: FunctionAST(PrototypeAST *proto, ExprAST *body) : Proto(proto), Body(body) {} }; //===----------------------------------------------------------------------===// // Parser (   ) //===----------------------------------------------------------------------===// /// CurTok/getNextToken -    . CurTok -   /// ,  . getNextToken     ///     CurTok. static int CurTok; static int getNextToken() { return CurTok = gettok(); } /// BinopPrecedence -      static std::map&lt;char, int&gt; BinopPrecedence; /// GetTokPrecedence -     . static int GetTokPrecedence() { if (!isascii(CurTok)) return -1; // ,     . int TokPrec = BinopPrecedence[CurTok]; if (TokPrec &lt;= 0) return -1; return TokPrec; } /// Error* -       . ExprAST *Error(const char *Str) { fprintf(stderr, "Error: %s\n", Str);return 0;} PrototypeAST *ErrorP(const char *Str) { Error(Str); return 0; } FunctionAST *ErrorF(const char *Str) { Error(Str); return 0; } static ExprAST *ParseExpression(); /// identifierexpr /// ::= identifier /// ::= identifier '(' expression* ')' static ExprAST *ParseIdentifierExpr() { std::string IdName = IdentifierStr; getNextToken(); //  . if (CurTok != '(') //  . return new VariableExprAST(IdName); //  . getNextToken(); //  ( std::vector&lt;ExprAST*&gt; Args; if (CurTok != ')') { while (1) { ExprAST *Arg = ParseExpression(); if (!Arg) return 0; Args.push_back(Arg); if (CurTok == ')') break; if (CurTok != ',') return Error("Expected ')' or ',' in argument list"); getNextToken(); } } //  ')'. getNextToken(); return new CallExprAST(IdName, Args); } /// numberexpr ::= number static ExprAST *ParseNumberExpr() { ExprAST *Result = new NumberExprAST(NumVal); getNextToken(); //   return Result; } /// parenexpr ::= '(' expression ')' static ExprAST *ParseParenExpr() { getNextToken(); //  (. ExprAST *V = ParseExpression(); if (!V) return 0; if (CurTok != ')') return Error("expected ')'"); getNextToken(); //  ). return V; } /// primary /// ::= identifierexpr /// ::= numberexpr /// ::= parenexpr static ExprAST *ParsePrimary() { switch (CurTok) { default: return Error("unknown token when expecting an expression"); case tok_identifier: return ParseIdentifierExpr(); case tok_number: return ParseNumberExpr(); case '(': return ParseParenExpr(); } } /// binoprhs /// ::= ('+' primary)* static ExprAST *ParseBinOpRHS(int ExprPrec, ExprAST *LHS) { //    ,    while (1) { int TokPrec = GetTokPrecedence(); //           , //  ,    if (TokPrec &lt; ExprPrec) return LHS; // ,  ,    . int BinOp = CurTok; getNextToken(); // eat binop //       ExprAST *RHS = ParsePrimary(); if (!RHS) return 0; //  BinOp   RHS  ,    RHS, //      RHS  LHS. int NextPrec = GetTokPrecedence(); if (TokPrec &lt; NextPrec) { RHS = ParseBinOpRHS(TokPrec+1, RHS); if (RHS == 0) return 0; } //  LHS/RHS. LHS = new BinaryExprAST(BinOp, LHS, RHS); } } /// expression /// ::= primary binoprhs /// static ExprAST *ParseExpression() { ExprAST *LHS = ParsePrimary(); if (!LHS) return 0; return ParseBinOpRHS(0, LHS); } /// prototype /// ::= id '(' id* ')' static PrototypeAST *ParsePrototype() { if (CurTok != tok_identifier) return ErrorP("Expected function name in prototype"); std::string FnName = IdentifierStr; getNextToken(); if (CurTok != '(') return ErrorP("Expected '(' in prototype"); //    . std::vector&lt;std::string&gt; ArgNames; while (getNextToken() == tok_identifier) ArgNames.push_back(IdentifierStr); if (CurTok != ')') return ErrorP("Expected ')' in prototype"); //  . getNextToken(); //  ')'. return new PrototypeAST(FnName, ArgNames); } /// definition ::= 'def' prototype expression static FunctionAST *ParseDefinition() { getNextToken(); //  def. PrototypeAST *Proto = ParsePrototype(); if (Proto == 0) return 0; if (ExprAST *E = ParseExpression()) return new FunctionAST(Proto, E); return 0; } /// toplevelexpr ::= expression static FunctionAST *ParseTopLevelExpr() { if (ExprAST *E = ParseExpression()) { //   . PrototypeAST *Proto = new PrototypeAST("", std::vector&lt;std::string&gt;()); return new FunctionAST(Proto, E); } return 0; } /// external ::= 'extern' prototype static PrototypeAST *ParseExtern() { getNextToken(); //  extern. return ParsePrototype(); } //===----------------------------------------------------------------------===// // Top-Level parsing (  ) //===----------------------------------------------------------------------===// static void HandleDefinition() { if (ParseDefinition()) { fprintf(stderr, "Parsed a function definition.\n"); } else { //      . getNextToken(); } } static void HandleExtern() { if (ParseExtern()) { fprintf(stderr, "Parsed an extern\n"); } else { //      . getNextToken(); } } static void HandleTopLevelExpression() { //      . if (ParseTopLevelExpr()) { fprintf(stderr, "Parsed a top-level expr\n"); } else { //      . getNextToken(); } } /// top ::= definition | external | expression | ';' static void MainLoop() { while (1) { fprintf(stderr, "ready&gt; "); switch (CurTok) { case tok_eof: return; case ';': getNextToken(); break; //     . case tok_def: HandleDefinition(); break; case tok_extern: HandleExtern(); break; default: HandleTopLevelExpression(); break; } } } //===----------------------------------------------------------------------===// // Main driver code (  ) //===----------------------------------------------------------------------===// int main() { //    . // 1 -  . BinopPrecedence['&lt;'] = 10; BinopPrecedence['+'] = 20; BinopPrecedence['-'] = 20; BinopPrecedence['*'] = 40; // highest. fprintf(stderr, "ready&gt; "); getNextToken(); //    " ". MainLoop(); return 0; }</span></span></span></span></code> </pre></blockquote><br><br>  <b>PS</b> <b><br>      ,            ¬´ ¬ª,      ( ).   ,      , ,    :)</b> </div><p>Source: <a href="https://habr.com/ru/post/120005/">https://habr.com/ru/post/120005/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../120000/index.html">Refactoring syndrome</a></li>
<li><a href="../120001/index.html">Kazakhstanis are sent to the App Store or How to make an application in a week</a></li>
<li><a href="../120002/index.html">III Festival of Contemporary Spanish Design</a></li>
<li><a href="../120003/index.html">Oracle DB for programmer</a></li>
<li><a href="../120004/index.html">Drupal 7.2 released</a></li>
<li><a href="../120006/index.html">Skype: Microsoft did not "kill" Asterisk support</a></li>
<li><a href="../120008/index.html">Billion tables ?!</a></li>
<li><a href="../120009/index.html">How to become a system administrator - a guide for beginners (part 4)</a></li>
<li><a href="../120010/index.html">How often do you mow?</a></li>
<li><a href="../120013/index.html">Commentary of the day: Server Spring</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>