<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Simple interpreter from scratch in Python # 2</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the previous article, we looked at the IMP language itself and the basic structure of the interpreter. Also, we carefully considered lexer. In this...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Simple interpreter from scratch in Python # 2</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/55d/ea9/8b3/55dea98b3e1964a8050a64d77f5bf4e3.png"><br><br>  In the previous article, we looked at the IMP language itself and the basic structure of the interpreter.  Also, we carefully considered lexer.  In this article we will write a small parser for our language.  It will extract an AST (abstract syntax tree) from the list of tokens generated by the lexer.  The combinator library will be independent, that is, using it you can write a parser for any language. <br><br><div class="spoiler">  <b class="spoiler_title">Content</b> <div class="spoiler_text">  <a href="http://habrahabr.ru/post/206320/">Simple interpreter from scratch in Python # 1</a> <br>  <b>Simple interpreter from scratch in Python # 2</b> <br>  <a href="http://habrahabr.ru/post/208872/">Simple interpreter from scratch in Python # 3</a> <br>  <a href="http://habrahabr.ru/post/207662/">Simple interpreter from scratch in Python # 4</a> <br></div></div><br><h5>  What are parser combinators? </h5><br>  There are so many ways to write a parser.  The simplest and fastest way to do this are the <b>combinators</b> . 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      You can think of a parser as a function that accepts a stream of tokens.  If successful, the parser will <i>‚Äúeat up‚Äù</i> some tokens from the stream.  The function will return part of the final AST along with the other tokens.  A combinator is a function that produces a parser as its result, usually after taking one or several analyzers (parsers) as input, hence the name ‚Äúcombinator‚Äù.  You can use combinators to create a complete parser for a language, like an IMP, by creating a set of small parsers for each part of the language. <br><a name="habracut"></a><br><h5>  Our little combinator </h5><br>  Combinator analyzers are quite common, <i>ordinary</i> , can be used for any language.  We start by writing the agnostic library of combinators, as we did with the lexer, and then use this to write the parser. <br><br>  First, let's create a <b>Result</b> class.  Each parser will return an instance of the Result class (if successful), or None if unsuccessful.  Result includes value (value, part of AST) and position (index of the next token in the stream). <br><br><pre><code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Result</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, value, pos)</span></span></span><span class="hljs-function">:</span></span> self.value = value self.pos = pos <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__repr__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'Result(%s, %d)'</span></span> % (self.value, self.pos)</code> </pre> <br><br>  Next we create the main class <b>Parser</b> .  Before, I said that parsers are functions that take a stream of tokens.  In fact, we will define parsers as objects with the <b>__call__</b> method <b>.</b>  This means that the parser object will behave as if it were a function, but we can also provide additional functionality by creating statements. <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Parser</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__call__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, tokens, pos)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-comment"><span class="hljs-comment"># subclasses will override this def __add__(self, other): return Concat(self, other) def __mul__(self, other): return Exp(self, other) def __or__(self, other): return Alternate(self, other) def __xor__(self, function): return Process(self, function)</span></span></code> </pre><br><br>  The method that actually performs the parsing is <b>__call__.</b>  The input data is the complete list of tokens (created by the lexer) and the index of the list, indicating the next token.  The default implementation always returns <b>None</b> .  Subclasses will have their own method __call__. <br><br>  Methods such as <b>__add__, __mul__, __or__,</b> and <b>__xor__</b> define <b>+, *, |</b>  and <b>^</b> operators respectively.  Each operator provides a shortcut to call a specific combinator.  We will look at each one in brief. <br><br>  Now we look at a simple combinator called <b>Reserved.</b>  Reserved will be used to parse reserved words and operators;  it will accept tokens with a specific value and tag.  Remember that tokens are a tag-value pair.  token [0] - value, token [1] - tag. <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Reserved</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Parser)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, value, tag)</span></span></span><span class="hljs-function">:</span></span> self.value = value self.tag = tag <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__call__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, tokens, pos)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> pos &lt; len(tokens) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> \ tokens[pos][<span class="hljs-number"><span class="hljs-number">0</span></span>] == self.value <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> \ tokens[pos][<span class="hljs-number"><span class="hljs-number">1</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> self.tag: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Result(tokens[pos][<span class="hljs-number"><span class="hljs-number">0</span></span>], pos + <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span></code> </pre><br><br>  Now you can say: <i>‚ÄúI thought that the combinators should be functions that return parsers.‚Äù The</i> subclass does not look like a function at all.  A subclass is <i>like a</i> function if you think of a constructor as a function that returns an object (which is <i>callable</i> in this case).  Subclassing is a simple way to define new combinators, since we only need to provide a constructor and a __call__ method, and we still retain the rest of the functionality (for example, operator overloading). <br><br>  Moving on.  Combinator <b>Tag is</b> very similar to Reserved.  It finds tokens corresponding to a specific tag.  The value can be anything. <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tag</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Parser)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, tag)</span></span></span><span class="hljs-function">:</span></span> self.tag = tag <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__call__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, tokens, pos)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> pos &lt; len(tokens) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> tokens[pos][<span class="hljs-number"><span class="hljs-number">1</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> self.tag: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Result(tokens[pos][<span class="hljs-number"><span class="hljs-number">0</span></span>], pos + <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span></code> </pre><br><br>  Tag and Reserved combinators are our primitives.  All other combinators will be built from them at the most basic level. <br><br>  <b>Concat combinator</b> takes two parsers as input (left and right).  When using the Concat parser, it will use the left parser, and then the right one [parser].  If both are successful, the resulting value will contain a pair of left and right results.  If at least one does not work, then None will return. <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Concat</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Parser)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, left, right)</span></span></span><span class="hljs-function">:</span></span> self.left = left self.right = right <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__call__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, tokens, pos)</span></span></span><span class="hljs-function">:</span></span> left_result = self.left(tokens, pos) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> left_result: right_result = self.right(tokens, left_result.pos) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> right_result: combined_value = (left_result.value, right_result.value) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Result(combined_value, right_result.pos) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span></code> </pre><br><br>  Concat is useful for parsing a specific sequence of tokens.  For example, for parsing <b>1 + 2</b> , you can write <br><br><pre> <code class="python hljs">parser = Concat(Concat(Tag(INT), Reserved(<span class="hljs-string"><span class="hljs-string">'+'</span></span>, RESERVED)), Tag(INT))</code> </pre> <br><br>  or more briefly using the shorthand operator <br><br><pre> <code class="python hljs">parser = Tag(INT) + Reserved(<span class="hljs-string"><span class="hljs-string">'+'</span></span>, RESERVED) + Tag(INT)</code> </pre> <br><br>  <b>Alternative</b> Combinator is also very similar to previous ones.  It also accepts left- and right-parsers.  If successful, the result is returned, otherwise - it takes the right-parser and returns its result. <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Alternate</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Parser)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, left, right)</span></span></span><span class="hljs-function">:</span></span> self.left = left self.right = right <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__call__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, tokens, pos)</span></span></span><span class="hljs-function">:</span></span> left_result = self.left(tokens, pos) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> left_result: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> left_result <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: right_result = self.right(tokens, pos) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> right_result</code> </pre><br><br>  Alternative is useful when selecting possible parsers.  For example, if we need to parse a binary operator: <br><br><pre> <code class="python hljs">parser = Reserved(<span class="hljs-string"><span class="hljs-string">'+'</span></span>, RESERVED) | Reserved(<span class="hljs-string"><span class="hljs-string">'-'</span></span>, RESERVED) | Reserved(<span class="hljs-string"><span class="hljs-string">'*'</span></span>, RESERVED) | Reserved(<span class="hljs-string"><span class="hljs-string">'/'</span></span>, RESERVED)</code> </pre><br><br>  The <b>Opt</b> class is useful for additional text, such as else.  It takes one parser.  If this parser is successful, the result is returned normally.  If not, the successful result is still returned, but its value is None.  Tokens are not consumed in case of failure;  position of the result is the same as the position of the input. <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Opt</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Parser)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, parser)</span></span></span><span class="hljs-function">:</span></span> self.parser = parser <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__call__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, tokens, pos)</span></span></span><span class="hljs-function">:</span></span> result = self.parser(tokens, pos) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> result: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Result(<span class="hljs-keyword"><span class="hljs-keyword">None</span></span>, pos)</code> </pre><br><br>  <b>Rep</b> accepts the parser until it fails.  This is useful for building lists.  Remember that Rep will successfully match the empty list and will not absorb tokens if the parser fails the first time. <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Rep</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Parser)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, parser)</span></span></span><span class="hljs-function">:</span></span> self.parser = parser <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__call__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, tokens, pos)</span></span></span><span class="hljs-function">:</span></span> results = [] result = self.parser(tokens, pos) <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> result: results.append(result.value) pos = result.pos result = self.parser(tokens, pos) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Result(results, pos)</code> </pre><br><br>  The <b>Process</b> Combinator is very useful for manipulating the values ‚Äã‚Äãof results.  Its input is a parser and a function.  When the parser is successful, the resulting value is sent to the function instead of the original value returned from the function.  We will use Process to build AST nodes from pairs and lists (returned by Concat and Rep). <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Process</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Parser)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, parser, function)</span></span></span><span class="hljs-function">:</span></span> self.parser = parser self.function = function <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__call__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, tokens, pos)</span></span></span><span class="hljs-function">:</span></span> result = self.parser(tokens, pos) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> result: result.value = self.function(result.value) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result</code> </pre><br><br>  As an example, consider the parser that we built with Concat.  When he parses <b>1 + 1</b> , the result will be <b>(('1', '+'), '2')</b> , which is not very convenient.  With Process we can change the result.  The following code will return the sum of these two numbers, for example. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">process_func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(parsed)</span></span></span><span class="hljs-function">:</span></span> ((l, _), r) = parsed <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> int(l) + int(r) better_parser = parser ^ process_func</code> </pre><br><br>  <b>Lazy</b> is a less obvious combinator.  Instead of taking a parser as input, it takes a function with zero argument, which returns a parser.  Lazy Combinator will not call a function to get a parser until it is used.  This is needed to build recursive parsers.  Since the analyzer (parser) refers to itself, we cannot just take it and define it by reference;  while the parser expression is executed, it is not dated.  We don‚Äôt need it in languages ‚Äã‚Äãlike Haskell or Scala, since they use lazy expressions, but Python isn‚Äôt. <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Lazy</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Parser)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, parser_func)</span></span></span><span class="hljs-function">:</span></span> self.parser = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> self.parser_func = parser_func <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__call__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, tokens, pos)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> self.parser: self.parser = self.parser_func() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self.parser(tokens, pos)</code> </pre><br><br>  The next <b>Phrase</b> combinator takes a single parser to the input, applies it, and returns its result.  The only catch is that it will fail if it does not absorb <i>all the</i> tokens.  Phrase will be the analyzer of the top level.  It does not allow us to match programs that have garbage at the end. <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Phrase</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Parser)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, parser)</span></span></span><span class="hljs-function">:</span></span> self.parser = parser <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__call__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, tokens, pos)</span></span></span><span class="hljs-function">:</span></span> result = self.parser(tokens, pos) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> result <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> result.pos == len(tokens): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span></code> </pre><br><br>  Last combinator, unfortunately, the most difficult.  <b>Exp</b> meaning is very simple;  It is used to match (match) an expression, which consists of a list of elements separated by something.  Here is an example of compound statements: <br><br><pre> <code class="python hljs">a := <span class="hljs-number"><span class="hljs-number">10</span></span>; b := <span class="hljs-number"><span class="hljs-number">20</span></span>; c := <span class="hljs-number"><span class="hljs-number">30</span></span></code> </pre><br><br>  In this case, we have a list of operators, which are separated by a semicolon.  You may think that we do not need Exp, since we can do the same with the help of other combinators.  You can write a parser for such expressions: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">compound_stmt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> stmt() + Reserved(<span class="hljs-string"><span class="hljs-string">';'</span></span>, RESERVED) + stmt()</code> </pre><br><br>  Create stmt: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stmt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Lazy(compound_stmt) | assign_stmt()</code> </pre><br><br>  So stmt calls compound_stmt, which calls stmt.  They will call each other until we get a buffer overflow.  This problem is not unique to compound operators, and is called left recursion. <br><br>  Fortunately, Exp provides an opportunity to bypass the left recursion, simply by sorting out the list (relatively as well as Rep).  Exp takes two parsers to enter.  The first parser corresponds to the real elements of the list, and the second separators.  If successful, the second parser should return a function that combines the disassembled elements on the left and right in one value.  This value accumulates from the entire list, from left to right, and ultimately returns. <br><br>  Let's look at the code: <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Exp</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Parser)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, parser, separator)</span></span></span><span class="hljs-function">:</span></span> self.parser = parser self.separator = separator <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__call__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, tokens, pos)</span></span></span><span class="hljs-function">:</span></span> result = self.parser(tokens, pos) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">process_next</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(parsed)</span></span></span><span class="hljs-function">:</span></span> (sepfunc, right) = parsed <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sepfunc(result.value, right) next_parser = self.separator + self.parser ^ process_next next_result = result <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> next_result: next_result = next_parser(tokens, result.pos) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> next_result: result = next_result <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result</code> </pre><br><br>  <b>result</b> will contain everything that has been written for all the time.  The <b>process_next</b> function can be used with the <b>Process</b> combinator.  <b>next_parser</b> takes <b>separator</b> and then <b>parser</b> to get the next list item.  <b>process_next</b> will create a new result by taking the separator function for the current result and for the newly-parsed element.  <b>The next_parser is</b> received in a loop while it is able to accept items. <br><br>  Let's see how Exp can be used to solve the compound_stmt problem: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">assign_stmt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">compound_sep</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">process_sep</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(parsed)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> l, r: CompoundStmt(l, r) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Reserved(<span class="hljs-string"><span class="hljs-string">';'</span></span>, RESERVED) ^ process_sep <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">compound_stmt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Exp(assign_stmt(), compound_sep())</code> </pre><br><br>  We can even write this: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">compound_stmt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> assign_stmt() * compound_sep()</code> </pre><br><br>  We delve into this when we consider the analysis of arithmetic expressions in the next article. <br><br>  Download full source code: <a href="">imp-interpreter.tar.gz</a> </div><p>Source: <a href="https://habr.com/ru/post/206454/">https://habr.com/ru/post/206454/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../206436/index.html">Review of literature read in two years</a></li>
<li><a href="../206440/index.html">As we wrote a scientific work with a schoolboy</a></li>
<li><a href="../206442/index.html">Laravel: Dependency Injection in practice</a></li>
<li><a href="../206444/index.html">Chicago woodpile - 1: The world's first nuclear reactor</a></li>
<li><a href="../206448/index.html">Mobidapter genial adapter of the past</a></li>
<li><a href="../206456/index.html">Meteor version 0.7.0 released</a></li>
<li><a href="../206458/index.html">Auto and decltype secrets</a></li>
<li><a href="../206460/index.html">How to make yourself work?</a></li>
<li><a href="../206464/index.html">Mobile VDS server management</a></li>
<li><a href="../206468/index.html">Solving Major CAPTCHA Problems</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>