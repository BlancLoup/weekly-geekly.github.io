<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Why does the speed of writing to the RAID decrease as the SSD fills, or why do we need TRIM</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This problem is most relevant for hardware RAID or firmware RAID (such as Intel RST RAID 1/10/5/6) with non-industrial SSDs. 

 SSD feature 
 SSDs wri...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Why does the speed of writing to the RAID decrease as the SSD fills, or why do we need TRIM</h1><div class="post__text post__text-html js-mediator-article">  This problem is most relevant for hardware RAID or firmware RAID (such as Intel RST RAID 1/10/5/6) with non-industrial SSDs. <br><br><h4>  SSD feature </h4><br>  SSDs write and read data in pages, you can only write to cleaned pages, and you can clear pages only in big blocks.  For example, a disk has a page size of 8 KB, the block contains 128 pages, so the block size is 1024 KB (hereinafter, unless otherwise indicated, the KB and MB are binary). <br><br>  For example, if you change 40 KB in one file, then at the physical level it will look like this: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/files/4ba/5a2/a95/4ba5a2a952a843bc8a643d03b39cda18.png"><br><a name="habracut"></a><br>  At the logical level, everything looks as usual - the data will be overwritten on top of the corresponding sectors.  As soon as in block 1 there are only empty and ready-to-clear pages, this block is erased and becomes empty entirely. <br><br>  To hide the physical implementation, the disk supports a map of logical and physical page numbers (Flash Translation Layer). <br><br>  So far we see only one way that the physical page can become cleansed again - if new data is written to its logical address.  The fact is that the disk controller works at the page level and does not know anything about the file system, and the operating system does not notify the disk about the deleted files which sectors can be cleared.  It is easy to see that sooner or later each page of the disk will be occupied and it will have nowhere to write data. <br><br>  To solve this problem, the <a href="http://www.thomas-krenn.com/en/wiki/ATA_Trim">ATA TRIM command</a> ( <a href="http://en.wikipedia.org/wiki/Trim_%2528computing%2529">wiki</a> ) was added.  The operating system sends it to the disk with the indication of the sectors that can be cleared.  The analogs of this command are SCSI UNMAP and CF ERASE.  Unfortunately, in some cases it is not possible to send it to the disk: <br>  - if the disk is in RAID with a hardware controller ( <a href="http://mycusthelp.info/LSI/_cs/AnswerDetail.aspx%3FsSessionID%3D21379102133MVGXNHSGDGYRNEPDVWWJVTQJAJMUJ%26inc%3D8039%26caller%3D~%252FFindAnswers.aspx%253FtxtCriteria%253Dtrim%2526sSessionid%253D21379102133MVGXNHSGDGYRNEPDVWWJVTQJAJMUJ">LSI</a> , <a href="http://ask.adaptec.com/app/answers/detail/a_id/16994">Adaptec</a> , etc.), <br>  - if the disks are in firmware-RAID, in particular, <a href="http://www.intel.com/support/chipsets/imsm/sb/CS-022304.htm%3Fwapkw%3Dtrim">Intel RST</a> RAID 1/10/5/6, <br>  - if the disk is connected via USB (protocol limitation), <br>  - if the disk is encrypted programmatically via TrueCrypt, dm-crypt, GELI, etc.  (may be supported, but usually not included for security reasons). <br><br>  If, as a result of <a href="https://github.com/CyberShadow/trimcheck">testing,</a> it turns out that the disk does not receive a TRIM command, then very few free pages may remain for recording.  But they will be: each disk contains some reserved area, which serves as a reserve of free pages and a reserve of blocks for the replacement of completely worn out.  To find out the size of this area, you need to see how much physical memory is installed on the disk and how much LBA is indicated in the documentation. <br><br>  For example, Samsung SSD 840 Pro 512 GB has 512 GB of memory, while 1000215216 LBA sectors are available.  The reserve is: 512 √ó 1024 √ó 1024 √ó 1024 - 1000215216 √ó 512 = 35 GB or 6.85%.  The available disk capacity in this case is (512 - 35) √ó 1024 √ó 1024 √ó 1024 = 512 √ó 10 ^ 9 = 512 GB, already decimal.  Samsung SSD 850 Pro 128 GB has 129 GB onboard, 128 GB decimal is available to the user, the reserve is 7.6%. <br><br>  So, if we fill the entire disk, then delete all the files, then without the support of TRIM, the disk can write only to some part of 6.85% of the disk volume.  A part, because this reserve will partly consist of not completely empty blocks due to fragmentation.  The presence of this area allows you to somehow continue to overwrite files on disk. <br><br>  An example of a worse situation: there is nowhere to write, although the volume of pages occupied does not exceed the amount available to the user without a reserve. <br><br><img src="https://habrastorage.org/files/e53/58d/4db/e5358d4dbfde46e2b70e1b5bfd980a85.png"><br><br>  In this case, along with the recording, the garbage collector works, which will read the block into RAM, erase the block on the disk (long operation, erasing takes 3000 ¬µs compared to 900 ¬µs of writing to a blank page) and write the block from the RAM.  The delay also occurs due to the growth of <a href="http://en.wikipedia.org/wiki/Write_amplification">Write Amplification</a> - there are 5-10 physical write operations per logical write operation. <br><br>  Therefore, the more disk there is free space for maneuvers, the higher the recording speed.  The garbage collector in the background is not only cleaning and defragmenting blocks, but also uniformly distributing write / clear cycles (P / E) among the blocks so that they wear out in the same way. <br><br>  There is a popular myth that modern disks have such a good garbage collector that they don‚Äôt need TRIM.  This is absolutely not true; the garbage collector and the TRIM solve different problems. <br><br>  Industrial drives often have 50% and more backup areas, so the absence of TRIM is not critical for them.  The remaining disks most often do not have a clearly stated reserve area, or it is insufficient.  Tests show that over-provisioning <a href="http://www.anandtech.com/show/6489/playing-with-op">25</a> to <a href="http://www.aerospike.com/docs/operations/plan/ssd/ssd_setup.html">29</a> % of the total physical memory (including the spare area) has a good effect.  Therefore, if the disk does not have enough spare area, then you need to do over-provisioning yourself. <br><br>  There are three ways: <br>  - mark the disk in such a way as to leave some part of the unallocated area after creating the RAID, <br>  - use the ATA command to create the <a href="http://www.thomas-krenn.com/en/wiki/SSD_Over-provisioning_using_hdparm">Host protected area</a> ( <a href="http://www.matrix44.net/cms/notes/gnulinux/ubuntu-11-04-and-ssds">howto</a> ), before creating the RAID, <br>  - configure the RAID controller so that it uses only part of the disk capacity. <br><br><img src="https://habrastorage.org/files/e70/d98/15e/e70d9815e43b4855b5edd1b30fbc43df.png"><br><br>  Before allocating a free area, you need to let the disk know that this area is not occupied with anything, in one of two ways: <br>  - connect the drive to another controller and <a href="http://forum.crucial.com/t5/Crucial-SSDs/SSD-Tool-free-space-trimmer/td-p/51198%3Fcm_mmc%3Daffiliation-_-null-_-null-_-null">send</a> an ATA TRIM command (or using O &amp; O Defrag - there is a cli interface, Windows 8 built-in disk optimizer or Anvil's Storage Utilities), <br>  - do a full cleaning of the FTL table by sending the ATA Secure Erase command. <br><br>  There is a version that you can also make the disk understand that the blocks are not used if you write 0x00 or 0xFF there (the so-called ‚ÄúTony TRIM‚Äù method).  Perhaps for some controllers it works, but my tests showed no changes. <br><br><h4>  On practice </h4><br>  I have two Samsung SSD 540 Pro 512 GB disks in Intel RST RAID 1, on which Windows 8.1 is installed.  After a year of work, I measured the performance and was unpleasantly surprised.  After checking TRIM, I saw that it was not working. <br><br>  - <a href="https://github.com/CyberShadow/trimcheck">Check TRIM under Windows</a> <br>  - Check TRIM for Linux: <br><pre><code class="hljs vala"><span class="hljs-meta"><span class="hljs-meta"># lsblk -D</span></span></code> </pre>  The DISC-GRAN and DISC-MAX columns should both be greater than 0 for all participating components. <br><br>  Alternative option: <br><pre> <code class="hljs delphi"># dd <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>=/dev/urandom <span class="hljs-keyword"><span class="hljs-keyword">of</span></span>=tempfile bs=<span class="hljs-number"><span class="hljs-number">1</span></span>M count=<span class="hljs-number"><span class="hljs-number">3</span></span> # hdparm --fibmap tempfile # hdparm --<span class="hljs-keyword"><span class="hljs-keyword">read</span></span>-sector [ADDRESS] /dev/sda # rm tempfile &amp;&amp; sync &amp;&amp; sleep <span class="hljs-number"><span class="hljs-number">120</span></span> # hdparm --<span class="hljs-keyword"><span class="hljs-keyword">read</span></span>-sector [ADDRESS] /dev/sda</code> </pre>  After deleting a file, the disk should be 0x00 or 0xFF, but this is not a valid method: different disks behave differently. <br><br>  TRIM in real time is enabled with the ‚Äúdiscard‚Äù option when mounting a disk: <br><pre> <code class="hljs pgsql"># grep -i <span class="hljs-keyword"><span class="hljs-keyword">discard</span></span> /etc/fstab # mount | grep -i <span class="hljs-keyword"><span class="hljs-keyword">discard</span></span></code> </pre><br>  TRIM for single disk file systems and LVM is supported with Linux kernel 2.6.33.  TRIM for mdraid is <a href="">supported from the Linux 3.7 kernel</a> .  But it can also be ported to older kernel versions, for example, <a href="https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/6/html-single/6.5_Release_Notes/">supported on CentOS 6</a> . <br><br>  By default, Ubuntu makes TRIM scheduled once a week using fstrim, but only for single (not mdraid) disks from the following manufacturers: Intel, Samsung, OCZ, SanDisk, and Patriot, and if hdparm is installed. <br><br>  - TRIM check in FreeBSD: <br>  ZFS, by default, <a href="https://www.freebsd.org/releases/9.2R/relnotes.html">supports</a> TRIM since FreeBSD 9.2: <br><pre> <code class="hljs sql"><span class="hljs-comment"><span class="hljs-comment"># sysctl -a | grep -i 'zfs.*trim'</span></span></code> </pre><br>  GEOM RAID gmirror <a href="https://www.freebsd.org/releases/9.1R/relnotes-detailed.html">supports</a> TRIM with FreeBSD 9.1: <br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">gstat</span></span> -d</code> </pre>  column "d / s" - BIO_DELETE / second. <br><br>  Intel RST RAID only supports TRIM for RAID 1 type, as an exception: to enable, you need to make sure that the Intel RST driver is version 11 and above, and the OROM (Legacy boot) or SataDriver (UEFI boot) version 11 or higher firmware, or the old version, but <a href="http://www.win-raid.com/t7f13-AHCI-amp-RAID-ROM-Modules.html">patched</a> .  TRIM is supported in Intel RSTe RAID 0/1/10 since version 3.7.0.1093. <br><br>  I decided to create an unallocated disk partition for over-provisioning. <br>  1. With <a href="http://www.acronis.com/ru-ru/business/backup/">Acronis Backup,</a> I took a disk image.  Also saved the partition table (it is important to have the first sector, last sector, GPT partition type, GPT unique identifier, partition name). <br><br>  2. Rebooted in BIOS and made SSD Secure Erase.  If this item is not in the BIOS, then you can execute the command using <a href="http://www.thomas-krenn.com/en/wiki/SSD_Secure_Erase">hdparam</a> (or <a href="https://ata.wiki.kernel.org/index.php/ATA_Secure_Erase">here</a> and <a href="http://tinyapps.org/docs/wipe_drives_hdparm.html">here</a> , is under Windows), <a href="http://cmrr.ucsd.edu/people/Hughes/Secure-Erase.html">HDDErase</a> or <a href="http://www.hdat2.com/">HDAT2</a> . <br><br>  3. Assembled RAID 1 on two disks. <br><br>  Here it is necessary to make an important note: when the array is initialized, the RAID controller reads each sector from one disk and writes it to the second.  Theoretically, this <a href="https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/6/html/Storage_Administration_Guide/ch-ssd.html">should prevent</a> our entire undertaking, and there will be no over-provisioning on one disk.  But tests have shown that for some reason this method works.  I have no explanation for this. <br><br>  4. I booted from the LiveCD and using <a href="http://sourceforge.net/projects/gptfdisk/files/">GPT fdisk</a> created the necessary partition table: the last partition is 104 GB less than before.  Sections must be aligned (partition align) to the size of the disk page, and not to the block size. <br><br>  5. Restored from the backup each partition. <br><br>  After that, I completely filled out the disk and ran the tests.  This should show the worst case.  The Windows cache is turned on, regular write cache is turned off, Inter RST write-back is turned off, all tests use a fixed-size disk area of ‚Äã‚Äã40 GB.  Testing discs is not easy, since the indicators may vary over time.  Below are the steady state indicators. <br><br>  I will compare three states: <br>  - One disk without RAID, fully populated, the standard hidden backup area of ‚Äã‚Äã6.58%. <br>  - One disk without RAID, after running TRIM on it free space. <br>  - Two disks in RAID 1, fully populated, standard hidden backup area of ‚Äã‚Äã6.58%. <br>  - Two drives in RAID 1, fully populated, over-provisioning 27.24% (including hidden backup area). <br><br><img src="https://habrastorage.org/files/fd3/b91/666/fd3b916664a0461480ccfe21f5c4a16e.png"><br><div class="spoiler">  <b class="spoiler_title">Latency and standard deviation</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/51e/45d/074/51e45d074a164a20bed2d71aeb654887.png"></div></div><br><div class="spoiler">  <b class="spoiler_title">Table</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/7c1/f35/df5/7c1f35df56794f06aa2148ec29416675.png"><br></div></div><br>  Analysis of the results: <br>  - Reading from RAID 1 is faster than from one disk, despite the fact that we only have firmware RAID. <br>  - the record is faster, the more unallocated space: in the first place TRIM, in the second - our home-made over-provisioning. <br><br>  The steady state is not always reached quickly.  Let's see the latest configuration test (over-provisioning 27.24%) over time and see the worst case scenario: <br><br><img src="https://habrastorage.org/files/bba/dcf/fdf/bbadcffdfe34400099e929c92c27c266.png"><br><br><img src="https://habrastorage.org/files/351/093/c31/351093c317314a8ca249b15ed8983ba5.png"><br><br>  A curious process takes place the first 400 seconds, after which the performance increases and stabilizes.  I think, in parallel with the record, the garbage collector works, which defragments the blocks and prepares them for writing.  This behavior is observed not every time, but from time to time.  It can be seen that sequential recording sags up to 70 MB / s, random recording - up to 18000 IOPS.  These indicators are still twice as good as without over-provisioning (32 MB / s and 7139 IOPS, respectively).  To make sure that the steady state actually has such high performance, I also ran the test for 30 minutes, while writing 490 GB of disk with an average of 69,721 IOPS. <br><br>  You can compare our results with colleagues and choose the optimal over-provisioning size: <br><ul><li>  <a href="http://www.anandtech.com/show/6489/playing-with-op">The Consortium in Modern SSDs</a> . </li><li>  <a href="http://www.anandtech.com/show/8216/samsung-ssd-850-pro-128gb-256gb-1tb-review-enter-the-3d-era/7">Performance Consistency</a> . </li><li>  <a href="http://www.custompcreview.com/reviews/samsung-850-pro-512gb-sata-ssd-review/21430/7/">Samsung 850 PRO 512GB Performance</a> . </li></ul><br><h4>  Briefly </h4><br>  - If the disk receives ATA TRIM from the OS, then there is nothing to worry about, it is enough to leave part of the disk space free. <br>  - If expensive industrial disks are used, then check the volume of the built-in backup area, if it is sufficient, then there will be no problems with the recording. <br>  - In other cases, you need to leave an unmarked area, the larger its size, the smaller the standard deviation of the recording latency. <br>  - Sometimes the garbage collector does not have time to prepare clean blocks and the write speed may sink and be intermittent. <br>  - After over-provisioning, the steady-state maximum write speed increased from 7000 to 68000 IOPS, and the average minimum - from 6000 IOPS to 19000 IOPS. <br><br><div class="spoiler">  <b class="spoiler_title">More to read.</b> <div class="spoiler_text"><ul><li>  <a href="http://codecapsule.com/2014/02/12/coding-for-ssds-part-1-introduction-and-table-of-contents/">Coding for SSDs</a> . </li><li>  <a href="http://www.outsidethebox.ms/14900/">Why Windows 8 and 8.1 will defragment your SSD, and how to avoid it</a> . </li><li>  <a href="http://forums.overclockers.ru/viewtopic.php%3Fp%3D11035580">FAQ on flash drives (SSD)</a> . </li><li>  <a href="http://forum.notebookreview.com/solid-state-drives-ssds-flash-storage/762363-ssd-tweaks.html">SSD Tweaks</a> . </li><li>  <a href="http://blogs.msdn.com/b/e7/archive/2009/05/05/support-and-q-a-for-solid-state-drives-and.aspx">Support and Q &amp; A for Solid-State Drives</a> . </li></ul></div></div></div><p>Source: <a href="https://habr.com/ru/post/242199/">https://habr.com/ru/post/242199/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../242189/index.html">Dark times are coming: HabraDarkAge theme</a></li>
<li><a href="../242191/index.html">Calling to mobile phones from the browser with recording conversations</a></li>
<li><a href="../242193/index.html">Honeymoon Manager: how to spend it with benefit</a></li>
<li><a href="../242195/index.html">The digest of interesting materials for the mobile developer # 77 (October 26 - November 2)</a></li>
<li><a href="../242197/index.html">Cloud Connect: Private and Secure Surfing. Bye for free</a></li>
<li><a href="../242201/index.html">Pattern matching with macros</a></li>
<li><a href="../242203/index.html">Why is the future behind remote work (part 2)</a></li>
<li><a href="../242205/index.html">Osquery exposes the OS as a relational database</a></li>
<li><a href="../242207/index.html">ah - better than history</a></li>
<li><a href="../242209/index.html">Writing plugins with AppDomain is fun</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>