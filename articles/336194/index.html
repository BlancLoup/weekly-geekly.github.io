<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Tautological tests</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello! My name is Artyom, and most of my working time I write complex auto-tests on Selenium and Cucumber / Calabash. Honestly, quite often I find mys...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Tautological tests</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/web/0bb/484/d1b/0bb484d1b1ba4850a060aad0870c6c54.jpg"></p><br><p>  <em>Hello!</em>  <em>My name is Artyom, and most of my working time I write complex auto-tests on Selenium and Cucumber / Calabash.</em>  <em>Honestly, quite often I find myself faced with a difficult choice: to write a test that checks a specific implementation of functionality (because it is easier) or a test that tests functionality (because it is more correct, but much more difficult)?</em>  <em>Recently, I came across a nice article that implementation tests are ‚Äútautological‚Äù tests.</em>  <em>And, having read it, I have been rewriting some tests in a different way for almost a week.</em>  <em>I hope she pushes you to thoughts too.</em> </p><a name="habracut"></a><br><p>  Everyone knows that tests are essential for quickly creating high-quality software.  But, like everything else in our lives, if used improperly, they can do more harm than good.  Consider the following simple function and test.  In this case, the author wants to protect the tests from external dependencies, so the stubs are used. </p><br><pre><code class="hljs python"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> hashlib <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> typing <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> List <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> unittest.mock <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> patch <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_key</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(key: str, values: List[str])</span></span></span><span class="hljs-function"> -&gt; str:</span></span> md5_hash = hashlib.md5(key) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> value <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> values: md5_hash.update(value) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">f'</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{key}</span></span></span><span class="hljs-string">:</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{md5_hash.hexdigest()}</span></span></span><span class="hljs-string">'</span></span> @patch(<span class="hljs-string"><span class="hljs-string">'hashlib.md5'</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_hash_values</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(mock_md5)</span></span></span><span class="hljs-function">:</span></span> mock_md5.return_value.hexdigest.return_value = <span class="hljs-string"><span class="hljs-string">'world'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> get_key(<span class="hljs-string"><span class="hljs-string">'hello'</span></span>, [<span class="hljs-string"><span class="hljs-string">'world'</span></span>]) == <span class="hljs-string"><span class="hljs-string">'hello:world'</span></span> mock_md5.assert_called_once_with(<span class="hljs-string"><span class="hljs-string">'hello'</span></span>) mock_md5.return_value.update.assert_called_once_with(<span class="hljs-string"><span class="hljs-string">'world'</span></span>) mock_md5.return_value.hexdigest.assert_called()</code> </pre> <br><p>  Looks great!  Four statements have been fully tested to ensure that the code works as expected.  Tests even pass! </p><br><pre> <code class="hljs pgsql">$ python3<span class="hljs-number"><span class="hljs-number">.6</span></span> -m pytest test_simple.py ========= test <span class="hljs-keyword"><span class="hljs-keyword">session</span></span> starts ========= itemstest_simple.py . ======= <span class="hljs-number"><span class="hljs-number">1</span></span> passed <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0.03</span></span> seconds ======</code> </pre> <br><p>  Of course, the problem is that the code is wrong.  md5 only accepts <code>bytes</code> , not <code>str</code> ( <a href="http://eli.thegreenplace.net/2012/01/30/the-bytesstr-dichotomy-in-python-3">this post</a> explains how <code>bytes</code> and <code>str</code> changed in Python 3).  The test script does not play a big role;  only string formatting was tested here, which gives us a false sense of security: it seems to us that the code was written correctly, and we even proved it with the help of test scripts! </p><br><p>  Fortunately, <a href="http://mypy-lang.org/">mypy</a> catches these problems: </p><br><pre> <code class="hljs pgsql">$ mypy test_simple.py test_simple.py:<span class="hljs-number"><span class="hljs-number">6</span></span>: error: Argument <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> ‚Äúmd5‚Äù has incompatible <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> ‚Äústr‚Äù; expected ‚Äú<span class="hljs-keyword"><span class="hljs-keyword">Union</span></span>[bytes, bytearray, memoryview]‚Äù test_simple.py:<span class="hljs-number"><span class="hljs-number">8</span></span>: error: Argument <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> ‚Äú<span class="hljs-keyword"><span class="hljs-keyword">update</span></span>‚Äù <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> ‚Äú_Hash‚Äù has incompatible <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> ‚Äústr‚Äù; expected ‚Äú<span class="hljs-keyword"><span class="hljs-keyword">Union</span></span>[bytes, bytearray, memoryview]‚Äù</code> </pre> <br><p>  Remarkably, we fixed our code to first transcode strings to bytes: </p><br><pre> <code class="hljs pgsql">def get_key(key: str, <span class="hljs-keyword"><span class="hljs-keyword">values</span></span>: List[str]) -&gt; str: md5_hash = hashlib.md5(key.encode()) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">values</span></span>: md5_hash.<span class="hljs-keyword"><span class="hljs-keyword">update</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>.encode()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> f<span class="hljs-string"><span class="hljs-string">'{key}:{md5_hash.hexdigest()}'</span></span></code> </pre> <br><p>  Now the code works, but the problems remain.  Suppose someone walked through our code and simplified it to just a few lines: </p><br><pre> <code class="hljs python"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_key</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(key: str, values: List[str])</span></span></span><span class="hljs-function"> -&gt; str:</span></span> hash_value = hashlib.md5(<span class="hljs-string"><span class="hljs-string">f"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{key}</span></span></span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{</span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">''</span></span></span></span><span class="hljs-string"><span class="hljs-subst">.join(values)}</span></span></span><span class="hljs-string">"</span></span>.encode()).hexdigest() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">f'</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{key}</span></span></span><span class="hljs-string">:</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{hash_value}</span></span></span><span class="hljs-string">'</span></span></code> </pre> <br><p>  Functionally obtained is identical to the source code.  For the same input data, it will always return the same result.  But even in this case, the test passes with an error: </p><br><pre> <code class="hljs pgsql">E AssertionError: Expected <span class="hljs-keyword"><span class="hljs-keyword">call</span></span>: md5(b<span class="hljs-string"><span class="hljs-string">'hello'</span></span>) E Actual <span class="hljs-keyword"><span class="hljs-keyword">call</span></span>: md5(b<span class="hljs-string"><span class="hljs-string">'helloworld'</span></span>)</code> </pre> <br><p>  Obviously, there is some problem with this simple test.  Here at the same time there <a href="https://www.khanacademy.org/math/statistics-probability/significance-tests-one-sample/idea-of-significance-tests/v/type-1-errors">is a first kind error</a> (the test fails even if the code is correct) and <a href="https://ru.wikipedia.org/wiki/%25D0%259E%25D1%2588%25D0%25B8%25D0%25B1%25D0%25BA%25D0%25B8_%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B2%25D0%25BE%25D0%25B3%25D0%25BE_%25D0%25B8_%25D0%25B2%25D1%2582%25D0%25BE%25D1%2580%25D0%25BE%25D0%25B3%25D0%25BE_%25D1%2580%25D0%25BE%25D0%25B4%25D0%25B0">a second kind error</a> (the test does not fall when the code is incorrect).  In an ideal world, tests will fall if (and only if) the code contains an error.  And in an even more perfect world, when passing tests, you can be completely sure of the correctness of the code.  And although both ideals are unattainable, it is worth striving for them. </p><br><p>  The tests described above, I call "tautological."  They confirm the correctness of the code, ensuring that it is executed as written, which, of course, assumes that it is written correctly. </p><br><p><img src="https://habrastorage.org/web/066/a13/12b/066a1312b61341619f81f8e795684f93.png"></p><br><p>  I believe that the tautological tests are an undoubted negative for your code.  For several reasons: </p><br><ol><li>  <strong>Tautological tests give engineers a false sense that their code is correct.</strong>  They can look at the high coverage of the code and be happy for their projects.  Other people using the same code base will confidently push the changes while the tests pass, although these tests do not actually test anything. </li><li>  <strong>Tautological tests actually "freeze" the implementation, and do not check that the code behaves as intended.</strong>  If you change any aspects of the implementation, you must reflect this by changing the tests, rather than changing the tests when the expected output changes.  This encourages engineers to correct tests in case of failures during their run, and not to find out why tests fail.  If this happens, then the tests become a burden, their original meaning is lost as a tool to prevent bugs from getting into production. </li><li>  <strong>Static analysis tools are able to find blatant errors in your code, such as typos, that would be caught by tautological tests anyway.</strong>  Static analysis tools have improved significantly over the past five years, especially in dynamic languages.  For example, <a href="http://mypy-lang.org/">Mypy</a> in Python, <a href="http://hacklang.org/">Hack</a> in PHP or <a href="https://www.typescriptlang.org/">TypeScript</a> in JavaScript.  All of them are often better suited for typos, while being more valuable to engineers, because they make the code more understandable and easier to navigate. </li></ol><br><p>  In other words, tautological tests often miss real problems, stimulating the bad habit of blindly correcting tests, and at the same time the benefits of them do not pay for their efforts to support them. </p><br><p>  Let's rewrite the test to check the output: </p><br><pre> <code class="hljs python"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_hash_values</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(mock_md5)</span></span></span><span class="hljs-function">:</span></span> expected_value = <span class="hljs-string"><span class="hljs-string">'hello:fc5e038d38a57032085441e7fe7010b0'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> get_key(<span class="hljs-string"><span class="hljs-string">'hello'</span></span>, [<span class="hljs-string"><span class="hljs-string">'world'</span></span>]) == expected_value</code> </pre> <br><p>  Now the details of <code>get_key</code> are not important for the test, it will fail only if <code>get_key</code> returns an incorrect value.  I can change the internals of <code>get_key</code> as I <code>get_key</code> without updating the tests (until I change public behavior).  In this case, the test is short and easy to understand. </p><br><p>  Although this is a contrived example, in real code it is easy to find places where, for the sake of increasing code coverage, it is assumed that the output of external services meets the implementation expectations. </p><br><h4 id="kak-vyyavit-tavtologicheskie-testy">  How to identify tautological tests </h4><br><ol><li>  <strong>Tests that fail when updated are much more frequently tested code.</strong>  We always pay the price for code coverage.  If this price exceeds the benefit received from the tests, then it is likely that the tests are too closely related to the implementation.  Related problem: small changes in the code under test require updating a much larger number of tests. </li><li><p>  <strong>The test code cannot be edited without matching with the implementation.</strong>  In this case, there is a great chance that you got a tautological test.  In <a href="https://testing.googleblog.com/2013/05/testing-on-toilet-dont-overuse-mocks.html">Testing on the Toilet: Don't Overuse Mocks</a> you will find a very familiar example.  You can recreate the implementation itself based on this test: </p><br><pre> <code class="hljs pgsql"><span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">void</span></span> testCreditCardIsCharged() { paymentProcessor = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> PaymentProcessor(mockCreditCardServer); <span class="hljs-keyword"><span class="hljs-keyword">when</span></span>(mockCreditCardServer.isServerAvailable()).thenReturn(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">when</span></span>(mockCreditCardServer.beginTransaction()).thenReturn(mockTransactionManager); <span class="hljs-keyword"><span class="hljs-keyword">when</span></span>(mockTransactionManager.getTransaction()).thenReturn(<span class="hljs-keyword"><span class="hljs-keyword">transaction</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">when</span></span>(mockCreditCardServer.pay(<span class="hljs-keyword"><span class="hljs-keyword">transaction</span></span>, creditCard, <span class="hljs-number"><span class="hljs-number">500</span></span>)).thenReturn(mockPayment); <span class="hljs-keyword"><span class="hljs-keyword">when</span></span>(mockPayment.isOverMaxBalance()).thenReturn(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>); paymentProcessor.processPayment(creditCard, <span class="hljs-type"><span class="hljs-type">Money</span></span>.dollars(<span class="hljs-number"><span class="hljs-number">500</span></span>)); verify(mockCreditCardServer).pay(<span class="hljs-keyword"><span class="hljs-keyword">transaction</span></span>, creditCard, <span class="hljs-number"><span class="hljs-number">500</span></span>); }</code> </pre> <br></li></ol><br><h4 id="kak-ispravit-tavtologicheskie-testy">  How to fix tautological tests </h4><br><ol><li>  <strong>Separate I / O from logic.</strong>  It is because of input / output engineers most often turn to plugs.  Yes, input / output is extremely important; without it, we could only scroll through the processor cycles and heat the air.  But it is better to transfer I / O to the periphery of your code, and not to mix it with logic.  The Python <a href="https://sans-io.readthedocs.io/how-to-sans-io.html">Sans-I / O</a> Working Group developed excellent documentation on this issue, and Corey Benfield gave an excellent account of it in his <a href="https://www.youtube.com/watch%3Fv%3D7cC3_jGwl_U">Building Building Libraries The Right Way</a> presentation at PyCon 2016. </li><li><p>  <strong>Avoid stubs in memory objects.</strong>  For stubs to use dependencies that are entirely in memory, we need very good reasons.  Perhaps the underlying function is non-deterministic or it takes too long to execute.  The use of real objects increases the value of tests by testing a larger number of interactions in the test scenario.  But even in this case, there should be tests to ensure that the code correctly uses these dependencies (such as a test that checks that the output is in the expected range).  Below is an example in which we check that our code works if <code>randint</code> returns a specific value and that we correctly call <code>randint</code> . </p><br><pre> <code class="hljs python"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> random <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> unittest.mock <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> patch <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_thing</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> random.randint(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>) @patch(<span class="hljs-string"><span class="hljs-string">'random.randint'</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_random_mock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(mock_randint)</span></span></span><span class="hljs-function">:</span></span> mock_randint.return_value = <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> get_thing() == <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_random_real</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> &lt;= get_thing() &lt; <span class="hljs-number"><span class="hljs-number">10</span></span></code> </pre> <br></li><li>  <strong>Use auxiliary data.</strong>  If a stub dependency is used as an external service, then create a set of fake data or use a stub server to provide supporting data.  Centralizing the fake implementation allows you to carefully emulate the behavior of a real implementation and minimize the amount of test changes as the implementation changes. </li><li>  <strong>Do not be afraid to leave part of the code uncovered!</strong>  If you choose between good code testing and no tests, the answer is obvious: test well.  But when choosing between a tautological test and the absence of a test, everything is not so obvious.  I hope I convinced you that the tautological tests are evil.  If you leave some of the code uncovered, it will become for other developers a kind of indicator of the current state of affairs - they will be able to exercise caution when modifying this part of the code.  Or, preferably, use the aforementioned techniques to write suitable tests. </li></ol><br><p><img src="https://habrastorage.org/web/7e2/f78/235/7e2f782350a04c1394dddd493b780f1b.png"></p><br><p>  It is better to leave a line of code uncovered than to create the illusion that it is well tested. </p><br><p>  Also pay attention to the tautological tests, conducting a revision of someone else's code.  Ask yourself what the test actually tests, and not just cover any lines of code. </p><br><p>  Remember, tautological tests are bad because they are not good. </p><br><h4 id="chto-pochitat-po-teme">  What to read on the topic </h4><br><ul><li>  <a href="https://martinfowler.com/articles/mocksArentStubs.html">Mocks aren't stubs</a> </li><li>  <a href="https://testing.googleblog.com/2013/05/testing-on-toilet-dont-overuse-mocks.html">Don't Overuse Mocks</a> </li><li>  <a href="https://teamgaslight.com/blog/testing-behavior-vs-testing-implementation">Testing Behavior vs.</a>  <a href="https://teamgaslight.com/blog/testing-behavior-vs-testing-implementation">Testing implementation</a> </li></ul></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/336194/">https://habr.com/ru/post/336194/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../336180/index.html">How to enjoy work</a></li>
<li><a href="../336182/index.html">Creating modules for MODX Evolution in 2017 for the smallest</a></li>
<li><a href="../336184/index.html">The implementation of the list with the title, footer and pagination in Android</a></li>
<li><a href="../336188/index.html">Veeam Academy - practical classes for beginners C # developers</a></li>
<li><a href="../336190/index.html">ITMO University Digest: study, sports programming and science</a></li>
<li><a href="../336196/index.html">Room: Android data storage for everyone</a></li>
<li><a href="../336198/index.html">Neuro-authentication: an introduction to biometric authentication</a></li>
<li><a href="../336202/index.html">Another way to work with Promise for Redux</a></li>
<li><a href="../336204/index.html">How to become the best Android application developer: 31 tips</a></li>
<li><a href="../336208/index.html">Crashplan closes service for individuals</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>