<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Hierarchical Data Structures and Doctrine</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 

 Storing hierarchical data (or simply trees) in relational structures is quite a non-trivial task and causes some problems when develop...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Hierarchical Data Structures and Doctrine</h1><div class="post__text post__text-html js-mediator-article"><h2>  Introduction </h2><br><br>  Storing hierarchical data (or simply trees) in relational structures is quite a non-trivial task and causes some problems when developers encounter a similar task. <br><br>  First of all, this is due to the fact that relational databases are not adapted for storing hierarchical structures (such as XML files), the structure of relational tables is simple lists.  Hierarchical data has a parent-heirs relationship, which is not implemented in a relational structure. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      However, the task of ‚Äústoring trees in a database‚Äù sooner or later arises before any developer. <br><br>  Below we consider in detail what approaches exist in organizing the storage of trees in relational databases, and also consider the tools that ORM Doctrine provides for working with such structures. <br><a name="habracut"></a><br><h2>  Adjacent Vertices List (Adjacency List) </h2><br><br><h3>  Structure description </h3><br><br>  As a rule, such a data structure involves storing information about the adjacent vertices of our tree.  Let's consider the simplest graph with crown vertices (1,2,3): <br><br><img title="Three vertex graph" src="https://habrastorage.org/getpro/habr/post_images/fce/1c2/6b3/fce1c26b3ecdcee5037ccf2e5fa86d50.png" width="158" height="141"><br><br>  <em>Fig.</em>  <em>1. A graph with three vertices</em> <br><br>  As you can see, each element of this graph stores information about the connection with other elements, ie: <br><br><blockquote><pre>  1 - 2.3
 2 - 1.3
 3 - 1.2 </pre></blockquote><br><br>  In fact, to build a tree, such a graph is redundant, since  for the usual branching structure, we need to keep only the ‚Äúparent-heir‚Äù connection, ie: <br><br><blockquote><pre>  2-1
 3-1 </pre></blockquote><br><br>  Then we get a tree with one root element (1) and two branches (2,3): <br><br><img title="Tree graph" src="https://habrastorage.org/getpro/habr/post_images/765/d7e/b72/765d7eb723f92da4a974817d19863bc3.png" width="158" height="141"><br><br>  <em>Fig.</em>  <em>2. Tree graph</em> <br><br>  In principle, one and the other graphs can, if desired, be displayed in the database using a list of adjacent vertices, but since we are interested in precisely the trees, we‚Äôll dwell on them. <br><br>  So, in order to store the hierarchical structure in the database using the Adjacency List method, we need to store information on the heir-parent relationship in data tables.  Let's look at a real tree example: <br><br><img title="Adjacency List" src="https://habrastorage.org/getpro/habr/post_images/90b/a43/b01/90ba43b011ca58799b0fad09a9c289de.gif" width="500" height="380"><br><br>  <em>Fig.</em>  <em>3. Tree structure by the method of adjacent vertices</em> <br><br>  In the figure, squares indicate tree nodes.  Each node has a name (upper rectangle inside the square), an identifier (left lower square) and a link to the parent identifier (lower right square).  As can be seen from Fig.  3, each heir in such a structure refers to his ancestor.  In terms of the database, we can display it as follows in a table: <br><br><img title="Tree data table constructed using the adjacent vertex list method" src="https://habrastorage.org/getpro/habr/post_images/39a/cbc/47e/39acbc47ef660d9a3ba01e25ace3d8d9.png" width="210" height="80"><br><br>  <em>Fig.</em>  <em>4. Tree data table constructed by the method of the list of adjacent vertices</em> <br><br>  Or in the form of SQL: <br><br><blockquote><pre>  CREATE TABLE al_tree (
     `id` BIGINT NOT NULL AUTO_INCREMENT PRIMARY KEY,
     `parent_id` BIGINT NULL,
     `name` VARCHAR (50) NOT NULL
 ) TYPE = InnoDB DEFAULT CHARSET = utf8;

 CREATE INDEX fk_tree_tree ON al_tree (parent_id);

 ALTER TABLE al_tree ADD CONSTRAINT fk_tree_tree
     FOREIGN KEY (parent_id) REFERENCES al_tree (id) ON UPDATE CASCADE ON DELETE CASCADE;

 INSERT INTO al_tree VALUES
     (1, NULL, 'FOOD'),
     (2, 1, 'VEGETABLE'),
     (3, 2, 'POTATO'),
     (4, 2, 'TOMATO'),
     (5, 1, 'FRUIT'),
     (6, 5, 'APPLE'),
     (7, 5, 'BANANA'); </pre></blockquote><br><br>  It should be immediately noted that such an algorithm for storing trees has certain advantages and disadvantages.  First of all, it is not quite convenient for reading - and this is its main drawback. <br><br>  Problems with reading from the database are less noticeable if you read the entire tree.  This is a fairly simple query: <br><br><blockquote><pre>  SELECT * FROM al_tree ORDER BY id; </pre></blockquote><br><br>  Result: <br><br><blockquote><pre>  + ---- + ----------- + ----------- +
 |  id |  parent_id |  name |
 + ---- + ----------- + ----------- +
 |  1 |  NULL |  FOOD |
 |  2 |  1 |  VEGETABLE |
 |  3 |  2 |  POTATO |
 |  4 |  2 |  TOMATO |
 |  5 |  1 |  FRUIT |
 |  6 |  5 |  APPLE |
 |  7 |  5 |  BANANA |
 + ---- + ----------- + ----------- + </pre></blockquote><br><br>  However, in the future, such a sample implies a rather capacious programmatic post-processing of data.  First, you need to recursively rebuild the data, taking into account the connections "ancestor-heir", and only then they can be used to display somewhere. <br><br>  Another option to read the entire tree: <br><br><blockquote><pre>  SELECT t1.name AS lvl1, t2.name as lvl2, t3.name as lvl3
 FROM al_tree AS t1
 LEFT JOIN al_tree AS t2 ON t2.parent_id = t1.id
 LEFT JOIN al_tree AS t3 ON t3.parent_id = t2.id
 LEFT JOIN al_tree AS t4 ON t4.parent_id = t3.id
 WHERE t1.id = 1; </pre></blockquote><br><br>  The result in this case will be: <br><br><blockquote><pre>  + ------ + ----------- + -------- +
 |  lvl1 |  lvl2 |  lvl3 |
 + ------ + ----------- + -------- +
 |  FOOD |  VEGETABLE |  POTATO |
 |  FOOD |  VEGETABLE |  TOMATO |
 |  FOOD |  FRUIT |  APPLE |
 |  FOOD |  FRUIT |  BANANA |
 + ------ + ----------- + -------- + </pre></blockquote><br><br>  Although the data in this form is already more suitable for output at once, but, as you can see, the main drawback of this approach is that you need to know reliably the number of nesting levels in your hierarchy, besides, the larger the hierarchy, the more JOINs - the lower the performance. <br><br>  Nevertheless, this method also has significant advantages - it is easy to make changes, change places and delete nodes in a tree. <br><br>  Conclusion - this algorithm is well applicable if you operate with small tree structures that are often amenable to change. <br><br>  On the other hand, this algorithm also feels pretty confident with large trees, if you read them in portions of the form ‚ÄúI know a parent - read all the heirs.‚Äù  A good example of such a case is dynamically loaded trees.  In this case, the algorithm is practically optimized for this behavior. <br><br>  However, it is poorly applicable when you need to read any other pieces of wood, find the paths, the previous and next nodes when going around and read the whole tree branches (to the full depth). <br><br><h3>  Using a list of contiguous vertices in Doctrine </h3><br><br>  First I would like to make a few introductory words on the organization of table templates in Doctrine, with the help of which such things are implemented in it.  Those who are already familiar with this concept in the doctrine may skip a few paragraphs forward to more interesting things. <br><br>  So, the entities that we operate in ORM Doctrine are active records ( <a href="http://martinfowler.com/eaaCatalog/activeRecord.html">Active Record</a> ).  Those.  objects that combine business logic and are able to interact with the database.  But the Doctrine developers envisaged extending the functionality of record objects not only by inheritance, but also by applying ‚Äúpatterns of behavior‚Äù to these objects.  This is implemented by the Doctrine / Template package. <br><br>  Thus, if there is a need to bring up an active record before any behavior (for example, Versionable - conducts an audit of all changes, I18N - multilingual or NestedSet - a tree-like ‚Äúnested set‚Äù), then this can be done using these templates behavior. <br><br>  To connect any of the existing templates, it is enough to configure our model properly (via YAML or directly in the code of the base table of the model). <br><br>  When the time comes, we will show with examples how to do this. <br><br>  So far, unfortunately, or fortunately, but in the form of a template for tables, the method of the list of adjacent vertices in Doctrine is not implemented.  If you wish, you can write the implementation yourself and even offer it to the Doctrine developers, this is up to you. <br><br>  However, the basic functions that can be implemented within this model can be implemented in Doctrine without using patterns of behavior.  Unfortunately, we will not receive functions of work with a tree, but we will be able to solve the main tasks. <br><br>  To do this, configure our model properly.  Using YAML we describe the structure of our table: <br><br><blockquote><pre>  AlTree:
   tableName: al_tree
   columns:
     id:
       type: integer (8)
       primary: true
       autoincrement: true
     name:
       type: string (50)
       notnull: true
     parent_id: integer (8) </pre></blockquote><br><br>  And now the most important thing is to correctly describe the relationships in the table.  In the same place with the following line we will write: <br><br><blockquote><pre>  relations:
     Parent:
       class: AlTree
       local: parent_id
       foreign: id
       type: one
     Children:
       class: AlTree
       local: id
       foreign: parent_id
       type: many </pre></blockquote><br><br>  Now we build our model by running the command: <br><br><blockquote><pre>  ./doctrine generate-models-yaml </pre></blockquote><br><br>  Everything.  The model is ready.  In fact, the same could be done in the already ready BaseAlTree base class: <br><br><blockquote><pre>  &lt;? php
 ...
   public function setUp ()
   {
     $ this-&gt; hasOne ('AlTree as Parent', array ('local' =&gt; 'parent_id',
                                             'foreign' =&gt; 'id'));

     $ this-&gt; hasMany ('AlTree as Children', array ('local' =&gt; 'id',
                                                'foreign' =&gt; 'parent_id'));
   }
 ...
 ?&gt; </pre></blockquote><br><br>  Now it's time to enjoy the results of our work.  Let's write a simple code that displays a tree constructed with indents on a normal HTML page using recursion. <br><br><blockquote><pre> &lt;?  / ** * Extract the root of the tree * / $ root = Doctrine :: getTable ('AlTree') -&gt; findByDql ('WHERE parent_id IS NULL') -&gt; getFirst ();  echo '&lt;pre&gt;';  printRTree ($ root);  echo '&lt;/ pre&gt;';  / ** * Prints the tree recursively to the screen * * @param AlTree $ node - record object - tree node * @param int $ level - nesting level of the transmitted node * / function printRTree (AlTree $ node, $ level = 0) {/ * * * This line draws our tree * / echo str_repeat ("\ t", $ level).  $ node-&gt; getName ().  "\ n";  / ** * Next we check if there are any heirs, * and if there is, we enter into recursion.  * Pay attention - this is the miracle property of * Children, which we described in the config * of our model!  * / if (($ children = $ node-&gt; Children-&gt; getIterator ()) &amp;&amp; $ children-&gt; count ()&gt; 0) {$ level ++;  while (($ child = $ children-&gt; current ())) {/ ** * Entering recursion * / printRTree ($ child, $ level);  $ children-&gt; next ();  }}}?&gt; </pre></blockquote><br><br>  Please note that after we have properly configured the links in our model object, we have the <strong>Children</strong> and <strong>Parent</strong> properties available to us.  However, any first read access to them generates a query to the database.  Therefore, to build large trees in one pass, this approach can be quite expensive. <br><br>  But at the same time, it is a pleasure to implement a dynamically loadable tree in this way! <br><br><h2>  Nested Set </h2><br><br><h3>  Structure description </h3><br><br>  About this algorithm and its speed, probably, all web developers have heard.  Yes, this algorithm is really very good when you need to frequently and a lot refer to the hierarchical data for reading.  Consider the essence of this approach. <br><br>  When building a tree on the basis of nested sets, we will use the principle of traversing this tree from left to right, as shown by the arrows in Fig.  5. To do this, we define for each node of the tree integer keys on the left (lft) and on the right (rgt) (the lower squares inside the node).  And distribute integer incremental values ‚Äã‚Äãto them during the traversal.  See what happened. <br><br><img title="Nested set" src="https://habrastorage.org/getpro/habr/post_images/80d/126/cb0/80d126cb007779d502bd92e6522774cb.gif" width="500" height="383"><br><br>  <em>Fig.</em>  <em>5. Nested Set.</em> <br><br>  The root element received keys 1 and 14, which include the range of numbers of all other keys.  VEGETABLE branch received keys 2 and 7, which, in turn, include the entire range of numbers of keys of all its heirs, etc.  Here they are - nested sets.  It's simple, isn't it? <br><br>  Let's recreate the same structure in the context of the database table. <br><br><img title="Nested Set Tree Table" src="https://habrastorage.org/getpro/habr/post_images/96b/f21/dcb/96bf21dcb4175e85c0ee696932d100c9.png" width="166" height="95"><br><br>  <em>Fig.</em>  <em>6. Table of hierarchical data based on the method of nested sets</em> <br><br>  Or in the form of SQL: <br><br><blockquote><pre>  CREATE TABLE ns_tree (
     `id` BIGINT NOT NULL AUTO_INCREMENT PRIMARY KEY,
     `name` VARCHAR (50) NOT NULL,
     `lft` BIGINT NOT NULL,
     `rgt` BIGINT NOT NULL,
     `level` BIGINT NOT NULL
 ) TYPE = InnoDB DEFAULT CHARSET = utf8;

 CREATE INDEX nslrl_idx ON ns_tree (lft, rgt, level);

 INSERT INTO ns_tree VALUES
     (1, 'FOOD', 1, 14, 0),
     (2, 'VEGETABLE', 2, 7, 1),
     (3, 'POTATO', 3, 4, 2),
     (4, 'TOMATO', 5, 6, 2),
     (5, 'FRUIT', 8, 13, 1),
     (6, 'APPLE', 9, 10, 2),
     (7, 'BANANA', 11, 12, 2); </pre></blockquote><br><br>  As you can see, we have added one more field to the table - level.  It will store information about the nesting level of each branch of the tree.  In principle, it is not necessary to do this at all - the nesting level can be quite simply calculated, but since this algorithm is optimized just for reading, why not win in performance by caching the level information?  A rhetorical question‚Ä¶ <br><br>  <strong>Reading a tree from the database</strong> <br><br>  We read the whole tree: <br><br><blockquote><pre>  SELECT node.id, node.name, node.level
 FROM ns_tree AS node,
 ns_tree AS parent
 WHERE node.lft BETWEEN parent.lft AND parent.rgt
 AND parent.id = 1
 ORDER BY node.lft; </pre></blockquote><br><br>  The result will be: <br><br><blockquote><pre>  + ---- + ----------- + ------- +
 |  id |  name |  level |
 + ---- + ----------- + ------- +
 |  1 |  FOOD |  0 |
 |  2 |  VEGETABLE |  1 |
 |  3 |  POTATO |  2 |
 |  4 |  TOMATO |  2 |
 |  5 |  FRUIT |  1 |
 |  6 |  APPLE |  2 |
 |  7 |  BANANA |  2 |
 + ---- + ----------- + ------- + </pre></blockquote><br><br>  Theoretically, we could get the same result by calculating the nesting level on the fly: <br><br><blockquote><pre>  SELECT node.id, node.name, (COUNT (parent.id) - 1) AS level
 FROM ns_tree AS node,
 ns_tree AS parent
 WHERE node.lft BETWEEN parent.lft AND parent.rgt
 GROUP BY node.name
 ORDER BY node.lft; </pre></blockquote><br><br>  Try to compare the result yourself - it will be identical to the first.  Only the request itself is more resource intensive in this case.  And since Nested Set is an optimal reading algorithm, a small optimization in the form of caching the nesting level along with the rest of the data is not such a bad strategy. <br><br>  In the same, rather simple way, we can read whole branches, paths from our tree, bypass its nodes, etc. <br><br>  For example, if we want to extract all vegetables (VEGETABLE) from our example, it is quite simple to do this: <br><br><blockquote><pre>  SELECT node.id, node.name, node.level
 FROM ns_tree AS node, ns_tree AS parent
 WHERE node.lft BETWEEN parent.lft AND parent.rgt AND parent.id = 2
 ORDER BY node.lft; </pre></blockquote><br><br>  Moreover, if it is necessary to exclude from the results of the parent itself, you can do several ways: <br><ul><li>  adding HAVING level&gt; 1 </li><li>  adding in the WHERE clause: AND node.id! = 2 </li></ul><br>  or in another way - let it be a creative task for the reader. <br><br>  Yes, fast and flexible reading, including aggregation with external related data, is a strong point of this algorithm. <br><br>  However, there is no blessing in disguise, and in this case, significant difficulties begin when we need to make changes to the Nested Set tree or remove any of its branches. <br><br>  This is due, primarily, to the fact that with changes, we will <strong>need to recalculate all the keys of the part of the tree that is located to the right of the node being changed</strong> , as well as update the information about nesting levels.  And all this is not done in one simple request. <br><br>  See for yourself. <br><br>  <strong>Adding a new branch</strong> <br><br>  Suppose we want to add a new branch named SEA FOOD to our tree on the same level as VEGETABLES and FRUIT. <br><br><blockquote><pre>  BEGIN;

 SELECT @treeRight: = rgt FROM ns_tree
 WHERE id = 2;  / * to the right of the VEGETABLES branch, which has id = 2 * /

 UPDATE ns_tree SET rgt = rgt + 2 WHERE rgt&gt; @treeRight;
 UPDATE ns_tree SET lft = lft + 2 WHERE lft&gt; @treeRight;

 INSERT INTO ns_tree VALUES (0, 'SEA FOOD', @treeRight + 1, @treeRight + 2, 1);

 COMMIT; </pre></blockquote><br><br>  If you use MYISAM tables in MySQL, or a version that does not support transactions, you can use write locks instead of BEGIN and COMMIT: <br><br><blockquote><pre>  LOCK TABLE ns_tree WRITE;
 ...
 UNLOCK TABLES; </pre></blockquote><br><br>  As you can see, the task of adding a new branch is quite expensive and non-trivial.  However, solvable. <br><br>  <strong>Deleting a branch</strong> <br><br>  Let's now try to delete the newly created branch: <br><br><blockquote><pre>  BEGIN;

 SELECT @treeLeft: = lft, @treeRight: = rgt, @treeWidth: = rgt - lft + 1
 FROM ns_tree
 WHERE id = 8;  / * here is the identifier of the new entry named 'SEA FOOD' * /

 DELETE FROM ns_tree WHERE lft BETWEEN @treeLeft AND @treeRight;
 / *
   ATTENTION!
   Please note - we do not delete by id,
   Although in this case it would suit us.
   But in general, we need to remove the entire branch with its contents!
 * /

 UPDATE ns_tree SET rgt = rgt - @treeWidth WHERE rgt&gt; @treeRight;
 UPDATE ns_tree SET lft = lft - @treeWidth WHERE lft&gt; @treeRight;

 COMMIT; </pre></blockquote><br><br>  Conclusion - Nested Set is really good when we need to read the tree structure from the database.  At the same time it is equally good for trees of any size. <br><br>  However, for hierarchical structures that are subject to frequent change, it obviously will not be the optimal choice. <br><br><h3>  Using Nested Set in Doctrine </h3><br><br>  But this method is reflected in Doctrine as an implementation of a pattern of behavior that we can attach to our model. <br><br>  It is quite simple to do this, using the model configuration method via YAML-config or Pramo in the base class code. <br><br>  YAML: <br><br><blockquote><pre>  NsTree:
   tableName: ns_tree
   actAs: [NestedSet]
   columns:
     id:
       type: integer (8)
       primary: true
       autoincrement: true
     name:
       type: string (50)
       notnull: true
     lft:
       type: integer (8)
       notnull: true
     rgt:
       type: integer (8)
       notnull: true
     level:
       type: integer (8)
       notnull: true </pre></blockquote><br><br>  As you can see, it is enough just to specify <strong>actAs: [NestedSet]</strong> in the class description. <br><br>  However, Doctrine provides a more flexible configuration for the NestedSet model.  For example, you can store several trees in one table.  To do this, you need to enter into the table an additional field in which you will store the root identifier of the tree for each record. <br><br>  In this case, the configuration should be written as: <br><br><blockquote><pre>  NsTree:
   tableName: ns_tree
   actAs: 
     NestedSet:
       hasManyRoots: true
       rootColumnName: root_id
   columns:
     id:
       type: integer (8)
       primary: true
       autoincrement: true
     root_id:
       type: integer (8)
       notnull: true
     name:
       type: string (50)
       notnull: true
     lft:
       type: integer (8)
       notnull: true
     rgt:
       type: integer (8)
       notnull: true
     level:
       type: integer (8)
       notnull: true </pre></blockquote><br><br>  All the same could be done in the existing base class of the model. <br><br>  For the first case: <br><br><blockquote><pre>  &lt;? php
 ...
     public function setTableDefinition ()
     {
         ...
         $ this-&gt; actAs ('NestedSet');
        ...
     }
 ...
 ?&gt; </pre></blockquote><br><br>  or: <br><br><blockquote><pre>  &lt;? php
 ...
     public function setTableDefinition ()
     {
         ...
         $ this-&gt; actAs ('Doctrine_Template_NestedSet');
        ...
     }
 ...
 ?&gt; </pre></blockquote><br><br>  For the second case (several trees): <br><br><blockquote><pre>  &lt;? php
 ...
     public function setTableDefinition ()
     {
         ...
         $ options = array ('hasManyRoots' =&gt; true,
                          'rootColumnName' =&gt; 'root_id');
         $ this-&gt; actAs ('NestedSet', $ options);
        ...
     }
 ...
 ?&gt; </pre></blockquote><br><br>  Note, Doctrine uses 'root_id' as the default field name.  Therefore, you do not need to specify this option if it matches the name in your real table.  Otherwise you can set it. <br><br>  <strong>Examples of working with Nested Set trees in Doctrine</strong> <br><br>  Extract and print the whole tree on the screen: <br><br><blockquote><pre>  &lt;? php
 $ tree = Doctrine :: getTable ('NsTree') -&gt; getTree () -&gt; fetchTree ();
 echo "&lt;pre&gt;";
 foreach ($ tree as $ node) {
     echo str_repeat ("\ t", $ node ['level']).  $ node ['name'].  "\ n";
 }
 echo "&lt;/ pre&gt;";
 ?&gt; </pre></blockquote><br><br>  See how easy it is! <br><br>  For additional examples and information, you can refer to the official Doctrine documentation, sections <a href="http://www.doctrine-project.org/documentation/manual/1_0/en/one-page">8.2.4</a> and <a href="http://www.doctrine-project.org/documentation/manual/1_0/en/one-page">8.2.5.</a> <br><br><h2>  Materialized Path </h2><br><br><h3>  Structure description </h3><br><br>  Another rather interesting approach for storing hierarchical structures.  The basic idea of ‚Äã‚Äãthe algorithm is to store the full path to the node from the top of the tree.  It looks like this: <br><br><img title="Materialized Path" src="https://habrastorage.org/getpro/habr/post_images/55c/36b/37b/55c36b37b77a5d3c8e23b66fd53cd807.gif" width="496" height="378"><br><br>  <em>Fig.</em>  <em>7. Tree structure, organized according to the principle ‚Äúmaterialized way‚Äù</em> <br><br>  The principle of forming such paths is quite simple.  The depth of the path is the level of the tree.  Within the branch numbering - incremental.  In other words, VEGETABLE is the first child of FOOD, FRUIT is the second child, etc. <br><br>  It will be easier to look at this in the form of a table: <br><br><blockquote><pre>  + --------------- + ------- +
 |  name |  path |
 + --------------- + ------- +
 |  FOOD |  1 |
 |  VEGETABLE |  1.1 |
 |  POTATO |  1.1.1 |
 |  TOMATO |  1.1.2 |
 |  FRUIT |  1.2 |
 |  APPLE |  1.2.1 |
 |  BANANA |  1.2.2 |
 + --------------- + ------- + </pre></blockquote><br><br>  Perhaps even more clearly. <br><br>  All this is reflected in the database. <br><br><img title="Materialized Path Table Structure" src="https://habrastorage.org/getpro/habr/post_images/051/fca/96a/051fca96a9b383a0554ffbd9188fe61d.png" width="167" height="72"><br><br>  <em>Fig.</em>  <em>8. the structure of the hierarchical data table organized according to the ‚Äúmaterialized way‚Äù principle</em> <br><br>  Or in the form of SQL: <br><br><blockquote><pre>  CREATE TABLE mp_tree (
     `id` BIGINT NOT NULL AUTO_INCREMENT PRIMARY KEY,
     `name` VARCHAR (50) NOT NULL,
     `path` VARCHAR (100) NOT NULL
 ) TYPE = InnoDB DEFAULT CHARSET = utf8;

 CREATE INDEX mpp_idx ON mp_tree (`path`);

 INSERT INTO mp_tree VALUES
     (1, 'FOOD', '1'),
     (2, 'VEGETABLE', '1.1'),
     (3, 'POTATO', '1.1.1'),
     (4, 'TOMATO', '1.1.2'),
     (5, 'FRUIT', '1.2'),
     (6, 'APPLE', '1.2.1'),
     (7, 'BANANA', '1.2.2'); </pre></blockquote><br><br>  What is the advantage of this approach? <br><br>  First, compared to the Nested Set, it is more amenable to change.  At the same time, it remains quite convenient for sampling entire trees and their parts.  But, and he is not perfect.  Especially in the search for the ancestors of the branch. <br><br>  <strong>Search for a node path:</strong> <br><br><blockquote><pre>  SELECT t1.name from mp_tree t1, mp_tree t2
 WHERE t2.path like CONCAT (t1.path, '.%')
 AND t2.id = 3;  / * Search for the path to the node named 'POTATO' * / </pre></blockquote><br><br>  Result: <br><br><blockquote><pre>  + ----------- +
 |  name |
 + ----------- +
 |  FOOD |
 |  VEGETABLE |
 + ----------- + </pre></blockquote><br><br>  <strong>Calculate nesting level.</strong> <br><br>  To solve this problem, we basically need to count the number of points (or other separators, if you use a non-point) in the paths.  Unfortunately, MySQL does not have a suitable function, but we can implement it quite simply on our own: <br><br><blockquote><pre>  CREATE FUNCTION STRFIND (str VARCHAR (255), delimtr CHAR (1)) RETURNS INT
 BEGIN
 DECLARE _cnt INT;
 DECLARE _start INT;
 SET _cnt = -1;
 SET _start = 1;
 WHILE _start&gt; 0 DO
   SET _start = LOCATE (delimtr, str);
   SET str = SUBSTRING (str, _start + 1);
   SET _cnt = _cnt + 1;
 END WHILE;
 RETURN _cnt;
 END </pre></blockquote><br><br>  <strong>Branch selection:</strong> <br><br><blockquote><pre>  SELECT name, strfind (path, '.') AS level 
 FROM mp_tree 
 WHERE path LIKE '1.1%';  / * Select the entire 'VEGETABLES' branch * /; </pre></blockquote><br><br>  Result: <br><br><blockquote><pre>  + ----------- + ------- +
 |  name |  level |
 + ----------- + ------- +
 |  VEGETABLE |  1 |
 |  POTATO |  2 |
 |  TOMATO |  2 |
 + ----------- + ------- + </pre></blockquote><br><br>  Please note that in this example we used our samopisnaya function and it was quite convenient. <br><br>  <strong>Parent Search:</strong> <br><br><blockquote><pre>  SELECT t2. * 
 FROM mp_tree t1, mp_tree t2 
 WHERE t1.id = 3 AND t2.path = SUBSTRING (t1.path, 1, (LENGTH (t1.path) - LOCATE ('.', REVERSE (t1.path))))); </pre></blockquote><br><br>  As you can see, all these requests do not make maximum performance (compared to the previous method), but, nevertheless, the use of this particular algorithm can be much more convenient for trees, on which both read operations and changes are often performed. <br><br>  As far as the author knows, the algorithm feels pretty confident on fairly large amounts of data. <br><br>  It should be noted that the most unpleasant in this algorithm will be the operation of inserting a node into the middle of an already existing structure (between other nodes), since  this will change all the paths in the underlying nodes.  Although, in fairness, it should be said that such an operation will be non-trivial for any data storage model.  Another major operation is transferring one branch to another. <br><br>  But deleting, adding to the end or changing the node - these operations are quite simple, and, as a rule, do not cause difficulties in this model. <br><br>  As can be seen from the examples, this algorithm can also be somewhat optimized for reading by introducing another level field, as was done for the lists of adjacent vertices (Nested Set).  However, it will somewhat complicate the operations of adding, changing and deleting tree nodes, since  levels will have to be recalculated for the whole or part of the tree with each change.  Ultimately, it is the developer who decides which way to skew the performance. <br><br><h3>  Use in Doctrine </h3><br><br>  Unfortunately, at the moment, this method of storing trees has not yet found its implementation in ORM Doctrine (the current version at the time of writing this material is 1.0.4, 1.1.0 ‚Äî it also has no implementation in the alpha version). <br><br>  Nevertheless, there are all prerequisites for believing that its implementation will appear in the future, since  the source code of the library contains in the Doctrine / Tree package an abstract empty class called MaterializedPath. <br><br>  The author will follow the events and update this article as soon as the implementation is reflected, so you can return here later. <br><br><h2>  Combined approach </h2><br><br>  In fact, it should be noted that the above methods can be combined only in two directions: <br><ul><li>  Adjacency List + Materialized Path </li><li>  Adjacency Lists + Nested Sets (Adjacency List + Nested Set) </li></ul><br>  Combining the same Nested Set and Materialized Path does not make much sense, because  There is no significant gain in reading or writing. <br><br>  In fact, combining approaches at the database level is limited to entering a field that stores a link to the parent entry in the adjacency list tables and materialized paths: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/235/bd0/09b/235bd009bafdd26ee393aafd6e540f90.png" title="Tables of data structures AL + MP and AL + NS" width="420" height="106"><br><br>  <em>Fig.</em>  <em>9. Tables of models of hierarchical data structures AL + MP and AL + NS</em> <br><br>  The implications of this approach are obvious. <br><br>  <strong>AL + MP</strong> <br><br>  For AL when used with MP: <br><ul><li>  Entire branch and subtree sampling operations are improved. </li><li>  Worsening branch transfer operations </li></ul><br><br>  For MP when used with AL: <br><ul><li>  Improved parent sampling operations for a given node </li><li>  Improved selection of the heirs of a given node </li></ul><br><br>  <strong>AL + NS</strong> <br><br>  For the AL + NS bundle, reciprocity is not so obvious.  This is primarily due to the fact that the disadvantages of the problems of changing tree nodes in the NS model completely kill all the advantages of AL in this area.  This means that such a bundle should be considered only as a qualitative improvement in the search for parents and heirs of a given node in the NS algorithm, and also as an increase in the reliability of the algorithm itself (the keys can always be rebuilt in the event of damage - the information about the links is stored in AL).  The statement about the increase in reliability is true for the previous combination of methods.  But this is also a qualitative improvement, although not so obvious, is it? <br><br><h2>  Conclusion </h2><br><br>  In this article, we looked at several basic methods for storing hierarchical data in relational databases and outlined all their advantages and disadvantages.  We also showed in practice which of them are available for use in the implementation of the Doctrine ORM, and how to use them. <br><br>  Obviously, even choosing one method or another in each specific case is not a simple task, but the author hopes that this material will facilitate the adoption of a conscious and correct decision, and will also contribute to the creative process of finding new and more optimal solutions. <br><br>  Good luck in development! <br><br><blockquote>  <sub>PS This is a cross-post of the <a href="http://mikhailstadnik.com/hierarchical-data-structures-and-doctrine">original article</a> from my blog.</sub> </blockquote></div><p>Source: <a href="https://habr.com/ru/post/46659/">https://habr.com/ru/post/46659/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../46651/index.html">3M</a></li>
<li><a href="../46652/index.html">Wine coolers</a></li>
<li><a href="../46654/index.html">New album McCartney released in the figure without DRM</a></li>
<li><a href="../46656/index.html">ARM S3C2440 Development Board: assemble a handheld on the knee</a></li>
<li><a href="../46658/index.html">Ten most stupid IT predictions from version T3</a></li>
<li><a href="../46660/index.html">100,000,000 Americans are watching YouTube</a></li>
<li><a href="../46661/index.html">Social network for equity investors</a></li>
<li><a href="../46665/index.html">Falcon Northwest Mach V - the fastest PC in the world</a></li>
<li><a href="../46666/index.html">Full translation of Web Standards Curriculum</a></li>
<li><a href="../46667/index.html">Neat: new kind of spam</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>