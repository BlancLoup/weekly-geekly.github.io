<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Holiday geeky: with ARM and TFT LCD</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 
 Having seen posts from dlinyj , goodic and Hoshi, I once again felt that Habr is a cake. 

 The first post concerned writing a characte...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Holiday geeky: with ARM and TFT LCD</h1><div class="post__text post__text-html js-mediator-article"><h4>  Introduction </h4><br><img src="https://habrastorage.org/getpro/habr/post_images/30c/3bc/362/30c3bc362c114ba88e0b591830fef111.jpg" alt="Result" align="right">  Having seen posts from <a href="https://habrahabr.ru/users/dlinyj/" class="user_link">dlinyj</a> , <a href="https://habrahabr.ru/users/goodic/" class="user_link">goodic</a> and <a href="https://habrahabr.ru/users/hoshi/" class="user_link">Hoshi,</a> I once again felt that Habr is a cake. <br><br>  The first post concerned writing a character driver based on the HD44780 for Linux ( <a href="http://habrahabr.ru/post/206148/">Creating your own Linux drivers</a> from <a href="https://habrahabr.ru/users/dlinyj/" class="user_link">dlinyj</a> );  The excellent answers to it were the posts of goodic <a href="https://habrahabr.ru/users/goodic/" class="user_link">habrauers</a> ( <a href="http://habrahabr.ru/post/206692/">Congratulations on geeks, without writing firewood</a> ) and <a href="https://habrahabr.ru/users/hoshi/" class="user_link">Hoshi</a> ( <a href="http://habrahabr.ru/post/206782/">New Year raspberry - fastening the HD44780 screen to Raspberry Pi</a> ). <br><br>  I also wanted to participate in this celebration of life and implement my hardware <code>vt52-like</code> terminal.  I didn't have a character display, but there was a Chinese dev-board based on ARM Cortex-M3 with a full TFT-display 240x320, partial documentation. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      There was a lot of enthusiasm, so, waking up on Sunday afternoon (~ 17 MSK), I began to write the embedded driver for this LCD. <br><br>  If you are interested in embedded ARM programming, electronics or just the result, I ask for cat. <br><a name="habracut"></a><br><h4>  Iron </h4><br>  I had a simple debug board from the Middle Kingdom (costing about $ 20) based on an <a href="http://www.st.com/web/en/resource/technical/document/datasheet/CD00161566.pdf" title="ST STM32F103xB datasheet">ST STM32F103RB microcontroller</a> with a USB-to-UART <a href="http://www.prolific.com.tw/UserFiles/files/ds_pl2303HXD_v1_4_4.pdf" title="Prolific PL-2303HX datasheet">Prolific PL-2303HX</a> hardware bridge, a bunch of small peripherals and a TFT LCD with an <a href="http://www.densitron.com/uploadedFiles/Displays/Support/ILI9320AN_V0.92.pdf" title="Ilitek ILI9320 datasheet">Ilitek ILI9320</a> controller with an unknown wiring diagram. <br><br>  <a href="https://www.olimex.com/Products/ARM/JTAG/ARM-USB-TINY-H/">Olimex JTAG ARM-TINY-USB-H was</a> used as an in-circuit debugger and programmer.  Good device, it works fine with <a href="http://openocd.sourceforge.net/">OpenOCD</a> . <br><br><div class="spoiler">  <b class="spoiler_title">devboard</b> <div class="spoiler_text"><img src="https://habrastorage.org/getpro/habr/post_images/4ed/606/9bb/4ed6069bb4c56bc82605f71b16c04e0d.jpg" alt="devboard"></div></div><br><br>  More precisely, initially it was not even known what the controller is on the LCD.  All that could be learned from the display module, that it is connected via a 16-bit bus, has <code>nCS</code> , <code>nWR</code> , <code>nRD</code> , <code>BL_EN</code> and <code>RS</code> signals, <br>  the purpose of which was not difficult to guess: <br><ul><li>  <code>nCS</code> - bus display activation (hereinafter the prefix <code>n</code> means that the active signal level is 0) </li><li>  <code>BL_EN</code> - backlight control </li><li>  <code>nWR</code> - records </li><li>  <code>nRD</code> - reading </li><li>  <code>RS</code> - register selection </li></ul><br><br>  In one of the archives with the documentation found on the open spaces of the Chinese segment of the Internet there was a similar fee to <br>  module Ilitek 932x. <br><br><h4>  Software interfaces </h4><br><h5>  Low-level interface </h5><br>  Since there are not many descriptions of work with this LCD controller in Runet, I will probably describe a low-level interface. <br><br>  In essence, this controller has 4: i80-system (parallel interface, a-la regular memory, similar to HD44780 interface), SPI, VSYNC (system + <code>VSYNC</code> , with internal clock) and RGB ( <code>VSYNC</code> , <code>HSYNC</code> , <code>ENABLE</code> , with external <code>DOTCLK</code> clocking).  In my case, i80-system is available and, possibly, SPI (did not check). <br><br>  Since I used only the system, we‚Äôll do its description.  In order not to load much into the article - it will be in the spoiler. <br><br><div class="spoiler">  <b class="spoiler_title">Electrical interface ILI9320</b> <div class="spoiler_text">  At the electrical level, working with digital technology is usually described by timing charts.  In our case, there are five control signals and a 16-bit data bus. <br><br>  Before transmitting any information to the <code>nCS</code> , the interface should be activated by the <code>nCS</code> signal, setting it to 0. <br><br>  Further, with the <code>RS</code> set to 0, the register address is written into which information will be written (the actual recording is performed by activating the <code>nWR</code> signal. The <code>RS</code> signal is set back to 1. <br><br>  After that, the actual read or write operation is performed (using <code>nRD</code> and <code>nWR</code> respectively). <br><br>  Diagrams of these processes are as follows: <br><table><thead><tr><th>  op </th><th></th></tr></thead><tbody><tr><td>  read </td><td><img src="https://habrastorage.org/getpro/habr/post_images/ae8/3db/ac5/ae83dbac57fa56e86a7390847bc7920e.png" alt="LCD read op" title="LCD read timing diagram"></td></tr><tr><td>  write </td><td><img src="https://habrastorage.org/getpro/habr/post_images/d1f/234/d79/d1f234d797cf255bb678056b6ea0cd18.png" alt="LCD write op" title="LCD write timing diagram"></td></tr></tbody></table><br><br>  When writing / reading from GRAM, a special register <code>0x22</code> .  In addition, the controller can auto-increment <br>  addresses GRAM, which allows you to read / write its contents sequentially. <br><br>  Charts: <br><table><thead><tr><th>  op </th><th></th></tr></thead><tbody><tr><td>  GRAM read </td><td><img src="https://habrastorage.org/getpro/habr/post_images/4a3/a19/e43/4a3a19e4325502dd381375643db7aebd.png" alt="LCD GRAM read op" title="LCD GRAM read timing diagram"></td></tr><tr><td>  GRAM write </td><td><img src="https://habrastorage.org/getpro/habr/post_images/271/26a/45e/27126a45e7c8157ea133ecaa642509cc.png" alt="LCD GRAM write op" title="LCD GRAM write timing diagram"></td></tr></tbody></table><br><br>  After performing operations, <code>nCS</code> set back to 1. <br><br>  For drawing timing charts, I found a wonderful <a href="http://wavedrom.com/" title="Wavedrom timing diagram editor">wavedrom</a> project running in a browser.  Test <a href="http://wavedrom.com/editor.html" title="Wavedrom timing diagram editor">here</a> (here the schemes were prepared above). </div></div><br><br>  Low-level functions were written based on the electrical interface: <br><br><div class="spoiler">  <b class="spoiler_title">lcd_ll_funcs</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> _lcd_select(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { GPIO_ResetBits(GPIOC, GPIO_Pin_9); } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> _lcd_deselect(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { GPIO_SetBits(GPIOC, GPIO_Pin_9); } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> _lcd_rs_set(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { GPIO_SetBits(GPIOC, GPIO_Pin_8); } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> _lcd_rs_reset(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { GPIO_ResetBits(GPIOC, GPIO_Pin_8); } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> _lcd_rd_en(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { GPIO_ResetBits(GPIOC, GPIO_Pin_11); } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> _lcd_rd_dis(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { GPIO_SetBits(GPIOC, GPIO_Pin_11); } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> _lcd_wr_en(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { GPIO_ResetBits(GPIOC, GPIO_Pin_10); } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> _lcd_wr_dis(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { GPIO_SetBits(GPIOC, GPIO_Pin_10); } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> _lcd_bl_en(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { GPIO_SetBits(GPIOC, GPIO_Pin_12); } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> _lcd_bl_dis(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { GPIO_ResetBits(GPIOC, GPIO_Pin_12); } <span class="hljs-comment"><span class="hljs-comment">// changes DB[15:0] GPIO pins mode void lcd_gpio_conf(GPIOMode_TypeDef mode); void _lcd_put_data(u16 data) { // data[0-7] -&gt; GPIOC[0-7], data[8-15] -&gt; GPIOB[8-15] GPIOB-&gt;ODR = (GPIOB-&gt;ODR&amp;0x00ff)|(data&amp;0xff00); GPIOC-&gt;ODR = (GPIOC-&gt;ODR&amp;0xff00)|(data&amp;0x00ff); } u16 _lcd_read_data(void) { lcd_gpio_conf(GPIO_Mode_IN_FLOATING); u16 result = (GPIOB-&gt;IDR&amp;0xff00)|(GPIOC-&gt;IDR&amp;0x00ff); lcd_gpio_conf(GPIO_Mode_Out_PP); return result; } // assume that lcd_select() was done before it void _lcd_tx_reg(u8 addr) { _lcd_put_data(addr); _lcd_rs_reset(); _lcd_wr_en(); _lcd_wr_dis(); _lcd_rs_set(); } // assume that _lcd_tx_reg(u8) was done before it void _lcd_tx_data(u16 data) { _lcd_put_data(data); _lcd_wr_en(); _lcd_wr_dis(); } // assume that _lcd_tx_reg(u8) was done before it u16 _lcd_rx_data(void) { _lcd_rd_en(); u16 result = _lcd_read_data(); _lcd_rd_dis(); return result; }</span></span></code> </pre></div></div><br><br>  To speed up, you can zainlaynit these functions and convert to macros (with which Eclipse is not very friendly, unfortunately). <br><br>  Based on these functions, the functions of writing to the register, reading from the register, blitting the image are implemented. <br><br><h5>  High-level interface </h5><br>  The functions of the LCD display for the main part of the program are available through the following API: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">u16 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lcd_init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lcd_set_cursor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(u16 x, u16 y)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lcd_set_window</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(u16 left, u16 top, u16 right, u16 bottom)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lcd_fill</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(u32 color)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lcd_rect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(u16 left, u16 top, u16 right, u16 bottom)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lcd_put_char_at</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(u32 data, u16 x, u16 y)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">u32 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lcd_get_fg</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">u32 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lcd_get_bg</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lcd_set_fg</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(u32 color)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lcd_set_bg</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(u32 color)</span></span></span></span>;</code> </pre><br><br>  Terminal functions use this interface for all their operations. <br><br>  The most interesting part is the function of drawing a symbol, since it hides all the work with fonts.  It looks like this: <br><br><div class="spoiler">  <b class="spoiler_title">lcd_put_char_at</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lcd_put_char_at</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(u32 data, u16 x, u16 y)</span></span></span><span class="hljs-function"> </span></span>{ u8 xsize, ysize; u8 *char_img; lcd_get_char(data, &amp;xsize, &amp;ysize, &amp;char_img); lcd_set_cursor(x, y); lcd_set_window(x, y, x + xsize, y + ysize); _lcd_select(); _lcd_tx_reg(<span class="hljs-number"><span class="hljs-number">0x22</span></span>); <span class="hljs-comment"><span class="hljs-comment">// works only for 8xN fonts for(u8 i = 0; i &lt; ysize; i++) { u8 str = char_img[i]; for(u8 j = 0; j &lt; xsize; j++) { _lcd_tx_data((str&amp;(1&lt;&lt;(xsize-j-1)))?fg_color:bg_color); } } _lcd_deselect(); }</span></span></code> </pre></div></div><br><br>  As you can see, the link to the character bitmap and its size comes from the <code>lcd_get_char</code> function by the character code (it is 32-bit, so that the additional characters do not rub the ASCII part). <br><br>  The font currently in use is the font that contains the bottom of the ASCII table plus the herringbone.  Those interested can try to find it,) <br><br><div class="spoiler">  <b class="spoiler_title">debug</b> <div class="spoiler_text"><img src="https://habrastorage.org/getpro/habr/post_images/650/510/3ec/6505103eca23a2a81774d364e36d4fed.jpg" alt="debug"></div></div><br><br>  The least interesting and most costly (in terms of writing time) is the function of display initialization: <br><div class="spoiler">  <b class="spoiler_title">lcd_init: for those who want to get scared</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">u16 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lcd_init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB | RCC_APB2Periph_GPIOC, ENABLE); GPIO_InitTypeDef gpio_conf; gpio_conf.GPIO_Speed = GPIO_Speed_50MHz; gpio_conf.GPIO_Mode = GPIO_Mode_Out_PP; gpio_conf.GPIO_Pin = GPIO_Pin_8 | GPIO_Pin_9 | GPIO_Pin_10 | GPIO_Pin_11 | GPIO_Pin_12; GPIO_Init(GPIOC, &amp;gpio_conf); lcd_gpio_conf(GPIO_Mode_Out_PP); <span class="hljs-comment"><span class="hljs-comment">// to init state (0xffff on db0-15, backlit is disabled, nCS, nWR, nRD and RS are high) _lcd_bl_dis(); _lcd_put_data(0xffff); _lcd_deselect(); _lcd_wr_dis(); _lcd_rd_dis(); _lcd_rs_set(); // osc enable _lcd_bl_dis(); lcd_write_reg(0x00, 0x0001); delay_ms(100); u16 lcd_code = lcd_read_reg(0x00); delay_ms(100); // driver output control (S720-S1) lcd_write_reg(0x01, 0x0100); // driving wave control (line inv) lcd_write_reg(0x02, 0x0700); // entry mode (horiz, dir(h+,v+), hwm-, bgr+) lcd_write_reg(0x03, 0x1030); // resize (off) lcd_write_reg(0x04, 0x0000); // display control 2 (skip 2 lines on front porch and on back porch) lcd_write_reg(0x08, 0x0202); // display control 3-4 (scan mode normal, fmark off) lcd_write_reg(0x09, 0x0000); lcd_write_reg(0x0a, 0x0000); // RGB disp iface control (int clock, sys int, 16bit) lcd_write_reg(0x0c, 0x0001); // frame marker position (isn't used) lcd_write_reg(0x0d, 0x0000); // RGB disp iface control 2 (all def, we don't use rgb) lcd_write_reg(0x0f, 0x0000); // power on seq lcd_write_reg(0x07, 0x0021); delay_ms(10); // turn on power supply and configure it (enable sources, set contrast, power supply on) lcd_write_reg(0x10, 0x16b0); // set normal voltage and max dcdc freq lcd_write_reg(0x11, 0x0007); // internal vcomh (see 0x29), pon, gray level (0x08) lcd_write_reg(0x12, 0x0118); // set vcom to 0.92 * vreg1out lcd_write_reg(0x13, 0x0b00); // vcomh = 0.69 * vreg1out lcd_write_reg(0x29, 0x0000); // set x and y range lcd_write_reg(0x50, 0); lcd_write_reg(0x51, LCD_WIDTH-1); lcd_write_reg(0x52, 0); lcd_write_reg(0x53, LCD_HEIGHT-1); // gate scan control (scan direction, display size) lcd_write_reg(0x60, 0x2700); lcd_write_reg(0x61, 0x0001); lcd_write_reg(0x6a, 0x0000); // partial displays off for(u8 addr = 0x80; addr &lt; 0x86; addr++) { lcd_write_reg(addr, 0x0000); } // panel iface control (19 clock/line) lcd_write_reg(0x90, 0x0013); // lcd timings lcd_write_reg(0x92, 0x0000); lcd_write_reg(0x93, 0x0001); lcd_write_reg(0x95, 0x0110); lcd_write_reg(0x97, 0x0000); lcd_write_reg(0x98, 0x0000); lcd_write_reg(0x07, 0x0133); // turn on backlit after init done _lcd_bl_en(); return lcd_code; }</span></span></code> </pre></div></div><br><br><h4>  Terminal implementation </h4><br>  This part is not particularly remarkable.  Implemented unbuffered terminal, with part of the codes from previous articles. <br><br><div class="spoiler">  <b class="spoiler_title">escape sequences</b> <div class="spoiler_text">  Escape sequences: <br><ul><li>  \ 033 [A = Move cursor one line up </li><li>  \ 033 [B = Move cursor one line down </li><li>  \ 033 [C = Move the cursor one position to the right </li><li>  \ 033 [D = Move the cursor one position to the left </li><li>  \ 033 [H = Move the cursor to the upper left corner - home (position 0,0) </li><li>  \ 033 [J = Clear all, does NOT return the cursor home! </li><li>  \ 033 [K = Erases to the end of the line, does NOT return the cursor home! </li><li>  \ 033 [M = New Character Map - Not Implemented </li><li>  \ 033 [Y = Position, accepts YX </li><li>  \ 033 [X = Position, takes XY </li><li>  \ 033 [R = CGRAM Memory selection is not implemented, since there is no CGRAM </li><li>  \ 033 [V = Scroll Enabled - Not Implemented </li><li>  \ 033 [W = Scrolling disabled - not implemented </li><li>  \ 033 [b = Backlight on / off - not implemented </li></ul><br><br>  Other useful codes: <br><ul><li>  \ r = Carriage return (return the cursor to position 0 on the current line!) </li><li>  \ n = New line </li><li>  \ t = Tab (default 3 characters) </li></ul><br></div></div><br><br><h4>  Communications </h4><br>  To interact with the outside world, <code>USART1</code> used in asynchronous mode via the <code>PL-2303HX</code> USB-to-UART <code>PL-2303HX</code> . <br><br>  From the point of view of the Linux host on board, this is <code>/dev/ttyUSBx</code> .  Unfortunately, the drivers for <code>pl2303</code> were rather unstable.  But, as soon as picked up, work well. <br><br>  In order not to poll the UART in the main loop (which is empty), work with it is implemented on interrupts. <br><br>  From a software point of view, this means that after initializing USART1, you must configure the corresponding interrupt vector in <abbr title="Nested Vectored Interrupt Controller">NVIC</abbr> . <br><br>  It looks like this: <br><pre> <code class="cpp hljs">NVIC_InitTypeDef nvic_conf; nvic_conf.NVIC_IRQChannel = USART1_IRQn; nvic_conf.NVIC_IRQChannelPreemptionPriority = <span class="hljs-number"><span class="hljs-number">0</span></span>; nvic_conf.NVIC_IRQChannelSubPriority = <span class="hljs-number"><span class="hljs-number">2</span></span>; nvic_conf.NVIC_IRQChannelCmd = ENABLE; NVIC_Init(&amp;nvic_conf); USART_ITConfig(USART1, USART_IT_RXNE, ENABLE);</code> </pre><br><br>  The last command allows the event to fill the receiving register USART1. <br><br>  Accordingly, the processing looks like this: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">USART1_IRQHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ u8 data = USART1-&gt;DR; uart_write_byte(data); handle_byte(data); }</code> </pre><br><br>  We send the byte back (echo) and call the handler, which is a simple state machine. <br><div class="spoiler">  <b class="spoiler_title">handle_byte (u8)</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// escape sequence handling vars u8 escape_seq = 0; u8 buf[10]; void handle_byte(u8 data) { if((!escape_seq) &amp;&amp; (data == 0x1b)) { escape_seq = 1; } else if (escape_seq == 1) { buf[escape_seq] = data; escape_seq++; if(data != '[') { escape_seq = 0; } } else if (escape_seq == 2) { switch(data) { case 'A': lcd_term_set_cursor(lcd_term_row()-1, lcd_term_col()); break; case 'B': lcd_term_set_cursor(lcd_term_row()+1, lcd_term_col()); break; case 'C': lcd_term_set_cursor(lcd_term_row(), lcd_term_col()+1); break; case 'D': lcd_term_set_cursor(lcd_term_row(), lcd_term_col()-1); break; case 'H': lcd_term_set_cursor(0, 0); break; case 'J': lcd_term_clear(); break; case 'K': lcd_term_flush_str(); break; case 'X': case 'Y': buf[escape_seq] = data; escape_seq++; return; } escape_seq = 0; } else if(escape_seq == 3) { buf[escape_seq] = data; escape_seq++; } else if(escape_seq == 4) { u8 row = (buf[2] == 'Y') ? buf[3] - 037 : data - 037; u8 col = (buf[2] == 'Y') ? data - 037 : buf[3] - 037; lcd_term_set_cursor(row, col); escape_seq = 0; } else { lcd_term_put_str(&amp;data, 1); } }</span></span></code> </pre></div></div><br><br>  All code is published in the <a href="https://github.com/grossws/stm32-lcd/">github</a> repository. <br><br><h4>  PS </h4><br>  Writing this post took almost 6 hours.  Writing and debugging of the hardware-software part is about 13 hours. <br><br>  Thanks to everyone who read it.  About any ochepyatkah and other insects, write in a personal. </div><p>Source: <a href="https://habr.com/ru/post/207136/">https://habr.com/ru/post/207136/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../207124/index.html">Yandex.Disk congratulates the new year</a></li>
<li><a href="../207126/index.html">Zoo of Algebraic Data Types</a></li>
<li><a href="../207130/index.html">LEDs in the snow</a></li>
<li><a href="../207132/index.html">10 new commercials from Trailer Studio</a></li>
<li><a href="../207134/index.html">Who, when and how is going to fly to Mars</a></li>
<li><a href="../207138/index.html">School bell on Raspberry Pi with remote control</a></li>
<li><a href="../207140/index.html">Capturing and shooting a demo video of an iOS application with improvised and not so much means - ways and solutions</a></li>
<li><a href="../207144/index.html">Silent Domain Authorization at GlassFish</a></li>
<li><a href="../207146/index.html">10,000,000 repositories</a></li>
<li><a href="../207148/index.html">PostgreSQL New Year Check</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>