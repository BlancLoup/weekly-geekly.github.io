<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Celesta and Flute: Creating Business Logic in the Java Ecosystem</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hi, Habr! The project, which we describe, from the very beginning was created by us as open-source, but until recently we used it only for our own nee...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Celesta and Flute: Creating Business Logic in the Java Ecosystem</h1><div class="post__text post__text-html js-mediator-article">  Hi, Habr!  The project, which we describe, from the very beginning was created by us as open-source, but until recently we used it only for our own needs, we did not talk about it extensively and did not create a community.  Now, after a few years of development, we felt confident that it was time to talk about him, and we hope that he will begin to benefit not only us. <br><br><img src="https://habrastorage.org/web/931/202/2f7/9312022f7c9f44e588db2e501da7a270.png" alt="Ian Anderson and John Lord"><br><br><a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Celesta ( <a href="https://ru.wikipedia.org/wiki/%25D0%25A7%25D0%25B5%25D0%25BB%25D0%25B5%25D1%2581%25D1%2582%25D0%25B0">Celesta</a> ) is the ‚Äúengine‚Äù of Jython language embedded in Java applications.  Flute (flute) is a component that allows the celesto to work as a service.  First, we will talk about why this is generally necessary, but if you want to skip the introduction and go directly to the technical part, then you should go to Part II. <br><br><h2>  Part I, introductory </h2><br><h3>  What is Celesta for? </h3><br>  The problem to be solved is this: how to embed business logic into a Java application or, more broadly, into an application running in a Java ecosystem. <br><br>  It would seem, why is there to reinvent the next "bicycle"?  After all, we know that there are special systems for working with business logic and writing business applications.  The most common in Russia is ‚Äú1C‚Äù, there is Microsoft Dynamics, SAP and many others.  And in working with such software products involved, apparently, at least half of all IT professionals around the world.  At least, the founder of "1C" <a href="https://roem.ru/08-06-2015/197404/1s-nuraliev-view/">claims</a> that out of a million IT professionals in Russia, one third are 1C specialists. <br><br>  At the same time, there are always more local tasks where attracting such systems is problematic.  Suppose there is an online store, and "behind" it should be some business logic that processes orders.  Is it possible to supply one of the above large systems for processing business logic?  Full  But the inconvenience is that if the entire store, for example, is written in the Java ecosystem, the business application creation system is no longer in the Java ecosystem, which makes integration difficult.  The system is expensive in licensing and support, requires special experts.  And the tasks that in these cases are assigned to this system are not so global.  The price of the issue turns out to be unreasonably high, and a solution of the Celesta caliber might look like a good alternative. <br><br>  Very often there are tasks related to the implementation of a process of working with a document.  For example, negotiating a contract or an application for payment.  The classic solution is to use systems like Documentum, Alfresco, etc.  (often used the term CMS + BPM, i.e. Content Management + Business Process Management).  However, these are all fairly complex infrastructure systems.  It makes sense to use them if you need to work with a large number of documents of different types and support a lot of business processes.  And if you do not want to go beyond a specific project?  Celesta + <a href="https://www.activiti.org/">Activiti</a> perfectly solve the problem.  Celesta at the same time meaningful work with the document, and Activiti will show what and in what order should be performed. <br><br>  Therefore, we decided to create a solution that would allow us, without going beyond the limits of the Java ecosystem, and without introducing new large components into the infrastructure, to create quite effective modules that control the business logic that our customer needs. <br><br>  Over several years of work, we have implemented solutions based on our platform in quite a few organizations, some of which <a href="https://corchestra.ru/">are listed</a> on the platform website. <br><br><h3>  How does ‚Äúbusiness logic‚Äù differ from simple logic? </h3><br>  Why do we need special systems for business logic?  Why "you can not just take" and write in Java, say, accounting for finances or stock balances?  After all, it would seem, what difference does it make where to add sums of money - in Java or in 1C (in Java, moreover, the calculations will most certainly be faster).  Why do we have 1C, SAP and similar platforms? <br><br>  The problem primarily lies in the <b>variability of the</b> logic of the system.  It is impossible to create a business application ‚Äúonce and for all‚Äù: changes to the requirements for a business application come in a continuous stream at all stages of its life cycle: development, implementation, operation - because a business process lives and develops that the application should automate.  One might think that such a number of changes is the result of an incorrect initial analysis or poor organization of the whole process.  But no, this is an objective property of real life, and not only in commercial organizations.  For example, in state structures, requirements are essentially determined by regulatory documents (laws, decrees, orders, etc.).  It happens that a project for a state structure must be submitted by a certain date, but until the last moment it is not known whether the Prime Minister will sign or not sign a resolution on which the functional requirements for the system will depend, and its exact content is unknown. <br><br>  Another specific feature of business applications is the <b>need to ensure data integrity</b> .  If we take into account the sale, it should be reflected in all the necessary books of operations.  If, say, a sale, reflected in the subsystem responsible for logistics, is not reflected in the balance sheet, this will lead to big problems. <br><br>  The third specific feature is the <b>inability to predict data access requirements</b> .  At the initial stage, it is even impossible to clearly define in which format the data will be required at the output, how they will be segmented, and in which documents.  It is necessary to build such a system so that the data output can be changed quite quickly, on the go. <br><br>  How usually solutions for business logic cope with these tasks? <br><br><div style="text-align:center;"><img width="350" src="https://habrastorage.org/web/1f3/d0e/777/1f3d0e7774e14cea8c56b9543cd48dc9.png"></div><br><br>  First, due to the separation of code on the platform and business logic.  This applies to all systems of this class.  There is a platform code that provides basic things, and there is a business logic code that is written most often in a specialized language: for example, 1C, Microsoft Dynamics and SAP offer their own languages ‚Äã‚Äãfor writing business logic. <br><br>  The platform code, which solves the most basic tasks, is made by the authors of the platform and modified only together with the releases of the new versions of the platform.  Business logic code is constantly changing by business logic developers. <br><br>  Secondly (in our time it is especially necessary to emphasize) - the use of relational DBMS.  Despite the strong development of NoSQL-databases, for solving problems of building business logic, today the best tool remains relational DBMS.  The best - if only because it is older, more mature projects.  All the main advantages of relational DBMSs that are not present in many of the NoSQL databases remain in demand.  This is also the atomic nature of operations - the possibility in case of an error to roll back a transaction with a large number of changes, as if it had not begun.  This is isolation.  This and ensuring integrity through foreign keys.  And the ability to provide fast data retrieval in any format.  Let's not forget about the need for integration with a huge number of legacy-systems, data of which are in relational DBMS.  In general, relational database management systems have been and remain the main data storage tool in such systems. <br><br><h3>  How does the creation of business logic differ from ‚Äúordinary‚Äù coding? </h3><br>  With things that make the development of business logic "special", of course.  How does it look like the rest of the program code, be it games or operating systems? <br><br><ul><li>  First of all, we should have standard code control tools, version control.  Today everyone is using Git - let it be Git.  There will be an even more convenient "Git ++", then let it be even more convenient "Git ++".  Surprisingly, many ‚Äúlarge‚Äù business logic creation platforms have not resolved this issue: for example, in Microsoft Dynamics the code is stored directly in the database, there is even no elementary version control! </li><li>  There should be a convenient IDE, preferably the one to which everyone is used and able to work productively: in the Java world it is IDEA or Eclipse.  Manufacturers of "large" platforms, creating their own programming languages, often do not pay due attention to the convenience of the IDE. </li><li>  There should be a convenient opportunity to test the code, unit tests should be easily accessible, it should be possible to implement test-driven development.  Like any other applications, business applications should not be mistaken. </li></ul> Business applications must comply with the overall IT infrastructure of the project. <br><br><h3>  Where is the place for Celesta? </h3><br>  In practice, it is practically impossible to combine the business logic development platform and the listed requirements.  We have two extremes. <br><br>  One extreme is the total use of a large system such as 1C, Microsoft Dynamics, SAP, etc., to solve any problems at all.  Often, these systems constrain developers, deprive them of their usual tools and development methods (for example, it is impossible to perform automated testing with standard tools), this increases the cost and lengthens the development time.  For typical large-scale tasks, this is justified, but for small tasks this approach can be disastrous. <br><br>  The opposite extreme is to take on any task on a general-purpose development system.  We open IDEA, create a new Java-project, and then we'll see whether or not we will be able to implement, for example, financial accounting and a balance sheet for the online sales system.  What's the big deal?  At first glance, nothing will happen until you begin to do and make sure that without the time-consuming implementation of special patterns and approaches this cannot be done, and that it takes all your resources.  We do not claim that it is impossible to succeed in this way, but there are certain things that you should not undertake. <br><br>  Celesta here occupies an intermediate position.  Being a Java library (celesta.jar), it is the ‚Äúengine‚Äù of business logic.  This is a ‚Äúengine‚Äù that either integrates into a Java application or, using the Flute module, exists independently and provides the ability to quickly and correctly implement business logic. <br><br>  Celesta itself is written in Java, and business logic is written in Jython.  Jython is a Java implementation of Python.  Now it is available for Python version 2.7.  The elegance of the Python-code, the ease of development played an important role in choosing a language for business logic, and it has been with us for several years. <br><br>  However, we don‚Äôt bind to Python / Jython that much.  We can use any scripting language, lately we are looking to embed it in Celesta Groovy. <br><br><h2>  Part II, technical </h2><br><h3>  What is Celesta and what does it do? </h3><br>  The place of the Celesta platform as an intermediate layer between the relational base and the business logic code in the overall picture can be represented as follows: <br><br><div style="text-align:center;"><img width="200" src="https://habrastorage.org/web/283/8ca/387/2838ca387a8f49f9b959eb17f6b3a009.png"></div><br>  We support four types of relational databases and business logic code in Jython.  At the same time, Celesta is also slightly present inside the database, creating service objects and triggers for itself. <br><br>  The main functionality of Celesta: <br><br><ol><li>  A principle very similar to the basic principle of Java: "Write once, run on every supported RDBMS."  Business logic code does not know on which type of database it will be executed.  <b>You can write the code of business logic and run it in MS SQL Server, then go to PostgreSQL, and this will happen without complications</b> (well, almost :) </li><li>  Automatic structure change to a live database.  Most of the life cycle of Celesta-projects occurs when there is already a database, when it is already filled with real productive data that you cannot just put somewhere, throw out and start from a new sheet.  At the same time, it is necessary to constantly change the structure.  One of the key features is <b>Celesta automatically ‚Äúfits‚Äù the database structure to your data model</b> . </li><li>  Testing.  We paid great attention to ensuring that the Celesta code was tested, so that we could <b>automatically test the procedures that modify the data in the database, making it easy and elegant, without using external tools like DbUnit and containers</b> . </li><li>  Easy deployment of changes on the "live" system.  We work with a constantly used system, and the situation is such that sometimes some corrections have to be made and turned on at the height of the work.  Conveniently, when all deployment is reduced to a simple substitution of source code in the scripting language, that is, when the script is the artifact that can be put on the machine, avoiding the need to compile and package something. </li><li>  The modularity of solutions, that is, the possibility of transferring a standard piece of functionality between different projects.  Customers always or very often have repeated requirements from time to time.  For example, that the system must support the allocation of access rights, it must integrate with LDAP, it must record all changes made in some critical tables, perform an audit of successful / unsuccessful entries.  All this is so standard, frequent requirements, which is good when the platform implements them once and for all.  The developer of business logic uses standard modules and does not even think about once again collecting the ‚Äúbike‚Äù. </li></ol><br><h3>  What is independence from the type of DBMS? </h3><br>  We did not set the independence of the business logic code from the DBMS type as the first item: the code written for Celesta does not know at all on which DBMS it is executed.  Why is this done? <br><br>  First, due to the fact that the choice of the type of DBMS is not a technological issue, but a political one.  Coming to a new customer, we often find that he already has an Oracle or SQL Server in which funds have been invested, and the customer wants to see other solutions on the existing infrastructure.  The technological landscape is gradually changing: PostgreSQL is becoming more and more common in state and private companies, although several years ago MS SQL Server prevailed in our practice.  Celesta supports the most common DBMSs, and we are not disturbed by these changes. <br><br>  Secondly, the code already created for solving standard tasks, I would like to transfer from one customer to another, to create a reusable library.  Things like hierarchical directories or email distribution modules are essentially standard, and why do we need to support multiple versions for customers with different relations? <br><br>  Third, last but not least, is the ability to run unit tests without using DbUnit and containers using the H2 database running in in-memory mode.  In this mode, the base H2 starts instantly.  Celesta very quickly creates a data scheme in it, after which you can perform the necessary tests and ‚Äúforget‚Äù the database.  Since the code of business logic really does not know on which base it runs, then accordingly, if it runs on H2 without errors, then it will work on PostgreSQL as well without errors.  Of course, the task of the developers of the Celesta system itself is to do all the tests with the use of lifting real DBMSs, to make sure that our platform performs its API in different ways (and we do this).  But the developer of business logic is no longer required. <br><br><h3>  CelestaSQL </h3><br>  Due to what is achieved "cross-basement"?  Of course, due to the fact that you can work with data only through a special API that isolates logic from any specifics of the database.  Celesta codes the Python classes for data access, on the one hand, and the SQL code and some auxiliary objects around the tables, on the other hand. <br><br>  Celesta does not provide object-relational mapping in its pure form, because when designing a data model, we do not come from classes, but from the structure of the database.  That is, we first build the ER-model of the tables, and then, based on this model, Celesta itself generates classes-cursors for data access. <br><br>  To achieve the same work on all supported DBMS is possible only for the functionality that is approximately equally implemented in each of them.  If conventionally in the form of "Euler circles" depict the set of functionalities of each of the bases we support, then we get the following picture: <br><br><div style="text-align:center;"><img width="250" src="https://habrastorage.org/web/e77/61e/16a/e7761e16ac42455badb0ff8bdd0ede59.png"></div><br><br>  If we provide complete independence from the type of database, then the functionality that we open to business programmers must lie inside the intersection in all bases.  At first glance it seems that this is a significant limitation.  Yes: some specific features, for example, we cannot use SQL Server.  But without exception, all databases support tables, foreign keys, views, SQL queries with JOIN and GROUP BY.  Accordingly, we can give these opportunities to developers.  We provide developers with ‚Äúimpersonal SQL‚Äù, which we call ‚ÄúCelestaSQL‚Äù, and in the process, we modify SQL queries for dialects of the corresponding bases. <br><br>  Each database has its own set of data types.  Since we work through the CelestaSQL language, we also have our own set of types.  There are only seven of them, and here they are their comparison with real types in the bases: <br><br><table><tbody><tr><td></td><td>  CelestaSQL </td><td>  Microsoft SQL Server </td><td>  Oracle </td><td>  PostgreSQL </td><td>  H2 </td></tr><tr><td>  Integer (32-bit) </td><td>  Int </td><td>  Int </td><td>  NUMBER </td><td>  Int4 </td><td>  INTEGER </td></tr><tr><td>  Floating point (64-bit) </td><td>  REAL </td><td>  FLOAT (53) </td><td>  REAL </td><td>  FLOAT8 </td><td>  DOUBLE </td></tr><tr><td>  String (Unicode) </td><td>  Varchar (n) </td><td>  NVARCHAR (n) </td><td>  NVARCHAR2 (n) </td><td>  Varchar (n) </td><td>  Varchar (n) </td></tr><tr><td>  Long string (Unicode) </td><td>  TEXT </td><td>  NVARCHAR <br>  (MAX) </td><td>  NCLOB </td><td>  TEXT </td><td>  CLOB </td></tr><tr><td>  Binary </td><td>  Blob </td><td>  Varbinary <br>  (MAX) </td><td>  Blob </td><td>  BYTEA </td><td>  Varbinary <br>  (MAX) </td></tr><tr><td>  Date / time </td><td>  DATETIME </td><td>  DATETIME </td><td>  TIMESTAMP </td><td>  TIMESTAMP </td><td>  TIMESTAMP </td></tr><tr><td>  Boolean </td><td>  Bit </td><td>  Bit </td><td>  NUMBER <br>  CHECK IN (0, 1) </td><td>  Bool </td><td>  Boolean </td></tr></tbody></table><br>  It may seem that only seven types are few, but in fact these are the types that are always enough to store financial, trade, logistic information: lines, integers, fractional, dates, boolean values ‚Äã‚Äãand BLOBs always enough to present such data. <br><br>  The language of CelestaSQL is described in the <a href="https://corchestra.ru/wiki/index.php%3Ftitle%3D%25D0%25AF%25D0%25B7%25D1%258B%25D0%25BA_Celesta-SQL">documentation</a> with a large number of Wirth diagrams. <br><br><h3>  Modification of the database structure.  Idempotent DDL </h3><br>  Another key feature of Celesta is the approach to modifying the structure, which should occur on a live database. <br><br>  What are some possible approaches to solving the problem of controlling changes in the database structure? <br><br>  There is a very common approach that can be called the <i>‚Äúchange log‚Äù</i> .  <a href="http://www.liquibase.org/">Liquibase</a> is the most famous tool in the Java world that solves a problem in this way.  In the Python world, <a href="https://www.djangoproject.com/">Django is</a> doing the same thing.  This approach is to gradually increase the database change log, database change log.  As changes are made to the base structure, you add incremental change sets to this log.  Gradually, your change log accumulates, incorporating the entire history of modifications to your database: erroneous, correcting, refactorings, etc. After some time, there are so many changes that it becomes impossible to understand the current structure of the tables directly from the log. <br><br>  Although on the site of the Liquibase system they write that their approach provides refactoring and control of the versions of the database structure - neither is really achieved with the help of the database change log.  To understand this is quite simple, comparing with how you perform the refactoring of ordinary code.  If, for example, you need to add some methods to a class, then you add them directly to the class definition, rather than appending a change log code like ‚Äúalter class Foo add method bar {....}‚Äù to the change log.  The same with version control: when working with normal code, the version control system itself creates a change log for you, and not you add changesets to the end of a journal. <br><br>  It is clear that for the database structure this is done for a reason: the reason is that there are already data in the database tables, and the change set is designed to convert not only the structure, but also your data.  Thus, change log <i>seems to</i> give you the assurance that you can always upgrade to use it from any version of the database.  But actually this is a false assurance.  After all, if you tested the modification code of your data on some copy of the database and it worked, there is no guarantee that it will work on the basis with some other data, where there may be some special cases that you did not consider in your changeset  The most unpleasant thing that can happen with such a system is the changeset, which has worked in half and commits some of the changes: the base is ‚Äúin the middle‚Äù between the versions, and manual intervention is required to correct the situation. <br><br>  There is another approach, let's call it <i>‚Äúconfiguration management-approach‚Äù</i> or otherwise - ‚Äúidempotent DDL‚Äù. <br><br>  By analogy with how configuration management systems like Ansible, you have <b>idempotent scripts</b> that do not say ‚Äúdo something‚Äù, but ‚Äúbring something to the desired state,‚Äù just the same as when we write the following text on CelestaSQL : <br><br><pre><code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> OrderLine( order_id <span class="hljs-built_in"><span class="hljs-built_in">VARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">30</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, line_no <span class="hljs-built_in"><span class="hljs-built_in">INT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, item_id <span class="hljs-built_in"><span class="hljs-built_in">VARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">30</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, item_name <span class="hljs-built_in"><span class="hljs-built_in">VARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">100</span></span>), qty <span class="hljs-built_in"><span class="hljs-built_in">INT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DEFAULT</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">cost</span></span> <span class="hljs-built_in"><span class="hljs-built_in">REAL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DEFAULT</span></span> <span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">CONSTRAINT</span></span> Idx_OrderLine PRIMARY <span class="hljs-keyword"><span class="hljs-keyword">KEY</span></span> (order_id, line_no) );</code> </pre> <br>  - this text is interpreted by Celesta not as ‚Äúcreate a table, but if the table already exists, then give an error‚Äù, but ‚Äúbring the table to the desired structure‚Äù.  That is: ‚Äúif there is no table, create it, if there is a table, see which fields are in it, with which types, which indices, which foreign keys, which default values, etc., and whether it is necessary to change something in this table to bring it to the desired form. " <br><br>  With this approach, we achieve real refactoring and true version control on our scripts defining the base structure: <br><br><ol><li>  We see the current ‚Äúdesired image‚Äù of the structure in the script. </li><li>  What, by whom and why in the structure has changed over time, we can look through the version control system. </li><li>  As for the ALTER commands, they are automatically, ‚Äúunder the hood,‚Äù formed and executed by Celesta as needed. </li></ol><br>  The question may arise: what about the transformation of the data, because simple ALTER is not always enough?  Yes, indeed it does not always work in automatic mode.  For example, if we add a NOT NULL field to a non-empty table and do not supply it with a DEFAULT value, Celesta will not be able to add a field: it simply does not know what data to substitute for existing rows, and the database will not allow creating such a field.  But there is nothing wrong with that.  First, Celesta signals that it didn‚Äôt fully perform such an update for such a reason, with such a database error.  Unlike ‚Äúchangelog‚Äù systems, updates that are not completed to the end are not a problem for Celesta, since for generating ALTER commands, it compares the current <i>actual</i> state of the database with the desired one, and changes that are not performed in one attempt, will try to finish the other.  You, for your part, can make an ad hoc script that transforms the data and ‚Äúhelps‚Äù Celesta to complete the update.  This script can be debugged on a test base, run on a product base, finish the Celesta update - after which you can simply throw out your ad hoc script, because you will never need it anymore!  After all, your work base is already in the state you need according to its structure, and if you decide to make a new base from scratch, then you do not need to force the base to go all the way you have gone, modifying its structure during the development process. <br><br>  In practice, the creation of "auxiliary" scripts is required infrequently.  The vast majority of changes (adding fields, rebuilding indexes, changing views) are made in Celesta automatically ‚Äúon the fly‚Äù. <br><br><h3>  The structure of the project Celesta.  Granules </h3><br>  In order to start using Celesta, you need to understand how the Celesta project works with business logic. <br><br>  The aggregate of all business logic we call ‚Äúscore‚Äù (‚Äúscore‚Äù), inside ‚Äúscore‚Äù there are ‚Äúgrains‚Äù - granules, they are modules: <br><br><div style="text-align:center;"><img width="300" src="https://habrastorage.org/web/473/24c/ab7/47324cab7a17495b95f93a91d8fb42c6.png"></div><br>  Here, the dotted arrows show the dependencies, that is, the granules can use objects from other granules.  And these dependencies can be complex, but the main limitation is that the foreign key dependencies are not cyclic - this is necessary to ensure the successful update of the database structure by granules, when Celesta starts by choosing the correct update order. <br><br>  What is a granule? <br><br>  In terms of <b>source codes</b> , a granule is a folder.  Folder requirements are as follows: <br><br><ul><li>  it contains a CelestaSQL file, called the granule itself, with an underscore at the beginning (this is so that this particularly important file is at the top of the file manager when sorted by name) </li><li>  the contents of this file begin with the declaration of the pellet ‚Äî its name and version ‚Äî using the create grain expression ... version ...; </li><li>  this file contains DDL with granule table structure </li></ul><br>  From the point of view of <b>the database, the</b> granule turns into a schema.  All tables defined in the foo granule will end up in the SCHEMA foo. <br><br>  From the point of view of <b>Python</b> (or Jython in our case), the granule is the package in which the generated data access classes will be located, and in which you can create your own modules with a business logic code.  Therefore, a file with the name __init__.py must also be in the granules folder. <br><br><h3>  Launch Celesta and synchronize base structure </h3><br>  When launched, Celesta synchronizes the structure of the database.  An approximate sequence of steps is as follows: <br><br><ol><li>  The list of granules is topologically sorted by foreign key dependencies in order to perform the update in a manner that does not lead to conflicts. </li><li>  The checksum of the granule DDL script is compared with the checksum of the last successful update stored in the service table.  If these amounts are the same, Celesta considers that you can skip the step of checking the structure of the tables to speed up the launch. <br><br><img width="450" src="https://habrastorage.org/web/a8b/6f8/638/a8b6f863894148c0ac2761c30314bb9b.png"><br></li><li>  If the checksum has changed, and the version remains the same or has grown, Celesta begins to bypass all the granule objects and investigate which of the metadata has diverged.  If the metadata is diverged, then CREATE and ALTER commands are generated and executed, which in most cases pass without problems and manual intervention. </li><li>  In parallel, if necessary, Python modules with data access classes are generated or re-created - one class for each table. </li></ol><br><br>  This is a very brief retelling of what is happening on a multi-stage start-up process, which includes the generation of classes for data access and the initialization of packages of granules.  A more detailed start-up process is described on <a href="https://corchestra.ru/wiki/index.php%3Ftitle%3D%25D0%2597%25D0%25B0%25D0%25BF%25D1%2583%25D1%2581%25D0%25BA_Celesta_%25D0%25B8_%25D0%25B0%25D0%25B2%25D1%2582%25D0%25BE-%25D0%25BE%25D0%25B1%25D0%25BD%25D0%25BE%25D0%25B2%25D0%25BB%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B5_%25D0%2591%25D0%2594">this</a> documentation <a href="https://corchestra.ru/wiki/index.php%3Ftitle%3D%25D0%2597%25D0%25B0%25D0%25BF%25D1%2583%25D1%2581%25D0%25BA_Celesta_%25D0%25B8_%25D0%25B0%25D0%25B2%25D1%2582%25D0%25BE-%25D0%25BE%25D0%25B1%25D0%25BD%25D0%25BE%25D0%25B2%25D0%25BB%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B5_%25D0%2591%25D0%2594">page</a> . <br><br><h3>  Creating a data model and database in Celesta </h3><br>  Let's take a look at how you can create a data model and deploy a database in Celesta. <br><br>  Suppose we are doing a project for an e-commerce company that has recently merged with another company.  Each has its own database.  They collect orders, but until they merge their databases together, we need a single entry point in order to collect orders coming from outside. <br><br>  First we need to create the structure of the tables that store the orders.  An order is known to be an integral entity: it consists of a header where information about the customer, the date of the order and other attributes of the order, as well as many lines (headings) are stored. <br><br>  So, for the cause: create <br><br><ol><li>  folder score, </li><li>  in it the granule is the orders folder, </li><li>  insert the empty __init__.py file into the orders folder (thanks to this file, Python will treat this folder as a package) </li><li>  in the orders folder, create an _orders.sql file with the following content: </li></ol><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> GRAIN orders <span class="hljs-keyword"><span class="hljs-keyword">VERSION</span></span> <span class="hljs-string"><span class="hljs-string">'1.0'</span></span>; <span class="hljs-comment"><span class="hljs-comment">--  /** */ CREATE TABLE OrderHeader( id VARCHAR(30) NOT NULL, date DATETIME, customer_id VARCHAR(30), /** */ customer_name VARCHAR(50), CONSTRAINT Pk_OrderHeader PRIMARY KEY (id) ); /** */ CREATE TABLE OrderLine( order_id VARCHAR(30) NOT NULL, line_no INT NOT NULL, item_id VARCHAR(30) NOT NULL, item_name VARCHAR(100), qty INT NOT NULL DEFAULT 0, cost REAL NOT NULL DEFAULT 0.0, CONSTRAINT Idx_OrderLine PRIMARY KEY (order_id, line_no) ); ALTER TABLE OrderLine ADD CONSTRAINT fk_OrderLine FOREIGN KEY (order_id) REFERENCES OrderHeader(id); /**/ CREATE VIEW OrderedQty AS SELECT item_id, sum(qty) AS qty FROM OrderLine GROUP BY item_id;</span></span></code> </pre><br>  Here we have described two tables connected by a foreign key, and one view that will return the aggregate quantity for the goods present in all orders.  As you can see, this is no different from normal SQL, with the exception of the CREATE GRAIN command, in which we declared the version of the orders granule.  But there are also features.  For example, all the names of tables and fields that we use can only be such that they can be turned into valid names in Python for classes and variables.  Therefore, spaces, special characters, non-Latin letters are excluded.  You may also notice that the comments that we put above the names of the tables and some of the fields, we did not start with / *, as usual, but with / **, how JavaDoc comments begin - and this is no accident!  A comment defined on some entity, starting with / **, will be available at runtime in the .getCelestaDoc () property of this entity.  This is useful when we want to provide the elements of the database with additional meta-information: for example, human readable field names, information on how to represent fields in the user interface, etc. <br><br>  The first stage is done: the data model is built in the first approximation, and now we would like to apply it to the database.  To do this, we create an empty database and write a simple Java application using Celesta. <br><br>  We use Maven-dependency for Celesta (the current version can be found on the website <a href="https://corchestra.ru/">corchestra.ru</a> ): <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">dependency</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">groupId</span></span></span><span class="hljs-tag">&gt;</span></span>ru.curs<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">groupId</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">artifactId</span></span></span><span class="hljs-tag">&gt;</span></span>celesta<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">artifactId</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">version</span></span></span><span class="hljs-tag">&gt;</span></span>6.0RC2<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">version</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">scope</span></span></span><span class="hljs-tag">&gt;</span></span>compile<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">scope</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">dependency</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  Create a boilerplate code and run it: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">App</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( String[] args )</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> CelestaException </span></span>{ Properties settings = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Properties(); settings.setProperty(<span class="hljs-string"><span class="hljs-string">"score.path"</span></span>, <span class="hljs-string"><span class="hljs-string">"c:/path/to/score"</span></span>); settings.setProperty(<span class="hljs-string"><span class="hljs-string">"pylib.path"</span></span>, <span class="hljs-string"><span class="hljs-string">"d:/jython2.7.1b3/Lib"</span></span>) ; settings.setProperty(<span class="hljs-string"><span class="hljs-string">"rdbms.connection.url"</span></span>, <span class="hljs-string"><span class="hljs-string">"jdbc:postgresql://localhost:5432/mytest"</span></span>); settings.setProperty(<span class="hljs-string"><span class="hljs-string">"rdbms.connection.username"</span></span>, <span class="hljs-string"><span class="hljs-string">"postgres"</span></span>); settings.setProperty(<span class="hljs-string"><span class="hljs-string">"rdbms.connection.password"</span></span>, <span class="hljs-string"><span class="hljs-string">"123"</span></span>); Celesta.initialize(settings); Celesta c = Celesta.getInstance(); } }</code> </pre><br>  Through the Properties object, the basic settings of Celesta are transferred, such as the path to the score folder (its subfolder must be / orders), the path to the standard Jython library (Jython must be installed on your machine!) And the parameters of the JDBC connection to the database.  A complete list of Celesta parameters is given in the <a href="https://corchestra.ru/wiki/index.php%3Ftitle%3D%25D0%2591%25D0%25B0%25D0%25B7%25D0%25BE%25D0%25B2%25D0%25B0%25D1%258F_%25D0%25BD%25D0%25B0%25D1%2581%25D1%2582%25D1%2580%25D0%25BE%25D0%25B9%25D0%25BA%25D0%25B0_Celesta">wiki documentation</a> . <br><br>  If the parameters are set correctly and everything went well, then you can see what happened to the mytest database.  We will see that the orders scheme with our ‚ÄúOrderHeader‚Äù and ‚ÄúOrderLine‚Äù tables, as well as the ‚ÄúOrderedQty‚Äù view, appeared in the database.  Now suppose that after some time we decided to change our data model.  Suppose we want to expand the field with the client‚Äôs name to 100 characters in the header of the order and add the field with the manager‚Äôs code.  We can do this by directly editing the table definition in the _orders.sql file, literally changing one line and adding another: <br><br><pre> <code class="sql hljs"> customer_name VARCHAR(100), manager_id VARCHAR(30),</code> </pre><br>  By running the application again, we can verify that the database structure has changed to meet the new model. <br><br>  In addition to the orders scheme, a celesta service scheme is created in the database.  It is useful to look at the grains table to see in it an entry about the orders granule, its status, and the _orders.sql script checksum. <br><br><h3>  Creating Celesta-procedures: session and call contexts, launching ‚Äúhello, world!‚Äù </h3><br>  Having dealt with the creation of the database structure, you can begin to write business logic. <br><br><div style="text-align:center;"><img width="350" src="https://habrastorage.org/web/74e/4c0/0ee/74e4c00eec82466a9725b925c7ccada7.png"></div><br>  In order to be able to implement the requirements for the distribution of access rights and logging actions, any operation on data in Celesta is performed on behalf of a certain user, there can be no "anonymous" operations.  Therefore, any Celesta code is executed in a certain call context, which, in turn, exists in a session context. <br><br>  The appearance and deletion of the session context through the login / logout methods allow auditing of the inputs and outputs.  Binding the user to the context determines the permissions to access the tables, and also provides the ability to log changes made on his behalf. <br><br>  To make sure that we can run the code of Celesta procedures as such, first consider the example ‚ÄúHello, world‚Äù, and then build a less trivial system that will modify the data in the database and use unit tests to verify its correctness. <br><br>  Let's go back to the score / orders folder and create a Python module hello.py in it, with the following contents: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># coding=UTF-8 def run(context, name): print u', %s' % name</span></span></code> </pre><br>  Any Celesta procedure should have a context as its first argument, which is an instance of the <a href="https://corchestra.ru/wiki/index.php%3Ftitle%3D%25D0%259A%25D0%25BE%25D0%25BD%25D1%2582%25D0%25B5%25D0%25BA%25D1%2581%25D1%2582%25D1%258B_%25D1%2581%25D0%25B5%25D1%2581%25D1%2581%25D0%25B8%25D0%25B8_%25D0%25B8_%25D0%25B2%25D1%258B%25D0%25B7%25D0%25BE%25D0%25B2%25D0%25B0">ru.curs.celesta.CallContext</a> class - in our primitive example it is not required, but as we will see later, it plays a key role.  In addition, Celesta-procedures can have an arbitrary number of other additional parameters (including not at all).  In our example, there is one additional parameter name. <br><br>  To run a Celesta-procedure, it must be identified by a <i>three-part name</i> .  Inside the orders granule, we have the Python module hello, inside which the run function is located, which means that the three-component name of our procedure will be <b>orders.hello.run</b> .  If we used several nested Python modules, then their names could also be listed through a period, for example: orders.subpackage.hello.run. <br><br>  We modify our Java code a little by adding the creation of session and call contexts and, in fact, the start of the procedure: <br><br><pre> <code class="java hljs">Celesta c = Celesta.getInstance(); String sessionId = String.format(<span class="hljs-string"><span class="hljs-string">"%08X"</span></span>, (<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Random()).nextInt()); <span class="hljs-comment"><span class="hljs-comment">//  c.login(sessionId, "super"); //super --        c.runPython(sessionId, "orders.hello.run", "Ivan"); c.logout(sessionId, false);</span></span></code> </pre><br>  By running a Java program, we will receive a greeting from Python code that runs from under Celesta. <br><br><pre> <code class="hljs">, Ivan</code> </pre><br><h3>  Creating Celesta-procedures: data modification, protection from race conditions and transactions </h3><br>  Now we will show how to write code on Celesta that reads and modifies data in the database.  To do this, we use the so-called cursors - the classes that Celesta generated for us.  We can see what they are, by going into the folder with the orders: t. To. We have already started Celesta, then code generation has been performed, and the orders folder will contain the <b>_orders_orm.py</b> file. <br><br>  Inside it will be found the classes of the cursors OrderHeaderCursor, Order LineCursor and OrderedQtyCursor.  As you can see, one class was created for each of the objects of the granules - on two tables and one view.  And now we can use these classes to access database objects in our business logic. <br><br>  To create a cursor on the order table and select the first entry, you need to write the following Python code: <br><br><pre> <code class="python hljs"> header = OrderHeaderCursor(context) header.tryFirst()</code> </pre><br>  After creating the header object, we can access the table entry fields through variables: <br><br><div style="text-align:center;"><img width="300" src="https://habrastorage.org/web/05e/811/654/05e8116545cc400e97bec989c67cd02e.png"></div><br>  As we already said, the first argument of any Celesta procedure is the context of the call, and we are obliged to pass this context as the first argument to the constructor of any cursor ‚Äî this is the only way to create a cursor.  The context of the call carries information about the current user and his access rights. <br><br>  With the cursor object, we can produce different things: filter, navigate through records, and also, of course, insert, delete, and update records.  The entire cursor API is described in detail in the <a href="https://corchestra.ru/wiki/index.php%3Ftitle%3D%25D0%25A0%25D0%25B0%25D0%25B1%25D0%25BE%25D1%2582%25D0%25B0_%25D1%2581_%25D0%25B4%25D0%25B0%25D0%25BD%25D0%25BD%25D1%258B%25D0%25BC%25D0%25B8_%25D1%2587%25D0%25B5%25D1%2580%25D0%25B5%25D0%25B7_%25D0%25BA%25D0%25BB%25D0%25B0%25D1%2581%25D1%2581%25D1%258B_%25D0%25B4%25D0%25BE%25D1%2581%25D1%2582%25D1%2583%25D0%25BF%25D0%25B0_%25D0%25BA_%25D0%25B4%25D0%25B0%25D0%25BD%25D0%25BD%25D1%258B%25D0%25BC">documentation</a> . <br><br>  For example, the code of our example could be developed as follows: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(context, delta)</span></span></span><span class="hljs-function">:</span></span> header = OrderHeaderCursor(self.context) header.setRange(<span class="hljs-string"><span class="hljs-string">'city'</span></span>, <span class="hljs-string"><span class="hljs-string">'MSK'</span></span>) header.tryFirst() header.counter = orderHeader.counter + delta header.update()</code> </pre><br>  In this example, we set the filter by the city field, then we find the first record using the tryFirst method. <br><br><div class="spoiler">  <b class="spoiler_title">(why try)</b> <div class="spoiler_text">  The methods get, first, insert, update have two options: without the prefix try (just get (...), etc.) and with the prefix try (tryGet (...), tryFirst (), etc.) .  Methods without the try prefix cause an exception if the database does not have the appropriate data to perform the action.  For example, first () will throw an exception if no records are included in the filter set on the cursor.  At the same time, the methods with the try prefix do not throw exceptions, but instead return a Boolean value indicating the success or failure of the corresponding operation.  The recommended practice is to use methods <i>without the</i> prefix try wherever possible.  Thus, a ‚Äúself-testing‚Äù code is created that signals errors in logic and / or in database data in time. </div></div><br>  When tryFirst is triggered, the cursor variables are filled with the data of one record, we can read and assign values ‚Äã‚Äãto them.  And when the data in the cursor is fully prepared, we execute update (), and it stores the contents of the cursor in the database. <br><br>  What problem can this code be affected by?  Of course, the occurrence of race condition / lost update!  Because between the moment when we received the data in the ‚ÄútryFirst‚Äù line, and the moment when we are trying to update this data at the ‚Äúupdate‚Äù point, someone else can already get, change and update this data.  After the data is read, the cursor in no way blocks their use by other users!  Lost updates would be a big problem in such a system, but Celesta contains protection based on checking versions of data.  In each table, by default, Celesta creates a recversion field, and at the ON UPDATE level the trigger executes the increment of the version number and checks that the updated data is the same version as in the table.  If a problem occurs, throws an exception.  Read more about this in the documentation of the article <a href="https://corchestra.ru/wiki/index.php%3Ftitle%3D%25D0%2597%25D0%25B0%25D1%2589%25D0%25B8%25D1%2582%25D0%25B0_%25D0%25BE%25D1%2582_%25D0%25BF%25D0%25BE%25D1%2582%25D0%25B5%25D1%2580%25D1%258F%25D0%25BD%25D0%25BD%25D1%258B%25D1%2585_%25D0%25BE%25D0%25B1%25D0%25BD%25D0%25BE%25D0%25B2%25D0%25BB%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B9">‚Äúprotection against lost updates</a> . <a href="https://corchestra.ru/wiki/index.php%3Ftitle%3D%25D0%2597%25D0%25B0%25D1%2589%25D0%25B8%25D1%2582%25D0%25B0_%25D0%25BE%25D1%2582_%25D0%25BF%25D0%25BE%25D1%2582%25D0%25B5%25D1%2580%25D1%258F%25D0%25BD%25D0%25BD%25D1%258B%25D1%2585_%25D0%25BE%25D0%25B1%25D0%25BD%25D0%25BE%25D0%25B2%25D0%25BB%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B9">‚Äù</a> <br><br>  If the exit from the Celesta procedure occurs with an unhandled exception, Celesta rolls back the implicit transaction that it starts before executing the procedure.  It is important to understand that the call context is not only the context of the call, but also a transaction.  If the Celesta procedure succeeds, then a commit occurs.  If the Celesta procedure ends with an unhandled exception, then rollback occurs. <br><br>  A specialist who writes business logic may not know all the subtleties that occur behind the scenes: he simply writes business logic, and the system ensures the consistency of data.  If an error occurs in a complex procedure, the entire transaction associated with the call context is rolled back, as if we didn‚Äôt start to do anything with the data, the data is not corrupted.  If for some reason you need a commit in the middle, say, some big procedure, then you can execute an explicit commit by calling context.commit (). <br><br><h3>  Creating Celesta Procedures: Unit Testing </h3><br>  Let's look at a more advanced example. <br><br>  Suppose we have here JSON-files that we want to put in a database consisting of <div class="spoiler">  <b class="spoiler_title">two tables</b> <div class="spoiler_text"><pre> <code class="python hljs">request1 = { <span class="hljs-string"><span class="hljs-string">'id'</span></span>: <span class="hljs-string"><span class="hljs-string">'no1'</span></span>, <span class="hljs-string"><span class="hljs-string">'date'</span></span>: <span class="hljs-string"><span class="hljs-string">'2017-01-02'</span></span>, <span class="hljs-string"><span class="hljs-string">'customer_id'</span></span>: <span class="hljs-string"><span class="hljs-string">'CUST1'</span></span>, <span class="hljs-string"><span class="hljs-string">'customer_name'</span></span>: <span class="hljs-string"><span class="hljs-string">u''</span></span>, <span class="hljs-string"><span class="hljs-string">'lines'</span></span>: [ {<span class="hljs-string"><span class="hljs-string">'item_id'</span></span>: <span class="hljs-string"><span class="hljs-string">'A'</span></span>, <span class="hljs-string"><span class="hljs-string">'qty'</span></span>: <span class="hljs-number"><span class="hljs-number">5</span></span> }, {<span class="hljs-string"><span class="hljs-string">'item_id'</span></span>: <span class="hljs-string"><span class="hljs-string">'B'</span></span>, <span class="hljs-string"><span class="hljs-string">'qty'</span></span>: <span class="hljs-number"><span class="hljs-number">4</span></span> } ] } request2 = { <span class="hljs-string"><span class="hljs-string">'id'</span></span>: <span class="hljs-string"><span class="hljs-string">'no2'</span></span>, <span class="hljs-string"><span class="hljs-string">'date'</span></span>: <span class="hljs-string"><span class="hljs-string">'2017-01-03'</span></span>, <span class="hljs-string"><span class="hljs-string">'customer_id'</span></span>: <span class="hljs-string"><span class="hljs-string">'CUST1'</span></span>, <span class="hljs-string"><span class="hljs-string">'customer_name'</span></span>: <span class="hljs-string"><span class="hljs-string">u''</span></span>, <span class="hljs-string"><span class="hljs-string">'lines'</span></span>: [ {<span class="hljs-string"><span class="hljs-string">'item_id'</span></span>: <span class="hljs-string"><span class="hljs-string">'A'</span></span>, <span class="hljs-string"><span class="hljs-string">'qty'</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span> } ] }</code> </pre><br></div></div><br>  In each of these JSON we have fields related to the order header, and there is an array relating to its rows.  How to quickly and reliably create an application that processes this data and puts it in a DBMS?  Of course, through testing! <br><br>  Let's start by creating a unit test class that we inherit from CelestaUnit.  In turn, CelestaUnit is the successor of the unittest.TestCase of the PyUnit system: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#coding=utf-8 from celestaunit.celestaunit import CelestaUnit, clean_db from basic_operations import post_order, get_aggregate_report from _orders_orm import OrderHeaderCursor class test_basic_operations(CelestaUnit): request1 =.... request2 = ... def setUp(self): CelestaUnit.setUp(self) clean_db(self.context)</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> And we will write a unit test for the test procedure: </font></font><br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_document_is_put_to_db</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment">#   (   ) post_order(self.context, test_basic_operations.request1) #,      header = OrderHeaderCursor(self.context) header.tryFirst() # ,     id='no1' self.assertEquals('no1', header.id)</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Please note that we have the ability to write unit tests under the assumption that by the time they are executed, the database will be completely empty, but with the structure we need, and after executing them we may not care about what we have left ‚Äúgarbage "In the database. </font><font style="vertical-align: inherit;">Moreover: using the CelestaUnit import, we can not care at all that at least some database is on our working machine. </font><font style="vertical-align: inherit;">CelestaUnit raises the H2 in-memory base and configures everything for us, and we just have to take the ready context of the call from self and use it to create cursors. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you run this test immediately, it will not work, because we have not implemented the test method. </font><font style="vertical-align: inherit;">We write it:</font></font><br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">post_order</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(context, doc)</span></span></span><span class="hljs-function">:</span></span> header = OrderHeaderCursor(context) line = OrderLineCursor(context) <span class="hljs-comment"><span class="hljs-comment">#  header.id = doc['id'] header.date = datetime.datetime.strptime(doc['date'], '%Y-%m-%d') header.customer_id = doc['customer_id'] header.customer_name = doc['customer_name'] header.insert() lineno = 0 #    for docline in doc['lines']: lineno += 1 line.line_no = lineno line.order_id = doc['id'] line.item_id = docline['item_id'] line.qty = docline['qty'] line.insert()</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Run the test again in the IDE and cheers: </font></font><br><br><div style="text-align:center;"><img width="400" src="https://habrastorage.org/web/0eb/7bd/bd2/0eb7bdbd2d8d4ec2ab7e2bb034c831e2.png"></div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We can also add some more complex checks to the test, for example, that order lines are inserted, that there are exactly two of them, etc. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's create a second procedure that returns JSON with aggregated values ‚Äã‚Äãthat show how many products we have ordered. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The test writes two orders to the database, after which it checks the total value returned by the new get_aggregate_report method:</font></font><br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_report_returns_aggregated_qtys</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> post_order(self.context, test_basic_operations.request1) post_order(self.context, test_basic_operations.request2) result = get_aggregate_report(self.context) <span class="hljs-comment"><span class="hljs-comment">#  8 : 5  1   3  2 self.assertEquals(8, result['A']) #  4   2  self.assertEquals(4, result['B'])</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> To implement the get_aggregate_report method, we will use the OrderedQty view, which, recall, in the CelestaSQL file looks like this: </font></font><br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">view</span></span> OrderedQty <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> item_id, <span class="hljs-keyword"><span class="hljs-keyword">sum</span></span>(qty) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> qty <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> OrderLine <span class="hljs-keyword"><span class="hljs-keyword">group</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> item_id;</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Query standard: we summarize order lines by quantity and group them by item code. </font><font style="vertical-align: inherit;">An OrderedQtyCursor cursor has already been created for the view, which we can use. </font><font style="vertical-align: inherit;">We declare this cursor, iterate over it and collect the necessary JSON:</font></font><br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_aggregate_report</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(context)</span></span></span><span class="hljs-function">:</span></span> result = {} ordered_qty = OrderedQtyCursor(context) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ordered_qty <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ordered_qty.iterate(): result[ordered_qty.item_id] = ordered_qty.qty <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result</code> </pre><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Celesta Materialized Views </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What's wrong with using a view to get aggregated data? This approach is quite workable, but in reality it puts a time bomb under our entire system: after all, a view that is an SQL query runs slower and slower as data accumulates in the system. He will have to summarize and group more and more lines. How to avoid it? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Celesta is trying to implement all the standard tasks that business programmers are constantly faced with at the platform level.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MS SQL Server has a great concept of materialized (indexed) views, which are stored as tables and are updated quickly as the data in the source tables changes. If we worked in a ‚Äúclean‚Äù MS SQL Server, then for our case, replacing the view with the indexed one would be just what we need: extracting the aggregated report would not slow down as data was accumulated, and the work on updating the aggregated report would be performed at the moment inserting data into the table of order lines would also not increase much as the number of lines increased. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But we work with PostgreSQL through Celesta. What we can do? Override the view by adding the word materialized:</font></font><br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">materialized</span></span> <span class="hljs-keyword"><span class="hljs-keyword">view</span></span> OrderedQty <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> item_id, <span class="hljs-keyword"><span class="hljs-keyword">sum</span></span>(qty) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> qty <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> OrderLine <span class="hljs-keyword"><span class="hljs-keyword">group</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> item_id;</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Run the system and see what happened to the database. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We will notice that the OrderedQty view has disappeared, and the OrderedQty table has appeared instead. At the same time, as the OrderLine table is filled with data, information will be ‚Äúmagically‚Äù updated in the OrderedQty table, as if OrderedQty were a representation. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There is no magic here if we take a look at the triggers built on the OrderLine table. Celesta, after receiving the task to create a ‚Äúmaterialized view,‚Äù analyzed the query and created triggers on the OrderLine table, updating OrderedQty. By inserting a single keyword - materialized - into the CelestaSQL file, we solved the problem of performance degradation, and the code of the business logic did not even need to be changed!</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Naturally, this approach has its own, and rather strict, limitations. </font><font style="vertical-align: inherit;">Only views that are built on a single table, without JOINs, with aggregation by GROUP BY can become ‚Äúmaterialized‚Äù in Celesta. </font><font style="vertical-align: inherit;">However, this is enough to build, for example, statements of fund balances on bills, goods by warehouse cells, etc. often encountered in practice reports.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Flute: REST-endpoints, schedules, queues, etc. </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">At the end of our introduction to Celesta, it remains to discuss how to turn the code that we launched into the IDE as a unit test ‚Äúto connect with the outside world‚Äù into a working service. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For example, this can be done by taking the Celesta Maven dependency into your Java project and running the required methods through Celesta.getInstance (). RunPython (&lt;the three-part name of the procedure&gt;). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But you can do without Java programming. </font><font style="vertical-align: inherit;">We have a module called </font></font><a href="https://corchestra.ru/wiki/index.php%3Ftitle%3DFlute"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Flute</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (aka ‚ÄúFlute‚Äù), which is installed as a service on Windows and Linux. </font><font style="vertical-align: inherit;">It uses Celesta and implements many ways that allow your scripts to "play". </font><font style="vertical-align: inherit;">These methods are:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> raise a REST service and map start tasks to URLs </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pick up tasks from the Redis queue or SQL table </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> perform CRON-scheduled procedures </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> perform procedures time after time in an infinite loop with a given pause between executions </font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">How is the REST-endpoint created in Flute? </font><font style="vertical-align: inherit;">Just like in Spring, in Java:</font></font><br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># coding=utf-8 from flute.mappingbuilder import mapping @map('/foo') def processor(context, request, response): # whatever</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In this case, the map decorator tells Flute which URL this code will be associated with. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The Flute module is configured via a flute.xml file of the following content:</font></font><br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">config</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-comment"><span class="hljs-comment">&lt;!--     --&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">dbconnstring</span></span></span><span class="hljs-tag">&gt;</span></span>jdbc:postgresql://127.0.0.1:5432/celesta<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">dbconnstring</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">dbuser</span></span></span><span class="hljs-tag">&gt;</span></span>postgres<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">dbuser</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">dbpassword</span></span></span><span class="hljs-tag">&gt;</span></span>123<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">dbpassword</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-comment"><span class="hljs-comment">&lt;!--  Redis,    --&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">redishost</span></span></span><span class="hljs-tag">&gt;</span></span>localhost<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">redishost</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">redisport</span></span></span><span class="hljs-tag">&gt;</span></span>6379<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">redisport</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-comment"><span class="hljs-comment">&lt;!-- :    Celesta score--&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">scorepath</span></span></span><span class="hljs-tag">&gt;</span></span>D:/score2<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">scorepath</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-comment"><span class="hljs-comment">&lt;!--,     REST---&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">restport</span></span></span><span class="hljs-tag">&gt;</span></span>8888<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">restport</span></span></span><span class="hljs-tag">&gt;</span></span> ... <span class="hljs-comment"><span class="hljs-comment">&lt;!--  Redis--&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">redisqueue</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">queuename</span></span></span><span class="hljs-tag">&gt;</span></span>q1<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">queuename</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">redisqueue</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-comment"><span class="hljs-comment">&lt;!-- ,   CRON-   --&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">scheduledtask</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">schedule</span></span></span><span class="hljs-tag">&gt;</span></span>5 * * * *<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">schedule</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span><span class="undefined"><span class="undefined">foo.module.script</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">scheduledtask</span></span></span><span class="hljs-tag">&gt;</span></span> ... <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">config</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A detailed description of Flute features is provided in the </font></font><a href="https://corchestra.ru/wiki/index.php%3Ftitle%3DFlute"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">documentation</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><h2>  Conclusion </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We went over the basic features of Celesta and Flute. </font><font style="vertical-align: inherit;">If you are interested in our technology - welcome to our </font></font><a href="https://corchestra.ru/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">website</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and our </font></font><a href="https://corchestra.ru/wiki/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wiki</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">And also come in September to the </font></font><a href="https://jugmsk.timepad.ru/event/569994/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">meeting jug.msk.ru</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , where we will show everything "live" and answer all the questions!</font></font></div><p>Source: <a href="https://habr.com/ru/post/335966/">https://habr.com/ru/post/335966/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../335954/index.html">ReactOS versus Windows XP SP3: the epic battle in 3DMark</a></li>
<li><a href="../335958/index.html">Implementation, analog and adaptation for ‚Äúpure‚Äù javascript JavaScript jQuery () functions; and adjacent to it</a></li>
<li><a href="../335960/index.html">Playfully bash'im</a></li>
<li><a href="../335962/index.html">Parametric modeling in CAD SolveSpace: "The ways of the Solver are inscrutable" or "Newton's Wormholes"</a></li>
<li><a href="../335964/index.html">How cloud service Drimkas Cabinet copes with spontaneous loads</a></li>
<li><a href="../335968/index.html">Cloning the Lode Runner game from the first PC in the USSR "BK-0010" plus a few words about the programming of games in the late 80s</a></li>
<li><a href="../335970/index.html">We break haks completely. We read machine codes as an open book.</a></li>
<li><a href="../335972/index.html">Game model of behavior in the market of two competing firms in Python</a></li>
<li><a href="../335974/index.html">Labyrinth generation by Eller algorithm in Unity</a></li>
<li><a href="../335976/index.html">About website rejuvenation - decision criteria</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>