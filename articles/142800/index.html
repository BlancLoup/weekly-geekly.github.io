<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ASP.NET MVC: Conversion or injection? That is the question</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Classes should have dependencies only on abstract, not concrete, classes. To solve this problem, you can choose between 2 practices Service Locator an...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>ASP.NET MVC: Conversion or injection? That is the question</h1><div class="post__text post__text-html js-mediator-article">  Classes should have dependencies only on abstract, not concrete, classes.  To solve this problem, you can choose between 2 practices Service Locator and Dependency Injection.  ASP.NET MVC uses ‚ÄúDependency Resolvers", which are Service Locators. When developing ASP.NET MVC applications, you yourself have to decide what to use (resolve) or injects, so what are the pros and cons? <br><a name="habracut"></a><br>  I understand that Dependency Injection has a very great value in solving the dependency problem, but I do not believe that it is the only true one.  Dependency Injection is only a detail of the implementation that really matters the principle underlying it - the principle of inversion (Dependency Inversion) dependencies.  If you are familiar with the <a href="http://ru.wikipedia.org/wiki/SOLID_(%25D0%25BE%25D0%25B1%25D1%258A%25D0%25B5%25D0%25BA%25D1%2582%25D0%25BD%25D0%25BE-%25D0%25BE%25D1%2580%25D0%25B8%25D0%25B5%25D0%25BD%25D1%2582%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25BD%25D0%25BE%25D0%25B5_%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B3%25D1%2580%25D0%25B0%25D0%25BC%25D0%25BC%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5)">SOLID</a> abbreviation, the principle of dependency inversion is simply ‚ÄúD‚Äù in the abbreviation.  By the way, solid results from the initials are five design principles that are considered necessary in object-oriented software development.  These five principles are: <br><ul><li>  Principle of sole duty </li><li>  Principle of openness / closeness </li><li>  Barbara Liskov substitution principle </li><li>  Interface separation principle </li><li>  Principle of dependency inversion </li></ul><br>  Almost all of these principles are only vectors in the sense that they show you the direction, but do not give specific instructions on how to solve your tasks.  Let's take the principle of the sole duty as an example.  All of this suggests that you should try to write classes so that you only have one reason to change later.  The idea of ‚Äã‚Äãthe principle is that classes should be much more cohesive than they often are not.  The methods they contain should be logically connected and form a single chain of responsibility.  As you can see, the principle portends a clear and general idea, but it does not give you instructions on how to achieve this. <br><br><h5>  The interiors of the principle of dependency inversion </h5><br>  The principle of dependency inversion, on the contrary, has a rather unclear formulation, but can be translated into a detailed set of implementation steps.  The principle of dependency inversion states that classes should not have dependencies on specific classes, but only in abstraction.  In a more understandable language, this means that you must use interfaces to abstract all critical dependencies within a class.  If, for example, your class uses a logging component, then the best thing you can do is to declare the ILogger interface, and not the Logger class.  Thus, you can change the implementation of the logging class at any time (and how many times you want) without breaking your main code. <br>  The meaning of the algorithm for implementing the principle of dependency inversion is that you transfer the list of dependencies to the required place in the code.  Let's look at this with an example: <br><pre><code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">MyComponent</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyComponent</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { : } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoSomeWork</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> logger = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Logger(); : } }</code> </pre> <br>  Obviously, the MyComponent class has a dependency on the Logger class.  If we decide to change it to ILogger, how can we get a link to the actual class that implements the interface? <br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">MyComponent</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyComponent</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { : } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoSomeWork</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ILogger logger = ...; <span class="hljs-comment"><span class="hljs-comment">// who's going to provide this? : } }</span></span></code> </pre><br>  To implement the principle of dependency inversion, you have a choice of two main models: Service Locator and Dependency Injection.  The first method solves the problem inside the class, the second allows you to remove the dependency from the class.  The following listing illustrates the Service Locator method: <br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">MyComponent</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyComponent</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { : } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoSomeWork</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ILogger logger = ServiceLocator.GetService(); : } }</code> </pre><br>  You have a dependency resolution component that the type usually takes (usually an interface) and returns an instance of a particular type that implements this interface.  The type negotiation that is transmitted and the specific instance of the type are hidden in the implementation of the locator component.  This model is known as the Service Locator pattern. <br>  Here is another approach: <br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">MyComponent</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> ILogger _logger; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyComponent</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ILogger logger</span></span></span><span class="hljs-function">)</span></span> { _logger = logger; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoSomeWork</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Use the logger component here _logger.Log(); : } }</span></span></code> </pre><br>  In this case, the MyComponent class gets an ILogger component for use with the outside world.  Your environment will take care of initializing the registrar before passing it to MyComponent.  This is the essence of the dependency injection model. <br>  What is the difference (if any) between dependency injection (Dependency Injection) and Service Locator?  Both models are good at implementing the principle of dependency inversion.  The Service Locator model is easier to use in existing code, it makes the overall design weaker, without forcing changes to the public interface.  For the same reason, the code based on the Service Locator model is worse to read than the equivalent code based on Dependency Injection. <br>  In Dependency Injection, you can clearly see what type will be before and after the injection into the class (or method).  For this reason, as a result, the code becomes cleaner and more readable.  What about ASP.NET MVC? <br><br><h5>  Dependency Injection in ASP.NET MVC </h5><br>  ASP.NET MVC is designed for multiple extension points, but in general it does not provide comprehensive support for dependency injection.  Service Locator is perhaps the most effective way to make the existing system more loosely connected with the addition of new expansion points, since this is the least intrusive solution.  The Service Locator acts as a black box, which you install at a certain point and give it rules, what contracts are required, and how to get them.  ASP.NET MVC has a number of extension points, which are components of the system, but which can also be replaced by user ones.  The table shows the known extension points on ASP.NET MVC 3. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <table><tbody><tr><th>  Provider </th><th>  Description </th></tr><tr><td>  Action Invoker </td><td>  // In the controller constructor class controller.ActionInvoker = new YourActionInvoker (); </td></tr><tr><td>  Controller factory </td><td>  // In global.asax, Application_Start <br>  var factory = new YourControllerFactory ();  ControllerBuilder.Current.SetControllerFactory (factory); <br></td></tr><tr><td>  Dictionary values </td><td>  // In global.asax, <br>  Application_Start var providerFactory = new YourValueProviderFactory ();  ValueProviderFactories.Factories.Add (providerFactory); <br></td></tr><tr><td>  Model binder </td><td>  // In global.asax, Application_Start ModelBinders.Binders.Add (typeof (YourType), new YourTypeBinder ()); </td></tr><tr><td>  Model binder provider </td><td>  // In global.asax, Application_Start var provider = new YourModelBinderProvider ();  ModelBinderProviders.BinderProviders.Add (provider); </td></tr><tr><td>  Model metadata </td><td>  // In global.asax, Application_Start ModelMetadataProviders.Current = new YourModelMetadataProvider (); </td></tr><tr><td>  Model validator </td><td>  // In global.asax, Application_Start var validator = new YourModelValidatorProvider ();  ModelValidatorProviders.Providers.Add (validator); </td></tr><tr><td>  Tempdata </td><td>  // In the controller class constructor <br>  controller.TempDataProvider = new YourTempDataProvider (); <br></td></tr><tr><td>  View engine </td><td>  // In global.asax, Application_Start ViewEngines.Engines.Clear ();  ViewEngines.Engines.Add (new YourViewEngine ()); </td></tr></tbody></table><br><br>  View engine // In global.asax, Application_Start ViewEngines.Engines.Clear ();  ViewEngines.Engines.Add (new YourViewEngine ()); <br>  Before ASP.NET MVC 3, there was no standard way to register custom components.  Each of the components listed in Table 1 requires its own API for integration into custom applications.  Starting from version 3, ASP.NET MVC introduces new (additional) models based on arbitration dependencies.  To replace the system components, you can follow the path described in Table 1 or register an injection (Dependency Injection) for this type.  The ASP.NET runtime will detect dependencies and reference it when necessary. <br>  Dependency resolution is just a service locator integrated with ASP.NET MVC code.  Arbitrators are one way to add the implementation of the principle of dependency inversion in existing (large) code.  For the size and complexity of the code, using dependencies is less appropriate, as this would require changes at various levels in the public API.  This is just not an option for frameworks such as ASP.NET MVC.  Let's find out more detailed information about the implementation of dependency arbitrators in ASP.NET MVC. <br><br><h5>  Determining Your Dependency Resolver </h5><br>  In ASP.NET MVC, Dependency Resolver is an object that implements the following interface <br><pre> <code class="hljs pgsql">{ <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span> GetService(<span class="hljs-keyword"><span class="hljs-keyword">Type</span></span> serviceType); IEnumerable&lt;<span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>&gt; GetServices(<span class="hljs-keyword"><span class="hljs-keyword">Type</span></span> serviceType); }</code> </pre><br>  The logic you write to the converter is entirely up to you.  It can be as simple as logic, which checks the type description and returns a newly created instance of a particular type.  This can be done by a more complex implementation of creating instances, reading information from a configuration file, or using reflection.  Finally, it can be based on unity or any other IoC framework.  Here is a very simple, but functional, conversion example: <br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SampleDependencyResolver</span></span> : <span class="hljs-title"><span class="hljs-title">IDependencyResolver</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">object</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetService</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Type serviceType</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (serviceType == <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(ISomeClass)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SomeClass(); : } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> IEnumerable&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">object</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetServices</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Type serviceType</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Enumerable.Empty&lt;Object&gt;(); } }</code> </pre><br>  The following code shows how the converter uses Unity (and its section in the file configuration) to resolve dependencies. <br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">UnityDependencyResolver</span></span> : <span class="hljs-title"><span class="hljs-title">IDependencyResolver</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> IUnityContainer _container; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UnityDependencyResolver</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">this</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">new UnityContainer(</span></span></span><span class="hljs-function">).</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LoadConfiguration</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>))</span></span> { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UnityDependencyResolver</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IUnityContainer container</span></span></span><span class="hljs-function">)</span></span> { _container = container; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Object </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetService</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Type serviceType</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _container.Resolve(serviceType); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> IEnumerable&lt;Object&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetServices</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Type serviceType</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _container.ResolveAll(serviceType); } }</code> </pre><br>  You register your permissions with an ASP.NET MVC structure using the DependencyResolver class and the SetResolver method. <br><pre> <code class="hljs pgsql">protected <span class="hljs-type"><span class="hljs-type">void</span></span> Application_Start() { // <span class="hljs-keyword"><span class="hljs-keyword">Prepare</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> configure the IoC container var container = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> UnityContainer(); : // <span class="hljs-keyword"><span class="hljs-keyword">Create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> register the resolver var resolver = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> UnityDependencyResolver(container); DependencyResolver.SetResolver(resolver); }</code> </pre><br>  If you are using IoC framework from permission, then you need to find the best way to provide it with a list of registered types.  If you prefer to pass this information through free code, then you need to fully configure the IoC container before creating names.  If you want to configure IoC using the web.config file, according to Unity rules, then you can use the default constructor for resolving which is required to load configuration data.  Note, however, that you may need to change this code if you are targeting a different IoC framework. <br>  In general, resolution dependency is an internal tool that developers can additionally use to deploy their own individual components, rather than system components.  The beauty of dependency converter is limited to using ASP.NET MVC.  Transformers are called in known places to achieve clear targets.  In other words, if ASP.NET MVC does not cause a conversion, before creating, say, a cache controller, then we unfortunately can do so much to replace the embedded cache with our own. <br><br><h5>  Using Transformations in Applications </h5><br>  It turned out that dependency conversion is nothing more than a name that ASP.NET MVC uses to discover a service.  But how can you still use it in real applications?  The answer is very simple: you should have only one transducer in which you have to make all your clodification, as you like.  Here is just one more variant of dependency conversion, an example of which was slightly higher. <br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SampleDependencyResolver</span></span> : <span class="hljs-title"><span class="hljs-title">IDependencyResolver</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">object</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetService</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Type serviceType</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> serviceType == <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(ModelMetadataProvider) ? <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ExtendedAnnotationsMetadataProvider() : Activator.CreateInstance(serviceType); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> IEnumerable&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">object</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetServices</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Type serviceType</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Enumerable.Empty&lt;<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>&gt;(); } }</code> </pre><br>  The GetService method gets the type, and checks it with a list of known types.  For some known interface types, it can simply return a manually created instance of a known type.  For other types, it can return anything, this means that the arbitrator is not able to work with this type. <br>  The dependency converter in ASP.NET MVC cannot convert the same type in any way during the life cycle of an application.  While this may be a significant limitation in implementing a shared service locator, it is not a big problem in the specific context of ASP.NET MVC.  dependency conversion is an intrinsic feature of ASP.NET MVC, and only ASP.NET MVC decides when and how to call and use registered converters.  In the end, your converter will be called only in a limited number of cases, and the interface will become more than understandable. <br><br><h5>  So what to use transformations or injections? </h5><br>  If you look at this question from the point of view of design efficiency, then Dependency Injection is preferred because it leads the design to a clean and crystal clear distribution of responsibilities.  To use Dependency Injection, you may have to dare to change your API interface.  This may not be acceptable depending on the context, it would not be acceptable, for example, when moving from ASP.NET MVC 2 to ASP.NET MVC 3. For this reason, Microsoft opted to use dependency converters, a fancy name for classic Service Locator.  A more realistic example, a locator service is the only option when you need to refactor a large existing application. <br><br>  <i><u>ps This is my first translation thanks for your understanding.</u></i> </div><p>Source: <a href="https://habr.com/ru/post/142800/">https://habr.com/ru/post/142800/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../142794/index.html">"Crouching cars, hidden piano", or the theory of probability in action</a></li>
<li><a href="../142795/index.html">EAP-SIM authentication in WLAN</a></li>
<li><a href="../142796/index.html">Determine which row was clicked in UIPickerView</a></li>
<li><a href="../142798/index.html">Google Street View in Donetsk</a></li>
<li><a href="../142799/index.html">Java Agent in Jelastic</a></li>
<li><a href="../142801/index.html">Shareware Building ASP.NET MVC Apps with EF Code First, HTML5, and jQuery</a></li>
<li><a href="../142802/index.html">The use of analogue "notebook" is not quite as intended</a></li>
<li><a href="../142803/index.html">Disk Encryption in XenServer</a></li>
<li><a href="../142804/index.html">What would our world look like if the Internet had existed for thousands of years</a></li>
<li><a href="../142805/index.html">Determining the IP address of a Skype user</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>