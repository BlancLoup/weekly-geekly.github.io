<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We use Secure Boot in Linux to the fullest</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Secure Boot technology is aimed at preventing the execution of untrusted code when booting the operating system, that is, protection against bootkits ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We use Secure Boot in Linux to the fullest</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/255/553/3ff/2555533ffb374565aed2eec1951e90c4.png"><br><br><p>  Secure Boot technology is aimed at preventing the execution of untrusted code when booting the operating system, that is, protection against bootkits and Evil Maid attacks.  Devices with Secure Boot contain in non-volatile memory a public key database that verifies the signatures of downloadable UEFI applications, such as OS loaders and drivers.  Applications signed with a trusted key and with the correct checksum are allowed to load, the rest are blocked. </p><br><p>  More details about Secure Boot can be found in a series of articles from <a href="https://habr.com/users/coderush/" class="user_link">CodeRush</a> . </p><br><ul><li><p>  <a href="https://habrahabr.ru/post/267953/">About UEFI security, part five</a> </p><br></li><li><p>  <a href="https://habrahabr.ru/post/273497/">Taming UEFI SecureBoot</a> </p><br></li></ul><br><p>  In order for Secure Boot to provide security, signed applications must comply with some ‚Äúcode of honor‚Äù: do not have loopholes for unrestricted access to the system and the parameters of Secure Boot, as well as require the same from the applications they download.  If a signed application provides the ability to use unfair use directly or by downloading other applications, it becomes a security threat to all users who trust this application.  <strong>Such a threat is represented by the shim loader signed by Microsoft and GRUB loaded by it</strong> . </p><br><p>  To protect against this, we will <a href="https://habrahabr.ru/post/308032/">install</a> Ubuntu with encryption of the entire drive based on LUKS and LVM, protect initramfs from changes, <a href="https://habrahabr.ru/post/308032/">merging</a> it with the kernel into one UEFI application, and <a href="https://habrahabr.ru/post/308032/">sign</a> it with our own keys. <a name="habracut"></a></p><br><h3 id="ogranicheniya-resheniy-iz-korobki">  Out-of-box solution constraints </h3><br><p>  Ubuntu, like other common distributions, offers the option of encrypting the entire LVM drive during installation.  The distribution in this configuration without errors is installed on UEFI with active Secure Boot. </p><br><p>  But Canonical is primarily <a href="https://firmwaresecurity.com/2016/01/07/ubuntus-uefi-secure-boot-not-a-security-measure/">interested in operating the OS on devices with Secure Boot enabled, and not in providing security through it</a> .  If you want to use Secure Boot as a security tool, then you are on your own. </p><br><h4 id="kak-ubuntu-realizuet-zagruzku-v-secure-boot-s-shifrovaniem-vsego-diska-i-chto-s-etim-ne-tak">  How does Ubuntu implement Secure Boot encryption for the entire disk and what‚Äôs wrong with that? </h4><br><p>  Red Hat developed the <a href="https://github.com/rhinstaller/shim">shim</a> loader <a href="https://github.com/rhinstaller/shim">so</a> that it worked on all devices and served the benefit of humanity, observing the strict requirements of the Secure Boot standard and downloading only trusted UEFI applications.  Canonical uses shim as a proxy, embedding its public key into it and signing it with Microsoft.  Shim loads GRUB, signed by the Canonical dongle, which then loads the kernel, signed by Canonical. </p><br><ul><li><p>  Let's start with the fact that not the entire disk is encrypted - / boot remains unencrypted, and therefore the initramfs in it.  Access to initramfs means root access.  Fail. </p><br></li><li><p>  / boot <a name="back1"></a>  remains unencrypted because the default GRUB cannot decrypt a disk without cryptographic modules.  Which for some reason is not embedded in the signed GRUB.  GRUB is <a href="https://sources.debian.net/patches/grub2/2.02~beta2-36/no_insmod_on_sb.patch/">not allowed to load additional modules into Secure Boot</a> .  Double Fail <sup><a href="https://habr.com/ru/post/308032/">1</a></sup> . </p><br></li><li><p>  GRUB must verify loadable kernels and reject incorrectly signed ones.  <a href="https://bugs.launchpad.net/ubuntu/%2Bsource/grub2/%2Bbug/1401532">He does not do this</a> .  Triple Fail. </p><br></li><li><p>  Grub <a name="back2"></a>  loads its settings from a file and by default provides access to the console.  The authenticity of the configuration file is not checked, with the help of its modification or via the console you can do anything: load the UEFI Shell, another kernel, initramfs or transfer the arguments to the kernel and get root access.  Fatal Error <sup><a href="https://habr.com/ru/post/308032/">2</a></sup> . </p><br></li></ul><br><h4 id="chto-eto-vsyo-oznachaetanchorback3anchor">  What does all this mean? <a name="back3"></a></h4><br><p>  If you have a Microsoft <sup><a href="https://habr.com/ru/post/308032/">3</a></sup> key on your system, then anyone can boot from an external device, install a bootkit and gain complete control over your device.  There is no need to disable Secure Boot: it no longer works. </p><br><img src="https://habrastorage.org/files/5ef/c12/bdd/5efc12bdd242454da026fb254c2ce254.png"><br><br><p>  <a href="https://blogs.msdn.microsoft.com/windows_hardware_certification/2013/12/03/microsoft-uefi-ca-signing-policy-updates/">According to the Microsoft UEFI application</a> signing <a href="https://blogs.msdn.microsoft.com/windows_hardware_certification/2013/12/03/microsoft-uefi-ca-signing-policy-updates/">policy</a> , all signed GRUB and shim bootloaders used to download GRUB should already be blacklisted. </p><br><p>  Speak <a name="back4"></a>  , you just need to disable booting from external devices?  This is a fight with symptoms.  If you have an unprotected GRUB installed, this will not save you.  If your device is Windows, then you can choose from it a device to boot, and it is likely that your firmware will allow it <sup><a href="https://habr.com/ru/post/308032/">4</a></sup> .  There is still <a href="https://wiki.kubuntu.org/UEFI/SecureBoot-PXE-IPv6">PXE Network Boot</a> .  It will only help the password to turn on the device. </p><br><h5 id="vyvod">  Conclusion </h5><br><p>  It is necessary to abandon the keys of others.  The user must control the secure boot.  The loader must be signed by the user, all unencrypted and writable elements in the boot system must be verified.  User data must be encrypted.  What we will try to achieve. </p><br><h3 id="ustanovka-ubuntu-s-shifrovaniem-vsego-diska-s-pomoschyu-luks-i-lvmanchorinstallanchor">  Installing Ubuntu with full disk encryption using LUKS and LVM <a name="install"></a></h3><br><p>  <strong>LUKS</strong> - Linux Unified Key Setup - a <strong>dm-crypt</strong> cryptographic system wrapper that allows you to create virtual encrypted devices in files and on physical disks.  With LUKS, you can encrypt data on the entire disk so that you need to enter a password before loading the OS. </p><br><p>  <strong>LVM</strong> - Logical Volume Manager is a logical volume manager with which we will divide the cryptocontainer into volumes.  LVM volumes are automatically mounted after entering the password to the cryptocontainer; a separate password is not required for each volume. </p><br><p>  The following instructions should be applicable to any Ubuntu-based distribution, others will require adjustments.  First boot from the Live CD or installation image in <em>Try before installing</em> mode. </p><br><h4 id="razmetka-i-shifrovanie">  Markup and Encryption </h4><br><p>  To boot from disk in UEFI mode, it must be marked up in GPT format.  Disk layout will be discussed using KDE Partition Manager and GParted.  If you do not have them, install one that matches your environment. </p><br><pre><code class="bash hljs">sudo apt-get install partitionmanager <span class="hljs-comment"><span class="hljs-comment"># KDE sudo apt-get install gparted # GNOME  </span></span></code> </pre> <br><p>  Start the partition editor and select the disk you are interested in, usually it is the first one in the system - / dev / sda.  Look at the properties of the disk. </p><br><pre> <code class="bash hljs">KDE Partition Manager:     , GParted: View -&gt; Device Information.</code> </pre> <br><p>  The row of the <strong>partition table</strong> shows the <strong>partition table</strong> used.  If the disk is marked in <strong>dos</strong> / <strong>msdos</strong> (MBR) format, then it must be converted to GPT.  It is possible to do this without losing data, but I will not describe it here, look for instructions on the Internet.  If there is no important data on the disk and you want to format it in GPT, create a new table. </p><br><pre> <code class="bash hljs">KDE Partition Manager: New Partition Table ‚Äî GPT GParted: Device -&gt; Create Partition Table ‚Äî gpt</code> </pre> <br><p>  The disk must have at least one <strong>ESP</strong> partition (EFI System Partition) in which the boot loaders will be stored.  If the UEFI mode is installed on this disk, then one such partition already exists.  In any case, I recommend creating a new one with a size of at least 100 MB.  ESP should be formatted in one of the FAT formats, preferably in FAT32, and also marked as bootable. </p><br><pre> <code class="bash hljs">KDE Partition Manager:     -&gt; New File system: fat32 Size: 128.00 MiB Free space before: 0.00 ‚Äî    GPT OK, Apply       (Properties),   boot OK, Apply GParted:     -&gt; New File system: fat32 New size: 128 MiB Free space preceding: 1 MiB   ‚Äî    GPT Add, Apply        (Manage Flags),   boot Close</code> </pre><br><p>  Next you need to create a partition for encryption.  In the same way as ESP, only without formatting (unformatted), setting flags and larger in size - so as to accommodate the system and the swap partition.  In this section, we will create a LUKS cryptocontainer through the terminal, having previously switched to the superuser mode. </p><br><pre> <code class="bash hljs">sudo -i</code> </pre> <br><p>  We format the section with the indication of modern encryption and hashing algorithms.  In XTS mode, the key length must be specified twice as large, so for AES-256 you need to specify a key with a length of 512 bits.  The <code>--iter-time</code> parameter specifies the time, in milliseconds, spent on key generation from the entered password using the PBKDF2 function.  More iterations complicate brute force, but also increase the waiting time after entering the correct password. </p><br><pre> <code class="bash hljs">cryptsetup luksFormat --cipher aes-xts-plain64 --key-size 512 --<span class="hljs-built_in"><span class="hljs-built_in">hash</span></span> sha512 --iter-time 2000 /dev/sda2</code> </pre> <br><p>  Confirm the formatting by writing <strong>YES</strong> , enter the password.  Now open the cryptocontainer (sda2_crypt is the name for the mapping) and enter the same password. </p><br><pre> <code class="bash hljs">cryptsetup luksOpen /dev/sda2 sda2_crypt</code> </pre> <br><p>  The container should become available as a block device / dev / mapper / sda2_crypt.  Let us turn to the layout of logical volumes inside the cryptocontainer.  Initialize the LVM physical partition on top of / dev / mapper / sda2_crypt. </p><br><pre> <code class="bash hljs">pvcreate /dev/mapper/sda2_crypt</code> </pre> <br><p>  Inside this physical partition, create a volume group called <em>ubuntu</em> . </p><br><pre> <code class="bash hljs">vgcreate ubuntu /dev/mapper/sda2_crypt</code> </pre> <br><p>  Now we can create logical volumes within this group.  First create a volume for the swap partition and initialize it.  The recommended size is from sqrt (RAM) to 2xRAM in gigabytes. </p><br><pre> <code class="bash hljs">lvcreate -n swap -L 4G ubuntu <span class="hljs-comment"><span class="hljs-comment">#      swap  4    ubuntu mkswap /dev/ubuntu/swap</span></span></code> </pre> <br><p>  Add a volume for the root and create an <strong>ext4</strong> file system in it.  It is considered good practice to leave free space and expand volumes as needed, therefore we will allocate 20 GB for the root.  If desired, additional volumes for home, usr, var, and so on can be allocated in the free space.  You can select all free space for a volume using the <code>-l 100%FREE</code> parameter. </p><br><pre> <code class="bash hljs">lvcreate -n root -L 20G ubuntu mkfs.ext4 /dev/ubuntu/root</code> </pre> <br><p>  With the markup finished, you can proceed to the installation. </p><br><h4 id="ustanovka">  Installation </h4><br><p>  Since we are planning to create the bootloader ourselves, and the Ubuntu installer does not support <em>/ boot</em> encryption, we will start the installation without creating a bootloader. </p><br><pre> <code class="bash hljs">ubiquity -b</code> </pre> <br><p>  At the disk layout stage, select <em>Manual</em> . </p><br><p>  Here we need to specify the mount points.  Select / dev / mapper / ubuntu-root, specify the use <em>of Ext4</em> as a <em>journaling file system</em> , the Mount Point in <em>/</em> , without formatting.  Ubiquity will pick up / dev / mapper / ubuntu-swap as a swap partition and remember one of the EFI system partitions.  The markup screen should look like this: </p><br><img src="https://habrastorage.org/files/299/532/905/2995329054204234905887985f4d0c78.png">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>  Finish the installation and do not reboot. </p><br><h4 id="nastroyka-crypttab-fstab-i-resume">  Configuring crypttab, fstab and resume </h4><br><p>  Mount the root of the installed system in / mnt, link / dev, / sys and / proc with / mnt / dev, / mnt / sys and / mnt / proc respectively, and also /etc/resolv.conf with / mnt / etc / resolv. conf so that you have access to the network.  Now change the root directory with <code>chroot</code> . </p><br><pre> <code class="bash hljs">mount /dev/ubuntu/root /mnt mount --<span class="hljs-built_in"><span class="hljs-built_in">bind</span></span> /dev /mnt/dev mount --<span class="hljs-built_in"><span class="hljs-built_in">bind</span></span> /sys /mnt/sys mount --<span class="hljs-built_in"><span class="hljs-built_in">bind</span></span> /proc /mnt/proc mount --<span class="hljs-built_in"><span class="hljs-built_in">bind</span></span> /etc/resolv.conf /mnt/etc/resolv.conf chroot /mnt mount -a <span class="hljs-comment"><span class="hljs-comment">#  ESP   /boot/efi ,      /etc/fstab</span></span></code> </pre> <br><p>  You need to manually fill in / etc / crypttab - a file that describes crypto containers that are mounted when loading. </p><br><pre> <code class="bash hljs">nano /etc/crypttab</code> </pre> <br><p>  Add to it an entry for / dev / sda2, mounted on / dev / mapper / sda2_crypt.  Set up the mount by UUID, not by device name.  To find the UUID / dev / sda2, open another terminal and use the command: </p><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">sudo</span></span> blkid</code> </pre> <br><p>  The line starting with / dev / sda2 will contain its UUID.  Copy it ( <strong>Ctrl + Shift + C</strong> ).  In / etc / crypttab add an entry like <em>mapping_name UUID = &lt;UUID&gt; none luks</em> , inserting the UUID ( <strong>Ctrl + Shift + V</strong> ).  Close <code>nano</code> by pressing <strong>Ctrl + X</strong> and <strong>Y</strong> , confirming the save. </p><br><img src="https://habrastorage.org/files/7b5/9cb/244/7b59cb244f974dda95b85d3ffbecb942.png"><br><br><p>  Make sure that the mounted partitions are described correctly in / etc / fstab, and the /etc/initrmfs-tools/conf.d/resume section has a partition for waking from hibernation. </p><br><img src="https://habrastorage.org/files/621/cf2/69c/621cf269cc2e4540ac41687db956df9d.png"><br><br><p>  After all the changes, update the initramfs image. </p><br><pre> <code class="bash hljs">update-initramfs -u</code> </pre> <br><p>  Do not log out and <code>chroot</code> , </p><br><h3 id="sozdanie-zagruzchikaanchorprotectanchor">  Build Loader <a name="protect"></a></h3><br><p>  The Linux kernel <a href="https://habrahabr.ru/post/197438/">supports booting directly from UEFI</a> if it has been compiled with the CONFIG_EFI_STUB parameter.  In this case, initramfs is usually stored side by side in ESP, and the path to it is passed in arguments to the kernel. </p><br><p>  However, the lack of verification initramfs allows you to embed malicious code into it, with write access to the ESP.  Teddy Reed <a href="http://prosauce.org/blog/2015/10/31/booting-linux-securely">offers to compile the kernel by building initramfs into it</a> . </p><br><p>  The process of compiling the kernel is quite long, it will have to be done after each change of initramfs.  Fortunately, there is another way.  The <code>systemd</code> package (previously in <code>gummiboot</code> ) contains <em>linuxx64.efi.stub</em> , a UEFI application <em>stub</em> into which you can embed the kernel, initramfs, and arguments passed to the kernel.  By signing this UEFI application, we will protect the kernel and initramfs from changes. </p><br><p>  This operation will require the <code>binutils</code> . </p><br><pre> <code class="bash hljs">sudo apt-get install binutils</code> </pre> <br><p>  We write in / tmp / cmdline the arguments that will be passed to the kernel. </p><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> -n <span class="hljs-string"><span class="hljs-string">"quite splash"</span></span> &gt; /tmp/cmdline</code> </pre> <br><p>  The / boot contains kernel images ( <em>vmlinuz - * - generic</em> ) and initramfs ( <em>initrd.img - * - generic</em> ).  Determine the latest version and embed them in the workpiece. </p><br><pre> <code class="bash hljs">objcopy \ --add-section .osrel=/etc/os-release --change-section-vma .osrel=0x20000 \ --add-section .cmdline=/tmp/cmdline --change-section-vma .cmdline=0x30000 \ --add-section .linux=/boot/vmlinuz-4.4.0-34-generic --change-section-vma .linux=0x2000000 \ --add-section .initrd=/boot/initrd.img-4.4.0-34-generic --change-section-vma .initrd=0x3000000 \ /usr/lib/systemd/boot/efi/linuxx64.efi.stub ubuntu.efi</code> </pre> <br><p>  The resulting UEFI application ubuntu.efi must be located in ESP in the EFI / BOOT / directory.  The Ubuntu installer should have defined ESP and set up the mount in / boot / efi.  If there are no other bootloaders in this ESP, then ubuntu.efi can be copied to /boot/efi/EFI/BOOT/BOOTX64.EFI, then it will load when you select this section in the UEFI boot menu. </p><br><pre> <code class="bash hljs">mkdir -p /boot/efi/EFI/BOOT cp ubuntu.efi /boot/efi/EFI/BOOT/BOOTX64.EFI</code> </pre> <br><p>  If a <a name="back5"></a>  ESP has already recorded the BOOTX64.EFI boot loader, then you can create another ESP, or write ubuntu.efi under a different name and add the corresponding boot record via the UEFI (UEFI Shell) console built into your firmware.  Using <code>efibootmgr</code> not recommended <sup><a href="https://habr.com/ru/post/308032/">5</a></sup> . </p><br><p>  UPD: If the UEFI Shell is not built into your firmware, you can download it <a href="https://github.com/tianocore/edk2/tree/master/ShellBinPkg/UefiShell">from here</a> .  Put it in EFI / BOOT / BOOTX64.EFI of any ESP and boot with disabled Secure Boot.  To add a boot entry, enter the following command: </p><br><pre> <code class="bash hljs">bcfg boot add 0 fs0:\EFI\BOOT\UBUNTU.EFI <span class="hljs-comment"><span class="hljs-comment"># 0 --     ,      # fs0 --   ,    #       ESP,    \UBUNTU.EFI</span></span></code> </pre> <br><p>  Thanks to <a href="https://habr.com/users/prototik/" class="user_link">Prototik</a> for the UEFI Shell link.  A list of other teams can be found <a href="https://software.intel.com/en-us/articles/efi-shells-and-scripting/">here</a> . </p><br><p>  If you have Secure Boot enabled, it will not work with ubuntu.efi, since it is not signed.  Temporarily disable Secure Boot and boot, or continue from chroot. </p><br><h3 id="nastroyka-secure-bootanchorsignanchor">  Configure Secure Boot <a name="sign"></a></h3><br><p>  Generating keys, installing them into the firmware and signing UEFI applications described the <a href="https://habr.com/users/coderush/" class="user_link">CodeRush</a> <a href="https://habrahabr.ru/post/273497/">here</a> , so I will assume that you understand and can do everything. </p><br><p>  It remains only to sign the bootloader we created. </p><br><pre> <code class="bash hljs">sbsign --key ISK.key --cert ISK.pem --output BOOTX64.EFI ubuntu.efi</code> </pre> <br><p>  Place the BOOTX64.EFI in the EFI / BOOT directory / EFI partition from which you plan to boot. </p><br><h4 id="avtomatizaciya">  Automation </h4><br><p>  To ensure that the bootloader is automatically updated and signed when the initramfs is updated, create the update-efi-loader script in /etc/initramfs/post-update.d/, changing the paths where required. </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/sh echo -n "quiet splash" &gt; /tmp/cmdline objcopy \ --add-section .osrel=/etc/os-release --change-section-vma .osrel=0x20000 \ --add-section .cmdline=/tmp/cmdline --change-section-vma .cmdline=0x30000 \ --add-section .linux=/boot/vmlinuz-$(uname -r) --change-section-vma .linux=0x2000000 \ --add-section .initrd=/boot/initrd.img-$(uname -r) --change-section-vma .initrd=0x3000000 \ /usr/lib/systemd/boot/efi/linuxx64.efi.stub /tmp/ubuntu.efi sbsign --key /root/keys/ISK.key --cert /root/keys/ISK.pem --output /boot/efi/EFI/BOOT/BOOTX64.EFI /tmp/ubuntu.efi</span></span></code> </pre><br><p>  Give the script the right to execute. </p><br><pre> <code class="bash hljs">chmod a+x /etc/initramfs/post-update.d/update-efi-loader</code> </pre> <br><p>  When updating the kernel, you will have to perform this operation manually. </p><br><h4 id="podpisyvanie-drayverov-i-moduley-yadra">  Signing drivers and kernel modules </h4><br><p>  If you need to install third-party or own drivers and kernel modules, you need to sign them.  To sign kernel modules, you need a certificate in the DER format and a key without a password, that is, generated with the <code>-nodes</code> parameter. </p><br><pre> <code class="bash hljs">openssl req -new -nodes -utf8 -sha256 -days 36500 -batch -x509 \ -subj <span class="hljs-string"><span class="hljs-string">"/CN=Kernel Key"</span></span> -outform DER -out kernel.der \ -keyout kernel.key</code> </pre> <br><p>  For signing, use the <code>sign-file</code> script. </p><br><pre> <code class="bash hljs">/usr/src/linux-headers-$(uname -r)/scripts/sign-file sha256 kernel.key kernel.der module.ko</code> </pre><br><p>  To add this certificate to the firmware, you need to convert it to PEM format, then to ESL and sign it with the KEK key. </p><br><pre> <code class="bash hljs">openssl x509 -inform der -<span class="hljs-keyword"><span class="hljs-keyword">in</span></span> kernel.der -outform pem -out kernel.pem cert-to-efi-sig-list -g <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$(uuidgen)</span></span></span><span class="hljs-string">"</span></span> kernel.pem kernel.esl sign-efi-sig-list -k KEK.key -c KEK.pem kernel kernel.esl kernel.auth</code> </pre><br><h4 id="ochevidnye-sovety">  Obvious tips </h4><br><p>  If your task is to protect the data on the device, then Secure Boot will do its job and no more.  The rest is yours. </p><br><ul><li><p>  Do not add other people's keys to the firmware.  Even from Microsoft.  First of all from Microsoft. </p><br></li><li><p>  Do not sign UEFI Shell, KeyTool or other applications that have access to the record in NVRAM.  Use them in Setup Mode. </p><br></li><li><p>  Do not leave the device turned on without supervision.  The device in suspend to RAM contains the decrypted data and master keys of cryptocontainers in RAM. </p><br></li><li><p>  Set a password for UEFI Setup is not easier than from your cryptocontainer. </p><br></li><li><p>  When physically accessing the device internals, you can disable Secure Boot by dropping NVRAM's memory or damaging it, and also leave the hardware tab.  Such an attack is successful only when it is invisible.  Make it so that you can find out about it: glue the screws on the case with hard-to-reproduce stickers, smear them with varnish and sparkles.  Seal your device. </p><br></li><li><p>  Put the first in the download list unsigned application.  If you don‚Äôt see a message from Secure Boot one day, your device is definitely compromised. </p><br></li><li><p>  Reliably disconnected from the Internet device stored in the safe, you still can not think of anything.  Vulnerabilities in the implementation of Secure Boot in specific firmware are not excluded. </p><br></li></ul><br><h3 id="bonus-vozvraschenie-gibernacii">  Bonus: the return of hibernation </h3><br><p>  When encrypting the entire disk instead of the standby mode, hibernation is used to save the state and continue working from the point of stopping, it is also sleep mode or suspend to disk. </p><br><p>  For security reasons, kernel developers have <a href="http://kernel.ubuntu.com/git/ubuntu/ubuntu-xenial.git/commit/%3Fid%3Dd0ab4b7075ed12cc802df25d84419f4442c04882">disabled the possibility of hibernation when verification of kernel modules is enabled</a> .  It is argued that the recovery image is not verified upon waking, the swap partition can be replaced and then the system will wake up with unchecked and potentially malicious code. </p><br><img src="https://habrastorage.org/files/874/608/657/8746086575194fa1b3264169ad2497a5.png"><br><br><p>  This is true if initramfs is not verified and / or the swap partition is not encrypted.  However, regardless of the use of hibernation under such conditions, the initramfs can be replaced, and sensitive data restored from the swap partition.  In our configuration, initramfs is verified by being included in the signed boot file, and the swap partition is encrypted.  So this restriction is meaningless to us. </p><br><p>  Back in 2013, Chung-Yi Lee <a href="https://www.youtube.com/watch%3Fv%3DsnXZIP2JJtg">proposed to verify the recovery image</a> , and in 2015 he introduced a <a href="https://lwn.net/Articles/651274/">patch that</a> implements his idea.  But things are there.  Therefore, we assume that we are sufficiently protected with our encryption, and we will return to us hibernation without verification. </p><br><h4 id="sposob-1-otklyuchit-verifikaciyu-moduley-yadra">  Method 1: Disable Kernel Module Verification </h4><br><p>  Enabled verification of kernel modules disables hibernation.  By default, verification of kernel modules is enabled with Secure Boot, but it does not depend on Secure Boot.  It can be disabled, leaving only the Secure Boot. </p><br><p>  This should not cause much damage to safety.  Kernel modules are installed from a trusted source along with a kernel update and are stored on an encrypted disk and in a verified initramfs.  Third-party drivers are installed manually, and they will be signed by us or not, does not matter, because we already trust them.  SecureApt for the kernel and TLS / HTTPS for third-party drivers should be protected from MiTM, and then only root access to the decrypted disk remains.  But in this case, the attacker already has our data. </p><br><p>  ‚ÄúLeave a request‚Äù to disable module verification is possible using <code>mokutil</code> , and the <code>shim</code> loader <code>shim</code> confirm it. </p><br><pre> <code class="bash hljs">sudo apt-get install mokutil shim sudo mokutil --<span class="hljs-built_in"><span class="hljs-built_in">disable</span></span>-validation</code> </pre> <br><p>  Enter the password, which is then required to confirm character-by-character.  Now you need to boot via <code>shim</code> and select <em>Change Secure Boot state</em> (sic!) In it.  Place <em>/usr/lib/shim.efi</em> in <em>EFI / BOOT / BOOTX64.EFI</em> on one of the <em>ESPs</em> or add a boot record via UEFI Shell.  Pre-disable Secure Boot, then return it back. </p><br><p>  <strong>UPD 01/12/17:</strong> Together with <em>shim.efi, MokManager</em> should be saved alongside.  The latest versions of the <em>shim.efi</em> and <em>MokManager packages</em> are located in <em>/ usr / lib / shim /</em> , <em>shimx64.efi</em> and <em>mmx64.efi.signed</em> respectively.  You need to rename <em>mmx64.efi.signed</em> to <em>mmx64.efi</em> . </p><br><img src="https://habrastorage.org/files/e73/f0b/6e6/e73f0b6e64e349e8b4d6ab3eeecb7a23.png" align="left"><br><p>  Now Secure Boot and Hibernation are working, UEFI applications are being verified, but there are no kernel modules. </p><br><p>  In principle, <code>shim</code> and <code>mokutil</code> no longer required, they can be removed. <br><br clear="left"></p><br><h4 id="sposob-2-ispolzovat-staruyu-versiyu-yadra">  Method 2: Use the old kernel version </h4><br><p>  A patch that disables hibernation, appeared in Ubuntu-4.4.0-18.34.  Ubuntu-4.4.0-17.33 should be free from it.  However, staying at the old core, ignoring security updates, is not the best option. </p><br><h4 id="sposob-3-skompilirovat-svoyo-yadro">  Method 3: Compile your kernel </h4><br><p>  If your time is worth nothing, then you can compile your kernel without this limitation.  There is no guarantee that after long suffering you will be satisfied with the result.  But if you really want this, praise Linus Torvalds and the GPLv2, you have the right to do so.  You can pre-test the <a href="https://drive.google.com/open%3Fid%3D0BzkDXdrziEUmbWxKeXhqSlExNHM">kernel compiled by me</a> , so as not to waste your time. </p><br><div class="spoiler">  <b class="spoiler_title">Instructions</b> <div class="spoiler_text"><h4 id="poluchenie-ishodnogo-koda">  Getting the source code </h4><br><h5 id="apt-get">  apt-get </h5><br><p>  The easiest way to get the source code for the kernel of your version is to download it from the repository. </p><br><p>  In <em>/etc/apt/sources.list</em> , pointers to the source repositories should be present.  Usually there are already commented out entries with <em>deb-src</em> .  Uncomment them for the <em>xenial main</em> and <em>xenial-security main</em> repositories, or add them yourself, and then update the apt index. </p><br><pre> <code class="bash hljs">$ sudo nano /etc/apt/sources.list ... deb-src http://ru.archive.ubuntu.com/ubuntu/ xenial main restricted deb-src http://security.ubuntu.com/ubuntu xenial-security main restricted ... $ apt-get update</code> </pre> <br><p>  Download the source code and go to the created directory. </p><br><pre> <code class="bash hljs">apt-get <span class="hljs-built_in"><span class="hljs-built_in">source</span></span> linux-image-$(uname -r) <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> linux-4.4.0</code> </pre> <br><p>  Please note that apt will download the current version of the source code.  Check the version number of the <em>.dsc</em> file. </p><br><pre> <code class="bash hljs">linux_4.4.0-34.53.dsc</code> </pre> <br><h5 id="git">  git </h5><br><p>  If you want to keep the kernel up to date and recompile it as updates are released while preserving their changes, select git.  The initial download will take a long time. </p><br><p>  Install git. </p><br><pre> <code class="bash hljs">sudo apt-get install git</code> </pre> <br><p>  Create a local copy of the git-repository of the kernel of the current release of Ubuntu and go to the directory created. </p><br><pre> <code class="bash hljs">git <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> git://kernel.ubuntu.com/ubuntu/ubuntu-xenial.git <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> ubuntu-xenial</code> </pre> <br><p>  By default, git points to the <em>master</em> branch corresponding to the latest release version.  You can switch to another version by the release tag of this version.  To list all tags for a given mask, use <code>git tag -l &lt;&gt;</code> . </p><br><pre> <code class="bash hljs">$ git tag -l Ubuntu-* ... Ubuntu-4.4.0-33.52 Ubuntu-4.4.0-34.53 Ubuntu-4.4.0-35.54 ...</code> </pre> <br><p>  Create a <em>temp</em> branch for the tag corresponding to your version, and switch to it. </p><br><pre> <code class="bash hljs">git checkout -b temp Ubuntu-4.4.0-34.53</code> </pre> <br><h4 id="nastroyka">  Customization </h4><br><p>  Download the packages required for compilation (build dependencies). </p><br><pre> <code class="bash hljs">sudo apt-get build-dep sudo apt-get ccache fakeroot kernel-package libncurses5-dev</code> </pre> <br><p>  Make sure that scripts have the right to execute, start cleaning. </p><br><pre> <code class="bash hljs">chmod a+x debian/rules chmod a+x debian/scripts/* chmod a+x debian/scripts/misc/* fakeroot debian/rules clean</code> </pre> <br><p>  Copy the old configuration file to the current directory, run the configuration, select <em>Load</em> and load the <em>config</em> .  There is no need to change anything else, exit and save the configuration - <em>Exit ‚Üí Yes</em> . </p><br><pre> <code class="bash hljs">cp /boot/config-4.4.0-34-generic config fakeroot debian/rules editconfigs</code> </pre> <br><p>  Modify the <em>kernel / power / hibernate.c</em> file to remove the <em>secure_modules ()</em> check. </p><br><pre> <code class="bash hljs">--- a/kernel/power/hibernate.c +++ b/kernel/power/hibernate.c @@ -67,7 +67,7 @@ static const struct platform_hibernation_ops *hibernation_ops; bool hibernation_available(void) { - <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> ((nohibernate == 0) &amp;&amp; !secure_modules()); + <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> (nohibernate == 0); } /** --</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">If you use git</b> <div class="spoiler_text"><p>  Prepare the file for commit. </p><br><pre> <code class="bash hljs">git add kernel/power/hibernate.c</code> </pre> <br><p>  If you have not made commits and have not entered your data, do it now. </p><br><pre> <code class="bash hljs">git config --global user.email <span class="hljs-string"><span class="hljs-string">"you@example.com"</span></span> git config --global user.name <span class="hljs-string"><span class="hljs-string">"Your Name"</span></span></code> </pre> <br><p>  Make a commit, enter a comment. </p><br><pre> <code class="bash hljs">$ git commit ... Allow hibernation on Secure Boot</code> </pre> <br><p>  Now your changes are saved in a new snapshot.  If you want to upgrade to the next version and apply the same changes to it, use <code>git rebase &lt;  &gt;</code> </p><br><pre> <code class="bash hljs">$ git rebase Ubuntu-4.4.0-35.54     ,      ‚Ä¶ : Allow hibernation on Secure Boot</code> </pre> </div></div><br><p>  Compilation scripts determine the kernel version of the last entry in the change history (changelog) in the <em>debian.master</em> directory.  Add a new entry to change the version. </p><br><pre> <code class="bash hljs">EDITOR=nano debchange -c debian.master/changelog -l <span class="hljs-string"><span class="hljs-string">"custom"</span></span></code> </pre> <br><p>  The <em>custom1</em> suffix will be added to the <em>version</em> , which will be reflected when building <em>.deb</em> packages and will allow installing them if packages of the same version are already installed without a suffix.  However, this suffix applies only to the package name, but not to its contents: the kernel and the directory with its modules will have the same version <em>4.4.0-34-generic</em> , and during installation, the old files will be overwritten with new ones.  To avoid this, change the version of the <a href="https://wiki.ubuntu.com/KernelTeam/KernelMaintenance">ABI</a> c 34 to, for example, 3400. </p><br><pre> <code class="bash hljs">linux (4.4.0-3400.53custom1) UNRELEASED; urgency=medium * Allow hibernation on Secure Boot ...</code> </pre> <br><h4 id="kompilyaciya">  Compilation </h4><br><p>  Run the cleaning again and compile the kernel.  If you are not an experienced kernel developer and do not understand how ABI checks and modules work (I don‚Äôt understand), disable them (skipabi = true, skipmodule = true), otherwise your compilation will break at one of the last stages.  It uses multi-threaded packet building with the number of threads equal to the number of processor cores.  The goal of <em>binary-generic</em> means to compile the usual kind of kernel, the architecture is determined automatically. </p><br><pre> <code class="bash hljs">fakeroot debian/rules clean skipabi=<span class="hljs-literal"><span class="hljs-literal">true</span></span> skipmodule=<span class="hljs-literal"><span class="hljs-literal">true</span></span> DEB_BUILD_OPTIONS=parallel=$(getconf _NPROCESSORS_ONLN) do_tools=<span class="hljs-literal"><span class="hljs-literal">false</span></span> no_dumpfile=1 \ fakeroot debian\rules binary-generic</code> </pre> <br><p>  If the compilation was successful, three <em>.deb</em> packages will appear in your home directory.  You must install <em>linux-image- &lt;version&gt; .deb</em> , and also preferably <em>linux-image-extra- &lt;version&gt; .deb</em> .  This can be done using <code>dpkg -i &lt;  &gt;</code> or via <em>QApt</em> by opening the package in the file manager, if it supports it.  Be careful: if you have not changed the ABI version, the old kernel and modules will be overwritten. </p><br><p>  Reassemble the boot file. </p><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> -n <span class="hljs-string"><span class="hljs-string">"quiet splash"</span></span> &gt; /tmp/cmdline objcopy \ --add-section .osrel=/etc/os-release --change-section-vma .osrel=0x20000 \ --add-section .cmdline=/tmp/cmdline --change-section-vma .cmdline=0x30000 \ --add-section .linux=/boot/vmlinuz-4.4.0-34-generic --change-section-vma .linux=0x2000000 \ --add-section .initrd=/boot/initrd.img-4.4.0-34-generic --change-section-vma .initrd=0x3000000 \ /usr/lib/systemd/boot/efi/linuxx64.efi.stub /tmp/test.efi sbsign --key /root/keys/my.key --cert /root/keys/my.pem --output /boot/efi/EFI/BOOT/BOOTX64.EFI /tmp/test.efi</code> </pre> </div></div><br><img src="https://habrastorage.org/files/e7d/cbe/387/e7dcbe38791b46d68c46d668b2b166de.png" align="left"><br><p>  ,  . , ,   Secure Boot. <br><br clear="left"></p><br><h4 id="sposob-4-otkaz-ot-gibernacii-i-ispolzovanie-virtualizacii">  4.       </h4><br><p>    ,         .      ,  ,   , KDE Plasma,    Kubuntu   . </p><br><p>             Linux,   ‚Äî   .          ,    .     .      ,     <code>Qemu KVM</code> .       . </p><br><p>       :       .           ,    ‚Äî  .  -           . ,    Qubes OS.       Secure Boot. Fail. </p><br><p>   ,     . </p><br><h3 id="primechaniya">  Notes </h3><br><ol><li><p>  <a href="https://habr.com/ru/post/308032/">‚Üë</a> <a name="note1"></a>     GRUB      <code>grub-mkstandalone</code> ,     . </p><br></li><li><p>  <a href="https://habr.com/ru/post/308032/">‚Üë</a> <a name="note2"></a>   , <a href="https://help.ubuntu.com/community/Grub2/Passwords"> </a> ,  grub.cfg   GRUB   <code>grub-mkstandalone</code>    grub.cfg prefix   ,  GRUB     grub.cfg  .       . </p><br></li><li><p>  <a href="https://habr.com/ru/post/308032/">‚Üë</a> <a name="note3"></a>       <del>  </del>     . </p><br></li><li><p>  <a href="https://habr.com/ru/post/308032/">‚Üë</a> <a name="note4"></a>     USB  . Windows 8  10          . </p><br></li><li><p>  <a href="https://habr.com/ru/post/308032/">‚Üë</a> <a name="note5"></a> ,    .    ESP   . </p><br></li></ol></div><p>Source: <a href="https://habr.com/ru/post/308032/">https://habr.com/ru/post/308032/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../308020/index.html">Introducing the new UWP Community Toolkit</a></li>
<li><a href="../308024/index.html">The effectiveness of the implementation of information systems. Practice experience</a></li>
<li><a href="../308026/index.html">Introducing RAIL: Site Performance Assessment Model</a></li>
<li><a href="../308028/index.html">0day vulnerabilities in lshell</a></li>
<li><a href="../308030/index.html">A critical vulnerability has been discovered in the encryption library Libgcrypt for 18 years.</a></li>
<li><a href="../308034/index.html">Three-position checkbox (aka tristate) without scripts and SMS</a></li>
<li><a href="../308036/index.html">Multiprotocol bot via Microsoft Bot Connector REST API v3.0</a></li>
<li><a href="../308038/index.html">Flash revolution</a></li>
<li><a href="../308040/index.html">Friendly introduction to Dagger 2. Part 2</a></li>
<li><a href="../308042/index.html">We found 10,000 bugs in various open source projects.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>