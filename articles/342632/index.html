<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Optimize the speed of rendering web pages</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Often, stories about how web developers take care of their applications start with the site rendering process, drop to the DOM level, and stop at stat...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Optimize the speed of rendering web pages</h1><div class="post__text post__text-html js-mediator-article">  Often, stories about how web developers take care of their applications start with the site rendering process, drop to the DOM level, and stop at statements like: "And this is fast because acceleration is used."  Martin Splitt talks about bottom-up performance: he starts at a pixel and rises level after level, ending with the page layout. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/A16g16bTtjA" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i>The article is based on Martin's speech at the JavaScript conference of HolyJS 2017 in St. Petersburg, where he talks about how visualization takes place in browsers and what you need to do in order for your websites to ‚Äúfly‚Äù.</i> <br><a name="habracut"></a><br>  <i><b>About speaker</b></i> <i><br></i>  <i>Martin is the head of the Archilogic engineering department.</i>  <i>This is a small company that develops a web service of the same name that allows users to create virtual 3D tours in browsers on desktops and mobile devices.</i> <br><br><h2>  How does the site load from the network </h2><br>  Today we will talk about how to convert text into something visual.  We start with markup and finish with pixels.  How it works? 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/getpro/habr/post_images/c44/61f/9d2/c4461f9d2a1969139598a4c91b4573ef.png"><br><br>  The first thing you need to know about performance optimization is how the site loads. <br><br><ol><li>  HTML retrieved from web </li><li>  HTML text is parsed to tokens as they arrive. </li><li>  Tokens are object based (DOM / CSSOM) </li><li>  Objects are located on the page. </li><li>  Objects are drawn and assembled as a whole. </li><li>  Js or css can change content </li></ol><br>  So, at the first stage there is a request to the server, from where it is necessary to obtain text data (HTML, CSS, JavaScript).  Having received the text, we must mark it, that is, break it into elements and tags in order to work with it further. <br><br>  When you deal with JavaScript, you need to get it all before you start working with the code.  HTML has a tree structure, so you can start the analysis by getting one of the elements.  Since the analysis is performed as you receive HTML data, it is called streaming. <br><br>  When we have enough tokens, we begin to analyze them and create objects from them.  Objects have a tree structure (for example, the document has a title, below it is text, an image, etc.).  This is done not only for HTML, but also for CSS, so we have two trees - DOM and CSSOM. <br><br>  After the tags have been analyzed and the objects have been received, we already know the sizes of these objects and can place them on the page.  This stage is called layout. <br><br>  When the page layout is created, it is necessary to make the objects visible.  And the drawn objects are arranged to make a page.  Once this process is complete, you can use JavaScript and CSS to make the pages dynamic. <br><br>  Now we will dwell on these stages in more detail. <br><br><h2>  How is the analysis of the site page </h2><br>  The analysis begins with the receipt of completed elements - like this: <br><br><pre><code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">h1</span></span></span><span class="hljs-tag">&gt;</span></span>Hello HolyJS!<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">h1</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  This is a complete element, so the browser decomposes it into a header element and a text node inside it. <br><br><pre> <code class="css hljs">&lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">p</span></span>&gt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">Lorem</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">ipsum</span></span>‚Ä¶&lt;/<span class="hljs-selector-tag"><span class="hljs-selector-tag">p</span></span>&gt;</code> </pre><br>  Then the browser can see a paragraph element with a text node inside. <br><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">img‚Ä¶</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  And another paragraph with the image, etc. <br><br>  In the end, the browser says: ‚ÄúOk, I have elements, I can build a tree.‚Äù  It takes the body of the page, adds a title, text nodes, paragraphs, images, etc.  He does this as new data is received. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b7e/33a/1f2/b7e33a1f2d5427f23b999ec46980f94c.png"><br><br>  This is what it looks like for style sheets.  Here we see the external table and inline styles: <br><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">link</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">rel</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"stylesheet"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">href</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"style.css"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">style</span></span></span><span class="hljs-tag">&gt;</span></span><span class="css"><span class="css">   </span><span class="hljs-selector-tag"><span class="css"><span class="hljs-selector-tag">body</span></span></span><span class="css"> { </span><span class="hljs-attribute"><span class="css"><span class="hljs-attribute">color</span></span></span><span class="css">: red; }  </span><span class="hljs-selector-tag"><span class="css"><span class="hljs-selector-tag">h1</span></span></span><span class="css">   { </span><span class="hljs-attribute"><span class="css"><span class="hljs-attribute">color</span></span></span><span class="css">: blue; } </span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">style</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">style</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"color: green"</span></span></span><span class="hljs-tag">&gt;</span></span>... <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  The problem with the external table is that we need to load it before doing something further.  When the download is complete, we move on, see that the body of the page should be red, and color our tree. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7da/be1/8d2/7dabe18d2fe832728054d92f2e581ac2.png"><br><br>  Then we go to the next element and see that the title should be blue and the paragraph should be green.  So we build the object model of the stylesheet. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f90/746/6a4/f907466a4429db71215f84225a486e8d.png"><br><br>  But we do not visualize it.  When you open a site, it looks wrong.  Here are some things to keep in mind to improve the rendering speed during the site analysis phase: <br><br><ul><li>  Use inline-styles for important CSS rules (color, position on the page, etc.) so that external CSS does not slow down the construction of the tree. <br></li><li>  When analyzing, pay attention to the order in which you receive the original HTML data. <br></li><li>  Minimize repetition when building a tree. <br></li><li>  Use server side rendering. <br></li></ul><br>  Another moment.  When analyzing animations and tables on how fast they are visualized, you can hardly catch all the problems in automatic mode, you always have to manually test.  I know that the Chrome and Firefox developers are already working on improving performance measurement tools.  Among them, animation inspectors who report how often it is rendered, new JavaScript API, measurement of build time.  By the way, now you can estimate the rendering time.  We ourselves use this opportunity, assessing how quickly the scene is visualized.  If this happens too slowly, we turn off some things and test again. <br><br><h2>  The location of objects on the page </h2><br>  Now consider how the layout.  For example, we have a class with some text. <br><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"box"</span></span></span><span class="hljs-tag">&gt;</span></span> Hello world <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  The browser has a rectangle with the text on the entire width of the page. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4d1/9cd/e1d/4d19cde1dda5d269e75ba14b848b8f60.png"><br><br>  Then there is some image <br><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"box"</span></span></span><span class="hljs-tag">&gt;</span></span> Hello world <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">b</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">img</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"yay.png"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">b</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  It is located below, because the rectangle with the text occupied the entire width of the page. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/cb6/313/bdb/cb6313bdbf12b5355d3c02640b61290e.png"><br><br>  Now CSS is added to this: <br><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">style</span></span></span><span class="hljs-tag">&gt;</span></span><span class="css"><span class="css"> </span><span class="hljs-selector-class"><span class="css"><span class="hljs-selector-class">.box</span></span></span><span class="css"> {  </span><span class="hljs-attribute"><span class="css"><span class="hljs-attribute">display</span></span></span><span class="css">: inline-block;  </span><span class="hljs-attribute"><span class="css"><span class="hljs-attribute">width</span></span></span><span class="css">: </span><span class="hljs-number"><span class="css"><span class="hljs-number">50%</span></span></span><span class="css">; } </span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">style</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  And it turns out that the rectangle is an inline-block, which should occupy only half the width of the page.  And if so, then the image appears above the place, so we transfer it there. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3a1/b55/4ac/3a1b554acfe6bee71d5fb5d420ccc9f6.png"><br><br>  This is how layout works in a browser. <br><br>  Here are some things that affect the speed of visualization, it is worth remembering at the stage of layout of the site: <br><br><ul><li>  It is important to understand how the page will look at the layout level, not the content (where the blocks are located and what size they are). <br></li><li>  The layout is based on CSSOM + DOM, that is, if you have made important changes in JavaScript, you need to redo the layout. <br></li><li>  Layout determines the actual size of each element (when resizing elements, you need to re-do the layout). <br></li><li>  Layout can affect performance, so try to avoid changes in layout. <br></li><li>  Changes in the layout can lead to re-drawing of elements, which also affects performance (for example, when resizing an image, it is necessary to draw it on a new one). <br></li><li>  With animation, the layout can ‚Äúfly off‚Äù. <br></li></ul><br><h2>  Drawing objects </h2><br>  To understand what is happening at this stage, remember what a pixel is.  This is the smallest logical element of a two-dimensional digital image, consisting of three colors (green, red and blue), which differ in brightness.  For each pixel, there are three numeric values ‚Äã‚Äãthat determine how bright the green, blue, and red will be. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e83/126/29e/e8312629ed78059560a98cca1c888b83.png"><br><br>  Therefore, drawing and rendering is in the end nothing but getting a list of numbers and writing them.  It is very good that these numbers do not affect each other: we have three numbers for the first pixel, three for the second, etc.  Therefore, if there is a need to make changes to some pixels, it will not entail a change in something else, there are no dependencies between the numbers.  Also thanks to this we can write them in parallel, copy large volumes of numbers, etc. <br><br>  Here are some things to keep in mind with respect to rendering: <br><br><ul><li>  It does not occur consistently. <br></li><li>  This can affect performance (remember that the resolution of Full HD is 1920 √ó 1080, which is about two million pixels). <br></li><li>  At the same time, memory is used (even for an image with a resolution of 500x500 pixels, each of which has a volume of 3 bytes, 750 kilobytes of memory are needed). <br></li></ul><br>  Since writing such a quantity of data is not rational, the layout is used.  Instead of rewriting the pixel values ‚Äã‚Äãeach time, it‚Äôs enough to draw them once, keep them in memory and copy them from memory each time to speed up the process.  Thus, if we have a background image and a picture with a cat in our memory, we can reuse them by placing the cat layer on top of the background in the right place. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ff9/08c/578/ff908c578651cca103ef2c2ee5b5ee43.png"><br><br>  We do not redraw all these pixels, we just change the numbers a little, getting, for example, an animation of a cat flying around the screen. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/69a/61c/cfe/69a61ccfeda7b43c26024fb2a996ba69.png"><br><br>  You can compose these images using blending - changing blending modes.  In the blending process, a shader is applied to the two original layers - a function that shows how the layers should be mixed.  Here is what it might look like in pseudocode: <br><br><pre> <code class="hljs pgsql">const shader = (x, y, layers, blend, <span class="hljs-keyword"><span class="hljs-keyword">filter</span></span>) =&gt; {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">filter</span></span>(      blend(x, y, layers) // <span class="hljs-keyword"><span class="hljs-keyword">returns</span></span> colour  ) // <span class="hljs-keyword"><span class="hljs-keyword">returns</span></span> final colour }</code> </pre><br>  In other words, for a specific pixel, the values ‚Äã‚Äãof all layers are taken and combined in a certain way.  There are 15 blending modes (multiply, screen, and others), each of which is essentially a formula by which colors are combined.  For example, when using Multiply mode, the values ‚Äã‚Äãare multiplied: <br><br><pre> <code class="hljs lisp">color(<span class="hljs-name"><span class="hljs-name">x</span></span>,y) = cat(<span class="hljs-name"><span class="hljs-name">x</span></span>,y) * sky(<span class="hljs-name"><span class="hljs-name">x</span></span>,y)</code> </pre><br>  In this case, we get here such a cat: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7eb/995/0bb/7eb9950bb81035db1f12433d694d8bb1.png"><br><br>  After getting the mixed color, we can run another function - the filter.  Examples of filters are opacity, contrast, color inversion, sepia, saturation, shadow casting, conversion to shades of gray, etc. For example, when using the Grayscale filter, the numerical values ‚Äã‚Äãfor the resulting color are added and then divided into three: <br><br><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">r</span></span>, g, b) =&gt; (<span class="hljs-name"><span class="hljs-name">r</span></span> + g + b) / <span class="hljs-number"><span class="hljs-number">3</span></span></code> </pre><br>  Thus, if the pixel colors were bright enough, when converting to shades of gray, we also get a bright image, and if they were faded - dark. <br><br>  And this is how the Grayscale function actually looks like: <br><br><pre> <code class="hljs mel">varying highp vec2 coord; <span class="hljs-keyword"><span class="hljs-keyword">uniform</span></span> sampler2D layer; void main(void) {  vec4 <span class="hljs-keyword"><span class="hljs-keyword">color</span></span> = texture2D(layer, vec2(coord.s, coord.t));  <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> grayScale = (<span class="hljs-keyword"><span class="hljs-keyword">color</span></span>.r + <span class="hljs-keyword"><span class="hljs-keyword">color</span></span>.g + <span class="hljs-keyword"><span class="hljs-keyword">color</span></span>.b) / <span class="hljs-number"><span class="hljs-number">3.0</span></span>; gl_FragColor = vec4(grayScale, grayScale, grayScale, <span class="hljs-number"><span class="hljs-number">1.0</span></span>); }</code> </pre><br>  It is important that when using blending modes and filters, different browsers behave differently.  Chrome is the only browser that redesigned the architecture so that visualization occurs only using layers.  The rest of the browsers work roughly the same with CSS filters, but SVG filters for some reason I do not draw again.  This happens in most browsers: Firefox, Safari, Internet Explorer, Edge. <br><br>  So, what gives the layout: <br><br><ul><li>  Allows you to store different elements of the site in the form of layers in memory and arrange them as needed. <br></li><li>  Accelerates site loading due to the fact that copying operations from memory occur very quickly. <br></li><li>  Allows you to make some changes without re-drawing, using blending modes and filters. <br></li><li>  Allows you to move data to another position, perform scaling and rotation. <br></li></ul><br>  However, it is worth remembering that each layer must be kept in memory, so you can not make many layers (otherwise mobile users will quickly face a memory shortage error).  It is worth using layers only where they are needed, namely: <br><br><ul><li>  video, canvas - for video and games that contain a large number of changing frames; <br></li><li>  3D transformations; <br></li><li>  composite animations (where moving, rotating, scaling data are involved); <br></li><li>  The new property will-change, with which you can specify what exactly you plan to change many times. <br></li></ul><br>  The will-change property is a hint for the browser, and the more hints, the better the rendering will be.  That is, if you tell the browser: ‚ÄúI have this Canvas, and I'm going to change its location or size,‚Äù then most likely the browser will be able to process the page faster. <br><br><h2>  Let's play: practical examples </h2><br>  I propose now to play the game and check how you understand all of the above. <br>  The code below moves the element 150 pixels to one side and then returns to its original position after 2 seconds.  Answer the question whether this animation will be drawn, and then check the answer below. <br><br><pre> <code class="hljs smalltalk"><span class="hljs-symbol"><span class="hljs-symbol">#transform</span></span> {  transform: translateX(<span class="hljs-number"><span class="hljs-number">150</span></span>px); } setTimeout(() =&gt; {  el.style.transform = <span class="hljs-string"><span class="hljs-string">'translateX(0)'</span></span> }, <span class="hljs-number"><span class="hljs-number">2000</span></span>)</code> </pre><br>  Yes, it will, because this is a 2D transformation.  No layers are used here, and the pixels will be redrawn. <br><br>  Now the second round of the game, with a different code.  He does the same thing, but with a different movement.  Will this animation be drawn? <br><br><pre> <code class="hljs smalltalk"><span class="hljs-symbol"><span class="hljs-symbol">#transform</span></span> { transform: translate3d(<span class="hljs-number"><span class="hljs-number">150</span></span>px, <span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>); } setTimeout(() =&gt; {   el.style.transform = <span class="hljs-string"><span class="hljs-string">'translate3d(0, 0, 0)'</span></span> }, <span class="hljs-number"><span class="hljs-number">2000</span></span>)</code> </pre><br>  No, because 3D transformations are used here, which means layers. <br><br>  Finally, the third round.  What is it? <br><br><pre> <code class="css hljs">@<span class="hljs-keyword"><span class="hljs-keyword">keyframes</span></span> move {    0% { <span class="hljs-attribute"><span class="hljs-attribute">left</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>; }   100% { <span class="hljs-attribute"><span class="hljs-attribute">left</span></span>: <span class="hljs-number"><span class="hljs-number">200px</span></span>; } }</code> </pre><br>  This is something that should not be done in any way.  But I can change the rules of the game using the will-change property here.  Now we have a two-second animation, and it can shift to the left.  Do you think it is possible to use such a code? <br><br><pre> <code class="hljs css"><span class="hljs-selector-id"><span class="hljs-selector-id">#transform</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">will-change</span></span>: left; <span class="hljs-attribute"><span class="hljs-attribute">animation</span></span>: move <span class="hljs-number"><span class="hljs-number">2s</span></span> infinite; }</code> </pre><br>  It is possible, but only if the element does not depend on others in the layout (for example, the position of the element is absolute).  If its position is relative, then when its position changes, other elements on the page will shift. <br><br>  So, this is what you need to remember about layers and layouts: <br><br><ul><li>  It is worth avoiding the re-layout and rendering - it reduces performance.  Layers can be useful, but be careful.  Do not create them if you are not sure if they are necessary in order not to use too much memory. <br></li><li>  Measure first, then optimize.  Test your animations using the developer console in the browser, watch how often the elements are drawn, measure the memory usage. <br></li><li>  Try to use the layout wherever possible (enable the property will-change, 3D-transformation, etc.) <br></li></ul><br>  A quote from Paul Lewis would be appropriate here: ‚ÄúProductivity is the art of avoiding work.‚Äù  Always remember that when it comes to performance, the best thing you can do is do less. <br><br><h2>  Canvas 2D and WebGL performance comparison </h2><br>  Let's talk a little more about when to use Canvas 2D, and when to use WebGL. <br><br>  Here is a simple example of using Canvas 2D.  Suppose the size of our canvas is equal to the size of an HD frame.  We have many objects in different places, make them of arbitrary size and then draw an image several times in different places and with different sizes.  It's not that hard: <br><br><pre> <code class="hljs matlab"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(var <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>=<span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>&lt;NUM_OBJECTS; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>++) {  var x = Math.random() * HD_WIDTH,      y = Math.random() * HD_HEIGHT,     <span class="hljs-built_in"><span class="hljs-built_in">size</span></span> = Math.random() * <span class="hljs-number"><span class="hljs-number">512</span></span> ctx.drawImage(img, x - HALF_SIZE, y - HALF_SIZE, <span class="hljs-built_in"><span class="hljs-built_in">size</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">size</span></span> ) }</code> </pre><br>  On the Y axis, we can see the number of frames per second, and on the X axis, the number of objects we are going to make.  That is, the same object is drawn once, one hundred, two hundred fifty, five hundred and a thousand times. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c49/a6d/0c6/c49a6d0c6d39f3397ce91dd6b5520945.png"><br><br>  Anything higher than the green line means super smooth rendering with a frame rate of more than 60 per second.  The orange line shows how many frames the drawing still takes place smoothly, though not as fast as we would like.  Red is a line behind which drawing is performed with jerks, in the mode of such a slide show (instead of smooth animation).  As we can see, if the number of objects is 250, then the number of frames per second is significantly below the allowable one. <br><br>  On the other hand, as can be seen in the graph below, when using WebGL, the same number of objects does not affect the number of frames per second. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/edb/777/6a4/edb7776a488ecae621f3ea31a48dbb20.png"><br><br>  Then they may ask me: ‚ÄúWhat if we use hardware acceleration?‚Äù As can be seen from the test result below, when rendering 10,000 WebGL objects, it gives at least 20 frames per second.  This is not very cool, but in principle permissible.  But with 2D Canvas, we get only 7 frames per second.  And with 50,000 objects, the visualization will be very slow in both cases, but WebGL will give a slideshow, the speed of which is still twice as high. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3a6/23c/500/3a623c500f2c4a8476e08a5c3ba48d04.png"><br>  That is why you should use WebGL not only for 3D, but also for 2D content, too. <br><br>  However, do not think that you need to do EVERYTHING using WebGL, because it is fast.  I always say this is a bad idea.  You need to use the right tools, and not reinvent technology from scratch, as it happens if you start doing absolutely everything with WebGL. <br><br>  Just remember what to use and when.  And always try to make sure that you choose the right tool. <br><br>  HTML + CSS is used to create: <br><br><ul><li>  Semantic and accessible content <br></li><li>  Graphic primitives <br></li></ul><br>  SVG is used for: <br><br><ul><li>  Images that scale well <br></li></ul><br>  Canvas 2D is convenient for creating: <br><br><ul><li>  Simple 2D animations <br></li></ul><br>  WebGL should be used for: <br><br><ul><li>  3D content and any games <br></li></ul><br>  I think that someday web animations will be able to play as fast as flash-animations used to be.  Browser rendering engines are constantly improving.  If you take the browser engine of 2010 and compare it with the modern one, you will see a big difference.  Yes, of course, the engines are not perfect yet.  The main problem of modern browsers is that they were created for less dynamic pages; now they must constantly adapt to interactive graphic applications. <br><br>  Perhaps one of the best examples of what we will see in the near future is the experimental Servo engine from Mozilla.  It uses hardware acceleration wherever possible, so where in other browsers visualization occurs at 60 frames per second, in Servo you get 120 FPS. <br><br><hr><br>  Those who are close to the topic of application performance will surely like the new report by Martin <a href="https://holyjs-moscow.ru/talks/6f57ymvefsmu0cweciwc4a/">Better, faster, stronger - getting more from the web platform</a> , which he will deliver at <a href="https://holyjs-moscow.ru/">HolyJS</a> in Moscow. <br><br>  You may also be interested in other reports, for example: <br><br><ul><li>  <a href="https://holyjs-moscow.ru/talks/3hmyldgekuymaycqcykq60/">Faster Angular applications</a> (Minco Gechev) <br></li><li>  <a href="https://holyjs-moscow.ru/talks/1xsrhlexdq0u6koqscsgmc/">New Adventures in Responsive Web Design</a> (Vitaly Friedman) <br></li><li>  <a href="https://holyjs-moscow.ru/talks/5urrpcyfbayw6es6ymyeqo/">Dirty animations in the world of states</a> (Alexey Taktarov) <br></li></ul><br>  The entire conference program is available on the <a href="https://holyjs-moscow.ru/">website</a> , tickets can be purchased <a href="https://holyjs-moscow.ru/tickets/">here</a> . </div><p>Source: <a href="https://habr.com/ru/post/342632/">https://habr.com/ru/post/342632/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../342618/index.html">Computer vision, cloud development and competition</a></li>
<li><a href="../342620/index.html">Hello Logify, or monitor errors on installed applications</a></li>
<li><a href="../342624/index.html">About PVS-Studio on the eve of the open conference of the ISP RAS. V.P. Ivannikova</a></li>
<li><a href="../342626/index.html">Results hackathon HR-hack</a></li>
<li><a href="../342628/index.html">Tutu.ru: How to spend the IT Day on their own and inexpensively</a></li>
<li><a href="../342634/index.html">Take care of revision: code analysis automation techniques</a></li>
<li><a href="../342636/index.html">From Kotlin to whip: how did Mobius 2017 Moscow go</a></li>
<li><a href="../342638/index.html">How we created a new type of tariff "Turn on"</a></li>
<li><a href="../342640/index.html">Configuring Minio and Nginx for the RoR application</a></li>
<li><a href="../342644/index.html">Gorgeous assholes in the making</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>