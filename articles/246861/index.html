<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Embedding electronic signatures in systems with a WEB interface using a browser plugin and openssl</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A few years ago, our company launched the product Rutoken Plugin , which is designed to embed electronic signatures in systems with a web interface. B...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Embedding electronic signatures in systems with a WEB interface using a browser plugin and openssl</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/fe6/ac6/b87/fe6ac6b878504ec5ac7aca2a9bdf73b4.jpg"><br><br>  A few years ago, our company launched the product <a href="http://www.rutoken.ru/products/all/rutoken-plugin/">Rutoken Plugin</a> , which is designed to embed electronic signatures in systems with a web interface.  Based on the experience gained in integrating the product into real projects, I would like to note that developers often use the openssl supporting Russian cryptoalgorithms to implement the server part. <br><br>  This article will describe the typical scheme for such integration, based on the following use cases for the plugin: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  Registration on the portal (with the issuance of a certificate or by existing certificate) </li><li>  Strong portal authentication </li><li>  Electronic signature of data and / or files in CMS format </li><li>  Encryption of data and / or files in CMS format </li></ul><br><br>  These scripts involve client-server interaction, writing client-side scripts in JavaScript and their corresponding openssl server calls. <br><br>  Details under the cut. <br><a name="habracut"></a><br><br><h2>  General operations </h2><br><h3>  Device operations </h3><br><h4>  Search for connected devices </h4><br>  Any client script begins with a search for Rutoken USB devices connected to the computer.  In the context of this article, the focus is on the device Rutoken EDS. <br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> devices = <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { devices = plugin.enumerateDevices(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (error) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(error); }</code> </pre> <br><br>  This returns a list of identifiers of the connected devices.  The identifier is the number associated with the slot number to which the device is connected.  When re-listing this number may be different for the same device. <br><br>  Rutoken Plug-in detects all USB-connected devices Rutoken EDS, Rutoken PINPad, Rutoken WEB.  Therefore, the next step is to determine the type of device. <br><br><h4>  Getting device information </h4><br>  To determine the type of device, use the <a href="http://dev.rutoken.ru/pages/viewpage.action%3FpageId%3D3801092">getDeviceInfo</a> function with the TOKEN_INFO_DEVICE_TYPE parameter.  The value of this constant is contained in the plug-in object. <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> type; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { type = plugin.getDeviceInfo(deviceId, plugin.TOKEN_INFO_DEVICE_TYPE); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (error) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(error); } <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (type) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> plugin.TOKEN_TYPE_UNKNOWN: message = <span class="hljs-string"><span class="hljs-string">" "</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> plugin.TOKEN_TYPE_RUTOKEN_ECP: message = <span class="hljs-string"><span class="hljs-string">" "</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> plugin.TOKEN_TYPE_RUTOKEN_WEB: message = <span class="hljs-string"><span class="hljs-string">" Web"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> plugin.TOKEN_TYPE_RUTOKEN_PINPAD_2: message = <span class="hljs-string"><span class="hljs-string">" PINPad"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; }</code> </pre><br><br>  Also, using the <a href="http://dev.rutoken.ru/pages/viewpage.action%3FpageId%3D3801092">getDeviceInfo</a> function, <a href="http://dev.rutoken.ru/pages/viewpage.action%3FpageId%3D3801092">you</a> can get: <br><ul><li>  device model </li><li>  device label </li><li>  device serial number </li><li>  information about whether the user is logged in to the device </li></ul><br><br><h4>  PIN change </h4><br>  Example of changing the PIN-code on the device: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> options = {}; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { plugin.changePin(deviceId, <span class="hljs-string"><span class="hljs-string">"12345678"</span></span>, <span class="hljs-string"><span class="hljs-string">"12345671"</span></span>, options); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (error) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(error); }</code> </pre><br><br>  Here, the first parameter is the old PIN, and the second is the new PIN. <br><br><h3>  Work with certificates </h3><br>  1. On the token 3 categories of certificates can be stored: <br><br><ul><li>  custom (constant in plugin CERT_CATEGORY_USER) <br>  These are certificates associated with the user's private key.  Used, for example, for signing CMS / PKCS # 7, user authentication in the TLS protocol. <br>  If the certificate is imported as a user, then the import will search the device for the corresponding private key.  If such a key is found, the certificate will be ‚Äútied‚Äù to this key.  If the key is not found, an error will be returned. <br></li><li>  root (constant in plugin CERT_CATEGORY_CA) <br>  These are certificates issued by certificates issued to verify the signature on certificates.  This verification of the signature (building a chain of trust) allows you to determine whether the user trusts the signature of another user.  For example, in the <a href="http://dev.rutoken.ru/pages/viewpage.action%3FpageId%3D3801092">verify</a> plugin <a href="http://dev.rutoken.ru/pages/viewpage.action%3FpageId%3D3801092">function,</a> there is a certificate verification mode on which the message was signed.  This uses the root certificate store on the token created by importing the root certificates to the token. <br></li><li>  others (constant in plugin CERT_CATEGORY_OTHER) <br>  These are certificates that are not associated with a private key and are not root. <br></li></ul><br><br>  2. To read certificates stored on the device, no authorization is required on the device. <br><br>  Example of reading user certificates from the device: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> certs = <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { certs = plugin.enumerateCertificates(deviceId, plugin.CERT_CATEGORY_USER); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (error) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(error); }</code> </pre><br><br>  3. The certificate can be exported in PEM format: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> certpem; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { certpem = plugin.getCertificate(deviceId, certId); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (error) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(error); }</code> </pre><br><br>  It turns out like this: <br><pre> <code class="hljs ruby">-----<span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> CERTIFICATE----- MIIBmjCCAUegAwIBAgIBATAKBgYqhQMCAgMFADBUMQswCQYDVQQGEwJSVTEPMA0G A1UEBxMGTW9zY293MSIwIAYDVQQKFBlPT08gIkdhcmFudC1QYXJrLVRlbGVjb20i MRAwDgYDVQQDEwdUZXN0IENBMB4XDTE0MTIyMjE2NTEyNVoXDTE1MTIyMjE2NTEy NVowEDEOMAwGA1UEAxMFZmZmZmYwYzAcBgYqhQMCAhMwEgYHKoUDAgIjAQYHKoUD AgIeAQNDAARADKA/O1Zw50PzMpcNkWnW39mAJcTehAhkQ2Vg7bHkIwIdf7zPe2Px HyAr6lH+stqdACK6sFYmkZ58cBjzL0WBwaNEMEIwJQYDVR0lBB4wHAYIKwYBBQUH AwIGCCsGAQUFBwMEBgYpAQEBAQIwCwYDVR0PBAQDAgKkMAwGA1UdEwEB/wQCMAAw CgYGKoUDAgIDBQADQQD5TY55KbwADGKJRK+bwCGZw24sdIyayIX5dn9hrKkNrZsW detWY3KJFylSulykS/dfJ871IT+<span class="hljs-number"><span class="hljs-number">8</span></span>dXPU5A7WqG4+ -----<span class="hljs-keyword"><span class="hljs-keyword">END</span></span> CERTIFICATE-----</code> </pre><br><br>  4. The certificate can be parsed by calling the function <a href="http://dev.rutoken.ru/pages/viewpage.action%3FpageId%3D3801092">parseCertificate</a> and obtaining from it DN Subject, DN Issuer, extensions, public key value, signature, serial number, expiration date, etc. <br><br>  5. The certificate can be written to the device. <br><br>  Example of writing a certificate to a device as a user: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> certpem = <span class="hljs-string"><span class="hljs-string">"-----BEGIN CERTIFICATE----- MIIBmjCCAUegAwIBAgIBATAKBgYqhQMCAgMFADBUMQswCQYDVQQGEwJSVTEPMA0G A1UEBxMGTW9zY293MSIwIAYDVQQKFBlPT08gIkdhcmFudC1QYXJrLVRlbGVjb20i MRAwDgYDVQQDEwdUZXN0IENBMB4XDTE0MTIyMjE2NTEyNVoXDTE1MTIyMjE2NTEy NVowEDEOMAwGA1UEAxMFZmZmZmYwYzAcBgYqhQMCAhMwEgYHKoUDAgIjAQYHKoUD AgIeAQNDAARADKA/O1Zw50PzMpcNkWnW39mAJcTehAhkQ2Vg7bHkIwIdf7zPe2Px HyAr6lH+stqdACK6sFYmkZ58cBjzL0WBwaNEMEIwJQYDVR0lBB4wHAYIKwYBBQUH AwIGCCsGAQUFBwMEBgYpAQEBAQIwCwYDVR0PBAQDAgKkMAwGA1UdEwEB/wQCMAAw CgYGKoUDAgIDBQADQQD5TY55KbwADGKJRK+bwCGZw24sdIyayIX5dn9hrKkNrZsW detWY3KJFylSulykS/dfJ871IT+8dXPU5A7WqG4+ -----END CERTIFICATE-----"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { plugin.importCertificate(deviceId, certpem, plugin.CERT_CATEGORY_USER); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (error) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(error); }</code> </pre><br><br>  6. <a href="http://dev.rutoken.ru/pages/viewpage.action%3FpageId%3D3801092">By calling the deleteCertificate</a> function, <a href="http://dev.rutoken.ru/pages/viewpage.action%3FpageId%3D3801092">you</a> can delete the certificate from the token. <br><br><h3>  Work with key pairs of GOST R 34.10-2001 </h3><br>  1. To obtain the decryptor key pairs stored on the device, you must enter a PIN code.  It should be understood that the value of the private key itself cannot be obtained, since the key is non-recoverable. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> keys = <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { plugin.login(deviceId, <span class="hljs-string"><span class="hljs-string">"12345678"</span></span>); keys = plugin.enumerateKeys(deviceId, <span class="hljs-literal"><span class="hljs-literal">null</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (error) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(error); }</code> </pre><br><br>  2. To generate a key pair, you must enter a PIN code.  When generating a key, parameters can be selected from the set: <br><ul><li>  A: id-GostR3410-2001-CryptoPro-A-ParamSet </li><li>  B: id-GostR3410-2001-CryptoPro-B-ParamSet </li><li>  C: id-GostR3410-2001-CryptoPro-C-ParamSet </li><li>  XA: id-GostR3410-2001-CryptoPro-XchA-ParamSet </li><li>  XB: id-GostR3410-2001-CryptoPro-XchB-ParamSet </li></ul><br><br>  An example of generating a key pair GOST R 34.10-2001: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> options = {}; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> keyId; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { keyId = plugin.generateKeyPair(deviceId, <span class="hljs-string"><span class="hljs-string">"A"</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span>, options); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (error) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(error); }</code> </pre><br><br>  3. Using the <a href="http://dev.rutoken.ru/pages/viewpage.action%3FpageId%3D3801092">deleteKeyPair</a> function <a href="http://dev.rutoken.ru/pages/viewpage.action%3FpageId%3D3801092">, the</a> key pair can be deleted from the token. <br><br><h3>  Configuring openssl </h3><br>  Openssl supports Russian cryptoalgorithms starting from version 1.0.  In order to use them, in openssl you need to load the engine gost.  Most openssl distributions have this library.  In order for the engine to load, you can put it in the openssl configuration file: <br><br><pre> <code class="hljs cs">[<span class="hljs-meta"><span class="hljs-meta">openssl_def</span></span>] engines = engine_section [engine_section] gost = gost_section [gost_section] engine_id = gost default_algorithms = ALL</code> </pre><br><br>  If the openssl configuration file is not located in a standard location, then the path to it can be set via the environment variable OPENSSL_CONF. <br><br>  Another option for loading engine gost is to send it in the command line parameters of the openssl utility. <br><br>  If the engine gost is not located in the standard location, then the environment variable OPENSSL_ENGINES can be used to set the path to the directory in which openssl will look for it. <br><br>  For information on whether the openssl utility was successful or not, with the ability to clarify the error, you need to parse stdout and stderror.  At the end of the article there is a link to a PHP script that uses this utility. <br><br>  We now turn to the implementation of complete custom scripts. <br><br><h2>  Registration on the portal </h2><br><br><h3>  Certificate is issued upon registration in the system </h3><br><br><ul><li>  We receive the list of devices connected to the computer Rutoken EDS </li><li>  We generate a key pair of GOST R 34.10-2001 on the selected Rutoken EDS </li><li>  Create a PKCS # 10 certificate request for a generated key pair </li><li>  Send a request to the server </li><li>  On the server, create a certificate, bind to the account (the certificate itself or its descriptor).  It should be noted that the certificate handles received when calling the enumerateCertificates function are unique and unchanged. </li><li>  We send the certificate to the client </li><li>  On the client, we visualize the received certificate. </li><li>  We import the received certificate into Rutoken EDS </li></ul><br><br>  The sequence of calls in the client script will be as follows: <br><br><img src="https://habrastorage.org/files/603/516/15f/60351615f0654178bd46be913f908864.png"><br><br>  Then the request is sent to the server, where a certificate is issued on its basis. <br>  To do this, the server must have installed and correctly configured openssl version from 1.0 and deployed the CA functionality. <br><br>  1. Generation of Ulyuch TC: <br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">openssl</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">genpkey</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-engine</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">gost</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-algorithm</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">GOST2001</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-pkeyopt</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">paramset</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:A</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-out</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">ca</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.key</span></span></code> </pre><br>  After that, the private key will be created in the ca.key file. <br><br>  2. Creating a self-signed CA certificate: <br><pre> <code class="hljs cs">openssl req -engine gost -x509 -<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> -key ca.key -<span class="hljs-keyword"><span class="hljs-keyword">out</span></span> ca.crt</code> </pre><br>  After entering the necessary information about the publisher in the ca.crt file, the CA certificate will be created. <br><br>  The request received from the client is saved in the file user.csr and we issue a certificate based on it (without modifying the data from the request): <br><pre> <code class="hljs pgsql">openssl ca -engine gost -keyfile ca.key -cert ca.crt -<span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>.csr -<span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>.crt -outform PEM -batch</code> </pre><br><br>  After that, a user certificate in PEM format is created in the user.crt file.  It should be sent to the client. <br>  Further sequence of calls on the client: <br><br><img src="https://habrastorage.org/files/e82/882/96c/e8288296c49340ee8af2f74c1ee1e7ef.png"><br><br><h3>  The certificate is already on the token, issued by an external CA </h3><br>  The key pair must be created in a format compatible with the rtPKCS11ECP library for Rutoken EDS. <br><br><ul><li>  We receive the list of devices connected to the computer Rutoken EDS </li><li>  We receive the list of all available user certificates on the selected Rutoken EDS </li><li>  We visualize every certificate </li><li>  The user selects the desired certificate. </li><li>  The server forms the initial sequence of random data (salt string) and sends it to the client. </li><li>  Call <a href="http://dev.rutoken.ru/pages/viewpage.action%3FpageId%3D3801092">authenticate</a> on the client.  When sending salt to the function of the plugin authenticate, this sequence is supplemented with additional random data of 32 characters in size, and the final sequence is signed on the certificate selected by the user in the CMS attached format </li><li>  The signature is sent to the server </li><li>  On the server, CMS attached signature is verified using a root certificate. </li><li>  The resulting random sequence is extracted from the CMS attached message, the salt is ‚Äúdisconnected‚Äù and a comparison is made. </li><li>  If the comparison is successful, then register the user with the certificate contained in the CMS attached message </li></ul><br><br>  The sequence of calls on the client: <br><img src="https://habrastorage.org/files/8c2/57f/50b/8c257f50b9694ae09de476e9f251a3dc.png"><br><br>  The signature is obtained in base64 format.  When checking it on the server using openssl, the signature should be framed with headers to make it PEM.  This signature will look something like this: <br><br><pre> <code class="hljs objectivec">-----BEGIN <span class="hljs-built_in"><span class="hljs-built_in">CMS</span></span>----- MIIDUQYJKoZIhvcNAQcCoIIDQjCCAz4CAQExDDAKBgYqhQMCAgkFADCBygYJKoZI hvcNAQcBoIG8BIG5PCFQSU5QQURGSUxFIFVURjg+PFY+<span class="hljs-number"><span class="hljs-number">0</span></span>JLRi9C/<span class="hljs-number"><span class="hljs-number">0</span></span>L7Qu9C90LjR gtGMINCw0YPRgtC10L3RgtC40YTQuNC60LDRhtC40Y4/PCE+c2VydmVyLXJhbmRv bS1kYXRhZTI6ZGE6MmM6MDU6MGI6MzY6MjU6MzQ6YzM6NDk6Nzk6Mzk6YmI6MmY6 YzU6Mzc6ZGI6MzA6MTQ6NDQ6ODM6NjY6Njk6NmI6OWY6YTU6MDk6MzQ6YmY6YzQ6 NzY6YzmgggGeMIIBmjCCAUegAwIBAgIBATAKBgYqhQMCAgMFADBUMQswCQYDVQQG EwJSVTEPMA0GA1UEBxMGTW9zY293MSIwIAYDVQQKFBlPT08gIkdhcmFudC1QYXJr LVRlbGVjb20iMRAwDgYDVQQDEwdUZXN0IENBMB4XDTE0MTIyMjE2NTEyNVoXDTE1 MTIyMjE2NTEyNVowEDEOMAwGA1UEAxMFZmZmZmYwYzAcBgYqhQMCAhMwEgYHKoUD AgIjAQYHKoUDAgIeAQNDAARADKA/O1Zw50PzMpcNkWnW39mAJcTehAhkQ2Vg7bHk IwIdf7zPe2PxHyAr6lH+stqdACK6sFYmkZ58cBjzL0WBwaNEMEIwJQYDVR0lBB4w HAYIKwYBBQUHAwIGCCsGAQUFBwMEBgYpAQEBAQIwCwYDVR0PBAQDAgKkMAwGA1Ud EwEB/wQCMAAwCgYGKoUDAgIDBQADQQD5TY55KbwADGKJRK+bwCGZw24sdIyayIX5 dn9hrKkNrZsWdetWY3KJFylSulykS/dfJ871IT+<span class="hljs-number"><span class="hljs-number">8</span></span>dXPU5A7WqG4+MYG7MIG4AgEB MFkwVDELMAkGA1UEBhMCUlUxDzANBgNVBAcTBk1vc2NvdzEiMCAGA1UEChQZT09P ICJHYXJhbnQtUGFyay1UZWxlY29tIjEQMA4GA1UEAxMHVGVzdCBDQQIBATAKBgYq hQMCAgkFADAKBgYqhQMCAhMFAARAco5PumEfUYVcLMb1cnzETNOuWC8Goda8pdUL W5ASK+tztCwM7wpXgAy+Y6/sLtClO9sh8dKnAaEY2Yavg3altQ== -----END <span class="hljs-built_in"><span class="hljs-built_in">CMS</span></span>-----</code> </pre><br><br>  Signature verification on server: <br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">openssl</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">cms</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-engine</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">gost</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-verify</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-in</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">sign</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.cms</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-inform</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">PEM</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-CAfile</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">ca</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.crt</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-out</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">data</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.file</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-certsout</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">user</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.crt</span></span></code> </pre><br><br>  Here, sign.cms is the file that contains the signature, ca.crt is the file with root certificates, up to one of which a chain should line up, data.file is the file where the signed data will be saved, user.crt is the file where the user certificate will be saved.  It is from data.file that you need to extract the data to disconnect the last 32 characters and compare the salt. <br><br>  If on the server you need to get information from the certificate, then you can parse it like this: <br><br>  Show certificate contents in text view: <br><pre> <code class="hljs pgsql">openssl x509 -<span class="hljs-keyword"><span class="hljs-keyword">in</span></span> cert.pem -noout -<span class="hljs-type"><span class="hljs-type">text</span></span></code> </pre><br><br>  Show certificate serial number: <br><pre> <code class="hljs pgsql">openssl x509 -<span class="hljs-keyword"><span class="hljs-keyword">in</span></span> cert.pem -noout -<span class="hljs-type"><span class="hljs-type">serial</span></span></code> </pre><br><br>  Show subject DN: <br><pre> <code class="hljs objectivec">openssl x509 -<span class="hljs-keyword"><span class="hljs-keyword">in</span></span> cert.pem -noout -subject</code> </pre><br><br>  Show publisher DN: <br><pre> <code class="hljs objectivec">openssl x509 -<span class="hljs-keyword"><span class="hljs-keyword">in</span></span> cert.pem -noout -issuer</code> </pre><br><br>  Show Subject Postal Address: <br><pre> <code class="hljs objectivec">openssl x509 -<span class="hljs-keyword"><span class="hljs-keyword">in</span></span> cert.pem -noout -email</code> </pre><br><br>  Show certificate start time: <br><pre> <code class="hljs objectivec">openssl x509 -<span class="hljs-keyword"><span class="hljs-keyword">in</span></span> cert.pem -noout -startdate</code> </pre><br><br>  Show certificate expiration time: <br><pre> <code class="hljs objectivec">openssl x509 -<span class="hljs-keyword"><span class="hljs-keyword">in</span></span> cert.pem -noout -enddate</code> </pre><br><br><h2>  Strong portal authentication </h2><br><br>  The general authentication scheme used in the Rutoken Plugin is as follows: <br><ul><li>  the server forms the initial sequence of random data (salt string) and sends it to the client </li><li>  when transferring salt to the function of the plugin <a href="http://dev.rutoken.ru/pages/viewpage.action%3FpageId%3D3801092">authenticate,</a> this sequence is supplemented with random data of 32 characters in size, and the final sequence is signed on the certificate selected by the user in the CMS format attached </li><li>  the signature is sent to the server </li><li>  On the server, the signature is checked </li><li>  the final random sequence is extracted from the CMS attached message, the salt is ‚Äúdisconnected‚Äù and a comparison is made </li><li>  upon successful verification, the user is authenticated based on the certificate extracted from the CMS message </li></ul><br>  The implementation of this scheme is not fundamentally different from "Registration, the certificate is already available, issued by an external CA". <br><br><h2>  Electronic signature of data and / or files in CMS format </h2><br><br><ul><li>  a text message (string) is formed, the message can be generated both on the server and on the client </li><li>  if you want to sign a document of arbitrary format (for example, PDF), then you need to encode it into base64 format </li><li>  the string containing the data for the signature is passed to the <a href="http://dev.rutoken.ru/pages/viewpage.action%3FpageId%3D3801092">sign</a> function </li><li>  if the string is base64 encoded data, then the isBase64 function parameter must be set to true, and the base64 decoding will occur before the signature </li><li>  if you want to use hardware calculation of the GOST R 34.11-94 hash function (certified implementation, speed 60-70 Kb / s), then in the options you need to set the useHardwareHash option to true.  If this option is set to false, then a quick software implementation of the hash function GOST R 34.11-94 will be used </li><li>  if you want to create a ‚Äúdetached‚Äù (detached) CMS signature, then you need to set the detached option to true, otherwise, a ‚Äúattached‚Äù signature will be formed </li><li>  in order to include / not include the user certificate in the signed CMS message there is an option addUserCertificate </li><li>  Setting the addSignTime option to true will result in the system time being added to the signed CMS message as a signed attribute </li></ul><br><br>  Verification of the signature on the server is described above. <br><br><h2>  Encryption / decryption of data and / or files in CMS format </h2><br><br><h3>  Client data encryption for the server </h3><br><br>  In order to ensure confidentiality of data exchange between the client and the server, the plugin provides for data encryption / decryption.  Data is encrypted in CMS format.  In order to encrypt data in the CMS format, a certificate of the ‚Äúrecipient‚Äù public key is required.  In this case, only the owner of the private key can decrypt such a message.  When encrypting data for the server, it is recommended to store the server certificate on the Rutoken EDS.  This certificate can be written to the device when the user registers on the portal.  To do this, use the <a href="http:">importCertificate</a> function, and you should pass CERT_CATEGORY_OTHER as the category parameter.  To be used in the <a href="http:">cmsEncrypt</a> function, <a href="http:">you</a> need to get the body of the certificate by its descriptor using the <a href="http:">getCertificate</a> function.  In this case, the descriptor is unique and unchanged and can be stored in the user account on the server when importing the server certificate.  In order to use hardware encryption according to GOST 28147-89, it is required to set the useHardwareEncryption option to true.  Otherwise, fast software implementation of GOST 28147-89 will be used. <br><br>  The sequence of calls is shown in the picture: <br><br><img src="https://habrastorage.org/files/316/bc6/ef3/316bc6ef30f947f6bc20ece93d4dde66.png"><br><br>  Data encryption on the client: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> recipientCert = plugin.getCertificate(deviceId, certRecId); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (error) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(error); } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> options = {}; options.useHardwareEncryption = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cms; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { cms = plugin.cmsEncrypt(deviceId, certSenderId, recipientCert, data, options); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (error) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(error); }</code> </pre><br><br>  To decrypt data on the server, before decrypting, the message must be framed with PEM headers "----- BEGIN PKCS7 -----" and "----- END PKCS7 -----": <br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">openssl</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">smime</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-engine</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">gost</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-decrypt</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-in</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">message</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.cms</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-inform</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">PEM</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-recip</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">recipient</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.crt</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-inkey</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">recipient</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.key</span></span></code> </pre><br>  recipient.crt is the certificate of the person for whom the message is encrypted, recipient.key is the key of the person for whom the message is encrypted. <br><br><h3>  Decryption of data received from the server on the client </h3><br><br>  To decrypt data received from the server, the <a href="http:">cmsDecrypt</a> function is <a href="http:">used</a> .  Since the server encrypts the client using its certificate, the client's private key descriptor corresponding to the public key in the certificate must be passed as the keyId.  This descriptor is unique and unchanged and therefore can be stored in a user account on the server.  In addition, a user key descriptor can be obtained explicitly by calling the <a href="http://dev.rutoken.ru/pages/viewpage.action%3FpageId%3D3801092">getKeyByCertificate</a> function. <br><br>  Data encryption on the server for the client: <br><pre> <code class="hljs delphi">openssl smime -encrypt -engine gost -gost89 -binary -outform PEM -<span class="hljs-keyword"><span class="hljs-keyword">in</span></span> data.<span class="hljs-keyword"><span class="hljs-keyword">file</span></span> -<span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">message</span></span>.enc user.crt</code> </pre><br><br>  Decryption of data on the client: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> data; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> options = {}; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { data = plugin.cmsDecrypt(deviceId, keyId, cms, options); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (error) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(error); }</code> </pre><br><br><h2>  useful links </h2><br>  These links can be useful for information system developers with EDS support based on the Rutoken Plugin and openssl: <br><br>  <a href="http://demobank.rutoken.ru/">Demo System Rutoken Plugin</a> <br>  <a href="http://ra.rutoken.ru/">WEB-service for generating keys, generating requests, managing certificates, generating certificate request templates</a> <br>  <a href="http://dev.rutoken.ru/pages/viewpage.action%3FpageId%3D3801104">Rutoken Plugin Documentation</a> <br>  <a href="http://www.cryptocom.ru/docs/cryptopack21-openssl.pdf">Documentation on the use of the openssl utility with Russian cryptographic algorithms</a> <br>  <a href="">Sample PHP script using openssl utility</a> </div><p>Source: <a href="https://habr.com/ru/post/246861/">https://habr.com/ru/post/246861/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../246845/index.html">Not another evalboard for STM32 - we do it right in XFR-L3 "KYRNN"</a></li>
<li><a href="../246849/index.html">Hacker's guide to neural networks. Chapter 2: Machine Learning. Network learning based on support vector machine (SVM)</a></li>
<li><a href="../246851/index.html">Do not make icons, make live tiles</a></li>
<li><a href="../246853/index.html">School call to .NET Micro Framework with remote control</a></li>
<li><a href="../246855/index.html">Bluetooth and other ways to hack handcuffs</a></li>
<li><a href="../246865/index.html">10 key strategic technologies of 2015 according to Gartner</a></li>
<li><a href="../246867/index.html">As a student to have an up-to-date schedule, as wardens and teachers send messages to the whole group at once.</a></li>
<li><a href="../246869/index.html">Generator do-it-yourself at 220 volts. Now the blackouts are not scary.</a></li>
<li><a href="../246873/index.html">The release of the educational program for startups ABRT-Mangrove CEO Camp 2.0</a></li>
<li><a href="../246875/index.html">About the personal effectiveness of the programmer, or How to focus on the most important, not forgetting everything else</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>