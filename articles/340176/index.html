<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>The whole web on 60+ FPS: how a new renderer in Firefox got rid of jerks and slowdowns</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Before the release of Firefox, Quantum has less and less time. It will bring many improvements in performance, including the super-fast CSS engine , w...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>The whole web on 60+ FPS: how a new renderer in Firefox got rid of jerks and slowdowns</h1><div class="post__text post__text-html js-mediator-article">  Before the release of Firefox, Quantum has less and less time.  It will bring many improvements in performance, including the <a href="https://habrahabr.ru/post/336722/">super-fast CSS engine</a> , which we borrowed from Servo. <br><br>  But there is another major part of the Servo technology, which has not yet become part of Firefox Quantum, but will soon be included.  This is WebRender, part of the Quantum Render project. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/a3a/909/152/a3a909152059013d762ce682c1eeda91.png"></a> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      WebRender is known for its exceptional speed.  But the main task is not to speed up the rendering, but to make it smoother. <br><br>  When developing WebRender, we set the goal for all applications to run at 60 frames per second (FPS) or better, regardless of the size of the display or the size of the animation.  And it worked.  Pages that puff 15 FPS in Chrome or the current Firefox <a href="https://www.youtube.com/watch%3Fv%3Du0hYIRQRiws">fly 60 FPS when launching WebRender</a> . <br><br>  How does WebRender do this?  It fundamentally changes the way the rendering engine works, making it more similar to the 3D game engine. <br><a name="habracut"></a><br>  Let's figure out what that means.  But first‚Ä¶ <br><br><h1>  What does the renderer do? </h1><br>  In the <a href="https://habrahabr.ru/post/336722/">article on Stylo,</a> I explained how the browser goes from parsing HTML and CSS to pixels on the screen, and how most browsers do it in five steps. <br><br>  These five stages can be divided into two parts.  The first of these is, in essence, a plan.  To plan, the browser parses HTML and CSS, taking into account information such as the size of the viewing area, to find out exactly how each element should look like - its width, height, color, etc.  The end result is what is called a ‚Äúframe tree‚Äù or ‚Äúrender tree‚Äù. <br><br>  In the second part - rendering and layout - the renderer starts working.  He takes this plan and turns it into pixels on the screen. <br><br> <a href=""><img src="https://habrastorage.org/webt/59/e4/b1/59e4b1e617981295490413.png"></a> <br><br>  But the browser is not enough to do it only once.  He has to repeat the operation again and again for the same web page.  Every time something changes on a page ‚Äî for example, a div opens across a switch ‚Äî the browser has to go through all the steps repeatedly. <br><br> <a href=""><img src="https://habrastorage.org/webt/59/e4/b1/59e4b1e6152fa670173840.png"></a> <br><br>  Even if nothing changes on the page ‚Äî for example, you simply scroll or select text ‚Äî the browser still has to perform rendering operations to draw new pixels on the screen. <br><br> <a href=""><img src="https://habrastorage.org/webt/59/e4/b1/59e4b1e6566d8764297567.png"></a> <br><br>  To make scrolling and animation smooth, they must be updated at 60 frames per second. <br><br>  You may have heard this phrase before - frames per second (FPS) - being unsure what it means.  I imagine them as a flipbook.  It's like a book with static pictures that you can quickly scroll through, so that creates the illusion of animation. <br><br>  To make the animation in such a flipbook look smooth, you need to view 60 pages per second. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/2df/8bf/00a/2df8bf00a666b750f946726de01c6137.gif"></a> <br><br>  The pages in the flipbook are made of graph paper.  There are many, many small squares, and each square can contain only one color. <br><br>  The task of the renderer is to fill the squares in graph paper.  When they are all filled, the frame is rendered. <br><br>  Of course, there is no real graph in your computer.  Instead, the computer has a memory area called frame buffer.  Each memory address in the frame buffer is like a small square on graph paper ... it corresponds to a pixel on the screen.  The browser fills each cell with numbers that correspond to the RGBA values ‚Äã‚Äã(red, green, blue, and alpha). <br><br><img src="https://habrastorage.org/webt/59/e4/b1/59e4b1e6700f1525927181.png"><br><br>  When the screen needs to be updated, it accesses this area of ‚Äã‚Äãmemory. <br><br>  Most computer displays are updated 60 times per second.  That is why browsers try to issue 60 frames per second.  This means that the browser has only 16.67 milliseconds for all the work: analysis of CSS styles, layout, rendering - and filling all slots in the frame buffer with numbers that correspond to the colors.  This time interval between two frames (16.67 ms) is called the frame budget. <br><br>  You could hear people sometimes mention missing frames.  A missing frame is when the system does not fit into the budget.  The display attempts to get a new frame from the frame buffer before the browser has finished working on its display.  In this case, the display again shows the old version of the frame. <br><br>  Missed frames can be compared with a torn page from a flipbook.  The animation begins to freeze and twitch, because you have lost the intermediate link from the previous page to the next. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/249/aea/e79/249aeae794b38d43df5034aabcabf463.gif"><br><br>  So you need to have time to place all the pixels in the frame buffer before the display checks it again.  Let's see how browsers used to cope with this and how technology has changed over time.  Then we can figure out how to speed up this process. <br><br><h1>  Brief history of drawing and layout </h1><br>  <i>Note.</i>  <i>Drawing and layout is the part where the rendering engines in browsers are most different from each other.</i>  <i>Single-platform browsers (Edge and Safari) work a bit differently than multiplatform browsers (Firefox and Chrome).</i> <br><br>  Even in the very first browsers, some optimizations were made to speed up the rendering of pages.  For example, when scrolling through the page, the browser tried to move the already rendered parts of the page, and then draw the pixels in the free space. <br><br>  The process of calculating what has changed, and then updating only the changed elements or pixels, is called invalidation. <br><br>  Over time, browsers began to use more advanced invalidation techniques, such as the invalidation of rectangles.  Here, the minimum rectangle is calculated around the changed screen area, and then only the pixels inside these rectangles are updated. <br><br>  Here the amount of computation is really greatly reduced if only a small number of elements change on the page ... for example, only a blinking cursor. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9a2/00d/58f/9a200d58f1f476e38d2fffdef715ce65.gif"><br><br>  But it doesn‚Äôt help much if large parts of the page change.  For such cases, we had to come up with new technology. <br><br><h3>  Layer appearance and layout </h3><br>  Using layers helps a lot when changing large parts of the page ... at least in some cases. <br><br>  Layers in browsers look like layers in Photoshop or layers of thin, smooth paper that used to be used to draw cartoons.  In general, the various elements of the page you draw on different layers.  Then place these layers on top of each other. <br><br>  For a long time, browsers used layers, but they did not always accelerate rendering.  At first, they were used simply to ensure correct drawing of elements.  They implemented the so-called ‚Äúpositioning context‚Äù (stacking context). <br><br>  For example, if you have a translucent element on a page, then it should be in its own positional context.  This means that it has its own layer so that it is possible to mix its color with the color of the underlying element.  These layers were discarded as soon as the frame was rendered.  The next frame had to draw the layers again. <br><br><img src="https://habrastorage.org/webt/59/e4/b2/59e4b2cc2a43b232155421.png"><br><br>  But part of the elements on these layers does not change from frame to frame.  For example, imagine a regular animation.  The background does not change, even if the characters move in the foreground.  It‚Äôs much more efficient to save the background layer and just reuse it. <br><br>  This is exactly what browsers did.  They began to keep the layers, updating only the changed.  And in some cases, the layers did not change at all.  They need only be slightly moved - for example, if the animation moves around the screen or in the case of scrolling an item. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/68f/e52/f93/68fe52f934abeb64a7aac97fd8a132c6.gif"><br><br>  This process of co-location of layers is called a layout.  Linker works with the following objects: <br><br><ul><li>  source raster images: background (including an empty window where content should scroll) and the scrolling content itself; </li><li>  The target bitmap is what is displayed on the screen. </li></ul><br>  First, the layout copies the background to the target bitmap. <br><br>  Then he must figure out what part of the scrolling content needs to be shown.  It will copy this part on top of the target bitmap. <br><br><img src="https://habrastorage.org/webt/59/e4/b2/59e4b2cc11333307609423.png"><br><br>  This reduces the amount of rendering in the main thread.  But the main thread is still spending a lot of time on the layout.  And there are many processes that fight for resources in the main thread. <br><br>  I gave this example earlier: the main thread is similar to the full-stack developer.  He is responsible for DOM, layout and JavaScript.  And he is also responsible for the drawing and layout. <br><br><img src="https://habrastorage.org/webt/59/e4/b2/59e4b2cc41f19382860124.png"><br><br>  Every millisecond spent in the main thread for drawing and layout is the time taken from JavaScript or layout. <br><br><img src="https://habrastorage.org/webt/59/e4/b2/59e4b2cc53a5a142084963.png"><br><br>  But we have other hardware that sits here and does almost nothing.  And it is specially created for graphic processing.  We are talking about the GPU, which games from the 90s are used for fast frame rendering.  And since then, graphics processors have become bigger and more powerful. <br><br><img src="https://habrastorage.org/webt/59/e4/b2/59e4b2cc6ff08526852609.png"><br><br><h3>  Hardware Accelerated Layout </h3><br>  So the browser developers began to transfer the work of the GPU. <br><br>  Theoretically, the graphics accelerator can transfer two tasks: <br><br><ol><li>  Drawing layers. </li><li>  Layering layers with each other. </li></ol><br>  Drawing can be difficult to transfer to the GPU.  So usually multiplatform browsers leave this task on the CPU. <br><br>  However, the GPU can do the layout very quickly, and this task is easy to hang onto it. <br><br><img src="https://habrastorage.org/webt/59/e4/b5/59e4b58eaa693119342488.png"><br><br>  Some browsers force parallelism even more by adding linker flow to the CPU.  He becomes the manager of all the work on the layout, which is performed on the GPU.  This means that if the main thread is busy with something (for example, it does JavaScript), the linker thread is still active and does work that is visible to the user, such as scrolling through the content. <br><br><img src="https://habrastorage.org/webt/59/e4/b5/59e4b58eaa6b2562102494.png"><br><br>  That is, all the work on the layout leaves the main thread.  However, there still remains a lot of things.  Every time you need to redraw a layer, it makes the main thread, and then passes the layer to the GPU. <br><br>  Some browsers have moved and rendering to an additional stream (we are also working on this in Firefox).  But it will be faster to transfer this last piece of calculations - the drawing - immediately to the GPU. <br><br><h3>  Hardware accelerated rendering </h3><br>  So, browsers started transferring to the graphics processor and rendering too. <br><br><img src="https://habrastorage.org/webt/59/e4/b5/59e4b58f4d51e102629676.png"><br><br>  This transition is still ongoing.  Some browsers perform all rendering on the GPU, while in others this is only possible on certain platforms (for example, only on Windows or only on mobile devices). <br><br>  Drawing on the GPU led to several consequences.  It allowed the CPU to devote all the time to tasks like JavaScript and layout.  In addition, the GPU draws pixels much faster than the CPU, so the whole process of drawing is accelerated.  The amount of data that needs to be transferred from the CPU to the GPU has also decreased. <br><br>  But maintaining such a separation between rendering and layout still requires certain expenses, even if both processes are performed on the GPU.  This separation also limits you in the optimization options for accelerating the work of the GPU. <br><br>  This is where WebRender comes in.  It fundamentally changes the rendering method, leveling the distinction between drawing and layout.  This allows you to adjust the performance of the renderer to the requirements of the modern web and prepare it for situations that will appear in the future. <br><br>  In other words, we wanted to not only speed up the rendering of frames ... we wanted them to be rendered more stably, without jerks and slowdowns.  And even if you need to draw a lot of pixels, like in WebVR 4K virtual reality helmets, we still want smooth playback. <br><br><h1>  Why is animation so slow in modern browsers? </h1><br>  The above optimization has helped in some cases to speed up the rendering.  When a minimum of elements changes on a page ‚Äî for example, only flashing courses ‚Äî the browser does the minimum amount of work possible. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9a2/00d/58f/9a200d58f1f476e38d2fffdef715ce65.gif"><br><br>  After splitting pages into layers, the number of such ‚Äúideal‚Äù scenarios increased.  If you can just draw a few layers and then just move them relative to each other, then the ‚Äúdrawing + layout‚Äù architecture works fine. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/cde/22c/aa3/cde22caa325c7dffed22e92dbfde4909.gif"><br><br>  But the layers have flaws.  They take up a lot of memory, and sometimes can slow down rendering.  Browsers have to combine layers where it makes sense ... but it's difficult to determine exactly where it makes sense and where it doesn't. <br><br>  So, if there are a lot of different objects moving on the page, you will have to create a bunch of layers.  Layers take too much memory, and transferring to a linker takes too much time. <br><br><img src="https://habrastorage.org/webt/59/e4/b5/59e4b58f7ba0b918518583.png"><br><br>  In other cases, it turns out one layer where there should be several.  This single layer will be continuously redrawn and transferred to the linker, which then assembles it without changing anything. <br><br>  That is, the drawing effort is removed: each pixel is processed twice without any need.  Faster would be just to directly render the page, bypassing the layout stage. <br><br> <a href=""><img src="https://habrastorage.org/webt/59/e4/b5/59e4b58fc6b8d131449845.png"></a> <br><br>  There are many cases in which layers are simply useless.  For example, if you have an animated background, then the whole layer will still have to be redrawn.  These layers only help with a small amount of CSS properties. <br><br>  Even if the majority of frames fit into the optimal scenario - that is, they take only a small part of the frame budget - the movement of objects can still remain intermittent.  In order to perceive jerks and brakes on the eye, it is enough to lose a whole pair of frames that fit into the worst scenario. <br><br> <a href=""><img src="https://habrastorage.org/webt/59/e4/b5/59e4b58fc0be1833629028.png"></a> <br><br>  These scenarios are called performance cliffs.  The application works as if it is normal, until it encounters one of these worst scenarios (such as an animated background) - and the frame rate suddenly drops to the limit. <br><br><img src="https://habrastorage.org/webt/59/e4/b5/59e4b58ff2b27060208058.png"><br><br>  But you can get rid of such cliffs. <br><br>  How to do it?  Let's follow the example of 3D game engines. <br><br><h1>  Using the GPU as a game engine </h1><br>  What if we stop guessing which layers we need?  What if you remove this intermediate step between drawing and layout and just go back to drawing each pixel in each frame? <br><br>  It may seem a ridiculous idea, but in some places such a system is used.  In modern video games, every pixel is redrawn, and they keep the level of 60 frames per second more reliably than browsers.  They do this in an unusual way ... instead of creating these rectangles for invalidation and layers that minimize the area to be redrawn, the entire screen is simply updated. <br><br>  Will rendering web pages in this way be much slower? <br><br>  If we draw on the CPU, then yes.  But the GPUs are specifically designed for this kind of work. <br><br>  GPUs are built with maximum concurrency.  I talked about <a href="https://hacks.mozilla.org/2017/08/inside-a-super-fast-css-engine-quantum-css-aka-stylo/">concurrency in my latest article about Stylo</a> .  Thanks to parallel processing, the computer performs several tasks simultaneously.  The number of simultaneously performed tasks is limited by the number of cores in the processor. <br><br>  The CPU usually has from 2 to 8 cores, and in the GPU there are at least several hundred, and often more than 1000 cores. <br><br>  However, these kernels work a little differently.  They cannot function completely independently, like the CPU cores.  Instead, they usually perform some kind of joint task, running one instruction on different pieces of data. <br><br> <a href=""><img src="https://habrastorage.org/webt/59/e4/b5/59e4b590044d4692341820.png"></a> <br><br>  This is exactly what we need when filling the pixels.  All pixels can be distributed to different cores.  Since the GPU works with hundreds of pixels at the same time, it performs much faster filling of pixels than the CPU ... but only if all the cores are loaded with work. <br><br>  Since the cores have to work on the same task at the same time, the GPU has a rather limited set of steps to perform, and their program interfaces are very limited.  Let's see how it works. <br><br>  The first step is to tell the GPU what to draw.  This means giving them the forms of objects and instructions for filling them out. <br><br>  To do this, break the whole pattern into simple shapes (usually triangles).  These forms are in 3D space, so some of them may obscure others.  Then you take the vertices of all the triangles - and add their x, y, z coordinates to the array. <br><br><img src="https://habrastorage.org/webt/59/e4/b5/59e4b5902e869364813472.png"><br><br>  Then send the GPU command to draw these forms (draw call). <br><br><img src="https://habrastorage.org/webt/59/e4/b5/59e4b5903604c108770352.png"><br><br>  From this moment on, the GPU starts working.  All cores will perform the same task at the same time.  They will do the following: <br><br><ol><li>  Determine the corners of all shapes.  This is called vertex shading. <br><br><img src="https://habrastorage.org/webt/59/e4/b5/59e4b59093fbc862683838.png"></li><li>  Set the lines that connect the vertices.  Now you can determine which pixels the shapes include.  This is called rasterization. <br><br><img src="https://habrastorage.org/webt/59/e4/b5/59e4b590941fd534597101.png"></li><li>  When we know which pixels belong to each shape, we can go through each pixel and assign a color to it.  This is called pixel shading. <br><br><img src="https://habrastorage.org/webt/59/e4/b5/59e4b590e9050458380521.png"></li></ol><br>  The last step is done differently.  To issue specific instructions, a special program called the ‚Äúpixel shader‚Äù works with the GPU.  Coloring pixels is one of the few elements of GPU functionality that you can program. <br><br>  Some pixel shaders are very simple.  For example, if the entire shape is filled with the same color, then the shader should simply assign this color to each pixel of the shape. <br><br>  But there are more complex shaders, for example, in the background image.  Here you have to find out which parts of the image correspond to which pixel.  This can be done in the same way that the artist scales the image, increasing or decreasing it ... put a grid with squares for each pixel on top of the image.  Then take color swatches inside each square and determine the final pixel color.  This is called texture mapping, because here the image (called texture) is superimposed on the pixels. <br><br><img src="https://habrastorage.org/webt/59/e4/b5/59e4b591035ec850670252.png"><br><br>  The GPU will access the pixel shader for each pixel.  Different cores work in parallel on different pixels, but they all need the same pixel shader.  When you instruct the GPU to draw the shapes of the objects, you simultaneously specify which pixel shader to use. <br><br>  For almost all web pages, different parts of the page require different pixel shaders. <br><br>  Since the shader works for all pixels specified in the draw command, you usually need to break these commands into several groups.  They are called packages.  In order to maximally load all the cores, you need to create a small number of packages with a large number of figures in each of them. <br><br><img src="https://habrastorage.org/webt/59/e4/b5/59e4b5913acfe434399679.png"><br><br>  This is how the GPU distributes work across hundreds or thousands of cores.  All because of the exceptional parallelism when rendering each frame.  But even with such exceptional parallelism, a lot of work still remains.  By setting tasks need to be approached wisely to achieve decent performance.  Here comes the WebRender case ... <br><br><h1>  How WebRender works with the GPU </h1><br>  Let's remember what steps the browser is taking to render the page.  Here there are two changes. <br><br> <a href=""><img src="https://habrastorage.org/webt/59/e4/b5/59e4b5914fb0f325555806.png"></a> <br><br><ol><li>  There is no longer a separation between drawing and layout ... both processes are performed in one stage.  The GPU does them simultaneously, guided by the commands received from the graphics API. </li><li>  Layout now gives us a different data structure for rendering.  Previously, it was something called a frame tree (or a Chrome visualization tree).  And now it passes the display list. </li></ol><br>  A display list is a set of high-level drawing instructions.  It indicates what needs to be drawn without using specific instructions for a particular graphics API. <br><br>  As soon as something new needs to be drawn, the main thread passes the display list to RenderBackend - this is the WebRender code running on the CPU. <br><br>  The task of RenderBackend is to take a list of high-level drawing instructions and convert it into commands for the GPU, which are combined into packages for faster execution. <br><br> <a href=""><img src="https://habrastorage.org/webt/59/e4/b5/59e4b591c7fc9576778327.png"></a> <br><br>  Then RenderBackend passes these packets to the linker stream, which then passes them to the GPU. <br><br>  RenderBackend wants the draw commands to run on the GPU at maximum speed.  To do this, use several different techniques. <br><br><h3>  Removing unnecessary pieces from the list (early culling) </h3><br>  The best way to save time is not to work at all. <br><br>  First, RenderBackend shortens the display list.  It determines which elements of the list will actually be displayed on the screen.  To do this, it looks how far from the window in the scroll list is the item. <br><br>  If the figure falls within the window, it is included in the display list.  And if no part of the figure falls here, then it is excluded from the list.  This process is called early culling. <br><br><img src="https://habrastorage.org/webt/59/e4/b8/59e4b82657435181812846.png"><br><br><h3>  Minimizing the number of intermediate structures (task tree for rendering) </h3><br>  Now our tree contains only the necessary forms.  This tree is organized in the positional contexts that we talked about earlier. <br><br>  Effects like CSS filters and positional contexts complicate things a little.  For example, you have an element with a transparency of 0.5, and it has a child element.  You may think that all children are also transparent ... but in reality the whole group is transparent. <br><br><img src="https://habrastorage.org/webt/59/e4/b8/59e4b82633523175503581.png"><br><br>  Because of this, you must first display the group on the texture, with full transparency of each square.  Then, placing it in the parent object, you can change the transparency of the entire texture. <br><br>  Positional contexts can be nested inside each other ... and the parent object can belong to another positional context.  That is, it will need to be drawn on another intermediate texture, and so on. <br><br>  Allocating space for these textures is expensive.  We would like to maximally accommodate all the objects on the same intermediate structure. <br><br>  To help the GPU cope with the task, create a tree of tasks for rendering.  It indicates which textures need to be created before other textures.  Any textures that are independent of others can be created in the first pass, that is, they can then be combined into one intermediate texture. <br><br>  So in the above example with translucent squares, we would paint one corner of the square with the first pass.  (In fact, everything is a little more complicated, but the essence is this). <br><br><img src="https://habrastorage.org/webt/59/e4/b8/59e4b826a45b6301786261.png"><br><br>  The second pass can duplicate this angle for the entire square and paint over it.  Then render the group of opaque squares. <br><br><img src="https://habrastorage.org/webt/59/e4/b8/59e4b826a5015324226579.png"><br><br>  Finally, it remains only to change the transparency of the texture and place it in the appropriate place of the final texture that will be displayed on the screen. <br><br><img src="https://habrastorage.org/webt/59/e4/b8/59e4b8272681e464394909.png"><br><br>  Having built a task tree for rendering, we find out the minimum possible number of rendering objects before displaying on the screen.  This is good, because I mentioned that the allocation of space for these textures is expensive. <br><br>  The task tree also helps package tasks. <br><br><h3>  Grouping commands for drawing (batch processing) </h3><br>  As we have said, you need to create a small number of packages with a large number of figures in each of them. <br><br>  Careful packet formation allows for much faster rendering.  You need to squeeze as many objects as possible into the package.  Such a requirement is made for several reasons. <br><br>  First, whenever the CPU issues a drawing command to the GPU, the CPU always has many other tasks.  He needs to take care of things such as configuring the GPU, loading the shader program and checking for various hardware bugs.  All this work accumulates, and while the CPU does it, the GPU can stand idle. <br><br>  Secondly, there are certain costs of state change.  Let's say between packages you need to change the state of the shader.  On an ordinary GPU, you will have to wait until all cores have completed the task from the current shader.  This is called draining the pipeline.  While the pipeline is not cleared, the remaining cores will be put on standby. <br><br> <a href=""><img src="https://habrastorage.org/webt/59/e4/b8/59e4b8272692c522770296.png"></a> <br><br>  Because of this, it is advisable to pack the bag as tightly as possible.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For an ordinary desktop PC, it is advisable to leave less than 100 drawing commands for each frame, and it would be nice to stuff thousands of vertices into each command. </font><font style="vertical-align: inherit;">So the maximum from parallelism is squeezed out. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We look at each pass in the task tree for rendering and on which of the tasks to group into one package. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">At this time, each type of primitive requires a different shader. </font><font style="vertical-align: inherit;">For example, there is a border shader, text shader and image shader. </font></font><br><br><img src="https://habrastorage.org/webt/59/e4/b8/59e4b827c93f0231060803.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We believe that it is possible to combine many of these shaders, which will make it possible to create even larger packages, although they are well grouped now as well. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tasks are almost ready to be sent to the GPU. </font><font style="vertical-align: inherit;">But there is still a little bit of work to get rid of.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Reduce pixel shading work with opacity and alpha channel passes (Z-culling) </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Most web pages contain many overlapping shapes. For example, a text field is on top of a div (with a background), which is on top of a body (with a different background). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When determining the color of a pixel, the GPU could calculate the color of the pixel in each shape. But only the top layer will be shown. This is called overdraw, a waste of GPU time. </font></font><br><br><img src="https://habrastorage.org/webt/59/e4/b8/59e4b827b9228296741157.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So you can first render the top layer. When it is the turn to render a pixel for the next figure, we check if this pixel already has a value. If there is, then the extra work is not performed. </font></font><br><br><img src="https://habrastorage.org/webt/59/e4/b8/59e4b8283cb8f109235185.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">True, there is a small problem. If the figure is translucent, then you need to mix the colors of the two figures. And so that everything looks right, rendering should be carried out from the bottom up.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So we divide the work into two passes. First pass on opacity. Render from top to bottom all opaque shapes. We skip rendering all pixels that are closed by others. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Then proceed to the translucent shapes. They are drawn from bottom to top. If the translucent pixel is on top of the opaque, then their colors are mixed. If it is behind the opaque, it is not calculated. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The division into two passes ‚Äî by opacity and alpha channel ‚Äî with the further omission of calculations of unnecessary pixels is called Z-culling.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Although this may seem like a simple optimization, here we get a big profit. </font><font style="vertical-align: inherit;">On a typical web page, the number of pixels to process is significantly reduced. </font><font style="vertical-align: inherit;">We are now looking for ways to move even more tasks into the opacity passage. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">At the moment we have prepared the frame. </font><font style="vertical-align: inherit;">We did our best to remove the extra work.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ... And we are ready to draw! </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The graphics processor is ready to set up and render packages. </font></font><br><br> <a href=""><img src="https://habrastorage.org/webt/59/e4/b8/59e4b82855977445463362.png"></a> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Disclaimer: not everything went away on the GPU </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The CPU still does some of the rendering work. For example, we still render characters on a CPU (they are called glyphs) in text blocks. It is possible to do this on the GPU, but it is difficult to achieve pixel-by-pixel matching with the glyphs that the computer renders in other applications. So people can get confused when rendering fonts on the GPU. We are experimenting with moving the rendering of glyphs to the GPU as part of the </font></font><a href="https://github.com/pcwalton/pathfinder"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pathfinder</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> project </font><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But now these things are drawn into bitmaps on the CPU. Then they are loaded into the texture cache on the GPU. This cache is saved from frame to frame, because usually there is no change in it.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Even though this rendering remains on the CPU, there is still the potential to speed it up. </font><font style="vertical-align: inherit;">For example, when drawing characters of a font, we distribute various characters across all cores. </font><font style="vertical-align: inherit;">This is done using the same technique that Stylo uses to parallelize the calculation of styles ... </font></font><a href="https://hacks.mozilla.org/2017/08/inside-a-super-fast-css-engine-quantum-css-aka-stylo/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">interception of work</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Future webrender </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In 2018, we plan to introduce WebRender into Firefox as part of Quantum Render, a few releases after the initial release of Firefox Quantum. After that, the existing web pages will work smoother. And Firefox will be ready for a new generation of high-resolution 4K displays, since rendering performance is extremely important as the number of pixels on the screen increases. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But WebRender is not only useful for Firefox. It is also necessary in our work on WebVR, where you need to render different frames for each eye at a speed of 90 FPS at 4K resolution.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The first version of WebRender is already available in Firefox, if you manually activate the corresponding flag. </font><font style="vertical-align: inherit;">The integration work continues, so the performance is not as high as it will be in the final release. </font><font style="vertical-align: inherit;">If you want to monitor the development of WebRender, watch </font></font><a href="https://github.com/servo/webrender"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the GitHub repository</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> or the </font></font><a href="https://twitter.com/firefoxnightly"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Firefox Nightly twitter</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , where weekly news is published on the entire Quantum Render project. </font></font><br><br> <font color="gray"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">About the author: </font></font><b><a href="http://code-cartoons.com/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lin Clark</font></font></a></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - engineer of the Mozilla Developer Relations group. </font><font style="vertical-align: inherit;">She works with JavaScript, WebAssembly, Rust and Servo and loves to draw programmer pictures.</font></font></font> </div><p>Source: <a href="https://habr.com/ru/post/340176/">https://habr.com/ru/post/340176/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../340164/index.html">Information security in the process control system: attack vector man-machine interface</a></li>
<li><a href="../340166/index.html">How Android Converts Resource Sizes</a></li>
<li><a href="../340168/index.html">How did we choose Graylog2</a></li>
<li><a href="../340170/index.html">Rust 1.21 release</a></li>
<li><a href="../340172/index.html">Analysis of the latest version of the Dridex malware for identity theft</a></li>
<li><a href="../340178/index.html">Monoids, semigroups and all-all-all</a></li>
<li><a href="../340180/index.html">Wi-Fi security is compromised due to multiple vulnerabilities found in WPA2</a></li>
<li><a href="../340182/index.html">Critical vulnerabilities detected in WPA2 - Key Reinstallation Attacks (KRACK)</a></li>
<li><a href="../340184/index.html">Introduction to Neural Network Architectures</a></li>
<li><a href="../340186/index.html">How to create a competitive advantage and value of a technological product</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>