<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Creating a software module for the programmer XELTEK SuperPro 6100</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Foreword 
 In the previous article , the anti-cloning mechanism of the XELTEK SuperPro 6100 programmer adapters was considered. 

 This article will d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Creating a software module for the programmer XELTEK SuperPro 6100</h1><div class="post__text post__text-html js-mediator-article"><h4>  Foreword </h4><br>  In the previous <a href="https://habr.com/post/320870/">article</a> , the anti-cloning mechanism of the XELTEK SuperPro 6100 programmer adapters was considered. <br><br>  This article will describe the creation of a proprietary software module for this programmer, which, by a certain modification of the code, can be adapted to work with any other types of chips - currently not supported or, as in our case, declared only formally. <br><br><h4>  Prehistory </h4><br>  Once again, we had a task, which at first glance was solved quite simply - it took to make a copy of one specialized flash memory chip - mDOC H3 SDED5-512M. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      This chip has been developed more than ten years ago.  Here is a pdf <a href="https://habr.com/ru/post/430634/">(1)</a> with its description.  Below is a short excerpt from the Russian-language announcement: <br><br>  <i>... msystems has prepared an mDOC family suitable for use as solid-state drives ...</i> <i><br></i>  <i>The TrueFFS firmware, which is entrusted with the management tasks of the mDOC H3 flash memory, runs its own module controller, which turns it into a complete, self-contained unit that is easily added to a variety of handheld devices. ...</i> <br><a name="habracut"></a><br>  In the list of supported by the programmer SuperPro 6100 such a chip was listed and for her even found the appropriate adapter DX5057.  But after assembling the entire designer and selecting this chip, the program displayed the following picture with the mysterious item ‚ÄúDimageMain‚Äù, the description of which was not found either in the documentation or on the developer‚Äôs website. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/0l/dy/hk/0ldyhknaorevv2x5mjq4cens0qw.jpeg"></div><br>  Having tried to perform the operation ‚ÄúDimageMain‚Äù without a chip in the adapter, a warning was received about its absence and after confirming this fact, the program displayed the following information: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/kh/x4/hk/khx4hkhkb3uu2w5zbpguawdzhh4.jpeg"></div><br>  Judging by the inscription "mDOC H3 Write Image", "Image" is an image that can be written to a chip using this programmer.  But how to read this image from an already recorded chip, how to erase it, etc.? <br><br>  A little later, on the Internet, there was a file <a href="https://habr.com/ru/post/430634/">(2)</a> from the company ‚ÄúDataman‚Äù, in which the structure of the above image is partially given and the software for its creation is mentioned. <br>  Thus, further efforts were directed to the search for utilities from M-Systems, described in the document Software Utilities for TrueFFS 7.1 <a href="https://habr.com/ru/post/430634/">(3)</a> . <br><br>  The request to the technical support of the former M-Systems, now SanDisk, did not give any result - there was simply no answer. <br><br>  On the Internet, it was possible to find only old utilities that do not support versions of the H3 chips.  The full SDK from SanDisk also could not be found, only its "fragments" <a href="https://habr.com/ru/post/430634/">(5)</a> in terms of implementing a driver for Linux. <br><br>  As the accumulated information was studied, the following line attracted attention in the file from Dataman: ‚ÄúImage files can be created with the SanDisk Docshell utility or PG4UW‚Äù. <br><br>  SanDisk Docshell utilities didn‚Äôt detect themselves in any way, so I had to figure out how PG4UW <a href="https://habr.com/ru/post/430634/">(4)</a> works with this chip.  They did not embed the entire SDK from SanDisk into their software, but created a plugin with the exported methods necessary for running TrueFFS utilities, which are then called from their program. <br>  We will go the same way. <br><br><h4>  Creating your own software module </h4><br>  This disclaimer is based on the fact that the author is not responsible for any use you make of the materials in this article. <br>  In other words - only you yourself will be responsible for your actions, to which you may be motivated to become familiar with this material. <br><br>  <em>Let's agree, as in the previous article, to call the programmer programmer from SuperPro 6100 simply ‚Äúsoftware‚Äù, and the computer on which this program works is ‚Äúhost‚Äù.</em>  <em>Now we have another program that works in the programmer itself.</em>  <em>We will call it ‚Äúsoftware module‚Äù.</em> <br><br>  The Software Utilities for TrueFFS 7.1 manual <a href="https://habr.com/ru/post/430634/">(3)</a> describes the functions implemented by the DOCSHELL utilities, which are divided into the following four categories: <br><br><ul><li>  DFORMAT is a utility for formatting an mDOC device. </li><li>  DINFO - utilities for obtaining various information about mDOC device and sections existing on it. </li><li>  DIMAGE - utilities for reading, writing and comparing the image of an mDOC device. </li><li>  SPLITIMAGE - utilities for splitting the image of an mDOC device into parts. </li></ul><br>  Utilities DOCSHELL intended for the command line, so the interface to communicate with the plugin "DOCSHELL.dll" was implemented using the same mechanism of text commands. <br>  Before you start communicating with the ‚ÄúDOCSHELL.dll‚Äù, you must call each of the exported methods and pass in them pointers to the functions implemented in their software for physical exchange with the mDOC chip.  These are writing and reading (in several modifications), as well as methods for making text messages about the progress of current operations and methods for working with image files. <br><br>  One of the exported ‚ÄúmainEntry‚Äù methods as input argument <br>  accepts ASCIIZ-string - the command described in the ‚ÄúSoftware Utilities for TrueFFS 7.1‚Äù manual <a href="https://habr.com/ru/post/430634/">(3)</a> . <br><br>  The parser inside the ‚ÄúDOCSHELL.dll‚Äù processes the received command and, depending on the command itself and its arguments, calls one or another method from the main software of the programmer using the pointer received during the initial initialization. <br><br>  We decided to write software for the programmer.  This approach, on the one hand, relieved us of ‚Äúdigging‚Äù in the original files to comply with agreements on the exchange of information between the host and the programmer, and on the other, greatly simplified the debugging process, which in the case of integration of the module into the original software made it impossible in some aspects or extremely difficult. <br><br>  Own user interface for the programmer was written in C # in Visual Studio 2017. The sources <a href="https://habr.com/ru/post/430634/">(6)</a> are attached. <br><br>  In the first place, of course, there was a functional, so there was no question of liking the appearance, as well as the text of the source itself.  Therefore, the minimalist "design" of the program is as follows. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/oz/ki/8b/ozki8byinhgupo_k6hvfnzab-oc.jpeg"></div><br>  At the top of the main (and only) window is a menu, for the buttons of which you can assign arbitrary functions.  The menu item ‚ÄúXILINX‚Äù will be described below. <br><br>  Below are two windows.  The upper part displays messages sent from the program to the DOCSHELL.dll plugin and received from it. <br><br>  In the lower window, you can type the commands you need and execute them by double clicking in the corresponding line. <br><br>  When the program starts, some commands will be displayed in it. <br><br>  <em>If suddenly you get to work with a real microcircuit - be careful, because</em>  <em>no warning that you may lose all data during formatting, etc.</em>  <em>The program is not implemented.</em> <br><br>  The file ‚ÄúDOCSHELL.dll‚Äù is found in the directory with the installed program PG4UW <a href="https://habr.com/ru/post/430634/">(4)</a> from ‚ÄúDataman‚Äù (it is also possible from ‚ÄúElnec‚Äù). <br><br>  To be able to use a third-party DLL in your program, you need a header file with a description of the exported methods and their arguments.  For his absence, I had to recover this information on my own.  Methods of such a restoration are beyond the scope of this article, so the arguments of the exported methods can be found in the attached source code. <br><br>  With the user interface in part of its interaction with the plugin, the case has somewhat cleared up.  Now you can go to the implementation of communication with the microcircuit at the physical level in order to be able to execute read / write commands from / to mDOC received from the plugin. <br><br>  The program module for the programmer was written in C in the IDE "IAR Embedded Workbench for ARM".  Sources <a href="https://habr.com/ru/post/430634/">(7)</a> are attached. <br><br>  It was debugged using the JTAG J-Link debugger, which is connected to the programmer via a JTAG connector mounted on the side panel of the case and connected to the motherboard with a flat cable. <br><br>  <em>JTAG debugger J-Link v9 was purchased on Aliexpress.</em>  <em>The drivers installed with IAR Embedded Workbench for ARM work fine with it and even the update of the native firmware from SEGGER was successful.</em> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/md/5e/vq/md5evqm8gj7khtrvdsucwhd5yac.jpeg"></div><br>  Structurally, the programmer is made in the form of eight boards, one above the other and connected together with connectors. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/3v/1n/b6/3v1nb6ntkgimwtwtir0lcekdgmm.jpeg"></div><br>  Adjustable DC-DC converters are placed on the lowest board to form several voltages necessary for operation with various memory chips. <br>  Above it is the motherboard, on which are located the ARM microcontroller ATMEL AT91SAM9G20, SDRAM, SPI FLASH with firmware, the ID chip AE801 with the model of programmer and its serial number, the USB chip of the controller ISP1582, the digital-to-analog converter TLC7226 for controlling the DC-DC converters, a number of other microcircuits and external connectors for connecting the power supply and USB cable for connecting to the host. <br><br>  The third bottom board houses the XILINX XC2S50E chip, which controls the legs of the chip on the adapter connected to the programmer during read / write procedures, etc. <br>  On the other five boards, there are serially loaded registers and assemblies connected to their outputs with transistor switches, through which you can feed shaped DC-DC voltage converters to one or another chip in an adapter, <br>  including the "land".  Since the registers that control the transistor keys are sequential loading, and the number of controllable legs in the adapter can reach 144, it takes considerable time to load all the key blocks.  Therefore, using transistor switches, only static levels are fed to the microcircuit: ground, power, etc.  And using XILINX - dynamic: addresses, data, CS, OE, RD, WR, etc. <br><br>  To advance further, it was necessary, at a minimum, to have a tool for creating firmware for the XILINX XC2S50E microcircuit and a circuit diagram, if not of the entire programmer, then at least its part of the CPU ‚Äî the FPGA adapter of the socket. <br><br>  As for the IDE for XILINX Spartan-IIE, I had to use the old version of ISE 10.1, because  all subsequent IDEs do not support the Spartan-II FPGA model. <br><br>  With the concept of the situation was more difficult.  In order to identify the connections we are interested in, we had to remove the U4 and XILINX U12 processors from the motherboards in order to gain access to the pads under their BGA packages, since  not all of them go to the other side. <br><table><tbody><tr><td><div style="text-align:center;"><img src="https://habrastorage.org/webt/em/i6/xz/emi6xzfj5g9ks4imtdzvrc9mqa0.jpeg"></div></td><td><div style="text-align:center;"><img src="https://habrastorage.org/webt/fl/rg/st/flrgstgrxvaicirr108z0ahlphs.jpeg"></div></td></tr></tbody></table>  The mechanism of communication between the host and the programmer is carried out via USB through several endpoints.  The host always acts as a lead.  Through one of the endpoints, the host transmits a command to the programmer and through it receives a confirmation, <br>  through the other exchange data between themselves. <br><br>  Parsing commands from the host in a software module is done in the USB_ReceiveBuf_EP1RX_Parse () method. <br><br>  The command packet is described by the CMD_PROG structure and consists of several fields.  If the Cmd field contains 1, then this is the command for working with the microcircuit and the ProgProcNum field in this case is the index in the _progProcedures array of PROG_PROC structures, in one of the fields of which the pointer to the command being executed is stored. <br><br>  In the directory with the installed program "SUPERPRO 6100N" is the subdirectory "\ lib".  XILINX firmware files for all types of microcircuits supported by the programmer are stored in it with the extension "* .bin".  Among them there are two universal firmware for checking the contact of the legs of the chip with the contacts sockets in the adapter. <br><br>  These are the ‚ÄúGENERAL ~ .BIN‚Äù with the inner pull-up of all XILINX pull-up legs and the GENERAL_.BIN with the inner pull-down pull-up. <br><br>  Checking the contact of the legs of the chip is carried out in the SOCKET_CkeckInsertIC () method of the program module as follows. <br><br>  First, the ‚ÄúGENERAL_.BIN‚Äù firmware is loaded into XILINX and with its help all the FPGA legs connected to the socket are tuned to the output and logical ‚Äú1‚Äù are fed to them.  Then, each FPGA leg is alternately tuned to the input, a logical level is read from it, and then ‚Äú1‚Äù is output to this leg again. <br><br>  If the chip foot has electrical contact with the corresponding foot sockets, then it should read "1" (through the internal protective diodes of the chip from all other legs).  And if there is no contact due to the fact that all the FPGA pins are pulled into the ‚Äúground‚Äù from this input, ‚Äú0‚Äù will be read.  After that, the array of logical levels read in this way is sent to the host and processed there.  Then the execution of the specified operation proceeds, or a message about the non-contact of the corresponding legs of the chip in the socket is displayed. <br>  After successfully passing this test, the host sends to the programmer the XILINX firmware corresponding to the chip installed in the adapter. <br><br>  Compiling a program for FPGA in ISE 10.1 (sequential execution of synthesis procedures (Synthesize), implementation of design (Implement Design) and generation of files for programming (Generate Programming File)) creates in the project directory a binary configuration file "xeltek.bin" of 78756 bytes in size.  <em>To do this, two options must be set in the properties of the Generate Programming File process in the Processes window in the General Options category: Create Bit File and Create Bibary Configuration File.</em> <br><br>  It is not known for what reasons, but programmers from XELTEK decided to modify the files obtained in this way by mirroring all the bits in each byte. <br><br>  If for some reason you need to ‚Äúmirror‚Äù your own file in this way, or to ‚Äúmirror‚Äù the file from the "\ lib" directory back to normal, in the software in the "XILINX" menu there is a ‚ÄúBitstream Converter‚Äù item (at the end of the resulting file is underlined). <br><br>  To work with the SDED5 chip on the physical level, the following four methods are implemented in the software module: <br><br>  - PROGPROC_FLWRITE_IO_WORD () - write a word (16 bits) at a given address <br>  - PROGPROC_FLREAD_IO_WORD () - read words (16 bits) at a given address <br>  - PROGPROC_hal_blk_write_nor () - write one or several sectors (512 bytes) at a given address <br>  - PROGPROC_hal_blk_read_nor () - reading one or several sectors (at 512 bytes) at a given address <br><br>  To interact with the FPGA XILINX, we identified four registers in our firmware (the I / O ports described in the common.h file of the ARM sources). <br><br>  - _IC_ADDR (0x30000010) <br>  - _IC_DATA (0x30000012) <br>  - _IC_CTRL (0x30000014) // Out: 0 - WE, 1 - 0E, 2 - CE, 3 - RSTIN;  In: 0 - BUSY <br>  - _IC_ENABLE (0x30000016) // In: 7 - Work enable (0 - active, 1 - all the legs on the socket in Z) <br><br>  _IC_ADDR and _IC_DATA are the 16-bit address and data registers for the programmable chip SDED5; <br>  _IC_CTRL - 8-bit control register, through which the WE, OE, CE and RSTIN signals are set and the BUSY signal is read from SDED5. <br><br>  The original software modules for communication with FPGA use addresses from 0x30000000 to 0x3000000E.  The CPLD with the XELTEK inscription is set as the address decoder in the programmer, and since its firmware is not known to us, we, just in case, used addresses with 0x30000010 to reduce the likelihood of unexpected consequences from the manifestation of someone else's behavior when using "standard" addresses. <br><br>  After loading the FPGA of its firmware, all the FPGA outputs connected to the legs of the chip in the socket are in the Z state and to start working with it you need to enable the resolution by writing zero to the seventh bit of the _IC_ENABLE register. <br><br>  The algorithm of the entire system may look as follows. <br><br><ol><li>  After starting the software on the host, it checks if there is a connection to the programmer via USB and displays the corresponding message in the status line at the bottom of the main window <br>  (the programmer can be connected after the start of the program). </li><li>  The user selects the type of chip with which he intends to work. </li><li>  In the database (in the simplest case, just in the file) there is a match between the selected chip and the type of adapter required, and a request is sent to the programmer for the type of adapter installed in it. </li><li>  The programmer asks the adapter for its type and sends this information back to the host, where this information is compared with that found in the database and if the adapter types match, the work continues. </li><li>  For each type of chip selected, a corresponding menu should be displayed in the software with the commands available for that chip (read, write, check for purity, compare, etc.). </li><li>  When you select any menu item for working with a chip, the corresponding command is sent to the programmer, after which the programmer first checks whether there is an electrical contact between the sockets and the legs of the chip, and then, if successful, executes this command. </li></ol><br>  <em>In the source code attached to the article to simplify the task, the items from the second to the fifth inclusive are not implemented.</em> <br><br><h4>  Total </h4><br>  We were not faced with the task of integrating the software module into the original software, <br>  therefore, the material described in this article does not claim to be complete. <br>  We hope that the information presented here will be useful for a certain category of readers, and we will try to answer your questions as far as possible and free time. <br><br>  Thank you for your interest! <br><br><h4>  Resources </h4><br>  one. <a name="ref1"></a>  <a href="http://fornida.com/wp-content/uploads/2015/06/SDED5-Datasheet.pdf">PDF - mDOC H3 Embedded Flash Drive (EFD) featuring Embedded TrueFFS Flash Management Software</a> <br>  2 <a name="ref2"></a>  <a href="https://www.dataman.com/downloads/dl/file/id/235/product/0/dataman_mdoc_h3_flash_memories.pdf">PDF - Programming mDOC H3 Flash Memories Using Dataman Device Programmers</a> <br>  3 <a name="ref3"></a>  <a href="http://unit01.ru/download/m-system/trueffs_manual.pdf">PDF - Software_Utilities_TrueFFS_7.1</a> <br>  four. <a name="PG4UW"></a>  <a href="">Dataman Control Software - PG4UW</a> <br>  five. <a name="linux"></a>  <a href="">Implementation of the mDOC H3 driver for Linux (performance not tested)</a> <br>  6 <a name="refSrcHost"></a>  <a href="https://github.com/beketata/sded5-prog">Source files for the host programmer (Visual Studio 2017).</a> <br>  7 <a name="refSrcModule"></a>  <a href="https://github.com/beketata/sded5-algo">Source files of the program module (IAR Embedded Workbench for ARM v8.30.1).</a> <br>  eight. <a name="refSrcFPGA"></a>  <a href="https://github.com/beketata/sded5-fpga">Source files for FPGA XILINX XC2S50E (XILINX ISE 10.1).</a> </div><p>Source: <a href="https://habr.com/ru/post/430634/">https://habr.com/ru/post/430634/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../430620/index.html">Functional thinking. Part 4</a></li>
<li><a href="../430622/index.html">Functional thinking. Part 5</a></li>
<li><a href="../430626/index.html">Announcement of Moscow GraphQL Meetup</a></li>
<li><a href="../430628/index.html">Forchun algorithm, implementation details</a></li>
<li><a href="../430630/index.html">Comparison sneak "Two Balls" from the 60s and 2016. From the sole to the laces</a></li>
<li><a href="../430636/index.html">Cerebellum and basal nuclei instead of a crystal ball: how the brain predicts the future</a></li>
<li><a href="../430640/index.html">Red Sea: why Apple and other technology companies are falling</a></li>
<li><a href="../430642/index.html">The direction of "Photonics" at the Olympiad "I am a professional", or how to enter the magistracy without exams</a></li>
<li><a href="../430644/index.html">New vulnerability in Facebook leads to leakage of users' personal data.</a></li>
<li><a href="../430646/index.html">.Net Binary serialization without reference to the assembly with the original type or how to negotiate with BinaryFormatter</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>