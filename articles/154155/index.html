<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Lecture number 02: MSP430. Cities and Registers</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Translator's note: Not so long ago, the LaunchPad I ordered came to me. The only thing I wanted then was to immediately start flashing the LEDs. So I ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Lecture number 02: MSP430. Cities and Registers</h1><div class="post__text post__text-html js-mediator-article">  Translator's note: Not so long ago, the LaunchPad I ordered came to me.  The only thing I wanted then was to immediately start flashing the LEDs.  So I ran into the first problem - I have Linux.  After reading about the main IDE for development for this platform, I realized that nothing good shines for me here.  And the use of Energia, just simply did not allow religion.  I have a habit (I don‚Äôt know if it‚Äôs good or not) not to work with such tools of ‚Äúincreased abstraction‚Äù until I study the background of what I‚Äôm working with.  Therefore, Energia quickly dropped out of the options.  Only one thing remains - to assemble the gcc-msp430 toolchain, which includes everything you need.  My laptop is very weak, so I was going to this toolchain for half a day already.  That in no way pleased me, since I already wanted to FLASH.  When collected, faced with the following difficulty.  Very little Russian-language literature and help on this microcontroller.  Something asked among the habrovchan, something was somehow able to pull out of the code examples from TI, but the problem remained - I had little understanding of everything I was doing.  It lasted exactly until I came across a <a href="http://mspsci.blogspot.com/">wonderful English-language blog</a> , which, although in English, explained all the basics fairly well.  I began to read and translate it.  I admit honestly, I wrote this translation not so much for Habra as for myself, in order to understand the material presented 100%.  To say that I understood everything 100% - to lie a little.  Frankly speaking, I‚Äôm far from electronics, at the time of the launch pad I had zero knowledge in this field.  Therefore, some moments of the translation may, probably, make the more serious developers cry in tears of blood.  For example - Vcc and Vss or PxREN.  I understand the idea, but I doubt that I translated it technically competently.  However, I tried to translate so that it was clear to the same zero as me.  In general, if that - do not blame me.  How could.  In addition, there are paragraphs in the translations that are written purely by myself in order to chew the material in a little more detail. <br>  Oh, yes, I began to translate from lecture 02, because the first ‚ÄúIntroductory‚Äù lecture contains too much water, which is already the sea and in the vast Habra, and indeed the Internet.  We want to work right away, not read about how well TI did when releasing cheap LaunchPads. <br><a name="habracut"></a><br>  So. <br><br>  Most of the articles on MSP430, what I have seen, almost from the first lines told about processor architecture, memory addressing, data buses and other technical things, which, unfortunately, a person without experience in electronics is hard to understand.  In this article I will try to explain to you the basics necessary to start working with this family of microcontrollers (hereinafter referred to as MK), without any abstruse things like bipolar connections and the like.  Deep technical knowledge would be very helpful in fine-tuning the system being developed or programming in assembly language, but also elementary knowledge of the C language is enough to begin quite comfortable and productive work. <br><br>  One of the features that distinguishes the MSP430 microcontroller from the main mass is the von Neumann architecture: all the data that the processor can operate with are located in the same address space.  The rest of the microcontrollers are different in this respect: their data can be located in different address spaces, which increases the efficiency, but considerably complicates the work with them, but oh, how we don‚Äôt want it.  To quickly understand what it is about, you can imagine a microcontroller as a city: in the background Neumann cities (like MSP430) all people live in the same city and have their own unique address.  Well, for example, there are several cities in Harvard architecture, therefore addresses can be repeated.  Thus, if you want to send a letter to a specific address, you will first have to specify the city. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  Memory </h2><br>  The MSP430's address space includes the area for storing the program itself, the area for storing the data needed by this program, RAM, and other important information that we will look at later on.  Today we will satisfy all your insatiable craving for knowledge by studying addresses in memory, which are called ‚Äúregisters‚Äù.  These addresses are like various municipal and social services (such as post office or housing and communal services) in our small MSP430 town.  In our microcontroller, the registers control various functions of the processor and peripherals.  Imagine a room with many different switches and buttons on which it depends whether tomorrow in your area will turn on heating or hot water - these will be our registers.  Like any other switches, they have only two states - ‚Äúon‚Äù and ‚Äúoff‚Äù, in computer language - 1 and 0. In the microcontroller, the state of the registers determines how one or the other periphery will behave, for which one or another leg of your MK, what happens when a certain event occurs, and so on and so forth.  The registers in MSP430 are grouped into 3 sections: <br>  1) Special Functions Register <i>(English: Special <b>F</b> Unction <b>R</b> egisters (SFR))</i> . <br>  (comment of the translator .: similar abbreviations should be remembered, or at least recorded, in the future, they will be used quite often) <br>  2) 8-bit registers for various processor peripherals (for storing the ‚Äúsettings‚Äù of the peripherals with which only 8 bits are sufficient) <br>  3) 16-bit registers (the same, only 16 bits are allocated). <br>  As an example, let's take a look at the smallest member of the MSP430 family, namely the MSP430G2001 microcontroller.  Open the following documents: <a href="http://www.ti.com/litv/pdf/slau144i">x2xx series description</a> and <a href="http://www.ti.com/litv/pdf/slas695g">G2x01 specifications</a> . <br><br>  <i>Note that the above links may be non-existent, this happens if Texas Instruments does update the documentation.</i>  <i>The easiest way to find these documents is to go to the official TI website and find the ‚ÄúSearch by Part Number‚Äù block.</i>  <i>In order to find the documentation on the G2x01 series, it is enough to enter any marking that falls under this mask, for example msp430g2001.</i> <br><br>  Let's take a look at the fourth part of the first chapter (Address Space) of the x2xx series description <i>(English: family guide)</i> , which illustrates the map of our ‚Äútown‚Äù of the x2xx family.  As you can see, the SFR registers are located starting at address 0h and ending at Fh (the h character indicates that the address is written in hexadecimal; in decimal, they would look like 0 and 15).  Next come the 8-bit registers;  their addresses begin with 010h and end with the address 0FFh (in the decimal system: from 16 to 255), then, from the address 0100h to 01FFh there are 16-bit registers.  You have probably noticed a huge empty space between the operating and flash memory areas <i>(note: do not confuse flash memory with USB drives or other external storage devices, in this case, flash memory is ‚Äúreprogrammable memory‚Äù)</i> .  The description of this series of microcontrollers shows us the areas of memory that belong to the entire x2xx family, in order to see the exact values ‚Äã‚Äãfor any particular microcontroller, you need to refer to the specifications of this chip, called datasheet <i>(Eng .: datasheet - get used to this name, everywhere it is used exactly)</i> . <br><br>  The eleventh page of datasheet provides us with a memory map, which fits all microcontrollers of the G2x01 and G2x11 series.  Looking at the bar from G2001, you can see that the service peripherals registers (SFR, 8-bit, 16-bit) go first, then 128 bits of RAM are used.  The address space, starting at address 0201h and ending with 10FEh, is empty; after it we see 256-bit memory, called the service memory area (this memory area stores calibration data and other important values ‚Äã‚Äãthat need to be saved if the device has stopped receiving power Usually this data is not available for rewriting, but this does not mean that it is impossible under real need, but it is a separate story that deserves a separate lecture).  As a result, we have 512 bytes of memory for program code and, to top it all, the memory allocated for interrupt vectors (but this is also discussed in another lecture). <br><br><h2>  Registers </h2><br>  Now we can see how our ‚ÄúG2001-town‚Äù looks from the inside, therefore, we should figure out how to work with the very ‚Äúswitch houses‚Äù that we described above.  The registers in the MSP430 microcontroller are special sections in memory, with the help of which it is configured and which inform us when something important happens.  Page 10 of our datasheet shows which special function registers (SFR) are available in our G2001.  As we can see, this device has only four registers of specials.  functions located at addresses 0h through 3h: interrupt enable register 1 <i>(English: <b>I</b> nterrupt <b>E</b> nable 1 (IE1))</i> , interrupt enable register 2 (IE2), and two register interrupt flags IFG1 and IFG2 <i>(English: <b>I</b> nterrupt <b>F</b> la <b>G</b> Register)</i> .  Each address points to 1 byte in memory, and in one byte, as we know, 8 bits.  Remember our ‚Äúswitch houses‚Äù?  So, each bit in the register performs the role of one switch.  Thus, the register itself is a home, and its every bit is a switch that has two states 0 (off) and 1 (on).  Each of these bits is very important, the state of each of them in one way or another affects the operation of the microcontroller and its behavior in general.  Page 10 also shows us which bits in these registers are available on our G2001. <br><br>  In this case, in the IE1 register, only 0, 1, 4, and 5 bits are available to us, while in IFG1 all bits from 0 to 5 are available to us. The datasheet contains full information about the name of each of these bits and what function it performs.  For example, the zero bit in the IE1 register is called WDTIE ‚Äî the resolution of the watchdog timer interrupt <i>(English: <b>W</b> atch <b>D</b> og <b>T</b> imer <b>I</b> nterrupt Enable)</i> .  By default, this bit is set to 0, but if we change it and set it to 1, we will allow the watchdog timer to ‚Äúraise‚Äù the interrupt flag in the IFG1 register (bit number 0, to be exact), thereby causing an interrupt (as already it was said that we will consider such interruptions later).  Simply put, this bit tells our MSP430 whether the watchdog timer can signal the processor to do something or use it normally.  It would probably be worth explaining what a watchdog is and what its ‚Äúnormal‚Äù mode is.  A watchdog timer is needed in order to reset the processor to the state in which it was at the time the power was applied.  He drops it regularly, at a certain interval.  Why is it necessary?  If a program crashes while the program is running, the watchdog timer resets the program so that it can work again.  Of course, you can disable it.  When we translate the watchdog timer into an interval mode, instead of resetting our program, it simply sends a signal to the processor.  How to handle this signal and what to do when the processor receives this signal - this decision falls on the programmer‚Äôs shoulders.  This is usually used to perform any cyclical actions.  For example, in the most elementary case to blink an LED, than we and we will soon be engaged. <br><br>  Now take a look at page 14 of our datasheet.  This table provides us with all the information about existing peripheral ‚Äúdevices‚Äù, the addresses of their registers and their names.  Incidentally, at the bottom of the table is the information about SFR, which we have repeatedly mentioned in this article.  Thus, when you want to use any peripherals of your microcontroller, this table will be your starting point in order to find out exactly which ‚Äúswitch houses‚Äù you need to visit in order to be sure that all your registers are configured correctly.  Today, we will take a closer look at the registers intended for port 1 (Port P1) and port 2 (Port P2), since they are the main elements that are needed to work with our microcontroller. <br><br>  Ports are the main input / output devices available on the microcontroller, input / output is done through the legs <i>(English: pin) of</i> your MK.  You can see the pinout of your device on the third page of the datasheet.  A port usually means a set of 8 pins of a microcontroller.  But the pins at the port may be less, it happens if the legs are simply not enough to complete the set.  The pinout shown in the datasheet shows us that the G2001 has a full set of 8 legs for port 1 (c P1.0 to P1.7) and two legs for port 2 (p2.6 to P2.7).  Each register of each port has a bit that corresponds to the corresponding leg of the microcontroller.  For example, P1.4 is controlled by the 4th bit of each register that belongs to port 1 (P1).  Let's take a closer look at the registers that the microcontroller offers us. <br><br><h3>  Pxin </h3><br>  An input register (input mode) whose values ‚Äã‚Äãare in <i>read-only</i> mode <i>(English: read-only)</i> .  If the direction of the foot was selected as ‚Äúincoming‚Äù <i>(English: <b>IN</b> put)</i> , then the value of this register will tell you whether the voltage is currently applied to this foot or not.  It should be understood that reading the value of the PxIN register returns you data on all the legs of the corresponding port at a time.  You should not forget that this is digital technology, so each bit read can only be in two states: 1 or 0. These values ‚Äã‚Äãshow us what voltage is applied to the leg: Vss (if the value is 0) or Vcc (if a value of 1), a value of 0 is accepted if the applied voltage is below 1.8 volts (Vss &lt;1.8V), and a value of 1 is accepted if the supplied voltage falls in the range between 1.8 and 3.6 volts (1.8V &lt;= Vcc &lt;= 3.6V).  To avoid damage to your device, NEVER try to directly apply voltage above the Vcc high threshold.  In a nutshell, Vcc is voltage, and Vss is earth. <br><br><h3>  PxOUT </h3><br>  "Output" register (output mode), available for writing.  When a certain pin of your microcontroller is set to ‚Äúoutput mode‚Äù <i>(English: <b>OUT</b> put)</i> , you can energize it by simply setting the corresponding bit in this register to 1. Just as in the PxIN register, with a value of 0, voltage is applied to the leg with Vss, if 1 - Vcc. <br><br><h3>  PxDIR </h3><br>  The direction register <i>(English: <b>DIR</b> ection)</i> determines the pin to the input mode, if the corresponding bit of this register is set to 0 and to the output mode, if 1. At the very beginning of your program, you must specify all the pin directions you plan to use.  Of course, this does not mean that you cannot change these values ‚Äã‚Äãsomewhere in the middle of the program. <br><br><h3>  PxIE, PxIES, and PxIFG </h3><br>  The following three registers are available at our ports: the interrupt enable register <i>(English: <b>I</b> nterrupt <b>E</b> nable (IE))</i> , the control interrupt register <i>(English: <b>I</b> n interrupt <b>E</b> dge <b>S</b> elect (IES))</i> and the interrupt flag register <i>(eng. : <b>I</b> nterrupt <b>F</b> laG (IFG))</i> .  We consider these three registers together, since working with any of these registers involves working with the two remaining ones, they are inseparable from each other.  What is interruption?  At the moment, it will be enough for you to simply imagine that this is a kind of message sent to the processor, upon receipt of which it suspends all its affairs and begins to perform the actions that are prescribed for execution upon receipt thereof.  As soon as he completes the processing of the interrupt, the processor returns to its previous work as if nothing had happened and continues the execution of the main program.  To allow a specific pin of your port to generate interrupts, you simply ‚Äúraise‚Äù (set to 1) the corresponding bit in the interrupt enable register (PxIE where x is the port number).  The control interrupt register (PxIES) contains control bits (edge-bits) with which the current state of the PxIN register is compared.  Simply put, if you have legs that are assigned to the input-mode in the PxDIR register (the bits corresponding to the legs are assigned the value 0), then the PxIN register is compared in bits to all the values ‚Äã‚Äãof the PxIES register and if it happens that the values ‚Äã‚Äãof the corresponding bits in these registers have different meanings, the next thing the processor does is to check if interrupt legs are allowed for these legs ‚Äî compares with the PxIE register ‚Äî and if interrupts are enabled ‚Äî an interrupt is generated, and this, in turn, is nothing more than a ‚Äúraise‚Äù corresponding bits  in the PxIFG register (interrupt flag register). <br>  Once again in brief: the interruption for a certain leg of your microcontroller is considered generated if a flag is raised in the PxIFG register (the bit has assumed the value 1) which corresponds to this leg with its sequence number.  The PxIE register bits determine which legs of your microcontroller are allowed to raise these flags, if in the PxIE register the bit with the sequence number 0 is 0, then this leg simply does not have access to the PxIFG register, and therefore cannot generate interrupts.  The PxIES register stores control values.  The processor comparing the PxIN and PxIES registers generates interrupts for the legs, the bits of which in these registers differ. <br><br><h3>  PxSEL </h3><br>  If you look again at the third page of our datasheet, where the pinout of our microcontroller is shown, you can see that each leg has several functions, which are separated by a slash.  This selection register <i>(English: <b>SEL</b> ection Register)</i> determines which function a pin will perform.  The function that a particular foot performs by default is listed first - so we can see that all the legs of the first port (P1) are by default just configured for input and output <i>(I / O - Input / <b>O</b> utput)</i> , while as the legs of the P2 are by default connected to a quartz oscillator.  Changing the bits in PxSEL will change the basic function of the corresponding foot.  We will consider all this later, now our main task is to learn how to use standard functions that are predefined in this register. <br><br><h3>  PxREN </h3><br>  The resistor enable register <i>(English: <b>R</b> esistor <b>EN</b> able register)</i> is a very convenient port function.  Sometimes it is necessary to manually apply the voltage or, on the contrary, to stop the supply thereof.  For example, if you connect a button to your microcontroller.  The resistor enable register gives you this opportunity.  When the bit corresponding to your pin in this register is ‚Äúraised‚Äù, the pitch can be adjusted by setting the same bit in the PxOUT register to 1 or 0. <br><br>  Well, we looked at some of the ‚Äúswitches‚Äù available to us, so in order to consolidate what we have covered, in the next article we will look at how to use them when writing our program and downloading it to our device. <br><br>  <a href="http://mspsci.blogspot.com/2010/07/tutorial-02-msp430-township-and.html">Original article.</a> <br>  A separate ‚Äúthank you‚Äù, I would like to say to Megafon, which for some reason has blocked access to this blog. </div><p>Source: <a href="https://habr.com/ru/post/154155/">https://habr.com/ru/post/154155/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../154133/index.html">Introduction to working with AppHarbor - a cloud for ASP.NET applications</a></li>
<li><a href="../154139/index.html">Surprisingly simple but beautiful CSS effect.</a></li>
<li><a href="../154141/index.html">HP Dynamic VPN technology. Part 1</a></li>
<li><a href="../154149/index.html">Digest news JetBrains from September 11 to October 9</a></li>
<li><a href="../154151/index.html">New attachments in Yandex.Mail</a></li>
<li><a href="../154165/index.html">The future of the process, or when the law of Moore "die"?</a></li>
<li><a href="../154167/index.html">Optimize complex MySQL queries</a></li>
<li><a href="../154169/index.html">Using the capabilities of Wolfram Mathematica in .NET applications</a></li>
<li><a href="../154177/index.html">TeamLab - reboot</a></li>
<li><a href="../154179/index.html">AWS: RDS appeared in the Free Tier package</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>