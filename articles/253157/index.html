<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Haskell Range Control Arithmetic with Type-Level Literals</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Functional programming (FP), as is well known, contributes to writing reliable (error-free) code. 

 Clearly this is a maxim. There are no programs wi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Haskell Range Control Arithmetic with Type-Level Literals</h1><div class="post__text post__text-html js-mediator-article">  Functional programming (FP), as is well known, contributes to writing reliable (error-free) code. <br><br>  Clearly this is a maxim.  There are no programs without errors.  However, the OP in combination with the strict static typification and development of the type system allows, to a large extent, to reveal the inevitable errors of the programmer at the compilation stage.  I'm talking about Haskell, although it probably also applies to OCaml. <br><br>  However, if we set ourselves the goal of writing reliable code, we will immediately discover that the possibilities of Haskell are not endless here.  Not everything that exists for this purpose (building secure code) in other languages ‚Äã‚Äãis easily implemented in Haskell.  It would be nice if they corrected me here, but alas <br><a name="habracut"></a><br>  First of all, of course, you should pay attention to the Hell language (to a lesser extent, related to her pascal), which was specially developed for reliable code writing.  And although the ideology of Ada, in my opinion, has long been outdated, the syntax draws fossils from the 80s, and some ideas that supposedly increase the security of the code now cause a grin.  For all of this, Ada has a developed system of static and dynamic data verification for given conditions ( <b>data validation</b> , <b>constraint validation</b> ).  Simply put, every time a variable is updated, the compiler can add to the output code the execution of the test we set.  The simplest and most common case is <b>range validation</b> - the value is outside the specified limits.  Such control is in pascal.  Without claiming to replace Ada (it is a standard in the military, in avionics, etc.), we will try to get closer to Ada‚Äôs safety standards by making Haskell <b>range validation</b> , for a start.  Obviously, it is necessary to overload the arithmetic functions (this is at least) of the class <b>Num</b> , by setting the range control in them and throwing exceptions when it exceeds its limits. <br>  Immediately we run into the problem - in the arithmetic functions of the class Num, of the form <br><pre><code class="haskell hljs">(+) :: a -&gt; a -&gt; a</code> </pre> <br>  There is no place to set the boundaries of the tested range.  What can be done? 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b><u>Option 1</u></b> .  Create a record of three numbers - the boundaries of the range and value to be processed, and determine (instantiate) for such a record <b>Num</b> .  The disadvantage is obvious.  It would be enough for us to store the boundaries of the ranges in one copy for each type, but not for each value (there may be 100,000). <br><br>  <b><u>Option 2</u></b> .  We can specify checks with hard boundaries in the class generated by Template Haskell.  This option is quite possible.  With the help of TH, we can do everything.  But let's try to find a way to set the boundaries of the range at compile time in some other way. <br><br>  <b><u>Option 3</u></b> .  Relatively recently, starting from GHC 7.8, if I do not confuse, an opportunity has appeared, called the <a href="https://downloads.haskell.org/~ghc/7.8.2/docs/html/users_guide/type-level-literals.html">Type-Level Literals</a> , i.e.  assignments of constants in the description of types, which, moreover, can be used in functions. <br><br>  Let's try to implement <b>range validation</b> using this mechanism. <br><br>  For a controlled number, we will not economically start a full data type, we will write, requiring less expense during the execution of a newtype. <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">newtype</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">RgVld</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">lo</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Nat</span></span></span><span class="hljs-class">) (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">hi</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Nat</span></span></span><span class="hljs-class">) a = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">RgVld</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">unRgVld</span></span></span><span class="hljs-class"> :: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class"> } </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">deriving</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Eq</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Ord</span></span></span><span class="hljs-class">)</span></span></code> </pre><br>  RgVld is short for <b>range validation</b> .  And <b>lo</b> and <b>hi</b> , having the type <b>Nat</b> (defined in <b>GHC.TypeLits</b> ) are the very constants in the definition of the type - the boundaries of the range.  Here they are integers (converted to Integer, but can not be negative, alas).  There are more string - but to describe the restrictions of the string and convert to string in runtime - no, we do not write in the script. <br><br>  Actually, this type is the essence of the implementation of <b>range validation</b> .  For him, you can now create: <br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">instance</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">KnownNat</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">lo</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">KnownNat</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">hi</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Num</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Ord</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Show</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">) =&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Num</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">RgVld</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">lo</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">hi</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> (<span class="hljs-type"><span class="hljs-type">RgVld</span></span> l) + (<span class="hljs-type"><span class="hljs-type">RgVld</span></span> r) = chkVld <span class="hljs-string"><span class="hljs-string">"(+)"</span></span> $ <span class="hljs-type"><span class="hljs-type">RgVld</span></span> $ l+r (<span class="hljs-type"><span class="hljs-type">RgVld</span></span> l) - (<span class="hljs-type"><span class="hljs-type">RgVld</span></span> r) = chkVld <span class="hljs-string"><span class="hljs-string">"(-)"</span></span> $ <span class="hljs-type"><span class="hljs-type">RgVld</span></span> $ lr (<span class="hljs-type"><span class="hljs-type">RgVld</span></span> l) * (<span class="hljs-type"><span class="hljs-type">RgVld</span></span> r) = chkVld <span class="hljs-string"><span class="hljs-string">"(*)"</span></span> $ <span class="hljs-type"><span class="hljs-type">RgVld</span></span> $ l*r fromInteger n = chkVld <span class="hljs-string"><span class="hljs-string">"fromInteger"</span></span> $ <span class="hljs-type"><span class="hljs-type">RgVld</span></span> $ fromInteger n abs = id signum (<span class="hljs-type"><span class="hljs-type">RgVld</span></span> v) = <span class="hljs-type"><span class="hljs-type">RgVld</span></span> $ signum v</code> </pre><br>  The <b>KnownNat</b> class is also defined in <b>GHC.TypeLits</b> .  Since  checks of the resulting values ‚Äã‚Äãare the same, for them you can create an auxiliary class <br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CheckValidation</span></span></span><span class="hljs-class"> a </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> chkVld:: <span class="hljs-type"><span class="hljs-type">String</span></span> -&gt; a -&gt; a</code> </pre>  (which can be useful for other types of checks) with a single function <b>chkVld</b> , which will pass values ‚Äã‚Äãthat fall into the range and throw an exception for values ‚Äã‚Äãout of range.  Its first argument is a substring in the exception message that shows the function that caused the exception. <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">instance</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">KnownNat</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">lo</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">KnownNat</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">hi</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Num</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Ord</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Show</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">) =&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CheckValidation</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">RgVld</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">lo</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">hi</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> chkVld whr r@(<span class="hljs-type"><span class="hljs-type">RgVld</span></span> v) = <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> lo' = natVal (<span class="hljs-type"><span class="hljs-type">Proxy</span></span> :: <span class="hljs-type"><span class="hljs-type">Proxy</span></span> lo) hi' = natVal (<span class="hljs-type"><span class="hljs-type">Proxy</span></span> :: <span class="hljs-type"><span class="hljs-type">Proxy</span></span> hi) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> v &lt; fromInteger lo' || v &gt; fromInteger hi' <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> throw $ <span class="hljs-type"><span class="hljs-type">OutOfRangeException</span></span> $ <span class="hljs-string"><span class="hljs-string">"out of range ["</span></span> ++ show lo' ++ <span class="hljs-string"><span class="hljs-string">" .. "</span></span> ++ show hi' ++ <span class="hljs-string"><span class="hljs-string">"], value "</span></span> ++ show v ++ <span class="hljs-string"><span class="hljs-string">" in "</span></span> ++ whr <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> r</code> </pre><br>  Naturally, you need to remember to create the exception class itself: <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">OutOfRangeException</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">OutOfRangeException</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">deriving</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Typeable</span></span></span><span class="hljs-class"> instance </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Show</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">OutOfRangeException</span></span></span><span class="hljs-class"> where show (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">OutOfRangeException</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">s</span></span></span><span class="hljs-class">) = s instance </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Exception</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">OutOfRangeException</span></span></span></span></code> </pre><br>  For the <b>RgVld</b> type, <b>we</b> also implement the <b>Show</b> , <b>Read</b> classes, and quite simple, but obviously useful in this case, <b>Bounded</b> . <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">instance</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">KnownNat</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">lo</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">KnownNat</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">hi</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Show</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">) =&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Show</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">RgVld</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">lo</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">hi</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> show (<span class="hljs-type"><span class="hljs-type">RgVld</span></span> v) = show v <span class="hljs-keyword"><span class="hljs-keyword">instance</span></span> (<span class="hljs-type"><span class="hljs-type">KnownNat</span></span> lo, <span class="hljs-type"><span class="hljs-type">KnownNat</span></span> hi, <span class="hljs-type"><span class="hljs-type">Num</span></span> a, <span class="hljs-type"><span class="hljs-type">Ord</span></span> a, <span class="hljs-type"><span class="hljs-type">Show</span></span> a, <span class="hljs-type"><span class="hljs-type">Read</span></span> a) =&gt; <span class="hljs-type"><span class="hljs-type">Read</span></span> (<span class="hljs-type"><span class="hljs-type">RgVld</span></span> lo hi a) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> readsPrec w = \s -&gt; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> readsPrec ws <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> [] -&gt; [] [(v,s')] -&gt; [(chkVld <span class="hljs-string"><span class="hljs-string">"readsPrec"</span></span> $ <span class="hljs-type"><span class="hljs-type">RgVld</span></span> v, s')] <span class="hljs-keyword"><span class="hljs-keyword">instance</span></span> (<span class="hljs-type"><span class="hljs-type">KnownNat</span></span> lo, <span class="hljs-type"><span class="hljs-type">KnownNat</span></span> hi, <span class="hljs-type"><span class="hljs-type">Num</span></span> a, <span class="hljs-type"><span class="hljs-type">Ord</span></span> a, <span class="hljs-type"><span class="hljs-type">Show</span></span> a) =&gt; <span class="hljs-type"><span class="hljs-type">Bounded</span></span> (<span class="hljs-type"><span class="hljs-type">RgVld</span></span> lo hi a) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> minBound = fromInteger $ natVal (<span class="hljs-type"><span class="hljs-type">Proxy</span></span> :: <span class="hljs-type"><span class="hljs-type">Proxy</span></span> lo) maxBound = fromInteger $ natVal (<span class="hljs-type"><span class="hljs-type">Proxy</span></span> :: <span class="hljs-type"><span class="hljs-type">Proxy</span></span> hi)</code> </pre><br>  Since  Since the Ada language, which is strongly associated with the ‚Äúmilitary‚Äù, we assume that our program controls the ICBM with divided warheads.  Suppose they are numbered from one, but there are only 20 of them, and each, of course, carries an atomic bomb - A-bomb, ‚ÄúH-bombs‚Äù.  Reduce to ab.  And here is an auxiliary function for creating an e-bomb: <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">ab</span></span>:: <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">RgVld</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">20</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> ab = <span class="hljs-type"><span class="hljs-type">RgVld</span></span></code> </pre><br>  The variable is the number of the bomb in the MBR, in the range from 1 to 20. If the rocket is upgraded, then the number 20 will need to be changed only in this auxiliary function.  Check it out. <br><br><pre> <code class="haskell hljs">*<span class="hljs-type"><span class="hljs-type">RangeValidation</span></span>&gt; ab <span class="hljs-number"><span class="hljs-number">2</span></span> + ab <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span> *<span class="hljs-type"><span class="hljs-type">RangeValidation</span></span>&gt; ab <span class="hljs-number"><span class="hljs-number">12</span></span> + ab <span class="hljs-number"><span class="hljs-number">13</span></span> *** <span class="hljs-type"><span class="hljs-type">Exception</span></span>: out <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> range [<span class="hljs-number"><span class="hljs-number">1</span></span> .. <span class="hljs-number"><span class="hljs-number">20</span></span>], value <span class="hljs-number"><span class="hljs-number">25</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> (+) *<span class="hljs-type"><span class="hljs-type">RangeValidation</span></span>&gt;</code> </pre><br>  - here and control ranges in Haskell. <br><br>  The attentive reader may argue: "Usually we do not add two numbers in the range, but add an offset to the range type."  Actually, this is not important for this implementation - not the input values ‚Äã‚Äãof the operations are checked, but only the output values, therefore it will not cause interruptions. <br><br><pre> <code class="haskell hljs">*<span class="hljs-type"><span class="hljs-type">RangeValidation</span></span>&gt; ab <span class="hljs-number"><span class="hljs-number">20</span></span> + ab <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">20</span></span> *<span class="hljs-type"><span class="hljs-type">RangeValidation</span></span>&gt;</code> </pre><br>  But, sort of, like, and not beautifully obtained.  We introduce an additional class <br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Num'</span></span></span><span class="hljs-class"> ab </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> (+.) :: a -&gt; b -&gt; a (-.) :: a -&gt; b -&gt; a (*.) :: a -&gt; b -&gt; a</code> </pre>  which implements arithmetic with operands of different types, and make RgVld its instance by defining <br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">instance</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">KnownNat</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">lo</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">KnownNat</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">hi</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Num</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Ord</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Show</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">) =&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Num'</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">RgVld</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">lo</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">hi</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">) a </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> (<span class="hljs-type"><span class="hljs-type">RgVld</span></span> l) +. r = chkVld <span class="hljs-string"><span class="hljs-string">"(+.)"</span></span> $ <span class="hljs-type"><span class="hljs-type">RgVld</span></span> $ l+r (<span class="hljs-type"><span class="hljs-type">RgVld</span></span> l) -. r = chkVld <span class="hljs-string"><span class="hljs-string">"(-.)"</span></span> $ <span class="hljs-type"><span class="hljs-type">RgVld</span></span> $ lr (<span class="hljs-type"><span class="hljs-type">RgVld</span></span> l) *. r = chkVld <span class="hljs-string"><span class="hljs-string">"(*.)"</span></span> $ <span class="hljs-type"><span class="hljs-type">RgVld</span></span> $ l*r</code> </pre><br>  Functions (+.), (-.), (*.) Are similar to ordinary ones, but perform actions with a range type and a regular number.  Example: <br><pre> <code class="haskell hljs">*<span class="hljs-type"><span class="hljs-type">RangeValidation</span></span>&gt; ab <span class="hljs-number"><span class="hljs-number">5</span></span> -. (<span class="hljs-number"><span class="hljs-number">3</span></span> :: <span class="hljs-type"><span class="hljs-type">Int</span></span>) <span class="hljs-number"><span class="hljs-number">2</span></span> *<span class="hljs-type"><span class="hljs-type">RangeValidation</span></span>&gt;</code> </pre>  - yes, the type of the number will have to be specified explicitly if this is a constant. <br><br>  Naturally, the range type is not required to be integer.  Create a helper function to determine the level of fuel. <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">fuel</span></span>:: <span class="hljs-type"><span class="hljs-type">Double</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">RgVld</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">15</span></span> <span class="hljs-type"><span class="hljs-type">Double</span></span> fuel = <span class="hljs-type"><span class="hljs-type">RgVld</span></span></code> </pre><br>  And check the work of the range type when refueling: <br><br><pre> <code class="haskell hljs">*<span class="hljs-type"><span class="hljs-type">RangeValidation</span></span>&gt; fuel <span class="hljs-number"><span class="hljs-number">4.6</span></span> + fuel <span class="hljs-number"><span class="hljs-number">4.5</span></span> <span class="hljs-number"><span class="hljs-number">9.1</span></span> *<span class="hljs-type"><span class="hljs-type">RangeValidation</span></span>&gt; fuel <span class="hljs-number"><span class="hljs-number">9.1</span></span> + fuel <span class="hljs-number"><span class="hljs-number">6</span></span> *** <span class="hljs-type"><span class="hljs-type">Exception</span></span>: out <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> range [<span class="hljs-number"><span class="hljs-number">0</span></span> .. <span class="hljs-number"><span class="hljs-number">15</span></span>], value <span class="hljs-number"><span class="hljs-number">15.1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> (+) *<span class="hljs-type"><span class="hljs-type">RangeValidation</span></span>&gt;</code> </pre>  - Oh no no no.  Pour over! <br><br>  Unfortunately, ‚Äúdue to‚Äù the limitations of the ‚Äútechnology‚Äù used - the <b>Type-Level Literals</b> range is still set to integers.  Maybe the authors of the GHC will improve it (although, in general, it is somewhat conceived by them for another).  In the meantime, we will be happy and with what we met. <br><br>  Full example code: <br><br><pre> <code class="haskell hljs"><span class="hljs-meta"><span class="hljs-meta">{-# LANGUAGE DataKinds, KindSignatures, ScopedTypeVariables, MultiParamTypeClasses, FlexibleInstances #-}</span></span> <span class="hljs-meta"><span class="hljs-meta">{-# LANGUAGE DeriveDataTypeable #-}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">module</span></span> RangeValidation <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Data.Proxy <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> GHC.TypeLits <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Data.Typeable <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Control.Exception data OutOfRangeException = OutOfRangeException String deriving Typeable instance Show OutOfRangeException where show (<span class="hljs-type"><span class="hljs-type">OutOfRangeException</span></span> <span class="hljs-title"><span class="hljs-title">s</span></span>) = s instance Exception OutOfRangeException class CheckValidation a where chkVld:: String -&gt; a -&gt; a instance (<span class="hljs-type"><span class="hljs-type">KnownNat</span></span> <span class="hljs-title"><span class="hljs-title">lo</span></span>, <span class="hljs-type"><span class="hljs-type">KnownNat</span></span> <span class="hljs-title"><span class="hljs-title">hi</span></span>, <span class="hljs-type"><span class="hljs-type">Num</span></span> <span class="hljs-title"><span class="hljs-title">a</span></span>, <span class="hljs-type"><span class="hljs-type">Ord</span></span> <span class="hljs-title"><span class="hljs-title">a</span></span>, <span class="hljs-type"><span class="hljs-type">Show</span></span> <span class="hljs-title"><span class="hljs-title">a</span></span>) =&gt; CheckValidation (<span class="hljs-type"><span class="hljs-type">RgVld</span></span> <span class="hljs-title"><span class="hljs-title">lo</span></span> <span class="hljs-title"><span class="hljs-title">hi</span></span> <span class="hljs-title"><span class="hljs-title">a</span></span>) where chkVld whr r@(<span class="hljs-type"><span class="hljs-type">RgVld</span></span> <span class="hljs-title"><span class="hljs-title">v</span></span>) = let lo' = natVal (<span class="hljs-type"><span class="hljs-type">Proxy</span></span> :: <span class="hljs-type"><span class="hljs-type">Proxy</span></span> <span class="hljs-title"><span class="hljs-title">lo</span></span>) hi' = natVal (<span class="hljs-type"><span class="hljs-type">Proxy</span></span> :: <span class="hljs-type"><span class="hljs-type">Proxy</span></span> <span class="hljs-title"><span class="hljs-title">hi</span></span>) in if v &lt; fromInteger lo' || v &gt; fromInteger hi' then throw $ OutOfRangeException $ "out of range [" ++ show lo' ++ " .. " ++ show hi' ++ "], value " ++ show v ++ " in " ++ whr else r newtype RgVld (<span class="hljs-title"><span class="hljs-title">lo</span></span> :: <span class="hljs-type"><span class="hljs-type">Nat</span></span>) (<span class="hljs-title"><span class="hljs-title">hi</span></span> :: <span class="hljs-type"><span class="hljs-type">Nat</span></span>) a = RgVld { unRgVld :: a } deriving (<span class="hljs-type"><span class="hljs-type">Eq</span></span>, <span class="hljs-type"><span class="hljs-type">Ord</span></span>) instance (<span class="hljs-type"><span class="hljs-type">KnownNat</span></span> <span class="hljs-title"><span class="hljs-title">lo</span></span>, <span class="hljs-type"><span class="hljs-type">KnownNat</span></span> <span class="hljs-title"><span class="hljs-title">hi</span></span>, <span class="hljs-type"><span class="hljs-type">Num</span></span> <span class="hljs-title"><span class="hljs-title">a</span></span>, <span class="hljs-type"><span class="hljs-type">Ord</span></span> <span class="hljs-title"><span class="hljs-title">a</span></span>, <span class="hljs-type"><span class="hljs-type">Show</span></span> <span class="hljs-title"><span class="hljs-title">a</span></span>) =&gt; Num (<span class="hljs-type"><span class="hljs-type">RgVld</span></span> <span class="hljs-title"><span class="hljs-title">lo</span></span> <span class="hljs-title"><span class="hljs-title">hi</span></span> <span class="hljs-title"><span class="hljs-title">a</span></span>) where (<span class="hljs-type"><span class="hljs-type">RgVld</span></span> <span class="hljs-title"><span class="hljs-title">l</span></span>) + (<span class="hljs-type"><span class="hljs-type">RgVld</span></span> <span class="hljs-title"><span class="hljs-title">r</span></span>) = chkVld "(+)" $ RgVld $ l+r (<span class="hljs-type"><span class="hljs-type">RgVld</span></span> <span class="hljs-title"><span class="hljs-title">l</span></span>) - (<span class="hljs-type"><span class="hljs-type">RgVld</span></span> <span class="hljs-title"><span class="hljs-title">r</span></span>) = chkVld "(-)" $ RgVld $ lr (<span class="hljs-type"><span class="hljs-type">RgVld</span></span> <span class="hljs-title"><span class="hljs-title">l</span></span>) * (<span class="hljs-type"><span class="hljs-type">RgVld</span></span> <span class="hljs-title"><span class="hljs-title">r</span></span>) = chkVld "(*)" $ RgVld $ l*r fromInteger n = chkVld "fromInteger" $ RgVld $ fromInteger n abs = id signum (<span class="hljs-type"><span class="hljs-type">RgVld</span></span> <span class="hljs-title"><span class="hljs-title">v</span></span>) = RgVld $ signum v infixl 6 +.,-. infixl 7 *. class Num' ab where (+.) :: a -&gt; b -&gt; a (-.) :: a -&gt; b -&gt; a (*.) :: a -&gt; b -&gt; a <span class="hljs-comment"><span class="hljs-comment">-- (/.) :: a -&gt; b -&gt; a instance (KnownNat lo, KnownNat hi, Num a, Ord a, Show a) =&gt; Num' (RgVld lo hi a) a where (RgVld l) +. r = chkVld "(+.)" $ RgVld $ l+r (RgVld l) -. r = chkVld "(-.)" $ RgVld $ lr (RgVld l) *. r = chkVld "(*.)" $ RgVld $ l*r instance (KnownNat lo, KnownNat hi, Show a) =&gt; Show (RgVld lo hi a) where show (RgVld v) = show v instance (KnownNat lo, KnownNat hi, Num a, Ord a, Show a, Read a) =&gt; Read (RgVld lo hi a) where readsPrec w = \s -&gt; case readsPrec ws of [] -&gt; [] [(v,s')] -&gt; [(chkVld "readsPrec" $ RgVld v, s')] instance (KnownNat lo, KnownNat hi, Num a, Ord a, Show a) =&gt; Bounded (RgVld lo hi a) where minBound = fromInteger $ natVal (Proxy :: Proxy lo) maxBound = fromInteger $ natVal (Proxy :: Proxy hi) -- examples ab:: Int -&gt; RgVld 1 20 Int ab = RgVld fuel:: Double -&gt; RgVld 0 15 Double fuel = RgVld</span></span></code> </pre></div><p>Source: <a href="https://habr.com/ru/post/253157/">https://habr.com/ru/post/253157/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../253145/index.html">"Patch" mirror in the car</a></li>
<li><a href="../253149/index.html">Corporate search</a></li>
<li><a href="../253151/index.html">The Groovy project intends to join the Apache Software Foundation</a></li>
<li><a href="../253153/index.html">Brutfors passwords of the engineering menu of the radio station</a></li>
<li><a href="../253155/index.html">How are we tested</a></li>
<li><a href="../253159/index.html">The history of participation in the competition "Flying robots". Part 1</a></li>
<li><a href="../253163/index.html">The tenth issue of the magazine TsODy.RF</a></li>
<li><a href="../253167/index.html">3D systems - a selection of great ways to mingle with content</a></li>
<li><a href="../253169/index.html">Open courses Android Study Jams now in Moscow</a></li>
<li><a href="../253171/index.html">New Yandex.Disk sync algorithm: how not to choke 900,000 files</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>