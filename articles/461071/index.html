<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Optimization of database queries on the example of B2B service for builders</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="How to grow 10 times under the number of database queries without moving to a more efficient server and keep the system working? I‚Äôll tell you how we ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Optimization of database queries on the example of B2B service for builders</h1><div class="post__text post__text-html js-mediator-article">  How to grow 10 times under the number of database queries without moving to a more efficient server and keep the system working?  I‚Äôll tell you how we struggled with the performance degradation of our database, how we optimized SQL queries to serve as many users as possible and not increase the cost of computing resources. <br><a name="habracut"></a><br>  I make a service for managing business processes in construction companies.  About 3 thousand companies work with us.  More than 10 thousand people work with our system for 4-10 hours every day.  It solves various tasks of planning, alerts, warnings, validations ... We use PostgreSQL 9.6.  We have about 300 tables in the database and every day up to 200 million requests (10 thousand different) are sent to it.  On average, we have 3-4 thousand requests per second, in the most active moments more than 10 thousand requests per second.  Most requests are OLAP.  There are much fewer additions, modifications and deletions, that is, the OLTP load is relatively small.  I gave all these figures so that you can evaluate the scope of our project and understand how our experience can be useful to you. <br><br><h3>  The first picture.  Lyrical </h3><br>  When we started development, we didn‚Äôt really think about what kind of load will be on the database and what we will do if the server stops pulling.  When designing the database, we followed the general recommendations and tried not to shoot ourselves in the foot, but beyond general tips like ‚Äúdo not use the <a href="https://en.wikipedia.org/wiki/Entity%25E2%2580%2593attribute%25E2%2580%2593value_model">Entity Attribute Values</a> pattern, we did not go.  Designed based on the principles of normalization avoiding data redundancy and did not care about speeding up certain queries.  As soon as the first users arrived, we ran into a performance problem.  As usual, we were completely unprepared for this.  The first problems were simple.  As a rule, everything was decided by adding a new index.  But there came a time when simple patches stopped working.  Having realized that there is not enough experience and it is becoming increasingly difficult to understand what is the cause of the problems, we hired specialists who helped us set up the server correctly, connect monitoring, showed where to look in order to get <a href="https://www.postgresql.org/docs/9.6/pgstatstatements.html">statistics</a> . <br><br><h3>  The second picture.  Statistical </h3><br>  So we have about 10 thousand different queries that are executed on our database per day.  Of these 10 thousand, there are monsters that run 2-3 million times with an average run time of 0.1-0.3 ms and there are queries with an average run time of 30 seconds that are called 100 times a day. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      It was not possible to optimize all 10 thousand queries, so we decided to figure out where to direct efforts in order to improve database performance correctly.  After several iterations, we began to divide requests into types. <br><br><h4>  TOP queries </h4><br>  These are the most difficult queries that take the most time (total time).  These are queries that are either called very often or queries that take a very long time (long and frequent queries were optimized even at the first iterations of the struggle for speed).  As a result, the server spends the most time on their execution in total.  Moreover, it is important to separate the top requests by the total execution time and separately by IO time.  The ways to optimize such queries are slightly different. <br><br>  The usual practice of all companies is to work with TOP requests.  There are few of them, optimization of even one request can free up 5-10% of resources.  However, as the project grows older, optimizing TOP queries becomes an increasingly non-trivial task.  All simple methods have already been worked out, and the most ‚Äúdifficult‚Äù request takes away ‚Äúonly‚Äù 3-5% of resources.  If TOP queries in total take less than 30-40% of the time, then most likely you have already made efforts so that they work quickly and it is time to move on to optimizing queries from the next group. <br>  It remains to answer the question how many top queries to include in this group.  I usually take no less than 10, but no more than 20. I try to ensure that the time of the first and last in the TOP group differs no more than 10 times.  That is, if the query execution time drops sharply from 1 place to 10, then I take TOP-10, if the drop is smoother, then I increase the group size to 15 or 20. <br><img src="https://habrastorage.org/webt/y5/j5/yx/y5j5yxa6u4kxlpahplsaprh07ro.png" alt="image"><br><br><h4>  Middle peasants (medium) </h4><br>  These are all requests that go immediately after TOP, with the exception of the last 5-10%.  Usually, in optimizing these particular requests lies the ability to greatly increase server performance.  These queries can ‚Äúweigh‚Äù up to 80%.  But even if their share has exceeded 50%, then it is time to look at them more closely. <br><br><h4>  Tail </h4><br>  As it was said, these requests go at the end and they take 5-10% of the time.  You can forget about them only if you do not use automatic query analysis tools, then their optimization can also be cheap. <br><br>  How to evaluate each group? <br><br>  I use an SQL query that helps to make such an assessment for PostgreSQL (I‚Äôm sure that for many other DBMSs you can write a similar query) <br><br><div class="spoiler">  <b class="spoiler_title">SQL query to evaluate the size of TOP-MEDIUM-TAIL groups</b> <div class="spoiler_text"><pre><code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sum</span></span>(time_top) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> sum_top, <span class="hljs-keyword"><span class="hljs-keyword">sum</span></span>(time_medium) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> sum_medium, <span class="hljs-keyword"><span class="hljs-keyword">sum</span></span>(time_tail) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> sum_tail <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> rn &lt;= <span class="hljs-number"><span class="hljs-number">20</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> tt_percent <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> time_top, <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> rn &gt; <span class="hljs-number"><span class="hljs-number">20</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> rn &lt;= <span class="hljs-number"><span class="hljs-number">800</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> tt_percent <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> time_medium, <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> rn &gt; <span class="hljs-number"><span class="hljs-number">800</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> tt_percent <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> time_tail <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> total_time / (<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sum</span></span>(total_time) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_statements) * <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> tt_percent, <span class="hljs-keyword"><span class="hljs-keyword">query</span></span>, ROW_NUMBER () <span class="hljs-keyword"><span class="hljs-keyword">OVER</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> total_time <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> rn <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_statements <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> total_time <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> t ) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> ts</code> </pre> <br></div></div><br>  The query result is three columns, each of which contains a percentage of the time that is spent processing requests from this group.  Inside the query, there are two numbers (in my case, 20 and 800) that separate requests from one group from another. <br><br>  This is how the share of requests at the time of the start of optimization work now roughly correlates. <br><br><img src="https://habrastorage.org/webt/db/at/i_/dbati_rdn49yulwdicigqdvrgew.png"><br><br>  The diagram shows that the share of TOP requests has sharply decreased, but the ‚Äúmiddle peasants‚Äù have grown. <br>  Initially, TOP blunders hit TOP queries.  Over time, childhood illnesses disappeared, the share of TOP requests was reduced, and more efforts had to be made to accelerate difficult requests. <br><br><div class="spoiler">  <b class="spoiler_title">To get the text of the requests we use such a request</b> <div class="spoiler_text"><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> ROW_NUMBER () <span class="hljs-keyword"><span class="hljs-keyword">OVER</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> total_time <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> rn, total_time / (<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sum</span></span>(total_time) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_statements) * <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> tt_percent, <span class="hljs-keyword"><span class="hljs-keyword">query</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_statements <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> total_time <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> T <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> rn &lt;= <span class="hljs-number"><span class="hljs-number">20</span></span> <span class="hljs-comment"><span class="hljs-comment">-- TOP -- rn &gt; 20 AND rn &lt;= 800 -- MEDIUM -- rn &gt; 800 -- TAIL</span></span></code> </pre><br></div></div><br>  Here is a list of the most commonly used tricks that helped us speed up TOP queries: <br><br><ul><li>  Redesign systems, for example, processing notification logic on message broker instead of periodic database queries </li><li>  Adding or Modifying Indexes </li><li>  Rewrite ORM queries in pure SQL </li><li>  Rewrite lazy data loading logic </li><li>  Caching through data denormalization.  For example, we have a link between the tables Delivery -&gt; Invoice -&gt; Request -&gt; Request.  That is, each delivery is associated with the application through other tables.  In order not to link all tables in each request, we duplicated the link to the application in the Delivery table. </li><li>  Caching static tables with directories and rarely changing tables in program memory. </li></ul><br>  Sometimes the changes dragged on an impressive redesign, but they gave 5-10% of the unloading of the system and were justified.  Over time, the exhaust became less and less, and the redesign needed more and more serious. <br><br>  Then we paid attention to the second group of requests ‚Äî the group of middle peasants.  It contains a lot more requests and it seemed that it would take a lot of time to analyze the entire group.  However, most of the queries turned out to be very simple for optimization, and many problems were repeated dozens of times in different variations.  Here are examples of some typical optimizations that we applied to dozens of similar queries and each group of optimized queries unloaded the database by 3-5%. <br><br><ul><li>  Instead of checking for records with COUNT and a full table scan, EXISTS <br></li><li>  We got rid of DISTINCT (there is no general recipe, but sometimes you can easily get rid of it by speeding up the request 10-100 times). <br><br>  For example, instead of querying to select all drivers on a large delivery table (DELIVERY) <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DISTINCT</span></span> P.ID, P.FIRST_NAME, P.LAST_NAME <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> DELIVERY D <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> PERSON P <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> D.DRIVER_ID = P.ID</code> </pre><br>  made a request for a relatively small PERSON table <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> P.ID, P.FIRST_NAME, P.LAST_NAME <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> PERSON <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXISTS</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> D.ID <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> DELIVERY <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> D.DRIVER_ID = P.ID)</code> </pre><br>  It would seem that we used a correlating subquery, but it gives an acceleration of more than 10 times. <br></li><li>  In many cases, COUNT and <br>  <a href="https://www.citusdata.com/blog/2016/10/12/count-performance/">replaced by the calculation of the approximate value</a> <br></li><li>  instead <br><br><pre> <code class="sql hljs">UPPER(s) LIKE JOHN%'</code> </pre><br>  use <br><br><pre> <code class="sql hljs">s ILIKE ‚ÄúJohn%‚Äù</code> </pre><br></li></ul><br>  Each specific request was sometimes accelerated by 3-1000 times.  Despite the impressive performance, at first it seemed to us that there was no point in optimizing the query, which was executed for 10 ms, included in the third hundred of the heaviest queries, and in the total database load time it took hundredths of a percent.  But applying the same recipe to a group of similar requests, we won back several percent.  In order not to waste time manually viewing all hundreds of queries, we wrote several simple scripts that, using regular expressions, found similar queries.  As a result, the automatic search for query groups allowed us to further improve our performance by spending modest efforts. <br><br>  As a result, we have been working on the same hardware for three years now.  The average daily load is about 30%, at peaks it reaches 70%.  The number of requests as well as the number of users has grown by about 10 times.  And all this thanks to the constant monitoring of these very groups of TOP-MEDIUM queries.  As soon as a new request appears in the TOP group, we immediately analyze it and try to speed it up.  We review the MEDIUM group once a week using query analysis scripts.  If you come across new requests that we already know how to optimize, then we quickly change them.  Sometimes we find new optimization methods that can be applied to several queries at once. <br><br>  According to our forecasts, the current server will withstand an increase in the number of users by another 3-5 times.  True, we have one more trump card in the sleeve; we still have not translated SELECT queries to the mirror, as recommended.  But we do not do this consciously, since we first want to fully exhaust the possibilities of ‚Äúsmart‚Äù optimization before turning on ‚Äúheavy artillery‚Äù. <br>  A critical look at the work done may suggest using vertical scaling.  Buy a more powerful server, instead of wasting the time of specialists.  The server may not cost so much, especially since the limits of vertical scaling have not yet been exhausted.  However, only the number of requests increased 10 times.  For several years, the functionality of the system has increased and now there are more varieties of queries.  The functionality that was, due to caching, is performed by fewer requests, moreover, more efficient requests.  So you can safely multiply by another 5 to get the real acceleration coefficient.  So, according to the most conservative estimates, we can say that the acceleration was 50 or more times.  Vertically shaking the server 50 times would cost more.  Especially considering that once the optimization is carried out all the time, and the bill for a rented server comes every month. </div><p>Source: <a href="https://habr.com/ru/post/461071/">https://habr.com/ru/post/461071/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../461061/index.html">Magnesium alloys, twin boundaries and segregation</a></li>
<li><a href="../461063/index.html">Interaction of R with databases on the example of Microsoft SQL Server and other DBMS</a></li>
<li><a href="../461067/index.html">Top 65 SQL questions from job interviews you should be prepared for in 2019. Part I</a></li>
<li><a href="../461069/index.html">Nobelic Outdoor IP Cameras: Tests, Technologies, and Capabilities of Ivideon Video Surveillance Systems</a></li>
<li><a href="../46107/index.html">Booting MS Windows from a USB flash drive</a></li>
<li><a href="../461073/index.html">We connect online maps to the navigator on the smartphone. Part 3 - OverpassTurbo</a></li>
<li><a href="../461075/index.html">Business analytics. IT objects, components, tools</a></li>
<li><a href="../461077/index.html">How are pentesters cooked? Entrance Testing for Digital Security Interns</a></li>
<li><a href="../461081/index.html">The day Dodo IS stopped. Asynchronous script</a></li>
<li><a href="../461083/index.html">Writing software with the functionality of client-server utilities Windows, part 02</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>