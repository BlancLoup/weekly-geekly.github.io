<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We do GraphQL API on PHP and MySQL. Part 3: Solving the N + 1 Query Problem</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In this, the third article on the creation of GraphQL server with graphql-php, I will talk about how to deal with the problem of N + 1 queries. 

 For...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We do GraphQL API on PHP and MySQL. Part 3: Solving the N + 1 Query Problem</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/web/0bc/8d1/715/0bc8d171582548d690cb776d7fb2ae8c.png" alt="image"><br><br>  In this, the third article on the creation of GraphQL server with <a href="https://github.com/webonyx/graphql-php">graphql-php,</a> I will talk about how to deal with the problem of N + 1 queries. <br><a name="habracut"></a><br><h2>  Foreword </h2><br>  I will continue to change the code received at the end of the <a href="https://habrahabr.ru/post/329238/">previous article</a> .  You can also view it in <a href="https://github.com/XAHTEP26/graphql-php-tutorial/tree/master/mutation-and-validation">the article repository on Github</a> .  If you have not read the previous articles, I recommend reading them before continuing. <br><br>  I will also comment out two lines in graphql.php, which add a limit to the maximum depth and complexity of the query, since they are not very necessary during development, and can only cause debugging problems: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre><code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">// DocumentValidator::addRule('QueryComplexity', new QueryComplexity(6)); // DocumentValidator::addRule('QueryDepth', new QueryDepth(1));</span></span></code> </pre> <br><br><h2>  Problem N + 1 queries </h2><br><h3>  Problem </h3><br>  The easiest way to explain what the problem is N + 1 queries on the example.  Suppose you need to request a list of articles and their authors.  Without hesitation, you can do it like this: <br><br><pre> <code class="php hljs">$articles = DB::table(<span class="hljs-string"><span class="hljs-string">'articles'</span></span>)-&gt;get(); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> ($articles <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> &amp;$article) { $article-&gt;author = DB::table(<span class="hljs-string"><span class="hljs-string">'users'</span></span>)-&gt;where(<span class="hljs-string"><span class="hljs-string">'id'</span></span>, $article-&gt;author_id)-&gt;first(); }</code> </pre> <br>  As a rule, <code>DB::table('articles')-&gt;get()</code> as a result sends one request to the database, something like this: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> articles;</code> </pre> <br>  And then in the loop another N queries are sent to the database: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">users</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">users</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">users</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">users</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> = <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">users</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> = <span class="hljs-number"><span class="hljs-number">5</span></span>; ... <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">users</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> = N;</code> </pre> <br>  Where N is the number of articles received in the first request. <br><br>  For example, we execute one request that returns 100 articles to us, and then for each article we execute one more request from the author.  In total, 100 + 1 = 101 queries are obtained.  This is an extra load on the database server and is called the N + 1 query problem. <br><br><h3>  Decision </h3><br>  The most common method for solving this problem is grouping queries. <br><br>  If we rewrite the same example using the grouping of queries, we will get something like this: <br><br><pre> <code class="php hljs">$articles = DB::table(<span class="hljs-string"><span class="hljs-string">'articles'</span></span>)-&gt;get(); $authors_ids = get_authors_ids($articles); $authors = DB::table(<span class="hljs-string"><span class="hljs-string">'users'</span></span>)-&gt;whereIn(<span class="hljs-string"><span class="hljs-string">'id'</span></span>, $authors_ids)-&gt;get(); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> ($articles <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> &amp;$article) { $article-&gt;author = search_author_by_id($authors, $article-&gt;author_id); }</code> </pre> <br>  That is, we do the following: <br><br><ol><li>  We request an array of articles </li><li>  We remember the id of all authors of these articles. </li><li>  We request an array of users by these id </li><li>  We insert authors into articles from the array of users </li></ol><br>  At the same time, no matter how many articles we have requested, only two requests will be sent to the database: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> articles; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">users</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, ..., N);</code> </pre> <br><br><h2>  Problem N + 1 queries in GraphQL </h2><br>  Now let's return to our GraphQL server in the state it is in after the previous article, and pay attention to how the request for the number of the user's friends is implemented. <br><br>  If we request a list of users with an indication of the number of friends each, then first the Graph SQL server will request all the records from the user table: <br><br><pre> <code class="php hljs"><span class="hljs-string"><span class="hljs-string">'allUsers'</span></span> =&gt; [ <span class="hljs-string"><span class="hljs-string">'type'</span></span> =&gt; Types::listOf(Types::user()), <span class="hljs-string"><span class="hljs-string">'description'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">' '</span></span>, <span class="hljs-string"><span class="hljs-string">'resolve'</span></span> =&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> DB::select(<span class="hljs-string"><span class="hljs-string">'SELECT * from users'</span></span>); } ]</code> </pre> <br>  And then for each user will request from the database the number of his friends: <br><br><pre> <code class="php hljs"><span class="hljs-string"><span class="hljs-string">'countFriends'</span></span> =&gt; [ <span class="hljs-string"><span class="hljs-string">'type'</span></span> =&gt; Types::int(), <span class="hljs-string"><span class="hljs-string">'description'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'  '</span></span>, <span class="hljs-string"><span class="hljs-string">'resolve'</span></span> =&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($root)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> DB::affectingStatement(<span class="hljs-string"><span class="hljs-string">"SELECT u.* FROM friendships f JOIN users u ON u.id = f.friend_id WHERE f.user_id = {$root-&gt;id}"</span></span>); } ]</code> </pre> <br>  This is where the problem of N + 1 queries appears. <br><br>  To solve this problem by the method of grouping queries, <a href="https://github.com/webonyx/graphql-php">graphql-php</a> suggests that we <a href="http://webonyx.github.io/graphql-php/data-fetching/">postpone the execution of</a> these fields to the <a href="http://webonyx.github.io/graphql-php/data-fetching/">resolol</a> until the values ‚Äã‚Äãof all the other (non-postponed) fields are obtained. <br><br>  The idea is simple: instead of the result, the function ‚Äúresolve‚Äù of the field should return an object of the GraphQL \ Deferred class, to the constructor of which the function is passed to get the same result. <br><br>  That is, now we can connect the class Deferred: <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">GraphQL</span></span>\<span class="hljs-title"><span class="hljs-title">Deferred</span></span>;</code> </pre> <br>  And postpone execution by rewriting the ‚ÄúcountFriends‚Äù field resolver as follows: <br><br><pre> <code class="php hljs"><span class="hljs-string"><span class="hljs-string">'countFriends'</span></span> =&gt; [ <span class="hljs-string"><span class="hljs-string">'type'</span></span> =&gt; Types::int(), <span class="hljs-string"><span class="hljs-string">'description'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'  '</span></span>, <span class="hljs-string"><span class="hljs-string">'resolve'</span></span> =&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($root)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Deferred(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">use</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($root)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> DB::affectingStatement(<span class="hljs-string"><span class="hljs-string">"SELECT u.* FROM friendships f JOIN users u ON u.id = f.friend_id WHERE f.user_id = {$root-&gt;id}"</span></span>); }); } ]</code> </pre> <br>  But simply postponing the execution of the query, we will not solve the problem of N + 1.  Therefore, we need to create a buffer that will accumulate the id of all users for which we need to request the number of friends, and in the future will be able to return the results for all users. <br><br>  To do this, I will create a small class that will have three simple static methods: <br><br><ul><li>  <code>add</code> - Add user id to buffer </li><li>  <code>load</code> - load the number of friends from the database for all users in the buffer </li><li>  <code>get</code> - Get the number of friends of the user from the buffer </li></ul><br>  You can also implement this class in any way you like; I will only give its code for a specific example: <br><br><div class="spoiler">  <b class="spoiler_title">App / Buffer.php</b> <div class="spoiler_text"><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">App</span></span>; <span class="hljs-comment"><span class="hljs-comment">/** * Class Buffer * *    * * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@package</span></span></span><span class="hljs-comment"> App */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Buffer</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/** *  id  * * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@var</span></span></span><span class="hljs-comment"> array */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> $ids = <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>(); <span class="hljs-comment"><span class="hljs-comment">/** *        * * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@var</span></span></span><span class="hljs-comment"> array */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> $results = <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>(); <span class="hljs-comment"><span class="hljs-comment">/** *           */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">load</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//     ,     if (!empty(self::$results)) return; //          $rows = DB::select("SELECT u.id, COUNT(f.friend_id) AS count FROM users u LEFT JOIN friendships f ON f.user_id = u.id WHERE u.id IN (" . implode(',', self::$ids) . ") GROUP BY u.id"); foreach ($rows as $row) { self::$results[$row-&gt;id] = $row-&gt;count; } } /** *  id    * * @param int $id */ public static function add($id) { //   id    ,     if (in_array($id, self::$ids)) return; self::$ids[] = $id; } /** *       * * @param $id * @return int */ public static function get($id) { if (!isset(self::$results[$id])) return null; return self::$results[$id]; } }</span></span></code> </pre> </div></div><br>  Now we connect our buffer to UserType.php: <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">App</span></span>\<span class="hljs-title"><span class="hljs-title">Buffer</span></span>;</code> </pre> <br>  And again rewrite the resolver for the ‚ÄúcountFriends‚Äù field: <br><br><pre> <code class="php hljs"><span class="hljs-string"><span class="hljs-string">'countFriends'</span></span> =&gt; [ <span class="hljs-string"><span class="hljs-string">'type'</span></span> =&gt; Types::int(), <span class="hljs-string"><span class="hljs-string">'description'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'  '</span></span>, <span class="hljs-string"><span class="hljs-string">'resolve'</span></span> =&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($root)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  id    Buffer::add($root-&gt;id); return new Deferred(function () use ($root) { //       (     ) Buffer::load(); //       return Buffer::get($root-&gt;id); }); } ],</span></span></code> </pre> <br>  Is done.  Now when you run the query: <br><br> <a href=""><img src="https://habrastorage.org/web/f46/d1d/f55/f46d1df55e8a49eba7200f6a71b1e1b9.png" alt="GraphQL: Requesting users with number of friends"></a> <br><br>  The number of friends for all users will be retrieved from the database only once.  Moreover, the data request on the number of friends will be executed only once, even with this GraphQL query: <br><br> <a href=""><img src="https://habrastorage.org/web/e15/38d/57a/e1538d57afdb4a61be6464a13cfa13e8.png" alt="GraphQL: Nested user request with number of friends"></a> <br><br>  Of course in this form our buffer is very highly specialized.  It turns out that for another field we need to create another buffer.  But this is just an example and nothing prevents us from making a universal buffer, which, for example, will store data for different fields by their keys, and also take a function as an argument to get results.  In this case, the buffer can receive not only from the database, but also from some API. <br><br><h2>  Conclusion </h2><br>  That's all.  Offer your solutions to these problems and ask questions if they arise. <br><br>  <a href="https://github.com/XAHTEP26/graphql-php-tutorial/tree/master/n-plus-one-query-problem">The source code</a> from an article on Github. <br><br>  Other parts of this article: <br><br><ol><li>  <a href="https://habrahabr.ru/post/328122/">Installation, layout and queries</a> </li><li>  <a href="https://habrahabr.ru/post/329238/">Mutations, variables, validation and security</a> </li><li>  Solving the problem of N + 1 queries </li></ol></div><p>Source: <a href="https://habr.com/ru/post/329408/">https://habr.com/ru/post/329408/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../329396/index.html">Google Chrome "eats" browser market</a></li>
<li><a href="../329398/index.html">Intel introduced the 18-core Core i9 Extreme Core X line</a></li>
<li><a href="../329400/index.html">Microsoft will introduce DNA storage in one of its data centers</a></li>
<li><a href="../329402/index.html">Building the right alert system - respond only to business critical issues</a></li>
<li><a href="../329404/index.html">Why did we write CRM to the SEO department and what did it lead to?</a></li>
<li><a href="../329410/index.html">The wonderful world of Word Embeddings: what are they and why are they needed?</a></li>
<li><a href="../329412/index.html">Evaluation of the quality of face recognition algorithms</a></li>
<li><a href="../329414/index.html">Google I / O 2017: Android developer notes</a></li>
<li><a href="../329416/index.html">Cloud Load Balancing</a></li>
<li><a href="../329418/index.html">Testing with –°odeception for dummies: 3 types of tests</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>