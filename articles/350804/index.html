<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Blockchain on Go. Part 2: Proof-of-Work</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hi, Habr! I present to your attention the translation of the article " Building Blockchain in Go. Part 2: Proof-of-Work ". 

 Content 


1. Blockchain...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Blockchain on Go. Part 2: Proof-of-Work</h1><div class="post__text post__text-html js-mediator-article">  Hi, Habr!  I present to your attention the translation of the article " <a href="https://jeiwan.cc/posts/building-blockchain-in-go-part-2/">Building Blockchain in Go. Part 2: Proof-of-Work</a> ". <br><br>  Content <br><ol><li>  <a href="https://habrahabr.ru/post/348672/">Blockchain on Go.</a>  <a href="https://habrahabr.ru/post/348672/">Part 1: Prototype</a> </li><li>  <b>Blockchain on Go.</b>  <b>Part 2: Proof-of-Work</b> </li><li>  <a href="https://habrahabr.ru/post/351296/">Blockchain on Go.</a>  <a href="https://habrahabr.ru/post/351296/">Part 3: Permanent Memory and Command Line Interface</a> </li><li>  <a href="http://habrahabr.ru/post/351752">Blockchain on Go.</a>  <a href="http://habrahabr.ru/post/351752">Part 4: Transactions, Part 1</a> </li><li>  <a href="https://habrahabr.ru/post/351834/">Blockchain on Go.</a>  <a href="https://habrahabr.ru/post/351834/">Part 5: Addresses</a> </li><li>  Blockchain on Go.  Part 6: Transactions, Part 2 </li><li>  Blockchain on Go.  Part 7: Network </li></ol><br><br><h3>  Introduction </h3><br>  In the <a href="https://habrahabr.ru/post/348672/">previous article,</a> we built a very simple data structure, which is the basis for the blockchain database.  We also added blocks with a chain link between them: each block is connected with the previous one.  Alas, our implementation of the blockchain has one major drawback: adding blocks to the chain is too simple and cheap. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      One of the cornerstones of Bitcoin and the blockchain is that adding new blocks should be a rather complicated job.  And now we are going to fix this flaw. <br><a name="habracut"></a><br><h3>  Proof-of-Work (PoW) </h3><br>  The key idea behind the blockchain is that in order to add a new block it is necessary to do some complicated work.  It is this hard work that makes the blockchain reliable and complete.  In addition, remuneration is paid for this difficult job (that's how people get coins for mining). <br><br>  This mechanism is like a real life: you have to work hard to get rewards and ensure your life.  In the blockchain, some participants (miners) of the network are working on maintaining the network, adding new blocks to the blockchain, and are rewarded for their work.  As a result of their work, the block is built in to the blockchain in a reliable way, which ensures the stability of the entire blockchain database.  It should be noted that the one who performed the work must also prove that it was done. <br><br>  This whole "do the hard work and prove it" -the mechanism is called Proof-of-Work (proof of work).  It is complicated because it requires large computing power: even high-performance computers cannot quickly complete it.  Moreover, the complexity of this work is gradually increasing in order to create on average about 6 blocks per hour.  In Bitcoin, the goal of such work is to find a hash of a block that satisfies certain requirements.  This hash is evidence.  Thus, the search for evidence is the actual work. <br><br>  One thing to be noted: Proof-of-Work algorithms must meet the following requirement: the work must be complex, but the proof must be simple.  Testing the evidence is usually passed to someone else, so this check should not take a lot of time from them. <br><br><h3>  Hashing </h3><br>  This part is dedicated to hashing.  Those who are familiar with this concept may skip this part. <br><br>  Hashing is the process of getting a hash for some data.  A hash is a unique representation for the data for which it was calculated.  A hash function is a function that, for data of arbitrary size, receives a hash of a specific size.  Some key features of hashing are: <br><br><ol><li>  Initial data cannot be recovered from the hash.  Thus, hashing is not encryption. </li><li>  A hash for specific data is always unambiguous and unique. </li><li>  Changing one byte in the data results in a completely different hash. </li></ol><br><img src="https://habrastorage.org/webt/uv/wr/8r/uvwr8retu9hthyarn3tnidlzo9i.png"><br><br>  Hash functions are widely used to verify data integrity.  Many software providers publish together with the software its checksums.  After downloading the file, it is necessary to feed the hash function, and then compare the resulting hash with that published by the software developer. <br><br>  In the blockchain, the hash is used to ensure the integrity of the block.  The input data for the hashing algorithm contains the hash of the previous block, which makes it impossible (or at least very complicated) to change the block in the chain: you have to recalculate the hash of the block itself, as well as the hashes of all the blocks following it. <br><br><h3>  Hashcash </h3><br>  Bitcoin uses <a href="https://ru.wikipedia.org/wiki/Hashcash">Hashcash</a> , a Proof-of-Work algorithm that was designed to protect against spam email.  The algorithm can be divided into the following steps: <br><br><ol><li>  Take publicly known data (for email, this is the recipient‚Äôs address; for Bitcoin, this is the block header </li><li>  Add a counter to them.  The counter starts from zero </li><li>  Get hash from combination <code>+</code> </li><li>  Check if the hash meets certain requirements. <ol><li>  If yes, then everything is ready </li><li>  If not, increase the counter and repeat steps 3 and 4 </li></ol></li></ol><br>  Thus, this is a brute force algorithm: change the counter, calculate the hash, check it, increment the counter, calculate the hash again, and so on.  That is why the algorithm is computationally expensive. <br><br>  Now consider the requirements that the hash must satisfy.  In the original Hashcash implementation, the requirement sounds like "the first 20 bits of the hash should be zero."  In Bitcoin, the requirement is corrected from time to time, because according to the plan, the block should be generated every 10 minutes, despite the fact that the computing power grows with time and more and more miners join the network. <br><br>  To demonstrate the algorithm, take the previous example (‚ÄúI like donuts‚Äù) and find a hash that starts with three zero bytes. <br><br><img src="https://habrastorage.org/webt/k0/29/sv/k029sv9slggpy6mbhyjgkgcbxxe.png"><br><br>  <code>ca07ca</code> is a hexadecimal representation of the counter, which corresponds to the number 13240266 in the decimal number system. <br><br><h3>  Implementation </h3><br>  So, the theory is finished, let's proceed to the code.  First, let's define the complexity of mining: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> targetBits = <span class="hljs-number"><span class="hljs-number">24</span></span></code> </pre> <br>  In Bitcoin, ‚Äútarget bits‚Äù is a block header field that stores the complexity on which the block was extracted.  We will not build a corrective algorithm, so we define complexity as a global constant. <br><br>  24 is an arbitrary number, our goal is to have complexity that takes less than 256 bits in memory.  And we want the difference to be significant enough, but not too big, because the bigger the difference, the harder it is to find the right hash. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> ProofOfWork <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { block *Block target *big.Int } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NewProofOfWork</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b *Block)</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ProofOfWork</span></span></span></span> { target := big.NewInt(<span class="hljs-number"><span class="hljs-number">1</span></span>) target.Lsh(target, <span class="hljs-keyword"><span class="hljs-keyword">uint</span></span>(<span class="hljs-number"><span class="hljs-number">256</span></span>-targetBits)) pow := &amp;ProofOfWork{b, target} <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> pow }</code> </pre> <br>  Here we create create <code>ProofOfWork</code> , which contains a pointer to a pointer to a block and a pointer to a target.  ‚ÄúTarget‚Äù is another name for the requirements described in the previous section.  We use <a href="https://golang.org/pkg/math/big/">big integer</a> because of the way the hash is compared to the target: we distribute the hash into the big integer and check if it is smaller than the target. <br>  In the <code>NewProofOfWork</code> function <code>NewProofOfWork</code> we will initialize <code>big.Int</code> value 1, and then shift by <code>256-targetBits</code> bits.  <code>256</code> is the length of the SHA-256 hash in bits, and we will use this hashing algorithm.  Hex <code>target</code> view: <br><br><pre> <code class="go hljs"> <span class="hljs-number"><span class="hljs-number">0x10000000000000000000000000000000000000000000000000000000000</span></span></code> </pre> <br>  And it takes 29 bytes in memory.  And here is a visual comparison with the hashes from the previous examples: <br><br><pre> <code class="go hljs"><span class="hljs-number"><span class="hljs-number">0f</span></span>ac49161af82ed938add1d8725835cc123a1a87b1b196488360e58d4bfb51e3 <span class="hljs-number"><span class="hljs-number">0000010000000000000000000000000000000000000000000000000000000000</span></span> <span class="hljs-number"><span class="hljs-number">0000008</span></span>b0f41ec78bab747864db66bcb9fb89920ee75f43fdaaeb5544f7f76ca</code> </pre><br>  The first hash (calculated for ‚ÄúI like donuts‚Äù) is larger than the goal, so this is incorrect proof of work.  The second hash (calculated for "I like donutsca07ca") is smaller than the target, so this is a sure proof. <br><br>  You can consider the target as the upper limit of the range: if the number (hash) is smaller than the limit, then it is suitable, and vice versa.  Lowering the border will reduce the number of suitable numbers, thereby increasing the difficulty of finding the right one. <br><br>  Now we need data for hashing.  Let's prepare them: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pow *ProofOfWork)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prepareData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(nonce </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> []</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">byte</span></span></span></span> { data := bytes.Join( [][]<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>{ pow.block.PrevBlockHash, pow.block.Data, IntToHex(pow.block.Timestamp), IntToHex(<span class="hljs-keyword"><span class="hljs-keyword">int64</span></span>(targetBits)), IntToHex(<span class="hljs-keyword"><span class="hljs-keyword">int64</span></span>(nonce)), }, []<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>{}, ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> data }</code> </pre> <br>  This piece of code is quite simple.  We simply combine the fields of the block with the goal and "nonce".  <code>nonce</code> is a counter from the Hashcash description; this is such a cryptographic term. <br><br>  So, all the preparations are made.  Now we implement the core of the Proof-of-Work algorithm: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pow *ProofOfWork)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> hashInt big.Int <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> hash [<span class="hljs-number"><span class="hljs-number">32</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> nonce := <span class="hljs-number"><span class="hljs-number">0</span></span> fmt.Printf(<span class="hljs-string"><span class="hljs-string">"Mining the block containing \"%s\"\n"</span></span>, pow.block.Data) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> nonce &lt; maxNonce { data := pow.prepareData(nonce) hash = sha256.Sum256(data) fmt.Printf(<span class="hljs-string"><span class="hljs-string">"\r%x"</span></span>, hash) hashInt.SetBytes(hash[:]) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> hashInt.Cmp(pow.target) == <span class="hljs-number"><span class="hljs-number">-1</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { nonce++ } } fmt.Print(<span class="hljs-string"><span class="hljs-string">"\n\n"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> nonce, hash[:] }</code> </pre><br>  First we initialize the variables.  <code>hashInt</code> is an integer representation for <code>hash</code> .  <code>nonce</code> is a counter.  Then we start the ‚Äúinfinite‚Äù loop: it is bounded by the <code>maxNonce</code> constant, the value of which is <code>math.MaxInt64</code> .  This is done to avoid possible <code>nonce</code> overflow.  Although the complexity of our PoW implementation is too small to overflow the counter, it is better to have such a check just in case. <br><br>  In the loop, we do the following: <br><br><ol><li>  Prepare data </li><li>  Hash them Hash256 </li><li>  Convert hash to big integer </li><li>  Compare the resulting integer with the goal </li></ol><br>  As easy as previously explained.  Now you can delete the <code>SetHash</code> method from <code>Block</code> and change the <code>NewBlock</code> function: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NewBlock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, prevBlockHash []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Block</span></span></span></span> { block := &amp;Block{time.Now().Unix(), []<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>(data), prevBlockHash, []<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>{}, <span class="hljs-number"><span class="hljs-number">0</span></span>} pow := NewProofOfWork(block) nonce, hash := pow.Run() block.Hash = hash[:] block.Nonce = nonce <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> block }</code> </pre> <br>  You may notice that <code>nonce</code> saved as a <code>Block</code> property.  This is necessary because <code>nonce</code> is required to verify the evidence.  The <code>Block</code> structure now looks like this: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Block <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Timestamp <span class="hljs-keyword"><span class="hljs-keyword">int64</span></span> Data []<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> PrevBlockHash []<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> Hash []<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> Nonce <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> }</code> </pre> <br>  And now we will launch our program and check that everything works well: <br><br><pre> <code class="go hljs">Mining the block containing <span class="hljs-string"><span class="hljs-string">"Genesis Block"</span></span> <span class="hljs-number"><span class="hljs-number">00000041662</span></span>c5fc2883535dc19ba8a33ac993b535da9899e593ff98e1eda56a1 Mining the block containing <span class="hljs-string"><span class="hljs-string">"Send 1 BTC to Ivan"</span></span> <span class="hljs-number"><span class="hljs-number">00000077</span></span>a856e697c69833d9effb6bdad54c730a98d674f73c0b30020cc82804 Mining the block containing <span class="hljs-string"><span class="hljs-string">"Send 2 more BTC to Ivan"</span></span> <span class="hljs-number"><span class="hljs-number">000000</span></span>b33185e927c9a989cc7d5aaaed739c56dad9fd9361dea558b9bfaf5fbe Prev. hash: Data: Genesis Block Hash: <span class="hljs-number"><span class="hljs-number">00000041662</span></span>c5fc2883535dc19ba8a33ac993b535da9899e593ff98e1eda56a1 Prev. hash: <span class="hljs-number"><span class="hljs-number">00000041662</span></span>c5fc2883535dc19ba8a33ac993b535da9899e593ff98e1eda56a1 Data: Send <span class="hljs-number"><span class="hljs-number">1</span></span> BTC to Ivan Hash: <span class="hljs-number"><span class="hljs-number">00000077</span></span>a856e697c69833d9effb6bdad54c730a98d674f73c0b30020cc82804 Prev. hash: <span class="hljs-number"><span class="hljs-number">00000077</span></span>a856e697c69833d9effb6bdad54c730a98d674f73c0b30020cc82804 Data: Send <span class="hljs-number"><span class="hljs-number">2</span></span> more BTC to Ivan Hash: <span class="hljs-number"><span class="hljs-number">000000</span></span>b33185e927c9a989cc7d5aaaed739c56dad9fd9361dea558b9bfaf5fbe</code> </pre><br>  Hooray!  Now you can see that each hash begins with three zero bytes and the search for hashes takes some time. <br><br>  There is still something to be done: let's make it possible to check the evidence of the work: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pow *ProofOfWork)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Validate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bool</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> hashInt big.Int data := pow.prepareData(pow.block.Nonce) hash := sha256.Sum256(data) hashInt.SetBytes(hash[:]) isValid := hashInt.Cmp(pow.target) == <span class="hljs-number"><span class="hljs-number">-1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> isValid }</code> </pre> <br>  This is where we need the saved <code>nonce</code> . <br><br>  Check that everything is in order: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { ... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, block := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> bc.blocks { ... pow := NewProofOfWork(block) fmt.Printf(<span class="hljs-string"><span class="hljs-string">"PoW: %s\n"</span></span>, strconv.FormatBool(pow.Validate())) fmt.Println() } }</code> </pre><br>  Output: <br><br><pre> <code class="go hljs">... Prev. hash: Data: Genesis Block Hash: <span class="hljs-number"><span class="hljs-number">00000093253</span></span>acb814afb942e652a84a8f245069a67b5eaa709df8ac612075038 PoW: <span class="hljs-literal"><span class="hljs-literal">true</span></span> Prev. hash: <span class="hljs-number"><span class="hljs-number">00000093253</span></span>acb814afb942e652a84a8f245069a67b5eaa709df8ac612075038 Data: Send <span class="hljs-number"><span class="hljs-number">1</span></span> BTC to Ivan Hash: <span class="hljs-number"><span class="hljs-number">0000003</span></span>eeb3743ee42020e4a15262fd110a72823d804ce8e49643b5fd9d1062b PoW: <span class="hljs-literal"><span class="hljs-literal">true</span></span> Prev. hash: <span class="hljs-number"><span class="hljs-number">0000003</span></span>eeb3743ee42020e4a15262fd110a72823d804ce8e49643b5fd9d1062b Data: Send <span class="hljs-number"><span class="hljs-number">2</span></span> more BTC to Ivan Hash: <span class="hljs-number"><span class="hljs-number">000000e42</span></span>afddf57a3daa11b43b2e0923f23e894f96d1f24bfd9b8d2d494c57a PoW: <span class="hljs-literal"><span class="hljs-literal">true</span></span></code> </pre><br><h3>  Conclusion </h3><br>  Our blockchain is still a step closer to the current architecture: adding blocks requires computational work, so mining is possible.  But it still lacks some important functions: the blockchain database is not permanent, there are no wallets, addresses, transactions, and there is no concess mechanism.  All these things we will consider in the following articles. <br><br><h3>  Links </h3><br>  <a href="https://habrahabr.ru/post/348672/">First part</a> <br>  <a href="https://jeiwan.cc/posts/building-blockchain-in-go-part-2/">Original article</a> <br>  <a href="https://github.com/Jeiwan/blockchain_go/tree/part_2">Source codes for the article</a> <br>  <a href="https://en.bitcoin.it/wiki/Block_hashing_algorithm">Blockchain hashing algorithm</a> <br>  <a href="https://en.bitcoin.it/wiki/Proof_of_work">Proof of work</a> <br>  <a href="https://en.bitcoin.it/wiki/Hashcash">Hashcash</a> </div><p>Source: <a href="https://habr.com/ru/post/350804/">https://habr.com/ru/post/350804/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../350794/index.html">Hessian-Free Optimization with TensorFlow</a></li>
<li><a href="../350796/index.html">Compact varint - uniqueness and great values ‚Äã‚Äãfor the same value.</a></li>
<li><a href="../350798/index.html">FastTrack Training. "Network Basics". "The value of Cisco routers." Eddie Martin December 2012</a></li>
<li><a href="../350800/index.html">Analysis of performance tasks with JBreak (part 1)</a></li>
<li><a href="../350802/index.html">Parsing proposals for Russian language patterns</a></li>
<li><a href="../350806/index.html">About machine learning, history and life with Dmitry Vetrov</a></li>
<li><a href="../350808/index.html">Task about forEach (ps :: println) from SKB Kontur</a></li>
<li><a href="../350810/index.html">Suspended fuel tanks for aircraft</a></li>
<li><a href="../350816/index.html">New API React: Suspense (ru subtitles, from Dan's speech on JS Conf)</a></li>
<li><a href="../350818/index.html">How to increase network bandwidth in the data center: a new PSE-3 chip is introduced</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>