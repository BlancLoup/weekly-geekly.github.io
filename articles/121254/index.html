<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>A simple Linux network interface monitor using netlink</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Once, in one of the projects, I needed to organize strict and reliable control over all network interfaces, routing tables, as well as receive notific...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>A simple Linux network interface monitor using netlink</h1><div class="post__text post__text-html js-mediator-article">  Once, in one of the projects, I needed to organize strict and reliable control over all network interfaces, routing tables, as well as receive notifications about any changes.  A strategic decision was made not to use good old ioctl netdevice (SIOCGIFMETRIC, SIOCSIFNAME, etc.) or direct calls to the corresponding utilities (ifconfig, route, etc.), but to find a more modern and more convenient solution.  It was found - libnetlink.  It is a library that provides a large number of methods for communicating with the kernel using the <a href="http://en.wikipedia.org/wiki/Netlink">netlink</a> mechanism.  This library was ideal for my purposes, allowing you to solve a huge number of tasks.  Unfortunately, the library turned out to have a not very convenient and rather complicated API, which required to perform a lot of incomprehensible actions.  Special fun added almost complete lack of documentation and in general any materials on this topic. <br>  Having thought it over, I decided to sort out netlink and write my library.  At the moment, all the functionality for working with notifications, network interfaces, routing tables is implemented, of course, IPv4 and IPv6 are supported.  Soon enough, this project will be presented to the public :) In the meantime, I would like to acquaint everyone interested in the wonderful world of netlink, using the example of a simple monitor of network interfaces. <br><a name="habracut"></a><br><h5>  What is netlink? </h5><br>  So, netlink is a convenient way of communication between userspace and the Linux kernel.  Communication is carried out using a standard socket, using a special protocol - AF_NETLINK. <br>  Netlink allows you to interact with a large number of kernel subsystems - interfaces, routing, network packet filter.  In addition, you can communicate with your kernel module.  Of course, the latter should support this type of communication. <br>  Each netlink message is a header, represented by the nlmsghdr structure, as well as a certain number of bytes - the ‚Äúpayload‚Äù (playload).  This "load" can be some kind of structure, or just RAW data.  The message, at the time of delivery, may be divided into several parts.  In such cases, each subsequent packet is flagged with the NLM_F_MULTI flag, and the last with the NLMSG_DONE flag.  For parsing messages, there is a whole set of macros defined in the header files netlink.h and rtnetlink.h <br><br><h6>  Create a netlink socket. </h6><br>  The netlink socket declaration looks pretty standard: <br><br> <code>socket(AF_NETLINK, SOCK_RAW, NETLINK_ROUTE)</code> <br> <br>  Where <b>AF_NETLINK</b> is the netlink protocol <br>  <b>SOCK_RAW</b> - socket type <br>  <b>NETLINK_ROUTE</b> is a netlink protocol family. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The last parameter may be different, depending on what we want to receive from netlink. <br>  I will give a table with the most interesting parameters (the full list of parameters can be found in the documentation): <br><br>  <b>NETLINK_ROUTE</b> ‚Äî be notified of changes to the routing table and network interfaces. <br>  It can also be used to change all the parameters of the above objects. <br>  <b>NETLINK_USERSOCK</b> ‚Äî Reserved for defining user protocols. <br>  <b>NETLINK_FIREWALL</b> - used to transfer IPv4 packets from the network filter to the user level <br>  <b>NETLINK_INET_DIAG</b> - monitoring inet sockets <br>  <b>NETLINK_NFLOG</b> - Network / packet filter ULOG <br>  <b>NETLINK_SELINUX</b> - receive notifications from the Selinux system <br>  <b>NETLINK_NETFILTER</b> - working with the network filter subsystem <br>  <b>NETLINK_KOBJECT_UEVENT</b> - receiving kernel messages <br><br>  Further, the created socket can be used to send messages, for example, using the send function and receiving messages using recvmsg. <br><br><h6>  Netlink message </h6><br>  The message header is represented by the structure nlmsghdr <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">nlmsghdr</span></span></span><span class="hljs-class"> {</span></span> __u32 nlmsg_len; <span class="hljs-comment"><span class="hljs-comment">//  ,    __u16 nlmsg_type; //    (  ) __u16 nlmsg_flags; //    __u32 nlmsg_seq; //    __u32 nlmsg_pid; //   (PID),   };</span></span></code> </pre><br><br>  The nlmsg_type field can point to one of the standard message types: <br>  <b>NLMSG_NOOP</b> - messages of this type are ignored. <br>  <b>NLMSG_ERROR</b> - an error message, and in the payload section there will be an nlmsgerr structure (about it below) <br>  <b>NLMSG_DONE</b> - a message with this flag should complete a message split into several parts <br><br>  Nlmsgerr structure <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">nlmsgerr</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> error; <span class="hljs-comment"><span class="hljs-comment">//     struct nlmsghdr msg; //  ,    };</span></span></code> </pre><br><br>  Messages can be one or several (different types are combined using a logical or operation) types: <br><br>  <b>NLM_F_REQUEST</b> - message - request for something <br>  <b>NLM_F_MULTI</b> - message, part of the message broken into parts <br>  <b>NLM_F_ACK</b> - message - confirmation request <br>  <b>NLM_F_ECHO</b> - echo request.  normal direction - requests from the kernel level to the user level <br>  <b>NLM_F_ROOT</b> - this type of query returns a certain table, inside an entity <br>  <b>NLM_F_MATCH</b> - the query returns all matches found. <br>  <b>NLM_F_ATOMIC</b> - returns an atomic slice of a certain table <br>  <b>NLM_F_DUMP</b> - analog NLM_F_ROOT | NLM_F_MATCH <br><br>  Additional flags: <br><br>  <b>NLM_F_REPLACE</b> - replace existing similar object <br>  <b>NLM_F_EXCL</b> - do not replace if such an object already exists <br>  <b>NLM_F_CREATE</b> - create an object if it does not exist <br>  <b>NLM_F_APPEND</b> - add an object to the list to an existing one <br><br>  To identify clients (at the kernel level and at the user level), there is a special address structure - nladdr: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sockaddr_nl</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sa_family_t</span></span> nl_family; <span class="hljs-comment"><span class="hljs-comment">//   -  AF_NETLINK unsigned short nl_pad; //     pid_t nl_pid; //   __u32 nl_groups; //   / };</span></span></code> </pre><br><br>  nl_pid is a unique socket address.  For clients in the kernel, it is always zero.  For clients at the user level, it is equal to the identifier of the process owning the socket.  Each identifier must be unique, so here you may encounter a problem when you try to create multiple netlink sockets in a multi-threaded application: when you create a new socket, the error ‚ÄúOperation not permitted‚Äù will be returned.  To bypass this restriction, nl_pid is followed to assign the value of this expression: <br> <code>pthread_self() &lt;&lt; 16 | getpid();</code> <br>  Assigning an identifier value should be done before bind () is called for a socket. <br>  You can also assign a null value to an identifier.  In this case, the core will generate the unique identifiers, but the first socket created in the application will always be assigned the value of the identifier of this application. <br><br>  <b>nl_groups</b> is a bitmask, each bit of which represents a netlink group number.  When bind () is called for a netlink socket, you must specify the bit mask of the group that the application wants to listen to in this context.  Different groups can be combined using logical or. <br>  Primary groups are defined in the netlink header file. <br>  An example of some of them: <br><br>  <b>RTMGRP_LINK</b> - this group receives notifications about changes in network interfaces (the interface has been deleted, added, lowered, raised) <br>  <b>RTMGRP_IPV4_IFADDR</b> - this group receives notification of changes in IPv4 interface addresses (the address has been added or deleted) <br>  <b>RTMGRP_IPV6_IFADDR</b> - this group receives notification of changes in IPv6 interface addresses (the address has been added or deleted) <br>  <b>RTMGRP_IPV4_ROUTE</b> - this group receives notifications of changes in the routing table for IPv4 addresses <br>  <b>RTMGRP_IPV6_ROUTE</b> - this group receives notifications of changes in the routing table for IPv6 addresses <br><br>  After the nlmsghdr header structure, the pointer to the data block is always located.  It can be accessed using macros, which will be discussed later. <br><br><h5>  Netlink macros </h5><br>  The most useful macros in this case are: <br>  <b>NLMSG_ALIGN</b> - Rounds the size of a netlink message to the nearest larger value aligned along the boundary. <br>  <b>NLMSG_LENGTH</b> ‚Äî Accepts the size of the data field (payload) as a parameter and returns the size-aligned value for writing in the nlmsg_len field of the nlmsghdr header. <br>  <b>NLMSG_SPACE</b> - Returns the size that data of the specified length will take in the netlink packet. <br>  <b>NLMSG_DATA</b> ‚Äî Returns a pointer to the data associated with the nlmsghdr header sent. <br>  <b>NLMSG_NEXT</b> - Returns the next part of a message consisting of many parts.  The macro accepts the following nlmsghdr header in a message consisting of many parts.  The calling application should check for the NLMSG_DONE flag in the current nlmsghdr <b>header</b> ‚Äî the function does not return NULL when the message processing is completed.  The second parameter sets the size of the rest of the message buffer.  The macro reduces this value by the size of the message header. <br>  <b>NLMSG_OK</b> - Returns true if the message was not truncated and it was successfully disassembled. <br>  <b>NLMSG_PAYLOAD</b> - Returns the size of the data (payload) associated with the nlmsghdr header. <br><br><h3>  From theory to practice. </h3><br>  Well then.  I think that I have already managed to get bored with the boring theory :) Maybe something seemed confusing or not understandable - I will try to chew everything in good examples, there really is nothing complicated. <br>  Below is the promised application that will receive notifications of changes in network interfaces and the routing table. <br>  In the example introduced a number of new structures: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">iovec</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *iov_base; <span class="hljs-comment"><span class="hljs-comment">//   __kernel_size_t iov_len; //   };</span></span></code> </pre><br>  This structure serves as a repository of payload data transmitted over netlink sockets.  The iov_base field is assigned a pointer to a byte array.  It is in this byte array that the message data will be written. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">msghdr</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *msg_name; <span class="hljs-comment"><span class="hljs-comment">//   ( ) int msg_namelen; //   struct iovec *msg_iov; //     __kernel_size_t msg_iovlen; //    void *msg_control; //    ,      __kernel_size_t msg_controllen; //     unsigned msg_flags; //   };</span></span></code> </pre><br>  This structure is directly passed through the socket.  It contains a pointer to a block of useful data, the number of data blocks, as well as a number of additional flags and fields that came, for the most part, from the BSD platform. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ifinfomsg</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> ifi_family; <span class="hljs-comment"><span class="hljs-comment">//  (AF_UNSPEC) unsigned short ifi_type; //   int ifi_index; //   unsigned int ifi_flags; //   unsigned int ifi_change; //  ,           0xFFFFFFFF };</span></span></code> </pre><br>  This structure is used to represent the network device, its family, type, index, and flags. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ifaddrmsg</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> ifa_family; <span class="hljs-comment"><span class="hljs-comment">//   (AF_INET  AF_INET6) unsigned char ifa_prefixlen; //    (  ) unsigned char ifa_flags; //   unsigned char ifa_scope; //   int ifa_index; //  ,     ifinfomsg };</span></span></code> </pre><br>  This structure is used to represent the network address assigned to the network interface. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">rtattr</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> rta_len; <span class="hljs-comment"><span class="hljs-comment">//   unsigned short rta_type; //   /*  */ }</span></span></code> </pre><br>  This structure is used to store any connection parameter or address. <br><br><h5>  Source code monitor </h5><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;errno.h&gt; #include &lt;stdio.h&gt; #include &lt;memory.h&gt; #include &lt;net/if.h&gt; #include &lt;arpa/inet.h&gt; #include &lt;sys/socket.h&gt; #include &lt;linux/rtnetlink.h&gt; //   ,     netlink    //       rtattr void parseRtattr(struct rtattr *tb[], int max, struct rtattr *rta, int len) { memset(tb, 0, sizeof(struct rtattr *) * (max + 1)); while (RTA_OK(rta, len)) { //     if (rta-&gt;rta_type &lt;= max) { tb[rta-&gt;rta_type] = rta; //  } rta = RTA_NEXT(rta,len); //    } } int main() { int fd = socket(AF_NETLINK, SOCK_RAW, NETLINK_ROUTE); //    if (fd &lt; 0) { printf("  netlink : %s", (char*)strerror(errno)); return 1; } struct sockaddr_nl local; //   char buf[8192]; //   struct iovec iov; //   iov.iov_base = buf; //  buf      iov iov.iov_len = sizeof(buf); //    memset(&amp;local, 0, sizeof(local)); //   local.nl_family = AF_NETLINK; //    local.nl_groups = RTMGRP_LINK | RTMGRP_IPV4_IFADDR | RTMGRP_IPV4_ROUTE; //    local.nl_pid = getpid(); //       //   netlink -    struct msghdr msg; { msg.msg_name = &amp;local; //   -    msg.msg_namelen = sizeof(local); //   msg.msg_iov = &amp;iov; //     msg.msg_iovlen = 1; //    } if (bind(fd, (struct sockaddr*)&amp;local, sizeof(local)) &lt; 0) { //    printf("   netlink : %s", (char*)strerror(errno)); close(fd); return 1; } //       while (1) { ssize_t status = recvmsg(fd, &amp;msg, MSG_DONTWAIT); //   bind()        //   if (status &lt; 0) { if (errno == EINTR || errno == EAGAIN) { usleep(250000); continue; } printf("   netlink: %s", (char*)strerror(errno)); continue; } if (msg.msg_namelen != sizeof(local)) { //  ,   :) printf("   "); continue; } //    struct nlmsghdr *h; //     for (h = (struct nlmsghdr*)buf; status &gt;= (ssize_t)sizeof(*h); ) { //     int len = h-&gt;nlmsg_len; //    int l = len - sizeof(*h); //    char *ifName; //   if ((l &lt; 0) || (len &gt; status)) { printf("  : %i", len); continue; } //    if ((h-&gt;nlmsg_type == RTM_NEWROUTE) || (h-&gt;nlmsg_type == RTM_DELROUTE)) { //     -   printf("    \n"); } else { //        char *ifUpp; //   char *ifRunn; //   struct ifinfomsg *ifi; //   ,      struct rtattr *tb[IFLA_MAX + 1]; //   , IFLA_MAX   rtnetlink.h ifi = (struct ifinfomsg*) NLMSG_DATA(h); //          parseRtattr(tb, IFLA_MAX, IFLA_RTA(ifi), h-&gt;nlmsg_len); //     if (tb[IFLA_IFNAME]) { //   ,    ifName = (char*)RTA_DATA(tb[IFLA_IFNAME]); //   } if (ifi-&gt;ifi_flags &amp; IFF_UP) { //    UP   ifUpp = (char*)"UP"; } else { ifUpp = (char*)"DOWN"; } if (ifi-&gt;ifi_flags &amp; IFF_RUNNING) { //    RUNNING   ifRunn = (char*)"RUNNING"; } else { ifRunn = (char*)"NOT RUNNING"; } char ifAddress[256]; //    struct ifaddrmsg *ifa; //         struct rtattr *tba[IFA_MAX+1]; //    ifa = (struct ifaddrmsg*)NLMSG_DATA(h); //     parseRtattr(tba, IFA_MAX, IFA_RTA(ifa), h-&gt;nlmsg_len); //     if (tba[IFA_LOCAL]) { //      inet_ntop(AF_INET, RTA_DATA(tba[IFA_LOCAL]), ifAddress, sizeof(ifAddress)); //  IP  } switch (h-&gt;nlmsg_type) { //   case RTM_DELADDR: printf("    %s\n", ifName); break; case RTM_DELLINK: printf("   %s\n", ifName); break; case RTM_NEWLINK: printf("  %s,   %s %s\n", ifName, ifUpp, ifRunn); break; case RTM_NEWADDR: printf("     %s: %s\n", ifName, ifAddress); break; } } status -= NLMSG_ALIGN(len); //     (    -   ,   :)) h = (struct nlmsghdr*)((char*)h + NLMSG_ALIGN(len)); //   } usleep(250000); //  ,       } close(fd); //    return 0; }</span></span></span></span></code> </pre><br><br>  Compile the program: <br> <b><code>gcc monitor.c -o monitor</code></b> <br> <br>  And the result of the work: <br><img src="http://habrastorage.org/storage/2c9f5070/71cea516/515d4925/340045ea.png"><br><br>  Explanation of the code. <br>  After starting the program, we create a netlink socket and check the success of its creation.  Next, the required variables are declared and the local address structure is populated.  Here we indicate the groups of messages we want to subscribe to: RTMGRP_LINK, RTMGRP_IPV4_IFADDR, RTMGRP_IPV4_ROUTE. <br>  We also declare the structure of the message and associate with it one data block. <br>  After that, binding to the socket occurs using bind ().  After that we become subscribed to messages for the specified groups.  You can receive messages through a socket. <br>  This is followed by an endless loop of receiving messages from the socket.  Because  A received data block can have several headers and their associated data ‚Äî we begin to iterate through all received data using netlink macros. <br>  Each new message is located at the pointer struct nlmsghdr * h. <br>  Now you can parse the message itself.  We look at the nlmsg_type field and find out what kind of message came to us.  If it is associated with the routing table, type the message and go to the next message.  And if not - we begin to understand in detail. <br>  Arrays of rtattr options are declared, where all the necessary data will be added.  The auxiliary function parseRtattr is responsible for obtaining this data.  It uses netlink macros and fills the specified array with all attributes from the ifinfomsg or ifaddrmsg structure data block. <br>  After we receive arrays filled with attributes, we can work with these values, analyze them, print. <br>  Each attribute is accessed by its index.  All indices are defined in netlink header files and commented. <br>  In this case, we use the following indices: <br>  IFLA_IFNAME is an attribute index with the name of the interface. <br>  IFA_LOCAL - attribute index with local IP address. <br>  After all this, we have complete information about what happened and we can print information on the screen. <br><br>  That's all.  I really hope that this material will be useful to someone. <br>  If there are enough willing (more than one person :)) - I can write a sequel and consider, for example, interaction with the kernel module or the implementation of working with IPv6. <br><br>  When writing an article used: <br>  1. <a href="http://tools.ietf.org/html/rfc3549">tools.ietf.org/html/rfc3549</a> <br>  2. <a href="http://www.linuxjournal.com/article/7356">www.linuxjournal.com/article/7356</a> <br><br>  Thanks for attention. </div><p>Source: <a href="https://habr.com/ru/post/121254/">https://habr.com/ru/post/121254/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../121246/index.html">Processor optimized for functional programming</a></li>
<li><a href="../121250/index.html">Another HTPC</a></li>
<li><a href="../121251/index.html">Type grouping concept in C ++</a></li>
<li><a href="../121252/index.html">Disable the jQuery library built into the MediaWiki 1.16.x engine, and replace it with a fresh one, updated and updated by the wiki administrators</a></li>
<li><a href="../121253/index.html">Free Cheese or Why so many reviews of Chinese Android tablets?</a></li>
<li><a href="../121256/index.html">How to train yourself to something</a></li>
<li><a href="../121257/index.html">Google has confirmed the acquisition of Admeld</a></li>
<li><a href="../121258/index.html">Snot blistering</a></li>
<li><a href="../121259/index.html">Facebook is preparing for the one hundred billion IPO in early 2012</a></li>
<li><a href="../121260/index.html">Are you still suffering without flash? Express review of Flash browsers for iPhone and iPad</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>