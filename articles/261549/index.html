<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Distributed cryptoprocessing</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="From the first day, when I began to realize how most of the financial processing works, the painful ‚ÄúIt‚Äôs impossible to live like this!‚Äù Was spinning ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Distributed cryptoprocessing</h1><div class="post__text post__text-html js-mediator-article">  From the first day, when I began to realize how most of the financial processing works, the painful ‚ÄúIt‚Äôs impossible to live like this!‚Äù Was spinning in my head.  But now, the concept of how to try to live, it seems, has developed.  Do you want strict consistency on N replicas without linear loss of speed?  Storage of states on blockchains? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a3d/2e0/baf/a3d2e0baf3f8c1129a578c0d8d089ed0.jpg" alt="image"><br><a name="habracut"></a><br><h4>  Introduction </h4><br>  This article is a ‚Äúdry residue‚Äù of thoughts on how to approach the solution of some inevitable problems in the system of distributed storage and state changes, financial processing in particular.  The article is not to "cast in granite" any one point of view, but rather for the exchange of views and constructive criticism. <br><br>  At once I will clarify: the described approaches work in accordance with the CAP theorem, do not allow data to move faster than the speed of light, and do not refute any other fundamental laws of nature. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Processing problem </h4><br>  Financial processing, a bird's-eye view, is a data structure that stores a set of states (balance sheets) and a history of changes in these states.  A program is attached to this structure, which determines the logic in accordance with which state changes are made.  It seems to be not particularly difficult. <br><br>  But processing requires the ability to conduct transactions as quickly as possible, since its main user is not Alice who sent Bob 10 rubles, but online stores with thousands and tens of thousands of customers who, with a drop in conversion, due to accidents or brakes, will go to competitors without hesitation .  (Actually, this seems to be the main reason why private processing cannot gobble up bitcoin). <br><br>  For an approximate understanding of existing needs, you can build on VISA reports on how <a href="http://visatechmatters.tumblr.com/post/96025603185/put-to-the-stress-test-visanet-gets-pushed-to-the">they prepare for New Year's peaks</a> . <br><br>  But as soon as we try to share the load, make the processing distributed (at each node there is a copy of the data and the ability to perform transactions), we will face the problem of data consistency. What is the actual problem? <br><br>  When a database with a lot of replicas is created, the question always arises of how to resolve the ambiguity (inconsistency) of data, when in some nodes of the system the data have already been changed, and before the other nodes the changes are still ‚Äúnot reached‚Äù.  With a parallel flow of changes, the system, from more than one node, simply can not always be in a consistent state (if you do not use the mechanisms described below). <br><br>  Existing terminology defines several types of consistency: <br><ul><li>  Strict consistency - after changing the data, the updated version is available immediately on all nodes of the system. </li><li>  Weak consistency - the system does not guarantee that subsequent accesses to the data will return the updated value.  Before the updated value is returned, a number of conditions must be met.  The period between the update and the moment when each observer is always guaranteed to see the updated value is called the inconsistency window. </li><li>  Eventual consistency is a special case of weak consistency.  The system ensures that in the absence of new data updates, ultimately, all requests will return the latest updated value.  In the absence of failures, the maximum inconsistency window size can be determined based on factors such as communication latency, system load, and number of replicas according to the replication scheme.  The most popular system implementing ‚Äúconsistency in the long run‚Äù is DNS.  The updated entry is distributed in accordance with the configuration parameters and settings of the caching intervals.  Ultimately, all customers will see the update. </li></ul><br><br>  This is a quotation of a <a href="http://habrahabr.ru/post/100891/">Habrpost</a> , in which there is much more interesting about the types of consistency, but for understanding the article these three are enough. <br><br>  If we score consistency, we get a vulnerability called the race condition.  In practice, this is exploited as ‚Äúdouble waste‚Äù (Double Spending is the most obvious way but far from the only) when two purchases are made for the same money if the time between purchases is less than the replication time.  There is <a href="https://www.schneier.com/blog/archives/2015/05/race_condition_.html">no need to go far</a> for an example.  How to deal with it? <br><br>  Modern distributed storage systems support different conditions under which the state change (commit) is recognized as successful, that is, the same state is available on all nodes of the network and is recognized by them as true.  With proper ‚Äúcooking,‚Äù these conditions can be very tight on life.  For example, in cassandra db modes are supported: <br><br><ul><li>  general commit - changes passed without errors on all nodes </li><li>  kommit by quorum - on most nodes the changes occurred without errors </li><li>  commit by the number of successes - on N nodes, changes occurred without errors </li></ul><br><br>  A general commit may seem salutary, but: <br><ul><li>  It does not scale well, since the relationship between the time required for a successful commit is linear (in the best case) depends on the number of nodes in the cluster. </li><li>  The same transaction is processed on all nodes, which does not solve the problem of load distribution. </li></ul><br><br>  In summary, a total commit might be good for redundancy, supporting a small number of hot copies, but is detrimental to speed and useless against a large number of transactions.  Partly because of this, the majority of modern successful (that is, large and growing) processings are <b>very</b> affected in the base area. <br><br><h4>  Task </h4><br>  From all that has been written, it is possible to derive the properties that a distributed structure must possess in order to claim the role of a part of modern processing: <br><ul><li>  Inability to race condition when conducting transactions </li><li>  Strict consistency in fixing the balance during the transaction </li><li>  Uniform distribution of computational load </li><li>  Capacity nodes with the influence on the optimal rate of linear </li><li>  No single point of failure </li></ul><br>  Here an interesting feature of the working conditions of processing can come to the rescue.  Transactions for the withdrawal of funds are made in it, in 95-99% of cases, by living people who do not really need immediate system readiness for the next transaction (10-60s).  Moreover, a fast transaction flow for write-off is sometimes specifically blocked, since it is a sign of quick withdrawal in case of theft (when there is a limit on the size of a single transaction).  If you go back to the example of an online store with thousands of customers, then individually, the customer does not pay often. <br><br>  Based on this property, we can describe a system that allows using the post-transaction time for an inconsistency window.  That is, after each transaction from a particular account, we will have a certain time interval T, which will be less than or equal to the data replication speed in the system and during which transactions from this and only this account will be impossible, but not more than the one that affects user experience 95-99% of customers.  First, a few terms. <br><br><h4>  Terms and Definitions </h4><br>  Necessary for ease of perception. <br><br><ul><li>  Transaction - a change in account status.  The same as the translation. </li><li>  An account is a certain ID with which some state (balance) is associated, which is changed by transactions. </li><li>  Chain is a chain of debit transactions associated with an ID.  It is designed like a classic block chain.  Technically, this is a write-off transaction log, where in each subsequent transaction there is a hash sum of the previous ones, this relationship gives two important properties <img src="https://habrastorage.org/getpro/habr/post_images/cf7/51b/e49/cf751be49ceb5e346aa91a88979d5ccf.png" alt="image"><ol><li>  Monitored transaction sequence </li><li>  Integrity control (not to be confused with authenticity control!).  If any of the transactions have been changed, then through checking the hashes it will immediately become noticeable. </li></ol><br></li><li>  A transaction request is a data structure in which the information necessary for conducting a transaction (to whom and how much) is located, but according to which the transaction has not yet been carried out and some decision on correctness has not yet been made </li><li>  A node is a program that stores a replica of all the chains in the system, ensures that the replica is up-to-date, processes transactions, creates new blocks (transactions and routes requests for transactions. A set of nodes forms a network or system. </li><li>  A system is a set of nodes that forms a network and that receives requests for transactions at the input.  The system works in a trusted environment: the nodes trust each other, that is, the Byzantine problem does not solve the problem. </li></ul><br><h4>  How to protect against race condition </h4><br>  First, consider the special case when the system is in a consistent state, that is, the chain for an attacking account is the same on all nodes at the time of creating two conflicting transaction requests on different nodes of the system.  In order to exclude the possibility of simultaneously processing a transaction request on two different nodes, we introduce the routing created by the nodes.  Moreover, in such a way that 2 conflicting requests for the transaction could not be processed and included in the chain on 2 different nodes.  How to do it? <br><br>  In order for the system to not have a single point of failure and scale horizontally (and also have a lot of nice features), it is reasonable to make routing based on the well-studied DHT protocol - Kademlia. <br><br>  What is DHT and why is one here?  In short, DHT is a space of values ‚Äã‚Äã(for example, all possible values ‚Äã‚Äãof the md5 hash function), which is evenly divided between network nodes. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/996/af7/bce/996af7bced9ae7e1dbc771ab273f8266.png" alt="image"><br><br>  In the picture, an example of a space of values ‚Äã‚Äãof 0-1000, which is distributed between nodes A, B, C, D, E, in this case is not uniform. <br><br>  In a DHT network, nodes contain information about the N nearest neighbors, and if you need to find a particular hash from a shared value space, by sending a request to such a network, you can relatively quickly find the node responsible for that part of the value space where the desired hash is located . <br><br>  To understand how quickly, 2 graphics with the dependence of the number of hops in the search for the classic implementation of Kademlia: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7b3/475/356/7b3475356cfb3e215877fcc0f25891b1.png" alt="image"><br><br>  And optimized: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/16c/a31/8dd/16ca318dd4c7a42d9661b90f3e18cd14.png" alt="image"><br><br>  As the number of hops in routing grows logarithmically, the network has outstanding horizontal scaling potential. <br><br>  By the way, DHT is used in Cassandra DB and Amazono Dynamo, but with an important difference, there it is used only for navigating shard data, and in case of changing the replicated data, the methods described in the introduction are used. <br><br>  How to make so that at change of the data in mirror replicas to exclude parallel change of the data on different replicas? <br><br>  To do this, we will consider the hash from the last transaction in the chain and use it as the value from the namespace, which is divided between the network nodes.  Thus, on both nodes where conflicting requests for a transaction were created, the resulting value will be the same (since in accordance with the chain on the nodes in a consistent state).  Further, using this value in the DHTsearch function, our requests will be ‚Äúpointed‚Äù to one and only one node, on which requests will be processed sequentially.  But this is in the case of initial consistency, which in the real world exists only on paper :) <br><br>  Now consider the general case when the system is in a non-consistent state, that is, the number of transactions in the chain of a particular account may differ from node to node.  Therefore, it is possible that 2 conflicting transactions will be received at nodes N1 and N2, where chains of different degrees of relevance (different recent transactions from which the hash is calculated), because of which requests for transactions will seem to be ‚Äúhovering‚Äù on nodes N3 and N4 accordingly, where they will be processed, which will lead to the "branching" of the chain, which should not be allowed.  If we consider this problem in detail, it does not exist, since we have an unequivocal connection: <br><br>  <u>..&gt; transaction&gt; processing node&gt; next transaction&gt; ..</u> <br><br>  that for different transactions of the same chain can be represented like this: <br>  <b>R</b> - route (value from a shared namespace) <br>  <b>N</b> - the node on which the next transaction is processed <br>  <b>T</b> - transaction <br><br>  <b>hash (T0) = R1</b> - destination, or the route to the node on which T1 will be processed <br>  <b>R1 -&gt; Nx</b> - we aim at the node <br>  <b>Nx -&gt; hash (T1)</b> - create a new route if T1 is processed successfully and included in the chain <br><img src="https://habrastorage.org/getpro/habr/post_images/b18/c4c/6d3/b18c4c6d3cf91b25476fc1f36f82991a.png" alt="image"><br><br>  From this it follows that if a transaction request arrives at a ‚Äúlagging‚Äù node, where the outdated version of the chain is, then this transaction request will be ‚Äúpointed‚Äù to the node where the most recent transaction has already been created and saved, i.e.  the last transaction hashes do not exactly match, and the request will be rejected.  There is no branching of the chain. <br><br>  Here it is better to go for tea. <br><br><h4>  Strict balance consistency </h4><br>  A method of safe state change was described, but for the processing work this is not enough, you need an unequivocal knowledge of which state we are changing into which: <br><br><ul><li>  Local unambiguity - on the node on which the transaction is processed, it should be possible to uniquely ‚Äúfix the balance‚Äù and exclude the possibility of re-using funds </li><li>  Inbound consistency - elimination of the possibility of double use of incoming funds in case of inconsistency of data on incoming funds on nodes when conducting two consecutive transactions (which, in accordance with the routing, will be performed on different nodes, and control through the routability of one chain does not guarantee the consistency of others routed independently ). </li></ul><br><br>  A small change in terminology - transactions, within the framework of this section, for simplicity of perception, are called incoming or outgoing transfers. <br><br>  How is all this achieved when transferring from IDa and IDb to IDc accounts, and then IDc does IDd transfer?  The initial state (here, for simplicity, is presented as a table, where each transaction added to the chain of some of the accounts is a series added from below): <br><br><table><tbody><tr><th>  Hash <br>  previous </th><th>  ID <br>  the sender </th><th>  ID <br>  recipient </th><th>  Transfer </th><th>  Balance </th><th>  the confirmation </th><th>  Control <br>  the sum <br>  incoming </th><th>  Previous hash <br>  confirmed </th></tr><tr><td>  Ba </td><td>  IDa </td><td>  IDc </td><td>  Xa </td><td>  Ya </td><td>  Null </td><td>  Ha </td><td>  Null </td></tr><tr><td>  Bb </td><td>  IDb </td><td>  IDc </td><td>  Xb </td><td>  Yb </td><td>  Null </td><td>  Hb </td><td>  Null </td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><br><br>  The balance that is on the account at the time of completion of the processing of the outgoing transfer is recorded in this transfer (data structure included in the chain).  All subsequent incoming transfers in this value are not entered into the ‚Äúlinked‚Äù transfer in any way and exist only as outgoing transfers on the chains of senders' accounts. <br><br>  Processing confirmations - a field in which it is noted whether the means of this transaction were used, that is, if A and B translate C, then this value is set to NULL in these translations, and after C translates D, then this value is for A and B will be changed to the hash of the transaction in which these funds participated (C =&gt; D). <br>  In the ‚ÄúHash of the previous confirmed‚Äù field, there will be respectively for each chain A and B the hash from the previous confirmed transaction in these chains, in which the ‚Äúprocessing confirmation‚Äù field is not zero, is entered.  (why is it described below) <br><br>  The balance in C =&gt; D is calculated in the following steps: <br><br><ol><li>  SELECT `Translation` FROM transactions WHERE` Recipient ID` = IDc AND `processing confirmation` = NULL;  Thus, we get the sum of all incoming funds that were transferred during the time period from the previous outgoing transfer with IDc. </li><li>  We consider the total balance by adding the value obtained in claim 1 to the balance value recorded in the last transfer IDc. </li><li>  We check the integrity of the sender's chains and whether the requested transfer meets all the necessary conditions, at a minimum, that the result is not negative.  Subtract the transfer from the amount received in paragraph 2. </li><li>  If everything is ok, then we write another translation to the table, and we‚Äôve set the hash of this transfer to the field ‚Äúconfirmation of processing‚Äù and ‚Äúthe hash of the previous confirmed one.‚Äù Yc is the IDc balance immediately after the transfer. <br></li></ol><br>  This algorithm allows you to uniquely fix the balance when translating performed on a node locally, while simultaneously receiving data that allows you to safely make the next transfer on a distributed system. <br><br>  When it comes to a distributed system, it is possible that the data on incoming transfers on the node on which the next transfer will be performed will be inconsistent with the data from the node where the previous transfer was performed: the "processing confirmation" field will also be set to NULL for transfers , which were used to calculate the balance in the previous transfer, as a result, these transfers can be credited again, which cannot be allowed. <br><br>  In order to detect such states, the ‚Äúincoming checksum‚Äù field is used, in which the hash from the hashes of all incoming transfers that were used as part of the outgoing processing is saved. <br><br>  Using this value, before processing a new N translation, you can check the consistency of incoming translations for N-1 translation, by collecting them (by value from the `processing confirmation` field), calculating the HASH hash (CONCAT (INCOME_BLOCKS)) from them and comparing it with the hash in the Checksum Incoming field in the N-1 translation.  In the event of a mismatch, the transfer request is rejected. <br><br>  Since the consistency of the last incoming transfers is verified by the described method, there is a possibility that due to the erroneous (or deliberate) resetting of the confirmation field in some old incoming transfer that was used to calculate the balance sometime in the past, this is the old incoming transfer when processing A new transfer may be counted by the recipient again, which cannot be allowed. <br><br>  In order to prevent this situation, the ‚Äúprevious confirmed hash‚Äù field is used, where the previous translation hash is set up with a non-zero confirmation, calculated using the value from this field (‚Äúprevious confirmed hash‚Äù), so we create a double connection in the sender's chain: the fact of transfer and the fact of receipt, i.e.  use by the recipient.  And if, due to zeroing (which destroys one of the links), confirming this transfer ‚Äúpops up‚Äù when calculating incoming ones, it will be rejected at the integrity control stage of the sender's chain. <br><br>  As a result, the final translation IDc =&gt; IDd will look like this: <br><table><tbody><tr><th>  Hash <br>  previous </th><th>  ID <br>  the sender </th><th>  ID <br>  recipient </th><th>  Transfer </th><th>  Balance </th><th>  the confirmation </th><th>  Control <br>  the sum <br>  incoming </th><th>  Previous hash <br>  confirmed </th></tr><tr><td>  Ba </td><td>  IDa </td><td>  IDc </td><td>  Xa </td><td>  Ya </td><td>  HASH (LAST_C_BLOCK) </td><td>  Ha </td><td>  HASH (LAST_CONFIRMD_A_BLOCK) </td></tr><tr><td>  Bb </td><td>  IDb </td><td>  IDc </td><td>  Xb </td><td>  Yb </td><td>  HASH (LAST_C_BLOCK) </td><td>  Hb </td><td>  HASH (LAST_CONFIRMD_A_BLOCK) </td></tr><tr><td>  Bc </td><td>  IDc </td><td>  Idd </td><td>  Xc </td><td>  Yc </td><td>  Null </td><td>  HASH (CONCAT (INCOME_BLOCKS)) </td><td>  Null </td></tr></tbody></table><br><br><h4>  About load sharing </h4><br>  If for routing cryptographic, that is, one that has the property of uniform distribution of values, is used as a hash function, all requests for a transaction from different accounts will be distributed evenly across all nodes, where they will be processed independently of each other, i.e.  the load will be distributed evenly. <br><br><h4>  fault tolerance </h4><br>  The loss of one node in the network will result in the system not being able to process only transactions directed to this node.  This problem can be solved by creating standby copies for each node in a simple case or by dynamically redistributing the name space between the remaining nodes (which should be done VERY carefully). <br><br><h4>  Conclusion </h4><br>  Despite the complexity of the presentation, I hope I was able to convey fundamental differences with traditional systems.  If you have found the strength to read this line up, then, probably, while waiting for the link to the githab, where will the collected concept already be?  Unfortunately, there is no practical PoC yet, however, the publication of this article is an attempt to collect the pitfalls that I could miss.  And one more step closer to practical implementation, so that all comments, constructive criticism, possible jambs are very welcome! <br><br><h4>  References </h4><br><ol><li>  <a href="http://docs.basho.com/riak/2.0.1/theory/dynamo/">Amazon's Dynamo</a> </li><li>  <a href="http://salsahpc.indiana.edu/b534projects/sites/default/files/public/1_Cassandra_Gala,%2520Dhairya%2520Mahendra.pdf">Cassandra (DHT)</a> </li><li>  <a href="http://pdos.csail.mit.edu/~petar/papers/maymounkov-kademlia-lncs.pdf">Kademlia</a> </li><li>  <a href="http://conviva.com/wp-content/uploads/The-Impact-of-DHT-Routing-Geometry-on-Resilience-and-Proximity.pdf">The Impact of DHT Routing Geometry on Resilience and Proximity</a> </li><li>  <a href="http://www-sop.inria.fr/members/Patrick.Valduriez/pmwiki/Patrick/uploads/Publications/AkbariniaCurrencySigmod07.pdf">Data Currency in Replicated DHTs</a> </li><li>  <a href="http://mirage.cs.uoregon.edu/pub/infocom06-kad.pdf">Improving the Lookup Performance over aWidely-Deployed DHT</a> </li></ol></div><p>Source: <a href="https://habr.com/ru/post/261549/">https://habr.com/ru/post/261549/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../261537/index.html">Manage dependencies in iOS applications correctly: Typhoon modularity</a></li>
<li><a href="../261539/index.html">Alt key for mouse gestures, as well as various important fixes in Vivaldi 1.0.212.3</a></li>
<li><a href="../261541/index.html">Expanding the functionality of the "notebook"</a></li>
<li><a href="../261543/index.html">We continue to expand the functionality of the browser Vivaldi</a></li>
<li><a href="../261547/index.html">Announcement Joker 2015 University Day: Celebration on student street</a></li>
<li><a href="../261551/index.html">Another smart home, in three parts. Part Three, User Interface</a></li>
<li><a href="../261553/index.html">Version 15.1 of DevExpress components for VCL released</a></li>
<li><a href="../261555/index.html">How was the usability conference UXPeople 2015</a></li>
<li><a href="../261559/index.html">New iOS 8.4, years spent on Facebook, Windows Phone success - and other news of the week for a mobile developer</a></li>
<li><a href="../261561/index.html">Parsing Formats: Packed Hashed Resources</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>