<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Unified API on PHP for all cloud push services</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Greetings to all readers. Now there are so many trends in web development that you will not follow. But the question of real-time interaction with use...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Unified API on PHP for all cloud push services</h1><div class="post__text post__text-html js-mediator-article">  Greetings to all readers.  Now there are so many trends in web development that you will not follow.  But the question of real-time interaction with users of the site is urgent to read for any project.  The easiest way is to install one of the widely available open comet-servers, for example, Dklab_Realplexor, Socket.IO or Faye - which one likes or depends on the stack of technologies.  True, this is a way of fairly complex projects where a team can afford such a solution. <br><br>  For many projects, it is simpler (although it is always a question of the specifics of the application) that it will be logical to use third-party solutions.  And it is simpler to rent a comet-server functionality as a service.  Today there is no shortage of such services, so we have something to review. <br><br>  And so, first, let's briefly review the existing push-services that allow us to maintain real-time communication between project clients without creating and maintaining our server infrastructure. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      There are only 6 such services: <b>Pusher</b> , <b>Pubnub</b> , <b>Partcl</b> , <b>BeaconPush</b> , <b>X-Stream.ly</b> and <b>ioBridge</b> (with some features).  Under the cat - a brief overview of all services, features of PHP libraries for them and a description of the library pushBridge.IO for unification of work with all cloud push-services. <br><a name="habracut"></a><br>  <b><a href="http://pusher.com/">Pusher.com</a></b> <br><img src="https://habrastorage.org/storage2/aef/b21/624/aefb21624cafee2161ecd80d42f50293.png"><br>  The most famous of these services.  At the same time and one of the most difficult because of the abundance of opportunities.  In general terms, communication is divided into channels, within which there are user events that client code (javascript) is subscribed to.  In addition, there are a number of system events, as well as a system of statuses and alerts and connections / disconnections of other channel users.  It is also possible to work with private channels, so that even a connected user, but not knowing a code identifier, will not receive events. <br><br>  To interact with other systems, Pusher uses the REST-HTTP-API (as well as all similar services), and provides a number of ready-made libraries for 11 languages, including Clojure, Groovy and ColdFusion.  I was only interested in PHP API, which is represented by 4 plugins - for Kohana, Code Igniter and bundle for Simfony 2 frameworks, as well as one independent class ( <a href="http://github.com/squeeks/Pusher-PHP">http://github.com/squeeks/Pusher-PHP</a> ).  It requires cURL and json extensions to work, and sha256 as a hashing algorithm. <br><br>  As a note, I‚Äôll say that it was from this service that the idea of ‚Äã‚Äãmy library arose.  I will be honest - for one project I needed realtime, and in the test version I didn‚Äôt want to write my server, so in a couple of minutes I thought to connect a pusher, especially since I already had an account.  It turned out that with all the merits and abundance of documentation, the system is not so simple, and not all the points are well described there.  debug mode was very helpful, when the site in the console section displays all your requests sent via the API in real time.  But somewhere I stepped and although requests were sent, they did not reach the client.  At this place, after an hour of debugging, I abandoned this case.  I didn‚Äôt like the prospect of rewriting the code at all, besides, in the final version of my project I would still have to switch to my own server.  So the idea came up - why should we rewrite everything every time, if you can try to put everything into one unified interface.  Looking ahead, I will say that the idea has successfully found its realization! <br><br>  <b><a href="http://pubnub.com/">PubNub.com</a></b> <br><img src="https://habrastorage.org/storage2/e6e/3e3/1c4/e6e3e31c4305c9323d0b1583dc6c02d4.png"><br>  This service is simpler and, in this, I see its advantage.  The API is extremely simple - there are channels, there are messages in them and that's it.  The data format is, of course, JSON everywhere.  Both in the client side and on the server side, Pubnub has the widest coverage, providing access to the service on any platform and programming language.  The simplicity and powerful support of all platforms makes this service the most interesting of those considered, especially if you need to provide real-time everywhere and everywhere. <br><br>  The PHP library for accessing the service is quite simple; it allows both sending and receiving messages based on cURL.  It works on both 5.2 and 5.3 versions of PHP, allowing you to use buns like callback functions.  After examining the source code, a big question remains - for some reason, when sending, after conversion to JSON, the message length should not exceed 1800 characters!  What this restriction is connected with is not yet clear, I will contact the developers and find out. <br><br>  <b><a href="http://partcl.com/">Partcl.com</a></b> <br><img src="https://habrastorage.org/storage2/483/af0/403/483af0403332ff17ab1779ceba2f9337.png"><br>  A fairly new service in this market, initially focused on embedding updated real-time tags on a web page.  Currently, the API there is quite expanded and allows you to get a history of changes in values, to build graphs, also working in real time, etc.  Unlike other services, positioned only as communication, Partcl works as a content provider, saving all messages and data, which is a rather unique function.  Expanding some of the details, I will say that the server part is written in Node.JS + Redis (it is real-time ‚Äúdistributor‚Äù - I am its direct developer), and the web part is in Zend Framework. <br><br>  Although the system has already written an API for PHP, and even a plugin for integration into Wordpress, it was, by my standards, quite primitive and could well not work on some hosts.  So I also tried to write a new library implementation for partcl.  It turned out even better than the original. <br><br>  <a href="http://beaconpush.com/"><b>BeaconPush.com</b></a> <br><img src="https://habrastorage.org/storage2/339/17f/27e/33917f27e5a6b03a5b8e67ef1e1df19c.png"><br>  A little-known service, but the only one that offers a dedicated server for demanding clients (the system, by the way, is written in Java).  And so, it is normal, though, in addition to channels and messages, it also brings the user‚Äôs abstraction to the top, simplifying the communication between specific connected clients.  In addition, an interesting functionality of web-hooks, when the service itself pulls the URL you specified, signaling about the input / output of users from the channel.  It is also possible to manage the possibilities of publications - if you do not enable it, anyone knowing the public ID will be able to publish data, otherwise only having a secret key. <br><br>  But with the PHP API, this service did not work out at all.  Of course, it is ( <a href="https://github.com/ImDom/BeaconPush-PHP">https://github.com/ImDom/BeaconPush-PHP</a> and even a module for Code Igniter), but the quality ... is very far from good.  By the way, the author of the module sewed your account into the source.  Honestly trying to use a ready-made module, but I could not configure it to work properly (stupidly refused to accept my account ID), I completely rewrote its API under Zend_Http. <br><br>  <a href="http://x-stream.ly/"><b>X-Stream.ly</b></a> <br><img src="https://habrastorage.org/storage2/305/70e/748/30570e748396f9b33ae7196ad0fead8d.png"><br>  One more almost unknown service, however possessing a number of interesting counters.  For example, you can create special keys to regulate access of specific users to the API (apparently due to the business model).  Also, it is the only one, except for Partcl, that has the functionality of persistent message storage.  Other features are more or less standard - channels, events, private channels with password access, user statuses.  A unique feature is a twitter feed, when the service itself will connect to the specified Twitter account and broadcast new messages to all connected users.  On the event of the appearance of messages in the channel, you can put kalbeky, which can also be controlled through the REST-API.  By the way, this service is the only one who requires the HTTP authorization to use for the publication (and generally access) to his HTTP API, except for the ID and the secret key, using the login and password of your account, as well as work only through an SSL connection, which makes additional hosting requirements. <br><br>  The server's native server API is more than scant - C #, Ruby and Node.JS.  I had to implement a part of their API from scratch, so here I am the first to write the library. <br><br>  <a href="http://www.iobridge.com/"><b>ioBridge.com</b></a> <br><img src="https://habrastorage.org/storage2/eb5/425/0cb/eb54250cb1595c4460dad2db26ebc0bf.png"><br>  The most interesting and strange service, not quite even push.  It is focused on connecting to the web all sorts of hardware (controllers and boards), and also provides data display, collection and storage, and of management via the web.  There is also no native client on PHP, there are several suggestions and code sketches in the official forum, but they are far from quality implementation.  Yes, and I understood why, starting to do it myself - the service is very strange in places, for example, to get the widget's actionId and session id, you need to make a request to their server, which immediately returns a piece of HTML + JavaScript, from which you have to retrieve data using stupid parsing of lines , which are then needed to connect and send commands.  Unfortunately, I could not advance further than the base code, apparently, for full testing it is necessary to connect the device itself.  So this code is not tested in real conditions, if anyone has experience with the service, I will be grateful for the tips and all possible help. <br><br>
<h4>  And now about the most important thing - pushBridge.IO PHP Library </h4><br><br>  My library for PHP is designed to replace all native libraries to access each of these services, provides a single and common interface to the basic functionality, while retaining the ability to work directly with the original library (for those cases when it is).  For some services, this is the first or, I do not feel shame, the best library (at least in PHP). <br><br>  So far, only the basic functionality has been implemented - connection and authorization, where required, and sending a message to the specified channel or generating a custom event.  All other specific functions can be obtained directly from an instance of the connection class.  In the next version, this will also be rewritten to not depend on other people's libraries and provide a single interface for all operations (retrieving the number of connected users, message history, reading messages, etc.). <br><br>  The library is divided into two parts - the base class is responsible for initializing the necessary adapter, processes the message, and if necessary, serializes it.  For this, I used the Zend_Serializer class, so all its formats are supported - from regular Json to exotic Wddx. <br><br>  The adapter class is responsible for working with specific services, which, if necessary, includes the native library.  So far, native classes are used only for Pusher and PubNub, due to the fact that the services provide their specific functions that have not yet been migrated.  But after initialization, you can always continue to work directly by simply calling the getConnection () method. <br><br>  I also tried to somehow unify the data for authorization.  Some services use app_id and a secret key, others call them publish and subscribe / public keys, etc.  Therefore, I tried to reduce them to the minimum set and save one name for all services: <br><ul><li>  <b>appId</b> - usually this is the application ID or API key, the unique identifier of the account or application </li><li>  <b>authKey</b> - the secret key that gives the right to publish data </li><li>  <b>secretKey</b> - password or other secret key for access to the account </li><li>  <b>readKey</b> - the public key for connecting as a client and reading data </li><li>  <b>emailKey</b> - username in the form of e-mail (for now it is exclusively for x-Stream.ly) </li></ul><br><br>  Three lines are enough to work with the library: <br><br><h5>  1. Initialization and connection. </h5><br><br> <code>$push = new pushBridge_IO( [ Adapter ], [serializer] );</code> <br> <br>  The first parameter is the adapter instance for the service you need, for example: <br><br> <code>new pushBridge_Adapter_Pusher(Array('appId' =&gt; 'Your app Id', 'authKey' =&gt; 'Your key', 'secretKey' =&gt; 'Your secret key', 'debug' =&gt; true)); <br> <br></code> <br><br>  Usually, it is enough only data for authorization, the set of which is specific to the service.  But the library, unlike its native classes, allows you to flexibly control connection methods using the Zend_Http network stack.  For requests, you can use cURL, directly sockets or an adapter to work through a proxy.  By default, cURL is used, but if you need, pass the name of the adapter as the httpAdapter parameter, and any of its settings in the httpAdapterConfig according to the ZF documentation ( <a href="http.client.adapters.html">for example, here</a> ).  I repent that at this moment there is still a bug in the current implementation of the library, while the options specified by the user for the adapter are not used, this will be fixed in the next version (the other day). <br><br>  Since different services require (or vice versa) different methods, you can specify in the method parameter how the adapter will connect to the server.  This is usually GET, but sometimes services only understand POST.  The adapter takes this into account, but you can override this parameter. <br><br>  The library inserts its custom header into the request, X-Powered-By, identifying itself, if you wish, you can disable it to save network traffic or just from the principle. <br><br>  The second parameter is the serializer that will process the message.  All services accept either JSON, or (some, for example, Partcl) just a string, without conversion.  Initially there is json using the Zend_Serializer class, however you can override with any other.  It is enough to pass either the string with the name of the serializer as the second parameter (we currently support: json, php and pickle) or immediately an instance of the Zend_Serializer class with the options you need. <br><br>  Examples: <br><br>  Partcl: <br> <code>$push = new pushBridge_IO( new pushBridge_Adapter_Partcl(Array('secretKey' =&gt; 'Your secret key')) );</code> <br>  Pusher: <br> <code>$push = new pushBridge_IO( new pushBridge_Adapter_Pusher(Array('appId' =&gt; 'Your app Id', 'authKey' =&gt; 'Your key', 'secretKey' =&gt; 'Your secret key', 'debug' =&gt; true)) );</code> <br>  Pubnub: <br> <code>$push = new pushBridge_IO( new pushBridge_Adapter_Pubnub(Array('readKey' =&gt; 'Your subscribe key', 'authKey' =&gt; 'Your publish key', 'secretKey' =&gt; ' Your secret key')) );</code> <br>  BeaconPush: <br> <code>$push = new pushBridge_IO( new pushBridge_Adapter_Beaconpush(Array('authKey' =&gt; 'Your API Key', 'secretKey' =&gt; 'Your secret key')) );</code> <br>  And as an example with a custom serializer: <br> <code>$push = new pushBridge_IO( new pushBridge_Adapter_Partcl(Array('secretKey' =&gt; ' Your secret key')), 'php' );</code> <br>  or <br> <code>$push = new pushBridge_IO( new pushBridge_Adapter_Partcl(Array('secretKey' =&gt; 'Your secret key')), Zend_Serializer::factory('Wddx', Array('comment' =&gt; 'Powered by ZF+pushBridge.IO') );</code> <br> <br><h5>  2. Just send a message. </h5><br><br>  In fact, everything is not so simple.  Services work very differently with messages.  The simplest is the channel-&gt; message model (or the tag -&gt; message), while others introduce a new level - the channel -&gt; event -&gt; message.  However, only partcl is very tolerant of the content of the message, for it is just a string, and its understanding is shifted completely to the client.  Others require special wrapping of messages in a json structure.  None of the services supports mass sending of messages, when in one request it would be possible to publish data in different channels or several different messages and events in one channel.  We have already taken into account this moment and in the next version of our service Partcl.com such an opportunity will appear in parallel in the library and emulation of this functionality for everyone else (for the sake of fairness, this functionality is implemented in the class for BeaconPush, but not ported to my library ). <br><br>  The general dispatch method is as follows: <br><br> <code>$push-&gt;send( '', 'channel', 'config' );</code> <br> <br>  An already converted string falls into the adapter method, so that it is guaranteed to receive data and it is something more than an empty string.  However, if the service requires it, the adapter will form the necessary Json structure over the message data. <br><br>  If the service uses channels, the second parameter is the string (or array) of channels to which the message should be sent.  if there are no channels, this is a tag id or another id. <br><br>  If you need to set an event code, you should use the config - the third parameter is always an array.  The event is set in the event parameter.  Additionally, you can disable serialization by passing the parameter serialize = false.  If the service accepts, you can specify additional message parameters, for example, the save data flag for X-Stream.ly or enable / disable the debug mode for the message in Pusher. <br><br>  An example of sending a simple message: <br><br>  Partcl: <br> <code>$push-&gt;send('Hello world from pushBridge.IO', 'Your tag id', Array('serialize' =&gt; false));</code> <br>  Pusher: <br> <code>$push-&gt;send('Hello world from pushBridge.IO', 'test_channel', Array('serialize' =&gt; false, 'event' =&gt; 'push_test', 'debug' =&gt; true));</code> <br>  Pubnub: <br> <code>$push-&gt;send('Hello world from pushBridge.IO', 'my_channel');</code> <br>  x-Stream.ly: <br> <code>$push-&gt;send('Hello world from pushBridge.IO', 'mychannel', Array('event' =&gt; 'my_event', 'persisted' =&gt; true));</code> <br> <br>  Of course, by default, the maximum parameters are set so that there is no need to specify something, often even the name of the channel or event is set as they are assigned by the service after registration.  But for a more complete understanding of the options, you should refer to the documentation for a particular service. <br><br><br>  Library source code and brief examples: <a href="https://github.com/aleksraiden/pushBridge.IO/tree/ServiceWrapper"><b></b></a><b><a href="https://github.com/aleksraiden/pushBridge.IO/tree/ServiceWrapper">github.com/aleksraiden/pushBridge.IO/tree/ServiceWrapper</a></b> <br><br>  The plans for the next release: error correction, unification of the send method, support for publishing several variables at once, the implementation of the data reading method, as well as raising the project site on the <a href="http://pushcloudapi.com/"><b>pushcloudapi.com</b></a> domain.  I would be grateful for comments and additions. </div><p>Source: <a href="https://habr.com/ru/post/136230/">https://habr.com/ru/post/136230/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../136222/index.html">Manual: Pyramid for People - Part 2</a></li>
<li><a href="../136224/index.html">We build a tracked Bluetooth robot with a camera. Part 3</a></li>
<li><a href="../136225/index.html">About two-dimensional packaging: offline algorithms</a></li>
<li><a href="../136227/index.html">Multi-criteria selection of alternatives using fuzzy inference rules. Implementation in Java. Part 3/3: Example</a></li>
<li><a href="../136228/index.html">JQuery plugin for sorting tables: TableSorter.js. How to achieve pagination?</a></li>
<li><a href="../136232/index.html">On the possibilities of antiviruses. Part 1</a></li>
<li><a href="../136234/index.html">An inside view: the world around us</a></li>
<li><a href="../136236/index.html">(#KatawaShoujo) Visual novel ‚ÄúKatawa Shoujo‚Äù as a bright event in the world of free culture and charity</a></li>
<li><a href="../136237/index.html">Neural network against DDoS'a</a></li>
<li><a href="../136238/index.html">Gorgeous Stickers with CSS3</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>