<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Machine War: PVS-Studio vs TensorFlow</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content=""I'll be back" ¬©. I think everyone knows this phrase. And although today we will not speak about the return of the terminator, the topic of the articl...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Machine War: PVS-Studio vs TensorFlow</h1><div class="post__text post__text-html js-mediator-article"><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5b3/f72/6ae/5b3f726ae3fe44d9cf1633ca30aac88b.png"></div><p></p><br>  "I'll be back" ¬©.  I think everyone knows this phrase.  And although today we will not speak about the return of the terminator, the topic of the article is somewhat similar.  Today we‚Äôll tell you about checking the TensorFlow machine learning library and try to find out if we can sleep well, or if the Skynet hour is close ... <br><a name="habracut"></a><br><h2>  Tensorflow </h2><br>  <a href="https://www.tensorflow.org/">TensorFlow</a> is a machine learning library developed by Google and available as an open-source project from November 9, 2015.  Currently it is used in research and in dozens of Google‚Äôs commercial products, including Google Search, Gmail, Photos, YouTube, Translate, Assistant, etc. The project‚Äôs source code is available in the <a href="https://github.com/tensorflow/tensorflow">repository on GitHub</a> , as well as on the <a href="https://opensource.google.com/projects/tensorflow">website Google projects</a> . <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b27/005/81e/b2700581e527bd24671e6633a9e2ac88.png" alt="Picture 13"></div><p></p><br><br>  Why did you choose this project? 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ol><li>  Google.  If the project is developed by Google, Microsoft or other eminent developers, then its verification and error detection is, in a way, a challenge.  In addition, I think many people are interested in how developers from eminent corporations are mistaken (or not mistaken). </li><li>  Machine learning.  Recently, this topic is gaining more and more popularity.  And for good reason, some results are really impressive!  I do not give examples, if you wish, you can easily find them yourself. </li><li>  Statistics on github.  It is also an important criterion, because the more popular the project, the better.  So, TensorFlow beats all conceivable and inconceivable records!  It is in the top C ++ projects, has more than 50,000 stars and more than 20,000 forks.  Incredible! </li></ol><br>  Of course, by such a project can not pass.  I don‚Äôt even know why my colleagues didn‚Äôt check it before.  Well, I'll fix it. <br><br><h2>  And what was checked? </h2><br>  If you know what PVS-Studio is, then you also know the answer to this question.  But do not rush to read further, what if you don‚Äôt know everything about our analyzer?  For example, that we have <a href="https://www.viva64.com/ru/b/0362/">already had a C # analyzer for more than a year</a> and about half a year - a <a href="https://www.viva64.com/ru/b/0441/">version for Linux</a> . <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/56a/45d/b66/56a45db663b499bf70e079c9504c85d7.png" alt="Picture 16"></div><p></p><br><br>  For those who are not in the subject.  The source code analysis was carried out using the <a href="https://www.viva64.com/ru/pvs-studio/">PVS-Studio</a> static analyzer, which looks for errors in programs written in C, C ++ and C #.  PVS-Studio works under Windows and Linux and at the moment over 400 diagnostic rules are implemented in it, the description of which can be found on the <a href="https://www.viva64.com/ru/w/">corresponding page</a> . <br><br>  In addition to analyzer development, we check open-source projects and write articles based on the results of testing.  At the moment we have checked more than <a href="https://www.viva64.com/ru/inspections/">280 projects</a> in which we found more <a href="https://www.viva64.com/ru/examples/">than 10,800 errors</a> .  And these are not some ordinary projects, but rather well-known ones: <a href="https://www.viva64.com/ru/b/0442/">Chromium</a> , <a href="https://www.viva64.com/ru/b/0446/">Clang</a> , <a href="https://www.viva64.com/ru/b/0425/">GCC</a> , <a href="https://www.viva64.com/ru/b/0363/">Roslyn</a> , <a href="https://www.viva64.com/ru/b/0377/">FreeBSD</a> , <a href="https://www.viva64.com/ru/b/0330/">Unreal Engine</a> , <a href="https://www.viva64.com/ru/b/0431/">Mono</a> , etc. <br><br>  PVS-Studio <a href="https://www.viva64.com/ru/pvs-studio-download/">is available for download</a> , so I advise you to try on your project and see what interesting things you can find. <br><br>  By the way, the PVS-Studio tag is on StackOverflow ( <a href="https://stackoverflow.com/questions/tagged/pvs-studio">link</a> ).  I recommend asking questions there, so that in the future other developers could quickly find the information they need without waiting for our answers by mail.  We, in turn, are always happy to help our users. <br><br><h2>  Article format </h2><br>  This time I want to move away from the traditional verification sequence: 'I loaded the project ‚Üí I checked ‚Üí I wrote about the errors found' and to tell in more detail about some of the analyzer settings, and how they can be useful.  In particular, I will show how you can effectively deal with false positives, which can be useful for disabling diagnostics and excluding from checking or outputting certain files.  And, of course, let's take a look at what PVS-Studio managed to find in the TensorFlow source code. <br><br><h2>  Preparation for analysis </h2><br>  Now that <a href="https://www.viva64.com/ru/m/0036/">PVS-Studio is available under Linux</a> , there is a choice of where to perform the verification of the project: under Linux or Windows.  Most recently, I tested one project under openSUSE, it was quite simple and convenient, but I decided to check TensorFlow under Windows.  So familiar.  In addition, it can be built using CMake, which implies further work in the Visual Studio development environment, for which we have a plugin (by the way, in its latest version, line selection with erroneous code appeared). <br><br>  Officially build TensorFlow under Windows is not supported ( <a href="https://www.tensorflow.org/install/install_sources">according to the site</a> ).  However, there is also a link on how to build a project using CMake.  And, I must say, it is easy to assemble according to <a href="https://github.com/tensorflow/tensorflow/tree/master/tensorflow/contrib/cmake">this instruction</a> . <br><br>  As a result, we obtain a set of <i>.vcxproj</i> files combined into <i>.sln</i> , which means that we can continue to conveniently work with the project from within Visual Studio.  And it pleases.  I worked from under the Visual Studio 2017 IDE, the support of which was added in the <a href="https://www.viva64.com/ru/m/0010/">PVS-Studio 6.14 release</a> . <br><br>  <b>Note.</b>  Before analyzing, it would be nice to put together a project, make sure everything is going well and there are no errors.  This is necessary in order to be sure that the analysis will pass qualitatively and the necessary syntactic and semantic information will be available to the analyzer.  So, on the TensorFlow website there is a note: <i>By default, building TensorFlow from sources consumes a lot of RAM.</i>  Well, it's okay, because I have 16Gb RAM on my machine.  And what do you think?  During the build, I had an error <a href="https://msdn.microsoft.com/en-us/library/yz7kx3y2.aspx">Fatal Error C1060</a> (compiler is out of heap space)!  Not enough memory!  It was quite unexpected.  And, no, I didn‚Äôt run 5 virtual machines simultaneously with the build.  In fairness, I note that when building via <a href="https://bazel.build/">bazel,</a> you can limit the amount of RAM used (as described in the TensorFlow assembly instructions). <br><br>  And now I can't wait to click on the cherished button ‚ÄúAnalyze solution with PVS-Studio‚Äù and see what interesting things can be found, but first it would be nice to exclude from the analysis those files that are not interesting to us, for example, third-party libraries.  This is done in the settings of PVS-Studio quite simply: on the 'Don't Check Files' tab, we set the masks of those files and paths that we are not interested in analyzing.  There is already a set of paths in the settings (for example, / boost /).  I added two masks to it: / third_party / and / external /.  This will allow not only to exclude warnings from the results window, but also not to perform the analysis of files in these directories, which has a positive effect on the analysis time. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7a0/a37/a71/7a0a37a7162eea1a888f3ec0a39f43ef.png" alt="Figure 1 - Specify analysis exceptions in the settings of PVS-Studio"></div><p></p><br>  <font color="#999999"><i>Figure 1 - Specify analysis exceptions in the settings of PVS-Studio</i></font> <br><br>  And now you can run the analysis and see what interesting things you can find. <br><br>  <b>Note.</b>  'Don't Check Files' can be configured 'before' and 'after' analysis.  I told about the first case above, in the second one the filtering of the already received log will be performed, which is also useful and will eliminate the viewing of unnecessary warnings.  This will be below. <br><br><h2>  False alarms: funny arithmetic </h2><br><h3>  Why false alarms are important (and unpleasant) </h3><br>  False positives are a headache for everyone: for us, the developers of the static analyzer, and for the users, as they clog up a useful conclusion.  A large number of false positives can repel people from using the tool.  In addition, people often evaluate analyzers by the criterion of how many false alarms they give out.  It's not so simple, and this topic is suitable for a separate article and discussion.  My colleague, by the way, recently just wrote <a href="https://www.viva64.com/ru/b/0488/">an article on this topic</a> , I recommend reading. <br><br><h3>  How to deal with false positives? </h3><br>  Our task is to try to filter out as many false positives as possible at the analysis stage so that the user doesn‚Äôt know about them at all.  For this purpose, exceptions are introduced into the diagnostic rules, i.e.  special cases in which it is not necessary to issue warnings.  The number of these exceptions can vary greatly from diagnostics to diagnostics: somewhere they may not exist at all, but tens of such exceptions can be realized somewhere. <br><br>  Nevertheless, all cases are not covered (sometimes they are very specific), so our second task is to give the user the opportunity to independently eliminate false alarms from the results of the analysis.  For this, the PVS-Studio analyzer implements a number of mechanisms, such as suppression of false positives through comments, configuration files, and suppression bases.  Again, a <a href="https://www.viva64.com/ru/m/0017/">separate article has been</a> written about this, so here I will not dig deep into it. <br><br><h3>  False positives and TensorFlow </h3><br>  Why do I even started a conversation about false positives?  Firstly, because the fight against false positives is important, and, secondly, because that's what I saw when I checked TensorFlow and filtered the output according to the <a href="https://www.viva64.com/ru/w/V654/">V654</a> diagnostic rule. <br><br><p><img src="https://habrastorage.org/getpro/habr/post_images/4eb/081/883/4eb0818836693fa064b7f8e4dd33989c.png" alt="Figure 2 - All found responses have a similar pattern."></p><br>  <font color="#999999"><i>Figure 2 - All found <a href="http://www.viva64.com/ru/w/V654/">V654</a> operations have a similar pattern.</i></font> <br><br>  64 operations, and all, like one, the same pattern - code of the form: <br><br><pre><code class="cpp hljs"><span class="hljs-literal"><span class="hljs-literal">false</span></span> &amp;&amp; expr</code> </pre> <br>  In the code itself, these places look like this: <br><br><pre> <code class="cpp hljs">DCHECK(v); DCHECK(stream != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>); DCHECK(result != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>);</code> </pre> <br>  This is how the <i>DCHECK</i> macro is <i>declared</i> : <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> NDEBUG .... #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DCHECK(condition) CHECK(condition) .... #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> .... #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DCHECK(condition) \ while (false &amp;&amp; (condition)) LOG(FATAL) .... #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span></span></code> </pre> <br>  What follows from this code?  <i>DCHECK</i> - debug macro.  In the debug version of the code it is revealed in the condition check ( <i>CHECK (condition)</i> ), in the release version - in a loop that will not be executed once - <i>while (false &amp;&amp; ....)</i> .  Due to the fact that I was collecting the release version of the code, the macro was opened accordingly (in a <i>while loop</i> ).  As a result, the analyzer seems to be cursing in the case, because the result of the expression is always always <i>false</i> .  But what is the use of these warnings, if they are issued to the code that was meant to be so?  As a result, the percentage of false positives for this diagnostic will be the same as in the diagram below. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b6b/e0b/f20/b6be0bf20fb17ef4a76abaa0faf6d1dd.png" alt="Figure 3 - The ratio of good and false positives diagnostics"></div><p></p><br>  <font color="#999999"><i>Figure 3 - The ratio of good and false positives diagnostics <a href="http://www.viva64.com/ru/w/V654/">V654</a></i></font> <br><br>  Maybe you thought it was a joke?  No, not a joke, 100% false positives.  I spoke about such specific cases above.  He also said that there are ways to deal with them.  With a slight movement of the hand and the button 'Add selected messages to suppression base' we can correct this ratio in the opposite direction. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a2e/4eb/480/a2e4eb4803082a259c874ad3dc212a02.png" alt="Figure 4 - Fighting False Positives"></div><p></p><br>  <font color="#999999"><i>Figure 4 - Fighting False Positives</i></font> <br><br>  This way you can suppress all current warnings by removing them from the output window.  But this is not entirely correct, since if you again use the <i>DCHECK</i> macro in the course of writing the code, warnings will be issued again.  There is a solution.  It is necessary to suppress the triggering in the macro, leaving a special comment.  The suppression code will look like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//-V:DCHECK:654 #define DCHECK(condition) \ while (false &amp;&amp; (condition)) LOG(FATAL)</span></span></code> </pre> <br>  The comment should be placed in the same header file where the macro is declared. <br><br>  That's all, now you can no longer worry about the <i>DCHECK</i> macro, because  <a href="http://www.viva64.com/ru/w/V654/">V654</a> warning on him will no longer be issued.  As a result, we again successfully fought with false positives.  Anyway, after these actions, the false positive chart for <a href="http://www.viva64.com/ru/w/V654/">V654</a> will look like this. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/088/728/d13/088728d138945eefad7d70ebbc82df0e.png" alt="Figure 5 - Successfully eliminated false positives"></div><p></p><br>  <font color="#999999"><i>Figure 5 - Successfully eliminated false positives</i></font> <br><br>  Now the picture looks a completely different way, because the percentage of false positives is 0. Such is the entertaining arithmetic.  Why all this talk about false positives?  I just wanted to explain that false positives are inevitable.  The goal of the analyzer is to get rid of as many of them as possible at the analysis stage, but due to the specifics of the project, you may have to deal with them.  I hope I managed to convey that it is possible (and necessary) to deal with false positives, and this is done quite simply. <br><br><h2>  Some more settings </h2><br>  Surely you can‚Äôt wait to look at the errors found, but I call for patience and I propose to consider some other settings that will help make life easier when working with the results of the analysis. <br><br><h3>  Warnings in automatically generated files </h3><br>  In the course of the analysis, it was checked not only the code that the programmers wrote themselves, but also automatically generated ones.  We are not interested in viewing warnings on such a code, so we need to somehow exclude them from the analysis.  Here come the settings mentioned earlier 'Don't check files'.  Specifically for this project, I set exceptions for the following file names: <br><br><pre> <code class="cpp hljs">pywrap_* *.pb.cc</code> </pre> <br>  This made it possible to hide more than 100 general-purpose (GA) warnings with an average confidence level (Medium). <br><br><h3>  Disabling specific diagnostics </h3><br>  Another analyzer setting that turned out to be useful is disabling groups of diagnostic rules.  Why this may be relevant?  For example, about 70 <a href="https://www.viva64.com/ru/w/V730/">V730</a> warnings were issued on this project (not all members of the class are initialized in the constructor).  Do not pass by these warnings, because  they can signal difficult-to-detect errors.  However, it is not always clear to someone unfamiliar with the code whether the uninitialized member will actually lead to problems, or there is some tricky way to further initialize it.  And for the article errors of this type are not the most interesting.  Therefore, they should be reviewed by developers, and we will not focus on this.  From here, the goal is formed - disabling a whole group of diagnostic rules.  This is done easily and simply: in the settings of the PVS-Studio plugin, it is enough to remove the selection for the 'Check box' from the corresponding diagnostics. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7dc/a25/cf0/7dca25cf0ce080ea3d2771f6a59595a4.png" alt="Figure 6 - Disabling irrelevant diagnostics"></div><p></p><br>  <font color="#999999"><i>Figure 6 - Disabling irrelevant diagnostics</i></font> <br><br>  By disabling those diagnostic rules that are not relevant for your project, you thereby simplify further work with the output of the analyzer. <br><br><h2>  Parsing Alerts </h2><br>  Well, let's move on to perhaps the most interesting part - the analysis of those code fragments that PVS-Studio found suspicious. <br><br>  I usually like to start with the classic error that is allowed in both C ++ projects and C # - an error of the form <i>a == a</i> , which is found by the diagnostic rules <a href="https://www.viva64.com/ru/w/V501/">V501</a> and <a href="https://www.viva64.com/ru/w/V3001/">V3001</a> .  But there are no such mistakes!  And in general, the set of detected errors is sufficient ... specific.  But let's not pull, get down to business. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToGraphDef</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Graph* g, GraphDef* gdef, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pretty)</span></span></span><span class="hljs-function"> </span></span>{ .... gtl::InlinedVector&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Edge*, <span class="hljs-number"><span class="hljs-number">4</span></span>&gt; inputs; .... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Edge* e : inputs) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> srcname = NewName(e-&gt;src(), pretty); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e == <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>) { ndef-&gt;add_input(<span class="hljs-string"><span class="hljs-string">"unknown"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!e-&gt;src()-&gt;IsOp()) { } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e-&gt;IsControlEdge()) { ndef-&gt;add_input(strings::StrCat(<span class="hljs-string"><span class="hljs-string">"^"</span></span>, srcname)); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e-&gt;src_output() == <span class="hljs-number"><span class="hljs-number">0</span></span>) { ndef-&gt;add_input(srcname); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { ndef-&gt;add_input(strings::StrCat(srcname, <span class="hljs-string"><span class="hljs-string">":"</span></span>, e-&gt;src_output())); } } .... }</code> </pre> <br>  ‚Üí <a href=""><u>Link to GitHub</u></a> <br><br>  <b>PVS-Studio</b> <a href="http://www.viva64.com/ru/w/V595/">warning</a> : <a href="http://www.viva64.com/ru/w/V595/">V595</a> The 'e' pointer was used before it was verified against nullptr.  Check lines: 1044, 1045. function.cc 1044 <br><br>  In the loop, the elements of the vector are traversed and, depending on the value of the element, certain actions are performed.  Checking <i>e == nullptr</i> implies that the pointer may be null.  Here is just a line above, during the call to the <i>NewName</i> function, this pointer is dereferenced: <i>e-&gt; src ()</i> .  The result of such an operation is undefined behavior, which may lead, inter alia, to the emergency termination of a program. <br><br>  But the TensorFlow code is not so simple.  The filling of this vector ( <i>inputs</i> ) is higher and looks like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Edge* e : n-&gt;in_edges()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e-&gt;IsControlEdge()) { inputs.push_back(e); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (inputs[e-&gt;dst_input()] == <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>) { inputs[e-&gt;dst_input()] = e; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { LOG(WARNING) &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Malformed graph node. multiple input edges: "</span></span> &lt;&lt; n-&gt;DebugString(); } } }</code> </pre> <br>  Looking attentively at this code, it can be understood that zero <i>inputs</i> will never be written to the <i>inputs</i> vector, because before adding elements, pointer dereference is always performed, moreover, before a pointer dereference, its check for equality <i>nullptr is missing</i> .  Since the <i>inputs</i> vector <i>will</i> not contain null pointers, it turns out that the expression <i>e == nullptr</i> , which we talked about earlier, will always be <i>false</i> . <br><br>  Anyway, this is a tricky code, and PVS-Studio successfully found it.  Go ahead. <br><br><pre> <code class="cpp hljs">Status MasterSession::StartStep(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> BuildGraphOptions&amp; opts, int64* count, ReffedClientGraph** rcg, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> is_partial) { .... ReffedClientGraph* to_unref = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (to_unref) to_unref-&gt;Unref(); .... }</code> </pre> <br>  ‚Üí <a href=""><u>Link to GitHub</u></a> <br><br>  <b>PVS-Studio</b> <a href="http://www.viva64.com/ru/w/V547/">warning</a> : <a href="http://www.viva64.com/ru/w/V547/">V547</a> Expression 'to_unref' is always false.  master_session.cc 1114 <br><br>  In the body of the method, a local variable <i>to_unref is declared</i> , initialized by the value <i>nullptr</i> .  Before the <i>if statement,</i> this pointer is not used, its value does not change.  Therefore, since the pointer has remained zero, the body of the <i>if</i> operator will never be executed.  This code may have remained after refactoring.  Maybe this pointer should have been used somewhere between initialization and validation, but another one was used instead (mixed up), but I did not find similar names.  It looks suspicious. <br><br>  Go ahead. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LSTMBlockCellBprop</span></span></span><span class="hljs-class"> .... {</span></span> .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...., </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> use_peephole, ....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (use_peephole) { cs_prev_grad.device(d) = cs_prev_grad + di * wci.reshape(p_shape).broadcast(p_broadcast_shape) + df * wcf.reshape(p_shape).broadcast(p_broadcast_shape); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (use_peephole) { wci_grad.device(d) = (di * cs_prev).sum(Eigen::<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>&gt;({<span class="hljs-number"><span class="hljs-number">0</span></span>})); wcf_grad.device(d) = (df * cs_prev).sum(Eigen::<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>&gt;({<span class="hljs-number"><span class="hljs-number">0</span></span>})); wco_grad.device(d) = (do_ * cs).sum(Eigen::<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>&gt;({<span class="hljs-number"><span class="hljs-number">0</span></span>})); } .... } };</code> </pre> <br>  ‚Üí <a href=""><u>Link to GitHub</u></a> <br><br>  <b>PVS-Studio</b> <a href="http://www.viva64.com/ru/w/V581/">warning</a> : <a href="http://www.viva64.com/ru/w/V581/">V581</a> The conditional expressions of the 'if' are agreed alongside each other are identical.  Check lines: 277, 284. lstm_ops.h 284 <br><br>  There are two conditional operators with the same conditional expression, while the expression between these operators (in this case, the <i>use_peephole</i> parameter) does not change.  Sometimes this may indicate a rather serious error, when in one of the cases we used not the expression that was meant, but in this case, starting from the context, we can conclude that we simply duplicated conditional statements.  I think this is not a mistake, but all operations could be placed in one conditional operator. <br><br>  You can not write an article and not look at the copy-paste error. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CompressFlags</span></span></span><span class="hljs-class"> {</span></span> .... Format format; .... <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> quality = <span class="hljs-number"><span class="hljs-number">95</span></span>; .... <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> progressive = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; .... <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> optimize_jpeg_size = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; .... <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> chroma_downsampling = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; .... <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> density_unit = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x_density = <span class="hljs-number"><span class="hljs-number">300</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y_density = <span class="hljs-number"><span class="hljs-number">300</span></span>; .... StringPiece xmp_metadata; .... <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> stride = <span class="hljs-number"><span class="hljs-number">0</span></span>; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EncodeJpegOp</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> OpKernel { .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EncodeJpegOp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(OpKernelConstruction* context)</span></span></span><span class="hljs-function"> : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OpKernel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(context)</span></span></span><span class="hljs-function"> </span></span>{ .... OP_REQUIRES_OK(context, context-&gt;GetAttr(<span class="hljs-string"><span class="hljs-string">"quality"</span></span>, &amp;flags_.quality)); OP_REQUIRES(context, <span class="hljs-number"><span class="hljs-number">0</span></span> &lt;= flags_.quality &amp;&amp; flags_.quality &lt;= <span class="hljs-number"><span class="hljs-number">100</span></span>, errors::InvalidArgument(<span class="hljs-string"><span class="hljs-string">"quality must be in [0,100], got "</span></span>, flags_.quality)); OP_REQUIRES_OK(context, context-&gt;GetAttr(<span class="hljs-string"><span class="hljs-string">"progressive"</span></span>, &amp;flags_.progressive)); OP_REQUIRES_OK(context, context-&gt;GetAttr(<span class="hljs-string"><span class="hljs-string">"optimize_size"</span></span>, &amp;flags_.optimize_jpeg_size)); OP_REQUIRES_OK(context, context-&gt;GetAttr(<span class="hljs-string"><span class="hljs-string">"chroma_downsampling"</span></span>, <span class="hljs-comment"><span class="hljs-comment">// &lt;= &amp;flags_.chroma_downsampling)); OP_REQUIRES_OK(context, context-&gt;GetAttr("chroma_downsampling", // &lt;= &amp;flags_.chroma_downsampling)); .... } .... jpeg::CompressFlags flags_; }</span></span></code> </pre> <br>  ‚Üí <a href=""><u>Link to GitHub</u></a> <br><br>  <b>PVS-Studio</b> <a href="http://www.viva64.com/ru/w/V760/">warning</a> : <a href="http://www.viva64.com/ru/w/V760/">V760</a> Two blocks of text were found.  The second block begins from line 58. encode_jpeg_op.cc 56 <br><br>  As can be seen from the code, in the constructor of the <i>EncodeJpegOp</i> class, the <i>OP_REQUIRES_OK</i> and <i>OP_REQUIRES macros</i> check the values ‚Äã‚Äãof flags read from the <i>flags_</i> field.  However, in the last lines of the given code fragment for the constructor, the value of the same flag is checked.  Very similar to copy-paste: duplicated, but forgot to fix. <br><br>  The most interesting (and difficult) that often happens in such cases is to understand whether the copy-paste code is redundant, or if something else is implied.  If the code is redundant, as a rule, there is nothing particularly terrible, but a completely different conversation, if a different code fragment was meant, since in this case we get a logical error. <br><br>  After reviewing the body of the constructor, I could not find the <i>stride</i> field check.  It is possible that in one of the cases this check was implied.  On the other hand, in the constructor, the order of the fields is the same as the order in which the fields are declared in the <i>CompressFlags</i> structure.  So it‚Äôs difficult to judge how to correct the code, you can only make assumptions.  In any case, you should pay attention to this place. <br><br>  Found analyzer and several suspicious places associated with the bit shift.  Let's look at them.  And I want to remind you that improper use of shift operations can lead to undefined behavior. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/629/ec6/f50/629ec6f50e2d6f1a22c9f91567e62440.png" alt="Picture 7"></div><p></p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InferenceContext</span></span></span><span class="hljs-class"> {</span></span> .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> int64 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Value</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(DimensionOrConstant d)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> d.dim.IsSet() ? d.dim-&gt;value_ : d.val; } .... } REGISTER_OP(<span class="hljs-string"><span class="hljs-string">"UnpackPath"</span></span>) .Input(<span class="hljs-string"><span class="hljs-string">"path: int32"</span></span>) .Input(<span class="hljs-string"><span class="hljs-string">"path_values: float"</span></span>) .Output(<span class="hljs-string"><span class="hljs-string">"unpacked_path: float"</span></span>) .SetShapeFn([](InferenceContext* c) { .... int64 num_nodes = InferenceContext::kUnknownDim; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (c-&gt;ValueKnown(tree_depth)) { num_nodes = (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; c-&gt;Value(tree_depth)) - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">// &lt;= } .... }) ....;</span></span></code> </pre> <br>  ‚Üí <a href=""><u>Link to GitHub</u></a> <br><br>  <b>PVS-Studio</b> <a href="http://www.viva64.com/ru/w/V629/">warning</a> : <a href="http://www.viva64.com/ru/w/V629/">V629</a> Consider inspecting the '1 &lt;&lt; c-&gt; Value (tree_depth)' expression.  Bit shifting of the 32-bit type.  unpack_path_op.cc 55 <br><br>  The suspicion of this code is that here 32-bit and 64-bit values ‚Äã‚Äãare mixed in the shift and assignment operations.  Literal <i>1</i> is a 32-bit value for which a left-side shift is performed.  The result of the shift is still of 32-bit type, but it is written to a 64-bit variable.  This is suspicious, because if the value that the <i>Value</i> method returns is greater than 32, an undefined behavior will occur. <br><br>  <b>Quote from the standard</b> : <i>The value of E1 &lt;&lt; E2 is E1 left-shifted E2 bit positions;</i>  <i>vacated bits are zero-filled.</i>  <i>If it is an unsigned pattern, it can be reduced to a minimum.</i>  <b><i>Otherwise, if it is a non-negative value, and if it is an E1 * 2 ^ E2, it is a representation of the result;</i></b>  <b><i>otherwise, the behavior is undefined</i></b> <i>.</i> <br><br>  This code can be corrected by deliberately writing <i>1</i> as a 64-bit literal, or by performing type extension through a cast.  More details about the shifts are written in the article " <a href="https://www.viva64.com/ru/b/0142/">Without knowing the ford, do not climb into the water. Part three</a> ". <br><br>  Expansion through the cast, by the way, was used elsewhere.  Here is the code: <br><br><pre> <code class="cpp hljs">AlphaNum::AlphaNum(Hex hex) { .... uint64 value = hex.value; uint64 width = hex.spec; <span class="hljs-comment"><span class="hljs-comment">// We accomplish minimum width by OR'ing in 0x10000 to the user's // value, // where 0x10000 is the smallest hex number that is as wide as the // user // asked for. uint64 mask = ((static_cast&lt;uint64&gt;(1) &lt;&lt; (width - 1) * 4)) | value; .... }</span></span></code> </pre> <br>  ‚Üí <a href=""><u>Link to GitHub</u></a> <br><br>  <b>PVS-Studio warning</b> : <a href="http://www.viva64.com/ru/w/V592/">V592</a> The expression was enclosed by parentheses twice: (((expression)).  One pair of parentheses is unnecessary or misprint is present.  strcat.cc 43 <br><br>  This is a valid code that the analyzer found suspicious by detecting duplicate parentheses.  The analyzer reasons like this: double brackets do not affect the result of the expression, therefore, perhaps, one pair of brackets is not located where necessary. <br><br>  It cannot be ruled out that they wanted to put brackets here in order to explicitly emphasize the sequence of calculations, and so that they would not have to remember the priorities of the operations '&lt;&lt;' and '*'.  But, since they are in the wrong place, there is no sense from them.  I believe that the order of expressions here is correct (first, the amount of shift is given, and then the shift itself is performed), so you just need to put brackets correctly so that they are not misleading. <br><br><pre> <code class="cpp hljs">uint64 mask = (<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;uint64&gt;(<span class="hljs-number"><span class="hljs-number">1</span></span>) &lt;&lt; ((width - <span class="hljs-number"><span class="hljs-number">1</span></span>) * <span class="hljs-number"><span class="hljs-number">4</span></span>)) | value;</code> </pre> <br>  Go ahead. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Compute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(OpKernelContext* context)</span></span></span><span class="hljs-function"> override </span></span>{ .... int64 v = <span class="hljs-built_in"><span class="hljs-built_in">floor</span></span>(in_x); .... v = <span class="hljs-built_in"><span class="hljs-built_in">ceil</span></span>(in_x1); x_interp.end = <span class="hljs-built_in"><span class="hljs-built_in">ceil</span></span>(in_x1); v = x_interp.end - <span class="hljs-number"><span class="hljs-number">1</span></span>; .... }</code> </pre> <br>  ‚Üí <a href=""><u>Link to GitHub</u></a> <br><br>  <b>PVS-Studio</b> <a href="http://www.viva64.com/ru/w/V519/">warning</a> : <a href="http://www.viva64.com/ru/w/V519/">V519</a> The 'v' variable is assigned values ‚Äã‚Äãtwice successively.  Perhaps this is a mistake.  Check lines: 172, 174. resize_area_op.cc 174 <br><br>  Write to the variable <i>v</i> twice, and the value of this variable is not used between assignments.  Moreover, the same value is written to <i>x_interp.end</i> , which was previously written to the variable <i>v</i> .  Even if we omit the fact of an unnecessary call to the <i>ceil</i> function, since it is not critical (although ...), the code still looks strange: either it is just strangely written, or it contains a cunning error. <br><br>  Farther: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Compute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(OpKernelContext* context)</span></span></span><span class="hljs-function"> override </span></span>{ .... int64 sparse_input_start; <span class="hljs-comment"><span class="hljs-comment">// &lt;= .... if (sparse_input) { num_total_features += GetNumSparseFeatures( sparse_input_indices, *it, &amp;sparse_input_start); // &lt;= } if (num_total_features == 0) { LOG(WARNING) &lt;&lt; "num total features is zero."; break; } if (rand_feature &lt; input_spec_.dense_features_size()) { .... } else { .... const int32 sparse_index = sparse_input_start + // &lt;= rand_feature - input_spec_.dense_features_size(); .... } .... }</span></span></code> </pre> <br>  ‚Üí <a href=""><u>Link to GitHub</u></a> <br><br>  <b>PVS-Studio Warning</b> : <a href="https://www.viva64.com/ru/w/V614/">V614</a> Potentially uninitialized variable 'sparse_input_start' used.  sample_inputs_op.cc 351 <br><br>  Suspicious in this code, it looks like the potentially uninitialized variable <i>sparse_input_start</i> can be used when initializing the constant <i>sparse_index</i> .  At the moment of declaration, this variable is not initialized by any value, i.e.  contains some rubbish.  Below, under the condition that the expression <i>sparse_input is true</i> , the address of the variable <i>sparse_input_start is</i> passed to the function <i>GetNumSparseFeatures</i> , where, probably, this variable is initialized.  But otherwise, if the body of this conditional operator is not executed, <i>sparse_input_start</i> will remain uninitialized. <br><br>  Of course, it can be assumed that if <i>sparse_input_start</i> remains uninitialized, it will not get to its use, but this is too bold and not obvious, so it would be nice to set a standard value for the variable. <br><br><h2>  It's all? </h2><br>  Yes and no.  To be honest, I myself was hoping to find more defects and wanted to write an article in the spirit of testing <a href="https://www.viva64.com/ru/b/0251/">Qt</a> , <a href="https://www.viva64.com/ru/b/0431/">Mono</a> , <a href="https://www.viva64.com/ru/b/0249/">Unreal Engine 4</a> and the like, but it did not work out.  Errors did not roll here and there, so you should pay tribute to the developers of the project.  However, I was hoping that the project would be larger in size, but in the selected configuration only about 700 files were checked, including the auto-generated ones. <br><br>  In addition, some remained outside the scope of this article, for example: <br><br><ul><li>  Only warnings from the GA group were considered; </li><li>  The warnings of confidence level 3 (Low) were not considered; </li><li>  Several dozens of <a href="https://www.viva64.com/ru/w/V730/">V730</a> warnings were <a href="https://www.viva64.com/ru/w/V730/">issued</a> , but it‚Äôs difficult to judge their criticality, therefore we leave them outside the article to the developers; </li><li>  And so forth </li></ul><br>  However, as we saw, PVS-Studio found a number of interesting code fragments, which were discussed in this article. <br><br><h2>  Summarizing </h2><br>  TensorFlow turned out to be quite interesting and high-quality from the point of view of the code project, but, as we saw, not without flaws.  And PVS-Studio once again demonstrated that it is able to find errors even in the code of famous developers. <br><br>  In conclusion, I would like to praise everyone who is working on TensorFlow for the quality code, and wish them good luck in the future. <br><br>  Oh yes, I almost forgot. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a02/26e/5d5/a0226e5d533e3c03516c9af251ec25f9.png" alt="Picture 15"></div><p></p><br><br>  Everyone who read to the end - thank you for your attention, a reckless code, and do not forget to use <a href="https://www.viva64.com/ru/pvs-studio/">PVS-Studio</a> ! <br><br><div style="text-align:center;"> <a href="http://www.viva64.com/en/b/0497/"><img src="https://habrastorage.org/files/8d2/41b/5bf/8d241b5bf34747169141ed7c1997143b.png"></a> </div><br>  If you want to share this article with an English-speaking audience, then please use the link to the translation: Sergey Vasiliev.  <a href="http://www.viva64.com/en/b/0497/">War of the Machines: PVS-Studio vs.</a>  <a href="http://www.viva64.com/en/b/0497/">Tensorflow</a> <br><br><div class="spoiler">  <b class="spoiler_title">Read the article and have a question?</b> <div class="spoiler_text">  Often our articles are asked the same questions.  We collected answers to them here: <a href="http://www.viva64.com/ru/a/0085/">Answers to questions from readers of articles about PVS-Studio, version 2015</a> .  Please review the list. </div></div></div><p>Source: <a href="https://habr.com/ru/post/326256/">https://habr.com/ru/post/326256/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../326242/index.html">Performance is a holiday</a></li>
<li><a href="../326246/index.html">Green light to developers - from startup to the stars. Valentin Gogichashvili</a></li>
<li><a href="../326248/index.html">W3Tech: the share of nginx in the world rose to third, Apache fell below half</a></li>
<li><a href="../326252/index.html">Startup of the day (March 2017)</a></li>
<li><a href="../326254/index.html">Where to look for work: chat rooms in Telegram, groups in FB and other resources</a></li>
<li><a href="../326258/index.html">Internal mechanisms of TCP, affecting the download speed: part 1</a></li>
<li><a href="../326260/index.html">The effect of Apollo is dedicated</a></li>
<li><a href="../326262/index.html">GameDev from scratch: Unity3D and vector graphics</a></li>
<li><a href="../326264/index.html">How not to get lost in the abbreviations SCCM [Cheat Sheet]</a></li>
<li><a href="../326268/index.html">Getting Started Python + Qt5 + QML Lesson # 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>