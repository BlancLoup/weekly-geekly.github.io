<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Why I no longer use modern C ++</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Modern C ++: what is it and how did it come about? 
 Over the past decade, with the arrival of the C ++ 11 standard, and before that, the TR1 specific...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Why I no longer use modern C ++</h1><div class="post__text post__text-html js-mediator-article"><h2>  Modern C ++: what is it and how did it come about? </h2><br>  Over the past decade, with the arrival of the C ++ 11 standard, and before that, the <i>TR1</i> specifications and the <i>Boost</i> library, which precede it, the C ++ community of developers witnessed a massive transition to a new programming style, the so-called modern C ++.  This transition implied the introduction of such techniques as the <i>auto</i> keyword, closures (lambda expressions), variable patterns, and much more.  C ++ turned out to be fertile ground for experimentation, and several libraries written in the new style were born.  Those who could understand new idioms like SFINAE, tag dispatch, CRTP, type generator, safe <i>bool</i> , etc., or at least learned how to reproduce them, were awarded the title of guru. <br><a name="habracut"></a><br>  With the appearance in the early 1970s.  <a href="https://en.wikipedia.org/wiki/Intuitionistic_type_theory">The intuitionistic theory of</a> Martin-L√∂f types, which is the result of the intersection of pure mathematics and computer science, began a period of active research in the field of new types of languages ‚Äã‚Äãsuch as <a href="https://en.wikipedia.org/wiki/Agda_(programming_language)">Agda</a> and <a href="https://en.wikipedia.org/wiki/Epigram_(programming_language)">Epigram</a> .  This laid the foundation for the <a href="https://en.wikipedia.org/wiki/Functional_programming">functional programming</a> paradigm.  All these theories are now being taught in universities and proclaimed as a ‚Äúbreakthrough‚Äù, and huge amounts of money are invested in their development and promotion.  There is even a whole community of speakers who earn their living by promoting this ‚Äúbreakthrough‚Äù among representatives of business America.  Therefore, it is not surprising that the current decisions of the C ++ Standardization Committee are actively influenced by new members - yesterday's students, whose opinion was shaped by this environment. <br><br><h2>  Reorientation from performance to functionality </h2><br>  Over time, C ++ has evolved from a ‚Äúfast‚Äù language into a ‚Äúfunctional‚Äù one, and performance has been forgotten.  Now it is no secret that some C ++ components, for example, the <i>iostream</i> library and strings, by their very nature, cannot work quickly;  In addition, some basic features are missing, such as controlling the transfer of data over the network and very basic functions, for example, the simplest procedure for splitting rows.  If you ask any member of the Committee why these shortcomings have not been eliminated over the past almost twenty years, the answer will invariably be the same: because no one wanted to bother with the preparation of the relevant report or proposal. <br><br>  The committee expects to use the research group <a href="https://github.com/WG21-SG14/SG14">SG14</a> - a division of the ISO 21 Working Group (WG21) dedicated to game development and high-frequency trading (HFT) - as a platform to discuss further language improvements between specialists from the low-latency software industry.  However, judging by the discussions that have already <a href="https://wongmichael.com/tag/sg14/">taken</a> place in the discussion groups and the <a href="https://wongmichael.com/tag/sg14/">Michael Wang Standard</a> (its content is as funny as the name), no one is eager to carry out the radical reforms that C ++ needs so much to compete in this area with ‚ÄúC ++‚Äù with classes ". 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  And why is this actually a problem? </h2><br>  I conduct an expert analysis of C ++ code for a large number of development companies as a consultant both in strategic investments and in optimizing and increasing application performance, and I learned from my own experience that the performance of programs written in modern C ++ leaves much to be desired.  The reason is not that the new style does not allow creating high-performance systems with low latencies; it‚Äôs just that there are many obstacles in the development process that paralyze the work of programmers or create extremely <a href="https://youtu.be/FnGCDLhaxKU%3Ft%3D34m43s">difficult-to-optimize graphs</a> that create difficulties for compilers.  I am extremely glad that there is Chandler Karut with his series of video lectures, thanks to which we can restore the lost connection (and at the same time a bit of sanity) between the C ++ language and reality. <br><br><h2>  Performance loss </h2><br>  The first stumbling block, as already mentioned, is the potential loss of performance due to the more complex structure of the intermediate code presentation and compiler passes.  From this point of view, Fortran is much better, since it is simpler and compilers can optimize it much more efficiently compared to similar C / C ++ code.  My own experience in the field of HFT and game development for decades, as well as data from authoritative peer-reviewed publications, and indeed, observations of anyone with a little compiler optimizations show that the common belief is that conventional and variable templates allow you to get much faster assembler code due to the automatic "dissolving" of C ++ code at the compilation stage is <b>not confirmed in practice</b> .  <i>This is nothing more than a fallacy, with very steady.</i>  In fact, the opposite takes place: small code fragments are much better compiled, debugged, and optimized when working with the generated assembly code, rather than with templates. <br><br><h2>  Compile time </h2><br>  The next issue is compile time.  Regular and variable templates are ‚Äúrenowned‚Äù for their ability to increase the compilation time tenfold because of the rebuilding of the much larger number of files involved in the process as compared to the traditional style.  While a simple, traditional class in C ++ is recompiled only if the header files that it directly included were changed, in modern C ++ one small change often entails a complete reassembly of the project, which often takes up to ten minutes.  For classic C ++, this time, with the same small revision, is a few seconds. <br><br>  How soon the programmer will be able to start testing the generated assembly code, having finished making the necessary changes to the program, depends on the quality of the generated code.  If the application can be quickly assembled and tested, then all problem areas will be fixed more likely.  And if the compilation takes ten minutes, then this probability is greatly reduced. <br><br><h2>  Maintainability </h2><br>  The third and last obstacle is related to the complexity of the code.  As Edsger Dijkstra once said, <br><br>  <i>Simplicity is the key to reliability.</i> <br><br>  If in order to understand the code, you have to hire a programming guru, then either something is wrong with the code, or the chosen language is not suitable for the tasks to be solved. <br><br>  If you carefully read, <a href="http://www.cs.utexas.edu/users/EWD/ewd02xx/EWD215.PDF">perhaps, the most famous article by Dijkstra</a> , ‚ÄúOn the dangers of the <i>goto</i> operator,‚Äù it is easy to see that its most important provisions also apply to templates (ordinary and variable): it‚Äôs not that the mechanism itself is bad, but that the inherent structure inherent in it inevitably generates a complex code, which ultimately eliminates the most important advantage of a quality code - its comprehensibility. <br><br>  When creating trading systems, when up to 100,000 orders per second are sent over the network, and trading strategies are developed and implemented every two days, the simplicity of the code is not just desirable - it is necessary.  Hence my ‚Äúrule of one minute‚Äù when developing such systems: <br><br>  <i>If in one minute it is impossible to understand what this C ++ file is doing, consider that the code is incorrect.</i> <br><br><h2>  True reason </h2><br>  However, the real reason I‚Äôve almost stopped dealing with modern C ++, despite the fact that I‚Äôve been very successful in it, is that there are more and more developments in the IT industry that really should be paid attention to. <br><br>  C ++ has become similar to Fortran: it has reached its limits.  Now so fast interfaces already exist that the <a href="https://en.wikipedia.org/wiki/Clock_recovery">very concept of a ‚Äúclock cycle‚Äù becomes irrelevant</a> for certain nodes of the system.  The speeds have reached such values ‚Äã‚Äãthat two bits of information, sent strictly along a pair of adjacent wires, will surely get out of sync without passing a meter. <br><br>  C ++ is no longer suitable for managing such speeds that are implemented in modern processors, mass-produced on the market, since it is initially focused on a serial data transfer method - even in the most parallel systems like the GPU. <br><br>  A modern developer, if he really wants to keep up with the times, is forced to turn to new languages ‚Äã‚Äã- Verilog and VHDL;  he must be able to design his own processors and virtual models of motherboards, otherwise he will not cope with the avalanche of technological advances in the coming years.  And the point is not that the FPGA ( <i>User</i> <i>Programmable Gate Array</i> , <i>Field-Programmable Gate Array</i> , <i>FPGA</i> ) is characterized by ultra-high speeds - this is not at all the case.  In fact, they are an order of magnitude slower than the top processors. <br><br>  Just now there are more and more all sorts of reconfigurable computing systems.  For example, Intel supplies Xeon processors with embedded FPGAs, and the Internet of Things ( <i>IoT</i> ) will turn into a market with billions of dollars in the next five years, and the engine of this process will be largely small ten-dollar PPVMs, for which will have to hire an army of skilled technologists.  And believe me, programming at the RTL level ( <i>register transfer level, register transfer level</i> ) is hundreds of times more difficult than writing code in C ++.  And if learning C ++ is not easy, imagine what it means to master PPVM programming at a professional level (documentation for Altera‚Äôs Transceiver Toolkit alone takes 700 pages, for the Quartus development environment, another 1000, not to mention Xilinx products). <br><br>  And yet it is worth it.  When you finally master these new languages ‚Äã‚Äãand techniques, you will have the greatest opportunities for the realization of your own ideas.  This is exactly how ‚Äúunicorns‚Äù are born ( <i>startups, whose estimated cost in a short time rises to a billion dollars and more - approx. Transl.)</i> - thanks to people who are able to see the whole picture. <br><br><h2>  Conclusion </h2><br>  Anyway, I think that C ++ is gradually becoming a thing of the past.  As in the case of Fortran, its age makes itself felt.  Therefore, investing time and energy in improving your programming skills in modern C ++ is the same as investing in Cobol or the same Fortran.  The programmer of the new time must master the new tools in order to be able to manage with the advanced technologies that will appear in the coming decades.  And the time to study all this is too little. <br><br><h2>  Translator's Note </h2><br>  I do not completely agree with the opinion of the author, however, I believe that C ++ programmers should read this article.  I also have a feeling that with modern C ++, something is wrong.  The "tricked" code on the templates becomes extremely difficult to understand and in addition, it does not give the promised efficiency.  I am generally more and more inclined towards writing C-style code with classes. <br><br>  Oh yes, I almost forgot.  Use static code analyzers to reduce at least the number of <a href="http://www.viva64.com/ru/examples/">stupid mistakes</a> - and without them there is enough headache with C ++. </div><p>Source: <a href="https://habr.com/ru/post/301736/">https://habr.com/ru/post/301736/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../301716/index.html">Marmalade SDK. Integration with AdMob, Chartboost, Inmobi and Leadbolt advertising services on iOS and Android platforms</a></li>
<li><a href="../301718/index.html">How a vacation trip changed the life of Salesforce founder Mark Benioff</a></li>
<li><a href="../301730/index.html">How to set up almost free advertising on Habr users using pixel retargeting, and how to fix this feature</a></li>
<li><a href="../301732/index.html">‚ÄúThe Dark Side‚Äù of IT Conferences: The Sponsor‚Äôs Work ‚ÄúFrom the Inside‚Äù</a></li>
<li><a href="../301734/index.html">Creating an Android application with React Native</a></li>
<li><a href="../301738/index.html">Invitation to the conference "Payment innovations and alternative payment systems" for Habr users</a></li>
<li><a href="../301742/index.html">Science of self-control: is it possible to develop willpower?</a></li>
<li><a href="../301744/index.html">Welcome to Symfony Moscow Meetup June 2</a></li>
<li><a href="../301746/index.html">VKS equipment for meeting rooms</a></li>
<li><a href="../301750/index.html">Developer .NET developer workstation or the difficulty of choosing the perfect configuration</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>