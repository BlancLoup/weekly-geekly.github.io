<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Introduction to Riemann: Event Monitoring and Analysis</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In previous articles, we have repeatedly addressed the issues of monitoring, collecting and 
 storage metrics (see, for example, here and here ). Toda...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Introduction to Riemann: Event Monitoring and Analysis</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/c7b/23c/069/c7b23c069ab32cbca7f9a9b125dd3423.png" alt="Riemann" width="100%" height="100%"><br><br>  In previous articles, we have repeatedly addressed the issues of monitoring, collecting and <br>  storage metrics (see, for example, <a href="https://blog.selectel.ru/time-series-metriki-i-statistika-vvedenie-v-influxdb/">here</a> and <a href="https://blog.selectel.ru/monitoring-servisov-s-prometheus/">here</a> ).  Today we would like to return to this topic again and tell you about an unusual, but very interesting tool - <a href="http://riemann.io/" rel="nofollow">Riemann</a> . <br><a name="habracut"></a><br><br>  Compared to other monitoring systems, it is characterized by increased complexity, <br>  and at the same time much more flexibility and resiliency.  On the Internet, we have come across publications where Riemann is described as "the most flexible monitoring system in the world."  Riemann is well suited for collecting information on the operation of complex high-load systems in real time. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In fact, the monitoring system in the strict sense of Riemann is not.  It would be more correct to call it the event processor. <br>  It collects information about events from hosts and applications, combines events into a stream and sends them to other applications for further processing or storage.  Riemann also monitors the status of events, which allows you to create checks and send notifications. <br><br>  Riemann is distributed free under the <a href="https://github.com/aphyr/riemann/blob/master/LICENSE" rel="nofollow">Eclipse</a> license.  Most of the code is written by Kyle Kingsbury, also known under the pseudonym <a href="https://aphyr.com/">Aphyr</a> (by the way, we recommend reading his blog: there are often interesting materials there). <br><br><h2>  Real-time event handling </h2><br><br>  The growth of interest in the problems of monitoring, collecting, storing and analyzing metrics, which we have been seeing recently, is quite understandable: computing systems are becoming more complex and heavier.  In the case of high-load systems, the ability to track events in real time is of particular importance.  Actually, Riemann was created in order to solve this problem. <br><br>  The idea of ‚Äã‚Äãprocessing events in a mode close to real time is not new: the first attempts at its implementation were made in the late 1980s.  As an example, we can call the so-called <a href="https://en.wikipedia.org/wiki/Active_database" rel="nofollow">Active Database Systems</a> (active database systems), which performed a certain set of instructions if the incoming data in the database corresponded to a specified set of conditions. <br><br>  In the 1990s, <a href="https://en.wikipedia.org/wiki/Data_stream_management_system">Data Stream Management Systems</a> , which could already process incoming data in real time, and <a href="https://en.wikipedia.org/wiki/Complex_event_processing" rel="nofollow">Complex Event Processing</a> (CEP) systems appeared.  Such systems could both detect events based on external data and internal logic, as well as perform certain analytical operations (for example, count the number of events for a certain period of time). <br><br>  Examples of modern tools for handling complex events are, in particular, <a href="http://storm.apache.org/" rel="nofollow">Storm</a> (see also the <a href="http://www.ibm.com/developerworks/ru/library/os-twitterstorm/" rel="nofollow">article about it in Russian</a> ) and <a href="http://www.espertech.com/esper/" rel="nofollow">Esper</a> .  They are focused on data processing without storage.  Riemann is a product of the same class.  Unlike the Storm, it is much simpler and more logical: the entire event-handling logic can be described in just one configuration file. <br>  For many system administrators and practitioners, this feature may scare away: the configuration file is in fact a code in the <a href="http://clojure.org/" rel="nofollow">Clojure</a> language, but with which Riemann is also written. <br><br>  Clojure refers to functional (and even more precisely - lispoobrazny) programming languages, which in itself is alarming.  However, there is nothing scary about this: with all its uniqueness, Clojure is not as complicated as it seems at first glance.  Consider its features in more detail. <br><br><h2>  Little Clojure </h2><br><br>  Clojure is a functional language based on LISP.  Programs written in Clojure run on the JVM platform.  The first version of this language appeared in 2007.  Most recently, the latest version to date - 1.8.0. <br><br>  Clojure is used in projects of companies such as Facebook, Spotify, SoundCloud, Amazon and others (see the <a href="http://clojure.org/community/companies" rel="nofollow">official website</a> for the full list). <br><br>  Unlike other implementations of LISP for JVM (for example, ABCL or Kawa), Clojure is not fully compatible with either Common Lisp or Scheme, but it borrows a lot from these languages ‚Äã‚Äãin it.  There are some improvements in Clojure that are not found in other modern LISP dialects: data immutability, competitive code execution, etc. <br><br>  Since Clojure was originally designed to work with JVM, it can work with numerous libraries that exist for this platform.  Interaction with Java is implemented in both directions.  You can call code written for Java.  It is also possible to implement classes that are available for calling from Java and other JVM-based programming languages ‚Äã‚Äã‚Äî for example, for Scala.  More details about Clojure and its capabilities can be found in <a href="http://alexott.net/ru/clojure/clojure-intro/index.html" rel="nofollow">this article</a> , as well as <a href="http://riemann.io/clojure.html" rel="nofollow">on the official website of Riemann</a> .  We also recommend that you familiarize yourself with another brief, but very informative <a href="https://adambard.com/blog/clojure-in-15-minutes/" rel="nofollow">introduction to Clojure</a> . <br><br><h2>  Installation and first launch </h2><br><br>  To work with Riemann, we first need to install all the necessary <br>  dependencies: Java and Ruby (some additional components are written on it, which will be discussed below): <br><br><pre><code class="bash hljs">$ sudo apt-get -y install default-jre ruby-dev build-essential</code> </pre> <br><br>  Next, download and install the latest version of Riemann: <br><br><pre> <code class="bash hljs">$ wget https://aphyr.com/riemann/riemann-0.2.10_all.deb $ dpkg -i riemann-0.2.10_all.deb</code> </pre><br><br>  Next, run: <br><br><pre> <code class="bash hljs">$ sudo service riemann start</code> </pre><br><br>  For full-fledged work, we also need to install components for collecting and metrics written in Ruby: <br><br><pre> <code class="bash hljs">$ gem install riemann-client riemann-tools</code> </pre><br><br>  That's all.  To get started with Riemann everything is ready.  Before turning to the practical part, let us make a small theoretical digression and clarify the meaning of the most important concepts: events, flows and index. <br><br><h2>  Events, Threads and Index </h2><br><br>  The basic concept in Riemann is an event.  Events can be processed, counted, collected and exported to other programs.  An event might look like this: <br><br><pre> <code class="bash hljs">{:host riemann, :service riemann streams rate, :state ok, :description nil, :metric 0.0, :tags [riemann], :time 355740372471/250, :ttl 20}</code> </pre><br><br>  The given event consists of the following fields: <br><br><ul><li>  : host - host name; </li><li>  : service - the name of the observed service; </li><li>  : state - event state (ok, warning, critical); </li><li>  : tags - event tags; </li><li>  : time - the time of the event in the Unix Timestamp format; </li><li>  : description - description of the event in any form; </li><li>  : metric - metric associated with the event; </li><li>  : ttl - time of event relevance (in seconds). </li></ul><br><br>  Some events can also have custom fields that can be added both during creation and during event processing (for example, fields with additional metrics). <br>  All events are combined into streams.  A thread is a function to which an event can be passed. <br><br>  You can create an unlimited number of threads.  Events pass through streams, but are not saved in them.  However, it is often necessary to monitor the status of events - for example, they have lost relevance or not.  For this, an index is used - a table of states of monitored events  In the index, events are sorted by groups by host and by service, for example: <br><br><pre> <code class="bash hljs">:host www, :service apache connections, :state nil, :description nil, :metric 100.0, :tags [www], :time 466741572492, :ttl 20</code> </pre><br><br>  This event occurred on the host www in the service apache connections.  The index always stores the most recent event.  Indexes can be accessed from threads and even from external services. <br><br>  We have already seen that each event contains a TTL (time to live) field.  TTL is the length of time that an event is relevant.  In the example just given, the TTL event is 20 seconds.  All events with parameters: host www and: service apache connections fall into the index.  If no such event occurs within 20 seconds, a new event will be created with the value expired in the state field.  It will then be added to the stream. <br><br><h2>  Configuration </h2><br><br>  Let's move from theory to practice and do the configuration of Riemann.  Open the configuration /etc/riemann/riemann.config.  It is a Clojure program and by default looks like this: <br><br><pre> <code class="hljs pgsql">; -*- mode: clojure; -*- ; vim: filetype=clojure (logging/init {:file "/var/log/riemann/riemann.log"}) ; <span class="hljs-keyword"><span class="hljs-keyword">Listen</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> the <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> interface <span class="hljs-keyword"><span class="hljs-keyword">over</span></span> TCP (<span class="hljs-number"><span class="hljs-number">5555</span></span>), UDP (<span class="hljs-number"><span class="hljs-number">5555</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> websockets ; (<span class="hljs-number"><span class="hljs-number">5556</span></span>) (let [host "127.0.0.1"] (tcp-<span class="hljs-keyword"><span class="hljs-keyword">server</span></span> {:host host}) (udp-<span class="hljs-keyword"><span class="hljs-keyword">server</span></span> {:host host}) (ws-<span class="hljs-keyword"><span class="hljs-keyword">server</span></span> {:host host})) ; Expire <span class="hljs-built_in"><span class="hljs-built_in">old</span></span> events <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> the <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> every <span class="hljs-number"><span class="hljs-number">5</span></span> seconds. (periodically-expire <span class="hljs-number"><span class="hljs-number">5</span></span>) (let [<span class="hljs-keyword"><span class="hljs-keyword">index</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>)] ; Inbound events will be passed <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> these streams: (streams (<span class="hljs-keyword"><span class="hljs-keyword">default</span></span> :ttl <span class="hljs-number"><span class="hljs-number">60</span></span> ; <span class="hljs-keyword"><span class="hljs-keyword">Index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">all</span></span> events immediately. <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> ; <span class="hljs-keyword"><span class="hljs-keyword">Log</span></span> expired events. (expired (fn [event] (<span class="hljs-keyword"><span class="hljs-keyword">info</span></span> "expired" event))))))</code> </pre><br><br>  This file is divided into several sections.  Each section begins with a comment, denoted, as is customary in Clojure, by a semicolon (;). <br><br>  The first section contains the file to which logs will be written.  Next comes the section with the interfaces.  Usually, Riemann listens on a TCP, UDP, and web interface.  By default, they are all bound to the local host (127.0.0.1). <br><br>  The following section contains settings for events and index: <br><br><pre> <code class="hljs pgsql">(periodically-expire <span class="hljs-number"><span class="hljs-number">5</span></span>) (let [<span class="hljs-keyword"><span class="hljs-keyword">index</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>)] ; Inbound events will be passed <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> these streams: (streams (<span class="hljs-keyword"><span class="hljs-keyword">default</span></span> :ttl <span class="hljs-number"><span class="hljs-number">60</span></span> ; <span class="hljs-keyword"><span class="hljs-keyword">Index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">all</span></span> events immediately. <span class="hljs-keyword"><span class="hljs-keyword">index</span></span></code> </pre><br><br>  The first function (periodically-expire) removes from the index all events for which the period of relevance has expired, and assigns them the status expired.  Event clearing runs every 5 seconds. <br><br>  By default, Riemann copies to the events with expired relevance of the field: service and: host.  You can copy and other fields;  for this you need to use the option: key-keys with the function periodically-expired.  So, for example, we can order to save not only the host name and service name, but also tags: <br><br><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">periodically-expire</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span> {<span class="hljs-symbol"><span class="hljs-symbol">:keep-keys</span></span> [<span class="hljs-symbol"><span class="hljs-symbol">:host</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:service</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:tags</span></span>]})</code> </pre><br><br>  The following is a construction in which we define a symbol named index.  The value of this symbol is index, i.e.  this is the function that sends events to the index.  It is used to tell Riemann when to index an event. <br><br>  We use streams to describe streams.  Each thread is a function that takes an event as an argument.  The streams function indicates Riemann: "here is a list of functions that need to be called when adding new events."  Inside this function, we set the TTL for events - 60 seconds.  To do this, we used the default function, which takes a field from the event and allows you to set a default value for it.  Events that do not have a TTL will receive expired status. <br><br>  Then the default configuration calls the symbol index.  This means that all incoming events will be added to the index automatically. <br><br>  The final section contains an instruction to log events with the status of expired: <br><br><pre> <code class="hljs cs">; Log expired events. (expired (fn [<span class="hljs-keyword"><span class="hljs-keyword">event</span></span>] (info <span class="hljs-string"><span class="hljs-string">"expired"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">event</span></span>))))))</code> </pre><br><br>  Let's make some changes to the configuration file.  In the section on network interfaces, replace 127.0.0.1 with 0.0.0.0 so that Riemann can receive events from any host. <br><br>  At the very end of the file, add: <br><br><pre> <code class="hljs pgsql">;print events <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> the log (streams prn #(<span class="hljs-keyword"><span class="hljs-keyword">info</span></span> %))</code> </pre><br><br>  This is the prn function that will write events to logs and to standard output.  After that, save the changes and restart Riemann. <br><br>  In a situation when you have to monitor the work of the server set, you can create not a common configuration file, but a whole directory with separate files for each server or group of servers (see recommendations in <a href="https://the-arm.com/2014/01/27/riemann-learnings/" rel="nofollow">this article</a> ). <br><br>  A detailed instruction on writing a configuration file can be found <a href="https://github.com/jdmaturen/reimann/blob/master/riemann.config.guide" rel="nofollow">here</a> . <br><br><h2>  Sending data to Riemann </h2><br><br>  Now let's try to send data to Riemann.  We use for this the client riemann-health, which is included in the previously installed riemann-tools package.  Open another terminal tab and execute: <br><br><pre> <code class="bash hljs">$ riemann-health</code> </pre><br><br>  This command sends Riemann data on the status of the host (CPU load, amount of used disk space, amount of used memory). <br>  Riemann will start accepting events.  Information about these events will be recorded in the /var/log/riemann/riemann.log file.  It is presented as follows: <br><br><pre> <code class="hljs lua">#riemann.codec.Event{:host <span class="hljs-string"><span class="hljs-string">"cs25706"</span></span>, :service <span class="hljs-string"><span class="hljs-string">"disk /"</span></span>, :state <span class="hljs-string"><span class="hljs-string">"ok"</span></span>, :description <span class="hljs-string"><span class="hljs-string">"8% used"</span></span>, :metric <span class="hljs-number"><span class="hljs-number">0.08</span></span>, :tags <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, :<span class="hljs-built_in"><span class="hljs-built_in">time</span></span> <span class="hljs-number"><span class="hljs-number">1456470139</span></span>, :ttl <span class="hljs-number"><span class="hljs-number">10.0</span></span>} INFO [<span class="hljs-number"><span class="hljs-number">2016</span></span><span class="hljs-number"><span class="hljs-number">-02</span></span><span class="hljs-number"><span class="hljs-number">-26</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span>:<span class="hljs-number"><span class="hljs-number">02</span></span>:<span class="hljs-number"><span class="hljs-number">19</span></span>,<span class="hljs-number"><span class="hljs-number">571</span></span>] defaultEventExecutorGroup<span class="hljs-number"><span class="hljs-number">-2</span></span><span class="hljs-number"><span class="hljs-number">-1</span></span> - riemann.<span class="hljs-built_in"><span class="hljs-built_in">config</span></span> - #riemann.codec.Event{:host cs25706, :service disk /, :state ok, :description <span class="hljs-number"><span class="hljs-number">8</span></span>% used, :metric <span class="hljs-number"><span class="hljs-number">0.08</span></span>, :tags <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, :<span class="hljs-built_in"><span class="hljs-built_in">time</span></span> <span class="hljs-number"><span class="hljs-number">1456470139</span></span>, :ttl <span class="hljs-number"><span class="hljs-number">10.0</span></span>} #riemann.codec.Event{:host <span class="hljs-string"><span class="hljs-string">"cs25706"</span></span>, :service <span class="hljs-string"><span class="hljs-string">"load"</span></span>, :state <span class="hljs-string"><span class="hljs-string">"ok"</span></span>, :description <span class="hljs-string"><span class="hljs-string">"1-minute load average/core is 0.02"</span></span>, :metric <span class="hljs-number"><span class="hljs-number">0.02</span></span>, :tags <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, :<span class="hljs-built_in"><span class="hljs-built_in">time</span></span> <span class="hljs-number"><span class="hljs-number">1456470139</span></span>, :ttl <span class="hljs-number"><span class="hljs-number">10.0</span></span>}</code> </pre><br><br>  Riemann-health is just one of the utilities in the riemann-tools package.  It includes a fairly large number of utilities for collecting metrics: riemann-net (for monitoring network interfaces), riemann-diskstats (for monitoring I / O subsystem), riemann-proc (for monitoring processes under Linux), and others.  A complete list of utilities can be found <a href="https://github.com/riemann/riemann-tools">here</a> . <br><br><h2>  Create the first check </h2><br><br>  So, Riemann is installed and running.  Now let's try to create the first check.  Open the configuration file and add the following lines to it: <br><br><pre> <code class="hljs pgsql">(let [<span class="hljs-keyword"><span class="hljs-keyword">index</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>)] (streams (<span class="hljs-keyword"><span class="hljs-keyword">default</span></span> :ttl <span class="hljs-number"><span class="hljs-number">60</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> ;#(<span class="hljs-keyword"><span class="hljs-keyword">info</span></span> %) (<span class="hljs-keyword"><span class="hljs-keyword">where</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">and</span></span> (service "disk /") (&gt; metric <span class="hljs-number"><span class="hljs-number">0.10</span></span>)) #(<span class="hljs-keyword"><span class="hljs-keyword">info</span></span> "Disk space on / is over 10%!" %))</code> </pre><br><br>  The function (#info) is preceded by a comment sign - a semicolon (;).  This is done so that Riemann does not record every event in the log.  Next, we describe the where stream.  It gets events that meet a given criterion.  In our example, there are two such criteria: <br><br><ul><li>  field: service must be disk /; </li><li>  field value: metric must be greater than 0.10 or 10%. </li></ul><br><br>  They are then passed to the child stream for further processing.  In our case, information about such events will be recorded in the /var/log/riemann/riemann.log file. <br><br><h2>  Filtering: quick reference </h2><br><br>  Without event filtering, full-fledged work with Riemann is impossible, so it‚Äôs worth saying a few words about it. <br><br>  Let's start by filtering events using regular expressions.  Consider the following example describing the where stream: <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">where</span></span> (service <span class="hljs-meta"><span class="hljs-meta">#‚Äù^nginx‚Äù))</span></span></code> </pre><br><br>  In Clojure, regular expressions are # and are enclosed in double quotes.  In our example, expressions with the name nginx in the field: service will be included in the where stream. <br><br>  Events in the where stream can be combined using logical operators: <br><br><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">where</span></span> (<span class="hljs-name"><span class="hljs-name">and</span></span> (<span class="hljs-name"><span class="hljs-name">tagged</span></span> <span class="hljs-string"><span class="hljs-string">"www"</span></span>) (<span class="hljs-name"><span class="hljs-name">state</span></span> <span class="hljs-string"><span class="hljs-string">"ok"</span></span>)))</code> </pre><br><br>  In this example, events with a www tag and value ok in the state field will fall into the where stream.  They are combined with tagged stream events. <br>  Tagged is the abbreviated name of the tagged-all function, which combines all events with the given tags.  There is another tagged-any function - it combines events marked with one or more of the specified tags into the stream: <br><br><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">tagged-any</span></span> [<span class="hljs-string"><span class="hljs-string">"www"</span></span> <span class="hljs-string"><span class="hljs-string">"app1"</span></span>] #(<span class="hljs-name"><span class="hljs-name">info</span></span> %))</code> </pre><br><br>  In our example, events tagged with www and app1 will be tagged in the stream. <br><br>  With respect to events, you can perform mathematical operations, for example: <br><br><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">where</span></span> (<span class="hljs-name"><span class="hljs-name">and</span></span> (<span class="hljs-name"><span class="hljs-name">tagged</span></span> <span class="hljs-string"><span class="hljs-string">"www"</span></span>) (<span class="hljs-name"><span class="hljs-name">&gt;=</span></span> (<span class="hljs-name"><span class="hljs-name">*</span></span> metric <span class="hljs-number"><span class="hljs-number">10</span></span>) <span class="hljs-number"><span class="hljs-number">5</span></span>)))</code> </pre><br><br>  In this example, there will be events with events with the www tag, for which the field value: metric multiplied by 10 will be greater than 5. <br>  Similar syntax can be used to select events whose values ‚Äã‚Äãin the: metric field fall within the specified range: <br><br><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">where</span></span> (<span class="hljs-name"><span class="hljs-name">and</span></span> (<span class="hljs-name"><span class="hljs-name">tagged</span></span> <span class="hljs-string"><span class="hljs-string">"www"</span></span>) (<span class="hljs-name"><span class="hljs-name">&lt;</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span> metric <span class="hljs-number"><span class="hljs-number">10</span></span>)))</code> </pre><br><br>  In the given example, events with the www tag, for which the field value: metric is in the range of 5 ‚Äî10, will fall into the where stream. <br><br><h2>  Configure Notifications </h2><br><br>  Riemann can send notifications in case of compliance with specified test conditions.  Let's start by setting up email notifications.  In Riemann, the email function is used for this: <br><br>  [ <pre> <code class="hljs pgsql">(def email (mailer {:<span class="hljs-keyword"><span class="hljs-keyword">from</span></span> "riemann@example.com"})) (let [<span class="hljs-keyword"><span class="hljs-keyword">index</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>)] ; Inbound events will be passed <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> these streams: (streams (<span class="hljs-keyword"><span class="hljs-keyword">default</span></span> :ttl <span class="hljs-number"><span class="hljs-number">60</span></span> ; <span class="hljs-keyword"><span class="hljs-keyword">Index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">all</span></span> events immediately. <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> (changed-state {:init "ok"} (email "andrei@example.com")))))</code> </pre><br><br>  Notifications are sent to Riemann on the basis of a special Clojure - <a href="https://github.com/drewr/postal">Postal</a> library.  By default, a local mail server is used for mailing. <br>  All messages will be sent from the address of the form riemann@example.com. <br><br>  If the local mail server is not installed, Riemann will display an error message of the form: <br><br><pre> <code class="java hljs">riemann.email$mailer$make_stream threw java.lang.NullPointerException</code> </pre><br><br>  In the example code above, we used the changed-state label and thus indicated that Riemann should track events whose state has changed.  The value of the init variable tells Riemann how the initial state of the event was.  All events that have changed from ok to something else will be sent to the email function.  Information about such events will be sent to the specified email address. <br>  More detailed examples of setting up notifications can be found in the <a href="https://kartar.net/2015/03/custom-emails-with-riemann/">article by James Turnbull</a> , one of the developers of Riemann. <br><br><h2>  Visualization of metrics: riemann-dash </h2><br><br>  Riemann has its own tool for visualizing metrics and building simple dashboards - riemann-dash.  You can install it like this: <br><br><pre> <code class="bash hljs">$ git <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> git://github.com/aphyr/riemann-dash.git $ <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> riemann-dash $ bundle</code> </pre><br><br>  Run riemann-dash with the command: <br><br><pre> <code class="bash hljs">$ riemann-dash</code> </pre><br><br>  The riemann-dash home page is available in the browser at [ip-address of the server]: 4567: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d68/104/cdd/d68104cdd6cb8a7e14fb80166c1dc136.png" alt="riemann-dash" width="100%" height="100%"><br><br>  Let's go to the black Riemann inscription in the very center, press the Ctrl key (on Mac - cmd) and click on it.  The inscription will be highlighted in gray.  After that, press the E key to start editing: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f46/dea/400/f46dea400a54a1e7cbcb85c1efa271b9.png" alt="riemann-dash" width="438" height="439"><br><br>  In the drop-down menu, title, select the Grid item, and in the query field, write true: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4ce/06c/ad2/4ce06cad27ef64379503072fb568fdaa.png" alt="riemann-dash" width="434" height="438"><br><br>  Having set the necessary settings, click on the Apply button: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/19b/72d/df7/19b72ddf7059a3517e5464353d540348.png" alt="riemann-dash" width="100%" height="100%"><br><br>  Dashboards are not very aesthetic and comfortable, but quite intuitive.  The inconvenience, however, is compensated by the fact that third-party visualization tools can be used with Riemann, d in particular Graphite and Grafana - the interested reader can easily find relevant publications on the Internet.  And we will describe the procedure for setting up the Riemann + InfluxDB + Grafana bundle in the next section. <br><br><h2>  Sending data to InfluxDB </h2><br><br>  The undoubted advantage of Riemann is its wide integration possibilities.  Metrics collected with it can be sent to third-party repositories.  Below we show how to integrate Riemann with <a href="https://blog.selectel.ru/time-series-metriki-i-statistika-vvedenie-v-influxdb/">InfluxDB</a> and customize data visualization with Grafana. <br><br>  Install InfluxDB: <br><br><pre> <code class="bash hljs">$ wget https://s3.amazonaws.com/influxdb/influxdb_0.9.6.1_amd64.deb $ sudo dpkg -i influxdb_0.9.6.1_amd64.deb</code> </pre><br><br>  You can read more about InfluxDB configuration in the <a href="https://docs.influxdata.com/influxdb/" rel="nofollow">official documentation</a> , as well as in <a href="https://habrahabr.ru/company/selectel/blog/245515/">one of our previous articles</a> . <br><br>  After the installation is completed, run the command: <br><br><pre> <code class="bash hljs">$ sudo /etc/init.d/influxdb start</code> </pre><br><br>  Then create a database for storing data from Riemann: <br><br><pre> <code class="bash hljs">$ sudo influx &gt;CREATE DATABASE riemann</code> </pre><br><br>  Create a user for this database and set a password for it: <br><br><pre> <code class="bash hljs">&gt;CREATE USER riemann WITH PASSWORD <span class="hljs-string"><span class="hljs-string">'  riemann'</span></span> &gt;GRANT ALL ON riemann TO riemann</code> </pre><br><br>  That's it, the installation and basic configuration of InfluxDB is complete.  Now you need to register the necessary settings in the Riemann configuration file (the code is taken <a href="http://tensor.readthedocs.org/en/stable/examples.html" rel="nofollow">from here</a> and slightly modified): <br><br><pre> <code class="hljs rust">; -*- mode: clojure; -*- ; vim: filetype=clojure ; capacitor,     InfluxDB (require <span class="hljs-symbol"><span class="hljs-symbol">'capacitor</span></span>.core) (require <span class="hljs-symbol"><span class="hljs-symbol">'capacitor</span></span>.async) (require <span class="hljs-symbol"><span class="hljs-symbol">'clojure</span></span>.core.async) (defn make-async-influxdb-client [opts] (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> [client (capacitor.core/make-client opts) events-<span class="hljs-keyword"><span class="hljs-keyword">in</span></span> (capacitor.async/make-chan) resp-out (capacitor.async/make-chan)] (capacitor.async/run! events-<span class="hljs-keyword"><span class="hljs-keyword">in</span></span> resp-out client <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-number"><span class="hljs-number">10000</span></span>) (<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> [</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">series</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">payload</span></span></span><span class="hljs-function">] </span></span>(<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> [p (merge payload { :series series :time (* <span class="hljs-number"><span class="hljs-number">1000</span></span> (:time payload)) ;; s ‚Üí ms })] (clojure.core.async/put! events-<span class="hljs-keyword"><span class="hljs-keyword">in</span></span> p))))) (def influx (make-async-influxdb-client { :host <span class="hljs-string"><span class="hljs-string">"localhost"</span></span> :port <span class="hljs-number"><span class="hljs-number">8086</span></span> :username <span class="hljs-string"><span class="hljs-string">"riemann"</span></span> :password <span class="hljs-string"><span class="hljs-string">"  riemann"</span></span> :db <span class="hljs-string"><span class="hljs-string">"riemann"</span></span> })) (logging/init {:file <span class="hljs-string"><span class="hljs-string">"/var/log/riemann/riemann.log"</span></span>}) (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> [host <span class="hljs-string"><span class="hljs-string">"0.0.0.0"</span></span>] (tcp-server {:host host}) (udp-server {:host host}) (ws-server {:host host})) (periodically-expire <span class="hljs-number"><span class="hljs-number">60</span></span>) (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> [index (index)] (streams index (<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> [</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">event</span></span></span><span class="hljs-function">] </span></span>(<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> [series (format <span class="hljs-string"><span class="hljs-string">"%s.%s"</span></span> (:host event) (:service event))] (influx series { :time (:time event) :value (:metric event) })))))</code> </pre><br><br>  Save the changes and restart Riemann. <br><br>  After that install Grafana: <br><br><pre> <code class="bash hljs">$ wget https://grafanarel.s3.amazonaws.com/builds/grafana_2.6.0_amd64.deb $ sudo dpkg -i grafana_2.6.0_amd64.deb</code> </pre><br><br>  We will not give detailed instructions on how to configure Grafana, and there is no special need for this: you can easily find relevant publications on the Internet. <br><br>  The Grafana home page will be accessible in a browser at http: // [Server IP]: 3000.  Then you just need to add a new data source (InfluxDB) and create a dashboard. <br><br><h2>  Conclusion </h2><br><br>  In this article, we have presented a brief overview of the possibilities of Riemann.  We covered the following topics: <br><br><ul><li>  features of Clojure; </li><li>  installation and initial setup of Riemann; </li><li>  structure of the configuration file and features of its syntax; </li><li>  creating checks; </li><li>  setting notifications; </li><li>  visualization of metrics with riemann-dash </li><li>  Riemann integration with InfluxDB and visualization of metrics with Grafana </li></ul><br><br>  If it seems to you that we have missed some important details, write to us and we will complete the review.  And if you use Riemann in practice, we invite you to share your experience in the comments. <br><br>  If for one reason or another you cannot leave comments here - welcome to <a href="https://blog.selectel.ru/kratkoe-vvedenie-v-riemann-monitoring-i-analiz-sobytij/">our corporate blog</a> . </div><p>Source: <a href="https://habr.com/ru/post/281651/">https://habr.com/ru/post/281651/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../281639/index.html">Develop HTML5 games in Intel XDK. Part 5. Increase the length of the snake and manage it</a></li>
<li><a href="../281641/index.html">I do not know how to do that! Honestly</a></li>
<li><a href="../281643/index.html">Patterns and antipatterns Cucumber BDD</a></li>
<li><a href="../281647/index.html">10 steps to create a startup based on 1C: Enterprise and Asp.Net MVC</a></li>
<li><a href="../281649/index.html">Unusual users at easla.com</a></li>
<li><a href="../281653/index.html">About search video say a word</a></li>
<li><a href="../281655/index.html">Posted by Blackhole exploit kit set for seven years</a></li>
<li><a href="../281657/index.html">Break me completely ... is it about Scrum?</a></li>
<li><a href="../281659/index.html">9 secrets of online payments. Part 4: the correct payment form - the key to successful payment</a></li>
<li><a href="../281661/index.html">VolgaCTF: summing up the first round</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>