<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Solving Japanese Crosswords in Wolfram Mathematica</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Japanese crossword puzzle is a famous puzzle, the answer to which is a drawing. What is it and how to solve it, you can read on Wikipedia . I want to ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Solving Japanese Crosswords in Wolfram Mathematica</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/d03/e04/5f0/d03e045f09c42ab4811d07cbdd315706.png"><br><br>  Japanese crossword puzzle is a famous puzzle, the answer to which is a drawing.  What is it and how to solve it, you can read on <a href="http://ru.wikipedia.org/wiki/%25D0%25AF%25D0%25BF%25D0%25BE%25D0%25BD%25D1%2581%25D0%25BA%25D0%25B8%25D0%25B9_%25D0%25BA%25D1%2580%25D0%25BE%25D1%2581%25D1%2581%25D0%25B2%25D0%25BE%25D1%2580%25D0%25B4">Wikipedia</a> .  I want to show how you can write a program that will solve the Japanese crossword puzzle in the Wolfram <i>Mathematica</i> system by iterating. <br><a name="habracut"></a><br><h4>  <b>Main ideas</b> </h4><br>  The idea of ‚Äã‚Äãa brute force solution is to create lists of various cell locations for all rows and columns.  After that, with the help of the obtained lists to find those cells, information about which will be accurately known.  Then weed out those locations that contradict the information found.  It is intuitively clear that if the last two procedures are cyclically repeated, then you can find information about any cell.  So, the task can be divided into three subtasks: <br><ol><li>  Drawing up all possible arrangements. </li><li>  Search for filled and uncolored cells. </li><li>  Removing conflicting locations. </li></ol><br>  Since Wolfram <i>Mathematica is</i> designed to work with lists, cell locations will be stored in the program as lists.  We will designate information about cells as follows: <br><ul><li>  1 - filled cell; </li><li>  0 - open cell; </li><li>  * - a cell about which nothing is known. </li></ul><br>  For example, the bottom shows the equivalent list and location of cells: <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/af5/dc1/0bd/af5dc10bde18491c61842e75ed344988.png" alt="image"></div><br><br><h4>  <b>Composing all possible locations</b> </h4><br><h5>  <b>Some theory</b> </h5><br>  Consider a specific example.  It is necessary to find all possible locations for such data: <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/016/84f/886/01684f886e55e59c2f3de413e667ce48.png"></div><br>  The above shows one of these locations.  How to sort through <i>all possible</i> locations? 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      We do this in the following way.  Let us assign the following groups of cells to the <i>key</i> (numbers to the left of the field): <code>{{1,0}, {1,1,0}, {1,1,1}}</code> .  Now we will create a list that will store the places where we will arrange these groups in order.  In places where we will put these groups, we will store zeros.  Thus, we obtain a list of places <code>{0,0,0,0,0}</code> .  Arranging groups of cells in order by all means to the places obtained, as it is easy to see, we obtain all the required arrangements for the data from the problem.  If we put the groups in order in the places with numbers 1, 3, 4, then we get the location from the example above.  Thus, it turns out that all the locations are equivalent to <a href="http://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25BE%25D1%2587%25D0%25B5%25D1%2582%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5">combinations</a> of the number of places by the number of groups.  Choosing in some way the place where to put the group, we get one of the possible locations.  For example data, the number of locations is ten. <br><br>  The questions ‚ÄúWhy is there no zero in the last group at the end?‚Äù And ‚ÄúWhy are there five places?‚Äù The conscious reader must answer himself. <br><br><h5>  <b>Implementation</b> </h5><br>  It is clear that there is no particular desire to write the function that will perform the search itself, because in <i>Mathematica</i> there is a built-in function <code>Subsets[list, {n}]</code> , which will do this.  It takes a <code>list</code> as the set of elements and the number <code>n</code> as parameters and returns a list of subsets of the set of length <code>n</code> .  For our example, using it to iterate through all the places will look like this: <br><br> <code>In := Subsets[{1,2,3,4,5}, {3}] <br></code> <br> <code>Out = {{1,2,3}, {1,2,4}, {1,2,5}, {1,3,4}, {1,3,5}, {1,4,5}, {2,3,4}, {2,3,5}, {2,4,5}, {3,4,5}} <br></code> <br><br>  Now we will write our own function, which will take a number ( <code>len</code> field length, for example data - <code>10</code> ) and a list ( <code>clue</code> key, for example data - <code>{1,2,3}</code> ) as parameters and return a list of all possible locations.  We will do everything consistently.  First, create a function that turns a number into a list of units.  For this there is a built-in function <code>ConstantArray[c, n]</code> ;  <code>c</code> is the element that fills the list, and <code>n</code> is the length of this list. <br><br> <code>In := ConstantArray[1, 2] <br></code> <br> <code>Out = {1, 1} <br></code> <br><br>  Next, we need to append a zero to the end of this list.  This is done using <code>Append[expr, elem]</code> .  The first parameter is a list, the second is what we will add. <br><br> <code>In := Append[{1, 1}, 0] <br></code> <br> <code>Out = {1, 1, 0} <br></code> <br><br>  Putting these two functions into one using an object such as a pure function.  This can be done in two ways: either <code>Function[arg, Append[ConstantArray[1, arg], 0]</code> , or in short, <code>Append[ConstantArray[1, #], 0]&amp;</code> . <br><br>  Now it remains to apply this function to each element of the list that corresponds to the key.  For this there is a very useful function <code>Map[f, expr]</code> .  It applies the <code>f</code> function to each item in the <code>expr</code> list.  It also has a short version: <code>f /@ expr</code> . <br><br> <code>In := Append[ConstantArray[1, #], 0]&amp; /@ {1, 2, 3} <br></code> <br> <code>Out = {{1,0}, {1,1,0}, {1,1,1,0}} <br></code> <br><br>  It remains only to remove the zero from the last group.  Here function <code>Delete[expr, {i, j}]</code> will help.  It will remove the item from the <code>expr</code> list with the index <code>{i, j}</code> .  Do not forget that the last element has index -1. <br><br> <code>In := Delete[{{1,0}, {1,1,0}, {1,1,1,0}}, {-1, -1}] <br></code> <br> <code>Out = {{1,0}, {1,1,0}, {1,1,1}} <br></code> <br><br>  Collected all together looks like this: <br><br> <code>In := groups = Delete[Append[ConstantArray[1, #], 0]&amp; /@ clue, {-1, -1}] <br></code> <br> <code>Out = {{1,0}, {1,1,0}, {1,1,1}} <br></code> <br><br>  Everything is clear with the list of places, but we need the function <code>Total[list]</code> , which summarizes the elements of the <code>list</code> . <br><br> <code>In := positions = ConstantArray[0, len - Total[clue] + 1] <br></code> <br> <code>Out = {0,0,0,0,0} <br></code> <br><br>  Now the most important thing is to use the <code>Subsets</code> function.  Plus, we need the <code>Range[n]</code> function, which returns the list <code>{1, 2, ..., n}</code> and <code>Length[list]</code> , which gives the length of the <code>list</code> . <br><br> <code>In := sub = Subsets[Range[len - Total[clue] + 1], {Length[clue]}] <br></code> <br> <code>Out = {{1,2,3}, {1,2,4}, {1,2,5}, {1,3,4}, {1,3,5}, {1,4,5}, {2,3,4}, {2,3,5}, {2,4,5}, {3,4,5}} <br></code> <br><br>  We received a list of places where to arrange groups of cells.  Now we will deal with the arrangement.  To do this, we need the <code>ReplacePart[expr, i-&gt;new]</code> function; it replaces the element <code>i</code> in the list of <code>expr</code> with the element <code>new</code> .  But first we will get a list of replacements, so that it is more convenient to write the code later.  The <code>MapThread[f, {a</code> function <code>MapThread[f, {a</code> <sub>1</sub> <code>, a</code> <sub>2</sub> <code>, ...}, {b</code> <sub>1</sub> <code>, b</code> <sub>2</sub> <code>, ...}]</code> will help us to do this.  The result of its execution will be the following: <code>{f[a</code> <sub>1</sub> <code>, b</code> <sub>1</sub> <code>], f[a</code> <sub>2</sub> <code>, b</code> <sub>2</sub> <code>], ...}</code> .  So, create a list of replacements: <br><br> <code>In := rep = MapThread[Function[{x, y}, x-&gt;y], {#, groups}]&amp; /@ sub <br></code> <br> <code>Out = {{1-&gt;{1,0}, 2-&gt;{1,1,0}, 3-&gt;{1,1,1}}, {1-&gt;{1,0}, 2-&gt;{1,1,0}, 4-&gt;{1,1,1}}, {1-&gt;{1,0}, 2-&gt;{1,1,0}, 5-&gt;{1,1,1}}, {1-&gt;{1,0}, 3-&gt;{1,1,0}, 4-&gt;{1,1,1}}, {1-&gt;{1,0}, 3-&gt;{1,1,0}, 5-&gt;{1,1,1}}, {1-&gt;{1,0}, 4-&gt;{1,1,0}, 5-&gt;{1,1,1}}, {2-&gt;{1,0}, 3-&gt;{1,1,0}, 4-&gt;{1,1,1}}, {2-&gt;{1,0}, 3-&gt;{1,1,0}, 5-&gt;{1,1,1}}, {2-&gt;{1,0}, 4-&gt;{1,1,0}, 5-&gt;{1,1,1}}, {3-&gt;{1,0}, 4-&gt;{1,1,0}, 5-&gt;{1,1,1}}} <br></code> <br><br>  The finale of the whole undertaking is the placement in its place.  Here we do <code>Flatten[list]</code> , which will remove the extra brackets: <br><br> <code>In := all = Flatten[ReplacePart[positions, #]]&amp; /@ rep <br></code> <br> <code>Out = {{1,0,1,1,0,1,1,1,0,0}, {1,0,1,1,0,0,1,1,1,0}, {1,0,1,1,0,0,0,1,1,1}, {1,0,0,1,1,0,1,1,1,0}, {1,0,0,1,1,0,0,1,1,1}, {1,0,0,0,1,1,0,1,1,1}, {0,1,0,1,1,0,1,1,1,0}, {0,1,0,1,1,0,0,1,1,1}, {0,1,0,0,1,1,0,1,1,1}, {0,0,1,0,1,1,0,1,1,1}} <br></code> <br><br>  That's all, all arrangements are received.  It remains to combine all this into one module for convenience and we will get the required function. <br><br> <code>allPositions[len_, clue_] := <br></code> <br> <code>Module[{groups, positions, sub, rep, all}, <br></code> <br> <code>groups = Delete[Append[ConstantArray[1, #], 0]&amp; /@ clue, {-1, -1}]; <br></code> <br> <code>positions = ConstantArray[0, len - Total[clue] + 1]; <br></code> <br> <code>sub = Subsets[Range[len - Total[clue] + 1], {Length[clue]}]; <br></code> <br> <code>rep = MapThread[Function[{x, y}, x-&gt;y], {#, groups}]&amp; /@ sub; <br></code> <br> <code>all = Flatten[ReplacePart[positions, #]]&amp; /@ rep; <br></code> <br> <code>Return[all];] <br></code> <br><br><h4>  <b>Search for filled and uncolored cells</b> </h4><br>  Now, in the midst of all this goodness that we will get, using our function, we need to extract information about the cells.  Suppose we have some list of locations.  If there is a place where in all arrangements is 1 or 0, then this gives us the right to say that <i>there</i> will <i>always</i> be a shaded cell in this position, or, accordingly, an unfinished cell.  In my opinion, the simplest implementation of the function that will do this is as follows: all locations are summed element by element and the resulting list looks for either numbers equal to the number of all locations or zeros.  In the first case, these numbers are changed by ones, and in the second, the zeros remain in their places.  All other elements are replaced with asterisks.  To implement we use the function <code>ReplaceAll[list, rule]</code> .  It will replace items in the <code>list</code> according to the rules of the <code>rule</code> .  <code>x_ /; x!=0</code>  <code>x_ /; x!=0</code> means "an element <code>x</code> , such that <code>x ‚â† 0</code> ". <br><br> <code>findInformation[list_] := ReplaceAll[Total[list], {x_ /; x!=0 &amp;&amp; x!=Length[list] -&gt; "*", x_ /; x==Length[list] -&gt; 1}]</code> <br> <br>  For our example, the function operation looks like this: <br><br> <code>In := findInformation[allPositions[len, clue]] <br></code> <br> <code>Out = {*,*,*,*,*,*,*,1,*,*} <br></code> <br><br>  The eighth cell in all arrangements will be shaded, so in the whole grid it will be painted over.  Nothing can be said about the remaining cells. <br><br><h4>  <b>Removing conflicting locations</b> </h4><br>  The resulting information can be used in order to weed out locations that contradict it.  The <code>DeleteCases[expr, pattern]</code> function will be our filter ‚Äî it removes from the expr list all elements that do not match the <code>pattern</code> .  The <code>Except[c]</code> function will also be used, which selects everything except its parameter. <br><br> <code>deleteFromList[list_, test_] := DeleteCases[list, Except[ReplaceAll[test, "*"-&gt;_]]] <br></code> <br><br>  Let us go back to the example, let us get that the location of the cells must satisfy this pattern: <code>{*,*,0,0,*,1,0,*,*,*}</code> .  Running our function, we get: <br><br> <code>In := deleteFromList[allPositions[len, clue], {"*","*",0,0,"*",1,0,"*","*","*"}] <br></code> <br> <code>Out = {{1,0,0,0,1,1,0,1,1,1}, {0,1,0,0,1,1,0,1,1,1}} <br></code> <br><br>  It turned out that only two out of ten locations satisfy the pattern. <br><br><h4>  <b>Putting it all together.</b>  <b>Final stage</b> </h4><br>  We have created step by step all the necessary functions for solving a crossword puzzle.  Now it is important to gather everything beautifully to get a solution.  As an example, I use a crossword puzzle taken from the Kiev magazine of Japanese crossword puzzles Relax.  Its author is A. Leut. <br><br>  Crossword is set in the program as a list of keys for the rows and for the columns. <br><br> <code>rows = {{1}, {2}, {4}, {3,1}, {4,1}, {12}, {9}, {4,1}, {1,1,1,1,1}, {1,1,1,1}, {1,3,1}, {2,1,1}, {9,1}, {4,5,1}, {3,4,1}, {3,5,3}, {3,1,5}, {5,1,2}, {7,3}, {4,10}, {4,3,3}, {4,2,3}, {5,2,2}, {5,3,2}, {4,1,1,2}, {3,2,2}, {2,2}, {7}, {10}, {2,6}}; <br></code> <br> <code>cols = {{3}, {6}, {8}, {13}, {1,12,1}, {2,7,2,1}, {5,2,7,4}, {5,3,12}, {8,2,3,1,1,2}, {8,2,1,3}, {2,3,4,1,4}, {2,2,1,1,5,3,5}, {4,6,7,2}, {2,3,3,8,2}, {1,2,2,2}, {1,4,1}, {2}, {2}, {9}, {1}}; <br></code> <br><br>  You do not need to enter grid dimensions, because you can define them anyway: <br><br> <code>rowlength = Length[cols] <br></code> <br> <code>collength = Length[rows] <br></code> <br><br>  The drawing will be stored in the program as a list of lists or an ordinary matrix.  Before the decision, we have no information at all, so each element of it will be an asterisk. <br><br> <code>pic = ConstantArray["*", {collength, rowlength}]; <br></code> <br><br>  Now the most cumbersome part of solving a crossword puzzle is filling lists of various locations.  Here you need to wait a bit. <br><br> <code>rowpos = allPositions[rowlength, #]&amp; /@ rows; <br></code> <br> <code>colpos = allPositions[collength, #]&amp; /@ cols; <br></code> <br><br>  When all the locations are filled, you can proceed to the solution.  The idea is this: a search is performed on all the rows of filled cells, and these cells are written into the main grid.  Then from the locations for the columns are removed those that contradict the information received and the search is conducted by columns, etc. The search will take place as long as there is at least one asterisk in the grid;  I think that the work of the <code>While</code> loop does not need to be explained.  <code>MemberQ</code> in the above code returns <code>True</code> if there is an asterisk in the grid and <code>False</code> otherwise.  <code>Transpose</code> also used in order to work equally with both rows and columns.  To output a picture, there is a built-in function <code>ArrayPlot</code> , which paints the cell with black if it is 1 and white if it is 0 (the asterisk is filled with brown by default).  In order to see how the pattern dynamically changes in the process of solving, <code>Dynamic</code> used. <br><br> <code>Dynamic[ArrayPlot[pic, Mesh-&gt;True]] <br></code> <br> <code>While[MemberQ[pic, "*", 2], <br></code> <br> <code>pic = findInformation /@ rowpos; <br></code> <br> <code>colpos = MapThread[deleteFromList, {colpos, Transpose[pic]}]; <br></code> <br> <code>pic = Transpose[findInformation /@ colpos]; <br></code> <br> <code>rowpos = MapThread[deleteFromList, {rowpos, pic}];] <br></code> <br><br>  The result is the following picture: <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d98/bfc/581/d98bfc581cb91c06a22e3c1c3bd7501c.png"></div><br>  Perhaps someone noticed that the solution is very sub-optimal.  Yes, it is, but not in the best case.  The purpose of the article is to show that with the help of Wolfram <i>Mathematica</i> you can conveniently and quickly solve this problem.  But if we are already talking about optimality, then for this task there are many ways to optimize the algorithm, for example, to filter and search for information only in those columns and rows, information about the cells of which was added at the previous step. In this version of the program, the search is performed in all columns and rows. </div><p>Source: <a href="https://habr.com/ru/post/204784/">https://habr.com/ru/post/204784/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../204768/index.html">3D VDI acceleration in practice. Part 1</a></li>
<li><a href="../204770/index.html">YotaPhone went on sale</a></li>
<li><a href="../204772/index.html">Group Policy: what's new? Cheat Sheet for all occasions</a></li>
<li><a href="../204780/index.html">Managed Service Accounts</a></li>
<li><a href="../204782/index.html">Directional lighting and shading in 2D space</a></li>
<li><a href="../204788/index.html">Cobbler + puppet or Ubuntu 12.04 network installation</a></li>
<li><a href="../204792/index.html">A1Agregator terminates agreements with medium-sized partners</a></li>
<li><a href="../204794/index.html">The British company proposes to extract energy using drones hovering at a height of 15 kilometers.</a></li>
<li><a href="../204796/index.html">Alert users about password expiration and account validity</a></li>
<li><a href="../204798/index.html">DEV Labs, Part 3. Online C ++ Conference</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>