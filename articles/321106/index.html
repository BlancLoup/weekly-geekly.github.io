<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Data Oriented Design in practice</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Recently, an increasingly interesting discussion of an interesting, but not very popular paradigm - the so-called Data Oriented Design ( DOD ). If you...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Data Oriented Design in practice</h1><div class="post__text post__text-html js-mediator-article">  Recently, an increasingly interesting discussion of an interesting, but not very popular paradigm - the so-called <b>Data Oriented Design</b> ( <b>DOD</b> ).  If you are looking for a job with high performance computing, be prepared for the relevant questions.  But I was very surprised to hear that some of my colleagues had not heard of this approach and, after a short discussion, were skeptical about it.  In this article I will try to compare the traditional <b>OOP</b> approach with the <b>DOD</b> . <br><a name="habracut"></a><br><h3>  What is DOD? </h3><br>  This article was conceived as an attempt to compare different approaches without trying to explain their essence.  On Habr√© there are several articles on the topic, for example <a href="https://habrahabr.ru/company/mailru/blog/319194/">this</a> .  It is also worth watching the <a href="https://www.youtube.com/watch%3Fv%3DrX0ItVEVjHc">video</a> from the <b>CppCon</b> conference.  But in a nutshell, <b>DOD</b> is a way to handle data in a <b>cache-friendly</b> manner.  It sounds incomprehensible, the example will explain better. <br><br><div class="spoiler">  <b class="spoiler_title">Example</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;chrono&gt; #include &lt;iostream&gt; #include &lt;vector&gt; using namespace std; using namespace std::chrono; struct S { uint64_t u; double d; int i; float f; }; struct Data { vector&lt;uint64_t&gt; vu; vector&lt;double&gt; vd; vector&lt;int&gt; vi; vector&lt;float&gt; vf; }; int test1(S const &amp; s1, S const &amp; s2) { return s1.i + s2.i; } int test2(Data const &amp; data, size_t const ind1, size_t const ind2) { return data.vi[ind1] + data.vi[ind2]; } int main() { size_t const N{ 30000 }; size_t const R{ 10 }; vector&lt;S&gt; v(N); Data data; data.vu.resize(N); data.vd.resize(N); data.vi.resize(N); data.vf.resize(N); int result{ 0 }; cout &lt;&lt; "test #1" &lt;&lt; endl; for (uint32_t i{ 0 }; i &lt; R; ++i) { auto const start{ high_resolution_clock::now() }; for (size_t a{ 0 }; a &lt; v.size() - 1; ++a) { for (size_t b{ a + 1 }; b &lt; v.size(); ++b) { result += test1(v[a], v[b]); } } cout &lt;&lt; duration&lt;float&gt;{ high_resolution_clock::now() - start }.count() &lt;&lt; endl; } cout &lt;&lt; "test #2" &lt;&lt; endl; for (uint32_t i{ 0 }; i &lt; R; ++i) { auto const start{ high_resolution_clock::now() }; for (size_t a{ 0 }; a &lt; v.size() - 1; ++a) { for (size_t b{ a + 1 }; b &lt; v.size(); ++b) { result += test2(data, a, b); } } cout &lt;&lt; duration&lt;float&gt;{ high_resolution_clock::now() - start }.count() &lt;&lt; endl; } return result; }</span></span></span></span></code> </pre> <br></div></div><br>  The second test runs 30% faster (in VS2017 and gcc7.0.1).  But why? <br><br>  The size of the <code>S</code> structure is 24 bytes.  My processor (Intel Core i7) has 32KB cache per core with 64B cache line (cache line).  This means that when requesting data from memory, only two <code>S</code> structures will fit completely into one cache line.  In the first test, I read only one <code>int</code> field, i.e.  with one memory access in one cache line there will be only 2 (sometimes 3) fields we need.  In the second test, I read the same <code>int</code> value, but from a vector.  <code>std::vector</code> guarantees consistency of data.  This means that when accessing the memory in one cache line there will be 16 ( <code>64B / sizeof(int) = 16</code> ) values ‚Äã‚Äãwe need.  It turns out that in the second test, we turn to memory less often.  A memory reference is known to be a weak link in modern processors. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h3>  How are things in practice? </h3><br>  The example above clearly demonstrates the advantages of using <b>SoA</b> (Struct of Arrays) instead of <b>AoS</b> (Array of Structs), but this example is from the <code>Hello World</code> category, i.e.  far from real life.  In real code, there are a lot of dependencies and specific data that may not give a performance boost.  In addition, if in the tests we address all fields of the structure, there will be no difference in performance. <br><br>  To understand the reality of the approach, I decided to write a more or less complex code using both techniques and compare the results.  Let it be a 2d simulation of solids - we will create N convex polygons, set the parameters - mass, velocity, etc.  and see how many objects we can simulate staying at around 30 fps. <br><br><h2>  1. Array of Structures </h2><br><h3>  1.1.  The first version of the program </h3><br>  The source code for the first version of the program can be taken from <a href="https://github.com/nikitablack/cpp-tests/tree/b672ca106ef5c88a23d7f8e2a909e07d6e54ca4a/data_oriented/oop/oop">this commit</a> .  Now we will briefly go over the code. <br><br>  For simplicity, the program is written for <b>Windows</b> and uses <b>DirectX11</b> for rendering.  The purpose of this article is to compare the performance on the processor, so we will not discuss the graphics.  The <code>Shape</code> class, which represents the physical body, looks like this: <br><br><div class="spoiler">  <b class="spoiler_title">Shape.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Shape</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Shape(<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> numVertices, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> radius, math::Vec2 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> pos, math::Vec2 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> vel, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> m, math::Color <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> col); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Shape </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createWall</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> w, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> h, math::Vec2 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pos)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: math::Vec2 position{ <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span> }; math::Vec2 velocity{ <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span> }; math::Vec2 overlapResolveAccumulator{ <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> massInverse; math::Color color; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;math::Vec2&gt; vertices; math::Bounds bounds; };</code> </pre> <br></div></div><br><ul><li>  The purpose of <code>position</code> and <code>velocity</code> , I think, is obvious.  <code>vertices</code> - the vertices of the figures given randomly. </li><li>  <code>bounds</code> is a bounding box that completely contains a shape ‚Äî it is used to pre-check intersections. </li><li>  <code>massInverse</code> is a unit divided by mass - we will use only this value, therefore we will store it, instead of mass. </li><li>  <code>color</code> - color - used only when rendering, but stored in a copy of the figure, set randomly. </li><li>  <code>overlapResolveAccumulator</code> see explanation below. </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9fe/9f4/ca8/9fe9f4ca81849bc19331e813c1e8c4e5.png" alt="image"></div><br>  When the triangle intersects with <b>a</b> , we have to move it a little to prevent the shapes from overlapping each other.  We also need to recalculate <code>bounds</code> .  But after moving, the triangle intersects another figure - <b>b</b> , and again we have to move it and recalculate the <code>bounds</code> again.  Notice that after the second movement, the triangle will again be above the a figure.  To avoid recalculations, we will store the amount by which the triangle should be moved in a special accumulator ‚Äî <code>overlapResolveAccumulator</code> ‚Äî and later we will move the shape to this value, but only once. <br><br>  The heart of our program is the <code>ShapesApp::update()</code> method.  Here is its simplified version: <br><br><div class="spoiler">  <b class="spoiler_title">ShapesApp.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> ShapesApp::update(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> dt) { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> dtStep{ dt / NUM_PHYSICS_STEPS }; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> s{ <span class="hljs-number"><span class="hljs-number">0</span></span> }; s &lt; NUM_PHYSICS_STEPS; ++s) { updatePositions(dtStep); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i{ <span class="hljs-number"><span class="hljs-number">0</span></span> }; i &lt; _shapes.size() - <span class="hljs-number"><span class="hljs-number">1</span></span>; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> j{ i + <span class="hljs-number"><span class="hljs-number">1</span></span> }; j &lt; _shapes.size(); ++j) { CollisionSolver::solveCollision(_shapes[i].get(), _shapes[j].get()); } } } }</code> </pre> <br></div></div><br>  Each frame we call the <code>ShapesApp::updatePositions()</code> method, which changes the position of each shape and calculates the new <code>Shape::bounds</code> .  Then we check each piece with each other for an intersection - <code>CollisionSolver::solveCollision()</code> .  I used <a href="https://en.wikipedia.org/wiki/Hyperplane_separation_theorem">Separating Axis Theorem (SAT)</a> .  All these checks we do <code>NUM_PHYSICS_STEPS</code> times.  This variable serves several purposes - first, the physics is more stable, and second, it limits the number of objects on the screen.  c ++ is fast, very fast, and without this variable we will have tens of thousands of shapes, which will slow down the rendering.  I used <code>NUM_PHYSICS_STEPS = 20</code> <br><br>  On my old laptop, this program counts 500 figures maximum, before fps starts to fall below 30. Fuuuu, only 500 ???!  I agree a little, but do not forget that every frame we repeat the calculations 20 times. <br><br>  I think that it is necessary to dilute the article with screenshots, so here: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6ec/d17/22b/6ecd1722b4b94dc4419b86b7e9ffa35d.png" alt="image"><br><br><h3>  1.2.  Optimization number 1. Spatial Grid </h3><br>  I mentioned that I want to conduct tests on a program as close as possible to reality.  What we have written above is not used in reality - to check every figure with each sooo slowly.  To speed up the calculations, a special structure is usually used.  I propose to use an ordinary 2d grid - I called it a <code>Grid</code> - which consists of NxM cells - <code>Cell</code> .  At the beginning of the calculations, we will write to each cell the objects that are in it.  Then we will only need to run through all the cells and check the intersection of several pairs of objects.  I have repeatedly used this approach in releases and it has proved itself - it is written very quickly, easily debugged, easy to understand. <br><br>  The commit of the second version of the program can be viewed <a href="https://github.com/nikitablack/cpp-tests/tree/8364d7c55c8948ab2fc5630e828d44551c6db951/data_oriented/oop/oop">here</a> .  A new <code>Grid</code> class has appeared and the <code>ShapesApp::update()</code> method has slightly changed - now it calls the grid methods for checking intersections. <br><br>  This version already holds 8000 figures at 30 fps (do not forget about 20 iterations in each frame)!  I had to reduce the figures 10 times so that they fit in the window. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7c6/4a5/ff0/7c64a5ff006133645b1cdc5450dbb4ad.png" alt="image"><br><br><h3>  1.3.  Optimization number 2. Multithreading. </h3><br>  Today, when even on phones processors with four cores are installed, it is just silly to ignore multi-threading.  In this last optimization, we will add a pool of threads and divide the main tasks into equal tasks.  So, for example, the <code>ShapesApp::updatePositions</code> , which previously ran through all the figures, setting a new position and recalculating <code>bounds</code> , now runs only in part of the figures, thus reducing the load on one core.  The pool class was honestly skipiped <a href="">from here</a> .  In tests, I use four threads (counting the main one).  The finished version can be found <a href="https://github.com/nikitablack/cpp-tests/tree/8d83cb351008a3faf3629279ebaf49ff3fc71b17/data_oriented/oop/oop">here</a> . <br><br>  The separation of the main tasks added a bit of headache.  For example, if a shape intersects the border of a cell in a grid, then it will be located simultaneously in several cells: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/db3/c2c/4b8/db3c2c4b8ac55216c569901ad49c8aba.png" alt="image"></div><br>  Here the figure <b>a</b> is in one cell, whereas <b>b is</b> immediately in four.  Therefore, access to these cells must be synchronized.  You also need to synchronize access to some fields of the <code>Shape</code> class.  To do this, we added <code>std::mutex</code> to <code>Shape</code> and <code>Cell</code> . <br><br>  By running this version I can observe 13,000 figures at 30 fps.  For so many objects had to increase the window!  And again - in each frame we repeat the simulation 20 times. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/978/2ef/4bf/9782ef4bf4a58721e462f6eaacbc0979.png" alt="image"><br><br><h2>  2. Structure of Arrays </h2><br><h3>  2.1.  The first version of the program </h3><br>  What we have written above I call the traditional approach - I have been writing such code for many years and I read mostly similar code.  But now we kill the <code>Shape</code> structure and see if this small modification can affect performance.  To everyone's joy, refactoring was not difficult, even trivial.  Instead of <code>Shape</code> we will use a structure with vectors: <br><br><div class="spoiler">  <b class="spoiler_title">Shape.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ShapesData</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;math::Vec2&gt; positions; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;math::Vec2&gt; velocities; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;math::Vec2&gt; overlapAccumulators; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>&gt; massesInverses; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;math::Color&gt; colors; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;math::Vec2&gt;&gt; vertices; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;math::Bounds&gt; bounds; };</code> </pre> <br></div></div><br>  And we pass this structure like this: <br><br><pre> <code class="cpp hljs">solveCollision(struct ShapesData &amp; data, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> indA, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> indB);</code> </pre> <br>  Those.  instead of specific figures, their indices are transferred and in the method the necessary data is taken from the desired vectors. <br><br>  <a href="https://github.com/nikitablack/cpp-tests/tree/8363e60c614377cccb777625805b6aea9e699117/data_oriented/dod/dod">This version of the program</a> produces 500 figures at 30 fps, i.e.  does not differ from the very first version.  This is due to the fact that measurements are carried out on a small amount of data and, moreover, the heaviest method uses almost all fields of the structure. <br><br>  Further, without pictures, because  they are exactly the same as they were before. <br><br><h3>  2.2.  Optimization number 1. Spatial Grid </h3><br>  Everything is as before, we only change <b>AoS</b> to <b>SoA</b> .  The code is <a href="https://github.com/nikitablack/cpp-tests/tree/f726cec7591a2568ef41fbe53623e5447bfdde45/data_oriented/dod/dod">here</a> .  The result is better than before - 9,500 figures (there were 8,000), i.e.  The performance difference is about 15%. <br><br><h3>  2.3.  Optimization number 2. Multithreading </h3><br>  Again, take the old code, change the structure and get 15,000 figures at 30 fps.  Those.  performance gain of about 15%.  The source code for the final version is <a href="https://github.com/nikitablack/cpp-tests/tree/ba57d299a26545d6045bd84797bc69d98ceca7bd/data_oriented/dod/dod">here</a> . <br><br><h2>  3. Conclusion </h2><br>  Initially, the code was written for myself in order to test various approaches, their performance and convenience.  As the results showed, a small change in the code can give a rather tangible increase.  And it may not give, maybe even the opposite - the performance will be worse.  So for example, if we need only one copy, then using the standard approach we will read it from memory only once and we will have access to all fields.  Using the structure of vectors, we will have to query each field individually, having a cache-miss for each request.  Plus, the readability deteriorates a bit and the code becomes more complicated. <br><br>  Therefore, it is impossible to answer unequivocally whether it is worth switching to a new paradigm for everyone.  When I was working on a game engine on a game engine, a 10% performance boost is an impressive number.  When I wrote custom launcher-type utilities, using the <b>DOD</b> approach would only be puzzling to my colleagues.  In general, profile, measure and draw conclusions yourself :). </div><p>Source: <a href="https://habr.com/ru/post/321106/">https://habr.com/ru/post/321106/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../321096/index.html">Standard exchange of 1C-Bitrix for BASH: incremental upload of XML files from the import and offers directory</a></li>
<li><a href="../321098/index.html">Agile in small teams - how beautiful it is to break your neck</a></li>
<li><a href="../321100/index.html">DUMP-2017: the new season. We meet on April 14 in Yekaterinburg</a></li>
<li><a href="../321102/index.html">"Clock Signal Component Issue" or again a massive marriage in Cisco devices</a></li>
<li><a href="../321104/index.html">Node.js, Express and MongoDB: API in half an hour</a></li>
<li><a href="../321108/index.html">We start the gas flow rate sensor</a></li>
<li><a href="../321110/index.html">Recursive multiple add IP to lock in the .htaccess file</a></li>
<li><a href="../321112/index.html">Osiris - the new reincarnation of the Locky Trojan</a></li>
<li><a href="../321114/index.html">The deadline of the Stepik Contest contest is extended until March 31, it's time to create IT tasks</a></li>
<li><a href="../321116/index.html">[Free pizza] Hacking a pizza delivery site, hacking mobidel.ru</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>