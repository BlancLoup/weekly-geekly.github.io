<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Demonstration of high-speed processing capabilities of IP packets, for example, a simple DDOS filter developed on the basis of the NETMAP framework</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="As soon as I became interested in Netmap, I immediately became curious about how many packets per second could be ‚Äúsqueezed out‚Äù on ordinary hardware ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Demonstration of high-speed processing capabilities of IP packets, for example, a simple DDOS filter developed on the basis of the NETMAP framework</h1><div class="post__text post__text-html js-mediator-article">  As soon as I became interested in Netmap, I immediately became curious about how many packets per second could be ‚Äúsqueezed out‚Äù on ordinary hardware in the packet generation mode and / or in the packet reception and filtering mode?  With what performance, it will be possible to filter the traffic of various attacks that are popular today and what packet losses will be at the same time. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5f4/05b/ae3/5f405bae3da39dbb43ca23f19a3ff928.jpg"><br><br>  The data that the author shows Netmap Luigi Rizzo is very impressive.  As is well known, according to published tests by Luigi, Netmap easily generates 14Mpps and allows you to ‚Äúraise‚Äù the flow of 14Mpps from the network cable to the userspace, using only one Core i7 processor core.  It became interesting to apply this technology in traffic filtering filters. <br>  So, at the 2013 InfosecurityRussia 2013 exhibition in September, we presented a booth where, at the request of everyone, they generated various attacks and demonstrated protection against them, collecting statistics and drawing various charts with Zabbix. <br>  In this article, we will focus on some of the features of the NETMAP architecture, as well as indicators of packet processing speed, which are obtained with its help on "ordinary" hardware. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <a name="habracut"></a><br><br><h4>  1. A brief introduction to NETMAP </h4><br>  Before moving on to performance measurements and tests, a few words should be written about the NETMAP framework, which does the basic work of speeding packet processing.  A detailed review of NETMAP, made on the basis of a compilation of all materials submitted by its author, was made by me earlier in this article (http://habrahabr.ru/post/183832/).  For those who do not need such a deep immersion, a brief description of the framework is offered. <br><br><h5>  1.1.  NIC data structures and operations with them </h5><br>  Network adapters (NICs) use ring queues (rings) of memory buffer descriptors to process incoming and outgoing packets, as shown in Figure 2. <br><img src="https://habrastorage.org/getpro/habr/post_images/b9d/ead/6b4/b9dead6b49c19908db89217f03a15ce2.jpg"><br>  "NIC data structures and their relationship with OS data structures" <br><br>  Each slot in the ring queue (rings) contains the length and physical address of the buffer.  Available (addressable) for the CPU registers NIC contain information about the queues for receiving and transmitting packets. <br>  When a packet arrives on the network card, it is placed in the current memory buffer, its size and status are written to the slot, and information that new incoming data has appeared for processing is written to the corresponding NIC register.  The network card initiates an interrupt to inform the CPU of the arrival of new data. <br>  In the case when a packet is sent to the network, the NIC assumes that the OS fills the current buffer, places information about the size of the transmitted data in the slot, writes the number of slots for transmission in the corresponding NIC register, which triggers the sending of packets to the network. <br>  In the case of high rates of reception and transmission of packets, a large number of interruptions can lead to the inability to perform any useful work ("receive live-lock").  To solve these problems, the OS uses the mechanism of polling or interrupt throttling.  Some high-performance NICs use multiple queues for receiving / transmitting packets, which allows you to distribute the load on the processor across multiple cores or split a network card into several devices for use in virtual systems working with such a network card. <br><br><h5>  1.2.  Packet handling problems with TCP / IP OS stack </h5><br>  The OS copies the NIC data structures to the queue of memory buffers, which is specific to each OS.  In the case of FreeBSD, these are mbufs equivalents to sk_buffs (Linux) and NdisPackets (Windows).  In essence, these memory buffers are containers that contain a large amount of metadata about each packet: the size, the interface with / to which the packet arrived, various attributes and flags defining the processing order of the memory buffer data in the NIC and / or OS. <br>  The NIC driver and the operating system TCP / IP stack (hereinafter referred to as the host stack), as a rule, assume that the packets can be broken into an arbitrary number of fragments, hence the driver and the host stack should be ready to handle packet fragmentation. <br>  When transferring a packet between a network cable and userspace, several copy operations are performed: <br><ul><li>  Populating NIC data structures with network data </li><li>  Copy data from NIC data structures to mbufs / sk_bufs / NdisPackets </li><li>  Copying data from mbuf / sk_buf / NdisPackets to userspace </li></ul><br><br>  As can be seen, the corresponding API exported to userspace implies that different subsystems can leave packets for delayed processing, therefore memory buffers and metadata cannot simply be passed by reference during call processing, but they must be copied or processed by the reference counting mechanism. ).  All this is a high overhead fee for flexibility and convenience. <br>  The analysis of the path of a packet through the sendto () system call discussed in the previous article, then the OS stack of FreeBSD on the network showed that the packet passes through several very expensive levels.  Using this standard API, there are no opportunities to bypass the memory allocation and copying mechanisms in mbufs, check the correct routes, prepare and construct TCP / UDP / IP / MAC headers and at the end of this processing chain, convert mbuf structures and metadata to NIC format to transfer the packet to the network.  Even in the case of local optimization, for example, caching routes and headers instead of building them from scratch, there is no radical increase in the speed that is required for processing packets on 10 Gbit / s interfaces. <br><br><h5>  1.3.  Techniques to increase productivity when processing packets used in NETMAP </h5><br>  One simple way to avoid additional copying in the process of transferring a package from the kernel space to the user space and vice versa is the ability to allow an application direct access to NIC structures.  As a rule, this requires that the application runs in the OS kernel.  Examples include the Click software router project or the traffic mode kernel mode pkt-gen.  Along with ease of access, the kernel space is a very fragile environment, errors in which can lead to a system crash, so a more correct mechanism is to export packet buffers to userspace. <br>  NETMAP, is a system that provides userspace application with very fast access to network packets, both for receiving and sending, both when communicating with the network and when working with the TCP / IP OS stack (host stack).  At the same time, efficiency is not sacrificed for risks arising from the full opening of data structures and network card registers in userspace.  The framework independently manages the network card, the operating system, at the same time, performs memory protection. <br>  A distinctive feature of NETMAP is tight integration with existing OS mechanisms and the lack of dependence on the hardware features of specific network cards.  To achieve the desired high performance characteristics, NETMAP uses several well-known techniques: <br><br><ul><li>  Compact and lightweight package metadata structures.  Simple to use, they hide hardware-specific mechanisms, providing a convenient and easy way to work with packages.  In addition, the NETMAP metadata is designed to handle many different packets for a single system call, thus reducing packet overhead. </li><li>  Linear preallocated buffers, fixed sizes.  Allow to reduce memory management overhead </li><li>  Zero copy operations for packet forwarding between interfaces, as well as between interfaces and host stack </li><li>  Linear preallocated buffers, fixed sizes.  Allow to reduce memory management overhead </li><li>  Zero copy operations for packet forwarding between interfaces, as well as between interfaces and host stack </li><li>  Support for useful network card hardware features such as multiple hardware queues </li></ul><br><br>  In NETMAP, each subsystem does exactly what it is intended for: the NIC transfers data between the network and RAM, the OS kernel performs memory protection, provides multitasking and synchronization. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d25/c64/0fe/d25c640feea652a6f9fdff3341778d47.png"><br><br>  Fig.  In NETMAP mode, the NIC queues are disconnected from the TCP / IP OS stack.  Exchange between the network and the host stack is carried out only through the NETMAP API. <br>  At the topmost level, when an application through the NETMAP API puts the network card into NETMAP mode, the NIC queues are disconnected from the host stack.  The program thus gets the ability to control the exchange of packets between the network and the OS stack, using circular buffers called ‚Äúnetmap rings‚Äù.  Netmap rings, in turn, are implemented in shared memory.  To synchronize the queues in the NIC and the OS stack, the usual OS system calls are used: select () / poll ().  Despite the disconnection of the TCP / IP stack from the network card, the operating system continues to operate and execute its operations. <br><br><h4>  2. Stand for testing </h4><br>  To demonstrate the performance of the DDOS traffic filter, at InfoSecurity Russia 2013, which took place in September 2013, we prepared a booth at which DDOS was generated and protected from large traffic streams.  Iron for the stand was chosen the most common: <br><br>  Traffic / Attack Generator <br><ul><li>  Intel Core i7-2600 3.4GHz TurboBoost processor </li><li>  RAM 8GB 1333MHz DDR3 </li><li> HDD SATA 500GB </li><li>  OS FreeBSD 9-STABLE </li><li>  Intel X520 10Gbit / s SFP + dual-port network card </li></ul><br><br>  DDOS filter server <br><ul><li>  Intel Xeon E3-1230 3.2GHz TurboBoost processor </li><li>  RAM 8GB 1333MHz DDR3 </li><li>  HDD SATA 500GB </li><li>  OS FreeBSD 9-STABLE </li><li>  Intel X520 10Gbit / s SFP + dual-port network card </li></ul><br>  Switch <br><ul><li>  Juniper EX4200 with 2x10Gbit / s SFP + interfaces </li></ul><br><br><img src="https://habrastorage.org/getpro/habr/post_images/5f6/a56/977/5f6a56977dbbf3682246105c41e9bf40.png"><br><br>  The stand works as follows: <br>  On request, the generator will launch a variety of attacks with adjustable power on the values ‚Äã‚Äãof PPS and Gbit / s.  Attack traffic arrives at Juniper through the 10Gbit / s interface and through the second 10Gbit / s interface arrives at the DDOS protection server.  Legal traffic comes to Juniper from the workstation via the 1Gbit / s interface and is mixed in the switch by attack traffic.  On the DDOS protection server, traffic is cleared and cleared traffic is sent to the protected server.  As a protected service, an HTTP web site is used, the main page of which contains the page access time. <br><br><h4>  3. A simplified description of the coarse traffic clearing mechanisms </h4><br>  The DDOS protection server, in addition to the modules for working with the NETMAP and TCP / IP stack, contains several filters through which the network packets pass. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2be/2fa/64e/2be2fa64e39312ea8e8ceb96b1356e3e.jpg"><br><br><ul><li>  The first filter is to check the destination address of the packet, the protocol and the destination port.  It makes no sense to spend resources on processing packets, if for example the tcp / port to which the packet arrived, is not served.  Such packages are immediately "forgotten" in the netmap-rings and overwritten by newcomers. </li><li>  The second filter works by limiting pps / bandwidth for an ip-address, or an ip-network / group of networks, etc.  Using this filter, for example, you can allow to pass a strictly specified number of packets per second from ‚Äúany‚Äù ip-addresses from the Internet, packets going to a specific address and port of the protected server.  All packages above the specified limit will be "killed" </li><li>  The third filter is an implementation of the syncookie mechanism to protect against SYNflood attacks.  If a legal connection arrives, the client is connected to the protected server, for increased performance, the TCP splicing technique is used ( <a href="http://www.pam2010.ethz.ch/papers/full-length/5.pdf">www.pam2010.ethz.ch/papers/full-length/5.pdf</a> ) </li><li>  The last filter is a search engine based on ‚Äúregular expressions‚Äù, working to add ip-addresses to ‚Äúblack‚Äù, ‚Äúwhite‚Äù, as well as ‚Äúblack-gray‚Äù and ‚Äúwhite-gray‚Äù lists, in which the IP address is temporarily </li></ul><br><br><h4>  4. Measurement of the speed of processing packages at the booth of the exhibition Infosecurity 2013 </h4><br>  As a software for generating traffic, a traffic generator is used, which was also made on the basis of NETMAP and implements the following types of attacks: <br><ul><li>  UDP flood in short and / or long packets </li><li>  Synflood short and / or long packages </li></ul><br>  The attack uses the parameter - the number of SRC_IP per second, from which traffic flows.  Obviously, it does not make much sense to test DDOS by generating an attack from a single ip-address.  The tests use from 160 thousand to 1600 thousand new IP-addresses every second to generate an attack. <br><br><h6>  UDP flood flood attack on port 53 of the protected web server </h6><br><img src="https://habrastorage.org/getpro/habr/post_images/12b/bb5/c30/12bbb5c306c85974ec4423b0df5c9231.jpg"><br><ul><li>  Attack power - 10 million PPS </li><li>  Attack power - 5Gbit / s </li><li>  Traffic after cleaning - 8 PPS </li><li>  Traffic after cleaning - 5Kbit / s </li></ul><br><br><h6>  SYN-flood attack short, then long packets on port 80 of the protected server </h6><br><img src="https://habrastorage.org/getpro/habr/post_images/0fb/15b/80c/0fb15b80c4851d0b4f77d14948770875.jpg"><br><br>  Short packet SYNflood attack <br><ul><li>  Attack power - 7 million PPS </li><li>  Attack power - 5 Gbit / s </li><li>  Traffic after cleaning - 8 PPS </li><li>  Traffic after cleaning - 5Kbit / s </li></ul><br>  Long batch SYNflood attack <br><ul><li>  Attack power - 600 thousand PPS </li><li>  Attack power - 8 Gbit / s </li><li>  Traffic after cleaning - 8 PPS </li><li>  Traffic after cleaning - 5Kbit / s </li></ul><br><br><img src="https://habrastorage.org/getpro/habr/post_images/d77/809/2a7/d778092a77ead0b71cf91913991640fe.jpg"><br>  Fig.  Incoming SYN packets <br><br><h6>  CPU load under UDP / SYN flood attack </h6><br><img src="https://habrastorage.org/getpro/habr/post_images/85d/de0/206/85dde0206da1ad833e957143cfd465b0.jpg"><br>  Attack UDP flood short packets <br><ul><li>  Attack power - 10 million PPS </li><li>  Attack power - 5 Gbit / s </li><li>  Average CPU load (user) 50% </li><li>  Average CPU load (system) 15% </li></ul><br><br>  Short packet SYN flood attack <br><ul><li>  PPS attack power 7 million PPS </li><li>  Attack power in Gbit / s 5 Gbit / s </li><li>  Average CPU load (user) 90% </li><li>  Average CPU load (system) 5% </li></ul><br><br><h6>  Long work under Flood-attacks </h6><br><img src="https://habrastorage.org/getpro/habr/post_images/e2b/232/962/e2b23296266b59293c80fd9bcbf5c9c4.jpg"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/c23/9c1/349/c239c1349411d40ddb6ed783bae844d2.jpg"><br><br><ul><li>  Attack time 6 hours </li><li>  Types of SYNflood / UDPflood attacks </li><li>  Attack power 5 Gbit / s - 10 Gbit / s </li><li>  Average CPU load (user) 50% </li><li>  Average CPU load (system) 11% </li></ul><br><br><h4>  5. Conclusion </h4><br>  The NETMAP framework can be used as an effective traffic clearing filter, as well as an effective tool for developing load testing tools.  As a main advantage, it can be noted that the programs built on the NETMAP framework work on regular hardware and achieve very high performance, which makes it possible to use them as a replacement for the much more expensive alternative solutions offered by Arbor, Radware, Spirent, RioRey etc. </div><p>Source: <a href="https://habr.com/ru/post/220331/">https://habr.com/ru/post/220331/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../220315/index.html">Amazon will go to the smartphone market, Unity to analytics, and Candy Crush Saga to China - the main mobile news of the week</a></li>
<li><a href="../220319/index.html">What showed tests of new flash-storage EMC XtremIO</a></li>
<li><a href="../220323/index.html">Who to entrust your business? Part 2 - legal support</a></li>
<li><a href="../220327/index.html">Horizontal scaling of small web-based Java applications (interview questions)</a></li>
<li><a href="../220329/index.html">Gamification bugfixes How we turned bug fixes into an exciting multiplayer online game</a></li>
<li><a href="../220333/index.html">Report on the passage of the first round of the Russian Code Cup</a></li>
<li><a href="../220335/index.html">Want to manage the product? What are all product managers silent</a></li>
<li><a href="../220337/index.html">Automation testing UI. From Coded UI to Cruciatus</a></li>
<li><a href="../220339/index.html">Ibm and red hat</a></li>
<li><a href="../220341/index.html">Deploy Ratpack app on Heroku</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>