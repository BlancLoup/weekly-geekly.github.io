<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>PostgreSQL Indexes - 9</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In previous articles, we looked at the PostgreSQL indexing mechanism , the interface of access methods and the following methods: hash indices , B-tre...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>PostgreSQL Indexes - 9</h1><div class="post__text post__text-html js-mediator-article"><br>  In previous articles, we looked at <a href="https://habrahabr.ru/company/postgrespro/blog/326096/">the PostgreSQL indexing mechanism</a> , the <a href="https://habrahabr.ru/company/postgrespro/blog/326106/">interface of access methods</a> and the following methods: <a href="https://habrahabr.ru/company/postgrespro/blog/328280/">hash indices</a> , <a href="https://habrahabr.ru/company/postgrespro/blog/330544/">B-trees</a> , <a href="https://habrahabr.ru/company/postgrespro/blog/333878/">GiST</a> , <a href="https://habrahabr.ru/company/postgrespro/blog/337502/">SP-GiST</a> , <a href="https://habrahabr.ru/company/postgrespro/blog/340978/">GIN</a> and <a href="https://habrahabr.ru/company/postgrespro/blog/343488/">RUM</a> .  The topic of this article is BRIN indices. <br><br><h1>  BRIN </h1><br><h2>  General idea </h2><br>  In contrast to the indexes with which we have already met, the idea of ‚Äã‚ÄãBRIN is not to quickly find the necessary lines, but to avoid looking at obviously unnecessary ones.  This is always an <em>inaccurate</em> index: it does not contain TIDs of table rows at all. <br><br>  Simply put, BRIN works well for those columns whose values ‚Äã‚Äãcorrelate with their physical location in the table.  In other words, if a query without an ORDER BY clause produces column values ‚Äã‚Äãin almost ascending or descending order (and there are no indices in the column). 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The access method was created in the framework of the European project on the extremely large <a href="https://axleproject.eu/">Axle</a> analytical databases with an eye on tables of the size of one and tens of terabytes.  An important property of BRIN that allows you to create indexes on such tables is the small size and minimal overhead costs of maintenance. <br><br>  It works as follows.  The table is divided into <em>zones</em> (range) the size of several pages (or blocks, which is the same) - hence the name: Block Range Index, BRIN.  For each zone, a <em>summary</em> of the data in that zone is stored in the index.  As a rule, this is the minimum and maximum values, but sometimes it happens otherwise, as we will see later.  If, when executing a query containing a condition on a column, the desired values ‚Äã‚Äãdo not fall within the range, then the entire zone can be safely omitted;  if they do, all the lines in all blocks of the zone will have to be viewed and the appropriate ones selected. <br><br>  It will not be a mistake to consider BRIN not as an index in the usual sense, but as an accelerator of sequential table scanning.  You can look at it as an alternative to partitioning, if each zone is considered a separate ‚Äúvirtual‚Äù section. <br>  Now consider the index device in more detail. <br><a name="habracut"></a><br><h2>  Device </h2><br>  The first (or rather, zero) in the index is a page with metadata. <br><br>  With some indent from the metadata are pages with summary information.  Each index line contains a summary of any one zone. <br><br>  And between the metastpage and the summary data there are pages with a <em>reverse zone map</em> (reverse range map, abbreviated revmap).  In essence, this is an array of pointers (TIDs) for the corresponding index rows. <br><br><img src="https://habrastorage.org/webt/nr/pm/s9/nrpms932o5clzubwymywxtud6q4.png"><br><br>  For some zones, the pointer in revmap may not lead to any index line (in the figure it is marked in gray).  In this case, it is considered that no summary information is available for this zone. <br><br><h3>  Index scan </h3><br>  How is an index used if it does not contain references to table rows?  Of course, this access method does not know how to return strings one by one, but it can build a bitmap.  Bitmap pages are of two types: exact - to the line - and inaccurate - to the page.  Inaccurate bitmap is used. <br><br>  The algorithm is simple.  The zone map is sequentially viewed (that is, the zones are sorted in the order of their location in the table).  Indexes are used to identify index lines with summary information for each zone.  If the zone does not exactly contain the desired value, it is skipped;  if it can contain (or if there is no summary information) - all pages of the zone are added to the bitmap.  The resulting bitmap is used further as usual. <br><br><h3>  Index update </h3><br>  More interesting is the case of updating the index when the table changes. <br><br>  <strong>When adding a</strong> new version of a row to a table page, we determine which zone it belongs to, and on the zone map we find the index row with summary information.  All this is simple arithmetic.  Suppose, for example, the zone size is 4 pages, and on page 13 there is a version of the line with the value "42".  The zone number (starting from zero) is 13/4 = 3, so in revmap we take, with an offset of 3 (the fourth in a row). <br><br>  The minimum value for this zone is 31, the maximum is 40. Since the new value of 42 exceeds these limits, we update the maximum value (see figure).  If the new value fits into the existing framework, the index does not need to be updated. <br><br><img src="https://habrastorage.org/webt/bh/tj/r7/bhtjr7d2pkrrjk2bwsyann7lmhi.png"><br><br>  All this concerns the case when a new version of the line appears in the zone for which there is already a summary information.  When building the index, the summary information is calculated for all existing zones, but with further growth of the table, new pages may appear that fall outside this range.  There are two possible options: <br><br><ol><li>  Usually, an immediate index update does not occur.  Nothing wrong with that;  as we said, scanning the index will see the entire area.  In fact, the update is performed during the cleaning (vacuum), or it can be done manually by calling the function brin_summarize_new_values. <br></li><li>  If you create an index with the autosummarize parameter, the update will take place immediately.  But when filling the pages of the zone with new values, the update can be performed very often, so this option is turned off by default. <br></li></ol><br>  When new zones appear, revmap size may increase.  If this card ceases to fit into the pages allotted to it, it simply ‚Äúcaptures‚Äù the next one, and all versions of the lines that were there are moved to other pages.  Thus, the zone map is always located between the metastpage and the summary data. <br><br>  <strong>When you delete a</strong> line ... nothing happens.  You may notice that in some cases the minimum or maximum value will be removed, and then the range could be reduced.  But to determine this, I would have to read all the values ‚Äã‚Äãin the zone, and this is expensive. <br><br>  The index correctness does not suffer from this, however, when searching you may need to look at more zones than you really need.  In principle, it is possible to manually reassemble the summary information on such a zone (call the functions brin_desummarize_range and brin_summarize_new_values), but how to detect such a need?  In any case, there is no standard procedure for this. <br><br>  Well, <strong>updating the line</strong> is just removing the old version and adding a new one. <br><br><h2>  Example </h2><br>  Let's try to build our own mini-data warehouse based on the <a href="https://postgrespro.ru/education/demodb">demo database tables</a> .  For example, for the needs of BI-reporting, a denormalized table is needed, reflecting flights departing from the airport or landing at the airport with accuracy to a seat in the cabin.  Data for each airport will be added to the table once a day, as soon as it is midnight in the corresponding time zone.  Data will not be changed or deleted. <br><br>  The table will look like this: <br><br> <code>demo=# create table flights_bi( <br> airport_code char(3),        --   <br> airport_coord point,        --   <br> airport_utc_offset interval, --   <br> flight_no char(6),          --   <br> flight_type text.            --  : departure () / arrival () <br> scheduled_time timestamptz,  --  /    <br> actual_time timestamptz,    --   <br> aircraft_code char(3),      --    <br> seat_no varchar(4),          --   <br> fare_conditions varchar(10), --   <br> passenger_id varchar(20),    --    <br> passenger_name text          --   <br> ); <br> CREATE TABLE <br></code> <br>  The data loading procedure can be simulated with nested loops: external by days (we take a <a href="">large</a> database, therefore, 365 days), internal - by time zones (from UTC + 02 to UTC + 12).  The request is quite long and does not represent much interest, so I hide it under the spoiler. <br><br><div class="spoiler">  <b class="spoiler_title">Simulate data loading in storage</b> <div class="spoiler_text"> <code>DO $$ <br> &lt;&lt;local&gt;&gt; <br> DECLARE <br> curdate date := (SELECT min(scheduled_departure) FROM flights); <br> utc_offset interval; <br> BEGIN <br> WHILE (curdate &lt;= bookings.now()::date) LOOP <br> utc_offset := interval '12 hours'; <br> WHILE (utc_offset &gt;= interval '2 hours') LOOP <br> INSERT INTO flights_bi <br> WITH flight ( <br> airport_code, <br> airport_coord, <br> flight_id, <br> flight_no, <br> scheduled_time, <br> actual_time, <br> aircraft_code, <br> flight_type <br> ) AS ( <br> --  <br> SELECT a.airport_code, <br> a.coordinates, <br> f.flight_id, <br> f.flight_no, <br> f.scheduled_departure, <br> f.actual_departure, <br> f.aircraft_code, <br> 'departure' <br> FROM  airports a, <br> flights f, <br> pg_timezone_names tzn <br> WHERE  a.airport_code = f.departure_airport <br> AND    f.actual_departure IS NOT NULL <br> AND    tzn.name = a.timezone <br> AND    tzn.utc_offset = local.utc_offset <br> AND    timezone(a.timezone, f.actual_departure)::date = curdate <br> UNION ALL <br> --  <br> SELECT a.airport_code, <br> a.coordinates, <br> f.flight_id, <br> f.flight_no, <br> f.scheduled_arrival, <br> f.actual_arrival, <br> f.aircraft_code, <br> 'arrival' <br> FROM  airports a, <br> flights f, <br> pg_timezone_names tzn <br> WHERE  a.airport_code = f.arrival_airport <br> AND    f.actual_arrival IS NOT NULL <br> AND    tzn.name = a.timezone <br> AND    tzn.utc_offset = local.utc_offset <br> AND    timezone(a.timezone, f.actual_arrival)::date = curdate <br> ) <br> SELECT f.airport_code, <br> f.airport_coord, <br> local.utc_offset, <br> f.flight_no, <br> f.flight_type, <br> f.scheduled_time, <br> f.actual_time, <br> f.aircraft_code, <br> s.seat_no, <br> s.fare_conditions, <br> t.passenger_id, <br> t.passenger_name <br> FROM  flight f <br> JOIN seats s <br> ON s.aircraft_code = f.aircraft_code <br> LEFT JOIN boarding_passes bp <br> ON bp.flight_id = f.flight_id <br> AND bp.seat_no = s.seat_no <br> LEFT JOIN ticket_flights tf <br> ON tf.ticket_no = bp.ticket_no <br> AND tf.flight_id = bp.flight_id <br> LEFT JOIN tickets t <br> ON t.ticket_no = tf.ticket_no; <br> <br> RAISE NOTICE '%, %', curdate, utc_offset; <br> utc_offset := utc_offset - interval '1 hour'; <br> END LOOP; <br> curdate := curdate + 1; <br> END LOOP; <br> END; <br> $$; <br></code> <br></div></div><br> <code>demo=# select count(*) from flights_bi; <br> count <br> ---------- <br> 30517076 <br> (1 row) <br> <br> demo=# select pg_size_pretty(pg_total_relation_size('flights_bi')); <br> pg_size_pretty <br> ---------------- <br> 4127 MB <br> (1 row) <br></code> <br>  It turned out 30 million lines and 4 GB.  God knows how much, but it‚Äôs good for a laptop: I have a full scan in about 10 seconds. <br><br><h3>  What columns to build the index? </h3><br>  Since BRIN-indexes are small and have low overhead, and updates, if they occur, rarely, there is a rare situation when you can create many ‚Äújust in case‚Äù indexes, for example, across all fields for which analytics users can build your adhoc requests.  Not useful - well, and even a not very efficient index will probably work better than a full scan.  Of course, there are fields where the index is completely useless;  they will be prompted by simple common sense. <br><br>  But it would be strange to confine to such advice, therefore we will try to formulate a more accurate criterion. <br><br>  We said that these data should in some way correlate with their physical location.  It is appropriate to recall here that PostgreSQL collects statistics on the fields of the tables, which also includes the correlation value.  This value is used by the scheduler to choose between conventional index scanning and bitmap scanning, and we can use it to evaluate the suitability of the BRIN index. <br><br>  In our example, the data is obviously ordered by days (both by scheduled_time and actual_time - the difference is small).  This happens because when adding rows to a table (in the absence of deletions and updates), they fit into the file sequentially, one after another.  In the load imitation, we did not even use the ORDER BY clause, therefore, within the day, the dates can in principle be mixed as desired, but orderliness must be present.  Check: <br><br> <code>demo=# analyze flights_bi; <br> ANALYZE <br> demo=# select attname, correlation from pg_stats where tablename='flights_bi' <br> order by correlation desc nulls last; <br> attname      | correlation <br> --------------------+------------- <br> scheduled_time    |    0.999994 <br> actual_time        |    0.999994 <br> fare_conditions    |    0.796719 <br> flight_type        |    0.495937 <br> airport_utc_offset |    0.438443 <br> aircraft_code      |    0.172262 <br> airport_code      |  0.0543143 <br> flight_no          |  0.0121366 <br> seat_no            |  0.00568042 <br> passenger_name    |  0.0046387 <br> passenger_id      | -0.00281272 <br> airport_coord      | <br> (12 rows) <br></code> <br>  A value that is not too close to zero (and, ideally, about plus or minus ones, as in our case), suggests that a BRIN index would be appropriate. <br><br>  The second and third places were unexpectedly the service class fare_condition (the column contains three unique values) and the flight type flight_type (two unique values).  This is a snag: formally, the correlation is high, but in fact in several pages taken in succession all the possible values ‚Äã‚Äãwill surely show up - and this means that there will be no sense from BRIN. <br><br>  Next is the time zone airport_utc_offset: in our example, within a single day cycle, the airports ‚Äúby construction‚Äù are ordered by time zones. <br><br>  With these two fields - time and time zone - we will continue to experiment. <br><br><h3>  Possible correlation violation </h3><br>  The correlation ‚Äúbuilt by construction‚Äù can be easily broken by changing the data.  And the point here is not to change a particular value, but to a device of multiversion: the old version of the line is deleted on one page, but the new one can be inserted anywhere where there is free space.  Because of this, the updates shuffle the lines entirely. <br><br>  In part, this phenomenon can be dealt with by reducing the value of the storage parameter fillfactor, thereby leaving room on the page for future updates.  But do you want to increase the volume of the already huge table?  In addition, this does not solve the issue of deletions: they also ‚Äúprepare traps‚Äù for new lines, freeing up space somewhere inside the existing pages.  Because of this, lines that would otherwise end up at the end of the file will be inserted in some arbitrary place. <br><br>  By the way, fun fact.  Since there are no references to table rows in the BRIN-index, its presence should not interfere with HOT-updates - but it does. <br><br>  So, first of all, BRIN is designed for tables of large and even huge size, which are either not updated at all or are updated very little.  However, with the addition of new rows (at the end of the table), he handles well.  This is not surprising, since this access method was created with an eye to data warehouses and analytical reporting. <br><br><h3>  What is the size of the zone to choose? </h3><br>  If we are dealing with a terabyte table, then, perhaps, the main concern in choosing the size of the zone will be that the BRIN index does not turn out too large.  In our case, we can afford to analyze the data more accurately. <br><br>  To do this, we can select unique column values ‚Äã‚Äãand see how many pages these values ‚Äã‚Äãoccur.  Localization of values ‚Äã‚Äãincreases the chances of successful use of the BRIN-index.  Moreover, the number of pages found will serve as a hint for determining the size of the zone.  If the value is ‚Äúspread‚Äù on all pages of the table - BRIN is useless. <br><br>  Of course, this technique should be applied with a good eye on the internal data structure.  For example, it makes no sense for us to consider each date (or rather, the timestamp, which includes time) as a unique value - we need to round it up to days. <br><br>  A number of technically such an analysis can be performed by looking at the value of the hidden ctid column, which gives a pointer to the row version (TID): the page number and the row number inside the page.  Unfortunately, there is no regular way to decompose the TID into its two components, so you have to bring types through a textual representation: <br><br> <code>demo=# select min(numblk), round(avg(numblk)) avg, max(numblk) <br> from ( <br> select count(distinct (ctid::text::point)[0]) numblk <br> from flights_bi <br> group by scheduled_time::date <br> ) t; <br> min  | avg  | max <br> ------+------+------ <br> 1192 | 1500 | 1796 <br> (1 row) <br> <br> demo=# select relpages from pg_class where relname = 'flights_bi'; <br> relpages <br> ---------- <br> 528172 <br> (1 row) <br></code> <br>  We see that each day is distributed fairly evenly across the pages, and the days are slightly mixed with each other (1500 √ó 365 = 547500, which is only slightly more than the number of pages in table 528172).  This, in fact, is understandable ‚Äúby construction‚Äù. <br><br>  Valuable information here is a specific number of pages.  With a standard zone size of 128 pages, each day will take from 9 to 14 zones.  This seems to be adequate: if you request for a particular day, you can expect an error of around 10%. <br><br>  Let's try: <br><br> <code>demo=# create index on flights_bi using brin(scheduled_time); <br> CREATE INDEX <br></code> <br>  The size of the index is only 184 KB: <br><br> <code>demo=# select pg_size_pretty(pg_total_relation_size('flights_bi_scheduled_time_idx')); <br> pg_size_pretty <br> ---------------- <br> 184 kB <br> (1 row) <br></code> <br>  Increasing the size of the zone, sacrificing accuracy, in this case hardly makes sense.  And if you wish, you can reduce it - then on the contrary, the accuracy will increase (along with the size of the index). <br><br>  Now look at the time zones.  Here, too, you can not act "in the forehead" - all values ‚Äã‚Äãshould be divided by the number of daily "cycles", since the distribution is repeated within each day.  In addition, since there are few time zones, you can view the entire distribution: <br><br> <code>demo=# select airport_utc_offset, count(distinct (ctid::text::point)[0])/365 numblk <br> from flights_bi <br> group by airport_utc_offset <br> order by 2; <br> airport_utc_offset | numblk <br> --------------------+-------- <br> 12:00:00          |      6 <br> 06:00:00          |      8 <br> 02:00:00          |    10 <br> 11:00:00          |    13 <br> 08:00:00          |    28 <br> 09:00:00          |    29 <br> 10:00:00          |    40 <br> 04:00:00          |    47 <br> 07:00:00          |    110 <br> 05:00:00          |    231 <br> 03:00:00          |    932 <br> (11 rows) <br></code> <br>  On average, the data for each time zone is 133 pages per day, but the distribution is very uneven: Petropavlosk-Kamchatsky and Anadyr fit only six pages, and Moscow and the surrounding area require nine hundred.  The default zone size is definitely not suitable here;  let's set 4 pages for example. <br><br> <code>demo=# create index on flights_bi using brin(airport_utc_offset) with (pages_per_range=4); <br> CREATE INDEX <br> demo=# select pg_size_pretty(pg_total_relation_size('flights_bi_airport_utc_offset_idx')); <br> pg_size_pretty <br> ---------------- <br> 6528 kB <br> (1 row) <br></code> <br><h3>  Execution plan </h3><br>  Now let's see how our indexes work.  Choose a day, say, a week ago (‚Äútoday‚Äù is defined in the demo database by the function bookings.now): <br><br> <code>demo=# \set d 'bookings.now()::date - interval \'7 days\'' <br> demo=# explain (costs off,analyze) <br> select * <br> from flights_bi <br> where scheduled_time &gt;= :d and scheduled_time &lt; :d + interval '1 day'; <br> QUERY PLAN <br> -------------------------------------------------------------------------------- <br> Bitmap Heap Scan on flights_bi (actual time=10.282..94.328 rows= <strong>83954</strong> loops=1) <br> Recheck Cond: ... <br> Rows Removed by Index Recheck: <strong>12045</strong> <br> Heap Blocks: lossy= <strong>1664</strong> <br> -&gt;  Bitmap Index Scan on flights_bi_scheduled_time_idx <br> (actual time=3.013..3.013 rows= <strong>16640</strong> loops=1) <br> Index Cond: ... <br> Planning time: 0.375 ms <br> Execution time: 97.805 ms <br></code> <br><br>  As you can see, the scheduler used the created index.  How accurate is it?  This is indicated by the ratio of the number of rows that satisfy the conditions of the sample (rows of the Bitmap Heap Scan node) to the total number of rows that was obtained using the index (the same plus Rows Removed by Index Recheck).  In our case, 83954 / (83954 + 12045) - approximately 90%, as expected (this value will change from day to day). <br><br>  Where did the number 16640 appear in the actual rows of the Bitmap Index Scan node?  The fact is that this plan node builds an inaccurate (page by page) bitmap and has no idea how many lines it will affect, but it‚Äôs necessary to show something.  Therefore, because of hopelessness, it is believed that on each page we will find 10 lines.  In total, the bitmap contains 1664 pages (this value can be seen from ‚ÄúHeap Blocks: lossy = 1664‚Äù) - it turns out to be 16640. In general, this is a meaningless number, you do not need to pay attention to it. <br><br>  What about airports?  For example, let's take Vladivostok time zone, which occupies 28 pages per day: <br><br> <code>demo=# explain (costs off,analyze) <br> select * <br> from flights_bi <br> where airport_utc_offset = interval '8 hours'; <br> QUERY PLAN <br> ---------------------------------------------------------------------------------- <br> Bitmap Heap Scan on flights_bi (actual time=75.151..192.210 rows= <strong>587353</strong> loops=1) <br> Recheck Cond: (airport_utc_offset = '08:00:00'::interval) <br> Rows Removed by Index Recheck: <strong>191318</strong> <br> Heap Blocks: lossy=13380 <br> -&gt;  Bitmap Index Scan on flights_bi_airport_utc_offset_idx <br> (actual time=74.999..74.999 rows=133800 loops=1) <br> Index Cond: (airport_utc_offset = '08:00:00'::interval) <br> Planning time: 0.168 ms <br> Execution time: 212.278 ms <br></code> <br>  Again the scheduler uses the BRIN index created.  Accuracy is worse (about 75% in this case), but this is expected: the correlation is lower. <br><br>  Of course, several BRIN indices (like any others) can be combined at the level of a bitmap.  For example, data on the selected time zone for the month: <br><br> <code>demo=# \set d 'bookings.now()::date - interval \'60 days\'' <br> demo=# explain (costs off,analyze) <br> select * <br> from flights_bi <br> where scheduled_time &gt;= :d and scheduled_time &lt; :d + interval '30 days' <br> and airport_utc_offset = interval '8 hours'; <br> QUERY PLAN <br> --------------------------------------------------------------------------------- <br> Bitmap Heap Scan on flights_bi (actual time=62.046..113.849 rows=48154 loops=1) <br> Recheck Cond: ... <br> Rows Removed by Index Recheck: 18856 <br> Heap Blocks: lossy=1152 <br> -&gt; <strong>BitmapAnd</strong> (actual time=61.777..61.777 rows=0 loops=1) <br> -&gt; <strong>Bitmap Index Scan</strong> on flights_bi_scheduled_time_idx <br> (actual time=5.490..5.490 rows=435200 loops=1) <br> Index Cond: ... <br> -&gt; <strong>Bitmap Index Scan</strong> on flights_bi_airport_utc_offset_idx <br> (actual time=55.068..55.068 rows=133800 loops=1) <br> Index Cond: ... <br> Planning time: 0.408 ms <br> Execution time: 115.475 ms <br></code> <br><h3>  Comparison with B-tree </h3><br>  What if you build a regular B-tree index on the same field as BRIN? <br><br> <code>demo=# create index flights_bi_scheduled_time_btree on flights_bi(scheduled_time); <br> CREATE INDEX <br> demo=# select pg_size_pretty(pg_total_relation_size('flights_bi_scheduled_time_btree')); <br> pg_size_pretty <br> ---------------- <br> 654 MB <br> (1 row) <br></code> <br>  It turned out <em>several thousand times more</em> than our BRIN!  True, the query execution speed slightly increased - the scheduler realized that the data is physically ordered and there is no need to build a bitmap, and, most importantly, do not need to recheck the index condition: <br><br> <code>demo=# explain (costs off,analyze) <br> select * <br> from flights_bi <br> where scheduled_time &gt;= :d and scheduled_time &lt; :d + interval '1 day'; <br> QUERY PLAN <br> ---------------------------------------------------------------- <br> Index Scan using flights_bi_scheduled_time_btree on flights_bi <br> (actual time=0.099..79.416 rows=83954 loops=1) <br> Index Cond: ... <br> Planning time: 0.500 ms <br> Execution time: 85.044 ms <br></code> <br>  This is the beauty of BRIN: we sacrifice efficiency, but we win a lot of space. <br><br><h2>  Operator Classes </h2><br><h3>  minmax </h3><br>  For data types whose values ‚Äã‚Äãcan be compared with each other, the summary information consists of the <em>minimum and maximum values.</em>  The corresponding operator classes contain minmax in the name, for example, date_minmax_ops.  Actually, we have so far considered them, and such are the majority. <br><br><h3>  inclusive </h3><br>  Comparison operations are not defined for all data types.  For example, they are not for points (type of point), which presents the coordinates of airports.  By the way, this is why statistics do not show a correlation for this column: <br><br> <code>demo=# select attname, correlation <br> from pg_stats <br> where tablename='flights_bi' and attname = 'airport_coord'; <br> attname    | correlation <br> ---------------+------------- <br> airport_coord | <br> (1 row) <br></code> <br>  But for many of these types, you can introduce the concept of a ‚Äúbounding area‚Äù, for example, a bounding box for geometric shapes.  We talked in detail about how this property is used by the <a href="https://habrahabr.ru/company/postgrespro/blog/333878/">GiST</a> index.  Similarly, BRIN allows you to collect summary information about columns of these types: the <em>bounding area for all values ‚Äã‚Äãwithin a zone</em> is a summary value. <br><br>  Unlike GiST, the summary value in BRIN must be of the same type as the data being indexed.  Therefore, for example, for points an index cannot be built, although it is clear that the coordinates could work in BRIN: the longitude is quite strongly related to the time zone.  Fortunately, no one bothers to create an index by expression, transforming points into degenerate rectangles.  At the same time, we set the zone size to one page, just to show the extreme case: <br><br> <code>demo=# create index on flights_bi using brin (box(airport_coord)) with (pages_per_range=1); <br> CREATE INDEX <br></code> <br>  Even in such an extreme version, the index takes only 30 MB: <br><br> <code>demo=# select pg_size_pretty(pg_total_relation_size('flights_bi_box_idx')); <br> pg_size_pretty <br> ---------------- <br> 30 MB <br> (1 row) <br></code> <br>  Now we can write queries, limiting airports to coordinates.  For example: <br><br> <code>demo=# select airport_code, airport_name <br> from airports <br> where box(coordinates) &lt;@ box '120,40,140,50'; <br> airport_code |  airport_name <br> --------------+----------------- <br> KHV          | - <br> VVO          |  <br> (2 rows) <br></code> <br>  True, the scheduler will refuse to use our index. <br><br> <code>demo=# analyze flights_bi; <br> ANALYZE <br> demo=# explain select * from flights_bi <br> where box(airport_coord) &lt;@ box '120,40,140,50'; <br> QUERY PLAN <br> --------------------------------------------------------------------- <br> Seq Scan on flights_bi  (cost=0.00..985928.14 rows=30517 width=111) <br> Filter: (box(airport_coord) &lt;@ '(140,50),(120,40)'::box) <br></code> <br>  Why?  Let's disable full scans and see. <br><br> <code>demo=# set enable_seqscan = off; <br> SET <br> demo=# explain select * from flights_bi <br> where box(airport_coord) &lt;@ box '120,40,140,50'; <br> QUERY PLAN <br> -------------------------------------------------------------------------------- <br> Bitmap Heap Scan on flights_bi  (cost=14079.67..1000007.81 rows=30517 width=111) <br> Recheck Cond: (box(airport_coord) &lt;@ '(140,50),(120,40)'::box) <br> -&gt;  Bitmap Index Scan on flights_bi_box_idx <br> (cost=0.00..14072.04 rows= <strong>30517076</strong> width=0) <br> Index Cond: (box(airport_coord) &lt;@ '(140,50),(120,40)'::box) <br></code> <br>  It turns out that the index <em>can be</em> used, but the scheduler believes that the bitmap will have to be built all over the table - no wonder that in this case he prefers a full scan.  The problem here is that for geometry types, PostgreSQL does not collect any statistics, so the scheduler has to act blindly: <br><br> <code>demo=# select * from pg_stats where tablename = 'flights_bi_box_idx' \gx <br> -[ RECORD 1 ]----------+------------------- <br> schemaname            | bookings <br> tablename              | flights_bi_box_idx <br> attname                | box <br> inherited              | f <br> null_frac              | 0 <br> avg_width              | 32 <br> n_distinct            | 0 <br> most_common_vals      | <br> most_common_freqs      | <br> histogram_bounds      | <br> correlation            | <br> most_common_elems      | <br> most_common_elem_freqs | <br> elem_count_histogram  | <br></code> <br>  Alas.  But there are no complaints about the index itself, it works, and not bad: <br><br> <code>demo=# explain (costs off,analyze) <br> select * from flights_bi where box(airport_coord) &lt;@ box '120,40,140,50'; <br> QUERY PLAN <br> ---------------------------------------------------------------------------------- <br> Bitmap Heap Scan on flights_bi (actual time=158.142..315.445 rows= <strong>781790</strong> loops=1) <br> Recheck Cond: (box(airport_coord) &lt;@ '(140,50),(120,40)'::box) <br> Rows Removed by Index Recheck: <strong>70726</strong> <br> Heap Blocks: lossy=14772 <br> -&gt;  Bitmap Index Scan on flights_bi_box_idx <br> (actual time=158.083..158.083 rows=147720 loops=1) <br> Index Cond: (box(airport_coord) &lt;@ '(140,50),(120,40)'::box) <br> Planning time: 0.137 ms <br> Execution time: 340.593 ms <br></code> <br>  The conclusion, apparently, is this: if you need at least something non-trivial from geometry, you need PostGIS.  In any case, he is able to collect statistics. <br><br><h2>  Inside </h2><br>  A peek inside the BRIN-index allows regular extension pageinspect. <br><br>  First, the meta-information will tell us the size of the zone and how many pages are allocated for revmap: <br><br> <code>demo=# select * from brin_metapage_info(get_raw_page('flights_bi_scheduled_time_idx',0)); <br> magic    | version | pagesperrange | lastrevmappage <br> ------------+---------+---------------+---------------- <br> 0xA8109CFA |      1 |          128 |              3 <br> (1 row) <br></code> <br>  Here pages 1 through 3 are revmap, the rest is summary data.  You can get from revmap links to the summary data for each zone.  Say, information about the first zone, covering the first 128 pages of the table, is here: <br><br> <code>demo=# select * from brin_revmap_data(get_raw_page('flights_bi_scheduled_time_idx',1)) limit 1; <br> pages <br> --------- <br> (6,197) <br> (1 row) <br></code> <br>  But the summary data itself: <br><br> <code>demo=# select allnulls, hasnulls, value <br> from brin_page_items(get_raw_page('flights_bi_scheduled_time_idx', <strong>6</strong> ), 'flights_bi_scheduled_time_idx') <br> where itemoffset = <strong>197</strong> ; <br> allnulls | hasnulls |                      value <br> ----------+----------+---------------------------------------------------- <br> f        | f        | {2016-08-15 02:45:00+03 .. 2016-08-15 17:15:00+03} <br> (1 row) <br></code> <br>  Next zone: <br><br> <code>demo=# select * from brin_revmap_data(get_raw_page('flights_bi_scheduled_time_idx',1)) offset 1 limit 1; <br> pages <br> --------- <br> (6,198) <br> (1 row) <br> <br> demo=# select allnulls, hasnulls, value from brin_page_items(get_raw_page('flights_bi_scheduled_time_idx', <strong>6</strong> ), 'flights_bi_scheduled_time_idx') where itemoffset = <strong>198</strong> ; <br> allnulls | hasnulls |                      value <br> ----------+----------+---------------------------------------------------- <br> f        | f        | {2016-08-15 06:00:00+03 .. 2016-08-15 18:55:00+03} <br> (1 row) <br></code> <br>  And so on. <br><br>  For inclusion classes, the value field will display something like <br><br> <code>{(94.4005966186523,69.3110961914062),(77.6600036621,51.6693992614746) .. f .. f} <br></code> <br>  The first value is the enclosing rectangle, and the letters ‚Äúf‚Äù at the end mean the absence of empty elements (the first) and the absence of values ‚Äã‚Äãthat cannot be combined (the second).  Actually, the only case of non-joining values ‚Äã‚Äãis IPv4 and IPv6 addresses (inet data type). <br><br><h2>  Properties </h2><br>  Let me remind you that the relevant requests <a href="https://habrahabr.ru/company/postgrespro/blog/326106/">were cited earlier</a> . <br><br>  Method properties: <br><br> <code>amname |    name      | pg_indexam_has_property <br> --------+---------------+------------------------- <br> brin  | can_order    | f <br> brin  | can_unique    | f <br> brin  | can_multi_col | t <br> brin  | can_exclude  | f <br></code> <br>  Indexes can be created in multiple columns.  In this case, each column collects its own summary information, but for each zone it is stored together.  Of course, such an index makes sense if the same zone size is suitable for all columns. <br><br>  Index properties: <br><br> <code>name      | pg_index_has_property <br> ---------------+----------------------- <br> clusterable  | f <br> index_scan    | f <br> bitmap_scan  | t <br> backward_scan | f <br></code> <br>  Obviously, only bitmap scanning is supported. <br><br>  But the lack of clustering can cause confusion.  It would seem that since the BRIN-index is sensitive to the physical order of rows, then it would be logical to be able to cluster data on it?  But no, unless you can create a ‚Äúregular‚Äù index (B-tree or GiST, depending on the type of data) and cluster on it.  And by the way, would you like to cluster a supposedly huge table, considering the exclusive lock, operation time and disk space consumption during the rebuild? <br><br>  Column level properties: <br><br> <code>name        | pg_index_column_has_property <br> --------------------+------------------------------ <br> asc                | f <br> desc              | f <br> nulls_first        | f <br> nulls_last        | f <br> orderable          | f <br> distance_orderable | f <br> returnable        | f <br> search_array      | f <br> search_nulls      | t <br></code> <br>  There are solid dashes, except for the possibility of working with uncertain values. <br><br>  <a href="https://habrahabr.ru/company/postgrespro/blog/349224/">Ending</a> </div><p>Source: <a href="https://habr.com/ru/post/346460/">https://habr.com/ru/post/346460/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../346446/index.html">Data Modeling Zone EU 2017</a></li>
<li><a href="../346448/index.html">Financial Times: How Traders Try to Survive the HFT Trading Decline</a></li>
<li><a href="../346450/index.html">About honors on sober head</a></li>
<li><a href="../346452/index.html">Testing with JUnit 5 on Kotlin</a></li>
<li><a href="../346458/index.html">Updating strings on the fly in mobile apps: part 1</a></li>
<li><a href="../346462/index.html">Startup of the day (December 2017)</a></li>
<li><a href="../346464/index.html">Fresh utilities, plugins and tools for designer and developer to note. Fifth release</a></li>
<li><a href="../346466/index.html">How to protect your IT infrastructure: 7 basic tips</a></li>
<li><a href="../346468/index.html">5 small talk technician to communicate with foreign colleagues</a></li>
<li><a href="../346470/index.html">Corporate habits in British and American companies</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>