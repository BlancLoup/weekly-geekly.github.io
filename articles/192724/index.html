<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Creating a video editor - useful avconv recipes (ffmpeg)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Recently it took to write a small video editor with a web interface. 
 Prior to that, occasionally it has been possible to use commands like 


ffmpeg...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Creating a video editor - useful avconv recipes (ffmpeg)</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/storage3/55c/7c1/9b1/55c7c19b19fa3b6bebe05dea72058a3b.png"><br><br>  Recently it took to write a small video editor with a web interface. <br>  Prior to that, occasionally it has been possible to use commands like <br><pre><code class="bash hljs">ffmpeg -i file.avi file.mp3</code> </pre> <br>  mainly for converting from one format to another.  Everything has always been more or less smooth and difficult to imagine how many different nuances actually exist for working with video and audio. <br>  But let's start from the beginning.  For some time, my ubuntu began to issue: <br><pre> <code class="bash hljs">*** THIS PROGRAM IS DEPRECATED *** This program is only provided <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> compatibility and will be removed <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> a future release. Please use avconv instead.</code> </pre><br>  In general, while it was used in small things, it was not particularly important, but to put the already obsolete feature into the project is somehow ‚Äúnot it‚Äù.  I had to google what was happening and it turned out that the <code>ffmpeg</code> project had split up some time ago and some developers started creating the libav library, which is currently included in ubuntu by default.  Of course, the compatibility of advanced features was sacrificed first.  At the same time, and with the renaming of the project, the ffmpeg executable file was renamed to avconv, which was the above warning. <br><br>  Under the cut a small squeeze of the main features that are useful. <br><a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="bash hljs">avconv [  ] -i   [ ]  </code> </pre><br>  There may be several incoming files, respectively, and -i options are written before each of them <br><br>  But in fact, everything turned out to be a little more complicated. <br>  Further, a set of useful recipes and in the course of the description a small comment about the options <br><br><h6>  The main options that are often found in teams </h6><br>  <code>-y</code> - overwrite the file without question <br>  <code>-threads 8</code> - how many threads to perform the operation (in this case, 8, but not all codecs can parallelize) <br>  <code>-s hd720</code> - video size (in this case, the standard hd720p-1280 * 720) <br>  <code>-q 1</code> - sets the quality of coding (on different codecs acts differently).  Do not forget this option, because by default, only the name of the quality. <br>  For options that set the properties of a stream, it is possible to specify this stream directly in the option itself (without this, the option's effect applies to all streams).  This is done as follows: <br>  <code>-q:a 1</code> - set the audio quality, <br>  <code>-q:v 1</code> - respectively - video. <br>  With the number will be implied flow number <br>  <code>-q:v:0 1</code> - the first video stream (counting from zero), <br>  <code>-q:0 1</code> - the first stream in general, depends on the layout of the file - you must first look at the information that avconv gives relative to the contents of the input files. <br><br><h6>  Cutting a large file into fragments </h6><br><pre> <code class="bash hljs">avconv -i in.mp4 -ss 00:00:30 -t 00:10:00 -q 1 -s hd720 -threads 8 -r 25 -y out.mp4</code> </pre><br>  We <code>-ss 00:00:30</code> from what second <code>-ss 00:00:30</code> and what's the length of time <code>-t 00:10:00</code> to take the video. <br><br><h6>  Separate audio from video at the right volume and length. </h6><br><pre> <code class="bash hljs">avconv -i in.mp4 -ss 00:00:22 -t 00:00:30 -vol 512 -vn -f u16le -ac 2 -ar 44100 -threads 8 -y out.raw</code> </pre><br>  <code>-vn</code> - exclude video stream on output <br>  <code>-ss 00:00:22</code> - the beginning of the cut fragment <br>  <code>-t 00:00:30</code> - the length of the cut fragment <br>  <code>-vol 512</code> - volume, 256 is the normal volume, all that rises higher and below, respectively <br>  <code>-ar 44100</code> - audio sample rate (audio stream sample rate) 44100 complies with cd quality and is standard <br>  <code>-ac 2</code> - sets the number of audio channels (2 - means stereo) <br>  <code>-f u16le</code> - sets the format of the output stream, u16le - saves raw data in a file without headers. <br>  You can export data in a different format, but raw is useful to us if we want to concatenate many audio fragments, which will be easy to accomplish simply by merging the files one by one. <br><br><h6>  Replicating or cloning files </h6><br>  If you need to connect audio tracks, you can use a simple <code>cat</code> <br><pre> <code class="bash hljs">cat in1.raw in2.raw &gt; out.raw</code> </pre><br>  Similarly, you can connect as many files as you like and you can take portions in several passes, creating intermediate ones. <br><pre> <code class="bash hljs">cat in1.raw in1.raw in1.raw &gt; out.raw</code> </pre><br>  Thus, we can replicate a fragment (for example, silence or a single-color signal) for the time we need, or loop a small audio fragment. <br><br><h6>  Convert raw format to normal wav </h6><br><pre> <code class="bash hljs">avconv -q 1 -f u16le -ac 2 -ar 44100 -threads 8 -i in.raw -y out.wav</code> </pre><br><h6>  Pictures </h6><br>  Split video file into images <br><pre> <code class="bash hljs">avconv -i in.avi -q 1 -s hd720 -threads 8 -y <span class="hljs-string"><span class="hljs-string">"out/%08d.jpg"</span></span></code> </pre><br>  At the exit, we get a set of frames that make up the video. <br><br>  Collect video file from images <br><pre> <code class="bash hljs">avconv -i <span class="hljs-string"><span class="hljs-string">"in/%08d.jpg"</span></span> -q 1 -s hd720 -threads 8 -y out_v.avi</code> </pre><br>  Clone images in the right quantity <br>  For example, we have a picture and we need it to be in the video for half a minute.  The option <code>-loop</code> basically serves for this <code>-loop</code> <br><pre> <code class="bash hljs">avconv -loop 1 -i in.jpg -t 00:00:05 -q 1 -s hd720 -threads 8 -y out.mp4</code> </pre><br><br>  Taking a screenshot <br><pre> <code class="bash hljs">avconv -i file.mp4 -an -ss 00:00:30 -r 1 -vframes 1 -y -f mjpeg -q 1 file.jpg</code> </pre><br>  <code>-f mjpeg</code> - specify the codec for this operation <br><h6>  Alternative way to mix audio tracks </h6><br>  For audio processing, there is a good, time-tested tool, <code>sox</code> .  Surprisingly, it was possible to merge two audio tracks after a series of unstable results with avconv without any surprises.  For example, <code>avconv</code> can merge two tracks that are identical in time, and at the exit one of them will complete earlier than the second.  Accordingly, the sound can ‚Äúmove out‚Äù strongly when applied, especially on long rollers. <br><br><pre> <code class="bash hljs">sox -m in1.wav in2.wav out.wav</code> </pre><br>  <code>-m</code> - option specifying the mixing mode of input files.  Without the options, sox simply scans the files, adding the second after the first. <br><br><h6>  Merging sound and video into one file </h6><br><pre> <code class="bash hljs">avconv -i in.mp4 -i in.mp3 -c:v copy -q 1 out.mp4</code> </pre><br>  <code>-c</code> - select codec, respectively <br>  <code>-c:a</code> - audio codec <br>  <code>-c:v</code> - video codec <br>  <code>-c:v copy</code> - Do not recode using original data <br><br><h6>  Concatenation option </h6><br><pre> <code class="bash hljs">avconv -i <span class="hljs-string"><span class="hljs-string">"concat:in1.avi|in2.avi"</span></span> -q 1 -b:a 128k -preset libvpx-720p -threads 8 -y {f_out}</code> </pre><br>  <code>-b</code> - select bitrate <br>  <code>-b:a 128k</code> - we set a bitrate of 128 kbps for mp3 tracks <br>  <code>-preset</code> - immediately sets the settings from the predefined <br>  <code>-preset libvpx-720p</code> - installs the vpx video codec and frame size according to the hd720p standard <br>  <code>concat:</code> is a special ‚Äúformat‚Äù of input files with which lists are set.  In practice, it works in the same way as <code>cat in1.avi in2.avi</code> connected files.  Correspondingly, like cat, it will put the files together, but the codec that parses them may not understand (this is what happens for most formats) and you need to choose a format that supports such a connection.  Of these formats, it is worth mentioning mpeg, avi and raw video data, which could be devoted to a separate article and will not be dealt with here. <br><br><h6>  Build tracks from different files </h6><br><pre> <code class="bash hljs">avconv -i in1.mp4 -i in2.mp4 -map 0:a -map 1:v -y -q 1 out.mp4</code> </pre><br>  <code>-map</code> - indicates the source track to be included in the output file (if no map is specified, avconv will simply convert the first file to the output file format). <br>  <code>-map 0:a</code> - audio track from the first file (counting from zero). <br>  <code>-map 1:v</code> - video track from the second. <br><br><h5>  <font color="darkred">New in version 0.9 <code>-filter_complex</code></font> </h5><br>  This option will determine the order of filters for complex (complex) operations. <br>  It normally works with files when they have the same frame rate. <br><br>  The filter is described by a string that looks like this: <br>  [in1] [in2] convert [out] <br><br>  At the entrance - this is, in fact, the same thing that we write in -map, for example [0: a] [1: a] - audio channels of the first and second videos. <br>  At the output, we give the name to the newly created channel after the completed conversions, for example, mix_a.  It can also be used in the map in the future or as a stream name at the input of the next transformation. <br><br>  By default, all incoming streams (or the first stream, if the filter accepts only one) are included in the conversion, so they can be omitted.  The resulting channel becomes the default channel for the resulting file, so in most cases, it can also be dropped. <br><br>  Transformation operations can be divided into ‚Äúgenerators‚Äù - they don‚Äôt accept anything at all, they only create a stream with specified properties, ¬ªfilters‚Äô - take one stream at the input and convert it and  mixers ‚Äô- take several streams at the input and connect their. <br><br>  There may also be several streams at the output, for example, if the filter breaks stereos into two mono tracks, they also need to be described with a list [out1] [out2], etc. <br><br><h6>  Generator example </h6><br><pre> <code class="bash hljs">avconv -filter_complex <span class="hljs-string"><span class="hljs-string">'color=white'</span></span> -t 5 -q 1 out.mkv</code> </pre><br>  <code>color=white</code> - generates an image with pure white.  This can be used, for example, to create a background for subtitles or as a pause between video clips. <br><br><h6>  Video Filter Examples </h6><br><pre> <code class="bash hljs">avconv -i in.avi -vf <span class="hljs-string"><span class="hljs-string">"hflip"</span></span> out.avi</code> </pre><br>  <code>hflip</code> - mirror image horizontally <br><br><pre> <code class="bash hljs">avconv -i in.avi -vf <span class="hljs-string"><span class="hljs-string">"smooth=type=blur"</span></span> -q 1 out.avi</code> </pre><br>  <code>smooth</code> - performs image blurring using one of several algorithms: ‚Äúblur‚Äù, ‚Äúblur_no_scale‚Äù, ‚Äúmedian‚Äù, ‚Äúgaussian‚Äù, ‚Äúbilateral‚Äù. <br><br><pre> <code class="bash hljs">avconv -i in.avi -vf <span class="hljs-string"><span class="hljs-string">"scale=w=200:h=100"</span></span> -q 1 out.avi</code> </pre><br>  <code>scale</code> - performs image scaling.  On his example, we can consider how parameters are passed to filters.  ‚ÄúScale = ...‚Äù - if after the filter name, as in this example, an equal sign is indicated, then a list of parameters of the form ‚Äúname = value‚Äù should follow.  The parameters are also indicated with an equal sign, therefore, initially it is somewhat confusing, but you can get used to it.  The parameters themselves in the list are separated by colons. <br>  <code>w=200:h=100</code> - rigidly sets the height and width of the output image.  Of course, with the hard way of setting the size, the image is obtained in a controlled size, but the proportions can be distorted. <br>  <code>scale=w=iw/2:h=ih/2</code> - the size of the output image can be specified depending on the input.  In this case, we specify to halve.  By fitting the coefficients accordingly, you can adjust the proportions.  This, by the way, allows you to achieve interesting effects, for example, a reduced image can be inserted as additional information into a corner or you can combine several video images as is done on video surveillance systems. <br>  <code>ow=200:oh=200</code> - cuts the image to the specified size <br>  You can also use more complex expressions and functions in calculations. <br><br><h6>  Mixing examples </h6><br><pre> <code class="bash hljs">avconv -i in1.mp4 -i in2.mp4 -filter_complex amix=inputs=2 -q 1 -b:a 128k -preset libvpx-720p -threads 2 -y out.mp4</code> </pre><br>  <code>amix=inputs=2</code> Mix audio streams.  Here we indicate how many streams at the input and discard the listing itself. <br>  Amix also has a useful <code>duration</code> parameter, which allows you to adjust the length of the output stream and can take one of three values: <br>  - <code>longest</code> - by the duration of the largest mixed audio stream, <br>  - <code>shortest</code> - respectively, the shortest, <br>  - <code>first</code> - by the length of the first stream listed. <br><br><h6>  The picture is superimposed on the video. </h6><br><pre> <code class="bash hljs">avconv -i video.mkv -i logo.png -filter_complex overlay=x=10:y=main_h-overlay_h-10 -q 1 out.mkv</code> </pre><br>  <code>overlay</code> - allows you to overlay one stream over another.  You can also use a picture as a stream.  In the example above, we set the logo to be indented to the left and bottom by ten pixels.  To calculate the indentation below, we subtract the height of the superposed stream from the height of the main stream and additionally subtract the indent itself. <br><br>  In this example, we can demonstrate the use of several filters together.  To separate the list of filters, use ";". <br><br><pre> <code class="bash hljs">avconv -i in1.avi -i in2.avi -filter_complex <span class="hljs-string"><span class="hljs-string">"[1:v]scale=w=iw/3:h=ih/3[v_small];[0:v][v_small]overlay=x=main_w-overlay_w-main_w/20:y=main_h-overlay_h-main_w/20"</span></span> -q 1 out.avi</code> </pre><br>  We take the second image, reduce it three times and place it in the lower right corner, making indent from the edge equal to the horizontal and vertical one-twentieth width of this image. <br><br>  PS I would like to say at the end that the final version was very different from how everything was seen at the beginning.  Last but not least, many bugs affected this even in the most recent version.  As a stable version is offered from the branch 0.8, but there, unfortunately, there are no many interesting features.  On the other hand, avconv from branch 0.9 is very unstable and contrived, in already seemingly tested places, on some input files to eat all the RAM in a few seconds and hang the server.  Of course, the use of memory can be limited to the current user, but this still does not solve the problem, since avconv in any case falls out with an error.  Sometimes individual videos from the video series disappeared, in some cases, the time on the audio track and video sequence unexpectedly diverged - you had to look for other tools and other ways to perform the same tasks. <br><br>  UPD: Apply one image to the sound: <br><pre> <code class="bash hljs">ffmpeg -r 1 -loop 1 -i aa.jpg -i aa.mp4 -acodec copy -vcodec mjpeg -t 326 -q 1 -y a.mp4</code> </pre><br><br>  Who does not have avconv 0.9 in the system <br>  1) clone git and configure <br><pre> <code class="bash hljs">git <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> git://git.libav.org/libav.git; ./configure</code> </pre><br>  2) Compilation is better to specify in several streams so that it is faster.  Install is better not to do so that later nothing had to be restored in the system. <br><pre> <code class="bash hljs">make -j 8</code> </pre><br>  If there is no codec: <br><pre> <code class="bash hljs"> ./configure --<span class="hljs-built_in"><span class="hljs-built_in">help</span></span></code> </pre><br>  And there just to see what <code>--enabled</code> for example <code>./configure --enable-vdpau</code> <br><br><h5>  useful links </h5><br>  - <a href="http://libav.org/avconv.html">Help avconv</a> (eng.) <br>  - <a href="http://libav.org/avconv.html">Computed expressions</a> that can be used in <code>-filter_complex</code> <br>  - <a href="http://libav.org/avconv.html">Video Filters</a> <br>  - <a href="http://libav.org/avconv.html">Audio Filters</a> <br>  Also on Habr√© there is a good translation of the article on video conversion <a href="http://habrahabr.ru/post/171213/">19 ffmpeg commands for any needs</a> , where you can learn more useful recipes.  Almost everything will work with avconv. </div><p>Source: <a href="https://habr.com/ru/post/192724/">https://habr.com/ru/post/192724/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../192714/index.html">Mars Pole: high resolution photo</a></li>
<li><a href="../192716/index.html">Repositories for Windows, or how to install programs faster</a></li>
<li><a href="../192718/index.html">Is there life after blocking Roskomnadzor? there is</a></li>
<li><a href="../192720/index.html">Data-Driven MS-Test Tests for Unit and Acceptance Testing</a></li>
<li><a href="../192722/index.html">Snowden has shed light on the cryptographic hacking situation. Everything is bad</a></li>
<li><a href="../192726/index.html">An example of developing a blog on Zend Framework 2. Part 3. Working with users</a></li>
<li><a href="../192728/index.html">A look at the problems of higher IT education from the teacher</a></li>
<li><a href="../192730/index.html">Sony PRS-T3 - a new reader with a higher resolution display</a></li>
<li><a href="../192736/index.html">Calculating the maximum number in the array at compile time</a></li>
<li><a href="../192738/index.html">0 dB Silent computer. Version 1.0</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>