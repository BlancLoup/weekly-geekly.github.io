<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Parameterized queries and django orm performance</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Faced with significant performance losses in using django orm, I began to look for a way out of the situation, considering different ways of using orm...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Parameterized queries and django orm performance</h1><div class="post__text post__text-html js-mediator-article">  Faced with <a href="https://habr.com/post/148044/">significant performance losses</a> in using django orm, I began to look for a way out of the situation, considering different ways of using orm.  What I did - look tackle. <br><br><a name="habracut"></a><br>  <i>How do I write a regular piece of code using django orm?</i> <br><br>  As a rule, this piece is included in a certain function, well, for example, view, receives parameters and generates a result based on these parameters. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      As an example, consider the following elementary situation: we want to get a list of the names of groups that include the current user.  The simplest and most obvious one that comes to mind in the first place is to get a list of groups through a relationship and find out their names: <br><br><pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">myview</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(request)</span></span></span><span class="hljs-function">:</span></span> u = request.user a = [g.name <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> g <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> u.groups.all()] ...</code> </pre> <br><br>  Let's check what the performance of this piece will be, bearing in mind that the user object request.user has already been received at the stage of preliminary processing of the request. <br><br>  Create thetest group and attach the very first user to it: <br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>u = User.objects.all()[<span class="hljs-number"><span class="hljs-number">0</span></span>] &gt;&gt;&gt; g = Group(name=<span class="hljs-string"><span class="hljs-string">'thetest'</span></span>) &gt;&gt;&gt; g.save() &gt;&gt;&gt; u.groups.add(g) &gt;&gt;&gt; u.groups.all() [&lt;Group: thetest&gt;]</code> </pre><br><br>  <i>I will use this case in all further tests.</i>  <i>Since everything is done through the shell, I also use in them the u variable obtained at this stage.</i> <br><br>  So, test number 1, we execute the intended piece of code.  Check if it really returns the desired list: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>a = [g.name <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> g <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> u.groups.all()] &gt;&gt;&gt; a [<span class="hljs-string"><span class="hljs-string">u'thetest'</span></span>]</code> </pre><br><br>  To measure performance, we will execute it 1000 times. <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> datetime ... t1 = datetime.datetime.now() ... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> xrange(<span class="hljs-number"><span class="hljs-number">1000</span></span>): ... a = [g.name <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> g <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> u.groups.all()] ... t2 = datetime.datetime.now() ... <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">"%s"</span></span> % (t2 - t1) ... &gt;&gt;&gt; test1() <span class="hljs-number"><span class="hljs-number">0</span></span>:<span class="hljs-number"><span class="hljs-number">00</span></span>:<span class="hljs-number"><span class="hljs-number">01.437324</span></span></code> </pre><br>  A thousand revolutions of our cycle were completed in about one and a half seconds, which gives 1.5 milliseconds per request. <br><br>  Experienced jang-painters probably already got ready to poke my nose at the fact that this piece is far from optimal.  Indeed, at first glance, it is possible to write a more optimal section of code that performs the same actions without constructing the group object and retrieving from the database only the data that we really need: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>a = [g[<span class="hljs-string"><span class="hljs-string">'name'</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> g <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> u.groups.values(<span class="hljs-string"><span class="hljs-string">'name'</span></span>)] &gt;&gt;&gt; a [<span class="hljs-string"><span class="hljs-string">u'thetest'</span></span>]</code> </pre><br><br>  Well, measure it and this piece. <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> datetime ... t1 = datetime.datetime.now() ... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> xrange(<span class="hljs-number"><span class="hljs-number">1000</span></span>): ... a = [g[<span class="hljs-string"><span class="hljs-string">'name'</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> g <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> u.groups.values(<span class="hljs-string"><span class="hljs-string">'name'</span></span>)] ... t2 = datetime.datetime.now() ... <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">"%s"</span></span> % (t2 - t1) ... &gt;&gt;&gt; test2() <span class="hljs-number"><span class="hljs-number">0</span></span>:<span class="hljs-number"><span class="hljs-number">00</span></span>:<span class="hljs-number"><span class="hljs-number">01.752529</span></span></code> </pre><br>  This seems unnatural, but is the second version of our code less optimal than the first? <br><br>  In fact, this is the way it is.  The loss on the values ‚Äã‚Äã() call and the additional query analysis turned out to be higher than the potential savings on the design of the Group object and on getting the values ‚Äã‚Äãof all its fields. <br><br>  But let me?  And why should we actually <i>re-construct and analyze the</i> request every time, if in our view we always execute <i>the same request</i> , and only the user object on which this request is executed will differ? <br><br>  Unfortunately, django initially <i>does not allow you to</i> prepare a request in advance, referring to a prepared request as needed.  There are no corresponding calls, and the syntax of forming a query implies using only specific values ‚Äã‚Äãas query parameters. <br><br>  It is necessary to climb a little bit on the source.  Taking this opportunity, I would like to express my gratitude to the developers of django_extensions and their wonderful team shell_plus, which greatly facilitates the introspection of objects. <br><br>  It turns out that the QuerySet object (this is the one that is obtained, for example, at the time of accessing objects.all ()) has a query property, an object of class django.db.models.sql.query.Query.  Which in turn has the sql_with_params () method <br><br>  This method returns a set of parameters, completely ready to be passed to cursor.execute () - that is, a string of an SQL expression and additional parameters.  The most remarkable thing is that these very additional parameters are the parameters that are passed to the QuerySet object during its formation: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>u.groups.all().values(<span class="hljs-string"><span class="hljs-string">'name'</span></span>).query.sql_with_params() (<span class="hljs-string"><span class="hljs-string">'SELECT `auth_group`.`name` FROM `auth_group` INNER JOIN `auth_user_groups` ON (`auth_group`.`id` = `auth_user_groups`.`group_id`) WHERE `auth_user_groups`.`user_id` = %s '</span></span>, (<span class="hljs-number"><span class="hljs-number">1</span></span>,))</code> </pre><br><br>  Now, if we receive a prepared SQL query and substitute various parameter values ‚Äã‚Äãinto it, we will be able to execute the query without wasting resources on preparing the query. <br><br>  To do this, create a special class that hides inside all the details of the hack that we are going to make. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> django.db <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> connection <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> django.db.models.query <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> QuerySet,ValuesQuerySet <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> django <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> threading <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> local <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PQuery</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(local)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self,query,connection=connection,**placeholders)</span></span></span><span class="hljs-function">:</span></span> self.query = query self.connection = connection self.placeholders = placeholders self.replaces = {} sql = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: sql = self.query.query.sql_with_params() <span class="hljs-comment"><span class="hljs-comment"># 1.4 except AttributeError: sql = self.query.query.get_compiler(connection=self.connection).as_sql() # 1.3, lower? self.places = list(sql[1]) self.sql = sql[0] self.is_values = isinstance(query,ValuesQuerySet) self.cursor = None for i in xrange(len(self.places)): x = self.places[i] found = False for p in self.placeholders: v = self.placeholders[p] if x == v: found = True if not p in self.replaces: self.replaces[p] = [] self.replaces[p].append(i) if not found: raise AttributeError("The placeholder %(ph)s not found, please add some_name=%(ph)s to the list of constructor parameters" % { 'ph':repr(x) }) def execute(self,**kw): try: for k in kw: for i in self.replaces[k]: self.places[i] = kw[k] except KeyError,ex: raise TypeError("No such placeholder: %s" % k) if not self.cursor: self.cursor = self.connection.cursor() self.cursor.execute(self.sql,self.places) if not hasattr(self,'fldnms'): self.fldnms = [col[0] for col in self.cursor.description] if self.is_values: return [dict(zip(self.fldnms,row)) for row in self.cursor.fetchall()] return [self.query.model(**dict(zip(self.fldnms,row))) for row in self.cursor.fetchall()] def __call__(self,**kw): return self.execute(**kw) ParametrizedQuery = PQuery # compatibility issue</span></span></code> </pre><br>  UPD: 2012-08-06 19:20:00 MSK - amended the code for compatibility with multitrading, fixes minor bugs when performing complex queries and improving usability. <br><div class="spoiler">  <b class="spoiler_title">Previous code version</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> django.db <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> connection <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> django.db.models.query <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> QuerySet,ValuesQuerySet <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ParametrizedQuery</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self,query,connection=connection,**placeholders)</span></span></span><span class="hljs-function">:</span></span> self.query = query self.connection = connection self.placeholders = placeholders self.replaces = {} sql = self.query.query.sql_with_params() self.places = list(sql[<span class="hljs-number"><span class="hljs-number">1</span></span>]) self.sql = sql[<span class="hljs-number"><span class="hljs-number">0</span></span>] self.is_values = isinstance(query,ValuesQuerySet) self.cursor = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> p <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> self.placeholders: v = self.placeholders[p] self.replaces[p] = self.places.index(v) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">execute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self,**kw)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> k <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> kw: self.places[self.replaces[k]] = kw[k] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> self.cursor: self.cursor = self.connection.cursor() self.cursor.execute(self.sql,self.places) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> hasattr(self,<span class="hljs-string"><span class="hljs-string">'fldnms'</span></span>): self.fldnms = [col[<span class="hljs-number"><span class="hljs-number">0</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> col <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> self.cursor.description] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self.is_values: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [dict(zip(self.fldnms,row)) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> row <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> self.cursor.fetchall()] <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [self.query.model(**dict(zip(self.fldnms,row))) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> row <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> self.cursor.fetchall()]</code> </pre><br></div></div><br>  What does this class do?  It receives a request and extracts prepared SQL and parameters from it.  We can form such a request, in which each of the parameters that we are going to substitute, has a special value that we know in advance.  We will use these values ‚Äã‚Äãto search for the place where we want to substitute the values ‚Äã‚Äãpassed during execution. <br><br>  Several additional implementation details will also help us save resources. <br><ul><li>  The fldnms property contains an array of field names obtained when the query is first executed.  Subsequent calls will use the finished array. </li><li>  The replaces property contains a mapping of substitution names to parameter numbers. </li><li>  Each object of our class will hold its own cursor.  The potential acceleration from this step is a consequence of the first, the fact that creating a cursor is quite a costly operation, and secondly, the following phrase from the <a href="http://code.google.com/p/pyodbc/wiki/GettingStarted">description of pyodbc</a> , which can be used as a database backend: "It is also more efficient if you execute the same SQL repeatedly with different parameters.  The SQL will be prepared only once.  ("If you‚Äôve prepared multiple times. </li><li>  The is_values ‚Äã‚Äãproperty will help us determine that the query should not return a model object, which will save on the creation of such an object when returning results. </li></ul><br><br>  We will slightly modify the original request so that it is convenient to slip the substitutions there: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>q = Group.objects.filter(user__id=<span class="hljs-number"><span class="hljs-number">12345</span></span>).values(<span class="hljs-string"><span class="hljs-string">'name'</span></span>) &gt;&gt;&gt; q.query.sql_with_params() (<span class="hljs-string"><span class="hljs-string">'SELECT `auth_group`.`name` FROM `auth_group` INNER JOIN `auth_user_groups` ON (`auth_group`.`id` = `auth_user_groups`.`group_id`) WHERE `auth_user_groups`.`user_id` = %s '</span></span>, (<span class="hljs-number"><span class="hljs-number">12345</span></span>,))</code> </pre><br><br>  The value 12345 we use as a substitution: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>p = ParametrizedQuery(q,user_id=<span class="hljs-number"><span class="hljs-number">12345</span></span>) &gt;&gt;&gt; [g[<span class="hljs-string"><span class="hljs-string">'name'</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> g <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> p.execute(user_id=u.id)] [<span class="hljs-string"><span class="hljs-string">u'thetest'</span></span>]</code> </pre><br><br>  When executing the query p.execute (), the real value of the user ID was substituted for the 12345 substitution place. <br><br>  Now let's try to see how the code performance will change: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test3</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> datetime ... t1 = datetime.datetime.now() ... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> xrange(<span class="hljs-number"><span class="hljs-number">1000</span></span>): ... a = [g[<span class="hljs-string"><span class="hljs-string">'name'</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> g <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> p.execute(user_id=u.id)] ... t2 = datetime.datetime.now() ... <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">"%s"</span></span> % (t2 - t1) ... &gt;&gt;&gt; test3() <span class="hljs-number"><span class="hljs-number">0</span></span>:<span class="hljs-number"><span class="hljs-number">00</span></span>:<span class="hljs-number"><span class="hljs-number">00.217270</span></span></code> </pre><br>  This is the result!  <b>The request execution time has decreased by 7 times</b> . <br><br>  How to use it in real code? <br><br>  First, you need a place in which the prepared request could be stored.  Secondly, at some point you need to fill this variable.  For example, at the time of the first execution of the function code.  Well and thirdly, of course, we use a call to a parameterized query instead of directly executing the query. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">myview</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(request)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> hasattr(myview,<span class="hljs-string"><span class="hljs-string">'query'</span></span>): myview.query = ParametrizedQuery(Group.objects.filter(user__id=<span class="hljs-number"><span class="hljs-number">12345</span></span>).values(<span class="hljs-string"><span class="hljs-string">'name'</span></span>),user_id=<span class="hljs-number"><span class="hljs-number">12345</span></span>) a = [g[<span class="hljs-string"><span class="hljs-string">'name'</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> g <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> myview.query.execute(user_id=request.user.id)] ...</code> </pre><br><br>  All code was executed on: <br>  - django.VERSION = (1, 4, 0, 'final', 0) <br>  - mysql DBMS (django.db.backends.mysql) <br>  - table engine = MYISAM <br>  - connection through localhost <br>  - Python 2.7.2+ (default, Oct 4 2011, 20:03:08) [GCC 4.6.1] on linux2 <br>  - Linux host seva 3.0.0-22-generic # 36-Ubuntu SMP Tue Jun 12 17:13:04 UTC 2012 i686 athlon i386 GNU / Linux <br><br>  Specialist comments are welcome. </div><p>Source: <a href="https://habr.com/ru/post/149066/">https://habr.com/ru/post/149066/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../149059/index.html">Making Your Time Machine for Linux</a></li>
<li><a href="../149060/index.html">AngularJS - a framework for dynamic web applications from Google</a></li>
<li><a href="../149061/index.html">How to stop regularly repairing computers to neighbors and acquaintances of their friends, but do not pass for ignorance</a></li>
<li><a href="../149062/index.html">The idea of ‚Äã‚Äãorganizing a distributed network infrastructure of mixed type for the publication of electronic educational resources</a></li>
<li><a href="../149063/index.html">Custom jUnit processing of tests in TeamCity</a></li>
<li><a href="../149068/index.html">Siemens SGold: Hacking Through Java</a></li>
<li><a href="../149071/index.html">Create a game on SFML</a></li>
<li><a href="../149074/index.html">How it's made for programmers. Series number 2</a></li>
<li><a href="../149075/index.html">We type in LilyPond using midi-keyboard</a></li>
<li><a href="../149076/index.html">Parse the consequences of hacking MS-CHAPv2 for Wi-Fi (WPA / WPA2-Enterprise)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>