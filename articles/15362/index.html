<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Scaling basics</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="After reading this blog about client-side balancing , I decided to publish my article, which describes the basic principles of scaling for web-project...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Scaling basics</h1><div class="post__text post__text-html js-mediator-article">  <em>After reading this blog <a href="http://habrahabr.ru/blog/webdev/27327.html">about client-side balancing</a> , I decided to publish my article, which describes the basic principles of scaling for web-projects.</em>  <em>I hope it will be interesting for the habra people to read.</em> <br><br><h1>  Scaling basics </h1><br><br>  Scalability - the ability of a device to increase its <br>  opportunities <br>  by increasing the number of functional blocks, <br>  performing one and <br>  the same tasks. <br>  Glossary.ru 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Usually they start thinking about scaling when one <br>  The server does not cope with the work assigned to it.  What exactly is he not <br>  cope?  The work of any web server by and large comes down to the main <br>  computer occupation - data processing.  Response to HTTP (or any other) request <br>  implies some operations on certain data.  Respectively, <br>  we have two main entities - these are data (characterized by their volume) and <br>  calculations (characterized by complexity).  The server can not cope with its <br>  due to the large amount of data (they may not physically fit on <br>  server), or because of the large computational load.  It comes here, <br>  Of course, about the total load - the complexity of processing a single request can be <br>  It is small, but a large number of them can "fill up" the server. <br><br><a name="habracut"></a>  We will mainly talk about scaling by example <br>  typical growing web project, but the principles described here are also suitable for <br>  other applications.  First we look at the architecture of the project and the simple <br>  distributing its components to multiple servers, and then talk about <br>  scaling calculations and data. <br><br><h2>  Typical site architecture </h2><br><br>  The life of a typical site begins with a very simple architecture. <br>  - this is one web server (usually Apache is in its role), <br>  who does all the work on HTTP requests, <br>  coming from visitors.  He gives customers the so-called "static", then <br>  there are files that are on the server disk and do not require processing: pictures (gif, <br>  jpg, png), style sheets (css), client scripts (js, swf).  Same server <br>  responds to queries requiring computation - usually this formation <br>  html pages, though sometimes images and other documents are created on the fly. <br>  Most often the answers to such requests are generated by scripts written in php, <br>  perl or other languages. <br><br>  The disadvantage of such a simple scheme of work is that <br>  the nature of requests (return files from disk and computational work of scripts) <br>  processed by the same web server.  Computational queries require <br>  keep a lot of information in the server‚Äôs memory (script language interpreter, <br>  the scripts themselves, the data they work with) and can take a lot <br>  computing resources.  Issuing statics, on the contrary, requires few resources. <br>  processor, but may take a long time if the client has a low <br>  communication speed  The internal structure of the Apache server assumes that each <br>  connection is processed by a separate process.  This is convenient for scripting, <br>  however, it is not optimal for handling simple requests.  It turns out that heavy (from <br>  scripts and other data) Apache processes spend a lot of time waiting (first when receiving <br>  request, then when sending a response), wasting memory of the server. <br><br>  The solution to this problem is the distribution of the processing work. <br>  requests between two different programs - i.e.  division into frontend and <br>  backend.  The lightweight frontend server performs static stat and the rest <br>  requests redirects (proxies) to the backend where the formation is performed <br>  pages.  Waiting for slow clients also takes on the frontend, and if it uses <br>  multiplexing (when one process serves multiple clients - so <br>  work, for example, nginx or lighttpd), then waiting for almost nothing <br>  worth it. <br><br><br><br>  Of the other components of the site should be noted database <br>  which is usually stored the basic data of the system - the most popular here <br>  free MySQL and PostgreSQL DBMS.  Often separately allocated storage <br>  binary files that contain images (for example, illustrations to articles <br>  site, avatars and user photos) or other files. <br><br>  Thus, we obtained an architecture diagram consisting of <br>  several components. <br><br><img width="615" height="327" src="https://habrastorage.org/getpro/habr/post_images/46c/b2e/cae/46cb2ecaec2e7a48f9ae25adc7c5f9d2.gif"><br><br>  Usually at the beginning of the life of the site all components of the architecture <br>  are located on the same server.  If he stops coping with the load, then <br>  there is a simple solution - move the most easily detachable parts to another <br>  server.  The easiest place to start is from the database - transfer it to a separate server and <br>  change access details in scripts.  By the way, at this moment we are faced with <br>  the importance of proper software code architecture.  If working with a database <br>  rendered into a separate module common to the whole site - then correct the parameters <br>  connections will be easy. <br><br>  Ways of further separation of components are also understandable - for example, you can take the frontend to a separate server.  But usually frontend <br>  requires few system resources and at this stage the takeaway will not provide significant <br>  performance gains.  Most often, the site rests on performance <br>  Scripting - the formation of a response (html-page) takes too long. <br>  Therefore, the next step is usually scaling the backend server. <br><br><h2>  Calculation Distribution </h2><br><br>  A typical situation for a growing site - the database is already <br>  rendered to a separate machine, the division into frontend and backend is done, <br>  However, attendance continues to increase and the backend does not have time to process <br>  requests.  This means that we need to distribute the calculations to several <br>  servers.  Make it simple - just buy a second server and put it on <br>  it programs and scripts needed to work backend. <br>  After that, you need to make sure that user requests are distributed. <br>  (balanced) between the received servers.  About different methods of balancing <br>  it will be said below, but for the time being we note that this is usually done by the frontend <br>  which is configured so that it evenly distributes the requests between <br>  servers. <br><br>  It is important that all backend servers are capable <br>  respond to requests.  Usually this requires that each of them work with <br>  the same relevant data set.  If we store all information in a single <br>  database, the DBMS itself will provide shared access and consistency of data. <br>  If some data is stored locally on the server (for example, php-session <br>  client), it is worth thinking about transferring them to a shared storage, or more <br>  complex query distribution algorithm. <br><br>  Distribute across multiple servers can not only work <br>  scripts, but also calculations performed by the database.  If the DBMS performs a lot <br>  complex queries, taking up server CPU time, you can create several <br>  database copies on different servers.  This raises the issue of synchronization <br>  data with changes, and several approaches are applicable here. <br><br><ul><li>  Synchronization <b>at the application level</b> .  In this case, our <br>  scripts independently write changes to all copies of the database (and they themselves carry <br>  responsibility for the correctness of the data).  This is not the best option since it <br>  requires caution in implementation and is highly error-tolerant. <br></li><li>  <b>Replication</b> - that is, automatic replication <br>  changes made on one server to all other servers.  Usually when <br>  When using replication, changes are always recorded on the same server - it is called master, and the remaining copies are slave.  Most DBMS have <br>  Built-in or external replication tools.  Distinguish <br>  synchronous replication - in this case, a data change request will wait <br>  until the data is copied to all servers, and only then it is completed successfully - and asynchronous - in this case, the changes are copied to the slave-server from <br>  delay, but the write request completes faster. <br></li><li>  <b>Multi-master</b> replication.  This approach is similar <br>  previous, but here we can make changes to the data, referring not to <br>  to one specific server, and to any copy of the database.  With this change <br>  synchronously or asynchronously get on other copies.  Sometimes such a scheme is called <br>  the term "database cluster". <br></li></ul><br><br>  There are various options for the distribution of the system servers. <br>  For example, we may have one database server and several backend (quite <br>  typical scheme), or vice versa - one backend and several databases.  And if we scale <br>  and the backend server and database, you can combine the backend and a copy of the database <br>  one car.  In any case, as soon as we have a few copies. <br>  any server, the question arises how to distribute between them correctly <br>  load. <br><br><h2>  Balancing methods </h2><br><br>  Suppose we have created several servers (for any purpose - http, database, etc.), each of which can handle requests.  Before <br>  we have a task - how to distribute work among them, how to find out on which <br>  server to send a request?  There are two main ways to distribute requests. <br><br><ul><li> <b>Balancing node</b> .  In this case, the client sends a request for one <br>  fixed, known to him the server, and he already redirects the request to one of <br>  working servers.  A typical example is a site with one frontend and several <br>  backend servers to which requests are proxied.  However, the ‚Äúclient‚Äù may <br>  be inside our system - for example, the script can send a request to <br>  to the database proxy server, which forwards the request to one of the DBMS servers. <br>  The balancing node itself can work both on a separate server and on one <br>  from working servers. <br><br>  The advantages of this approach are <br>  that the client does not need to know anything about the internal structure of the system - about the number <br>  servers, their addresses and features - all this information knows only <br>  balancer.  However, the disadvantage is that the balancing node is one <br>  system failure point - if it fails, the whole system will be <br>  inoperable.  In addition, with a heavy load, the balancer can simply stop <br>  cope with their work, so this approach is not always applicable. <br></li><li>  <b>Client side balancing</b> .  If we want to avoid <br>  single point of failure, there is an alternative option - to instruct the choice of server <br>  to the client himself.  In this case, the client should know about the internal structure of our <br>  systems to be able to choose the right server to access. <br>  The undoubted advantage is the absence of a point of failure - if one of the <br>  server, the client will be able to contact others.  However, the price for this is <br>  increased client logic and less balancing flexibility. <br></li></ul><br><br><img width="291" height="267" src="https://habrastorage.org/getpro/habr/post_images/876/485/ac6/876485ac654c53f415af7f22fc222c2a.gif"><br><img width="291" height="267" src="https://habrastorage.org/getpro/habr/post_images/1b1/5f3/d4a/1b15f3d4adf6aab371f8ec4f147e53e0.gif"><br><br><br>  Of course, there are combinations of these approaches.  For example, <br>  A known load balancing method, such as DNS balancing, is based on <br>  that when determining the site‚Äôs IP address, a client is issued <br>  address of one of several identical servers.  Thus, the DNS appears in <br>  the role of the balancing node from which the client receives the ‚Äúdistribution‚Äù.  but <br>  the very structure of DNS servers implies the absence of a point of failure due to <br>  duplication - that is, the merits of the two approaches are combined.  Of course, this <br>  There are also disadvantages to the balancing method - for example, such a system is difficult to dynamically <br>  rebuild. <br><br>  Work with the site is usually not limited to one request. <br>  Therefore, when designing, it is important to understand whether sequential queries can <br>  client to be correctly processed by different servers, or the client must be <br>  tied to one server while working with the site.  This is especially important if <br>  The site stores temporary information about the user's session (in this <br>  free distribution is also possible in case of accident <br>  sessions in general for all servers storage).  "Bind" the visitor to <br>  specific server can be on its IP-address (which, however, may vary), <br>  or by cookie (in which the server identifier is pre-recorded), or even <br>  just redirecting it to the desired domain. <br><br>  On the other hand, computing servers may not be equal. <br>  In some cases it is beneficial to do the opposite, allocate a separate server for <br>  processing requests of one type - and get vertical separation <br>  functions.  Then the client or balancing node will choose the server in <br>  depending on the type of request received.  This approach allows you to separate <br>  important (or vice versa, not critical, but heavy) requests from the rest. <br><br><h2>  Data distribution </h2><br><br>  We learned how to distribute calculations, so a large <br>  attendance is not a problem for us.  However, data volumes continue to grow, <br>  it becomes more difficult to store and process them - which means it's time to build <br>  distributed data storage.  In this case, we will not have one or <br>  multiple servers containing a complete copy of the database.  Instead, the data <br>  will be distributed across different servers.  What are the possible distribution schemes? <br><br><ul><li>  <b>Vertical distribution</b> (vertical partitioning) - in the simplest case <br>  is the removal of separate database tables to another server.  With <br>  this we will need to change the scripts to access different servers for <br>  different data.  In the limit, we can store each table on a separate server. <br>  (although in practice it is unlikely to be profitable).  Obviously, with such <br>  distribution, we lose the ability to make SQL queries that combine data from <br>  two tables located on different servers.  If necessary, you can implement <br>  merge logic in an application, but it will not be as efficient as in a DBMS. <br>  Therefore, when splitting a database, you need to analyze the relationships between the tables, <br>  to spread as independent tables as possible. <br><br>  More difficult case <br>  the vertical distribution of the base is the decomposition of a single table, when part of <br>  its columns are on one server, and some - on the other.  Such reception <br>  is less common, but it can be used, for example, to separate small <br>  and frequently updated data from a large amount of rarely used. <br></li><li>  <b>Horizontal distribution</b> (horizontal partitioning) - is <br>  distribution of data from one table across multiple servers.  In fact on <br>  each server creates a table of the same structure, and stores in it <br>  a certain piece of data.  You can distribute data across servers <br>  criteria: by range (records with id &lt;100000 go to server A, the rest - to server B), according to the list of values ‚Äã‚Äã(records of the type ‚ÄúZAO‚Äù and ‚ÄúOJSC‚Äù are saved to the server <br>  A, the rest - to server B) or by the value of a hash function from some field <br>  records  Horizontal data partitioning allows you to store unlimited <br>  the number of records, however, complicates the selection.  Most effectively you can choose <br>  records only when it is known on which server they are stored. <br></li></ul><br><br>  To select the correct data distribution scheme <br>  carefully analyze the structure of the base.  Existing tables (and possibly <br>  individual fields) can be classified by frequency of access to records, by frequency <br>  updates and interrelationships (the need to take samples from several <br>  tables). <br><br><br><br>  As mentioned above, besides a database, a site is often required <br>  storage for binary files.  Distributed File Storage Systems <br>  (in fact, file systems) can be divided into two classes. <br><br><ul><li>  Operating <b>at the operating system level</b> .  At the same time for <br>  applications work with files in such a system is no different from the usual work with <br>  files.  The exchange of information between the servers takes over the operating system. <br>  Examples of such file systems include the long-known <br>  NFS family or less well-known, but more modern Luster system. <br></li><li>  Implemented <b>at the application level</b> distributed <br>  the repositories imply that the work on information exchange is done by <br>  attachment.  Usually the functions of working with the storage for convenience are made in <br>  separate library.  One of the clearest examples of such a repository is MogileFS, developed by <br>  creators of LiveJournal.  Another common example is the use of <br>  WebDAV protocol and its supporting repository. <br></li></ul><br><br>  It should be noted that the distribution of data decides not only <br>  the issue of storage, but also partly the issue of load distribution - at each <br>  server gets fewer records, and therefore they are processed faster. <br>  The combination of methods for distributing calculations and data allows you to build <br>  potentially unlimitedly scalable architecture capable of working with <br>  any amount of data and any load. <br><br><h2>  findings </h2><br><br>  Summarizing the above, we formulate the conclusions in the form of brief theses. <br><br><ul><li>  The two main (and related) tasks of scaling are distribution of calculations and distribution of data. <br></li><li>  Typical site architecture implies separation of roles and <br>  includes frontend, backend, database and sometimes file storage <br></li><li>  With small amounts of data and heavy loads apply <br>  database mirroring - synchronous or asynchronous replication <br></li><li>  When large amounts of data is necessary to distribute the database - split <br>  her vertically or horizontally <br></li><li>  Binary files are stored in distributed file systems. <br>  (implemented at the OS level or in the application) <br></li><li>  Balancing (distribution of requests) can be uniform or <br>  with separation by functionality;  with balancing node or on client side <br></li><li>  The correct combination of methods will allow to keep any load;) <br></li></ul><br><br><h2>  Links </h2><br><br>  You can continue to study this topic on interesting English-speaking sites and blogs: <br><br><ul><li>  <a href="http://www.highscalability.com/">http://www.highscalability.com/</a> </li><li>  <a href="http://www.royans.net/arch/">http://www.royans.net/arch/</a> </li><li>  <a href="http://poorbuthappy.com/ease/archives/2007/04/29/3616/the-top-10-presentation-on-scaling-websites-twitter-flickr-bloglines-vox-and-more">http://poorbuthappy.com/ease/‚Ä¶ -bloglines-vox-and-more</a> </li><li>  <a href="http://www.possibility.com/epowiki/Wiki.jsp%3Fpage%3DScalability">http://www.possibility.com/epowiki/Wiki.jsp?page=Scalability</a> </li></ul><br><br><br><br>  <em>PS Comments, of course, are welcome <strong>;)</strong></em> </div><p>Source: <a href="https://habr.com/ru/post/15362/">https://habr.com/ru/post/15362/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../153611/index.html">Raspberry Pi. Video transmission for remote control</a></li>
<li><a href="../153613/index.html">Seven more HTML5 features you might not know about</a></li>
<li><a href="../153615/index.html">Nokia Plan B (take 2)?</a></li>
<li><a href="../153617/index.html">Optical character recognition in Linux</a></li>
<li><a href="../153619/index.html">MiniSCADA do it yourself</a></li>
<li><a href="../153625/index.html">Configuring Cisco ACS 5.3 in conjunction with Active Directory</a></li>
<li><a href="../15363/index.html">"Googled": Corey Doctorow on the all-pervading Google</a></li>
<li><a href="../153631/index.html">How is the short-term forecast for Yandex.Probka</a></li>
<li><a href="../153633/index.html">About how I got Java from PDF Flash</a></li>
<li><a href="../153635/index.html">How do you most often read technical literature?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>