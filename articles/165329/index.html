<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Getting rid of duplicate end-to-end code in PHP: code refactoring with AOP</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I think every programmer is familiar with the principle of sole responsibility,  it is not for nothing that it exists: by observing it, you can write ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Getting rid of duplicate end-to-end code in PHP: code refactoring with AOP</h1><div class="post__text post__text-html js-mediator-article">  I think every programmer is familiar with the principle of sole responsibility, <img src="https://habrastorage.org/storage2/0a2/16c/046/0a216c046a422ada0e6f2bc96b07e93c.jpg" align="right">  it is not for nothing that it exists: by observing it, you can write code better, it will be more understandable, it will be easier to refine it. <br><br>  But the more each of us works with the code, the more comes the understanding that this is impossible at the existing level of the language - object-oriented.  And we are hampered by the fact that end-to-end functionality prevents us from observing the principle of sole responsibility. <br><br>  This article is about how to get rid of duplicate end-to-end code, and how to make it a little better with AOP. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <a name="habracut"></a><br><br><h3>  End-to-end functionality or wet code </h3><br>  With a probability of about 95%, in any application, you can find pieces of <a href="http://en.wikipedia.org/wiki/Cross-cutting_concern">end-to-end functionality</a> that are hidden in the code under the guise of caching, logging, exception handling, transactional control, and access rights.  As you already guessed from the name, this functionality lives on all layers of the application (do you have layers?) And forces us to violate several important principles: <a href="http://ru.wikipedia.org/wiki/Don%25E2%2580%2599t_repeat_yourself" title="Do not Repeat Yourself">DRY</a> and <a href="http://ru.wikipedia.org/wiki/KISS_(%25D0%25BF%25D1%2580%25D0%25B8%25D0%25BD%25D1%2586%25D0%25B8%25D0%25BF)" title="Keep It Simple, Stupid">KISS</a> .  Violating the DRY principle, you automatically begin to use the <abbr title="Write Everything Twice">WET</abbr> principle and the code becomes ‚Äúwet‚Äù, which is reflected in the form of an increase in metrics Lines of Code (LOC), <a href="http://pdepend.org/documentation/software-metrics/weighted-method-count.html">Weighted Method Count</a> (WMC), <a href="http://pdepend.org/documentation/software-metrics/cyclomatic-complexity.html">Cyclomatic Complexity</a> (CCN). <br><br>  Let's see how this happens in real life.  A technical task comes, a system is designed for it, a decomposition into classes is carried out and the necessary methods are described.  At this stage, the system is perfect, the purpose of each class and service is clear, everything is simple and logical.  And then the end-to-end functionality begins to dictate its own rules and forces the programmer to make edits to the code of <u>all</u> classes, since it is not possible in OOP to decompose through the end-to-end functionality.  This process goes unnoticed, because everyone is accustomed to it as a normal phenomenon, and no one is trying to fix anything.  The process proceeds according to the standard scheme worked over the years. <br><br>  First, the logic of the method itself is written, which contains the necessary and sufficient implementation: <br><br><pre><code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">/** * Creates a new user * * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> string $newUsername Name for a new user */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createNewUser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($newUsername)</span></span></span><span class="hljs-function"> </span></span>{ $user = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> User(); $user-&gt;setName($newUsername); <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;entityManager-&gt;persist($user); <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;entityManager-&gt;flush(); }</code> </pre> <br><br>  ... after that we add 3 more lines of code for checking access rights <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">/** ... */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createNewUser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($newUsername)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;security-&gt;isGranted(<span class="hljs-string"><span class="hljs-string">'ROLE_ADMIN'</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AccessDeniedException(); } $user = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> User(); $user-&gt;setName($newUsername); <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;entityManager-&gt;persist($user); <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;entityManager-&gt;flush(); }</code> </pre><br><br>  ... then another 2 lines for logging the beginning and end of the method <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">/** ... */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createNewUser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($newUsername)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;security-&gt;isGranted(<span class="hljs-string"><span class="hljs-string">'ROLE_ADMIN'</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AccessDeniedException(); } <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;logger-&gt;info(<span class="hljs-string"><span class="hljs-string">"Creating a new user {$newUsername}"</span></span>); $user = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> User(); $user-&gt;setName($newUsername); <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;entityManager-&gt;persist($user); <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;entityManager-&gt;flush(); <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;logger-&gt;info(<span class="hljs-string"><span class="hljs-string">"User {$newUsername} was created"</span></span>); }</code> </pre><br><br>  Do you recognize your code?  Not yet?  Then let's add 5 more lines to handle a possible exception with several different handlers.  In the methods that return data, 5 more lines may be added to save the result in the cache.  Thus, from 4 lines of code that really have value, you can get about 20 lines of code.  Than it threatens, I think it is clear - the method becomes more difficult, it is harder to read, it takes longer to understand what it actually does, it is more difficult to test, because you have to slip mocks for the logger, cache, etc.  Since the example was for one of the methods, it is logical to assume that the statements regarding the size of the method are valid both for the class and for the system as a whole.  The older the system code, the more it acquires such garbage and it becomes harder to keep track of it. <br><br>  Let's look at existing solutions to end-to-end functionality problems. <br><br><h3>  Clean - the guarantee of health!  Health first! </h3><br>  I recommend reading the heading in the context of application development like this: ‚ÄúClean code is the key to the health of the application!  Health applications first! ‚Äù.  It would be nice to hang such a label in front of each developer to always remember this :) <br><br>  So, we decided to keep the code clean by all means.  What solutions do we have and what can we use? <br><br><h4>  Decorators </h4><br>  Decorators - the first thing that comes to mind.  <a href="http://ru.wikipedia.org/wiki/%25D0%2594%25D0%25B5%25D0%25BA%25D0%25BE%25D1%2580%25D0%25B0%25D1%2582%25D0%25BE%25D1%2580_(%25D1%2588%25D0%25B0%25D0%25B1%25D0%25BB%25D0%25BE%25D0%25BD_%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B5%25D0%25BA%25D1%2582%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D1%258F)">Decorator</a> is a structural design pattern intended to dynamically connect additional behavior to an object.  The Decorator pattern provides a flexible alternative to the practice of creating subclasses to extend functionality. <br><br>  When it comes to <a href="http://ru.wikipedia.org/wiki/%25D0%2590%25D1%2581%25D0%25BF%25D0%25B5%25D0%25BA%25D1%2582%25D0%25BD%25D0%25BE-%25D0%25BE%25D1%2580%25D0%25B8%25D0%25B5%25D0%25BD%25D1%2582%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25BD%25D0%25BE%25D0%25B5_%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B3%25D1%2580%25D0%25B0%25D0%25BC%25D0%25BC%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5" title="Aspect Oriented Programming">AOP</a> , the first question that OOP programmers usually ask is - why not use a regular decorator?  And it is right!  Because the decorator can do almost everything that is done with the help of AOP, but ... Counter-example: what if we make a LoggingDecorator on top of CachingDecorator, and the latter, in turn, on top of the main class?  How many of the same type code will be in these decorators?  How many different classes of decorators will be in the whole system? <br><br>  It is easy to estimate that if we have 100 classes that implement 100 interfaces, then adding caching decorators will add 100 more classes to our system.  Of course, this is not a problem in the modern world (look in the cache folder of any large framework), but why do we need these 100 classes of the same type?  Not clear, agree? <br><br>  Nevertheless, the moderate use of decorators is fully justified. <br><br><h4>  Proxy classes </h4><br>  Proxy classes - the second thing that comes to mind.  <a href="http://ru.wikipedia.org/wiki/Proxy_(%25D1%2588%25D0%25B0%25D0%25B1%25D0%25BB%25D0%25BE%25D0%25BD_%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B5%25D0%25BA%25D1%2582%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D1%258F)">Proxy</a> - a design pattern that provides an object that controls access to another object, intercepting all calls (performs the function of a container). <br><br>  Not a good solution from my point of view, but all developers have a lot of caching proxies, so they can be found in applications so often.  The main disadvantages are: a drop in the speed of work (__call, __get, __callStatic, call_user_func_array is often used), and typhingting also breaks because a proxy object comes in instead of a real object.  If you try to wrap a caching proxy on top of the logging proxy, which in turn is on top of the main class, the speed will drop by an order of magnitude. <br><br>  But there is a plus: in the case of 100 classes, we can write one caching proxy to all classes.  But!  At the cost of abandoning of typhinting over 100 interfaces, which is totally unacceptable when developing modern applications. <br><br><h4>  Events and the Observer Pattern </h4><br>  It is hard not to recall such a wonderful pattern as the Observer.  <a href="http://ru.wikipedia.org/wiki/%25D0%259D%25D0%25B0%25D0%25B1%25D0%25BB%25D1%258E%25D0%25B4%25D0%25B0%25D1%2582%25D0%25B5%25D0%25BB%25D1%258C_(%25D0%25BC%25D0%25BE%25D0%25B4%25D0%25B5%25D0%25BB%25D1%258C)">Observer</a> is a behavioral design pattern.  Also known as ‚Äúsubordinates‚Äù (Dependents), ‚ÄúPublisher-Subscriber‚Äù (Publisher-Subscriber). <br><br>  In many well-known frameworks, developers are faced with end-to-end functionality and the need to extend the logic of some method over time.  Many ideas were tried out, and one of the most successful and understandable was the model of events and subscribers to these events.  By adding or removing event subscribers, we can expand the logic of the main method, and changing their order with the help of priorities, we can execute the logic of the handlers in the necessary order.  Very nice, almost AOP! <br><br>  It should be noted that this is the most flexible template, because on its basis you can design a system that will be expanded very easily and will be understandable.  If it were not for AOP, it would be the best way to extend the logic of the methods without changing the source code.  Not surprisingly, many frameworks use events to extend functionality, such as ZF2, Symfony2.  The Symfony2 website has a <a href="http://symfony.com/doc/master/cookbook/event_dispatcher/class_extension.html">great article</a> on how you can extend the logic of a method without using inheritance. <br><br>  Nevertheless, despite all the advantages, there are several big drawbacks, which sometimes outweigh the advantages.  The first minus is that you need to know in advance what and where can be expanded in your system.  Unfortunately, it is often unknown.  The second disadvantage is that it is necessary to write code in a special way, adding template lines for generating an event and processing it (an example from Symfony2): <br><br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... public function __call($method, $arguments) { // create an event named 'foo.method_is_not_found' $event = new HandleUndefinedMethodEvent($this, $method, $arguments); $this-&gt;dispatcher-&gt;dispatch('foo.method_is_not_found', $event); // no listener was able to process the event? The method does not exist if (!$event-&gt;isProcessed()) { throw new \Exception(sprintf('Call to undefined method %s::%s.', get_class($this), $method)); } // return the listener returned value return $event-&gt;getReturnValue(); } }</span></span></code> </pre><br><br><h4>  Signals and Slots </h4><br>  This <a href="http://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25B8%25D0%25B3%25D0%25BD%25D0%25B0%25D0%25BB%25D1%258B_%25D0%25B8_%25D1%2581%25D0%25BB%25D0%25BE%25D1%2582%25D1%258B">pattern</a> , in its essence, is an implementation of the Observer pattern, but reduces the number of duplicate code. <br><br>  Of the most interesting implementations of this pattern, I would point out the core of the Lithium framework, the study of which can give a lot of new, even to advanced developers.  In short, Lithium allows you to hang up callback filter functions on any important methods in the system and perform additional processing.  Would you like to write a log of database requests to a file in debug mode - there is nothing easier: <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">lithium</span></span>\<span class="hljs-title"><span class="hljs-title">analysis</span></span>\<span class="hljs-title"><span class="hljs-title">Logger</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">lithium</span></span>\<span class="hljs-title"><span class="hljs-title">data</span></span>\<span class="hljs-title"><span class="hljs-title">Connections</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Set up the logger configuration to use the file adapter. Logger::config(array( 'default' =&gt; array('adapter' =&gt; 'File') )); // Filter the database adapter returned from the Connections object. Connections::get('default')-&gt;applyFilter('_execute', function($self, $params, $chain) { // Hand the SQL in the params headed to _execute() to the logger: Logger::debug(date("DM j G:i:s") . " " . $params['sql']); // Always make sure to keep the filter chain going. return $chain-&gt;next($self, $params, $chain); });</span></span></code> </pre><br><br>  I strongly recommend that you familiarize yourself with <a href="">the filter system</a> , because the implementation of filters in Lithium brings development as close as possible to aspect-oriented programming and can be the impetus for you to plunge into the world of AOP finally. <br><br><h4>  Aspect-oriented programming </h4><br>  So, we come to the most interesting - to use aspect-oriented programming to combat duplicate end-to-end code.  On Habr√© there were already articles on <a href="http://habrahabr.ru/search/%3Fq%3Daop">AOP</a> , including for <a href="http://habrahabr.ru/search/%3Fq%3Daop%2Bphp">PHP</a> , so I will not repeat this material and give definitions of those terms and those techniques that AOP uses.  If you are not familiar with the terms and concepts of AOP, then before further reading you can read the article about <a href="http://ru.wikipedia.org/wiki/%25D0%2590%25D1%2581%25D0%25BF%25D0%25B5%25D0%25BA%25D1%2582%25D0%25BD%25D0%25BE-%25D0%25BE%25D1%2580%25D0%25B8%25D0%25B5%25D0%25BD%25D1%2582%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25BD%25D0%25BE%25D0%25B5_%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B3%25D1%2580%25D0%25B0%25D0%25BC%25D0%25BC%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5" title="Aspect-oriented programming">AOP</a> on Wikipedia. <br><br>  So, the filters in Lithium allow you to connect additional handlers almost anywhere, which makes it possible to put the caching code, logging, access rights checks into individual closures.  It would seem, here it is, a silver bullet.  But all is not so smooth.  First, to use filters, we need to connect the entire framework, since there is no separate library for this, which is a pity.  Secondly, filter closures (in terms of AOP - tips) are scattered everywhere and it is very difficult to follow them.  Third, the code must be written in a certain way and implement special interfaces so that filters can be used.  These three minuses significantly limit the ability to use filters as AOP in other applications and frameworks. <br><br>  This is where I got the idea to write a library that would allow using AOP in any PHP application.  Next was the battle with PHP, the study of code acceleration techniques, the fight against the opcode accelerator bugs, and many, many interesting things.  As a result, the Go! Library was born.  PHP AOP, which can be embedded in an existing application, intercepts the available methods in all classes and extract the cross-cutting functionality from them to several thousand lines of code in a couple of dozen lines of advice. <br><br><h3>  Go Library  PHP AOP </h3><br>  The main differences from all existing analogues is a library that does not require any PHP extensions, does not call for help black magic runkit-a and php-aop.  It does not use evals, is not tied to a DI container, does not need a separate aspect compiler in the final code.  Aspects are ordinary classes that seamlessly use all the features of the PLO.  The code generated by the library with interwoven aspects is very clean, it can be easily debugged with XDebug, both the classes themselves and the aspects. <br><br>  The most valuable thing in this library is that theoretically it can be connected to any application, because to add new functionality with the help of AOP you do not need to change the application code at all, the aspects are woven dynamically.  For example: using ten to twenty lines of code, you can intercept all public, protected and static methods in all classes when starting a standard ZF2 application and display the name of this method and its parameters when the method is called on the screen. <br><br>  The issue of working with opcode-chesherem is worked out - in combat mode, the interweaving of aspects occurs only once, after which the code gets from the opcode-cacher.  Doctrine annotations are used for aspect classes.  In general, a lot of interesting things inside. <br><br><h4>  End-to-end refactoring using AOP </h4><br>  To spark interest in AOP more, I decided to choose an interesting topic about which you can find little information - refactoring code to aspects.  Next, there will be two examples of how you can make your code cleaner and clearer using aspects. <br><br><h5>  We take out logging from code </h5><br>  So, let's imagine that we have logging of all executed public methods in 20 classes that are in the Acme namespace.  It looks something like this: <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">Acme</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Controller</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">updateData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($arg1, $arg2)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;logger-&gt;info(<span class="hljs-string"><span class="hljs-string">"Executing method "</span></span> . <span class="hljs-keyword"><span class="hljs-keyword">__METHOD__</span></span>, func_get_args()); <span class="hljs-comment"><span class="hljs-comment">// ... } }</span></span></code> </pre><br><br>  Let's take and refactor this code using aspects!  It is easy to see that logging is performed <u>before the</u> code of the method itself, so we immediately select the type of advice - Before.  Next we need to determine the point of implementation - the implementation of all public methods inside the Acme namespace.  This rule is given by the expression execution (public Acme \ * -&gt; * ()).  So, we write LoggingAspect: <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">Go</span></span>\<span class="hljs-title"><span class="hljs-title">Aop</span></span>\<span class="hljs-title"><span class="hljs-title">Aspect</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">Go</span></span>\<span class="hljs-title"><span class="hljs-title">Aop</span></span>\<span class="hljs-title"><span class="hljs-title">Intercept</span></span>\<span class="hljs-title"><span class="hljs-title">MethodInvocation</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">Go</span></span>\<span class="hljs-title"><span class="hljs-title">Lang</span></span>\<span class="hljs-title"><span class="hljs-title">Annotation</span></span>\<span class="hljs-title"><span class="hljs-title">Before</span></span>; <span class="hljs-comment"><span class="hljs-comment">/** * Logging aspect */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LoggingAspect</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Aspect</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/** </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@var</span></span></span><span class="hljs-comment"> null|LoggerInterface */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> $logger = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-comment"><span class="hljs-comment">/** ... */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__construct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($logger)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;logger = $logger; } <span class="hljs-comment"><span class="hljs-comment">/** * Method that should be called before real method * * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> MethodInvocation $invocation Invocation * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@Before</span></span></span><span class="hljs-comment">("execution(public Acme\*-&gt;*())") */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">beforeMethodExecution</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(MethodInvocation $invocation)</span></span></span><span class="hljs-function"> </span></span>{ $obj = $invocation-&gt;getThis(); $class = is_object($obj) ? get_class($obj) : $obj; $type = $invocation-&gt;getMethod()-&gt;isStatic() ? <span class="hljs-string"><span class="hljs-string">'::'</span></span> : <span class="hljs-string"><span class="hljs-string">'-&gt;'</span></span>; $name = $invocation-&gt;getMethod()-&gt;getName(); $method = $class . $type . $name; <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;logger-&gt;info(<span class="hljs-string"><span class="hljs-string">"Executing method "</span></span> . $method, $invocation-&gt;getArguments()); } }</code> </pre><br><br>  Nothing complicated, normal class with a seemingly normal method.  However, this is an aspect that determines the advice beforeMethodExecution, which will be called before calling the methods we need.  As you have already noticed, go!  uses annotations to store metadata, which has long been common practice, as it is visual and convenient.  Now we can register our aspect in the Go kernel!  and throw out of the heap of our classes all logging!  By removing unnecessary dependency on the logger, we made our code of classes cleaner, he began to more respect the principle of common responsibility, because we learned from it what he should not do. <br><br>  Moreover, now we can easily change the logging format, because now it is set in one place. <br><br><h5>  Transparent caching </h5><br>  I think everyone knows the sample code of the method using caching: <br><br><pre> <code class="php hljs"> <span class="hljs-comment"><span class="hljs-comment">/** ... */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cachedMethod</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ $key = <span class="hljs-keyword"><span class="hljs-keyword">__METHOD__</span></span>; $result = <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;cache-&gt;get($key, $success); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!$success) { $result = <span class="hljs-comment"><span class="hljs-comment">// ... $this-&gt;cache-&gt;set($key, $result); } return $result; }</span></span></code> </pre><br><br>  Undoubtedly, everyone will recognize this template code, since there are always plenty of such places.  If we have a large system, then there can be a lot of such methods, so that they can be cached.  And what an idea!  Let's annotate the methods that need to be cached, and in the point we set the condition - all methods marked with a specific annotation.  Since caching wraps the method code, we also need the right type of advice ‚Äî Around, the most powerful.  This type of board itself decides whether to execute the source code of the method.  And then everything is simple: <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">Go</span></span>\<span class="hljs-title"><span class="hljs-title">Aop</span></span>\<span class="hljs-title"><span class="hljs-title">Aspect</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">Go</span></span>\<span class="hljs-title"><span class="hljs-title">Aop</span></span>\<span class="hljs-title"><span class="hljs-title">Intercept</span></span>\<span class="hljs-title"><span class="hljs-title">MethodInvocation</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">Go</span></span>\<span class="hljs-title"><span class="hljs-title">Lang</span></span>\<span class="hljs-title"><span class="hljs-title">Annotation</span></span>\<span class="hljs-title"><span class="hljs-title">Around</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CachingAspect</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Aspect</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/** * Cache logic * * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> MethodInvocation $invocation Invocation * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@Around</span></span></span><span class="hljs-comment">("</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@annotation</span></span></span><span class="hljs-comment">(Annotation\Cacheable)") */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">aroundCacheable</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(MethodInvocation $invocation)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> $memoryCache = <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>(); $obj = $invocation-&gt;getThis(); $class = is_object($obj) ? get_class($obj) : $obj; $key = $class . <span class="hljs-string"><span class="hljs-string">':'</span></span> . $invocation-&gt;getMethod()-&gt;name; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!<span class="hljs-keyword"><span class="hljs-keyword">isset</span></span>($memoryCache[$key])) { $memoryCache[$key] = $invocation-&gt;proceed(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $memoryCache[$key]; } }</code> </pre><br><br>  In this advice, the most interesting thing is to call the original method, which is done by calling proceed () on the MethodInvocation object containing information about the current method.  It is easy to see that if we have data in the cache, then we do not make a call to the original method.  At the same time, your code does not change in any way! <br>  Having this aspect, we can annotate Annotation \ Cacheable before any method and this method will be cached thanks to AOP automatically.  We go through all the methods and cut out the caching logic, replacing it with the annotation.  Now the template code of the method using caching looks simple and elegant: <br><br><pre> <code class="php hljs"> <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@Cacheable</span></span></span><span class="hljs-comment"> */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cachedMethod</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ $result = <span class="hljs-comment"><span class="hljs-comment">// ... return $result; }</span></span></code> </pre><br><br>  This example can also be found inside the Go! Demos folder of the Go! Library.  PHP AOP, and also look at the <a href="https://github.com/lisachenko/go-aop-php/commit/75cc05ea0472100b102e590170aed85c14cefd4b">commit</a> that implements the above in action. <br><br><h3>  Conclusion </h3><br>  Aspect-oriented programming is a fairly new paradigm for PHP, but it has a great future.  The development of metaprogramming, the writing of Enterprise frameworks in PHP - all this follows the footsteps of Java, and AOP in Java has been living for a very long time, so you need to prepare for AOP now. <br><br>  Go!  PHP AOP is one of the few libraries that works with AOP and in some cases it compares favorably with its counterparts - the ability to intercept static methods, methods in final classes, access to object properties, the ability to debug source code and aspect code.  Go!  uses a lot of techniques to ensure high speed: compilation instead of interpretation, lack of slow techniques, optimized execution code, the ability to use opcode-cacher - all this contributes to the common cause.  One of the amazing discoveries was that Go!  in some similar conditions, PHP-AOP can work faster than C-extension.  Yes, yes, this is true, which has a simple explanation - extension interferes with the work of all methods in PHP in runtime and makes small checks for matching the item, the more such checks, the slower the call to each method, whereas Go!  does it once when compiling class code without affecting the speed of the methods in runtime. <br><br>  If you have questions and suggestions about the library, I will be happy to discuss them with you.  I hope, my first article on Habr√© was useful to you. <br><br><h5>  Links </h5><br><ol><li>  Source code <a href="https://github.com/lisachenko/go-aop-php">https://github.com/lisachenko/go-aop-php</a> </li><li>  SymfonyCampUA-2012 presentation <a href="http://www.slideshare.net/lisachenko/php-go-aop">http://www.slideshare.net/lisachenko/php-go-aop</a> </li><li>  SymfonyCampUA-2012 Video <a href="http://www.youtube.com/watch%3Fv%3DZXbREKT5GWE">http://www.youtube.com/watch?v=ZXbREKT5GWE</a> </li><li>  An example of intercepting all methods in ZF2 (after cloning we install dependencies via composer) <a href="https://github.com/lisachenko/zf2-aspect">https://github.com/lisachenko/zf2-aspect</a> </li><li>  An interesting article on the topic: <a href="http://www.mwop.net/blog/251-Aspects,-Filters,-and-Signals,-Oh,-My!.html">Aspects, filters and signals - oh, my God!</a>  <a href="http://www.mwop.net/blog/251-Aspects,-Filters,-and-Signals,-Oh,-My!.html">(en)</a> </li></ol></div><p>Source: <a href="https://habr.com/ru/post/165329/">https://habr.com/ru/post/165329/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../165319/index.html">The first certified Android prefix for downloading torrents</a></li>
<li><a href="../165321/index.html">For holivaru about managers - about the results and products</a></li>
<li><a href="../165323/index.html">We are driving a car with 2GIS</a></li>
<li><a href="../165325/index.html">DVD-RX fighting protection</a></li>
<li><a href="../165327/index.html">ORM or object-relational projector</a></li>
<li><a href="../165337/index.html">Visualization of computer usage statistics with R</a></li>
<li><a href="../165339/index.html">Zero-day vulnerability in Firefox 18 and Opera 12.12</a></li>
<li><a href="../165341/index.html">Samsung Galaxy Nexus with Ubuntu Phone OS is shown at CES 2013</a></li>
<li><a href="../165343/index.html">Run arbitrary code in Rails</a></li>
<li><a href="../165345/index.html">How valuable is your time? YouTrack and Pomodoro will help you find out.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>