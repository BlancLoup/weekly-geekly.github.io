<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Golang: specific performance issues</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The Go language is gaining popularity. So confident that there are more and more conferences, for example, GolangConf , and the language is among the ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Golang: specific performance issues</h1><div class="post__text post__text-html js-mediator-article">  The Go language is gaining popularity.  So confident that there are more and more conferences, for example, <a href="https://golangconf.ru/2019">GolangConf</a> , and the language <a href="https://proglib.io/p/stack-overflow-2018/">is among the ten</a> most highly paid technologies.  Therefore, it already makes sense to talk about its specific problems, for example, performance.  In addition to common problems for all compiled languages, Go has its own.  They are associated with the optimizer, the stack, the type system and the multitasking model.  Ways to solve them and workarounds are sometimes very specific. <br><br>  <strong>Daniel Podolsky</strong> , although the evangelist of Go, also encounters a lot of strange things in him.  Everything strange and, most importantly, interesting, collects and <a href="https://github.com/Djarvur/go-perf-test">tests</a> , and then talks about it in HighLoad ++.  The transcript of the report will include numbers, graphs, code examples, profiler results, a comparison of the performance of the same algorithms in different languages ‚Äã‚Äã- and everything else, for which we so hate the word ‚Äúoptimization‚Äù.  There will be no revelations in the transcript - where did they come from in such a simple language - and everything that can be read about in the newspapers. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/8UESXMJwTpc" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><a name="habracut"></a><br>  <strong>About the speakers.</strong>  <b>Daniil Podolsky</b> : 26 years of experience, 20 in operation, including the leader of the group, 5 years of programming on Go.  <b>Kirill Danshin</b> : creator of Gramework, Maintainer, Fast HTTP, Black Go-mage. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <em>The report was jointly prepared by Daniil Podolsky and Kirill Danshin, but Daniel made a report, and Cyril helped mentally.</em> <br><br><h2>  Language constructions </h2><br>  We have a performance standard - <code>direct</code> .  This is a function that increments a variable and no longer does anything. <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">//   var testInt64 int64 func BenchmarkDirect(b *testing.B) { for i := 0; i &lt; bN; i++ { incDirect() } } func incDirect() { testInt64++ }</span></span></code> </pre> <br>  The result of the function is <b>1.46 ns per operation</b> .  This is the minimum option.  Faster than 1.5 ns per operation, probably will not work. <br><br><h3>  Defer how we love him </h3><br>  Many know and love to use the defer language construct.  Quite often we use it like this. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BenchmarkDefer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b *testing.B)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; bN; i++ { incDefer() } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">incDefer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> incDirect() }</code> </pre> <br>  But you can‚Äôt use it like that!  Each defer eats 40 ns per operation. <br><br><pre> <code class="plaintext hljs">//   BenchmarkDirect-4 2000000000 1.46 / // defer BenchmarkDefer-4 30000000 40.70 /</code> </pre> <br>  I thought maybe this is due to inline?  Maybe inline is so fast? <br><br>  Direct inlines, and the defer function cannot inline.  Therefore, compiled a separate test function without inline. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BenchmarkDirectNoInline</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b *testing.B)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; bN; i++ { incDirectNoInline() } } <span class="hljs-comment"><span class="hljs-comment">//go:noinline func incDirectNoInline() { testInt64++ }</span></span></code> </pre> <br>  Nothing has changed, defer took the same 40 ns.  Defer dear, but not catastrophic. <br><br><blockquote>  Where a function takes less than 100 ns, you can do without defer. </blockquote><br>  But where the function takes more than a microsecond, it is all the same - you can use defer. <br><br><h3>  Passing a parameter by reference </h3><br>  Consider a popular myth. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BenchmarkDirectByPointer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b *testing.B)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; bN; i++ { incDirectByPointer(&amp;testInt64) } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">incDirectByPointer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int64</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { *n++ }</code> </pre> <br>  Nothing has changed - nothing is worth it. <br><br><pre> <code class="plaintext hljs">//     BenchmarkDirectByPointer-4 2000000000 1.47 / BenchmarkDeferByPointer-4 30000000 43.90 /</code> </pre> <br>  Except for 3 ns per defer, but this is written off for fluctuations. <br><br><h3>  Anonymous Functions </h3><br>  Sometimes newbies ask, ‚ÄúIs an anonymous function expensive?‚Äù <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BenchmarkDirectAnonymous</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b *testing.B)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; bN; i++ { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { testInt64++ }() } }</code> </pre> <br><blockquote>  An anonymous function is not expensive, it takes 40.4 ns. </blockquote><br><h3>  Interfaces </h3><br>  There is an interface and a structure that implements it. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> testTypeInterface <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { Inc() } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> testTypeStruct <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { n <span class="hljs-keyword"><span class="hljs-keyword">int64</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s *testTypeStruct)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Inc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { s.n++ }</code> </pre> <br>  There are three options for using the increment method.  Directly from Struct: <code>var testStruct = testTypeStruct{}</code> . <br><br>  From the appropriate concrete interface: <code>var testInterface testTypeInterface = &amp;testStruct</code> . <br><br>  With runtime interface conversion: <code>var testInterfaceEmpty interface{} = &amp;testStruct</code> . <br><br>  Below is runtime interface conversion and use directly. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BenchmarkInterface</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b *testing.B)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; bN; i++ { testInterface.Inc() } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BenchmarkInterfaceRuntime</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b *testing.B)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; bN; i++ { testInterfaceEmpty.(testTypeInterface).Inc() } }</code> </pre> <br><blockquote>  The interface, as such, costs nothing. </blockquote><br><pre> <code class="plaintext hljs">//  BenchmarkStruct-4 2000000000 1.44 / BenchmarkInterface-4 2000000000 1.88 / BenchmarkInterfaceRuntime-4 200000000 9.23 /</code> </pre> <br><br>  Runtime interface conversion is worth it, but not expensive - you don‚Äôt need to specifically refuse.  But try to do without it where possible. <br><br>  <b>Myths:</b> <br><br><ul><li>  Dereference - dereferencing pointers - free. </li><li>  Anonymous features are free. </li><li>  Interfaces are free. </li><li>  Runtime interface conversion - NOT FREE. </li></ul><br><h3>  Switch, map and slice </h3><br>  Every newcomer to Go asks what happens if you replace switch with map.  Will it be faster? <br><br>  Switch come in different sizes.  I tested on three sizes: small for 10 cases, medium for 100 and large for 1000 cases.  Switch for 1000 cases are found in real production code.  Of course, no one writes them with his hands.  This is auto-generated code, usually a type switch.  Tested on two types: int and string.  It seemed that it would turn out more clearly. <br><br>  <strong>Little switch.</strong>  The fastest option is the actual switch.  It is followed immediately by slice, where the corresponding integer index contains a reference to the function.  Map is not a leader on either int or string. <br><div class="scrollable-table"><table><tbody><tr><td>  BenchmarkSwitchIntSmall-4 </td><td>  500000000 </td><td>  3.26 ns / op </td></tr><tr><td>  BenchmarkMapIntSmall-4 </td><td>  100,000,000 </td><td>  11.70 ns / op </td></tr><tr><td>  BenchmarkSliceIntSmall-4 </td><td>  500000000 </td><td>  3.85 ns / op </td></tr><tr><td>  BenchmarkSwitchStringSmall-4 </td><td>  100,000,000 </td><td>  12.70 ns / op </td></tr><tr><td>  BenchmarkMapStringSmall-4 </td><td>  100,000,000 </td><td>  15.60 ns / op </td></tr></tbody></table></div><br>  Switch on strings is significantly slower than on int.  If you can switch not to string, but to int, then do so. <br><br>  <strong>Middle switch.</strong>  Switch itself still rules int, but slice has overtaken it a bit.  Map is still bad.  But on a string key, map is faster than switch - as expected. <br><div class="scrollable-table"><table><tbody><tr><td>  BenchmarkSwitchIntMedium-4 </td><td>  300000000 </td><td>  4.55 ns / op </td></tr><tr><td>  BenchmarkMapIntMedium-4 </td><td>  100,000,000 </td><td>  17.10 ns / op </td></tr><tr><td>  BenchmarkSliceIntMedium-4 </td><td>  300000000 </td><td>  3.76 ns / op </td></tr><tr><td>  BenchmarkSwitchStringMedium-4 </td><td>  50,000,000 </td><td>  28.50 ns / op </td></tr><tr><td>  BenchmarkMapStringMedium-4 </td><td>  100,000,000 </td><td>  20.30 ns / op </td></tr></tbody></table></div><br>  <strong>Big switch.</strong>  A thousand cases show the unconditional victory of map in the nomination ‚Äúswitch by string‚Äù.  Theoretically, slice won, but in practice I advise you to use the same switch here.  Map is still slow, even considering that map has integer keys with a special hash function.  In general, this function does nothing.  The int itself acts as a hash for int. <br><div class="scrollable-table"><table><tbody><tr><td>  BenchmarkSwitchIntLarge-4 </td><td>  100,000,000 </td><td>  13.6 ns / op </td></tr><tr><td>  BenchmarkMapIntLarge-4 </td><td>  50,000,000 </td><td>  34.3 ns / op </td></tr><tr><td>  BenchmarkSliceIntLarge-4 </td><td>  100,000,000 </td><td>  12.8 ns / op </td></tr><tr><td>  BenchmarkSwitchStringLarge-4 </td><td>  20,000,000 </td><td>  100.0 ns / op </td></tr><tr><td>  BenchmarkMapStringLarge-4 </td><td>  30000000 </td><td>  37.4 ns / op </td></tr></tbody></table></div><br>  <strong>Findings.</strong>  Map is only better on large quantities and not on an integer condition.  I am sure that on any of the conditions except int, it will behave the same as on string.  Slice always steers when the conditions are integer.  Use it if you want to ‚Äúspeed up‚Äù your program by 2 ns. <br><br><h2>  Inter-routine interaction </h2><br>  The topic is complex, I have conducted many tests and will present the most revealing ones.  We know the following <strong>means of interagency interaction</strong> . <br><br><ul><li>  Atomic  These are means of limited applicability - you can replace the pointer or use int. </li><li>  Mutex has been used widely since Java. </li><li>  Channel is unique to GO. </li><li>  Buffered Channel - buffered channels. </li></ul><br>  Of course, I tested on a significantly larger number of goroutines that compete for one resource.  But he chose three for himself as indicative: a little - 100, a medium - 1000 and a lot - 10000. <br><br>  <strong>The load profile is different</strong> .  Sometimes all gorutins want to write in one variable, but this is rare.  Usually, after all, some write, some read.  Of the mostly readers - 90% read, of those who write - 90% write. <br><br>  This is the code that is used so that the goroutine that serves the channel can provide both reading from and writing to a variable. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> n, ok := &lt;-cw: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> !ok { wgc.Done() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } testInt64 += n <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> cr &lt;- testInt64: } } }()</code> </pre> <br>  If a message arrives to us through the channel through which we write, we execute it.  If the channel is closed, we finish goroutin.  At any time, we are ready to write to the channel that is used by other goroutines for reading. <br><div class="scrollable-table"><table><tbody><tr><td>  Benchmarkmutex-4 </td><td>  100,000,000 </td><td>  16.30 ns / op </td></tr><tr><td>  Benchmarkatomic-4 </td><td>  200000000 </td><td>  6.72 ns / op </td></tr><tr><td>  BenchmarkChan-4 </td><td>  5,000,000 </td><td>  239.00 ns / op </td></tr></tbody></table></div><br>  This is data for one goroutine.  The channel test is performed on two goroutines: one processes the Channel, the other writes to this Channel.  And these options were tested on one. <br><br><ul><li>  Direct writes to a variable. </li><li>  Mutex takes a log, writes to a variable and releases a log. </li><li>  Atomic writes to a variable through Atomic.  It is not free, but still significantly cheaper than Mutex on one garutin. </li></ul><br>  With a small amount of goroutine, the Atomic is an effective and fast way to synchronize, which is not surprising.  Direct is not here, because we need synchronization, which it does not provide.  But Atomic has flaws, of course. <br><div class="scrollable-table"><table><tbody><tr><td>  BenchmarkMutexFew-4 </td><td>  30000 </td><td>  55894 ns / op </td></tr><tr><td>  BenchmarkAtomicFew-4 </td><td>  100,000 </td><td>  14585 ns / op </td></tr><tr><td>  BenchmarkChanFew-4 </td><td>  5000 </td><td>  323859 ns / op </td></tr><tr><td>  BenchmarkChanBufferedFew-4 </td><td>  5000 </td><td>  341321 ns / op </td></tr><tr><td>  BenchmarkChanBufferedFullFew-4 </td><td>  20000 </td><td>  70052 ns / op </td></tr><tr><td>  BenchmarkMutexMostlyReadFew-4 </td><td>  30000 </td><td>  56402 ns / op </td></tr><tr><td>  BenchmarkAtomicMostlyReadFew-4 </td><td>  1,000,000 </td><td>  2094 ns / op </td></tr><tr><td>  BenchmarkChanMostlyReadFew-4 </td><td>  3000 </td><td>  442689 ns / op </td></tr><tr><td>  BenchmarkChanBufferedMostlyReadFew-4 </td><td>  3000 </td><td>  449,666 ns / op </td></tr><tr><td>  BenchmarkChanBufferedFullMostlyReadFew-4 </td><td>  5000 </td><td>  442,708 ns / op </td></tr><tr><td>  BenchmarkMutexMostlyWriteFew-4 </td><td>  20000 </td><td>  79708 ns / op </td></tr><tr><td>  BenchmarkAtomicMostlyWriteFew-4 </td><td>  100,000 </td><td>  13358 ns / op </td></tr><tr><td>  BenchmarkChanMostlyWriteFew-4 </td><td>  3000 </td><td>  449,556 ns / op </td></tr><tr><td>  BenchmarkChanBufferedMostlyWriteFew-4 </td><td>  3000 </td><td>  445,423 ns / op </td></tr><tr><td>  BenchmarkChanBufferedFullMostlyWriteFew-4 </td><td>  3000 </td><td>  414626 ns / op </td></tr></tbody></table></div><br>  Next up is Mutex.  I expected Channel to be about as fast as Mutex, but no. <br><br><blockquote>  Channel is an order of magnitude more expensive than Mutex. </blockquote><br>  Moreover, Channel and buffered Channel come out at about the same price.  And there is Channel, in which the buffer never overflows.  It is an order of magnitude cheaper than the one whose buffer overflows.  Only if the buffer in Channel is not full, then it costs about the same in orders of magnitude as Mutex.  This is what I expected from the test. <br><br>  This picture with the distribution of how much it costs is repeated on any load profile - both on MostlyRead and MostlyWrite.  Moreover, the full MostlyRead Channel costs the same as the incomplete one.  And MostlyWrite's buffered Channel, in which the buffer is not full, costs the same as the rest.  I cannot say why this is so - I have not yet studied this question. <br><br><h2>  Passing parameters </h2><br>  <strong>How to pass parameters faster - by reference or by value?</strong>  Let's check. <br><br>  I checked as follows - made nested types from 1 to 10. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> TP001 <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { I001 <span class="hljs-keyword"><span class="hljs-keyword">int64</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> TV002 <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { I001 <span class="hljs-keyword"><span class="hljs-keyword">int64</span></span> S001 TV001 I002 <span class="hljs-keyword"><span class="hljs-keyword">int64</span></span> S002 TV001 }</code> </pre> <br>  The tenth nested type will have 10 int64 fields, and the nested types of the previous nesting will also be 10. <br><br>  Then he wrote functions that create a type of nesting. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NewTP001</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TP001</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &amp;TP001{ I001: rand.Int63(), } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NewTV002</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TV002</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TV002{ I001: rand.Int63(), S001: NewTV001(), I002: rand.Int63(), S002: NewTV001(), } }</code> </pre> <br>  For testing, I used three options of the type: small with nesting 2, medium with nesting 3, large with nesting 5. I had to put a very large test with nesting 10 at night, but there the picture is exactly the same as for 5. <br><br>  <b>In functions, passing by value is at least twice as fast as passing by reference</b> .  This is due to the fact that passing by value does not load the escape analysis.  Accordingly, the variables that we allocate are on the stack.  It is substantially cheaper for runtime, for garbage collector.  Although he may not have time to connect.  These tests went on for several seconds - the garbage collector was probably still asleep. <br><div class="scrollable-table"><table><tbody><tr><td>  BenchmarkCreateSmallByValue-4 </td><td>  200,000 </td><td>  8942 ns / op </td></tr><tr><td>  BenchmarkCreateSmallByPointer-4 </td><td>  100,000 </td><td>  15985 ns / op </td></tr><tr><td>  BenchmarkCreateMediuMByValue-4 </td><td>  2000 </td><td>  862317 ns / op </td></tr><tr><td>  BenchmarkCreateMediuMByPointer-4 </td><td>  2000 </td><td>  1228130 ns / op </td></tr><tr><td>  BenchmarkCreateLargeByValue-4 </td><td>  thirty </td><td>  47398456 ns / op </td></tr><tr><td>  BenchmarkCreateLargeByPointer-4 </td><td>  20 </td><td>  61928751 ns / op </td></tr></tbody></table></div><br><h2>  Black magic </h2><br>  Do you know what this program will output? <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> A <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { a, b <span class="hljs-keyword"><span class="hljs-keyword">int32</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { a := <span class="hljs-built_in"><span class="hljs-built_in">new</span></span>(A) aa = <span class="hljs-number"><span class="hljs-number">0</span></span> ab = <span class="hljs-number"><span class="hljs-number">1</span></span> z := (*(*<span class="hljs-keyword"><span class="hljs-keyword">int64</span></span>)(unsafe.Pointer(a))) fmt.Println(z) }</code> </pre> <br>  The result of the program depends on the architecture on which it is executed.  On little endian, for example, AMD64, the program displays <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msup><mn>2</mn><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mn>32</mn></mrow></msup></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="3.039ex" height="2.419ex" viewBox="0 -935.7 1308.3 1041.5" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/company/oleg-bunin/blog/461291/&amp;xid=17259,15700023,15700186,15700191,15700256,15700259,15700262,15700265&amp;usg=ALkJrhhc-HCSDI3BPEuwgEJYOPHV4tes2Q#MJMAIN-32" x="0" y="0"></use><g transform="translate(500,393)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/company/oleg-bunin/blog/461291/&amp;xid=17259,15700023,15700186,15700191,15700256,15700259,15700262,15700265&amp;usg=ALkJrhhc-HCSDI3BPEuwgEJYOPHV4tes2Q#MJMAIN-33"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/company/oleg-bunin/blog/461291/&amp;xid=17259,15700023,15700186,15700191,15700256,15700259,15700262,15700265&amp;usg=ALkJrhhc-HCSDI3BPEuwgEJYOPHV4tes2Q#MJMAIN-32" x="500" y="0"></use></g></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mn>2</mn><mrow class="MJX-TeXAtom-ORD"><mn>32</mn></mrow></msup></math></span></span><script type="math/tex" id="MathJax-Element-1"> 2 ^ {32} </script>  .  On big endian - one.  The result is different, because on little endian this unit appears in the middle of the number, and on big endian - at the end. <br><br>  There are still processors in the world where endian switches, for example, Power PC.  You will have to figure out what endian is configured on your computer during startup before making conclusions about what unsafe tricks of this kind do.  For example, if you write a Go-code that will be executed on some IBM multiprocessor server. <br><br>  I cited this code to explain why I consider all unsafe black magic.  You do not need to use it.  But Cyril believes that it is necessary.  And that's why. <br><br>  There is a function that does the same thing as GOB - Go Binary Marshaller.  This is Encoder, but on unsafe. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">encodeMut</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint64</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(res []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { sz := <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(data) * <span class="hljs-number"><span class="hljs-number">8</span></span> dh := (*header)(unsafe.Pointer(&amp;data)) rh := &amp;header{ data: dh.data, <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>: sz, <span class="hljs-built_in"><span class="hljs-built_in">cap</span></span>: sz, } res = *(*[]<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)(unsafe.Pointer(&amp;rh)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> }</code> </pre> <br>  In fact, it takes a piece of memory and draws an array of bytes from it. <br><br>  This is not even an order - these are two orders.  Therefore, Cyril Danshin, when he writes a high-performance code, does not hesitate to get into the guts of his program and make it unsafe. <br><br><div class="scrollable-table"><table><tbody><tr><td>  Benchmark gob-4 </td><td>  200,000 </td><td>  8466 ns / op </td><td>  120.94 MB / s </td></tr><tr><td>  BenchmarkUnsafeMut-4 </td><td>  50,000,000 </td><td>  37 ns / op </td><td>  27691.06 MB / s </td></tr></tbody></table></div><blockquote>  We will discuss more specific features of Go on October 7 at the <a href="https://golangconf.ru/2019">GolangConf</a> - a conference for those who use Go in professional development, and those who consider this language as an alternative.  Daniil Podolsky is just a member of the Program Committee, if you want to argue with this article or reveal related issues - <a href="https://conf.ontico.ru/lectures/propose%3Fconference%3Dgc2019">submit an application</a> for a report. <br><br>  For everything else, with regard to high performance, of course, <a href="https://www.highload.ru/moscow/2019">HighLoad ++</a> .  We also accept applications there.  <a href="http://eepurl.com/VYVaf">Sign up</a> for the newsletter and stay up to date with the news of all our conferences for web developers. </blockquote></div><p>Source: <a href="https://habr.com/ru/post/461291/">https://habr.com/ru/post/461291/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../461281/index.html">Walkthrough for setting up a BIND DNS server in a chroot environment for Red Hat (RHEL / CentOS) 7</a></li>
<li><a href="../461283/index.html">Software architecture and systems design: a big picture and resource guide</a></li>
<li><a href="../461285/index.html">5 main sampling algorithms</a></li>
<li><a href="../461289/index.html">CLion 2019.2 released: embedded development support, debugger for MSVC, search for unused header files</a></li>
<li><a href="../46129/index.html">Are you familiar with parallel programming?</a></li>
<li><a href="../461297/index.html">What modern targeted attacks look like</a></li>
<li><a href="../461299/index.html">How the PC conquered the media industry with successful software: discussing Pro Tools and Media Composer</a></li>
<li><a href="../4613/index.html">Nine reasons to wait a bit with Firefox upgrade</a></li>
<li><a href="../46130/index.html">Web Directions Survey</a></li>
<li><a href="../461303/index.html">Using the Troika card as a mandatory medical insurance policy</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>