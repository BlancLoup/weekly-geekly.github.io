<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Getting started in STM32CubeMX. Part 3</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="We continue the cycle about the basics of the work of the STM32MXCube and the programming of the STM32 microcontrollers. 

 ‚Üí Part 1 
 ‚Üí Part 2 

 In ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Getting started in STM32CubeMX. Part 3</h1><div class="post__text post__text-html js-mediator-article">  We continue the cycle about the basics of the work of the STM32MXCube and the programming of the STM32 microcontrollers. <br><br>  ‚Üí <a href="https://habrahabr.ru/post/310742/">Part 1</a> <br>  ‚Üí <a href="https://habrahabr.ru/post/312810/">Part 2</a> <br><div style="text-align:center;"><img src="https://habrastorage.org/files/ee3/d7e/3d3/ee3d7e3d325e4952ab61b4ee9446f619.jpg"></div><br>  In the last parts we mastered the basic settings of the microcontroller, work with GPIO, timer, DMA and DAC.  In this part we will get acquainted with ADC and USB. <br><a name="habracut"></a><br><h2>  A small introduction to the third part </h2><br>  First, I want to say that from this part I will use the NUCLEO-F767ZI debugging board.  This board is more accessible than the STM32F746G Discovery, uses a microcontroller in the LQFP144 package, not BGA, and the board itself is more convenient for embedding in different DIY projects.  It has Ethernet and USB, as well as a JTAG debugger.  The disadvantage of the board is the lack of LCD, but we do not need it yet. <br><br>  Although the board has a different microcontroller, all projects from the previous parts are transferred to it almost unchanged (you only need to change pin numbers).  Also note that on this board the microcontroller is clocked by a 8 MHz source.  Quartz for clocking the microcontroller is provided by the scheme, but not soldered, the 8 MHz signal is removed from the JTAG debugger.  If your project uses a USB interface, then it is advisable to include clocking from HSE, and not from the internal RC oscillator, since the RC oscillator does not have sufficient accuracy and frequency stability.  If you try to turn on the RC oscillator if there is a USB in the project, the STM32CubeMX will issue a warning and will offer to switch to HSE (that is, to an external highly stable clock source).  In order to enable an external clock source (8 MHz) on the PinOut tab, you should enable HCE in the RCC item and select BYPASS Clock Source.  In practice, the USB interface still works, even from RC, but it's better not to risk it. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      I transferred the projects from the previous parts to this board and <a href="https://github.com/arktur04/stm32-habr">uploaded</a> them to the <a href="https://github.com/arktur04/stm32-habr">githab</a> . <br><br>  In the comments to the previous installments there were questions about the IDE.  STM32CubeMX allows you to automatically create projects for various IDE: IAR (EWARM), MDK ARM v4, MDK ARM v5, Atollic TRUEStudio, SW4STM32, etc. I use Atollic TRUEStudio, which is available for download from the official site for free. <br><br>  I also checked the material from the previous parts and made a number of amendments. <br>  I want to thank <a href="https://habrahabr.ru/users/shamrel/" class="user_link">Shamrel</a> for the valuable comments on the previous part. <br><br><h2>  USB VCP </h2><br>  One of the simplest modes of USB is VCP - Virtual COM Port.  Setting up work with it will require minimal effort from you. <br><br>  In STM32CubeMX, find the USB_OTG_FS section on the Pinout tab and set the Mode = Device_Only: <br><br><img src="https://habrastorage.org/files/da5/ddf/044/da5ddf0442dd4628bbe80e024386bca0.jpg"><br><br>  In the USB_DEVICE section, set Class For FS IP to CDC VCP (Communication Device Class Virtual Com Port) mode: <br><br><img src="https://habrastorage.org/files/4f7/f3a/a26/4f7f3aa26e9b4ba3a2729fc1cac667a0.jpg"><br><br>  Now you need to configure the clocking configuration so that the USB frequency is 48 MHz: <br><br><img src="https://habrastorage.org/files/2fe/c76/c46/2fec76c463924182b81bc1d12b388c4c.jpg"><br><br>  Go further to the Configuration tab, and disable the VBUS Sensing parameter: <br><br><img src="https://habrastorage.org/files/459/0f9/83a/4590f983a0a34148b1fdc7de7d9b398d.jpg"><br><br>  We generate the code and open the project in the IDE. <br><br>  Find the file usbd_cdc_if.c and insert the following into it: <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> int8_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CDC_Receive_FS</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">* Buf, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *Len)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* USER CODE BEGIN 6 */</span></span> USBD_CDC_SetRxBuffer(&amp;hUsbDeviceFS, &amp;Buf[<span class="hljs-number"><span class="hljs-number">0</span></span>]); CDC_Transmit_FS(Buf, *Len); USBD_CDC_ReceivePacket(&amp;hUsbDeviceFS); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (USBD_OK); <span class="hljs-comment"><span class="hljs-comment">/* USER CODE END 6 */</span></span> }</code> </pre> <br>  and <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> CDC_Transmit_FS(<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span>* Buf, <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> Len) { <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> result = USBD_OK; <span class="hljs-comment"><span class="hljs-comment">/* USER CODE BEGIN 7 */</span></span> USBD_CDC_SetTxBuffer(&amp;hUsbDeviceFS, Buf, Len); result = USBD_CDC_TransmitPacket(&amp;hUsbDeviceFS); <span class="hljs-comment"><span class="hljs-comment">/* USER CODE END 7 */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br>  Here the echo mode is implemented: everything that comes to the port, we immediately send back. <br><br>  We compile and flash the microcontroller.  Then we connect the User USB connector of the board to the computer.  The system should detect a new COM port. <br><br>  For Linux: check ls / dev / tty *, the device appeared / dev / ttyACM0.  Check, and here we are waiting for another surprise: denied access.  You need to add yourself to the dialout group: <br><br><pre> <code class="bash hljs">sudo adduser user dialout</code> </pre> <br>  (where user is your username) <br><br>  To work with the device in Windows, you will need to download and install the <a href="http://www.st.com/content/st_com/en/products/development-tools/software-development-tools/stm32-software-development-tools/stm32-utilities/stsw-stm32102.html">driver</a> .  To work on OS X and Linux, a special driver is not needed. <br><br>  We start (for example) Putty, we configure port parameters.  They must match the parameters specified in the port properties (see ‚ÄúDevice Manager / Ports‚Äù). <br><br>  We try to open the port in Putty and send something to the port: <br><br><img src="https://habrastorage.org/files/2ec/c43/af0/2ecc43af0a4c4c0caf75a2bd02fa98da.jpg"><br><br>  If the port does not open, you can try to exit debug mode in the IDE and restart the board.  Everything has to earn. <br><br>  Addition from <a href="https://habrahabr.ru/users/desinerstm/" class="user_link">desinerSTM</a> : <br><blockquote>  how to deal with error code 10 virtual port? <br>  Helps usbd_cdc.h file instead of 512 to put 256 in the line: <br>  #define CDC_DATA_HS_MAX_PACKET_SIZE (512 was) 256 / * Endpoint IN &amp; OUT Packet size * / </blockquote><br><br>  As we have seen, working with USB in the mode of a virtual COM port is very simple.  The only drawback of this mode is the very low data transfer rate.  The USB interface in Full Speed ‚Äã‚Äãmode provides up to 12 Mbps, in High Speed ‚Äã‚Äãmode - up to 480 Mbps, but the VCP limits the speed to a measly 128 Kbps. <br><br>  You can make a high data transfer rate, but for now let's put it off until the next time. <br><br><h2>  ADC </h2><br>  Now let's try to run the ADC, get values ‚Äã‚Äãfrom it and send it to a computer, implementing a very simple (and very slow) "oscilloscope".  To make it more interesting, we will apply a sine wave formed by the DAC to the ADC.  Since we have already done this in the last part, I will simply copy the code into a new project (with minor changes that do not play a big role). <br><br>  First, a little about the ADC, built into the microcontroller.  The STM32F767ZI microcontroller has three 12-bit ADCs, such as SAR (sequential approximation), with a capacity of up to 2 MSPS (million samples per second).  This type of ADC is characterized by high conversion speed, but less accuracy than sigma-delta ADC.  The reference voltage input VREF is connected to VDDA, and, through inductance, to VDD.  Thus, the reference voltage in our case is 3.3V.  A feature of SAR ADC is the use of a capacitor at the input to the sampling-storage circuit.  At the time of sampling the signal value, the capacitor is connected to the input and charged to the size of the input signal.  If the signal source has too much internal resistance, the capacitor will not have time to fully charge, and we will get a lower value.  This and other aspects of using the ADC are described in [1]. <br><br>  The ADC of this microcontroller has many modes of operation [2], we consider only one of them.  Let's try to simultaneously receive two signal values ‚Äã‚Äãfrom two ADCs, strictly synchronously, and write them to the buffer via DMA. <br><br>  So, we create a new project, add the ready code to it to generate a sine wave on the DAC and for the USB VCP (through it we will send data to the computer).  Further (by wires) we connect the output of the DAC with the inputs of ADC1 and ADC2.  In order to somehow distinguish the signals on the analog inputs, I connected ACP1 to a DAC directly, and ACP2 - through a voltage divider on a variable resistor, so that you can change the amplitude of the signal. <br><br><div class="spoiler">  <b class="spoiler_title">Caution, analog circuitry!</b> <div class="spoiler_text">  If you feed a signal from an external source to the ADC input, remember that the signal at any input of the microcontroller should be limited to 0 - Vcc, which in most practical cases makes it necessary to shift and amplify (or weaken) the signal. <br>  It should also be noted that the STM32 microcontrollers use sequential approximation (SAR) ADCs, which consume a fairly large current from the signal source at the time of measurement, and require a low impedance signal source. <br><br><img src="https://habrastorage.org/files/a92/e4e/285/a92e4e2854fb46e8beb1fd4eac91eaa4.jpg"><br>  Fig.  1. SAR ADC sample-storage scheme (not from STM32, but completely analogous) <br><br>  At the moments of signal sampling, capacitors (Fig. 1) are connected to the input of the ADC and must be charged to a full signal level in a very short time, while consuming a significant current.  If the signal source has a high resistance, they will not have time to charge, and the ADC readings will be incorrect.  In practice, this means that we must in most cases use an external buffer amplifier.  Since today we will focus on the software aspects of the task, we can do without an amplifier, but remember that without an amplifier, the ADC readings will be significantly distorted, and in real projects it is needed. <br><br><img src="https://habrastorage.org/files/523/9d5/31d/5239d531dba44e85ba97ce04a7892719.jpg"><br>  Fig.  2. The sampling-storage scheme causes dips in the signal level at the ADC input. <br><br>  Unfortunately, in the STM32 documentation these issues are poorly addressed, but I can recommend the manual [3]. <br>  If readers will be interested, I can consider the basics of analog node mapping circuitry in the next article. <br></div></div><br>  We will need two timers in our project.  One of them will set the period of the DAC, the second - the ADC.  Let's configure the analog-digital converter to work in dual channel mode with simultaneous sampling.  Sampling will occur on timer TIM2.  The resulting values ‚Äã‚Äãwill be buffered using DMA. <br><br>  We will use the single-time DMA mode (there is also a cyclic mode, we already met him while studying the DAC).  After the buffer is filled with values ‚Äã‚Äãfrom the ADC, we copy its contents to another buffer (with some processing), transfer it via USB and start the process again.  Also, for debugging and indication of the operation mode, we use two GPIO ports to which the LEDs are connected. <br><br>  So, we have created a project in which we added a DAC and a timer TIM1.  We also need to add ADC1 (input IN9), ADC2 (input IN12) and timer TIM2.  We also need USB_OTG_FS. <br><br>  We configure ADC1 to work in the mode of simultaneous sampling, with the launch on timer 2: <br><br><img src="https://habrastorage.org/files/43a/7a0/0a6/43a7a00a6d19488ba7804c66f9fdfe4f.jpg"><br><br>  ADC2 is automatically configured: <br><br><img src="https://habrastorage.org/files/94e/310/ba2/94e310ba294b40d18272c2f7d2516b8f.jpg"><br><br>  Configure DMA: <br><br><img src="https://habrastorage.org/files/192/b38/974/192b3897413b4115a126080880a1fb9f.jpg"><br><br>  Please note that the size of the transmitted data is Word, not Half Word, because  data from two ADCs, packed in a 32-bit word, are transmitted at one time.  Configuring timer TIM2: <br><br><img src="https://habrastorage.org/files/d74/ca2/db4/d74ca2db4cac4fccb50ebe92a71e78e1.jpg"><br><br>  We set up USB in the same way as we did before.  We generate the code. <br><br>  I will not paint here the entire source code of the project, I‚Äôll dwell only on the key points.  Starting the ADC-DMA chain: <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">//start adc HAL_ADC_Start(&amp;hadc2); HAL_ADCEx_MultiModeStart_DMA(&amp;hadc1, (uint32_t *)adc_buf, ADC_BUF_SIZE); HAL_TIM_Base_Start_IT(&amp;htim2);</span></span></code> </pre> <br>  Interrupt Handler: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HAL_ADC_ConvCpltCallback</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ADC_HandleTypeDef* hadc)</span></span></span><span class="hljs-function"> </span></span>{ HAL_TIM_Base_Stop(&amp;htim2); HAL_ADC_Stop(&amp;hadc2); HAL_ADCEx_MultiModeStop_DMA(&amp;hadc1); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> threshold = (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">11</span></span>); <span class="hljs-comment"><span class="hljs-comment">//find a trigger condition if(state == STARTED) { HAL_GPIO_WritePin(GPIOB, GPIO_PIN_7, 1); for(int i = 0; i &lt; (ADC_BUF_SIZE - VCP_BUF_SIZE); i++) { uint32_t sample0_0 = adc_buf[i] &amp; 0x00000FFF; uint32_t sample0_1 = adc_buf[i + 1] &amp; 0x00000FFF; if(sample0_0 &lt; threshold &amp;&amp; sample0_1 &gt;= threshold) //the trigger condition { memcpy(vcp_buf, adc_buf + i + 1, VCP_BUF_SIZE * sizeof(uint32_t)); vcp_buf[0] |= 0x80000000; //mark the first sample in the frame CDC_Transmit_FS((uint8_t*)vcp_buf, VCP_BUF_SIZE * sizeof(uint32_t)); } } HAL_GPIO_WritePin(GPIOB, GPIO_PIN_7, 0); } //restart adc HAL_ADC_Start(&amp;hadc2); HAL_ADCEx_MultiModeStart_DMA(&amp;hadc1, (uint32_t*)adc_buf, ADC_BUF_SIZE); HAL_TIM_Base_Start_IT(&amp;htim2); //led flashing static int cnt = 0; if((cnt++) % 128 == 0) { HAL_GPIO_TogglePin(GPIOB, GPIO_PIN_14); //Toggle the state of pin } }</span></span></code> </pre> <br>  Why can't we directly transfer the contents of the source buffer via USB?  Since the VCP speed is too low, we will not be able to transmit the entire data stream from the ADC.  We capture a piece of the signal, transfer it ‚Äúup‚Äù, then capture the next piece, etc. If we do not take special measures, then random fragments of the original signal will be transmitted to the port.  Therefore, you need to make a software analogue of the "trigger", like a digital oscilloscope.  We will send to the port not a random fragment captured by the ADC, but a piece of the signal after the occurrence of some condition.  Such a condition can be the crossing of a certain level in the bottom-up direction: sample0_0 &lt;threshold &amp;&amp; sample0_1&gt; = threshold, where threshold is the threshold. <br><br>  That is why we make the ADC buffer twice the size of the VCP buffer, and scan it to the middle in search of such a condition.  If the condition has not come, do not send anything to the port, and run the next ADC cycle. <br><br>  DMA packs signals from two ADCs into one 32-bit word.  We will not change this format, just add one to the high order of the first report in the buffer so that the top-level software can recognize the beginning of the ‚Äúframe‚Äù: <br><br><pre> <code class="cpp hljs">vcp_buf[<span class="hljs-number"><span class="hljs-number">0</span></span>] |= <span class="hljs-number"><span class="hljs-number">0x80000000</span></span>;</code> </pre> <br>  To display the signal on the computer, I wrote a small C # program: <br><br><img src="https://habrastorage.org/files/b03/2b5/d97/b032b5d976b042139ec4a6cf288e6a7e.jpg"><br><br>  It is mainly assembled from components in Visual Studio and contains minimal code.  Its source is also available on Github. <br><br><h2>  What's next </h2><br>  In the next part, we look at the Ethernet interface and a bit of the real-time operating system FreeRTOS. <br><br><img src="https://habrastorage.org/files/10e/ce4/594/10ece459409f4f1795aad5b901d23dc4.jpg"><br><br><h2>  Links </h2><br>  Project sources for the entire series of articles can be downloaded on <a href="https://github.com/arktur04/stm32-habr">github</a> .  All projects are made for the Nucleo F767ZI board and use IDE Atollic TRUEStudio. <br><br>  [1] <a href="http://www.st.com/content/ccc/resource/technical/document/application_note/group0/3f/4c/a4/82/bd/63/4e/92/CD00211314/files/CD00211314.pdf/jcr:content/translations/en.CD00211314.pdf">AN2834 Application note.</a>  <a href="http://www.st.com/content/ccc/resource/technical/document/application_note/group0/3f/4c/a4/82/bd/63/4e/92/CD00211314/files/CD00211314.pdf/jcr:content/translations/en.CD00211314.pdf">How to get the best ADC accuracy in STM32 microcontrollers</a> <br>  [2] <a href="http://www.st.com/content/ccc/resource/technical/document/application_note/c4/63/a9/f4/ae/f2/48/5d/CD00258017.pdf/files/CD00258017.pdf/jcr:content/translations/en.CD00258017.pdf">AN3116 Application note.</a>  <a href="http://www.st.com/content/ccc/resource/technical/document/application_note/c4/63/a9/f4/ae/f2/48/5d/CD00258017.pdf/files/CD00258017.pdf/jcr:content/translations/en.CD00258017.pdf">STM32's ADC modes and their applications</a> <br>  [3] <a href="https://developer.mbed.org/media/uploads/GregC/an4373-cookbook_for_sar_adc.pdf">Cookbook for SAR ADC Measurements.</a>  <a href="https://developer.mbed.org/media/uploads/GregC/an4373-cookbook_for_sar_adc.pdf">Freescale Semiconductor.</a>  <a href="https://developer.mbed.org/media/uploads/GregC/an4373-cookbook_for_sar_adc.pdf">AN4373</a> <br><br>  Thank you for your attention, please report any errors and typos in PM.  To be continued. </div><p>Source: <a href="https://habr.com/ru/post/323674/">https://habr.com/ru/post/323674/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../323660/index.html">When the ‚Äúcloud‚Äù breaks down: what can be done in this situation?</a></li>
<li><a href="../323662/index.html">Where did the sites with the "average" budget go, or how to make 80 projects a year with the help of Marketplace</a></li>
<li><a href="../323664/index.html">Pro learning experience at OKademy</a></li>
<li><a href="../323670/index.html">And you hto such? The evolution of MySQL and MariaDB authentication protocols in faces</a></li>
<li><a href="../323672/index.html">Instagram redesign: experience analyzing and rethinking the interface</a></li>
<li><a href="../323676/index.html">GameDev from scratch: From the hackathon to your own game development studio. Part 2</a></li>
<li><a href="../323680/index.html">Thief: creating a narrative with level design and mechanics</a></li>
<li><a href="../323682/index.html">The problem of saving context in asynchronous programming in scala</a></li>
<li><a href="../323684/index.html">Duke Nukem 3D Source Code Analysis: Part 2</a></li>
<li><a href="../323686/index.html">Great overview of the best designers of mobile applications in 2017</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>