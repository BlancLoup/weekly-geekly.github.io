<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Writing a framework on asyncio, aiohttp and thinking about Python3 part one</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A year and a half ago, there was a question of compatibility of written code with Python3 . Since it has become less obvious that only Python3 is bein...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Writing a framework on asyncio, aiohttp and thinking about Python3 part one</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/4dd/292/fb4/4dd292fb4a494a6dbafea76e0c50edbe.jpg"><br><p> A year and a half ago, there was a question of compatibility of written code with <code>Python3</code> .  Since it has become less obvious that only <code>Python3</code> is being <code>Python3</code> and, sooner or later, all libraries will be ported to it.  And in all distributions the <a href="http://www.opennet.ru/opennews/art.shtml%3Fnum%3D41989">default will be a triple</a> .  But gradually, as I <code>Asyncio</code> what was new in the latest versions of <code>Python</code> I became more and more pleased with <code>Asyncio</code> and, rather, not even <code>Acyncio</code> but <code>Acyncio</code> written to work with it.  And, after some time, a small wrapper appeared around <code>aiohttp</code> in the style of <code>like django</code> .  Who cares what came out of this please under the cat. </p><br><p>  <a href="https://habrahabr.ru/post/252575/">The second part of</a> <a href="https://habrahabr.ru/post/252575/"><br></a> </p><br><p>  <a href="https://habr.com/ru/post/242541/">Introduction</a> <br>  <a href="https://habr.com/ru/post/242541/">Overview of other aiohttp frameworks</a> <br>  <a href="https://habr.com/ru/post/242541/">1. Structure</a> <br>  <a href="https://habr.com/ru/post/242541/">2. aiohttp and jinja2</a> <br>  <a href="https://habr.com/ru/post/242541/">3. aiohttp and routes</a> <br>  <a href="https://habr.com/ru/post/242541/">4. Statics and GET, POST parameters, redirects</a> <br>  <a href="https://habr.com/ru/post/242541/">5. Websocket</a> <br>  <a href="https://habr.com/ru/post/242541/">6. asyncio and mongodb, aiohttp, session, middleware</a> <br>  <a href="https://habr.com/ru/post/242541/">7. aiohttp, supervisor, nginx, gunicorn</a> <br>  <a href="https://habr.com/ru/post/242541/">8. After installation, about examples.</a> <br>  <a href="https://habr.com/ru/post/242541/">9.RoadMap</a> </p><a name="habracut"></a><br><h3><a name="0"></a>  <font color="orange">Introduction</font> </h3><br><p>  At that time, almost all libraries frequently used in projects were already ready for <code>Python3</code> . <br>  The dead <code>PIL</code> was beautifully replaced by <code>Pillow</code> , <code>tweppy</code> on <code>twython</code> , <code>python-openid</code> on <code>python3-openid</code> , etc.  <code>Jinja2</code> , <code>xlrt</code> , <code>xlwt</code> and others have already been supporting <code>Python3</code> . </p><br><p>  Roughly speaking, all that had to be implemented was for the system to give data in the form of <code>bytes</code> : </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">application</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(env, start_response)</span></span></span><span class="hljs-function">:</span></span> start_response(<span class="hljs-string"><span class="hljs-string">'200 OK'</span></span>, [(<span class="hljs-string"><span class="hljs-string">'Content-Type'</span></span>,<span class="hljs-string"><span class="hljs-string">'text/html'</span></span>)]) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bytes(<span class="hljs-string"><span class="hljs-string">"Hello World"</span></span>, <span class="hljs-string"><span class="hljs-string">'utf-8'</span></span>)</code> </pre> <br><p>  It is a little, with library renaming to suffer: </p><br><pre> <code class="python hljs">py = sys.version_info py3k = py &gt;= (<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> py3k: unicode = str <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> io <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> StringIO <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> builtins <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> __builtin__ <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> StringIO</code> </pre> <br><p>  And, of course, as we learn what's new, Python3 could not help but draw <code>Asyncio</code> attention.  The asynchronous engine built into <code>python3</code> .  Appeared, however, only in version <code>3.4</code> .  And only from version <a href="http://www.opennet.ru/opennews/art.shtml%3Fnum%3D42952">3.5</a> , which was released the other day, it has got quite a good syntactic sugar, more on that below. </p><br><p>  The first time, of course, it was wildly inconvenient to write something on it and, as far as I understood, everyone still used <code>tornado</code> , <code>gevent</code> , <code>twisted</code> or wrapped around the same asynio and <code>twisted</code> - <a href="http://autobahn.4ws/python/">autobuh</a> .  Pretty good product.  But as time went on, one of the developers of <code>asyncio</code> <a href="https://habrahabr.ru/users/svetlov/" class="user_link">svetlov</a> created a fairly rapidly developing asynchronous framework <code>aiohttp</code> .  <code>Aiohttp</code> simplifies development using <code>asyncio</code> about the level of <code>flask</code> or <code>bottle</code> . </p><br><p>  But with fairly easily connected websockets and, if desired, allowing you to perform most operations asynchronously, and, in my opinion, with a fairly small price for it, especially with an eye to <code>python3.5</code> . <br>  It looks like this: </p><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#python3.4 @asyncio.coroutine def read_data(): data = yield from db.fetch('SELECT . . . ') #python3.5 async def read_data(): data = await db.fetch('SELECT ...')</span></span></code> </pre> <br><p>  Since so far for writing chats, toys, conferences with <code>webrtc</code> , where there are <code>websoket</code> I had to use either <code>gevent</code> or <code>autobah</code> or in some cases <code>node.js</code> , having weighed all the <code>aiohttp</code> and cons, I really wanted to rewrite my libraries on <code>aiohttp</code> , which over the last The year managed to grow its eco-system, and a number of convenient opportunities.  And so this publication appeared. </p><br><p>  We must also add that in <code>aiohttp</code> it is quite possible to write and synchronously, perform blocking operations, although this is not entirely correct. </p><br><p>  Next will be described the work with <code>aiohttp</code> and the creation of a small framework in the style of <code>like django</code> , with similar structure and capabilities. </p><br><p>  Naturally, it is not necessary to expect any batteries from version 0.1, but I think that in the next version, you can already see a lot of positive changes. </p><br><h3><a name="01"></a>  <font color="orange">Overview of other frameworks based on asyncio and aiohttp</font> </h3><br><p>  Here I want to give a very brief overview, so that there is a general overview of the current state of affairs with writing asynchronous libraries that simplify the life of developers in <code>Python3</code> . <br>  All of the frameworks listed below can be divided into two categories - those that are dependent on <code>aiohttp</code> and are based on it, and those that work without it, only with <code>asyncio</code> . </p><br><p>  <a href="https://github.com/quantmind/pulsar">Pulsar</a> - <code>framework</code> using <code>asyncio</code> and <code>multiprocessing</code> .  Integrates with <code>django</code> , <code>hello world</code> on it looks like a regular <code>wsgi</code> .  On <code>github</code> there are quite a few examples of use, for example, chats, the author, as far as I understand, loves <code>angular.js</code> </p><br><div class="spoiler">  <b class="spoiler_title">Pulsar-hello world</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pulsar.apps <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> wsgi <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hello</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(environ, start_response)</span></span></span><span class="hljs-function">:</span></span> data = <span class="hljs-string"><span class="hljs-string">b'Hello World!\n'</span></span> response_headers = [ (<span class="hljs-string"><span class="hljs-string">'Content-type'</span></span>,<span class="hljs-string"><span class="hljs-string">'text/plain'</span></span>), (<span class="hljs-string"><span class="hljs-string">'Content-Length'</span></span>, str(len(data))) ] start_response(<span class="hljs-string"><span class="hljs-string">'200 OK'</span></span>, response_headers) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [data] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> __name__ == <span class="hljs-string"><span class="hljs-string">'__main__'</span></span>: wsgi.WSGIServer(callable=hello).start()</code> </pre> </div></div><br><p>  <a href="https://github.com/klen/muffin">Mufin</a> is <a href="https://github.com/klen/muffin">aiohttp</a> based <code>framework</code> .  He has a number of plugins, as I understand it, written, as far as possible, asynchronously.  Also, there is a test application deployed on <code>Heroku</code> in the form of a chat. </p><br><div class="spoiler">  <b class="spoiler_title">Mufin - hello world</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> muffin app = muffin.Application(<span class="hljs-string"><span class="hljs-string">'example'</span></span>) @app.register(<span class="hljs-string"><span class="hljs-string">'/'</span></span>, <span class="hljs-string"><span class="hljs-string">'/hello/{name}'</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hello</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(request)</span></span></span><span class="hljs-function">:</span></span> name = request.match_info.get(<span class="hljs-string"><span class="hljs-string">'name'</span></span>, <span class="hljs-string"><span class="hljs-string">'anonymous'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'Hello %s!'</span></span> % name</code> </pre> </div></div><br><p>  <a href="https://github.com/inventive-ninja/interest">introduction</a> is another <code>aiohttp</code> based <code>framework</code> </p><br><div class="spoiler">  <b class="spoiler_title">Example introduction</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> interest <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Service, http <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Service</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Service)</span></span></span><span class="hljs-class">:</span></span> @http.get(<span class="hljs-string"><span class="hljs-string">'/'</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hello</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, request)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> http.Response(text=<span class="hljs-string"><span class="hljs-string">'Hello World!'</span></span>) service = Service() service.listen(host=<span class="hljs-string"><span class="hljs-string">'127.0.0.1'</span></span>, port=<span class="hljs-number"><span class="hljs-number">9000</span></span>, override=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, forever=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>)</code> </pre> </div></div><br><p>  <a href="https://github.com/ChannelOne/Spanner.py">Spanner.py</a> is positioned as a micro <code>web-framework</code> written in python for people :), the author was inspired by <code>Flask</code> and <code>express.js</code> .  Uses only <code>asyncio</code> .  Looks really pretty laconic. </p><br><div class="spoiler">  <b class="spoiler_title">Example</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> webspanner <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Spanner app = Spanner() @app.route(<span class="hljs-string"><span class="hljs-string">'/'</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">index</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(req, res)</span></span></span><span class="hljs-function">:</span></span> res.write(<span class="hljs-string"><span class="hljs-string">"Hello world"</span></span>)</code> </pre> </div></div><br><p>  <a href="https://github.com/pyGrowler/Growler">Growler</a> - <code>framework</code> using only <code>asyncio</code> , the authors say that they took the ideas of <code>node.js</code> and <code>express</code> . </p><br><div class="spoiler">  <b class="spoiler_title">Growler hello world</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> asyncio <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> growler <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> App <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> growler.middleware <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> (Logger, Static, Renderer) loop = asyncio.get_event_loop() app = App(<span class="hljs-string"><span class="hljs-string">'GrowlerServer'</span></span>, loop=loop) <span class="hljs-comment"><span class="hljs-comment">#   middleware  app.use(Logger()) app.use(Static(path='public')) @app.get('/') def index(req, res): res.render("home") Server = app.create_server(host='127.0.0.1', port=8000) loop.run_forever()</span></span></code> </pre> </div></div><br><p>  <a href="https://github.com/Parkayun/astrid">astrid</a> - A simple <code>flask</code> like <code>framework</code> based on <code>aiohttp</code> . </p><br><div class="spoiler">  <b class="spoiler_title">Example</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> astrid <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Astrid <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> astrid.http <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> render, response @app.route(<span class="hljs-string"><span class="hljs-string">'/'</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">index_handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(request)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> response(<span class="hljs-string"><span class="hljs-string">"Hello"</span></span>) app.run()</code> </pre> </div></div><br><h3><a name="1"></a>  <font color="orange">1. Structure</font> </h3><br><p>  So, we should have the library itself, which we want to install using <code>pip install</code> and in which there should be modules or batteries included in the composition - for example, an admin or a web store.  And there should be a project that we create in some place where the developer should be able to add their modules with different functionality. <br>  In each component of both the project and the library itself there should be a folder with statics and a folder with templates, a file with a list of routes and a file or a file with requests to the database and outputting all this to templates. </p><br><p>  If needed, <code>python 3.5</code> installed like this: </p><br><pre> <code class="bash hljs">sudo add-apt-repository ppa:fkrull/deadsnakes sudo apt-get update sudo apt-get install python3.5 python3.5-dev</code> </pre> <br><p>  Library - installed via <code>pip3 install</code> : </p><br><pre> <code class="python hljs">apps-&gt; app-&gt; static templ view.py routes.py app1-&gt; ... app2-&gt; ... core-&gt; core.py union.py utils.py</code> </pre> <br><p>  An example of a project - there may be as many as you like, ideally for each site its own: </p><br><pre> <code class="python hljs">apps-&gt; app-&gt; static templ view.py routes.py app1-&gt; ... app2-&gt; ... static templ view.py route.py settings.py</code> </pre> <br><p>  The content of the files with the list of routes we want to see approximately like this: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> core.union <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> route route(<span class="hljs-string"><span class="hljs-string">'GET'</span></span> , <span class="hljs-string"><span class="hljs-string">'/'</span></span>, page ) route( <span class="hljs-string"><span class="hljs-string">'GET'</span></span> , <span class="hljs-string"><span class="hljs-string">'/db'</span></span>, test_db )</code> </pre> <br><p>  And <code>view</code> where these routes are processed of this type: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">page</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(request)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> templ(<span class="hljs-string"><span class="hljs-string">'index'</span></span>, request, {<span class="hljs-string"><span class="hljs-string">'key'</span></span>:<span class="hljs-string"><span class="hljs-string">'val'</span></span>})</code> </pre> <br><p>  That is, everything looks quite simple and quite comfortable, except for the optional need to write a call to the coroutine <code>@asyncio.coroutine</code> or <code>async def</code> every time. </p><br><h3><a name="2"></a>  <font color="orange">2. aiohttp, jinja2 and debugger</font> </h3><br><p>  For <code>aiohttp</code> there is a specially written debugger and asynchronous wrapper for <code>jinja2</code> .  We will use them. </p><br><pre> <code class="python hljs">pip3 install aiohttp_jinja2</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">A simple jinja2 connection looks like this:</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> asyncio, jinja2, aiohttp_jinja2 <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> aiohttp <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> web <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">page</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(req)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> aiohttp_jinja2.render_template(<span class="hljs-string"><span class="hljs-string">'index.tpl'</span></span>, req,{<span class="hljs-string"><span class="hljs-string">'k'</span></span>:<span class="hljs-string"><span class="hljs-string">'v'</span></span>}) <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(loop)</span></span></span><span class="hljs-function">:</span></span> app = web.Application(loop=loop) aiohttp_jinja2.setup(app, loader=jinja2.FileSystemLoader(<span class="hljs-string"><span class="hljs-string">'./'</span></span>)) app.router.add_route(<span class="hljs-string"><span class="hljs-string">'GET'</span></span>, <span class="hljs-string"><span class="hljs-string">'/'</span></span>, page) srv = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> loop.create_server(app.make_handler(), <span class="hljs-string"><span class="hljs-string">'127.0.0.1'</span></span>, <span class="hljs-number"><span class="hljs-number">80</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> srv app = web.Application() loop = asyncio.get_event_loop() loop.run_until_complete(init(loop)) <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: loop.run_forever() <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> KeyboardInterrupt: <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span></code> </pre> </div></div><br><p>  But we need to call templates from different places and preferably as simple as possible, for example: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> templ(<span class="hljs-string"><span class="hljs-string">'index'</span></span>, request, {<span class="hljs-string"><span class="hljs-string">'key'</span></span>:<span class="hljs-string"><span class="hljs-string">'val'</span></span>})</code> </pre> <br><p>  And for the template itself, you need to somehow abbreviate the path.  Places where templates can be stored may be several pieces: </p><br><ol><li>  Templates in the `templ` folder at the root of the project itself. </li><li>  Templates that lie in the project modules or library modules. </li></ol><br><p>  Therefore, conditionally agree that if the templates are in the root of any project, then the name of the template will be simply indicated, for example, <code>'template'</code> .  And templates from modules will look like this: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> templ(<span class="hljs-string"><span class="hljs-string">"apps.app:template"</span></span>, request, {<span class="hljs-string"><span class="hljs-string">'key'</span></span>:<span class="hljs-string"><span class="hljs-string">'val'</span></span>})</code> </pre> <br><p>  where the <code>app</code> component and <code>template</code> template. </p><br><p>  Therefore, in the place where we initialize the paths, connecting the templates we call the function that will collect all the paths to the directories where the templates are located: </p><br><pre> <code class="python hljs">aiohttp_jinja2.setup(app, loader=jinja2.FunctionLoader ( load_templ ) )</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">General listing of functions that collect templates:</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_path</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(app)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> type(app) == str: __import__(app) app = sys.modules[app] <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> os.path.dirname(os.path.abspath(app.__file__)) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_templ_path</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(path)</span></span></span><span class="hljs-function">:</span></span> module_name = <span class="hljs-string"><span class="hljs-string">''</span></span>; module_path = <span class="hljs-string"><span class="hljs-string">''</span></span>; file_name = <span class="hljs-string"><span class="hljs-string">''</span></span>; name_templ = <span class="hljs-string"><span class="hljs-string">'default'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-string"><span class="hljs-string">':'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> path: module_name, file_name = path.split(<span class="hljs-string"><span class="hljs-string">":"</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-comment"><span class="hljs-comment"># app.table main module_path = os.path.join( get_path( module_name), "templ") else: module_path = os.path.join( os.getcwd(), 'templ', name_templ) return module_name, module_path, file_name+'.tpl' def render_templ(t, request, p): #      =  p = dict(**p) return aiohttp_jinja2.render_template( t, request, p ) def load_templ(t, **p): (module_name, module_path, file_name) = get_templ_path(t) def load_template (module_path, file_name): path = os.path.join(module_path, file_name) template = '' filename = path if os.path.exists ( path ) else False if filename: with open(filename, "rb") as f: template = f.read() return template template = load_template( module_path, file_name) if not template: return 'Template not found {}' .format(t) return template.decode('UTF-8')</span></span></code> </pre> </div></div><br><p>  Here I would like to focus on the sequence of actions: <br>  1) We parse our template path, for example, <code>'apps.app:index'</code> , simply check that if there is a <code></code> in the path, then the templates are not taken from the root of the project, and then we call the function to search for paths from imports: </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_path</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(app)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> type(app) == str: <span class="hljs-comment"><span class="hljs-comment">#    .    "news". __import__(app) #   "news"     news     app app = sys.modules[app] #      return os.path.dirname(os.path.abspath(app.__file__))</span></span></code> </pre> <br><p>  2) Knowing the path and name of the template, we read it from the disk (I note that <code>asyncio</code> does not support asynchronous read operations from disk): </p><br><pre> <code class="python hljs">filename = path <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> os.path.exists ( path ) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> filename: <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(filename, <span class="hljs-string"><span class="hljs-string">"rb"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> f: template = f.read()</code> </pre> <br><p>  Here I would like to note one thing, often in the examples for connecting to jinja2, including in <a href="http_jinja2">aiohttp_jinja2,</a> it is recommended to use <code>FileSystemLoader</code> for initialization simply by passing a path or a list of paths to it, for example: <br> <code>aiohttp_jinja2.setup(app, loader=jinja2.FileSystemLoader('/templ/'))</code> <br>  And in our case, we used <code>FunctionLoader</code> : <br> <code>aiohttp_jinja2.setup(app, loader=jinja2.FunctionLoader ( load_templ ) )</code> <br>  This is due to the fact that we want to store templates in different directories, for different modules, and not worry about the same names.  And in the case of the <code>FunctionLoader</code> we go only along the necessary paths.  As a result, our modules have independent namespaces. </p><br><p>  In order to write in the template call abbreviated <code>templ</code> we write a small wrapper and assign it to <code>builtins.templ</code> , after which we can call <code>templ</code> from any place without importing it permanently: </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">render_templ</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(t, request, p)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> aiohttp_jinja2.render_template( t, request, p ) builtins.templ = render_templ</code> </pre> <br><h4>  aiohttp_debugtoolbar </h4><br><p>  <code>aiohttp_debugtoolbar</code> - connects quite easily, where we initialize our <code>app</code> : </p><br><pre> <code class="python hljs">app = web.Application(loop=loop, middlewares=[ aiohttp_debugtoolbar.middleware ]) aiohttp_debugtoolbar.setup(app)</code> </pre> <br><p>  It connects through a very <code>middleware</code> , how to write your own will talk a little lower. </p><br><p>  The <code>aiohttp_debugtoolbar</code> itself has a pleasant impression on me, and everything I need is present, a few screenshots: </p><br><img src="https://habrastorage.org/files/a64/b1b/f1a/a64b1bf1a56044f0830fa44be5404a16.png"><br><div class="spoiler">  <b class="spoiler_title">More in the spoiler</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/501/8e4/a55/5018e4a556744ece9942da8e8d63ceae.png"><br><img src="https://habrastorage.org/files/620/7ba/4e9/6207ba4e97bd4850ba3a291a37ce2364.png"><br><img src="https://habrastorage.org/files/3b7/14d/3bf/3b714d3bfa62425cad92c5681da33ee3.png"><br><img src="https://habrastorage.org/files/99f/b77/0c0/99fb770c0b4d4deaa839c809a643d7b1.png"></div></div><br><h3><a name="3"></a>  <font color="orange">3. aiohttp and routes</font> </h3><br><p>  In <code>aiohttp</code> routes look quite simple, an example from the documentation with obtaining a dynamic parameter from the address: </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">@asyncio.coroutine def variable_handler(request): return web.Response( text="Hello, {}".format(request.match_info['name'])) app = web.Application() app.router.add_route('GET', '/{name}', variable_handler)</span></span></code> </pre> <br><p>  But since we have a modular system, we need to call our routes in each module in our <code>routes.py</code> .  And it is desirable to simplify it as much as possible, for example: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> core <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> route route(<span class="hljs-string"><span class="hljs-string">'GET'</span></span>, <span class="hljs-string"><span class="hljs-string">'/'</span></span>, page, <span class="hljs-string"><span class="hljs-string">'page'</span></span> ) route(<span class="hljs-string"><span class="hljs-string">'GET'</span></span>, <span class="hljs-string"><span class="hljs-string">'/db'</span></span>, test_db, <span class="hljs-string"><span class="hljs-string">'test_db'</span></span> )</code> </pre> <br><p>  There will have to use a global variable, although it is not very kosher.  The <code>route</code> function has a simple view: </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">route</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(t, r, func, name=None)</span></span></span><span class="hljs-function">:</span></span> routes.append((t, r, func, name))</code> </pre> <br><p>  In the global variable, which is a list, we put tuples of the values ‚Äã‚Äãof each route.  And then during the initialization we simply go through all the tuples and in the authentic call of the route: </p><br><pre> <code class="python hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> res <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> routes: name = res[<span class="hljs-number"><span class="hljs-number">3</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> name <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: name = <span class="hljs-string"><span class="hljs-string">'{}:{}'</span></span>.format(res[<span class="hljs-number"><span class="hljs-number">0</span></span>], res[<span class="hljs-number"><span class="hljs-number">2</span></span>]) app.router.add_route( res[<span class="hljs-number"><span class="hljs-number">0</span></span>], res[<span class="hljs-number"><span class="hljs-number">1</span></span>], res[<span class="hljs-number"><span class="hljs-number">2</span></span>], name=name)</code> </pre> <br><p>  Naturally, before going through all the routes we need to initialize the paths where the <code>routes.py</code> files are <code>routes.py</code> .  We do this using a function that looks like this in a simplified form: </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">union_routes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( dir=settings.root )</span></span></span><span class="hljs-function">:</span></span> name_app = dir.split(os.path.sep) name_app = name_app[len(name_app) - <span class="hljs-number"><span class="hljs-number">1</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> name <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> os.listdir(dir): path = os.path.join(dir, name) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> os.path.isdir ( path ) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> os.path.isfile ( os.path.join( path, <span class="hljs-string"><span class="hljs-string">'routes.py'</span></span> )): name = name_app+<span class="hljs-string"><span class="hljs-string">'.'</span></span>+path[len(dir)+<span class="hljs-number"><span class="hljs-number">1</span></span>:]+<span class="hljs-string"><span class="hljs-string">'.routes'</span></span> builtins.__import__(name, globals=globals())</code> </pre> <br><h3><a name="4"></a>  <font color="orange">4. Return statics</font> </h3><br><p>  Of course, by normal statics it is better to give using <code>nginx</code> but our framework should also be able to give statics. <br>  <code>aiohttp</code> already <a href="&amp;xid=17259,15700021,15700043,15700186,15700191,15700253&amp;usg=ALkJrhjtdtPyDbHlt0kcNrXZKIaHO-YNpQ#aio">had</a> a static return function, but it was noticed a little later than necessary and its own function was already written. <br>  Static files will be recognized by route <code>/static/path</code> .  Those files that are located in the project root will be recognized by the path <code>/static/static/file_name</code> , and files in the components <code>/static/modul_name/file_name</code> . </p><br><p>  Naturally, all static files will be in the <code>/static</code> folders of any module or project, and may have any number of nestings, say <code>/static/img/big_img/</code> . </p><br><p>  We begin to implement, as always, with initialization.  Here we are just one route serving all the main types of static addresses. </p><br><pre> <code class="python hljs">app.router.add_route(<span class="hljs-string"><span class="hljs-string">'GET'</span></span>, <span class="hljs-string"><span class="hljs-string">'/static/{component:[^/]+}/{fname:.+}'</span></span>, union_stat)</code> </pre> <br><p>  Further in the <code>union_stat</code> function <code>union_stat</code> we simply parse the parameters of the route <code>{component:[^/]+}/{fname:.+}</code> Which received: </p><br><pre> <code class="python hljs">component = request.match_info.get(<span class="hljs-string"><span class="hljs-string">'component'</span></span>, <span class="hljs-string"><span class="hljs-string">"st"</span></span>) fname = request.match_info.get(<span class="hljs-string"><span class="hljs-string">'fname'</span></span>, <span class="hljs-string"><span class="hljs-string">"st"</span></span>)</code> </pre> <br><p>  And form the appropriate path. </p><br><p>  After that, in another auxiliary function, we create the headers we need for the files, for example: </p><br><pre> <code class="python hljs">mimetype, encoding = mimetypes.guess_type(filename) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> mimetype: headers[<span class="hljs-string"><span class="hljs-string">'Content-Type'</span></span>] = mimetype <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> encoding: headers[<span class="hljs-string"><span class="hljs-string">'Content-Encoding'</span></span>] = encoding</code> </pre> <br><p>  And we read the file itself from the disk. <br>  At the end, we return the headers and the file itself: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> web.Response( body=content, headers=MultiDict( headers ) )</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Entirely functions look like this:</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">union_stat</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(request, *args)</span></span></span><span class="hljs-function">:</span></span> component = request.match_info.get(<span class="hljs-string"><span class="hljs-string">'component'</span></span>, <span class="hljs-string"><span class="hljs-string">"Anonymous"</span></span>) fname = request.match_info.get(<span class="hljs-string"><span class="hljs-string">'fname'</span></span>, <span class="hljs-string"><span class="hljs-string">"Anonymous"</span></span>) path = os.path.join( settings.root, <span class="hljs-string"><span class="hljs-string">'apps'</span></span>, component, <span class="hljs-string"><span class="hljs-string">'static'</span></span>, fname ) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> component == <span class="hljs-string"><span class="hljs-string">'static'</span></span>: path = os.path.join( os.getcwd(), <span class="hljs-string"><span class="hljs-string">'static'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> os.path.exists( path ): path = os.path.join( os.getcwd(), <span class="hljs-string"><span class="hljs-string">'apps'</span></span>, component, <span class="hljs-string"><span class="hljs-string">'static'</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: path = os.path.join( settings.root, <span class="hljs-string"><span class="hljs-string">'apps'</span></span>, component, <span class="hljs-string"><span class="hljs-string">'static'</span></span>) content, headers = get_static_file(fname, path) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> web.Response(body=content, headers=MultiDict( headers ) ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_static_file</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( filename, root )</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> mimetypes, time root = os.path.abspath(root) + os.sep filename = os.path.abspath(os.path.join(root, filename.strip(<span class="hljs-string"><span class="hljs-string">'/\\'</span></span>))) headers = {} mimetype, encoding = mimetypes.guess_type(filename) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> mimetype: headers[<span class="hljs-string"><span class="hljs-string">'Content-Type'</span></span>] = mimetype <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> encoding: headers[<span class="hljs-string"><span class="hljs-string">'Content-Encoding'</span></span>] = encoding stats = os.stat(filename) headers[<span class="hljs-string"><span class="hljs-string">'Content-Length'</span></span>] = stats.st_size <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> core.core <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> locale_date lm = locale_date(<span class="hljs-string"><span class="hljs-string">"%a, %d %b %Y %H:%M:%S GMT"</span></span>, time.gmtime(stats.st_mtime), <span class="hljs-string"><span class="hljs-string">'en_US.UTF-8'</span></span>) headers[<span class="hljs-string"><span class="hljs-string">'Last-Modified'</span></span>] = str(lm) headers[<span class="hljs-string"><span class="hljs-string">'Cache-Control'</span></span>] = <span class="hljs-string"><span class="hljs-string">'max-age=604800'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(filename, <span class="hljs-string"><span class="hljs-string">'rb'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> f: content = f.read() f.close() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> content, headers</code> </pre> </div></div><br><p>  UPD.  All the same, in the latest version of the library, the return of statics was slightly redone.  Now, static is given by <code>aiohttp</code> , from the <code>static</code> folder in the project root. </p><br><pre> <code class="python hljs">path = os.path.join( os.path.dirname(__file__), <span class="hljs-string"><span class="hljs-string">'static'</span></span>) app.router.add_static(<span class="hljs-string"><span class="hljs-string">'/static/'</span></span>, path, name=<span class="hljs-string"><span class="hljs-string">'static'</span></span>)</code> </pre> <br><p>  In the <code>/static</code> folder, there should be relative links to all folders with statics of all modules, both standard libraries and those that were created in the project.  Relative references are created during the launch of commands to create a project structure or create an application structure. </p><br><pre> <code class="bash hljs">utils.py -p name_project utils.py -a name_app</code> </pre> <br><p>  I will say a few words about <code>POST</code> , <code>GET</code> requests and redirection in <code>aiohttp</code> .  <code>GET</code> requests look pretty standard. </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(request)</span></span></span><span class="hljs-function">:</span></span> query = request.GET[<span class="hljs-string"><span class="hljs-string">'query'</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_post</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(request)</span></span></span><span class="hljs-function">:</span></span> data = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> request.post() filename = data[<span class="hljs-string"><span class="hljs-string">'mp3'</span></span>].filename</code> </pre> <br><p>  Redirect to the address specified in the route <code>'test'</code> with <code>302</code> response </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">redirect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(request)</span></span></span><span class="hljs-function">:</span></span> data = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> request.post() . . . url = request.app.router[<span class="hljs-string"><span class="hljs-string">'test'</span></span>].url() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> web.HTTPFound( url )</code> </pre> <br><p>  <a href="http.readthedocs.org/en/latest/web.html">A list of</a> all the answers. </p><br><h3><a name="6"></a>  <font color="orange">5. aiohttp and websocket</font> </h3><br><p>  One of the most pleasant features of <code>aiohttp</code> is the ability to easily connect web-sites, simply by calling a function in the route that is responsible for processing them.  Without any extra crutches. <br>  For example, <code>app.router.add_route('GET', '/ws', ws)</code> .  If we look at the route from our little wrapper we just wrote, it might look like this: <code>route('GET', '/ws', ws )</code> </p><br><p>  The processing of the web socket software itself looks pretty simple, and let's say writing a small chat by the amount of code is quite succinctly. </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">websocket_handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(request)</span></span></span><span class="hljs-function">:</span></span> ws = web.WebSocketResponse() <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> ws.prepare(request) <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> msg <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ws: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> msg.tp == aiohttp.MsgType.text: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> msg.data == <span class="hljs-string"><span class="hljs-string">'close'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> ws.close() <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: ws.send_str(msg.data + <span class="hljs-string"><span class="hljs-string">'/answer'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> msg.tp == aiohttp.MsgType.error: print(<span class="hljs-string"><span class="hljs-string">'ws connection closed %s'</span></span> % ws.exception()) print(<span class="hljs-string"><span class="hljs-string">'websocket connection closed'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ws</code> </pre> <br><p>  For example, the same is the case with <code>Node.JS</code> , using the <code>ws</code> module: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> WebSocketServer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'ws'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> clients = {}; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> webSocketServer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WebSocketServer.Server({ <span class="hljs-attr"><span class="hljs-attr">port</span></span>: <span class="hljs-number"><span class="hljs-number">8081</span></span> }); webSocketServer.on(<span class="hljs-string"><span class="hljs-string">'connection'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ws</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> id = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.random(); clients[id] = ws; ws.on(<span class="hljs-string"><span class="hljs-string">'message'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">message</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> key <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> clients) { clients[key].send(message); } }); ws.on(<span class="hljs-string"><span class="hljs-string">'close'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'onnection closed '</span></span> + id); <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> clients[id]; }); });</code> </pre> <br><h3><a name="5"></a>  <font color="orange">6. asyncio and mongodb, aiohttp, session, middleware</font> </h3><br><p>  <code>aiohttp</code> has such a great tool as <code>middleware</code> , in different cases this term means slightly different things, so let's look at it using the example of creating a connector to the database. </p><br><p>  Such frameworks as <code>flask</code> or <code>bootle</code> have the ability to call any function before loading the rest or after, for example, in the <code>bootle</code> : </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">@bottle.hook('after_request') def enable_cors(): response.headers['Access-Control-Allow-Origin'] = '*'</span></span></code> </pre> <br><p>  In the case of <code>aiohttp</code> , including for about such cases, <code>middleware</code> was invented. <br>  So, we want to write database requests as simple as possible, <code>request.db</code> : </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_db</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(request)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> templ(<span class="hljs-string"><span class="hljs-string">'apps.app:db_test'</span></span>, request, { <span class="hljs-string"><span class="hljs-string">'key'</span></span>: request.db.doc.find_one({<span class="hljs-string"><span class="hljs-string">"_id"</span></span>:<span class="hljs-string"><span class="hljs-string">"test"</span></span>}) })</code> </pre> <br><p>  To do this, we will create <code>middleware</code> and initialize it at the very beginning, this is done quite simply, an example with an already initialized debager, sessions and base. </p><br><pre> <code class="python hljs">app = web.Application(loop=loop, middlewares=[ aiohttp_debugtoolbar.middleware, db_handler(), session_middleware(EncryptedCookieStorage(<span class="hljs-string"><span class="hljs-string">b'Secret byte key'</span></span>)) ])</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Well, the factory itself</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">db_handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">factory</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(app, handler)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">middleware</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(request)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> request.path.startswith(<span class="hljs-string"><span class="hljs-string">'/static/'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> request.path.startswith(<span class="hljs-string"><span class="hljs-string">'/_debugtoolbar'</span></span>): response = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> handler(request) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> response <span class="hljs-comment"><span class="hljs-comment">#  db_inf = settings.database kw = {} if 'rs' in db_inf: kw['replicaSet'] = db_inf['rs'] from pymongo import MongoClient mongo = MongoClient( db_inf['host'], 27017) db = mongo[ db_inf['name'] ] db.authenticate('admin', settings.database['pass'] ) request.db = db #   (      ) response = await handler(request) mongo.close() #         return response return middleware return factory</span></span></code> </pre> </div></div><br><p>  What I would like to draw attention to, since the <code>middleware</code> responds to every server request, first of all, we check that the <code>request</code> does not contain the address at which we get the static, as well as the address at which the debugger is called.  In order for each request not to pull the base. </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">middleware</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(request)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> request.path.startswith(<span class="hljs-string"><span class="hljs-string">'/static/'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> request.path.startswith(<span class="hljs-string"><span class="hljs-string">'/_debugtoolbar'</span></span>): ```     : ```python mongo = MongoClient( db_inf[<span class="hljs-string"><span class="hljs-string">'host'</span></span>], <span class="hljs-number"><span class="hljs-number">27017</span></span>)</code> </pre> <br><p>  And at the end we close the connection: </p><br><pre> <code class="python hljs">mongo.close()</code> </pre> <br><p>  Everything looks quite simple, some utilities from the author <code>aiohttp</code> <a href="https://habrahabr.ru/users/svetlov/" class="user_link">svetlov are</a> initialized and created in a similar way through <code>middleware</code> . </p><br><p>  Well, then in more detail it is necessary to stop at the driver for <code>mongodb</code> .  Unfortunately, it is not yet asynchronous, it is more correct to say that the asynchronous driver is <a href="https://bitbucket.org/mrdon/asyncio-mongo/src/838bc8849e5a30973aef213a54722909906d0032%3Fat%3Dmaster">there,</a> but it has long been abandoned and leaves much to be desired, and there is no <code>gridFS</code> support, no <code>pymongo</code> innovations <code>pymongo</code> and so on. </p><br><p>  But still, progress does not stand still and <code>PyMongo</code> developer and at the same time an asynchronous driver for <code>MongoDB</code> for <code>Tornado</code> , <code>Motor</code> - <a href="http://emptysqua.re/blog/all-posts/">A. Jesse Jiryu Davis is</a> actively working on <a href="http://emptysqua.re/blog/motor-and-asyncio-update/">integrating</a> <code>Asyncio</code> into <code>Motor</code> .  And already promises this fall to release version <code>0.5</code> with support for <code>Asyncio</code> . </p><br><h3><a name="7"></a>  <font color="orange">7. aiohttp, supervisor, nginx, gunicorn</font> </h3><br><p>  <code>aiohttp</code> are several ways to run <code>aiohttp</code> : </p><br><ol><li>  `aiohttp` is better to simply run from the console if we are developing, and using` supervisor` if production. </li><li>  Start using `gunicorn` and` supervisor`. </li></ol><br><p>  I think for both cases, in a simplified version, the <code>nginx</code> configuration is suitable as a <code>proxy</code> , although <code>gunicorn</code> can be launched via a socket if desired. </p><br><pre> <code class="nginx hljs"><span class="hljs-section"><span class="hljs-section">server</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">server_name</span></span> test.dev; <span class="hljs-attribute"><span class="hljs-attribute">location</span></span> / { <span class="hljs-attribute"><span class="hljs-attribute">proxy_pass</span></span> http://127.0.0.1:8080; } }</code> </pre> <br><h4>  Aiohttp and supervisor </h4><br><p>  Install supervisor: </p><br><pre> <code class="bash hljs">apt install supervisor</code> </pre> <br><p>  In <code>/etc/supervisor/conf.d/</code> create the <code>/etc/supervisor/conf.d/</code> file and in it: </p><br><pre> <code class="bash hljs">[program:aio] <span class="hljs-built_in"><span class="hljs-built_in">command</span></span>=python3 index.py directory=/path/to/project/ user=nobody autorestart=<span class="hljs-literal"><span class="hljs-literal">true</span></span> redirect_stderr=<span class="hljs-literal"><span class="hljs-literal">true</span></span></code> </pre> <br><p>  After that we update configs of all applications, without restarting. </p><br><pre> <code class="bash hljs">supervisorctl reread &gt;&gt;aio: available &gt;&gt;erp: changed</code> </pre> <br><p>      : </p><br><pre> <code class="bash hljs">supervisorctl update &gt;&gt;erp: stopped &gt;&gt;erp: updated process group &gt;&gt;aio: added process group</code> </pre> <br><p>   : </p><br><pre> <code class="bash hljs">supervisorctl status &gt;&gt;aio RUNNING pid 31570, uptime 0:06:49 &gt;&gt;erp FATAL Exited too quickly (process <span class="hljs-built_in"><span class="hljs-built_in">log</span></span> may have details)</code> </pre> <br><div class="spoiler"> <b class="spoiler_title">      aiohttp</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> asyncio <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> aiohttp <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> web <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(request)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {<span class="hljs-string"><span class="hljs-string">'title'</span></span>: <span class="hljs-string"><span class="hljs-string">'Hello'</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(loop)</span></span></span><span class="hljs-function">:</span></span> app = web.Application( loop = loop ) app.router.add_route(<span class="hljs-string"><span class="hljs-string">'GET'</span></span>, <span class="hljs-string"><span class="hljs-string">'/'</span></span>, basic_handler, name=<span class="hljs-string"><span class="hljs-string">'index'</span></span>) handler = app.make_handler() srv = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> loop.create_server(handler, <span class="hljs-string"><span class="hljs-string">'127.0.0.1'</span></span>, <span class="hljs-number"><span class="hljs-number">8080</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> srv, handler loop = asyncio.get_event_loop() srv, handler = loop.run_until_complete( init( loop ) ) <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: loop.run_forever() <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> KeyboardInterrupt: loop.run_until_complete(handler.finish_connections())</code> </pre> </div></div><br><p>      ,       <code>sys.path</code>   : </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#   sys.path.append( settings.root ) #   sys.path.append( os.path.dirname( __file__ ) )</span></span></code> </pre> <br><h4> Aiohttp gunicorn  supervisor </h4><br><p>       <code>gunicorn</code>   ,           <code>index</code> ,  . </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> aiohttp <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> web <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">index</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(request)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> web.Response(text=<span class="hljs-string"><span class="hljs-string">"Hello!"</span></span>) app = web.Application() app.router.add_route(<span class="hljs-string"><span class="hljs-string">'GET'</span></span>, <span class="hljs-string"><span class="hljs-string">'/'</span></span>, index)</code> </pre> <br><p>       <code>gunicorn</code>     ,        ,     <code>app</code> . </p><br><div class="spoiler"> <b class="spoiler_title"> </b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init_gunicorn</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> app = web.Application( middlewares=[ aiohttp_debugtoolbar.middleware, db_handler(), session_middleware(EncryptedCookieStorage(<span class="hljs-string"><span class="hljs-string">b'Sixteen byte key'</span></span>)) ]) aiohttp_debugtoolbar.setup(app) aiohttp_jinja2.setup(app, loader=jinja2.FunctionLoader ( load_templ ) ) union_routes(os.path.join ( settings.root, <span class="hljs-string"><span class="hljs-string">'apps'</span></span> ) ) union_routes(os.path.join ( os.getcwd(), <span class="hljs-string"><span class="hljs-string">'apps'</span></span> ) ) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> res <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> routes: app.router.add_route( res[<span class="hljs-number"><span class="hljs-number">2</span></span>], res[<span class="hljs-number"><span class="hljs-number">0</span></span>], res[<span class="hljs-number"><span class="hljs-number">1</span></span>], name=res[<span class="hljs-number"><span class="hljs-number">3</span></span>]) app.router.add_route(<span class="hljs-string"><span class="hljs-string">'GET'</span></span>, <span class="hljs-string"><span class="hljs-string">'/static/{component:[^/]+}/{fname:.+}'</span></span>, union_stat) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> app</code> </pre> </div></div><br><p>         <code>gunicorn</code>    </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sys, os, settings sys.path.append( settings.root ) sys.path.append( os.path.dirname( __file__ ) ) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> core.union <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> init_gunicorn app = init_gunicorn()</code> </pre> <br><p>      gunicorn     </p><br><pre> <code class="bash hljs">&gt;&gt; gunicorn app:app -k aiohttp.worker.GunicornWebWorker -b localhost:8080</code> </pre> <br><p>          <code>supervisor</code> . </p><br><p>   <code>gunicorn</code>  <code>supervisor</code>     ,       gunicorn.conf.py  : </p><br><pre> <code class="bash hljs">worker_class =<span class="hljs-string"><span class="hljs-string">'aiohttp.worker.GunicornWebWorker'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">bind</span></span>=<span class="hljs-string"><span class="hljs-string">'127.0.0.1:8080'</span></span> workers=8 reload=True user = <span class="hljs-string"><span class="hljs-string">"nobody"</span></span></code> </pre> <br><p>  <code>/etc/supervisor/conf.d/name.conf</code> : </p><br><pre> <code class="bash hljs">[program:name] <span class="hljs-built_in"><span class="hljs-built_in">command</span></span>=/usr/<span class="hljs-built_in"><span class="hljs-built_in">local</span></span>/bin/gunicorn app:app -c /path/to/project/gunicorn.conf.py directory=/path/to/project/ user=nobody autorestart=<span class="hljs-literal"><span class="hljs-literal">true</span></span> redirect_stderr=<span class="hljs-literal"><span class="hljs-literal">true</span></span></code> </pre> <br><p>  : </p><br><pre> <code class="bash hljs">supervisorctl reread supervisorctl update</code> </pre> <br><br><h3><a name="8"></a> <font color="orange">8.  ,  .</font> </h3><br><p>       </p><br><pre> <code class="bash hljs">pip3 install tao1</code> </pre> <br><p>               .. <br>  <code>utils.py -p name</code>          , ,  <code>-p</code>   <code>--project</code>  <code>--startProject</code> . <br>  <code>utils.py -a name</code>     <code>apps</code>         <code>-a</code>    <code>--app</code>  <code>--startApp</code> ;-) </p><br><p>  <code>utils.py</code>   . <br>      . <br>    <code>argparse</code>     : </p><br><pre> <code class="python hljs">parser = argparse.ArgumentParser() parser.add_argument(<span class="hljs-string"><span class="hljs-string">'-project'</span></span>, <span class="hljs-string"><span class="hljs-string">'-startproject'</span></span>, <span class="hljs-string"><span class="hljs-string">'-p'</span></span>, type=str, help=<span class="hljs-string"><span class="hljs-string">'Create project'</span></span> ) parser.add_argument(<span class="hljs-string"><span class="hljs-string">'-app'</span></span>, <span class="hljs-string"><span class="hljs-string">'-startapp'</span></span>, <span class="hljs-string"><span class="hljs-string">'-a'</span></span>, type=str, help=<span class="hljs-string"><span class="hljs-string">'Create app'</span></span> ) args = parser.parse_args() ```              : ```python <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> shutil shutil.copytree( os.path.join( os.path.dirname(__file__), <span class="hljs-string"><span class="hljs-string">'sites'</span></span>, <span class="hljs-string"><span class="hljs-string">'test'</span></span>), str(args.project) )</code> </pre> <br><p>    <code>setup.py</code>         <br> <a href="https://pypi.python.org/">https://pypi.python.org/</a>  <code>scripts=['tao1/core/utils.py']</code> . <br>      utils.py    <code>/usr/local/bin/</code> (   ubuntu)   . </p><br><h3><a name="9"></a> <font color="orange">9. Road map</font> </h3><br><h4>  0.2 ‚Äî 0.5 </h4><br><ul><li>  (   memcached). </li><li> . </li><li>     - . </li><li>  .       . </li><li>          . </li></ul><br><p>   ,      ,    ,     , ,  <code>php</code>  <code>Node</code> ,    . , ,     . </p><br><p> PS     . ,            ,    ,   .            <code>Asyncio</code>   .               . </p><br><p>        . </p><br><p>   <a href="https://github.com/alikzao/tao1">github</a> <br> <a href="http://tao1.readthedocs.org/">  readthedocs</a> </p><br><p>  <a href="https://habrahabr.ru/post/252575/">The second part of</a> <a href="https://habrahabr.ru/post/252575/"><br></a> </p><br><p>  : </p><br><p> <a href="https://www.python.org/dev/peps/pep-0492/">pep-0492</a> <br> <a href="http://asvetlov.blogspot.com/"></a> <a href="https://habrahabr.ru/users/svetlov/" class="user_link">svetlov</a>  aiohttp <br> <a href="http/tree/master/docs">  aiohttp  github</a> <br> <a href="http.readthedocs.org/">  aiohttp  readthedocs</a> <br> <a href="http-jinja2.readthedocs.org/en/stable/">  aiohttp-jinja2 readthedocs</a> <br> <a href="https://docs.python.org/3/whatsnew/3.3.html">  yield from</a> <br> <a href="http_session">aiohttp_session</a> <br> <a href="https://github.com/mongodb/motor"> </a> <br> <a href="https://github.com/aio-libs">aio-libs ‚Äî  </a> <br> <a href="http://asyncio.org/">    </a> </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/242541/">https://habr.com/ru/post/242541/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../242531/index.html">Scheme> board> FPGA</a></li>
<li><a href="../242533/index.html">We write code C on Cython</a></li>
<li><a href="../242535/index.html">Ricochet - anonymous serverless instant messaging protocol</a></li>
<li><a href="../242537/index.html">6 A / B tests that you can conduct today (and get results)</a></li>
<li><a href="../242539/index.html">David Chappell about the clouds and the future development</a></li>
<li><a href="../242543/index.html">Detailed description of development capabilities with Microsoft Azure Cloud Services</a></li>
<li><a href="../242545/index.html">Practical application of FlexBox</a></li>
<li><a href="../242547/index.html">Dagaz: A new beginning</a></li>
<li><a href="../242557/index.html">DaData.ru calculates coordinates, and the address parser wags its tail</a></li>
<li><a href="../242559/index.html">Top 5 ORM for Android</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>