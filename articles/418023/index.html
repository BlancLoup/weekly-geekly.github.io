<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Pointers in C are more abstract than they might seem.</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A pointer refers to a memory cell, and dereferencing a pointer means reading the value of the specified cell. The value of the pointer itself is the a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Pointers in C are more abstract than they might seem.</h1><div class="post__text post__text-html js-mediator-article">  A pointer <i>refers</i> to a memory cell, and <i>dereferencing a</i> pointer means reading the value of the specified cell.  The value of the pointer itself is the address of the memory cell.  The C language standard does not specify a form for representing memory addresses.  This is a very important point, since different architectures may use different addressing models.  Most modern architectures use linear address space or similar.  However, even this question is not strictly stipulated, since addresses can be physical or virtual.  Some architectures use a non-numeric representation altogether.  So, Symbolics Lisp Machine operates with tuples of the form <i>(object, offset)</i> as addresses. <br><a name="habracut"></a><table><tbody><tr><td>  After some time, after the publication of the translation on Habr√©, the author made major modifications to the text of the article.  Updating the translation on Habr√© is not a good idea, as some comments will lose their meaning or will look inappropriate.  I do not want to publish the text as a new article either.  Therefore, we just <a href="https://www.viva64.com/ru/b/0576/">updated the translation of the article</a> on the website viva64.com, and here we left everything as is.  If you are a new reader, then I suggest reading a more recent translation on our website by clicking on the link above. </td></tr></tbody></table><br>  The standard does not specify the presentation of pointers, but specifies - to a greater or lesser extent - operations with them.  Below we consider these operations and the features of their definition in the standard.  Let's start with the following example: <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; int main(void) { int a, b; int *p = &amp;a; int *q = &amp;b + 1; printf("%p %p %d\n", (void *)p, (void *)q, p == q); return 0; }</span></span></span></span></code> </pre> <br>  If we compile this GCC code with optimization level 1 and run the program under Linux x86-64, it will print the following: <br><br><pre> <code class="cpp hljs"><span class="hljs-number"><span class="hljs-number">0x7fff4a35b19c</span></span> <span class="hljs-number"><span class="hljs-number">0x7fff4a35b19c</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre> <br>  Note that the <i>p</i> and <i>q</i> pointers refer to the same address.  However, the result of the expression <i>p == q</i> is <i>false</i> , and it seems strange at first glance.  Shouldn't the two pointers to the same address be equal? 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Here is how the C standard defines the result of testing two pointers to equality: <br><table><tbody><tr><td>  <b>C11 ¬ß 6.5.9 paragraph 6</b> <br><br>  Two pointers are equal if and only if both are zero, or point to the same object (including the object pointer and the first subobject in the object) or function, or point to the position behind the last element of the array, or one pointer refers to the position after the last element of the array, and the other to the beginning of another array, immediately following the first in the same address space. </td></tr></tbody></table><br>  First of all, the question arises: what is an ‚Äúobject <i>‚Äù</i> ?  Since we are talking about the C language, it is obvious that objects here have nothing to do with objects in OOP languages ‚Äã‚Äãlike C ++.  In standard C, this concept is not defined quite strictly: <br><table><tbody><tr><td>  <b>C11 ¬ß 3.15</b> <br><br>  An object is a storage area in a runtime environment, the contents of which can be used to represent values. <br><br>  NOTE When referred to, an object may be considered to be of a specific type;  see 6.3.2.1. </td></tr></tbody></table><br>  Let's figure it out.  A 16-bit integer variable is a set of in-memory data that can represent 16-bit integer values.  Therefore, such a variable is an object.  Will the two pointers be equal if one of them refers to the first byte of the given integer, and the second to the second byte of the same number?  The Committee for the Standardization of Language, of course, did not mean this at all.  But here it should be noted that on this account he does not have clear explanations, and we are forced to guess what was really meant. <br><br><h3>  When the compiler gets in the way </h3><br>  Let's return to our first example.  Pointer <i>p is</i> obtained from object <i>a</i> , and pointer <i>q</i> is from object <i>b</i> .  In the second case, address arithmetic is applied, which is defined for the plus and minus operators as follows: <br><table><tbody><tr><td>  <b>C11 ¬ß 6.5.6 clause 7</b> <br><br>  When used with these statements, a pointer to an object that is not an element of an array behaves like a pointer to the beginning of an array of one element in length, the type of which corresponds to the type of the original object. </td></tr></tbody></table><br>  Since any pointer to an object that is not an array <i>actually</i> becomes a pointer to an array of one element in length, the standard defines address arithmetic only for pointers to arrays ‚Äî this is item 8. We are interested in its next part: <br><table><tbody><tr><td>  <b>C11 ¬ß 6.5.6 clause 8</b> <br><br>  If an integer expression is added to or subtracted from the pointer, the resulting pointer is of the same type as the original pointer.  If the source pointer refers to an element of the array and the array is of sufficient length, then the source and the resulting elements are separated from each other so that the difference between their indices is equal to the value of the integer expression.  In other words, if the expression <i>P</i> points to the i-th element of the array, the expressions <i>(P) + N</i> (or equivalent <i>N + (P)</i> ) and <i>(P) -N</i> (where <i>N</i> is n) indicate respectively (i + n) th and (i ‚àí n) th elements of the array, provided that they exist.  Moreover, if the expression <i>P</i> indicates the last element of the array, then the expression <i>(P) +1</i> indicates the position behind the last element of the array, and if the expression <i>Q</i> indicates the position behind the last element of the array, then the expression <i>(Q) -1</i> indicates the last element array.  If both the source and result pointers refer to elements of the same array or to a position behind the last element of the array, then overflow is excluded;  otherwise, the behavior is undefined.  If the result pointer refers to a position beyond the last element of the array, the unary operator <i>*</i> cannot be applied to it. </td></tr></tbody></table><br>  From this it follows that the result of the expression <i>&amp; b + 1</i> absolutely must be an address, and, therefore, <i>p</i> and <i>q</i> are valid pointers.  Let me remind you how the equality of two pointers in the standard is defined: " <i>Two pointers are equal if and only if [...] one pointer refers to the position behind the last element of the array, and the other to the beginning of another array immediately following the first one in the same address space "</i> (C11 ¬ß 6.5.9 clause 6).  This is what we see in our example.  The pointer q refers to the position behind the object b, immediately followed by the object a referenced by the pointer p.  It turns out, in the GCC bug?  This contradiction was described in 2014 as <a href="https://gcc.gnu.org/bugzilla/show_bug.cgi%3Fid%3D61502">bug # 61502</a> , but the GCC developers do not consider it a bug and therefore are not going to fix it. <br><br>  Linux programmers encountered a similar problem in 2016.  Consider the following code: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _start[]; <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _end[]; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *i = _start; i != _end; ++i) { <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> } }</code> </pre> <br>  Symbols <i>_start</i> and <i>_end</i> set the boundaries of the memory area.  Since they are transferred to an external file, the compiler does not know how the arrays are actually located in memory.  For this reason, he should be careful here and proceed from the assumption that they follow each other in the address space.  However, GCC compiles the loop condition so that it is always true, which makes the loop infinite.  This problem is described here in this <a href="https://lkml.org/lkml/2016/6/25/77">post on LKML</a> - a similar code fragment is used there.  It seems that in this case, the GCC authors still took into account the comments and changed the behavior of the compiler.  At least I could not reproduce this error in the GCC 7.3.1 version under Linux x86_64. <br><br><h3>  Is there a clue in error report # 260? </h3><br>  Our case may clarify bug report <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_260.htm"># 260</a> .  It is more concerned with ambiguous values, but in it you can find a curious comment from the committee: <br><br>  <i>Compiler implementations [...] can also distinguish pointers derived from different objects, even if these pointers have the same set of bits.</i> <br><br>  If this comment is taken literally, then it is logical that the result of the expression <i>p == q</i> is ‚Äúfalse‚Äù, since <i>p</i> and <i>q are</i> obtained from different objects that are not related to each other.  It seems that we are getting closer to the truth - or not?  So far, we have dealt with equality operators, but what about relational operators? <br><br><h3>  The final answer - in relational operators? </h3><br>  The definition of relational operators <i>&lt;</i> , <i>&lt;=</i> , <i>&gt;</i> and <i>&gt; =</i> in the context of comparison of pointers contains one curious idea: <br><table><tbody><tr><td>  <b>C11 ¬ß 6.5.8 clause 5</b> <br><br>  The result of comparing two pointers depends on the relative position of the indicated objects in the address space.  If two pointers to object types refer to the same object, or both refer to the position behind the last element of the same array, then such pointers are equal.  If the referenced objects are members of the same compound object, then pointers to the members of the structure declared later are more pointers to the members declared earlier, and pointers to array elements with large indices are greater than pointers to elements of the same array with smaller indices.  All pointers to members of the same union are equal.  If the expression <i>P</i> points to an element of the array, and the expression <i>Q</i> points to the last element of the same array, then the value of the pointer-expression <i>Q + 1 is</i> greater than the value of the expression <i>P.</i>  In all other cases, the behavior is undefined. </td></tr></tbody></table><br>  According to this definition, the result of the comparison of pointers is determined only if the pointers are obtained from <i>the same</i> object.  Let us show it in two examples. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *p = <span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(<span class="hljs-number"><span class="hljs-number">64</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *q = <span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(<span class="hljs-number"><span class="hljs-number">64</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (p &lt; q) <span class="hljs-comment"><span class="hljs-comment">//   foo();</span></span></code> </pre> <br>  Here, the pointers <i>p</i> and <i>q</i> refer to two different objects that are not related to each other.  Therefore, the result of their comparison is not defined.  But in the following example: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *p = <span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(<span class="hljs-number"><span class="hljs-number">64</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *q = p + <span class="hljs-number"><span class="hljs-number">42</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (p &lt; q) foo();</code> </pre> <br>  pointers <i>p</i> and <i>q</i> refer to the same object and, therefore, are related.  So they can be compared - unless <i>malloc</i> returns a null value. <br><br><h3>  Summary </h3><br>  The C11 standard does not strictly describe pointer comparison.  The most problematic point we encountered was clause 6 ¬ß 6.5.9, where it is explicitly permitted to compare two pointers referring to two different arrays.  This is contrary to the comment from bug report # 260.  However, there we are talking about ambiguous values, and I would not like to build my reasoning on the basis of this commentary alone and interpret it in a different context.  When comparing pointers, relational operators are defined somewhat differently than equality operators ‚Äî namely, relational operators are defined only if both pointers are obtained from <i>the same</i> object. <br><br>  If we ignore the text of the standard and ask ourselves whether it is possible to compare two pointers obtained from two different objects, in any case, the answer is likely to be ‚Äúno‚Äù.  The example at the beginning of the article shows a rather theoretical problem.  Since the variables <i>a</i> and <i>b</i> have an automatic storage time, our assumptions about their placement in memory will be unreliable.  In some cases, we can guess, but it is clear that such code cannot be safely ported, and the meaning of the program can be found only by compiling and running or disassembling the code, which contradicts any serious programming paradigm. <br><br>  However, in general, I am not satisfied with the wording in the C11 standard, and since several people have already encountered this problem, the question remains: why not formulate the rules more clearly? <br><br><h3>  Addition <br>  Pointers to the position after the last element of the array </h3><br>  Regarding the rule on comparison and address arithmetic of pointers to a position behind the last element of an array, very often you can find exceptions to it.  Suppose that a standard would not allow comparing two pointers obtained from <i>the same</i> array, with at least one of them referring to the position at the end of the array.  Then the following code would not work: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> num = <span class="hljs-number"><span class="hljs-number">64</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x[num]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *i = x; i &lt; &amp;x[num]; ++i) { <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> }</code> </pre> <br>  With the help of the loop we go around the entire array <i>x</i> , consisting of 64 elements, i.e.  the loop body must execute exactly 64 times.  But in fact, the condition is checked 65 times - one time more than the number of elements in the array.  In the first 64 iterations, the pointer <i>i</i> always refers to the inside of the array <i>x</i> , while the expression <i>&amp; x [num]</i> always points to the position behind the last element of the array.  At the 65th iteration, the <i>i</i> pointer will also refer to the position beyond the end of the array <i>x</i> , which will cause the loop condition to be false.  This is a convenient way to bypass the entire array, while it relies on an exception to the rule on behavior uncertainty when comparing such pointers.  Note that the standard describes the behavior only when comparing pointers;  their dereference is a separate topic. <br><br>  Is it possible to change our example so that no pointer would refer to the position behind the last element of array <i>x</i> ?  It is possible, but it will be more difficult.  We'll have to change the condition of the loop and disable the increment of the variable <i>i</i> at the last iteration. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> num = <span class="hljs-number"><span class="hljs-number">64</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x[num]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *i = x; i &lt;= &amp;x[num<span class="hljs-number"><span class="hljs-number">-1</span></span>]; ++i) { <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i == &amp;x[num<span class="hljs-number"><span class="hljs-number">-1</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; }</code> </pre> <br>  This code is full of technical subtleties, the fussing with which distracts from the main task.  In addition, an additional branch appeared in the body of the cycle.  So I think it reasonable that the standard allows exceptions when comparing pointers to a position after the last element of an array. <br><br>  <b><i>PVS-Studio command note</i></b> <br><br>  <i>When developing the PVS-Studio code analyzer, we sometimes have to deal with subtle points in order to make diagnostics more accurate or to give detailed advice to our clients.</i>  <i>This article seemed interesting to us, as it touches upon issues in which we ourselves do not feel completely confident.</i>  <i>Therefore, we asked the author to post her translation.</i>  <i>We hope that more C and C ++ programmers will get to know her and understand that everything is not so simple and that when suddenly the analyzer gives out a strange message, you should not immediately rush to consider it a false positive :).</i> <br><br>  <i>The article was first <a href="https://stefansf.de/post/pointers-are-more-abstract-than-you-might-expect/"><i>published</i></a> in English on stefansf.de.</i>  <i>Translations are published with the permission of the author.</i> </div><p>Source: <a href="https://habr.com/ru/post/418023/">https://habr.com/ru/post/418023/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../418009/index.html">Node.js and server rendering in Airbnb</a></li>
<li><a href="../418011/index.html">One-page and SEO. Optimization secrets</a></li>
<li><a href="../418013/index.html">The Intel Core i7-8086K (Part 3)</a></li>
<li><a href="../418015/index.html">New Vasyuki. Innovative development of Moscow until 2100</a></li>
<li><a href="../418017/index.html">Analysis of the behavior of the Pegasus Trojan in the network</a></li>
<li><a href="../418025/index.html">The book "Learning Java EE. Modern programming for large enterprises ¬ª</a></li>
<li><a href="../418027/index.html">Microservice blitz</a></li>
<li><a href="../418029/index.html">ReactOS 0.4.9: Hayters will have to look for new arguments</a></li>
<li><a href="../418031/index.html">Mass stacking of ML models in production: is it real or not?</a></li>
<li><a href="../418035/index.html">Introduction to the Timeline in Unity</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>