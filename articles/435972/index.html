<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Introduction to reactive programming in Spring</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hi, Habr! 

 This week we are expecting a new book on Spring 5 from typography: 


 Among the interesting features of Spring 5, reactive programming d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Introduction to reactive programming in Spring</h1><div class="post__text post__text-html js-mediator-article">  Hi, Habr! <br><br>  This week we are expecting a new <a href="https://www.piter.com/collection/soon/product/spring-vse-patterny-proektirovaniya">book</a> on Spring 5 from typography: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ap/o3/tt/apo3ttu5x8fqhvkjyzyrj8g3m2s.jpeg"></div><br>  Among the interesting features of Spring 5, reactive programming deserves special mention, the implementation of which in this framework is briefly described by Matt Raible's proposed article.  In the aforementioned book, reactive patterns are discussed in Chapter 11. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Matt was co-authored by Josh Long, author of another excellent book about Java and Spring, " <a href="https://www.piter.com/product_by_id/112863337">Java in the Cloud,</a> " published last summer. <br><a name="habracut"></a><br>  Reactive programming is your way to creating systems that are resistant to high loads.  Processing huge traffic is no longer a problem, since the server is non-blocking, and client processes do not have to wait for responses.  The client can not directly observe how the program runs on the server, and synchronize with it.  When an API finds it difficult to process requests, it must still give reasonable responses.  Should not refuse and discard messages in an uncontrolled manner.  Must report to the parent components that it is working under load so that they can partially release it from this load.  This technique is called ‚Äúbackpressure‚Äù (backpressure), it is an important aspect of reactive programming. <br><br>  This article we co-wrote with <a href="https://twitter.com/starbuxman">Josh Long</a> .  Josh is a Java champion, Spring Developer Advocate and generally a world guy who works at Pivotal.  I've been working with Spring for a long time, but it was Josh who showed me the Spring Boot, it was at the Devoxx conference in Belgium.  Since then we have become close friends, we are interested in Java and write cool applications. <br><br>  <b>Reactive programming or I / O, I / O, we go to work ...</b> <br><br>  Reactive programming is an approach to software development that actively uses asynchronous I / O.  Asynchronous I / O is a small idea, fraught with big changes in programming.  The idea itself is simple: to remedy the situation with the inefficient allocation of resources, freeing up those resources that would have been wasted without our intervention, waiting for the completion of I / O.  Asynchronous I / O inverts the usual approach to handling I / O: the client is released and may be engaged in other tasks, waiting for new notifications. <br><br>  Consider what is common between synchronous and asynchronous I / O, and what are the differences between them. <br><br>  Let's write a simple program that reads data from a source (specifically, this is a <code>java.io.File</code> reference).  Let's start with an implementation that uses the good old <code>java.io.InputStream</code> : <br><br>  <i>Example 1. Synchronous reading of data from a file</i> <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> com.example.io; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> lombok.extern.log4j.Log4j2; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.springframework.util.FileCopyUtils; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.File; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.FileInputStream; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.IOException; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.function.Consumer; <span class="hljs-meta"><span class="hljs-meta">@Log</span></span>4j2 <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Synchronous</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Reader</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">read</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(File file, Consumer&lt;BytesPayload&gt; consumer)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> (FileInputStream in = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FileInputStream(file)) { <span class="hljs-comment"><span class="hljs-comment">//1 byte[] data = new byte[FileCopyUtils.BUFFER_SIZE]; int res; while ((res = in.read(data, 0, data.length)) != -1) { //2 consumer.accept(BytesPayload.from(data, res)); //3 } } } }</span></span></code> </pre> <br><ol><li>  We provide the file for reading using the usual <code>java.io.File</code> </li><li>  We pull the results from the source one line at a time ... </li><li>  I wrote this code to accept <code>Consumer&lt;BytesPayloadgt;</code>  called when new data arrives </li></ol><br>  Simple enough, what do you say?  Run this code - and you will see in the log output (to the left of each line), indicating that all actions occur in a single stream. <br>  Here we pull the bytes from our data taken from the source (in this case we are talking about a subclass of <code>java.io.FileInputStream</code> , inherited from <code>java.io.InputStream</code> ).  What is wrong with this example?  In this case, we use the InputStream, pointing to the data located in our file system.  If the file is there and the hard disk is functioning, then this code will work as expected. <br><br>  But, what will happen if we read data not from <code>File</code> , but from a network socket, and, moreover, we use another <code>InputStream</code> implementation?  There is nothing to worry about!  Of course, there will be nothing to worry about, if the speed of the network is infinitely great.  And if the network channel between this and another node will never fail.  If these conditions are met, then the code will work perfectly. <br><br>  And what will happen if the network starts to slow down or fall?  In this case, I mean that we will have to increase the time until the return operation <code>in.read(‚Ä¶)</code> .  In fact, she may never return!  This is a problem if we try to do something else with the stream from which we read data.  Of course, you can always create another stream and read data through it.  Up to a certain point, this can be managed, but in the end we will reach the limit at which simply adding flows for further scaling will not be enough.  We will not have true competition over the number of cores that are on our machine.  Dead end!  In this case, we can increase the processing of input / output (here we mean reading) only through additional threads, and here we will sooner or later reach the limit. <br><br>  In this example, the main piece of work falls on reading - almost nothing happens on other fronts.  We are addicted to I / O.  Consider how an asynchronous solution helps us partially overcome the monopolization of our flows. <br><br>  <i>Example 2. Asynchronous data read from file</i> <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> com.example.io; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> lombok.extern.log4j.Log4j2; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.springframework.util.FileCopyUtils; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.File; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.IOException; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.nio.ByteBuffer; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.nio.channels.AsynchronousFileChannel; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.nio.channels.CompletionHandler; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.nio.file.Path; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.nio.file.StandardOpenOption; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.Collections; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.concurrent.ExecutorService; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.concurrent.Executors; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.function.Consumer; <span class="hljs-meta"><span class="hljs-meta">@Log</span></span>4j2 <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Asynchronous</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Reader</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CompletionHandler</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Integer</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ByteBuffer</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> bytesRead; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> position; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> AsynchronousFileChannel fileChannel; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Consumer&lt;BytesPayload&gt; consumer; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> ExecutorService executorService = Executors.newFixedThreadPool(<span class="hljs-number"><span class="hljs-number">10</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">read</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(File file, Consumer&lt;BytesPayload&gt; c)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.consumer = c; Path path = file.toPath(); <span class="hljs-comment"><span class="hljs-comment">// 1 this.fileChannel = AsynchronousFileChannel.open(path, Collections.singleton(StandardOpenOption.READ), this.executorService); //2 ByteBuffer buffer = ByteBuffer.allocate(FileCopyUtils.BUFFER_SIZE); this.fileChannel.read(buffer, position, buffer, this); //3 while (this.bytesRead &gt; 0) { this.position = this.position + this.bytesRead; this.fileChannel.read(buffer, this.position, buffer, this); } } @Override public void completed(Integer result, ByteBuffer buffer) { //4 this.bytesRead = result; if (this.bytesRead &lt; 0) return; buffer.flip(); byte[] data = new byte[buffer.limit()]; buffer.get(data); //5 consumer.accept(BytesPayload.from(data, data.length)); buffer.clear(); this.position = this.position + this.bytesRead; this.fileChannel.read(buffer, this.position, buffer, this); } @Override public void failed(Throwable exc, ByteBuffer attachment) { log.error(exc); } }</span></span></code> </pre> <br><ol><li>  This time we adapt <code>java.io.File</code> , making it <code>Java NIO java.nio.file.Path</code> </li><li>  When creating the <code>Channel</code> , we, in particular, specify the <code>java.util.concurrent.ExecutorService</code> service, which will be used to call the <code>CompletionHandler</code> handler when the necessary data for this appears </li><li>  We start reading by passing the reference to <code>CompletionHandler&lt;Integer, ByteBuffer&gt; (this)</code> </li><li>  In the callback, we read the bytes from the <code>ByteBuffer</code> to the capacity of <code>byte[]</code> </li><li>  Just like in the <code>Synchronous</code> example, <code>byte[]</code> data is passed to the consumer. </li></ol><br>  Immediately make a reservation: this code turned goraaaazdo harder!  There is such a bunch of things going on here that your head is spinning at once, however, let me note ... this code reads data from the <code>Java NIO Channel</code> , and then processes this data in a separate thread responsible for callbacks.  Thus, the stream in which the reading has begun is not monopolized.  We return almost instantly after the call <code>.read(..)</code> , and when, finally, we have the data at our disposal, the callback is made - in a different thread.  If there is a delay between <code>.read()</code> calls, you can move on to other matters by performing them in our stream.  The duration of an asynchronous read operation, from the first byte to the last, is at best no more than that of a synchronous read operation.  Normally, an asynchronous operation is not significantly longer.  However, by going to such additional difficulties, we can more effectively handle our flows.  Do more work, multiplex I / O in a pool with a finite number of threads. <br><br>  I work for a cloud computing company.  We would like you to get all the new application instances to solve problems with horizontal scaling!  Of course, here I am a little crafty.  Asynchronous I / O complicates the situation a bit, but I hope this example illustrates why reactive code is so useful: it allows you to handle more requests and do more work on existing hardware if performance is highly dependent on I / O.  If the performance depends on the use of the processor (for example, talking about operations on Fibonacci numbers, mining bitcoins or cryptography), then reactive programming will not give us anything. <br><br>  Currently, most of us do not use <code>Channel</code> or <code>InputStream</code> implementations for everyday work!  Problems have to reflect at the level of higher-level abstractions.  It's about things like arrays or, rather, about the <code>java.util.Collection</code> hierarchy.  The <code>java.util.Collection</code> collection is very well displayed on the InputStream: both entities assume that you can operate with all the data at once, and almost instantly.  It is expected that you will be able to complete reading from most of the <code>InputStreams</code> earlier, not later.  Collection types become a bit awkward when moving to larger amounts of data.  What to do if you are dealing with something potentially infinite (unlimited) - for example, with web sockets or server events?  What if there is a delay between posts? <br><br>  We need a better way to describe this kind of data.  We are talking about asynchronous events, such that will occur in the end.  It may seem that <code>Future&lt;T&gt;</code> or <code>CompletableFuture&lt;T&gt;</code> are well suited for such a purpose, but they describe only one thing at a time that happens in the end.  In fact, Java does not provide a suitable metaphor for describing this kind of data.  Both <code>Iterator</code> and the <code>Stream</code> types from Java 8 can be unbound, however, both are pull-oriented;  you yourself are requesting the next entry, and not the type should send a callback to your code.  It is assumed that, if push-based processing was supported in this case, allowing much more to be achieved at the thread level, the API would also provide threading and scheduling control.  <code>Iterator</code> implementations say nothing about threading, and all Java 8 threads share the same fork-join pool. <br><br>  If <code>Iterator</code> and <code>Stream</code> really supported push processing, we would face another problem that really escalates in the context of I / O: we will need some kind of backward penetration mechanism!  Since the data consumer is processed asynchronously, we have no idea when the data will be in the pipeline and in what quantity.  We do not know how much data will need to be processed on the next callback: one byte or one terabyte! <br><br>  By pulling data from an <code>InputStream</code> , you read as much information as you are willing to process, and no more.  In the previous examples, we read the data into a <code>byte[]</code> buffer of a fixed and known length.  In an asynchronous context, we need some way to tell the provider how much data we are ready to process. <br>  Yes, sir.  There is definitely something missing here. <br><br>  <b>Finding the missing metaphor</b> <br><br>  In this case, we are looking for a metaphor that would beautifully reflect the essence of asynchronous I / O, support such a data transfer mechanism and allow controlling the flow of execution in distributed systems.  In reactive programming, the ability of a client to signal what load he is able to handle is called ‚Äúreverse flow‚Äù. <br><br>  Now there are a number of good projects - Vert.x, Akka Streams and RxJava - supporting reactive programming.  The Spring team is also leading a project called <a href="https://projectreactor.io/">Reactor</a> .  Between these different standards there is a fairly wide general field, de facto allocated to the standard of the <a href="http://www.reactive-streams.org/">Reactive Streams initiative</a> .  In the Reactive Streams initiative, four types are defined: <br><br>  <code>Publisher&lt;T&amp;gt</code> ;  produces values ‚Äã‚Äãthat may come eventually.  <code>Publisher&lt;T&amp;gt</code> ;  produces values ‚Äã‚Äãof type <code>T</code> for <code>Subscriber&lt;T&gt;</code> . <br><br>  <i>Example 3. Reactive threads: <code>Publisher&lt;T&gt;</code> interface</i> . <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> org.reactivestreams; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Publisher</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">subscribe</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Subscriber&lt;? </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">super</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Tgt; s)</span></span></span></span>; }</code> </pre> <br>  The <code>Subscriber</code> type subscribes to <code>Publisher&lt;T&gt;</code> , receiving notifications of any new values ‚Äã‚Äãof type <code>T</code> through its <code>onNext(T)</code> method.  If any errors occur, its <code>onError(Throwable)</code> method is <code>onError(Throwable)</code> .  When processing is completed normally, the subscriber‚Äôs <code>onComplete</code> method is called. <br><br>  <i>Example 4. Reactive threads: <code>Subscriber&lt;T&gt;</code> interface.</i> <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> org.reactivestreams; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Subscriber</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onSubscribe</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Subscription s)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onNext</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T t)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onError</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Throwable t)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onComplete</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; }</code> </pre><br>  When <code>Subscriber</code> first connects to <code>Publisher</code> , it gets the <code>Subscription</code> in the <code>Subscriber#onSubscribe</code> .  Subscription subscriptions are perhaps the most important part of the entire specification;  it is precisely it that provides the reverse flow.  The Subscriber subscriber uses the <code>Subscription#request</code> method to request additional data or the <code>Subscription#cancel</code> method to stop processing. <br><br>  <i>Example 5. Reactive threads: the <code>Subscription&lt;T&gt;</code> interface</i> . <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> org.reactivestreams; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Subscription</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">request</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cancel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; }</code> </pre> <br>  The specification of reactive streams provides another useful, albeit obvious, type: <code>Processor&lt;A,B&gt;</code> is just an interface that inherits both <code>Subscriber&lt;A&gt;</code> and <code>Publisher&lt;B&gt;</code> . <br><br>  <i>Example 6. Reactive threads: <code>Processor&lt;T&gt;</code> interface</i> . <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> org.reactivestreams; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Processor</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">R</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Subscriber</span></span></span><span class="hljs-class">&amp;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ltT</span></span></span><span class="hljs-class">&gt;, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Publisher</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">R</span></span></span><span class="hljs-class">&gt; </span></span>{ }</code> </pre> <br>  The specification is not positioned as a prescription for implementations; in fact, its goal is to define types to support interoperability.  The obvious benefit of types associated with reactive threads is that there is still a place for them in the Java 9 release, moreover, semantically, they ‚Äúone to one‚Äù correspond to interfaces from the <code>java.util.concurrent.Flow</code> class, for example: <code>java.util.concurrent.Flow.Publisher</code> . <br><br>  <b>Meet Reactor</b> <br><br>  Reactive stream types alone are not enough;  higher order implementations are needed to support operations such as filtering and transformation.  As such, the Reactor project is convenient;  it builds on the Reactive Streams specification and provides two <code>Publisher&lt;T&gt;</code> specializations. <br><br>  The first, <code>Flux&lt;T&gt;</code> , is <code>Publisher</code> , producing zero or more values.  The second, <code>Mono&lt;T&gt;</code> is a <code>Publisher&lt;T&gt;</code> that produces zero or one value.  Both of them publish values ‚Äã‚Äãand can handle them accordingly, however, their capabilities are much broader than the Reactive Streams specification.  Both provide operators, allow processing of value streams.  Reactor types are well packaged ‚Äî the output of one of them can serve as input for the other, and if the type needs to work with other data streams, they rely on instances of <code>Publisher&lt;T&gt;</code> . <br><br>  Both <code>Mono&lt;T&gt;</code> and <code>Flux&lt;T&gt;</code> implement <code>Publisher&lt;T&gt;</code> ;  recommend that your methods accept instances of <code>Publisher&lt;T&gt;</code> , but return <code>Flux&lt;T&gt;</code> or <code>Mono&lt;T&gt;</code> ;  this will help the client to distinguish exactly which data he receives. <br><br>  Suppose you were given <code>Publisher&lt;T&gt;</code> and asked to display the user interface for this <code>Publisher&lt;T&gt;</code> .  In this case, is it necessary to display a detail page for one record, so how can you get a <code>CompletableFuture&lt;T&gt;</code> ?  Or to display an overview page with a list or a grid, where all records are displayed page by page?  It is hard to say. <br><br>  In turn, <code>Flux&lt;T&gt;</code> and <code>Mono&lt;T&gt;</code> very specific.  You know that you need to display an overview page if <code>Flux&lt;T&gt;</code> received, and a page with details for one (or none) records when you get <code>Mono&lt;T&gt;</code> . <br><br>  Reactor is an open source project launched by Pivotal;  Now he has become very popular.  Facebook uses it in its jet <a href="https://github.com/rsocket/rsocket-java">engine to call remote procedures</a> , also used in <a href="https://github.com/rsocket/rsocket-java">Rsocket</a> , under the direction of RxJava creator Ben Christensen.  Salesforce uses it in its <a href="https://github.com/salesforce/reactive-grpc">gRPC reactive implementation</a> .  Reactor implements Reactive Streams types, so it can interact with other technologies that support these types, for example, with <a href="">RxJava 2</a> from Netflix, <a href="https://doc.akka.io/docs/akka/current/stream/operators/Sink/asPublisher.html">Akka Streams</a> from Lightbend and with the <a href="https://vertx.io/docs/vertx-reactive-streams/java/">Vert.x</a> project from the Eclipse Foundation.  David Cairnok, head of RxJava 2, also actively collaborated with Pivotal in developing Reactor, making the project even better.  Plus, of course, it is present in one form or another in the Spring Framework, starting with the Spring Framework 4.0. <br><br>  <b>Reactive programming with Spring WebFlux</b> <br><br>  For all its usefulness, Reactor is just the basis.  Our applications must communicate with data sources.  Must support authentication and authorization.  Spring provides all this.  If Reactor gives us the missing metaphor, then Spring helps us all speak a common language. <br><br>  Spring Framework 5.0 was released in September 2017. It builds on Reactor and Reactive Streams specifications.  It has a new reactive execution environment and a component model called <a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/web-reactive.html">Spring WebFlux</a> . <br><br>  Spring WebFlux does not depend on the Servlet API and does not require them to work.  It comes with adapters that allow you to use it on top of the Servlet engine, if required, but this is not necessary.  It also provides a completely new Netty-based runtime environment called Spring WebFlux.  The Spring Framework 5, which works with Java 8 and Java EE 7 and higher, now serves as the basis for most of the Spring ecosystem, including Spring Data Kay, Spring Security 5, Spring Boot 2, and Spring Cloud Finchley. </div><p>Source: <a href="https://habr.com/ru/post/435972/">https://habr.com/ru/post/435972/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../435960/index.html">Thought experiment: Flutter on Go</a></li>
<li><a href="../435962/index.html">25 years to Aeron: feelings and impressions from the updated version of Aeron Remastered</a></li>
<li><a href="../435964/index.html">Ethereum plans to be 99% more economical.</a></li>
<li><a href="../435968/index.html">An overview of deep machine learning algorithms for robots</a></li>
<li><a href="../435970/index.html">Beginner's Guide to Web Server Development with Node.js</a></li>
<li><a href="../435974/index.html">Three.js - make controls for space or planetarium</a></li>
<li><a href="../435976/index.html">WebAssembly in production and ‚Äúminefield‚Äù Smart TV: interview with Andrei Nagikh</a></li>
<li><a href="../436276/index.html">Three-dimensional visualization in simulators of rolling stock based on the OpenSceneGraph engine</a></li>
<li><a href="../436374/index.html">Trends in the design of UI and UX 2019</a></li>
<li><a href="../437996/index.html">SITIS CTF: how a seal helped CTF win</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>