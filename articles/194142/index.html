<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Database connection pools - why and why</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="When your project starts to be popular and every millisecond of processing a request from the user becomes critical, you have to look for bottlenecks ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Database connection pools - why and why</h1><div class="post__text post__text-html js-mediator-article">  When your project starts to be popular and every millisecond of processing a request from the user becomes critical, you have to look for bottlenecks in the system.  Often, it takes most of the time to execute an SQL query from a database application.  Let's try to figure out what can be optimized in the program when working with the database. <br><a name="habracut"></a><br><h2>  Theory </h2><br>  For a better understanding, consider what steps are performed when the application makes a query to the database, for example, a query query: <br><ol><li>  Opening a connection to the database and sending a request to the server. </li><li>  Server parsing SQL query. </li><li>  The server optimizes the query based on the rules, as well as from the statistics on the tables.  As a result, a query execution plan is built. </li><li>  The server executes the query in accordance with the previously constructed plan and sends the results to the user. </li></ol><br>  What can you save time on? <br>  The first step of opening a connection to the server is quite long and we can exclude it by preparing in advance a pool of already open connections and providing connections from it to the application as needed. <br><br>  It is also possible to avoid repeated execution of steps two and three if we use bound variables when writing queries and cache the results of step three, which we receive from the server. <br><br>  Currently, most drivers for working with the database support connection pooling.  However, there is always the temptation to write your own implementation, which will work faster.  Let's check how much we will win using connection pools and caching, both in the boxed solution and in the self-written one. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  Measuring method </h2><br>  For tests, we use the freely distributed PostgreSQL DBMS, and the client will write to JAVA.  In the database, create a small table test.test_table (about 10 rows), consisting of the primary key id and the string value value.  Let our clients execute queries to the database in parallel, for this we will create threads that will make simple search queries on the primary key in this table.  When creating threads, we will specify a different implementation of connection pools, which will allow us to compare performance, because  The thread will calculate the total time it spent on executing 100 queries. <br><br><pre><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestThread</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Thread</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> DBPool pool; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> workTime = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> foundStr = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ workTime = System.currentTimeMillis(); <span class="hljs-comment"><span class="hljs-comment">//   Connection con = null; PreparedStatement st = null; ResultSet rs = null; Random rnd = new Random();//        for (int i = 0; i &lt; 100; i++) { try { con = pool.getConnection();//     //         st = con.prepareStatement("SELECT a.* FROM test.test_table a WHERE id =?"); st.setObject(1, rnd.nextInt(10)); rs = st.executeQuery();//   if (rs.next()) { String tmp = (rs.getString(2)); //   if (tmp != null) { foundStr++; } } } catch (SQLException ex) { //  ,    System.out.println("Pool " + pool + " exeption " + ex); } finally { //   ,       try { if (rs != null) rs.close(); } catch (SQLException e) { //ignore } try { if (st != null) st.close(); } catch (SQLException e) { //ignore } try { if (con != null) pool.putConnection(con); //      } catch (SQLException e) { //ignore } } } workTime = System.currentTimeMillis() - workTime; //    } }</span></span></code> </pre> <br>  Now we will make some pools, and we will compare productivity. <br>  The first one will be the classic one, which opens a connection to the server for each request and closes it after the request is completed. <br><pre> <code class="java hljs"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DBPool</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String url, user, password; DBPool(String url, String user, String password) <span class="hljs-keyword"><span class="hljs-keyword">throws</span></span> ClassNotFoundException { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.url = url; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.user = user; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.password = password; Class.forName(<span class="hljs-string"><span class="hljs-string">"org.postgresql.Driver"</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Connection </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getConnection</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> SQLException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> DriverManager.getConnection(url, user, password); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">putConnection</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Connection connection)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> SQLException </span></span>{ connection.close(); } }</code> </pre><br>  The second will be using the special caching data source class from the PostgreSQL JDBC driver - PGPoolingDataSource.  Which allows you to set the size of the pool of connections, as well as the initial number of connections.  In addition, PreparedStatement has settings in its settings; setPrepareThreshold is responsible for the number of request executions after which the request is cached and does not require parsing and building an execution plan. <br><pre> <code class="java hljs"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DBPoolCache</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DBPool</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> PGPoolingDataSource source; DBPoolCache(String host, String database, String user, String password) { source = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PGPoolingDataSource(); source.setDataSourceName(<span class="hljs-string"><span class="hljs-string">"A Data Source"</span></span>); source.setServerName(host); source.setDatabaseName(database); source.setUser(user); source.setPassword(password); source.setMaxConnections(<span class="hljs-number"><span class="hljs-number">20</span></span>);<span class="hljs-comment"><span class="hljs-comment">//  source.setInitialConnections(20);//     } public Connection getConnection() throws SQLException { return source.getConnection(); } public void putConnection(Connection connection) throws SQLException { connection.close(); } }</span></span></code> </pre><br>  Well, at the end of our implementation of pools, when we ourselves cache connections to the database as well as the results of SQL query parsing (PreparedStatement). <br><pre> <code class="java hljs"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DBPoolCacheMy</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DBPool</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String url, user, password; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> PGSimpleDataSource source; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> BlockingQueue&lt;Connection&gt; connections = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayBlockingQueue&lt;Connection&gt;(<span class="hljs-number"><span class="hljs-number">20</span></span>); DBPoolCacheMy(String host, String database, String user, String password) <span class="hljs-keyword"><span class="hljs-keyword">throws</span></span> SQLException { source = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PGSimpleDataSource(); source.setServerName(host); source.setDatabaseName(database); source.setUser(user); source.setPassword(password); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">20</span></span>; i++) {<span class="hljs-comment"><span class="hljs-comment">//  connections.add(new MyConnection(source.getConnection())); } } public Connection getConnection() throws SQLException { try { //     return connections.poll(2, TimeUnit.SECONDS); } catch (InterruptedException e) { return null; } } public void putConnection(Connection connection) throws SQLException { connections.add(connection); } }</span></span></code> </pre><br>  You also have to implement your own database connection class, which will be caching the PreparedStatement. <br><pre> <code class="java hljs"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyConnection</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Connection</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Connection connection; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyConnection</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Connection connection)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.connection = connection; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> ConcurrentHashMap&lt;String, PreparedStatement&gt; statements = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ConcurrentHashMap&lt;String, PreparedStatement&gt;(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> PreparedStatement </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prepareStatement</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String sql)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> SQLException </span></span>{ PreparedStatement statement = statements.get(sql); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (statement == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { statement = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MyStatement(connection.prepareStatement(sql)); statements.put(sql, statement); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> statement; } ..... }</code> </pre><br>  Plus a class that implements the PreparedStatement interface and does not respond to closure. <br><pre> <code class="java hljs"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyStatement</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PreparedStatement</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> PreparedStatement statement; MyStatement(PreparedStatement statement) <span class="hljs-keyword"><span class="hljs-keyword">throws</span></span> SQLException { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.statement = statement; ((PGStatement) statement).setPrepareThreshold(<span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">close</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> SQLException </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//ignore } ..... }</span></span></code> </pre><br><br><h2>  Conclusion </h2><br><br>  Finally, let's compare the performance of three different connection pools, run the tests with the number of parallel threads from 1 to 10, for different implementations.  The result is the following dependence of the total task execution time on the number of threads. <br><br><img src="http://habrastorage.org/storage3/679/974/8de/6799748deafbe37309f39cc61aee15aa.png"><br><br>  From the graph it is clear that it is obviously necessary to cache connections with the database, this gives a significant increase in system performance.  But to write a self-written implementation of connection caching and PreparedStatement does not give tangible benefits. </div><p>Source: <a href="https://habr.com/ru/post/194142/">https://habr.com/ru/post/194142/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../194126/index.html">OpenJDK bugtracker became public</a></li>
<li><a href="../194128/index.html">Daisy, Daisy ...</a></li>
<li><a href="../194130/index.html">The widget becomes a new elementary part of the Internet.</a></li>
<li><a href="../194132/index.html">New WebStorm 7: everything you need to hand</a></li>
<li><a href="../194136/index.html">Riddles of Da'Vinci: Renaissance. 1 million rubles for the summer</a></li>
<li><a href="../194150/index.html">How we built a simulator: an invaluable experience</a></li>
<li><a href="../194154/index.html">D-Link IP Security Hole? No, this is ‚ÄúFeature‚Äù!</a></li>
<li><a href="../194160/index.html">UNIX early history</a></li>
<li><a href="../194162/index.html">Free Month at CodeSchool by NewRelic</a></li>
<li><a href="../194166/index.html">Subsoil payphone</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>