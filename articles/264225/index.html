<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Parsim pod from Perl 5 with Perl 6</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I‚Äôve just finished developing the pod parser (plain old documentation) for Perl 5 written in Perl 6. The grammar is surprisingly easy to do - thanks t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Parsim pod from Perl 5 with Perl 6</h1><div class="post__text post__text-html js-mediator-article">  I‚Äôve just finished developing the pod parser (plain old documentation) for Perl 5 written in Perl 6. The grammar is surprisingly easy to do - thanks to Perl 6, because I myself am not particularly a programming genius.  With the help of the guys from # perl6, I learned a lot of interesting things along the way, and I want to share this with everyone.  Well, the code, of course, is also attached. <br><br>  By the way, I recommend reading first my <a href="http://habrahabr.ru/post/263965/">introduction to grammars in Perl 6</a> , and much of this article will become clearer. <br><br><h4>  Grammar Development </h4><br>  In Perl 6, the grammar is a special type of class for parsing texts.  The idea is to declare a sequence of regularizers and assign them tokens, which can then be used to parse the input.  For Pod :: Perl5 :: Grammar, I worked out the perlpod specification in detail, adding the necessary tokens as the standards are studied. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Of course, there are a few problems.  First, how to define a regular schedule for lists?  In pod lists can contain lists - can the definition include itself?  It turns out that recursive definitions are possible, unless they coincide with a string of zero length, which leads to an infinite loop.  Here is the definition: <br><br><pre><code class="perl hljs">token over_back { &lt;over&gt; [ &lt;_item&gt; | &lt;paragraph&gt; | &lt;verbatim_paragraph&gt; | &lt;blank_line&gt; | &lt;_for&gt; | &lt;begin_end&gt; | &lt;pod&gt; | &lt;encoding&gt; | &lt;over_back&gt; ]* &lt;back&gt; } token over { ^^\=over [\h+ &lt;[<span class="hljs-number"><span class="hljs-number">0</span></span>..<span class="hljs-number"><span class="hljs-number">9</span></span>]&gt;+ ]? \n } token _item { ^^\=item \h+ &lt;name&gt; [ [ \h+ &lt;paragraph&gt; ] | [ \h* \n &lt;blank_line&gt; &lt;paragraph&gt;? ] ] } token back { ^^\=back \h* \n }</code> </pre> <br><br>  The over_back token describes the entire list from beginning to end.  Simply put, it says that the sheet should start with = over and end with = back, and there can be a lot of things in the middle, including another over_back! <br><br>  For simplicity, I used to call tokens as they are written in pod, although sometimes this was not possible due to intersections of namespaces. <br><a name="habracut"></a><br>  I especially like the following template, so I often turned to it: <br><br><pre> <code class="perl hljs">[ &lt;pod_section&gt; | &lt;?!before &lt;pod_section&gt; &gt; .]*</code> </pre><br><br>  It is useful if you need to find a template, but ignore everything else if it is not found.  In our case, pod_section is a token that defines a section in pod, but pod is often written directly in Perl code, and then everything superfluous should be ignored.  Therefore, in the second part of the definition, a negative lookahead?! Before is used to check that the next passage of the text is not equal to pod_section, and a point is used to hook ‚Äúeverything else‚Äù, including line breaks.  Both conditions are grouped in square brackets with an asterisk outside to check the text character by character. <br><br>  Grammar can be used to parse a pod, both individually written and included in the code.  It cuts out all the pod sections and puts them into a match object, which you can then work with.  It is easy to use: <br><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> Pod::Perl5::Grammar; <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $match = Pod::Perl5::Grammar.parse($pod); <span class="hljs-comment"><span class="hljs-comment">#  my $match = Pod::Perl5::Grammar.parsefile("/path/to/some.pod");</span></span></code> </pre><br><br><h4>  Action classes </h4><br>  Action classes are normal Perl 6 classes that can be passed to the grammar during parsing.  They allow you to assign behavior (actions) to the tokens to work at the time of the pattern match.  You just need to name the methods in the class in the same way as the token on which it must be executed.  I wrote a pod-to-HTML action class.  Here is a method to convert = head1 to HTML: <br><br><pre> <code class="perl hljs">method head1 ($/) { self.add_to_html(<span class="hljs-string"><span class="hljs-string">'body'</span></span>, <span class="hljs-string"><span class="hljs-string">"&lt;h1&gt;{$/&lt;singleline_text&gt;.Str}&lt;/h1&gt;\n"</span></span>); }</code> </pre><br><br>  Each time a grammar uses the token head1, this method is executed.  It is passed the $ / variable containing the found sequence head1, from which the text string is extracted. <br><br>  To convert to HTML, each action class simply extracts the text from the desired token, reformats it and displays it.  Everything worked fine until I met the nested tokens, like formatting codes, inside the text paragraph.  Instead: <br><br><pre> <code class="html hljs xml">There are different ways to emphasize text, I<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">this</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">is</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">in</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">italics</span></span></span><span class="hljs-tag">&gt;</span></span> and B<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">this</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">is</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">in</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">bold</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br><br>  It turned out: <br><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">i</span></span></span><span class="hljs-tag">&gt;</span></span>this is in italics<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">i</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">b</span></span></span><span class="hljs-tag">&gt;</span></span>this is in bold<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">b</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span>There are different ways to emphasize text, I<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">this</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">is</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">in</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">italics</span></span></span><span class="hljs-tag">&gt;</span></span> and B<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">this</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">is</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">in</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">bold</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br><br>  This is because italics and bold are regulars in the first place.  I had to use a buffer to store HTML from second-level tokens.  When a paragraph token is found, the parser substitutes the contents of this buffer instead of text.  The class looks like this: <br><br><pre> <code class="perl hljs">method paragraph ($/ is copy) { <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $original_text = $/&lt;text&gt;.Str.chomp; <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $para_text = $/&lt;text&gt;.Str.chomp; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> self.get_buffer(<span class="hljs-string"><span class="hljs-string">'paragraph'</span></span>).<span class="hljs-keyword"><span class="hljs-keyword">reverse</span></span> -&gt; $pair <span class="hljs-comment"><span class="hljs-comment"># reverse,      { $para_text = $para_text.subst($pair.key, {$pair.value}); } self.add_to_html('body', "&lt;p&gt;{$para_text}&lt;/p&gt;\n"); self.clear_buffer('paragraph'); } method italic ($/) { self.add_to_buffer('paragraph', $/.Str =&gt; "&lt;i&gt;{$/&lt;multiline_text&gt;.Str}&lt;/i&gt;"); } method bold ($/) { self.add_to_buffer('paragraph', $/.Str =&gt; "&lt;b&gt;{$/&lt;multiline_text&gt;.Str}&lt;/b&gt;"); }</span></span></code> </pre><br><br>  Particular attention should be paid to work with regulars.  Each example action class uses $ /.  This is a mistake - guess what happens as a result: <br><br><pre> <code class="perl hljs">method head1 ($/) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> $/.Str ~~ <span class="hljs-regexp"><span class="hljs-regexp">m/foobar/</span></span> <span class="hljs-comment"><span class="hljs-comment">#   { self.add_to_html('body', "&lt;h1&gt;{$/&lt;singleline_text&gt;.Str}\n"); } } Cannot assign to a readonly variable or a value</span></span></code> </pre><br><br>  <i>Assigning a variable to read only or value.</i> <br><br>  Nuclear explosion.  When $ / is passed to head1, it is read only.  Execution of any regular schedule in the same lexical scope will attempt to overwrite $ /.  I tried it a couple of times, and using the # perl6 channel I stopped at this option: <br><br><pre> <code class="perl hljs">method head1 ($/ is copy) { <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $match = $/; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> $match.Str ~~ <span class="hljs-regexp"><span class="hljs-regexp">m/foobar/</span></span> { self.add_to_html(<span class="hljs-string"><span class="hljs-string">'body'</span></span>, <span class="hljs-string"><span class="hljs-string">"&lt;h1&gt;{$match&lt;singleline_text&gt;.Str}&lt;/h1&gt;\n"</span></span>); } }</code> </pre><br><br>  By adding is copy to the parameters, I make a copy of the value instead of pointing to $ /.  Then I copy the match variable in $ match, and then the next regular can safely work with $ /.  I think it is better to do this: <br><br><pre> <code class="perl hljs">method head1 ($match) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> $match.Str ~~ <span class="hljs-regexp"><span class="hljs-regexp">m/foobar/</span></span> { self.add_to_html(<span class="hljs-string"><span class="hljs-string">'body'</span></span>, <span class="hljs-string"><span class="hljs-string">"&lt;h1&gt;{$match&lt;singleline_text&gt;.Str}&lt;/h1&gt;\n"</span></span>); } }</code> </pre><br><br>  Just do not call the parameter $ /, and everything will work.  But I did not check it out yet. <br><br>  To use the action class, we simply pass it to the grammar: <br><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> Pod::Perl5::Grammar; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> Pod::Perl5::ToHTML; <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $actions = Pod::Perl5::ToHTML.new; <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $match = Pod::Perl5::Grammar.parse($pod, :$actions); <span class="hljs-comment"><span class="hljs-comment">#  my $match = Pod::Perl5::Grammar.parse($pod, :actions($actions));</span></span></code> </pre><br><br>  The first example uses the positional argument: $ actions.  He must be called actions.  In the second example, I called the argument: actions ($ actions), and in this case the object of the action class can be called anything. <br><br><h4>  We improve pod </h4><br>  PerlTricks.com articles are written in HTML, with their own class names and span tags.  It is difficult to edit and difficult to write.  I would like to use pod for editing - it would be easier for writers and for the editor.  Therefore, I would like to expand pod by adding to it all the useful features for blogs.  For example, formatting is done through B &lt;...&gt; and similar functions.  Why not add @ &lt;...&gt; for links to Twitter, or M &lt;...&gt; for links to MetaCPAN? <br><br>  Since grammars in Perl 6 are classes, they can be inherited and redefined.  So I can add my own codes like this: <br><br><pre> <code class="perl hljs">grammar Pod::Perl5::Grammar::PerlTricks is Pod::Perl5::Grammar { token twitter { @\&lt; &lt;name&gt; \&gt; } token metacpan { M\&lt; &lt;name&gt; \&gt; } }</code> </pre><br><br>  You also need to override the format_codes token to include new ones: <br><br><pre> <code class="perl hljs">token format_codes { [ &lt;italic&gt;|&lt;bold&gt;|&lt;code&gt;|&lt;<span class="hljs-keyword"><span class="hljs-keyword">link</span></span>&gt; |&lt;escape&gt;|&lt;filename&gt;|&lt;singleline&gt; |&lt;<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>&gt;|&lt;zeroeffect&gt;|&lt;twitter|&lt;metacpan&gt; ] }</code> </pre><br><br>  That's how simple it is.  New grammar will be able to parse pod and work with my new formatting codes.  Of course, the Pod :: Perl5 :: Pod class can also be expanded and redefined, and the result will be something like: <br><br><pre> <code class="perl hljs">Pod::Perl5::ToHTML::PerlTricks is Pod::Perl5::ToHTML { method twitter ($match) { self.add_to_buffer(<span class="hljs-string"><span class="hljs-string">'paragraph'</span></span>, $match.<span class="hljs-string"><span class="hljs-string">Str =&gt;</span></span> <span class="hljs-string"><span class="hljs-string">"&lt;a href="</span></span>http:<span class="hljs-regexp"><span class="hljs-regexp">//twitter</span></span>.com/{$match&lt;name&gt;.Str}<span class="hljs-string"><span class="hljs-string">"&gt;{$match&lt;name&gt;.Str}&lt;/a&gt;"</span></span>); } method metacpan ($match) { self.add_to_buffer(<span class="hljs-string"><span class="hljs-string">'paragraph'</span></span>, $match.<span class="hljs-string"><span class="hljs-string">Str =&gt;</span></span> <span class="hljs-string"><span class="hljs-string">"&lt;a href="</span></span>https:<span class="hljs-regexp"><span class="hljs-regexp">//metacpan</span></span>.org/pod//{$match&lt;name&gt;.Str}<span class="hljs-string"><span class="hljs-string">"&gt;{$match&lt;name&gt;.Str}&lt;/a&gt;"</span></span>); } }</code> </pre><br><br><h4>  That's not all </h4><br>  There is a more visual way to work with groups of tokens, multi-dispatch.  Instead of defining format_codes as a list of alternative tokens, we declare a prototype method, and declare each formatting method as a variant of a multi prototype. <br><br><pre> <code class="perl hljs">proto token format_codes { * } multi token format_codes:italic { I\&lt; &lt;multiline_text&gt; \&gt; } multi token format_codes:bold { B\&lt; &lt;multiline_text&gt; \&gt; } multi token format_codes:code { C\&lt; &lt;multiline_text&gt; \&gt; } ...</code> </pre><br><br>  When inheriting a grammar, there is no need to override the format_codes.  You can add new through multi: <br><br><pre> <code class="perl hljs">grammar Pod::Perl5::Grammar::PerlTricks is Pod::Perl5::Grammar { token format_codes:twitter { @\&lt; &lt;name&gt; \&gt; } token format_codes:metacpan { M\&lt; &lt;name&gt; \&gt; } }</code> </pre><br><br>  This approach also simplifies working with a match object in terms of the way to extract data.  For example, the following code selects the link section from the third paragraph of the pod block: <br><br><pre> <code class="perl hljs">is $match&lt;pod_section&gt;[<span class="hljs-number"><span class="hljs-number">0</span></span>]&lt;paragraph&gt;[<span class="hljs-number"><span class="hljs-number">2</span></span>]&lt;text&gt;&lt;format_codes&gt;[<span class="hljs-number"><span class="hljs-number">0</span></span>]&lt;<span class="hljs-keyword"><span class="hljs-keyword">link</span></span>&gt;&lt;section&gt;.Str <span class="hljs-comment"><span class="hljs-comment">#   is $match&lt;pod_section&gt;[0]&lt;paragraph&gt;[2]&lt;text&gt;&lt;format_codes&gt;[0]&lt;section&gt;.Str #   multi dispatch</span></span></code> </pre><br><br>  In the first example, a reference to the name of the token format is required.  But with the help of multi-dispatch this can be avoided, as shown in the second example. <br><br><h4>  Conclusion </h4><br>  In general, writing a Perl 6 pod parser was a fairly straightforward and straightforward exercise.  If you have any questions when programming in Perl 6, I highly recommend the irc channel # perl6 on the freenode server, people gathered there quite friendly and responsive. </div><p>Source: <a href="https://habr.com/ru/post/264225/">https://habr.com/ru/post/264225/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../264213/index.html">Are you still using CJSON?</a></li>
<li><a href="../264217/index.html">Apply correlation in retail</a></li>
<li><a href="../264219/index.html">ipgeobase in nginx</a></li>
<li><a href="../264221/index.html">Oracle Exadata, or About the Use of Engineered Systems (Part 2)</a></li>
<li><a href="../264223/index.html">Simple plan-fact analysis in Power BI Desktop. Part Two - Visualization</a></li>
<li><a href="../264227/index.html">Underground carders market. Translation of the book "KingPIN". Chapter 1. "Key"</a></li>
<li><a href="../264229/index.html">Calque - a calculator that is more convenient than the browser console</a></li>
<li><a href="../264233/index.html">The complexity of building Python3 + Qt5 applications under Windows</a></li>
<li><a href="../264235/index.html">Mobile phones for / against special services</a></li>
<li><a href="../264237/index.html">Bikes of field engineers - installation and service of VKS / KC</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>