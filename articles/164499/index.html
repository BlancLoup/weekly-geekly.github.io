<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Electric field simulation with CUDA</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This article is written to demonstrate how CUDA can be used to simulate the simple interaction of charged particles (see Coulomb's Law ). To display a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Electric field simulation with CUDA</h1><div class="post__text post__text-html js-mediator-article"> This article is written to demonstrate how CUDA can be used to simulate the simple interaction of charged particles (see <a href="http://en.wikipedia.org/wiki/Coulomb%2527s_law">Coulomb's Law</a> ).  To display a static image, I used the <b>freeglut</b> library. <br>  How often they write on Habr√©: <a name="habracut"></a><br><br>  Back in the days of Turbo Pascal and Borland C 5.02, I was interested in the process of simulating simple physical phenomena of nature, be it gravitational forces or Coulomb interaction.  Unfortunately, the power of a single processor with several hundred MHz was not enough for simple mathematical operations, of which there were a lot of them. <br><br>  Although I am not a pogrommist, I once wanted to recall a distant childhood, and learn some of the basics of JavaScript, and I somehow modeled the gravitational interaction of any reasonable number of material points.  So, for example, the particle below revolves around the "sun" using the Newtonian law: <br><img src="https://habrastorage.org/storage2/a99/1d7/d8c/a991d7d8cad963868cfa2b535f0870a6.png"><br>  If it will be interesting for you, and I will not leave enthusiasm, then I will describe to you the creation of such a demo, so that you can write your evil birds in a vacuum. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      So, stop nostalgic, let's <s>pogrom</s> programming.  My platform is a laptop with Ubuntu and a GeForce GT 540m video card and CUDA Toolkit 5.0 installed.  If you start your acquaintance with CUDA, I can advise you on an interesting book <a href="https://developer.nvidia.com/content/cuda-example-introduction-general-purpose-gpu-programming-0">CUDA by Example</a> . <br><br>  To begin with, create a project from the Nsight template and connect the freeglut to it using the libraries <i>GLU, GL, glut</i> .  This will allow us to display the resulting vector field, which we calculate.  The approximate structure of our file with the <code>main</code> function will be as follows: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main(int argc, char** argv) { // Initialize freeglut // ... // Initialize Host and Device variables // ... // Launch Kernel to render the image // Display Image // Free resources return 0; }</span></span></span></span></code> </pre><br>  To begin with, everything looks simple.  Let's first display the window of the size we need, and then render a black screen.  By the way, I will tell you the obvious thing: <i>if any function is unfamiliar to you, just google it</i> . <br><h4>  Window initialization </h4><br>  Since when I conceived the application, I did not plan to dynamically resize the window, I decided to specify it declaratively using global constants: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> width = <span class="hljs-number"><span class="hljs-number">1280</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> height = <span class="hljs-number"><span class="hljs-number">720</span></span>;</code> </pre><br>  Oh yes!  Do not judge strictly for mixing styles C ++ and C99.  Some things, such as overload, I sometimes find useful, but I did not refuse malloc to at least somehow follow the style of applications with CUDA. <br><br>  The window display itself, the Escape key processing and the simple render can be done with the following code: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;GL/freeglut.h&gt; #include &lt;GL/gl.h&gt; #include &lt;GL/glext.h&gt; // ... void key(unsigned char key, int x, int y) { switch (key) { case 27: printf("Exit application\n"); glutLeaveMainLoop(); break; } } void draw(void) { glClearColor(0.0, 0.0, 0.0, 1.0); glClear(GL_COLOR_BUFFER_BIT); // glDrawPixels(width, height, GL_RGBA, GL_UNSIGNED_BYTE, screen); glFlush(); } // ... // Initialize freeglut glutInit(&amp;argc, argv); glutInitDisplayMode(GLUT_SINGLE | GLUT_RGBA); glutInitWindowSize(width, height); glutCreateWindow("Electric field"); glutDisplayFunc(draw); glutKeyboardFunc(key); glutSetOption(GLUT_ACTION_ON_WINDOW_CLOSE, GLUT_ACTION_CONTINUE_EXECUTION); // ... // Display Image glutMainLoop();</span></span></span></span></code> </pre><br>  When you run this code, you will not see anything except the black screen.  So I will omit the screenshot here.  Pay attention to the following points: <br><ul><li>  <code>glutLeaveMainLoop</code> - when Escape is pressed, freeglut allows you to interrupt the main loop so that we can free up application resources.  If you want, you can use <code>atexit</code> ; </li><li>  <code>glDrawPixels</code> - later I will create a buffer from <code>unsigned byte</code> , where I will store all the pixels (their colors) and then display them in the window; </li><li>  <code>glutSetOption</code> is to allow me to continue executing code in <code>main</code> to clear resources in the form of dynamic memory. </li></ul><br><h4>  Splitting calculation into blocks and threads </h4><br>  Pampering with examples, I was able to figure out for myself what such a thing as a block and a flow represents, and what to do with their dimension.  In principle, if we omit the technical details, the block is a cell in which there are a certain number of flows.  When a whole grid of blocks is calculated, at some point in time, each block fires its streams, waits for them to complete, and transfers control to another block.  So, for example, you can pile up blocks in a one-dimensional strip, or in a two-dimensional grid. <br><br>  The streams, in turn, can also be located in a block in the form of a one-dimensional band, or a two-dimensional table.  By the way, variants with three dimensions are possible, but I will miss them, since they do not yet fit into my task. <br><br>  I can break the screen into large squares (blocks), inside which the pixels will be rendered as a separate stream.  Such a task is the optimal use of a graphics card, but to break the screen into blocks, you have to apply simple arithmetic - I find out the number of flows allowed for me within the block, and then I divide the window size by the number of flows horizontally and vertically. <br><br>  To find out the number of threads inside a block, we use the <code>cudaGetDeviceProperties</code> function: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">threadsCount</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> deviceCount = <span class="hljs-number"><span class="hljs-number">0</span></span>; cudaGetDeviceCount(&amp;deviceCount); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (deviceCount &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"No CUDA devices\n"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span>(<span class="hljs-number"><span class="hljs-number">-1</span></span>); } cudaDeviceProp properties; cudaGetDeviceProperties(&amp;properties, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> properties.maxThreadsPerBlock; }</code> </pre><br>  My map returns the number 1024. Unfortunately, I cannot use all the threads, because in debug mode, when dividing the <code>float</code> numbers, I get the error <code>cudaErrorLaunchOutOfResources</code> .  I couldn‚Äôt find out why I didn‚Äôt have enough resources (or registers, as the Internet writes), so the only three solutions I could find were reducing the number of threads per block, using the release mode when compiling, using the <code>maxrregcount</code> option with any number Above zero. <br>  If you have read my article up to this point, then I am glad that it is not for nothing that I sit at night in front of the computer.  And if you know the answer, how to find out exactly what was my mistake, and let me know it, then I will be doubly glad. <br><br>  Now we will break our field into blocks and streams: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setupGrid</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dim3* blocks, dim3* threads, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> maxThreads)</span></span></span><span class="hljs-function"> </span></span>{ threads-&gt;x = <span class="hljs-number"><span class="hljs-number">32</span></span>; threads-&gt;y = maxThreads / threads-&gt;x - <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-comment"><span class="hljs-comment">// to avoid cudaErrorLaunchOutOfResources error blocks-&gt;x = (width + threads-&gt;x - 1) / threads-&gt;x; blocks-&gt;y = (height + threads-&gt;y - 1) / threads-&gt;y; } // ... // Initialize Host dim3 blocks, threads; setupGrid(&amp;blocks, &amp;threads, threadsCount()); printf("Debug: blocks(%d, %d), threads(%d, %d)\nCalculated Resolution: %dx %d\n", blocks.x, blocks.y, threads.x, threads.y, blocks.x * threads.x, blocks.y * threads.y);</span></span></code> </pre><br>  The result will be as follows (I deliberately increased the number of blocks by one in cases where the screen size is not a multiple of the number of streams): <br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">Debug</span></span>: blocks(<span class="hljs-number"><span class="hljs-number">40</span></span>, <span class="hljs-number"><span class="hljs-number">24</span></span>), threads(<span class="hljs-number"><span class="hljs-number">32</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>) Calculated Resolution: <span class="hljs-number"><span class="hljs-number">1280</span></span> x <span class="hljs-number"><span class="hljs-number">720</span></span></code> </pre><br><h4>  Theory and practice </h4><br>  Charges, distances, pendants and odds - that sounds good.  But when it comes to modeling, here we can‚Äôt use super-small values, because they can disappear in the calculation process.  Therefore, we simplify the task: <br><br>  A charge is a structure with coordinates (as on the screen). <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">charge</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x, y, q; };</code> </pre><br>  The electric field strength at a point is a vector that we express by the projections and the function that calculates them (it was here that I got my error): <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> k = <span class="hljs-number"><span class="hljs-number">50.0f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> minDistance = <span class="hljs-number"><span class="hljs-number">0.9f</span></span>; <span class="hljs-comment"><span class="hljs-comment">// not to divide by zero const float maxForce = 1e7f; struct force { float fx, fy; __device__ force() : fx(0.0f), fy(0.0f) { } __device__ force(int fx, int fy) : fx(fx), fy(fy) { } __device__ float length2() const { return (fx * fx + fy * fy); } __device__ float length() const { return sqrtf(length2()); } __device__ void calculate(const charge&amp; q, int probe_x, int probe_y) { // F(1-&gt;2) = k * q1 * q2 / r(1-&gt;2)^2 * vec_r(1-&gt;2) / abs(vec_r(1-&gt;2)) // e = vec_F / q2 fx = probe_x - qx; fy = probe_y - qy; float l = length(); if (l &lt;= minDistance) { return; } float e = k * qq / (l * l * l); if (e &gt; maxForce) { fx = fy = maxForce; } else { fx *= e; fy *= e; } } __device__ force operator +(const force&amp; f) const { return force(fx + f.fx, fy + f.fy); } __device__ force operator -(const force&amp; f) const { return force(fx - f.fx, fy - f.fy); } __device__ force&amp; operator +=(const force&amp; f) { fx += f.fx; fy += f.fy; return *this; } __device__ force&amp; operator -=(const force&amp; f) { fx -= f.fx; fy -= f.fy; return *this; } };</span></span></code> </pre><br>  My idea is simple - I will create a two-dimensional array of stress vectors.  At each point of the screen, the intensity will be equal to the sum of the vectors of the Coulomb forces.  It sounds abstruse, but I could not formulate otherwise.  Simply said, the code will be like this (you read it, but do not write it yet in your project): <br><pre> <code class="cpp hljs"> force temp_f; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; chargeCount; i++) { temp_f.calculate(charges[i], x, y); *f += temp_f; }</code> </pre><br>  If we get into a charge, then I miss the calculation of the tension at this point (for it is impossible to divide by zero).  So on the screen you should see a black dot - charge. <br><br>  Now that we have created the infrastructure, let's code under CUDA.  First, create the necessary host and device variables and release them! <br><h4>  Create and release resources. </h4><br>  We will need the following variables: <br><ul><li>  screen - host - color pixels; </li><li>  screen - the device - they are the same; </li><li>  Charges - device - coordinates and magnitudes of charges in the device‚Äôs permanent memory. </li></ul><br><br>  Create: <br><pre> <code class="cpp hljs">uchar4* screen = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; <span class="hljs-comment"><span class="hljs-comment">// ... screen = (uchar4*) malloc(width * height * sizeof(uchar4)); memset(screen, 0, width * height * sizeof(uchar4)); uchar4 *dev_screen = NULL; cudaMalloc((void**) &amp;dev_screen, width * height * sizeof(uchar4)); cudaMemset(dev_screen, 0, width * height * sizeof(uchar4)); // ... // Free resources free(screen); screen = NULL; cudaFree(dev_screen); dev_screen = NULL;</span></span></code> </pre><br>  We initialize the charges simply.  I do not reset the random number generator to get the same picture.  If you want a random field each time, you can add a call to <code>srand</code> : <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> chargeCount = <span class="hljs-number"><span class="hljs-number">10</span></span>; __constant__ charge dev_charges[chargeCount]; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> maxCharge = <span class="hljs-number"><span class="hljs-number">1000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> minCharge = <span class="hljs-number"><span class="hljs-number">-1000</span></span>; <span class="hljs-comment"><span class="hljs-comment">// ... void prepareCharges(void) { charge* charges = (charge*) malloc(chargeCount * sizeof(charge)); for (int i = 0; i &lt; chargeCount; i++) { charges[i].x = rand() % width; charges[i].y = rand() % height; charges[i].q = rand() % (maxCharge - minCharge) + minCharge; printf("Debug: Charge #%d (%d, %d, %d)\n", i, charges[i].x, charges[i].y, charges[i].q); } cudaMemcpyToSymbol(dev_charges, charges, chargeCount * sizeof(charge)); } // ... prepareCharges();</span></span></code> </pre><br>  Remember the commented out line rendering screen?  Now you can uncomment it: <br><pre> <code class="cpp hljs"> glDrawPixels(width, height, GL_RGBA, GL_UNSIGNED_BYTE, screen);</code> </pre><br><h4>  Create a kernel </h4><br>  Now we will create a function that we will call in each stream to render each pixel on the screen.  This function will do the following: it will calculate the field strength value, and call another function to match some color to a point. <br><br><pre> <code class="cpp hljs">__<span class="hljs-function"><span class="hljs-function">device__ uchar4 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getColor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> force&amp; f)</span></span></span><span class="hljs-function"> </span></span>{ uchar4 color; color.x = color.y = color.z = color.w = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> l = f.length(); color.x = (l &gt; maxLengthForColor ? <span class="hljs-number"><span class="hljs-number">255</span></span> : l * <span class="hljs-number"><span class="hljs-number">256</span></span> / maxLengthForColor); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> color; } __<span class="hljs-function"><span class="hljs-function">global__ </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">renderFrame</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(uchar4* screen)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// build the field and render the frame }</span></span></code> </pre><br>  To call the core ... and yet everything is clear: <br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// Launch Kernel to render the image renderFrame&lt;&lt;&lt;blocks, threads&gt;&gt;&gt;(dev_screen); cudaMemcpy(screen, dev_screen, width * height * sizeof(uchar4), cudaMemcpyDeviceToHost);</span></span></code> </pre><br>  Now add some code to the <code>renderFrame</code> and get what we need: <br><pre> <code class="cpp hljs">__<span class="hljs-function"><span class="hljs-function">global__ </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">renderFrame</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(uchar4* screen)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = blockIdx.x * blockDim.x + threadIdx.x; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = blockIdx.y * blockDim.y + threadIdx.y; force f, temp_f; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; chargeCount; i++) { temp_f.calculate(dev_charges[i], x, y); f += temp_f; } screen[x + y * width] = getColor(f); }</code> </pre><br><h4>  Conclusion </h4><br>  Often people skip the article because the conclusion is important.  I have nothing to say here, except how to publish a picture that I did.  A link to an almost empty repository can be found <a href="https://github.com/Vest/ElectroField">here</a> . <br><img src="http://habrastorage.org/storage2/3cd/e28/d58/3cde28d5846677bd7ee66a0bb20d0730.png"><br>  In principle, there is much to develop - for example, you can add an animation showing how the field changes as charges move.  But again, if this is interesting. </div><p>Source: <a href="https://habr.com/ru/post/164499/">https://habr.com/ru/post/164499/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../164489/index.html">Ways of moving computer characters (Part 1)</a></li>
<li><a href="../164491/index.html">Homemade lights on quadrocopter</a></li>
<li><a href="../164493/index.html">Directives in AngularJS</a></li>
<li><a href="../164495/index.html">Analysis and optimization of a single query in EclipseLink</a></li>
<li><a href="../164497/index.html">Online IDE - a tribute to cloud fashion or the inevitability of the development environment?</a></li>
<li><a href="../164501/index.html">New Year's IT ball</a></li>
<li><a href="../164507/index.html">Winter tale in your Android'e</a></li>
<li><a href="../164509/index.html">Close 2012</a></li>
<li><a href="../164515/index.html">New Year's Programming Contest 2013 (C ++)</a></li>
<li><a href="../164517/index.html">Happy new year friends! Happy New Year!</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>