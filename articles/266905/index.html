<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>FP on Scala: What is a functor?</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A specialist embarking on the study of functional programming faces both the ambiguity and confusion of terminology, as well as constant references to...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>FP on Scala: What is a functor?</h1><div class="post__text post__text-html js-mediator-article">  A specialist embarking on the study of functional programming faces both the ambiguity and confusion of terminology, as well as constant references to ‚Äúserious mathematics‚Äù. <br><br>  In this article, without using the theory of categories on the one hand and the esoteric language mechanisms of Scala on the other hand, two important concepts are considered <br><ul><li>  <b>co-variant functor</b> </li><li>  <b>contravariant functor</b> </li></ul>  which are the starting point for understanding the whole set of categorical constructions, where you can include <br><ul><li>  <b>Exponential (Invariant) Functor</b> , <b>BiFunctor</b> , <b>ProFunctor</b> </li><li>  <b>Applicative Functor</b> , <b>Arrow</b> , <b>Monad / Co-Monad</b> </li><li>  <b>Monad Transformers</b> , <b>Kleisli</b> , <b>Natural Transformations</b> </li></ul><br>  The origin of categorical terminology is explained, the role of language mechanisms in the implementation of categorical abstractions is indicated, and several covariant ( <b><a href="http://www.scala-lang.org/api/current/index.html">Option</a> , <a href="http://www.scala-lang.org/files/archive/nightly/docs/library/index.html">Try</a> , <a href="http://www.scala-lang.org/files/archive/nightly/docs/library/index.html">Future</a> , <a href="http://www.scala-lang.org/api/current/index.html">List</a> , <a href="http://www.scala-lang.org/api/2.10.2/index.html">Parser</a></b> ) and contravariant ( <b><a href="http://www.scala-lang.org/api/current/index.html">Ordering</a> , <a href="http://www.scala-lang.org/api/current/index.html">Equiv</a></b> ) functors from the Scala standard library are considered. <br><br>  The first article in the "categorical series": <br><ol><li>  FP on Scala: what is a functor? </li><li>  <a href="http://habrahabr.ru/company/golovachcourses/blog/267087/">FP on Scala: Invariant Functor</a> </li></ol><br>  If you want to immerse yourself in the world of Scala, mathematics and functional programming - try the <b>online course <a href="https://www.udemy.com/scala-for-java-developers-ru/%3FcouponCode%3DHABR-COVARIANT-FUNCTOR">Scala for Java Developers</a></b> (video + tests, for only 25% of the price!). 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  <a href="http://habrahabr.ru/company/golovachcourses/blog/266905/">About language abstraction mechanisms</a> </li><li>  <a href="http://habrahabr.ru/company/golovachcourses/blog/266905/">About category theory and Haskell</a> </li><li>  <a href="http://habrahabr.ru/company/golovachcourses/blog/266905/">What is a covariant functor?</a> </li><li>  <a href="http://habrahabr.ru/company/golovachcourses/blog/266905/">Examples of covariant functors</a> </li><li>  <a href="http://habrahabr.ru/company/golovachcourses/blog/266905/">Covariant functor: Identity Law</a> </li><li>  <a href="http://habrahabr.ru/company/golovachcourses/blog/266905/">Covariant functor: Composition Law</a> </li><li>  <a href="http://habrahabr.ru/company/golovachcourses/blog/266905/">Covariant functor: use for optimization</a> </li><li>  <a href="http://habrahabr.ru/company/golovachcourses/blog/266905/">What is a contravariant functor?</a> </li><li>  <a href="http://habrahabr.ru/company/golovachcourses/blog/266905/">Examples of contravariant functors</a> </li><li>  <a href="http://habrahabr.ru/company/golovachcourses/blog/266905/">Contravariant functor: Identity Law</a> </li><li>  <a href="http://habrahabr.ru/company/golovachcourses/blog/266905/">Contravariant functor: Composition Law</a> </li><li>  <a href="http://habrahabr.ru/company/golovachcourses/blog/266905/">What's next?</a> </li></ul><br><a name="habracut"></a><a name="1"></a><br><h3>  About language abstraction mechanisms </h3><br>  Immersion in any fundamentally new programming language includes the study of: <br><ol><li>  Language mechanisms for new types of abstraction. </li><li>  Typical idioms / patterns in which these types of abstraction are used. </li></ol><br>  Example: OOP studies the concepts of class, instance, inheritance, polymorphism, encapsulation, delegation, ... and GoF design patterns in which all this variety of abstraction mechanisms are used. <br><br>  In my opinion, the main problem with the transition Java =&gt; Scala is that programmers do not learn new abstraction mechanisms (generics of higher kind, path dependent types, types classes, macroses, ...) because they don‚Äôt understand why . <br><br>  But they cannot start using them because as soon as they start talking about ‚Äúobjects of abstraction‚Äù (functor, monad, monoid, dependent types, ...), theorists from modern mathematics appear (category theory, abstract algebra, mathematical logic) and swoop "knock over all the pieces from the board."  From the point of view of programmers, mathematicians often behave like fanatics of the Witness sect of Adventures of Categories / Homotopic Theory of Types / Calculus of Constructions: instead of speaking "in our language" and giving specific examples from the field of programming, they sypyat terms from abstract mathematics and refer to their own <a href="http://www.amazon.com/Categories-Working-Mathematician-Graduate-Mathematics/dp/0387984038/">Sacred Texts</a> . <br><br>  In this article, the functors (covariant and contravariant) are analyzed without recourse to category theory and based only on the basic capabilities of Scala.  <b>Type classes</b> and <b>generics of higher kind are</b> not used (as is done, for example, by the authors of the Scalaz libraries: <a href="https://github.com/scalaz/scalaz/blob/series/7.2.x/core/src/main/scala/scalaz/Functor.scala">scala.scalaz.Functor</a> + <a href="https://github.com/scalaz/scalaz/blob/series/7.2.x/core/src/main/scala/scalaz/Contravariant.scala">scala.scalaz.Contravariant</a> , Cats: <a href="https://github.com/non/cats/blob/master/core/src/main/scala/cats/Functor.scala">scala.cats.Functor</a> + <a href="https://github.com/non/cats/blob/master/core/src/main/scala/cats/functor/Contravariant.scala">cats.functor.Contravariant</a> , Algebird: <a href="https://github.com/twitter/algebird/blob/develop/algebird-core/src/main/scala/com/twitter/algebird/Functor.scala">com. twitter.algebird.Functor</a> ).  Please note, often in the names of the types corresponding to the idioms covariant functor and contravariant functor, use the abbreviated names - Functor and Contravariant. <br><br>  Generally speaking, functional programming on Scala (L2-L3) is an offset from Java in several directions (I see three).  At the same time, the displacement is characterized simultaneously by four ‚Äúcomponents‚Äù: <br><ol><li>  New patterns / idioms / pearls programming. </li><li>  New Scala language mechanisms for implementing these idioms. </li><li>  New Scala libraries with implementation of idioms based on language mechanisms. </li><li>  New sections of mathematics, which served as a source for key ideas of idioms. </li></ol><br>  It should be noted that <br><ul><li>  Studying idioms is a <b>must</b> (this is the ‚ÄúFP core‚Äù). </li><li>  Learning language abstraction mechanisms - <b>required in production mode</b> for implementing idioms adapted for reuse. </li><li>  Studying typical Scala functional libraries - <b>preferably in production mode</b> for reuse of already written and debugged idioms. </li><li>  Studying the relevant section of mathematics is <b>not necessary</b> for understanding or using idioms. </li></ul><br>  At a minimum, ‚Äúthree displacements‚Äù can be distinguished: categorical, algebraic, and logical (by the names of the sections of mathematics) <br><table><tbody><tr><th>  FP Idioms </th><th>  Scala mechanisms </th><th>  Scala Libraries </th><th>  Sections of mathematics </th></tr><tr><td>  Covariant functor, applicative functor, monad, arrow </td><td>  Type classes, generics of higher kind </td><td>  Scalaz, Cats </td><td>  Category Theory </td></tr><tr><td>  Dependent pair, dependent function </td><td>  Path dependent types </td><td>  Shapeless </td><td>  Mathematical logic </td></tr><tr><td>  Monoid, group, field, ring </td><td>  Type classes, generics of higher kind </td><td>  Algebird, Spire </td><td>  Algebra </td></tr></tbody></table><br>  In short, then: <br><ul><li>  <b>generics of higher king</b> are used to construct a reusable abstraction (for example, a covariant functor).  In OOP, in this case, an ancestor type is usually created. </li><li>  <b>type classes</b> serve to ‚Äúapply abstraction‚Äù to your code (the user class ‚Äúbecomes‚Äù a covariant functor).  In OOP, in this case, they are usually inherited from ancestor abstraction. </li></ul><br>  Our examples will not use generics of higher king + type classes and therefore will not be adapted for reuse (and the ‚Äúgood old OOP tricks‚Äù are not particularly suitable here).  But even without being ready for reuse, our examples will well demonstrate the essence of idioms. <br><br><a name="2"></a><br><h3>  About category theory and Haskell </h3><br>  In the middle of the 20th century, a new branch of mathematics emerged - the theory of categories (I note that mathematics themselves often call it <a href="https://en.wikipedia.org/wiki/Abstract_nonsense">‚Äúabstract nonsense‚Äù</a> ).  The theory of categories originated from general ideas / constructions that are widely used in many fundamental branches of mathematics (set theory, topology, functional analysis, ...) and currently claims the place of the foundation / base of all mathematics (replacing the set theory on which they built mathematics from the beginning of the 20th century). <br><br>  But if the theory of sets focuses on the sets themselves (elements, operations on sets, the power of a set, sets with a structure (ordered sets, partially ordered sets), ...) and set mappings (functions from set to set) are in the background, then in the theory of categories, categories are the basis, and, simply, <b>category = set + mappings</b> .  A mapping is a synonym for a function (more precisely, mapping = matching the elements of the definition domain of the elements of the value domain without specifying the transition procedure from arguments to values ‚Äã‚Äãdirectly, mapping = a function defined table, mapping = external interface of the function in the sense of <b>f: A =&gt; B</b> without specifying the "internal implementation" (function body)), and here it turns out that such an emphasis on functions as such is very important for functional programming. <br><br>  The concentration on mappings gave rise to rich functional abstractions (functors, monads, ...) and these abstractions were transferred to functional programming languages ‚Äã‚Äã(the most well-known implementations in Haskell).  Dawn of Scala (2005-2010) is shifted by 15 years from the dawn of Haskell (1990-1995), and many things are simply transferred already made from Haskell to Scala.  Thus, for a Scala programmer, it is more important to deal with implementations in Haskell, as the main source of categorial abstractions, and not in category theory itself.  This is due to the fact that during the transfer, category theory =&gt; Haskell was modified, lost or added many important details.  Important for programmers, but minor for mathematicians. <br><br>  Here is a transfer example: <br><ol><li>  Category Theory: <ul><li>  <a href="https://en.wikipedia.org/wiki/Functor">Covariant functor</a> </li><li>  <a href="http://cstheory.stackexchange.com/questions/12412/explaining-applicative-functor-in-categorical-terms-monoidal-functors">Applicative functor</a> </li><li>  Arrow </li><li>  <a href="https://en.wikipedia.org/wiki/Monad_(category_theory)">Monad</a> </li><li>  <a href="https://en.wikipedia.org/wiki/Kleisli_category">Kleisli</a> </li></ul></li><li>  Haskell: <ul><li>  <a href="https://wiki.haskell.org/Functor">Covariant functor</a> </li><li>  <a href="https://wiki.haskell.org/Applicative_functor">Applicative functor</a> </li><li>  <a href="https://www.haskell.org/arrows/">Arrow</a> </li><li>  <a href="https://wiki.haskell.org/Monad">Monad</a> </li><li>  <a href="https://hackage.haskell.org/package/data-category-0.6.1/docs/Data-Category-Kleisli.html">Kleisli</a> </li></ul></li><li>  Scala (Scalaz library) <ul><li>  <a href="https://github.com/eed3si9n/scalaz/blob/scalaz-seven/core/src/main/scala/scalaz/Functor.scala">Covariant functor</a> </li><li>  <a href="https://github.com/eed3si9n/scalaz/blob/scalaz-seven/core/src/main/scala/scalaz/Applicative.scala">Applicative functor</a> </li><li>  <a href="https://github.com/eed3si9n/scalaz/blob/scalaz-seven/core/src/main/scala/scalaz/Arrow.scala">Arrow</a> </li><li>  <a href="https://github.com/eed3si9n/scalaz/blob/scalaz-seven/core/src/main/scala/scalaz/Monad.scala">Monad</a> </li><li>  <a href="http://docs.typelevel.org/api/scalaz/nightly/index.html">Kleisli</a> </li></ul></li></ol><br><a name="3"></a><br><h3>  What is a covariant functor? </h3><br>  Some authors recommend that <b>Covariant Functor be a container</b> (to be more precise, a covariant functor is rather a ‚Äúhalf container‚Äù).  I propose to remember this metaphor, but it refers to it precisely as a metaphor, and not a definition. <br><br>  Others that <a href="https://wiki.haskell.org/Typeclassopedia"><b>Covariant Functor is the ‚Äúcomputational context‚Äù</b></a> .  This is a productive approach, but it is useful when we have fully understood the concept and are trying to ‚Äúsqueeze the maximum out of it‚Äù.  While ignoring. <br><br>  Still others offer a ‚Äúmore syntactic approach.‚Äù  <b>Covariant Functor is a certain type with a certain method</b> .  The method must comply with certain rules (two). <br><br>  I propose to use the "syntactic approach" and use the container / storage metaphor. <br><br>  From the point of view of the ‚Äúsyntactic approach,‚Äù any type of covariant functor (let's call it <b>X</b> ) has a type parameter (let's call it <b>T</b> ) with a method that has the following signature (let's call it <b>map</b> ) <br><pre><code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class">] </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">map</span></span></span></span>(f: <span class="hljs-type"><span class="hljs-type">T</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">R</span></span>): <span class="hljs-type"><span class="hljs-type">X</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>] }</code> </pre> <br>  <b>Important:</b> we will not inherit from this trait, we will look for similar types. <br><br>  The ‚Äúsyntactic approach‚Äù is good because it allows us to bring together into the general scheme many categorical constructions <br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class">] </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// covariant functor (functor) def map[R](f: T =&gt; R): X[R] // contravariant functor (contravariant) def contramap[R](f: R =&gt; T): X[R] // exponential functor (invariant functor) def xmap[R](f: (T =&gt; R, R =&gt; T)): X[R] // applicative functor def apply[R](f: X[T =&gt; R]): X[R] // monad def flatMap[R](f: T =&gt; X[R]): X[R] // comonad def coflatMap[R](f: X[T] =&gt; R): X[R] }</span></span></code> </pre><br>  Important: the methods specified here for some abstractions are the only ones required (covariant / contravariant / exponential functors), and for others (applicative functor, monad, comonad) - one of several required methods. <br><br><a name="4"></a><br><h3>  Examples of covariant functors </h3><br>  Those who have already started programming on Scala (or Java 8) can immediately call a number of ‚Äúcontainer types‚Äù, which are covariant functors: <br><br>  <b>Option</b> <br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.lang.<span class="hljs-type"><span class="hljs-type">Integer</span></span>.toHexString <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Demo</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">App</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> k: <span class="hljs-type"><span class="hljs-type">Option</span></span>[<span class="hljs-type"><span class="hljs-type">Int</span></span>] = <span class="hljs-type"><span class="hljs-type">Option</span></span>(<span class="hljs-number"><span class="hljs-number">100500</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> s: <span class="hljs-type"><span class="hljs-type">Option</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>] = k map toHexString }</code> </pre><br>  or a little closer to life <br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.lang.<span class="hljs-type"><span class="hljs-type">Integer</span></span>.toHexString <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Demo</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">App</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> k: <span class="hljs-type"><span class="hljs-type">Option</span></span>[<span class="hljs-type"><span class="hljs-type">Int</span></span>] = <span class="hljs-type"><span class="hljs-type">Map</span></span>(<span class="hljs-string"><span class="hljs-string">"A"</span></span> -&gt; <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"B"</span></span> -&gt; <span class="hljs-number"><span class="hljs-number">1</span></span>).get(<span class="hljs-string"><span class="hljs-string">"C"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> s: <span class="hljs-type"><span class="hljs-type">Option</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>] = s map toHexString }</code> </pre><br><br>  <b>Try</b> <br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.lang.<span class="hljs-type"><span class="hljs-type">Integer</span></span>.toHexString <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> scala.util.<span class="hljs-type"><span class="hljs-type">Try</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Demo</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">App</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> k: <span class="hljs-type"><span class="hljs-type">Try</span></span>[<span class="hljs-type"><span class="hljs-type">Int</span></span>] = <span class="hljs-type"><span class="hljs-type">Try</span></span>(<span class="hljs-number"><span class="hljs-number">100500</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> s: <span class="hljs-type"><span class="hljs-type">Try</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>] = k map toHexString }</code> </pre><br>  or a little closer to life <br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.lang.<span class="hljs-type"><span class="hljs-type">Integer</span></span>.toHexString <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> scala.util.<span class="hljs-type"><span class="hljs-type">Try</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Demo</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">App</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span></span>(x: <span class="hljs-type"><span class="hljs-type">Int</span></span>, y: <span class="hljs-type"><span class="hljs-type">Int</span></span>): <span class="hljs-type"><span class="hljs-type">Try</span></span>[<span class="hljs-type"><span class="hljs-type">Int</span></span>] = <span class="hljs-type"><span class="hljs-type">Try</span></span>(x / y) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> s: <span class="hljs-type"><span class="hljs-type">Try</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>] = f(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) map toHexString }</code> </pre><br><br>  <b>Future</b> <br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.lang.<span class="hljs-type"><span class="hljs-type">Integer</span></span>.toHexString <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> scala.concurrent.<span class="hljs-type"><span class="hljs-type">ExecutionContext</span></span>.<span class="hljs-type"><span class="hljs-type">Implicits</span></span>.global <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> scala.concurrent.<span class="hljs-type"><span class="hljs-type">Future</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Demo</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">App</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> k: <span class="hljs-type"><span class="hljs-type">Future</span></span>[<span class="hljs-type"><span class="hljs-type">Int</span></span>] = <span class="hljs-type"><span class="hljs-type">Future</span></span>(<span class="hljs-number"><span class="hljs-number">100500</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> s: <span class="hljs-type"><span class="hljs-type">Future</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>] = k map toHexString }</code> </pre><br>  or a little closer to life <br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.lang.<span class="hljs-type"><span class="hljs-type">Integer</span></span>.toHexString <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> scala.concurrent.<span class="hljs-type"><span class="hljs-type">ExecutionContext</span></span>.<span class="hljs-type"><span class="hljs-type">Implicits</span></span>.global <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> scala.concurrent.<span class="hljs-type"><span class="hljs-type">Future</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Demo</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">App</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calc</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">Int</span></span> = (<span class="hljs-number"><span class="hljs-number">0</span></span> to <span class="hljs-number"><span class="hljs-number">1000000000</span></span>).sum <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> k: <span class="hljs-type"><span class="hljs-type">Future</span></span>[<span class="hljs-type"><span class="hljs-type">Int</span></span>] = <span class="hljs-type"><span class="hljs-type">Future</span></span>(calc) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> s: <span class="hljs-type"><span class="hljs-type">Future</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>] = k map toHexString }</code> </pre><br><br>  <b>List</b> <br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.lang.<span class="hljs-type"><span class="hljs-type">Integer</span></span>.toHexString <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Demo</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">App</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> k: <span class="hljs-type"><span class="hljs-type">List</span></span>[<span class="hljs-type"><span class="hljs-type">Int</span></span>] = <span class="hljs-type"><span class="hljs-type">List</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">42</span></span>, <span class="hljs-number"><span class="hljs-number">100500</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> s: <span class="hljs-type"><span class="hljs-type">List</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>] = k map toHexString }</code> </pre><br><br>  <b>Parser</b> <br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.lang.<span class="hljs-type"><span class="hljs-type">Integer</span></span>.toHexString <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> scala.util.parsing.combinator._ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Demo</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RegexParsers</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">with</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">App</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> k: <span class="hljs-type"><span class="hljs-type">Parser</span></span>[<span class="hljs-type"><span class="hljs-type">Int</span></span>] = <span class="hljs-string"><span class="hljs-string">""</span></span><span class="hljs-string"><span class="hljs-string">"(0|[1-9]\d*)"</span></span><span class="hljs-string"><span class="hljs-string">""</span></span>.r ^^ { _.toInt } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> s: <span class="hljs-type"><span class="hljs-type">Parser</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>] = k map toHexString println(parseAll(k, <span class="hljs-string"><span class="hljs-string">"255"</span></span>)) println(parseAll(s, <span class="hljs-string"><span class="hljs-string">"255"</span></span>)) } &gt;&gt; [<span class="hljs-number"><span class="hljs-number">1.4</span></span>] parsed: <span class="hljs-number"><span class="hljs-number">255</span></span> &gt;&gt; [<span class="hljs-number"><span class="hljs-number">1.4</span></span>] parsed: <span class="hljs-type"><span class="hljs-type">FF</span></span></code> </pre><br><br>  In general, the metaphor of the covariant functor as a container, according to examples, works.  Really <br><ul><li>  Option - "as if the container" on one element where something can (Some), and maybe not (None). </li><li>  Try - ‚Äúas if a container‚Äù on one element, where something can lie (Success), or maybe not (Failure, or rather, an exception lies instead of an element). </li><li>  Future - ‚Äúas if a container‚Äù on one element, where something may already lie, may lie, or an exception already lies, or there will be an exception, or there will never be anything lying. </li><li>  List - a container in which there can be 0 ... N elements </li><li>  Parser is a bit more complicated here, nothing is ‚Äústored‚Äù in it, Parser is a way to extract data from a string.  However, Parser is a data source and in this it looks like a container. </li></ul><br><br>  A covariant functor is not just a method with a specific signature, it is also the fulfillment of two rules.  Mathematicians here usually refer to category theory, and they say that these rules are a consequence of the fact that the <a href="https://en.wikipedia.org/wiki/Functor">functor is a category homomorphism</a> , that is, a mapping of a category into a category that preserves their structure (the unit element of the category is the arrow element (Identity Law rule) and arrows composition rules (Composition law)). <br><br>  Such an approach is generally unproductive in programming.  Consider that in functional programming these two rules are necessary for the ability to transform programs while maintaining functionality (usually for the purpose of optimization). <br><br><a name="5"></a><br><h3>  Covariant functor: Identity Law </h3><br>  For any covariant functor, the following IdentityLaw.case0 (fun) rule must identically follow the same as IdentityLaw.case1 (fun). <br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IdentityLaw</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">case0</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">T</span></span>](fun: <span class="hljs-type"><span class="hljs-type">Functor</span></span>[<span class="hljs-type"><span class="hljs-type">T</span></span>]): <span class="hljs-type"><span class="hljs-type">Functor</span></span>[<span class="hljs-type"><span class="hljs-type">T</span></span>] = identity(fun) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">case1</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">T</span></span>](fun: <span class="hljs-type"><span class="hljs-type">Functor</span></span>[<span class="hljs-type"><span class="hljs-type">T</span></span>]): <span class="hljs-type"><span class="hljs-type">Functor</span></span>[<span class="hljs-type"><span class="hljs-type">T</span></span>] = fun.map(identity) }</code> </pre><br>  where identity is a polymorphic identity function (unit function) from Predef.scala <br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Predef</span></span></span><span class="hljs-class"> ... </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">identity</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>](x: <span class="hljs-type"><span class="hljs-type">A</span></span>): <span class="hljs-type"><span class="hljs-type">A</span></span> = x ... }</code> </pre><br>  Quite briefly, fun.map (identity) should not change anything inside a functor. <br><br>  So the container that stores the version and increments it with each mapping does not correspond to the high rank of the covariant functor <br><pre> <code class="scala hljs"><span class="hljs-comment"><span class="hljs-comment">//  -    class Holder[T](value: T, ver: Int = 0) { def map[R](f: T =&gt; R): Holder[R] = new Holder[R](f(value), ver + 1) }</span></span></code> </pre><br>  since it "counts" the number of display operations (even the display by the identity function). <br><br>  But such a code corresponds to the first rule of the functor (and the second too). <br><pre> <code class="scala hljs"><span class="hljs-comment"><span class="hljs-comment">//  -   class Holder[T](value: T, ver: Int = 0) { def map[R](f: T =&gt; R): Holder[R] = new Holder[R](f(value), ver) }</span></span></code> </pre><br>  Here the version is simply attached to the data and invariably accompanies them when displayed. <br><br><a name="6"></a><br><h3>  Covariant functor: Composition Law </h3><br>  For any covariant functor 'fun [T]' and any functions 'f:' and 'g', the following rule CompositionLaw.case0 (fun) must be identically the same as CompositionLaw.case1 (fun). <br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Lawompose</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">App</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">case0</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">T</span></span>, <span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">Q</span></span>](fun: <span class="hljs-type"><span class="hljs-type">Functor</span></span>[<span class="hljs-type"><span class="hljs-type">T</span></span>], f: <span class="hljs-type"><span class="hljs-type">T</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">R</span></span>, g: <span class="hljs-type"><span class="hljs-type">R</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">Q</span></span>): <span class="hljs-type"><span class="hljs-type">Functor</span></span>[<span class="hljs-type"><span class="hljs-type">Q</span></span>] = (fun map f) map g <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">case1</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">T</span></span>, <span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">Q</span></span>](fun: <span class="hljs-type"><span class="hljs-type">Functor</span></span>[<span class="hljs-type"><span class="hljs-type">T</span></span>], f: <span class="hljs-type"><span class="hljs-type">T</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">R</span></span>, g: <span class="hljs-type"><span class="hljs-type">R</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">Q</span></span>): <span class="hljs-type"><span class="hljs-type">Functor</span></span>[<span class="hljs-type"><span class="hljs-type">Q</span></span>] = fun map (f andThen g) }</code> </pre><br>  That is, an arbitrary functor-container, which is sequentially displayed by the function 'f' and then by the function 'g' is equivalent to the fact that we build a new function-composition of functions f and g (f andThen g) and display it once. <br><br>  Consider an example.  Since containers are often viewed as a functor, let's make our functor in the form of a recursive data type - a binary tree type container. <br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tree</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class">] </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">map</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>](f: <span class="hljs-type"><span class="hljs-type">T</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">R</span></span>): <span class="hljs-type"><span class="hljs-type">Tree</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>] } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Node</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class">](</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">value: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-class"><span class="hljs-params">, fst: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Tree</span></span></span></span><span class="hljs-class"><span class="hljs-params">[</span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-class"><span class="hljs-params">], snd: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Tree</span></span></span></span><span class="hljs-class"><span class="hljs-params">[</span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-class"><span class="hljs-params">]</span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tree</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class">] </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">map</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>](f: <span class="hljs-type"><span class="hljs-type">T</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">R</span></span>) = <span class="hljs-type"><span class="hljs-type">Node</span></span>(f(value), fst map f, snd map f) } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Leaf</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class">](</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">value: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tree</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class">] </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">map</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>](f: <span class="hljs-type"><span class="hljs-type">T</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">R</span></span>) = <span class="hljs-type"><span class="hljs-type">Leaf</span></span>(f(value)) }</code> </pre><br><br>  Here, the map method (f: T =&gt; R) applies the 'f' function to an element of type 'T' in each sheet or node (Leaf, Node) and recursively distributes to the descendants of the node (Node).  So we have <br><ul><li>  tree structure is preserved </li><li>  values ‚Äã‚Äãof the data "hanging on a tree" change </li></ul><br><br>  When you try to change the tree structure during mappings, both rules are violated (both Identity Law and Composition Law). <br><br>  NOT a functor: swapping when displaying descendants of each node <br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Node</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class">](</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">value: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-class"><span class="hljs-params">, fst: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Tree</span></span></span></span><span class="hljs-class"><span class="hljs-params">[</span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-class"><span class="hljs-params">], snd: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Tree</span></span></span></span><span class="hljs-class"><span class="hljs-params">[</span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-class"><span class="hljs-params">]</span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tree</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class">] </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">map</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>](f: <span class="hljs-type"><span class="hljs-type">T</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">R</span></span>) = <span class="hljs-type"><span class="hljs-type">Node</span></span>(f(value), snd map f, fst map f) }</code> </pre><br><br>  NOT a functor: with each map the tree grows, the leaves turn into branches <br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Leaf</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class">](</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">value: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tree</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class">] </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">map</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>](f: <span class="hljs-type"><span class="hljs-type">T</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">R</span></span>) = <span class="hljs-type"><span class="hljs-type">Node</span></span>(f(value), <span class="hljs-type"><span class="hljs-type">Leaf</span></span>(f(value)), <span class="hljs-type"><span class="hljs-type">Leaf</span></span>(f(value))) }</code> </pre><br><br>  If you look at such (incorrect) implementations of a binary tree as a functor, you can see that they, along with the data display, also count the number of map applications in the form of a change in the tree structure.  It means And react to identity and a couple of applications f and g differs from one application of f andThen g. <br><br><a name="7"></a><br><h3>  Covariant functor: use for optimization </h3><br><br>  Let's look at an example that demonstrates the use of the covariant functor axioms. <br><br>  As mappings, consider linear functions over integers. <br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LinFun</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">a: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-class"><span class="hljs-params">, b: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span></span><span class="hljs-class">) </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">apply</span></span></span></span>(k: <span class="hljs-type"><span class="hljs-type">Int</span></span>): <span class="hljs-type"><span class="hljs-type">Int</span></span> = a * k + b <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">andThen</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>](that: <span class="hljs-type"><span class="hljs-type">LinFun</span></span>): <span class="hljs-type"><span class="hljs-type">LinFun</span></span> = <span class="hljs-type"><span class="hljs-type">LinFun</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.a * that.a, that.a * <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.b + that.b) }</code> </pre><br>  Instead of the most common functions of the form T =&gt; R, I will use their subset ‚Äî linear functions over Int, since, unlike the general form, I can build compositions of linear functions in an explicit form. <br><br>  As a functor, consider a recursive container of the type of a simply connected list of integers (Int) <br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IntSeq</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">map</span></span></span></span>(f: <span class="hljs-type"><span class="hljs-type">LinFun</span></span>): <span class="hljs-type"><span class="hljs-type">IntSeq</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Node</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">value: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-class"><span class="hljs-params">, tail: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">IntSeq</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IntSeq</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">map</span></span></span></span>(f: <span class="hljs-type"><span class="hljs-type">LinFun</span></span>): <span class="hljs-type"><span class="hljs-type">IntSeq</span></span> = <span class="hljs-type"><span class="hljs-type">Node</span></span>(f(value), tail.map(f)) } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Last</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IntSeq</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">map</span></span></span></span>(f: <span class="hljs-type"><span class="hljs-type">LinFun</span></span>): <span class="hljs-type"><span class="hljs-type">IntSeq</span></span> = <span class="hljs-type"><span class="hljs-type">Last</span></span> }</code> </pre><br><br>  And now - a demonstration <br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Demo</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">App</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> seq = <span class="hljs-type"><span class="hljs-type">Node</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-type"><span class="hljs-type">Node</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-type"><span class="hljs-type">Node</span></span>(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-type"><span class="hljs-type">Node</span></span>(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-type"><span class="hljs-type">Last</span></span>)))) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> f = <span class="hljs-type"><span class="hljs-type">LinFun</span></span>(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-comment"><span class="hljs-comment">// k =&gt; 2 * k + 3 val g = LinFun(4, 5) // k =&gt; 4 * k + 5 val res0 = (seq map f) map g // slow version val res1 = seq map (f andThen g) // fast version println(res0) println(res1) } &gt;&gt; Node(17,Node(25,Node(33,Node(41,Last)))) &gt;&gt; Node(17,Node(25,Node(33,Node(41,Last))))</span></span></code> </pre><br>  We can either <br><ol><li>  TWO times to sort through all the elements of the list (TWO times to go through memory) </li><li>  and TWO times perform arithmetic operations (* and +) </li></ol><br>  either build a composition f andThen g and <br><ol><li>  One time to sort through all the elements of the list </li><li>  and ONCE perform arithmetic operations </li></ol><br><br><a name="10"></a><br><h3>  What is a contravariant functor? </h3><br>  Recall that a covariant functor is any class <b>X</b> that has a method with a specific signature (conditionally called <b>map</b> ) and obeying certain rules ( <b>Identity Law</b> , <b>Composition Law</b> ) <br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class">] </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">map</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>](f: <span class="hljs-type"><span class="hljs-type">T</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">R</span></span>): <span class="hljs-type"><span class="hljs-type">X</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>] }</code> </pre><br><br>  In turn, a contravariant functor is any class <b>X</b> that has a method (conditionally called <b>contramap</b> ) with a certain signature and obeying certain rules (they are also called <b>Identity Law</b> , <b>Composition Law</b> ) <br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class">] </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">contramap</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>](f: <span class="hljs-type"><span class="hljs-type">R</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">T</span></span>): <span class="hljs-type"><span class="hljs-type">X</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>] }</code> </pre><br><br>  At this point, the puzzled reader may stop.  Wait, but if we have a container containing <b>T</b> and we get the function <b>f: T =&gt; R</b> , then it‚Äôs clear how we get the container with <b>R.</b>  We transfer the function to the container, it immerses the function inside itself and without removing the element applies the function to it.  However, it is completely incomprehensible how, having a container with <b>T</b> and getting the function <b>f: R =&gt; T</b> , apply it in ‚Äúreverse order‚Äù ?! <br><br>  In mathematics in general, not every function has an inverse and there is no general way to find the inverse even when it exists.  In programming, we need to act constructively (not just working with existence, uniqueness, ... but building and executing constructions) ‚Äîsomehow, using the function <b>f: R =&gt; T</b> , we must build the function <b>g: T =&gt; R</b> to apply it to the contents of the container! <br><br>  And here it turns out that our metaphor (covariant functor ~ container) does not work.  Let's see why. <br><br>  Every container involves two operations. <br><ul><li>  put - put an item in a container </li><li>  get - remove item from container </li></ul><br>  however, the considered examples (Option, Try, Future, List, Parser) to some extent have a get method, but no put method!  In Option / Try / Future, an element gets into the constructor (or in the apply method from the companion object) or as a result of some action.  In general, Parser cannot be accessed, since Parser [T] - ‚Äúrecycles‚Äù strings in T. <b>Parser [T] is the source of T, not the repository!</b> <br><br>  And here lies the secret of the error in the metaphor. <br><br>  <b>A covariant functor is half a container.</b>  <b>The part that is responsible for retrieving the data.</b> <br><br>  Let's draw it as a diagram <br><br><pre>      + ------------------------- +
      |  + ------ + T |  R
      |  |  X [T] -----&gt; f: T =&gt; R ----&gt;
      |  + ------ + |
      + ------------------------- +
</pre><br>  That is, at the output of the covariant functor, the data element of type <b>T</b> lies in wait for the function <b>f: T =&gt; R,</b> and now this composition is, in turn, a covariant functor typed <b>R.</b> <br><br>  In this case, it becomes clear why not storage containers, but typical data sources Iterator and Stream are also covariant functors. <br>  ??? <br>  ??? <br><br>  Schematically, the covariant functor looks like this, we ‚Äúfasten‚Äù the transformation <b>f: R =&gt; T</b> ‚Äúat the input‚Äù, and not ‚Äúat the output‚Äù. <br><pre>      + ------------------------- +
    R |  T + ------ + |
   -----&gt; f: R =&gt; T -----&gt; X [T] |  |
      |  + ------ + |
      + ------------------------- +
</pre><br><br><a name="11"></a><br><h3>  Examples of contravariant functors </h3><br>  To search for examples of contravariant functors in the standard Scala library, we need to forget about the container metaphor and look for a type with one type parameter, which only accepts data as arguments, but does not return as a result of a function. <br><br>  As an example, you can take <a href="http://www.scala-lang.org/api/2.11.0-M2/index.html">Ordering</a> and <a href="http://www.scala-lang.org/api/2.11.0-M2/index.html">Equiv</a> <br><br>  Example: <b>Ordering</b> <br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> scala.math.<span class="hljs-type"><span class="hljs-type">Ordering</span></span>._ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Demo</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">App</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> strX: <span class="hljs-type"><span class="hljs-type">Ordering</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>] = <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> f: (<span class="hljs-type"><span class="hljs-type">Int</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">String</span></span>) = _.toString <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> intX: <span class="hljs-type"><span class="hljs-type">Ordering</span></span>[<span class="hljs-type"><span class="hljs-type">Int</span></span>] = strX on f }</code> </pre><br>  Having a way to compare strings among themselves and having a function to convert an integer to a string, I can build a way to compare numbers as strings. <br><br>  A quick note about the string <br><pre> <code class="scala hljs"> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> strX: <span class="hljs-type"><span class="hljs-type">Ordering</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>] = <span class="hljs-type"><span class="hljs-type">String</span></span></code> </pre><br>  in this case, not java.lang.String, but scala.math.Ordering.String is taken <br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> scala.math <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Ordering</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class">] </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> ... </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StringOrdering</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Ordering</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class">] </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">compare</span></span></span></span>(x: <span class="hljs-type"><span class="hljs-type">String</span></span>, y: <span class="hljs-type"><span class="hljs-type">String</span></span>) = x.compareTo(y) } <span class="hljs-keyword"><span class="hljs-keyword">implicit</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">String</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StringOrdering</span></span></span><span class="hljs-class"> ... }</span></span></code> </pre><br>  and the <b>contramap</b> method is the <b>on</b> method. <br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> scala.math <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Ordering</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class">] </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> ... </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>](f: <span class="hljs-type"><span class="hljs-type">R</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">T</span></span>): <span class="hljs-type"><span class="hljs-type">Ordering</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">Ordering</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>] { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">compare</span></span></span></span>(x: <span class="hljs-type"><span class="hljs-type">R</span></span>, y: <span class="hljs-type"><span class="hljs-type">R</span></span>) = outer.compare(f(x), f(y)) } ... }</code> </pre><br><br>  Example: <b>Equiv</b> <br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.lang.<span class="hljs-type"><span class="hljs-type">String</span></span>.<span class="hljs-type"><span class="hljs-type">CASE_INSENSITIVE_ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> scala.math.<span class="hljs-type"><span class="hljs-type">Equiv</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> scala.math.<span class="hljs-type"><span class="hljs-type">Equiv</span></span>.{fromFunction, fromComparator} <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Demo</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">App</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> strX: <span class="hljs-type"><span class="hljs-type">Equiv</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>] = fromComparator(<span class="hljs-type"><span class="hljs-type">CASE_INSENSITIVE_ORDER</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> f: (<span class="hljs-type"><span class="hljs-type">Int</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">String</span></span>) = _.toString <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> intX: <span class="hljs-type"><span class="hljs-type">Equiv</span></span>[<span class="hljs-type"><span class="hljs-type">Int</span></span>] = fromFunction((x, y) =&gt; strX.equiv(f(x), f(y))) }</code> </pre><br>  We build a string comparison method (the scala.math.Equiz equivalence relation) based on the java.lang.String.CASE_INSENSITIVE_ORDER comparator method <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> java.lang; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">String</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> ... </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Comparator&lt;String&gt; CASE_INSENSITIVE_ORDER = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CaseInsensitiveComparator(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CaseInsensitiveComparator</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Comparator</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">String</span></span></span><span class="hljs-class">&gt;, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">io</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Serializable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">compare</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String s1, String s2)</span></span></span><span class="hljs-function"> </span></span>{...} ... } ... }</code> </pre><br>  using the fromComparator method <br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Equiv</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> ... </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fromComparator</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">T</span></span>](cmp: <span class="hljs-type"><span class="hljs-type">Comparator</span></span>[<span class="hljs-type"><span class="hljs-type">T</span></span>]): <span class="hljs-type"><span class="hljs-type">Equiv</span></span>[<span class="hljs-type"><span class="hljs-type">T</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">Equiv</span></span>[<span class="hljs-type"><span class="hljs-type">T</span></span>] { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">equiv</span></span></span></span>(x: <span class="hljs-type"><span class="hljs-type">T</span></span>, y: <span class="hljs-type"><span class="hljs-type">T</span></span>) = cmp.compare(x, y) == <span class="hljs-number"><span class="hljs-number">0</span></span> } ... }</code> </pre><br>  instead of the contramap method, it uses a bulky construction based on the fromFunction method. <br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Equiv</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> ... </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fromFunction</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">T</span></span>](cmp: (<span class="hljs-type"><span class="hljs-type">T</span></span>, <span class="hljs-type"><span class="hljs-type">T</span></span>) =&gt; <span class="hljs-type"><span class="hljs-type">Boolean</span></span>): <span class="hljs-type"><span class="hljs-type">Equiv</span></span>[<span class="hljs-type"><span class="hljs-type">T</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">Equiv</span></span>[<span class="hljs-type"><span class="hljs-type">T</span></span>] { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">equiv</span></span></span></span>(x: <span class="hljs-type"><span class="hljs-type">T</span></span>, y: <span class="hljs-type"><span class="hljs-type">T</span></span>) = cmp(x, y) } ... }</code> </pre><br><br><a name="12"></a><br><h3>  Contravariant functor: Identity Law </h3><br>  As in the case of a covariant functor, the contravariant functor, in addition to the method with signature, must follow two rules. <br><br>  The first rule (Identity Law) says: for every contravariant functor <b>fun</b> , IdentityLaw.case0 (fun) must be identically equal to IdentityLaw.case1 (fun) <br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IdentityLaw</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">case0</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">T</span></span>](fun: <span class="hljs-type"><span class="hljs-type">Contravariant</span></span>[<span class="hljs-type"><span class="hljs-type">T</span></span>]): <span class="hljs-type"><span class="hljs-type">Contravariant</span></span>[<span class="hljs-type"><span class="hljs-type">T</span></span>] = identity(fun) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">case1</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">T</span></span>](fun: <span class="hljs-type"><span class="hljs-type">Contravariant</span></span>[<span class="hljs-type"><span class="hljs-type">T</span></span>]): <span class="hljs-type"><span class="hljs-type">Contravariant</span></span>[<span class="hljs-type"><span class="hljs-type">T</span></span>] = fun.contramap(identity) }</code> </pre><br>  That is, the mapping of a contravariant functor by a single function does not change it. <br><br><a name="13"></a><br><h3>  Contravariant functor: Composition Law </h3><br>  The second rule (Composition Law) says: for any contravariant functor <b>fun [T]</b> and an arbitrary pair of functions <b>f: Q =&gt; R</b> and <b>g: R =&gt; T the</b> pair must be IdentityLaw.case0 (fun) is identically equal to IdentityLaw.case1 (fun) <br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CompositionLaw</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">case0</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">Q</span></span>, <span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">T</span></span>](fun: <span class="hljs-type"><span class="hljs-type">Contravariant</span></span>[<span class="hljs-type"><span class="hljs-type">T</span></span>], f: <span class="hljs-type"><span class="hljs-type">Q</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">R</span></span>, g: <span class="hljs-type"><span class="hljs-type">R</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">T</span></span>): <span class="hljs-type"><span class="hljs-type">Contravariant</span></span>[<span class="hljs-type"><span class="hljs-type">Q</span></span>] = (fun contramap g) contramap f <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">case1</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">Q</span></span>, <span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">T</span></span>](fun: <span class="hljs-type"><span class="hljs-type">Contravariant</span></span>[<span class="hljs-type"><span class="hljs-type">T</span></span>], f: <span class="hljs-type"><span class="hljs-type">Q</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">R</span></span>, g: <span class="hljs-type"><span class="hljs-type">R</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">T</span></span>): <span class="hljs-type"><span class="hljs-type">Contravariant</span></span>[<span class="hljs-type"><span class="hljs-type">Q</span></span>] = fun contramap (f andThen g) }</code> </pre><br>  That is, the mapping of a contravariant functor sequentially by a pair of functions is equivalent to a single mapping by the composition of functions (inverted). <br><br><a name="20"></a><br><h3>  What's next? </h3><br>  The notions of a co-and contra-variant functor are only the starting point for a serious study of the use of abstractions from category theory in functional programming (in Scala terms, the transition to the use of Scalaz and Cats libraries). <br><br>  Further steps include: <br><ol><li>  Studying compositions of co- and contravariant functors (BiFunctor, ProFunctor, Exponential (Invariant) Functor) </li><li>  The study of more specialized constructions (Applicative Functor, Arrow, Monad), which already really make up a new paradigm of work with calculations, input-output, error handling, a mutating state.  Let me point out at least that every monad is a covariant functor. </li></ol><br><br>  Unfortunately, the size of the article does not allow you to tell it all at once. <br><br>  PS For those who have read the article until the very end, I offer my course <a href="https://www.udemy.com/scala-for-java-developers-ru/%3FcouponCode%3DHABR-COVARIANT-FUNCTOR">‚ÄúScala for Java Developers‚Äù</a> for only 25% of the price (just follow the link or use the coupon <b>HABR-COVARIANT-FUNCTOR</b> ).  The number of coupon codes is limited! </div><p>Source: <a href="https://habr.com/ru/post/266905/">https://habr.com/ru/post/266905/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../266895/index.html">HTML5 customization customization element</a></li>
<li><a href="../266897/index.html">Implementing a pseudo-random number generator on a FPGA using Vivado HLS 2014.4</a></li>
<li><a href="../266899/index.html">Reinforced.Typings is a library for automatically generating TypeScript-taipings and not only</a></li>
<li><a href="../266901/index.html">Using handle and intrusive reference counter-s in multi-threaded environments in the C language</a></li>
<li><a href="../266903/index.html">PSR-2, the analysis of one item of the standard. Spaces or tabs</a></li>
<li><a href="../266907/index.html">HP TippingPoint ATA Network and HP TippingPoint ATA Mail</a></li>
<li><a href="../266909/index.html">PHP and realpath_cache</a></li>
<li><a href="../266911/index.html">Crisis Junior System Administrator</a></li>
<li><a href="../266915/index.html">Technical website audit with Screaming Frog SEO Spider</a></li>
<li><a href="../266917/index.html">Search for periodic security elements of the RF Passport using the Fourier transform: part two</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>