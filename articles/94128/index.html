<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Data acquisition, part 2</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the first part of my story about data acquisition, I wrote about what tools are used to get HTML from the Internet. In this post I will tell you in...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Data acquisition, part 2</h1><div class="post__text post__text-html js-mediator-article">  In the <a href="http://habrahabr.ru/blogs/net/93958">first part of</a> my story about data acquisition, I wrote about what tools are used to get HTML from the Internet.  In this post I will tell you in more detail how to get the necessary data from this HTML, and how to transform this data into the format we need. <br><a name="habracut"></a><br><h3>  HTML Formation </h3><br>  When you get HTML from some resource, you may have two options - either ideally generated HTML that can be immediately converted to XML (that is, taken and used), or poorly formed HTML.  Most HTML, unfortunately, is poorly formed.  In this situation, there are two options: either use the HTML Agility Pack to pull out all the necessary data, or use the same library to ‚Äúcorrect‚Äù the resulting HTML and make it more XML-shaped.  Here is the most minimal example of how to remove all unclosed <code>IMG</code> elements: <br><br><blockquote> <code><font color="black"><font color="#00008B">var</font> someHtml = <font color="#A52A2A">"&lt;p&gt;&lt;img src='a.gif'&gt;hello&lt;/p&gt;"</font> ;&lt;br/&gt; <br> HtmlDocument doc = <font color="#00008B">new</font> HtmlDocument();&lt;br/&gt; <br> doc.LoadHtml(someHtml);&lt;br/&gt; <br> <font color="#006400">// fix images</font> <br> <font color="#00008B">foreach</font> ( <font color="#00008B">var</font> node <font color="#00008B">in</font> doc.DocumentNode.SelectNodes( <font color="#A52A2A">"//img"</font> ))&lt;br/&gt; <br> <font color="#00008B">if</font> (!node.OuterHtml.EndsWith( <font color="#A52A2A">"/&gt;"</font> ))&lt;br/&gt; <br> node.Remove();&lt;br/&gt; <br> Console.WriteLine(doc.DocumentNode.OuterHtml);&lt;br/&gt; <br> Console.ReadLine();&lt;br/&gt; <br></font></code> </blockquote><br>  It may seem to someone that fixing HTML is an unnecessary task - using the same <code>SelectNodes()</code> method, you can get any element, even if this element is poorly formed (malformed).  But there is one advantage that should not be forgotten - if you got the right XML, then a) you can make (or generate) XSD for this piece of XML;  and b) by getting an XSD, you can generate mappings from an XML structure on a POCO, which is much easier to work with. <br><br><h3>  Mappings </h3><br>  Data mapping is usually featured in integration systems like BizTalk.  The idea is to convert a dataset to anything ‚Äî usually it's really just another dataset.  In fact, in many cases this is a one-to-one mapping, but different conversions are often needed - for example, all HTML is text, and to get a number, you need to do a conversion ( <code>int.Parse()</code> , etc.).  Let's look at how this is done. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Suppose we get the following (primitive) structure when parsing: <br><br><blockquote> <code><font color="black">&lt;table&gt;&lt;br/&gt; <br> &lt;tr&gt;&lt;br/&gt; <br> &lt;td&gt;Alexander&lt;/td&gt;&lt;br/&gt; <br> &lt;td&gt;RD&lt;/td&gt;&lt;br/&gt; <br> &lt;/tr&gt;&lt;br/&gt; <br> &lt;tr&gt;&lt;br/&gt; <br> &lt;td&gt;Sergey&lt;/td&gt;&lt;br/&gt; <br> &lt;td&gt;MVP, RD&lt;/td&gt;&lt;br/&gt; <br> &lt;/tr&gt;&lt;br/&gt; <br> &lt;tr&gt;&lt;br/&gt; <br> &lt;td&gt;Dmitri&lt;/td&gt;&lt;br/&gt; <br> &lt;td&gt;MVP&lt;/td&gt;&lt;br/&gt; <br> &lt;/tr&gt;&lt;br/&gt; <br> &lt;/table&gt;&lt;br/&gt; <br></font></code> </blockquote><br>  And now let's imagine that we need to fix this data on the following structure: <br><br><blockquote> <code><font color="black"><font color="#00008B">class</font> Person&lt;br/&gt; <br> {&lt;br/&gt; <br> <font color="#00008B">public</font> <font color="#00008B">string</font> Name { get; set; }&lt;br/&gt; <br> <font color="#00008B">public</font> <font color="#00008B">bool</font> IsMVP { get; set; }&lt;br/&gt; <br> <font color="#00008B">public</font> <font color="#00008B">bool</font> IsRD { get; set; }&lt;br/&gt; <br> }&lt;br/&gt; <br></font></code> </blockquote><br>  For this class, it is better to create a collection class right away: <br><br><blockquote> <code><font color="black"><font color="#00008B">public</font> <font color="#00008B">class</font> PersonCollection : Collection&lt;Person&gt; {}&lt;br/&gt; <br></font></code> </blockquote><br>  Now we will generate the XSD for the source data.  The result looks like this: <br><br><blockquote> <code><font color="black">&lt;xs:schema xmlns:xs= <font color="#A52A2A">"http://www.w3.org/2001/XMLSchema"</font> &gt;&lt;br/&gt; <br> &lt;xs:element name= <font color="#A52A2A">"table"</font> &gt;&lt;br/&gt; <br> &lt;xs:complexType&gt;&lt;br/&gt; <br> &lt;xs:sequence&gt;&lt;br/&gt; <br> &lt;xs:element name= <font color="#A52A2A">"tr"</font> maxOccurs= <font color="#A52A2A">"unbounded"</font> &gt;&lt;br/&gt; <br> &lt;xs:complexType&gt;&lt;br/&gt; <br> &lt;xs:sequence&gt;&lt;br/&gt; <br> &lt;xs:element name= <font color="#A52A2A">"td"</font> type= <font color="#A52A2A">"xs:string"</font> /&gt;&lt;br/&gt; <br> &lt;xs:element name= <font color="#A52A2A">"td"</font> type= <font color="#A52A2A">"xs:string"</font> /&gt;&lt;br/&gt; <br> &lt;/xs:sequence&gt;&lt;br/&gt; <br> &lt;/xs:complexType&gt;&lt;br/&gt; <br> &lt;/xs:element&gt;&lt;br/&gt; <br> &lt;/xs:sequence&gt;&lt;br/&gt; <br> &lt;/xs:complexType&gt;&lt;br/&gt; <br> &lt;/xs:element&gt;&lt;br/&gt; <br> &lt;/xs:schema&gt;&lt;br/&gt; <br></font></code> </blockquote><br>  It is easy - probably too easy.  What's harder is getting the schema for our class collections.  (Nb: instead of a schema, you can use, for example, a database directly, but I‚Äôll probably use XSD.) Attention, a magic trick: we compile an assembly with type <code>PersonCollection</code> and then run the following command: <br><br><blockquote> <code><font color="black">xsd -t:PersonCollection <font color="#A52A2A">"04 Mapping.exe"</font> &lt;br/&gt; <br></font></code> </blockquote><br>  Do not believe it - this command generates XSD based on the CLR-type!  I note that it only makes sense to run <code>XSD</code> in the ‚Äúbit‚Äù of your system.  Despite the fact that everything is compiled for x86 in me, I had to make a 64-bit build to make <code>XSD</code> work.  The result is the following XSD file, with which you can do the mapping: <br><br><blockquote> <code><font color="black">&lt;xs:schema elementFormDefault= <font color="#A52A2A">"qualified"</font> xmlns:xs= <font color="#A52A2A">"http://www.w3.org/2001/XMLSchema"</font> &gt;&lt;br/&gt; <br> &lt;xs:element name= <font color="#A52A2A">"ArrayOfPerson"</font> nillable= <font color="#A52A2A">"true"</font> type= <font color="#A52A2A">"ArrayOfPerson"</font> /&gt;&lt;br/&gt; <br> &lt;xs:complexType name= <font color="#A52A2A">"ArrayOfPerson"</font> &gt;&lt;br/&gt; <br> &lt;xs:sequence&gt;&lt;br/&gt; <br> &lt;xs:element minOccurs= <font color="#A52A2A">"0"</font> maxOccurs= <font color="#A52A2A">"unbounded"</font> name= <font color="#A52A2A">"Person"</font> nillable= <font color="#A52A2A">"true"</font> type= <font color="#A52A2A">"Person"</font> /&gt;&lt;br/&gt; <br> &lt;/xs:sequence&gt;&lt;br/&gt; <br> &lt;/xs:complexType&gt;&lt;br/&gt; <br> &lt;xs:complexType name= <font color="#A52A2A">"Person"</font> &gt;&lt;br/&gt; <br> &lt;xs:sequence&gt;&lt;br/&gt; <br> &lt;xs:element minOccurs= <font color="#A52A2A">"1"</font> maxOccurs= <font color="#A52A2A">"1"</font> name= <font color="#A52A2A">"Name"</font> type= <font color="#A52A2A">"xs:string"</font> /&gt;&lt;br/&gt; <br> &lt;xs:element minOccurs= <font color="#A52A2A">"1"</font> maxOccurs= <font color="#A52A2A">"1"</font> name= <font color="#A52A2A">"IsMVP"</font> type= <font color="#A52A2A">"xs:boolean"</font> /&gt;&lt;br/&gt; <br> &lt;xs:element minOccurs= <font color="#A52A2A">"1"</font> maxOccurs= <font color="#A52A2A">"1"</font> name= <font color="#A52A2A">"IsRD"</font> type= <font color="#A52A2A">"xs:boolean"</font> /&gt;&lt;br/&gt; <br> &lt;/xs:sequence&gt;&lt;br/&gt; <br> &lt;/xs:complexType&gt;&lt;br/&gt; <br> &lt;/xs:schema&gt;&lt;br/&gt; <br></font></code> </blockquote><br>  Well, we have the left and right side of the mapping.  The mapping itself can be created using an application like Stylus Studio or MapForce.  Mappings are created visually, but the creation process is not <em>intuitive</em> , so if you have never worked with visual mappings, you will have to suffer a little at the beginning. <br><br>  In order to create my own mapping, I used the <a href="http://www.altova.com/mapforce.html">Altova MapForce</a> program.  In short, this program can do many different mappings, including XSD-to-XSD, which is what we need.  Mappings are generated for XSLT1 / 2, XQuery, Java, C #, and C ++.  Personally, I use XSLT2 for my own purposes, and to start the transformations I use the free <a href="http://www.altova.com/altovaxml.html">AltovaXML</a> engine, since  Everything Microsoft gives to .Net for XSLT is a real squalor.  And XQuery is not in .Net at all.  And no, the Mvp.Xml library also does not really help, although the prize for the efforts of the developers is necessary. <br><br>  The first thing we do is visually describe the mapping using the primitives available to us.  The result looks like this: <br><br><img src="http://nesteruk.org/pix/0/f520908f-6503-4eea-9ede-412dd1d91d97.jpg"><br><br><br>  Now we generate for XSLT mapping.  All that remains is to decide how to call it.  If we consider that we use AltovaXML for transformation, the code itself looks like this: <br><br><blockquote> <code><font color="black"><font color="#00008B">public</font> <font color="#00008B">static</font> <font color="#00008B">string</font> XsltTransform( <font color="#00008B">string</font> xml, <font color="#00008B">string</font> xslt)&lt;br/&gt; <br> {&lt;br/&gt; <br> <font color="#00008B">var</font> app = <font color="#00008B">new</font> Application();&lt;br/&gt; <br> <font color="#00008B">var</font> x = app.XSLT2;&lt;br/&gt; <br> x.InputXMLFromText = xml;&lt;br/&gt; <br> x.XSLFromText = xslt;&lt;br/&gt; <br> <font color="#00008B">return</font> x.ExecuteAndGetResultAsString();&lt;br/&gt; <br> }&lt;br/&gt; <br></font></code> </blockquote><br>  In order to deserialize XML into a collection, we use the following method: <br><br><blockquote> <code><font color="black"><font color="#00008B">public</font> <font color="#00008B">static</font> T FromXml&lt;T&gt;( <font color="#00008B">string</font> xml) <font color="#00008B">where</font> T : <font color="#00008B">class</font> &lt;br/&gt; <br> {&lt;br/&gt; <br> <font color="#00008B">var</font> s = <font color="#00008B">new</font> XmlSerializer( <font color="#00008B">typeof</font> (T));&lt;br/&gt; <br> <font color="#00008B">using</font> ( <font color="#00008B">var</font> sr = <font color="#00008B">new</font> StringReader(xml))&lt;br/&gt; <br> {&lt;br/&gt; <br> <font color="#00008B">return</font> s.Deserialize(sr) <font color="#00008B">as</font> T;&lt;br/&gt; <br> }&lt;br/&gt; <br> }&lt;br/&gt; <br></font></code> </blockquote><br>  That's all - after receiving our XML, it can be easily transformed: <br><br><blockquote> <code><font color="black"><font color="#00008B">string</font> xml = File.ReadAllText( <font color="#A52A2A">"Input.xml"</font> );&lt;br/&gt; <br> <font color="#00008B">string</font> xslt = File.ReadAllText( <font color="#A52A2A">"../../output/MappingProjectMapToPersonCollection.xslt"</font> );&lt;br/&gt; <br> <font color="#00008B">string</font> result = XsltTransform(xml, xslt);&lt;br/&gt; <br> <font color="#00008B">var</font> pc2 = FromXml&lt;PersonCollection&gt;(result);&lt;br/&gt; <br></font></code> </blockquote><br><h3>  Lyrics about mappings </h3><br>  It may seem to someone that mappings are superfluous, and for simple cases this may be true.  But I want to note that mappings, being an additional level of abstraction, allow you to better control the result and adapt it to changing conditions - and in the case of changing website design this is really relevant. <br><br>  Mappings and working with XML as a whole is not free - Visual Studio (even 2010) does a really bad job with it, so I used a specialized, paid program.  Although no, I'm lying of course, because mappings are supported in BizTalk (and therefore in VS2008).  And naturally, our task can be ‚Äútransposed‚Äù, in a sense, on BizTalk.  And what, for personal use, you can try if you are on an MSDN subscription. <br><br>  That's all for today.  Sources, as always, <a href="http://bitbucket.org/nesteruk/datagatheringdemos">here</a> .  Comments welcome. </div><p>Source: <a href="https://habr.com/ru/post/94128/">https://habr.com/ru/post/94128/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../94120/index.html">Steve Ballmer admitted that time was wasted on Windows Vista</a></li>
<li><a href="../94121/index.html">Stand-alone mobile phone charger</a></li>
<li><a href="../94122/index.html">Practice using arp-spoofing</a></li>
<li><a href="../94123/index.html">Internet of the future within a separate service</a></li>
<li><a href="../94126/index.html">HP makes a flexible plastic watch</a></li>
<li><a href="../94129/index.html">Open API for Google Buzz</a></li>
<li><a href="../94132/index.html">Habra users: IE is more dead than alive</a></li>
<li><a href="../94133/index.html">Replacing the cord from the laptop charger to a compact analog</a></li>
<li><a href="../94135/index.html">Waited - Launched beta Heroes of Might and Magic Online!</a></li>
<li><a href="../94138/index.html">Mobile solar charger</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>