<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How to make friends Custom View and keyboard</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 
 MoiOffice works on most modern platforms: these are the Web client, desktop versions of the application for Windows, MacOS and Linux, a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How to make friends Custom View and keyboard</h1><div class="post__text post__text-html js-mediator-article"><h2>  Introduction </h2><br>  MoiOffice works on most modern platforms: these are the Web client, desktop versions of the application for Windows, MacOS and Linux, as well as mobile applications for iOS, Android, Tizen.  And if in the development of computer applications for a long time there are basic rules for the approach to interface design, then when creating applications for mobile devices, a separate study of many features is required. <br><br><img src="https://habrastorage.org/files/5e8/2b3/76c/5e82b376c1e54d96abea6f8ae7115d6a.jpg"><br><a name="habracut"></a><br>  When developing a text editor, we abandoned the standard EditText and made our implementation of a component for entering and formatting text based on the TextureView component.  The standard mechanism did not give us the opportunity to add tables, images, apply styles, colors, work with lists, indents and much more.  Using your component gives us the flexibility to add new functionality and allows you to optimize the performance of the component. <br><br>  One of the tasks of the component is to give the user the opportunity to enter data from the keyboard, edit the text, use the autochange feature and adjust the text.  Further it will be described how to implement a custom element interacting with the keyboard, get the entered text and send the changes to the keyboard.  The creation of a custom keyboard is beyond the scope of this article (you can read <a href="https://developer.android.com/guide/topics/text/creating-input-method.html">here</a> , <a href="https://code.tutsplus.com/tutorials/create-a-custom-keyboard-on-android--cms-22615">here</a> or <a href="http://www.fampennings.nl/maarten/android/09keyboard/index.htm">here</a> ). 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <div style="text-align:center;"><img src="https://habrastorage.org/files/d08/1c0/505/d081c0505f1b48e2b2a4d71b46672178.jpg" width="300"></div><br><h3>  CustomView and keyboard </h3><br>  The whole process of interaction of View-elements with the keyboard takes place via the <a href="https://developer.android.com/reference/android/view/inputmethod/InputConnection.html">InputConnection</a> interface.  The Android SDK already has a base implementation, <a href="https://developer.android.com/reference/android/view/inputmethod/BaseInputConnection.html">BaseInputConnection</a> , which allows you to receive keyboard events, process them, and interact with the <a href="https://developer.android.com/reference/android/text/Editable.html">Editable</a> interface, which is the result of the data received for the component. <br><br>  But let's start in order.  To communicate with the keyboard, first of all it is necessary for the component being developed to determine the implementation of the interface for interaction - to subscribe to keyboard events.  In addition, the keyboard itself can transfer a number of settings that affect the type of keyboard and its behavior.  As a result, you need to override the component's method - <a href="https://developer.android.com/reference/android/view/View.html">onCreateInputConnection (...)</a> , which returns the implementation.  As an attribute, there are keyboard parameters that can be modified. <br><br><pre><code class="php hljs">@Override <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> InputConnection onCreateInputConnection(EditorInfo outAttrs) { <span class="hljs-comment"><span class="hljs-comment">//    outAttrs.inputType = InputType.TYPE_CLASS_TEXT; outAttrs.imeOptions = EditorInfo.IME_ACTION_DONE; outAttrs.initialSelEnd = outAttrs.initialSelStart = 0; //      return new BaseInputConnection(this, true); }</span></span></code> </pre> <br>  In this example, the method returns the base implementation of the interface.  And in EditorInfo parameters for the keyboard are specified.  About what exactly, you can see in the documentation <a href="https://developer.android.com/reference/android/view/inputmethod/EditorInfo.html">here</a> .  For example, using <a href="https://developer.android.com/reference/android/view/inputmethod/EditorInfo.html">inputType</a> you can specify numeric or text input for the keyboard. <br><br>  It should be noted that if <a href="https://developer.android.com/reference/android/view/inputmethod/EditorInfo.html">you</a> pass the value TYPE_NULL in inputType, then the software keyboard disables autocomplete and all events will come to View.  <a href="https://developer.android.com/reference/android/view/View.html">onKeyDown</a> (as well as when working with physical). <br><br>  If it becomes necessary to change the keyboard configuration when it is already shown (for example, the input type has changed), you should call the <a href="https://developer.android.com/reference/android/view/inputmethod/InputMethodManager.html">restartInput</a> method.  In this case, onCreateInputConnection will be recalled and new values ‚Äã‚Äãcan be passed to EditorInfo.  But it should be borne in mind that this will result in re-creation of the InputConnection itself. <br><br>  The next step is to call the <a href="https://developer.android.com/reference/android/view/View.html">setFocusableInTouchMode</a> (true) method (for example, from the <a href="https://developer.android.com/reference/android/view/View.html">onFinishInflate</a> () method or using an <a href="https://developer.android.com/reference/android/view/View.html">attribute in the markup</a> ).  With it, the component indicates that it can intercept the focus.  And interaction with the keyboard can be only for that element, which is now in focus.  If this is not done, the onCreateInputConnection method will not be called. <br><br><pre> <code class="php hljs">@Override <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> void onFinishInflate() { super.onFinishInflate(); setFocusableInTouchMode(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); ... }</code> </pre> <br>  Additionally, it is worth noting that when tapping into a component, you need to initiate the opening of the keyboard.  This will not happen automatically, so you need to take care of it.  One of the options how to do it: <br><br><pre> <code class="php hljs"> setOnClickListener(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> OnClickListener() { @Override <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> void onClick(View v) { InputMethodManager imm = (InputMethodManager) getContext().getSystemService(Context.INPUT_METHOD_SERVICE); imm.showSoftInput(v, <span class="hljs-number"><span class="hljs-number">0</span></span>); } });</code> </pre> <br>  The last thing to do is to override the <a href="https://developer.android.com/reference/android/view/View.html">onCheckIsTextEditor</a> method and return <b>TRUE</b> (false by default).  According to the documentation - is a hint for the system to automatically show the keyboard on the screen. <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CustomView</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">View</span></span></span><span class="hljs-class"> </span></span>{ ... @Override <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> boolean onCheckIsTextEditor() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; } ‚Ä¶ }</code> </pre> <br>  As a result, in order to establish interaction with the keyboard, it is necessary: <br><br>  1. Override the <a href="https://developer.android.com/reference/android/view/View.html">onCreateInputConnection</a> method, specifying the interaction interface implementation, as well as the parameters for the keyboard. <br>  2. Call <a href="https://developer.android.com/reference/android/view/View.html">setFocusableInTouchMode</a> (true) when the component is initialized. <br>  3. Call <a href="https://developer.android.com/reference/android/view/inputmethod/InputMethodManager.html">imm.showSoftInput (...)</a> to display the keyboard when tach a component. <br>  4. Return TRUE in the <a href="https://developer.android.com/reference/android/view/View.html">onCheckIsTextEditor</a> method. <br><br>  Now the mechanism was described how to start receiving events from the keyboard.  Further it will be told how to handle these events. <br><br><h3>  Input connection </h3><br>  It was already noted earlier that in the Android SDK there is a basic implementation of the InputConnection interface - <a href="https://developer.android.com/reference/android/view/inputmethod/BaseInputConnection.html">BaseInputConnection</a> .  It adds the main logic that allows you to interact with the keyboard, and delegates the received events to the Editable object, which the custom component should work with in the future.  For development, it is recommended to follow it and override the <a href="https://developer.android.com/reference/android/view/inputmethod/BaseInputConnection.html">getEditable</a> () method, passing its implementation to Editable. <br><br><pre> <code class="php hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestInputConnection</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseInputConnection</span></span></span><span class="hljs-class"> </span></span>{ ... @Override <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Editable getEditable() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mCustomView.getEditable(); } ... }</code> </pre> <br>  In more detail about the Editable interface will be described below.  In the meantime, I want to consider some InputConnection methods that may be useful to someone.  Full documentation on all methods can be found <a href="https://developer.android.com/reference/android/view/inputmethod/InputConnection.html">here</a> .  It should be noted that the sequence of method calls, the value of the parameters with which they are called, depends on the implementation of the keyboard used at the time of input on the device, and may differ. <br><br><h4>  beginBatchEdit () and endBatchEdit () </h4><br>  Informs about the start and end of a set of actions from the keyboard.  For example, using the keyboard in T9 mode, a space is entered after the text.  In this case, the call <b>finishComposingText ()</b> and <b>commitText ()</b> will be called <b>successively</b> within one batch event.  That is, the sequence will be something like this: <br><br><blockquote>  beginBatchEdit <br>  finishComposingText <br>  beginBatchEdit <br>  endBatchEdit <br>  commitText <br>  beginBatchEdit <br>  endBatchEdit <br>  endBatchEdit </blockquote><br>  Please note that batch nesting is allowed.  That is, it is necessary to count the number of started calls and the number of completed ones in order to determine whether the process has ended or not.  For example, you can look at the implementation of <b>EditableInputConnection</b> - the implementation for TextView, where increment occurs just at each begin and decrement at end. <br><br>  Important!  Until the batch is finished, it is not recommended to send events from the editor to the keyboard (for example, changing the cursor position). <br><br><h4>  setComposingText () </h4><br>  <a href="https://developer.android.com/reference/android/view/inputmethod/BaseInputConnection.html">The method</a> is called in cases where the so-called composite text is entered from the keyboard.  For example, voice input, text input in autochange mode, etc.  That is, the text that can be corrected / replaced from the keyboard. <br><br>  Example of entering the word test: <br><br><blockquote>  setComposingText t 1 <br>  setComposingText te 1 <br>  setComposingText tes 1 <br>  setComposingText test 1 </blockquote><br>  As the parameters of the method comes the new value of the composite text.  Next, this value is passed to Editable and marked with special spans (start and end mark composing text).  With each new composite text, the previous one is deleted according to the marked spans.  This is how text auto-replacement occurs. <br><br><h4>  finishComposingText () </h4><br>  It's all quite simple, the <a href="https://developer.android.com/reference/android/view/inputmethod/InputConnection.html">method</a> will be called at the moment when the keyboard decides that the text will not be further adjusted and the user will enter the final version.  Editing removes all the information about composing Text. <br><br><h4>  commitText () </h4><br>  The <a href="https://developer.android.com/reference/android/view/inputmethod/InputConnection.html">method</a> is called with the <b>CharSequence text</b> parameters <b>, int newCursorPosition</b> , when the added text is approved, that is, it is not planned to be adjusted.  For example, select from the keyboard suggest.  In this case, comes the value of the text, which should be added to the place of the current cursor or instead of the compose-text, if it was.  As well as information on the new position of the cursor for the editor.  A value of&gt; 0 (for example, 1) will indicate the position of the cursor at the end of the new text.  Any other value is at the beginning. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/374/24a/1c4/37424a1c42324510bd5fa5c5f53dff5d.png" width="300"></div><br><h4>  deleteSurroundingText () </h4><br>  The method is called with 2 parameters - <b>int beforeLength, int afterLength</b> and informs that it is necessary to delete part of the text before the current position of the cursor and after.  Moreover, if there is a selection of text, then these characters are ignored. <br><br>  For example, this method is called when the user in T9 mode clicks on the text in the editor and replaces the selected word from the list of hints. <br><br><h3>  Editable implementation </h3><br>  BaseInputConnection works closely with the Editable interface, the implementation of which needs to be passed in the <a href="https://developer.android.com/reference/android/view/inputmethod/BaseInputConnection.html">getEditable ()</a> method.  All interface methods can be divided into 3 types: <br><br>  * modification and receipt of text; <br>  * work with spans; <br>  * applying filters. <br><br>  If you look at the TextView implementation, you can see that the <a href="https://developer.android.com/reference/android/widget/EditText.html">getText ()</a> method returns Editable.  Or rather, the implementation of <a href="https://developer.android.com/reference/android/text/SpannableStringBuilder.html">SpannableStringBuilder</a> , which is basic and ready for storing and modifying text, working with filters and with spans. <br><br>  If for some reason the standard implementation does not fit, you can implement your own.  The main method of working with text changes is <a href="https://developer.android.com/reference/android/text/SpannableStringBuilder.html">replace (...)</a> .  All insert, append, delete and so on.  cause the replacement of the text of a particular site with a new one.  But you should not forget that before replacing it is necessary to apply a set of filters for text.  Further, it is important to correctly implement work with spans, which allow you to hang tags: cursor position, text selection, composing region (the beginning and end of the region for autochange), etc. <br><br><h4>  Textwatcher </h4><br>  Let's say that we are satisfied with the standard implementation of the interaction with the keyboard and the standard Editable.  Now back to the developed component and subscribe to the changes in Editable.  This is done quite simply by adding a special spans with a <a href="https://developer.android.com/reference/android/text/SpannableStringBuilder.html">TextWatcher</a> object. <br><br><pre> <code class="php hljs">mEditable.setSpan(mMyTextWatcher, <span class="hljs-number"><span class="hljs-number">0</span></span>, mEditable.length(), Spanned.SPAN_INCLUSIVE_INCLUSIVE);</code> </pre> <br>  After that, for any editable change, notifications will come.  It is important to specify the flag - SPAN_INCLUSIVE_INCLUSIVE, which allows you not to delete the listener when you call the <a href="https://developer.android.com/reference/android/text/Editable.html">clearSpans ()</a> method (for example, it is called when finishComposingText occurs). <br><br>  When receiving notifications, you can get the following information: <br><br>  * mEditable.  <a href="https://developer.android.com/reference/android/text/SpannableStringBuilder.html">toString ()</a> will return all text.  It can be displayed on the UI - this is what the user entered. <br>  * The methods of the <a href="https://developer.android.com/reference/android/text/Selection.html">Selection</a> class are needed to obtain information about the cursor and selection. <br><img src="https://habrastorage.org/files/a4c/5bd/eb5/a4c5bdeb56af4ed9951baac89b164a16.jpg"><br><h4>  setText () </h4><br>  Suppose the component has a setText () method.  You need to update the Editable value of the component being developed and notify the keyboard that the previous text in the keyboard buffer was not valid.  This is done by creating a new Editable object and calling the <a href="https://developer.android.com/reference/android/view/inputmethod/InputMethodManager.html">restartInput</a> method. <br><br><pre> <code class="php hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> void setText(@NonNull String newText) { mEditable = Editable.Factory.getInstance().newEditable(newText); mImm.restartInput(this); }</code> </pre> <br><h3>  Change cursor position </h3><br>  For full interaction with the keyboard, you must add support for cursor positioning.  If you enter text in the <b>setComposingText ()</b> and <b>commitText ()</b> methods, the value comes in the <b>cursorPosition</b> parameter, which determines whether the cursor will be placed at the beginning or at the end of the text to be added.  In the case of implementation through BaseInputConnection there is no need to worry about the position of the cursor, the logic is already implemented inside.  It is enough to use the <a href="https://developer.android.com/reference/android/text/Selection.html">Selection</a> method.  <a href="https://developer.android.com/reference/android/text/Selection.html">getSelectionStart</a> and <a href="https://developer.android.com/reference/android/text/Selection.html">getSelectionEnd</a> to find out the position. <br><br>  It is quite important to add backward support for changing the cursor.  For example, if the developed component is able to display the cursor and it has the ability to change its position, then with each change, you should notify the keyboard.  If you do not do this, subsequent keyboard input will ignore the changed position.  Also, the replacement of words in T9 mode will work incorrectly. <br><br>  For notification, use the <a href="https://developer.android.com/reference/android/view/inputmethod/InputMethodManager.html">updateSelection</a> method, where information about the new position of the pins is transferred.  It is worth remembering that until the batch in InputConnection ends, the notification should not be sent. <br><br><h4>  Word replacement with T9 </h4><br>  Now a small example, when the user uses the keyboard with T9.  Suppose that several words are entered in the editor and one of them is clicked.  When working with the standard EditText in the keyboard, a hint will be shown, when clicked, the word will be completely replaced. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/9c2/9e5/5bc/9c29e55bc7684ef6a8de1ee564c81754.gif" width="300"></div><br>  With EditText, the keyboard receives information about the new cursor position, sends back to the editor information about the currently selected composing text via the <a href="https://developer.android.com/reference/android/view/inputmethod/InputConnection.html">setComposingRegion</a> method, thereby marking the word with which it will continue to work, namely the word under the cursor.  Now, if you select one of the prompts, the method will be called: delete the current word and insert a new one. <br><br>  But research shows that just calling the updateSelection method is not enough.  The word is not replaced, but is added to the current position on the cursor, since setComposingRegion is not called. <br><br>  To find a solution, it is worth looking at the sequence of InputMethodManager called methods when working with EditText, which turns out like this: <br><br><pre> <code class="hljs pgsql">inputMethodManager.viewClicked(<span class="hljs-keyword"><span class="hljs-keyword">view</span></span>); inputMethodManager.updateSelection(<span class="hljs-keyword"><span class="hljs-keyword">view</span></span>, cursorPosition, cursorPosition, cursorPosition, cursorPosition); //    <span class="hljs-number"><span class="hljs-number">-1</span></span>  composing region  . inputMethodManager.updateSelection(<span class="hljs-keyword"><span class="hljs-keyword">view</span></span>, cursorPosition, cursorPosition, <span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>);</code> </pre> <br>  Now, if we add the specified lines to the processing of clicking on a component, the keyboard will start calling setComposingRegion and the text will be replaced correctly. <br><br><h4>  Code example </h4><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CustomView</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">View</span></span></span><span class="hljs-class"> </span></span>{ @NonNull <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Editable mEditable; @NonNull <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> InputMethodManager mImm; @NonNull <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> MyTextWatcher mMyTextWatcher = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MyTextWatcher(); <span class="hljs-comment"><span class="hljs-comment">/** *   ,     .  &gt; 0 -  . */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> int mBatch; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> CustomView(Context context, AttributeSet attrs, int defStyleAttr) { super(context, attrs, defStyleAttr); mImm = (InputMethodManager) getContext().getSystemService(Context.INPUT_METHOD_SERVICE); <span class="hljs-comment"><span class="hljs-comment">//  editable. mEditable = Editable.Factory.getInstance().newEditable(""); Selection.setSelection(mEditable, 0); //    setFocusableInTouchMode(true); //     setOnClickListener(v -&gt; mImm.showSoftInput(v, 0)); //       Editable mEditable.setSpan(mMyTextWatcher, 0, mEditable.length(), Spanned.SPAN_INCLUSIVE_INCLUSIVE); } @Override public InputConnection onCreateInputConnection(EditorInfo outAttrs) { outAttrs.inputType = InputType.TYPE_CLASS_TEXT; outAttrs.imeOptions = EditorInfo.IME_ACTION_DONE; outAttrs.initialSelEnd = outAttrs.initialSelStart = 0; //    . return new BaseInputConnection(this, true) { @Override public Editable getEditable() { return mEditable; } @Override public boolean endBatchEdit() { mBatch++; return super.endBatchEdit(); } @Override public boolean beginBatchEdit() { mBatch--; return super.beginBatchEdit(); } }; } @Override public boolean onCheckIsTextEditor() { return true; } /** *      . */ public void setText(@NonNull String newText) { mEditable = Editable.Factory.getInstance().newEditable(newText); mImm.restartInput(this); } @Override public boolean onTouchEvent(MotionEvent event) { if (event.getAction() == MotionEvent.ACTION_UP &amp;&amp; mBatch == 0) { int cursorPosition = 0; //    (   ) // notify keyboard that cursor position has changed. mImm.viewClicked(this); mImm.updateSelection(this, cursorPosition, cursorPosition, cursorPosition, cursorPosition); mImm.updateSelection(this, cursorPosition, cursorPosition, -1, -1); } return super.onTouchEvent(event); } private class MyTextWatcher implements TextWatcher { @Override public void beforeTextChanged(CharSequence charSequence, int i, int i1, int i2) {} @Override public void onTextChanged(CharSequence charSequence, int i, int i1, int i2) { Log.d("CustomView", "Current text: " + mEditable); } @Override public void afterTextChanged(Editable editable) {} } }</span></span></code> </pre> <br><h2>  Total </h2><br>  Creating your own editor component that is not inherited from EditText is a rather rare task.  But if you come across it, you have to engage in keyboard support.  As it was already written in the article, the easiest way is to use a ready-made implementation, which is in the SDK.  But if for some reason it does not fit, then it is necessary first of all to rely on the methods described in the article - this is the basis.  You can then read more documentation.  And the most productive way is to look into the source code of TextView. </div><p>Source: <a href="https://habr.com/ru/post/320788/">https://habr.com/ru/post/320788/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../320776/index.html">Google Chrome Extensions: a quick do-it-yourself translator</a></li>
<li><a href="../320778/index.html">Recheck SharpDevelop: What's New?</a></li>
<li><a href="../320780/index.html">Vysor is a handy tool for testing.</a></li>
<li><a href="../320782/index.html">Agile is dead, long live ... Agile</a></li>
<li><a href="../320784/index.html">Kamailio SIP proxy: an example of installation and minimum configuration</a></li>
<li><a href="../320790/index.html">Cloud surveillance: what everyone should know?</a></li>
<li><a href="../320792/index.html">Web Standards Days: Eternal Front End Values</a></li>
<li><a href="../320794/index.html">IT-meetup Superjob ‚ÄúiOS - architecture of design, code, deployment‚Äù (report, presentation, video)</a></li>
<li><a href="../320796/index.html">How to make a girl an offer with the help of social engineering</a></li>
<li><a href="../320798/index.html">The first Russian motherboard of the mass segment</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>