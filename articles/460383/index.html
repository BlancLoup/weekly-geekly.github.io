<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Screen transitions in Legend of Zelda use the undocumented features of NES</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="For the vertical scrolling effect, in the first part of ‚ÄúThe Legend of Zelda‚Äù, the NES graphic ‚Äúhardware‚Äù manipulations are used, most likely not prov...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Screen transitions in Legend of Zelda use the undocumented features of NES</h1><div class="post__text post__text-html js-mediator-article">  For the vertical scrolling effect, in the first part of ‚ÄúThe Legend of Zelda‚Äù, the NES graphic ‚Äúhardware‚Äù manipulations are used, most likely not provided for by the console developers. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/631/466/3d0/6314663d04d4e3ed0d86c7e6d9b8611a.png" width="512"></div><br>  I do not have access to the official documentation of the Picture Processing Unit (PPU - graphics chip) of the NES console, so my statements about "undefined behavior" are rather closer to conjectures.  The graphics hardware specifications I took from the <a href="https://wiki.nesdev.com/w/index.php/PPU">NesDev Wiki</a> .  PPU is controlled by writing to registers with memory mapping.  If these registers were used in the way that was (it seems) conceived by the designers, then it would be impossible to achieve this effect: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8a5/b0e/51c/8a5b0e51c195fb1e9ba9ca282f54e61a.gif" width="512"></div><br>  When scrolling the screen vertically, the entire screen should scroll at once.  The previous GIF shows an example of partial vertical scrolling.  Part of the screen remains stationary (interface elements), and the other part (game area) scrolls vertically.  Partial vertical scrolling cannot be implemented with ‚Äústandard‚Äù operation with PPU. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In contrast, partial <em>horizontal</em> scrolling is fully defined and possible. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ae7/c29/539/ae7c295393f6706e17e788e0a1cc39e7.gif" width="512"></div><br>  Writing to a separate PPU register at the time of frame drawing can lead to graphical artifacts.  The Legend of Zelda intentionally causes an artifact that manifests as a partial vertical scrolling.  In this post I will talk a little about the NES graphics hardware and explain how the vertical scrolling trick works. <br><a name="habracut"></a><br><h2>  Types of graphics </h2><br>  The NES console has two types of graphics: <br><br><ul><li>  Sprites are tiles that can be placed in arbitrary places on the screen and moved independently of each other. </li><li>  The background is a grid of tiles that can be smoothly scrolled as a single image. </li></ul><br>  To demonstrate the difference between them, I will show a scene made up of sprites and a background: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f75/f9b/138/f75f9b138db2e818cbdb9b2fb1e7b27b.gif" width="512"></div><br>  And here is the same scene, in which only sprites are visible: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5e8/26d/817/5e826d817b637fc450046aee1473abaf.gif" width="512"></div><br>  And here is a scene in which only the background is visible: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d81/b9c/bd7/d81b9cbd7bb5101f663d4decc5ebaef7.gif" width="512"></div><br><h2>  Scrolling </h2><br>  Image Processor (NES Picture Processor) supports scrolling background images.  In the graphics graphics memory, the background is stored as a two-dimensional grid of tiles covering an area twice the width and height of the screen. <br><br>  A ‚Äúwindow‚Äù is displayed on this screen in a grid the size of a screen, and the position of this window can be precisely controlled.  With the gradual movement of the visible window on the grid creates the effect of smooth scrolling. <br><br>  The NES output video signal is 256x240 pixels.  The grid of tiles inside the memory is represented as a pixel area of ‚Äã‚Äã512x480 in size and is divided into four screen-sized rectangles, which are called ‚Äúname tables‚Äù.  Games can configure the Picture Processing Unit (PPU), indicating the position of the visible window by selecting the pixel coordinates in the grid of name tables. <br><br>  When selecting a coordinate (0, 0), the entire upper left table of names will be displayed on the screen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5d3/b5d/47f/5d3b5d47f8efdfcac271a2a7e0222e57.png"></div><br>  Moving to (125, 181), we will see a little from each name table: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/912/78f/189/91278f1891416d9f15a69238e64d1422.png"></div><br>  The visible window is minimized to the far part of the tile grid in memory.  Moving to (342, 290), we will place the upper left corner of the visible screen inside the lower right name table, and due to folding, parts of each name table will be visible: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6e6/394/c93/6e6394c9325985807a97765ebe015bcf.png"></div><br><h3>  Not enough memory! </h3><br>  Each name table has a size of 1 KB, but NES allocates only 2 KB of its video memory to these tables, so only two name tables can fit in memory at a time. <br><br>  How can there be four tables of names in it? <br><br><h4>  Mirroring Name Tables </h4><br>  The video memory is connected to the PPU in such a way that when the PPU renders a tile of one of the four seeming name tables, one of the two real tables is actually selected, and the reading is from there.  In essence, this means that the four visible name tables are actually composed of two identical pairs of tables. <br><br>  This image shows a snapshot of the contents of all four tables.  The upper left and upper right are the same, as are both lower. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/051/5b8/9b2/0515b89b2afcf122ce8df6e97e97a0a8.png" width="1024"></div><br>  Why not just store two tables of names? <br><br>  Fortunately, the exact binding between the apparent and real tables can be configured at run time.  If the game wants to perform horizontal scrolling, then it adjusts the graphics hardware so that the upper left and upper right tables are different, and they can be scrolled without noticeable duplication.  In this configuration, the upper left and lower left tables will refer to one real name table;  similarly for the two right tables.  This configuration is called "vertical mirroring" (Vertical Mirroring). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1e3/d85/49d/1e3d8549d5427f7f7271595dc5c6f49b.png"></div><br>  There is also another possible configuration - ‚ÄúHorizontal Mirroring‚Äù (Horizontal Mirroring), which games use for vertical scrolling. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/650/6a2/528/6506a2528cba5d758301f72c80f48e8b.png"></div><br>  Usually games do not scroll diagonally, because it creates artifacts around the edges of the screen due to the mirroring of the name tables. <br><br><h3>  Cartridges </h3><br>  In the cartridge of each game there is an ‚Äúiron‚Äù that allows you to configure the mirroring of the tables. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a44/8ed/3dc/a448ed3dc3849ac558d39ba0bfc5309d.jpg" width="50%"></div><br>  In some games, there is no need to switch the mirroring at all, so their horizontal or vertical mirroring is rigidly written in their cartridges.  Other games dynamically switch between these two modes, so the mirroring in their cartridges is configured programmatically.  The Legend of Zelda falls into the second category.  Finally, in the cartridges of some truly complex games there is additional video memory, that is, they do not need mirroring at all: they can perform simultaneous scrolling vertically and horizontally without visible duplication artifacts. <br><br><h3>  Real example </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d0a/d58/80e/d0ad5880e16ce58d53ee2eb922c4da04.gif" width="512"></div><br>  <i>An example of vertical scrolling that is displayed on the screen.</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7bb/ff0/b01/7bbff0b019dadb96e423ebc744aeb12c.gif" width="1024"></div><br>  <i>Shown here is a table entry of names with horizontal mirroring.</i>  <i>The current visible window is highlighted.</i> <br><br>  Remember that in the very vertical scrolling is not unusual - the unusualness lies in the vertical scrolling with <em>split screen</em> . <br><br><h2>  Split screen </h2><br>  Each frame of the video signal created by NES is drawn from top to bottom, one row of pixels at a time.  In each row, the pixels are drawn one at a time, from left to right.  Halfway through the frame drawing, the game can reconfigure PPU, which affects the display of pixels that have not been drawn yet.  One of the most common changes in the middle of the frame is the update of the horizontal scrolling position. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/873/536/98f/87353698fa1a10a55f37d5f56ebfaefd.gif" width="512"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c64/502/8e9/c645028e950b7e202815d7c4ad560fac.gif" width="1024"></div><br>  With horizontal scrolling between rooms, The Legend of Zelda always starts from the scrolling position (0, 0) and renders the interface elements at the top of the screen.  After the last row of interface pixels is drawn on the screen, the horizontal scrolling changes by an amount that increases with each frame, thanks to which the camera moves smoothly. <br><br>  The animation of the display of the name tables shows how the game switches from horizontal to vertical mirroring before scrolling, and then to horizontal again after the transition is completed.  In addition, while scrolling continues, the upper left (and lower left) tables of names are updated, they are recorded copy of the room in which the player.  After completing the scrolling, the game ceases to divide the screen and again is completely rendered from the upper left table. <br><br><h3>  Measure the degree of rendering </h3><br>  To split the screen in the desired position, the game needs to somehow find out which part of the current frame was drawn.  Pixel rows are rendered at a known frequency, so the number of the pixel row drawn can be determined by counting the number of processor cycles that have passed since the beginning of the frame. <br><br>  There is another, more accurate technique called Sprite Zero Hit. <br><br>  NES can simultaneously render up to 64 sprites.  The first sprite in the video memory is called Sprite Zero (zero sprite).  In each frame, as soon as the opaque pixel of the zero sprite is superimposed on the opaque pixel of the background, a Sprite Zero Hit event occurs.  It sets a bit in one of the PPU registers with memory mapping, which can be checked by the processor. <br><br>  To use Sprite Zero Hit to split the screen, the games have a zero sprite in a vertical position near the boundary of the split, and during rendering it is constantly checked whether the Sprite Zero Hit event occurred.  If so, the game switches from horizontal scrolling to implement the split. <br><br>  Below is a horizontal transition between rooms with and without background. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/71b/27a/076/71b27a0768844603020981c26b3f5124.gif" width="512"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2c4/4c1/95d/2c44c195dfac0b6c2d6b10aaf11674aa.gif" width="512"></div><br><br>  The brown circle that appears at the beginning of the transition and disappears at the end is a zero sprite.  Take a closer look at the interface with and without the background: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/39b/373/83d/39b37383d425937e8e5cdb598656bac5.png" width="322"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c7d/6f9/ebe/c7d6f9ebeb7c7e066e6d349eb8c57914.png" width="322"></div><br>  A zero sprite is a discolored bomb sprite, ideally matching in location with a regular bomb sprite from the game interface.  The zero sprite is configured to appear under the background, but since the black pixels of the interface are considered transparent, the zero sprite bomb would have been visible if it had not been strategically hidden behind the bomb from the interface. <br><br>  Note that Sprite Zero Hit occurs several lines of pixels before the bottom line of the interface.  It occurs on the top pixel of the bomb, which is 16 pixels from the bottom of the interface.  When Sprite Zero Hit occurs, the game starts counting processor cycles, and after completing the required number of cycles it sets horizontal scrolling. <br><br><h2>  Beam reversal suppression </h2><br>  Most of the time, the PPU console draws pixels to the screen.  There is a short period of idle time between frames, during which no rendering is performed.  This phenomenon is called reverse beam damping (Vertical Blank, or vblank).  Some types of PPU configuration changes can only be performed during vblank. <br><br><h2>  Scrolling register </h2><br>  Games change the scrolling position by writing to the PPU register called <code>PPUSCROLL</code> , which is mapped to a memory address <code>0x2005</code> .  The first write operation in <code>PPUSCROLL</code> sets the X component of the scrolling position, and the second operation sets the Y component. Similarly, the alternate recording is performed further. <br><br>  Below are shown all non-zero write operations to <code>PPUSCROLL</code> during this playback (in slow motion) of 16 screen frames with the plot of the game.  The Y component of the scrolling position is incremented every two frames.  All write operations to <code>PPUSCROLL</code> in this example are performed during the vblank, which causes the entire background to scroll with it. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cad/0d1/003/cad0d1003d55488a17d988e6607739f2.gif" width="512"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1bc/ffb/c09/1bcffbc09db9bfe792ba85981acbe4b3.gif" width="1024"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/kg/rz/fi/kgrzfigaydwrvo3qqth5bcmkecq.png"></div><br><h3>  Split screen scrolling </h3><br>  The write operations to <code>PPUSCROLL</code> during vblank take effect at the beginning of the frame, drawn immediately after the vblank.  If the scrolling position changes during the frame drawing (i.e., not during the vblank time), then this change takes effect when the drawing reaches the next row of pixels.  Partial horizontal scrolling is implemented by writing to <code>PPUSCROLL</code> while the PPU device draws the last row of pixels before scrolling. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ddf/e12/b49/ddfe12b49ce180cb921243f32e77351a.gif" width="512"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4be/38c/0bb/4be38c0bb335a414ce99a2c8d2145009.gif" width="1024"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/cu/uu/1t/cuuu1twsw4wbeynzisaewszsqo8.png"></div><br>  When updating the scrolling position in the middle of the frame, only the X position of the scrolling position is applied.  That is, component Y of the scrolling position is discarded.  Thus, if the game wants to split the screen and changes the scrolling position of the frame, it can only scroll horizontally. <br><br>  And yet: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1a0/93e/4b7/1a093e4b76c8382f08d33b4202391094.gif" width="512"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/760/184/2b0/7601842b02f37dc10abd97b93e0a9ec2.gif" width="1024"></div><br>  Believe it or not, but during this transition the value of the <code>PPUSCROLL</code> register <code>PPUSCROLL</code> not change. <br><br>  You can see under the interface a graphical artifact with a height of one pixel.  This is a bug of my emulator, caused by the lack of synchronization of processor clock cycles with pixel-by-pixel rendering. <br><br><h3>  Intervention in other registers </h3><br>  The second register, called <code>PPUADDR</code> , mapped to the memory address <code>0x2006</code> ,, is used to set the current address of the video memory.  When a game, for example, wants to change one of the tiles in the name table, it first writes the video memory address of the <code>PPUADDR</code> to <code>PPUADDR</code> , and then writes the new <code>PPUDATA</code> value to <code>PPUDATA</code> ‚Äî this is the third register mapped to the address <code>0x2007</code> . <br><br>  Writing to <code>PPUADDR</code> not during vblank (i.e., when the frame is drawn) can cause graphical artifacts.  This is because the PPU circuit, which is affected by the entry in <code>PPUADDR</code> , is also directly controlled by the PPU device in the process of obtaining tiles from the video memory to draw them.  Since the drawing process on the screen runs from top to bottom, and from left to right within the line, the PPU essentially assigns <code>PPUADDR</code> value of the address of the current <code>PPUADDR</code> drawn.  When the drawing moves from one tile to another, <code>PPUADDR</code> changes by incrementing the current value. <br><br>  Thus, writing to <code>PPUADDR</code> in the middle of a frame can change the tiles received by the PPU from memory for the time of the current frame. <br><br>  Let's write write operations to <code>PPUADDR</code> during a vertical transition.  Since the name table is also updated during the transition, the output of <em>all</em> write operations to <code>PPUADDR</code> will be too extensive.  With a horizontal transition, scrolling is set at the time of drawing a row of 63 pixels, therefore, we consider write operations to <code>PPUADDR</code> only during this line. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1a0/93e/4b7/1a093e4b76c8382f08d33b4202391094.gif" width="512"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/760/184/2b0/7601842b02f37dc10abd97b93e0a9ec2.gif" width="1024"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/3b/w0/iw/3bw0iwoau9zl8frbuh-mgh78-ia.png"></div><br>  Clearly visible pattern.  Every two frames, the address written in the row of 63 pixels is reduced by 32 (0x20).  But how does this lead to updating the actual scrolling position? <br><br><h3>  <i>Real</i> scrolling register </h3><br>  Inside the PPU there is a 15-bit register that is not mapped to the CPU.  It is used as both the current address for access to the video memory and the background scrolling configuration. <br><br>  When working with this value as with the address, bit 14 is ignored, and bits 0-13 are treated as an address in the video memory. <br><br>  When working with this value as with the scrolling configuration, its different parts have different meanings: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ra/ot/-q/raot-qzjvlglrxraw3kyrpskouk.png"></div><br>  <strong>The selection of the name table</strong> is a value from 0 to 3, which determines the current name table from which the drawing is made. <br><br>  <strong>Rough scrolling on X</strong> and <strong>Rough scrolling on Y</strong> determine the coordinate of the tile inside the selected name table.  This is the current rendered tile. <br><br>  <strong>Exact Y scrolling</strong> contains a value from 0 to 7, which determines the current vertical displacement of a row of pixels inside the current tile.  Tiles are squares with a side of 8 pixels. <br><br>  <strong>Exact scrolling on X</strong> in this register is missing.  There is a separate register containing only the horizontal offset of the current pixel, but it is not important for explaining how vertical scrolling is performed in The Legend of Zelda. <br><br>  What happens to this register when the game writes to <code>PPUADDR</code> ?  Here are the first three write operations from the demo shown above. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/nm/km/2b/nmkm2bpk5osxvd1ohc4kmne7ck4.png"></div><br>  By breaking the records at the address into scrolling components, you can clearly understand what is happening here.  Every two frames, the <strong>coarse scrolling</strong> value <strong>of Y</strong> decreases, resulting in vertical scrolling by one tile or 8 pixels. <br><br>  During each frame, the initial scrolling offset is 0.0, after which the row of pixels 63 is written to the address.  This means that the first 63 rows of pixels are drawn from the top of the selected name table containing the background of the interface.  However, the 64th row of pixels is further drawn with vertical scrolling applied from this address.  Since vertical scrolling decreases every two frames, this gives the feeling of vertical scrolling of a part of the screen. <br><br><h3>  Scroll down to scroll up </h3><br>  The Legend of Zelda cannot hide this trick completely.  It creates a visible artifact on the vertical transitions of the screen, which are noticeable if you look closely.  When moving between rooms, the first frame of the scrolling animation will scroll down.  Here is the animation in very slow motion. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/af8/a8c/79d/af8a8c79d1b4c50280c31fbf1540852a.gif" width="512"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a52/e37/9a6/a52e379a6e5d6dd444fe115d484bb846.gif" width="1024"></div><br>  In the name table mode, you can see what is actually happening.  Although it may seem to players that the visible area will scroll upwards smoothly, the scrolling transition begins by moving the visible area from the upper left name table to the lower left table, which contains a copy of the room background.  This is necessary because the interface at the top of the screen is also part of the name table, and if the visible area scrolled up from its original position, it would pass through the interface. <br><br>  Vertical scrolling is implemented by writing to the <code>PPUADDR</code> register in the middle of the frame.  The very first value is written <code>0x2800</code> .  Two frames later, <code>0x23A0</code> written, and then the value begins to decrease by 32 every second frame. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/pk/la/gh/pklagh4idqhd3jg_mfkojhfv0lq.png"></div><br>  Writing the value <code>0x2800</code> to the <code>0x2800</code> register assigns <strong>the name table</strong> <code>PPUADDR</code> to 2, which results in the rendering of the lower left name table.  Since both scrolling values ‚Äã‚Äãare 0, it will start from the top left tile of this name table.  However, the <strong>exact scrolling on Y</strong> is 2, therefore there is a two-pixel vertical offset from the top of the lower left name table.  That is why in the very first frame of the transition we see at the bottom of the screen a black bar with a height of 2 pixels.  The original scrolling value for the transition animation is shifted down by 2 pixels so that the transition is seamless. <br><br>  Two frames later, the <code>PPUADDR</code> written to <code>0x23A0</code> .  This brings us back to the upper left table of names, and we render from the 29th row of tiles, that is, the lowest one.  <strong>Accurate Y scrolling</strong> still contains 2. <br><br>  Why is it necessary to assign <strong>Precise Scrolling on Y to a</strong> value of 2?  Why doesn't the game just write <code>0x0800</code> and <code>0x03A0</code> so as not to suffer from a two-pixel offset? <br><br>  Four tables of names occupy an area of ‚Äã‚Äã4 KB in the PPU address space, from <code>0x2000</code> to <code>0x2FFF</code> .  Each tile in the table occupies one byte of video memory (in fact, they are only indices in another table), and the order of the tiles and tables of names in the video memory is such that the <strong>choice of the name table</strong> , <strong>coarse scrolling on Y</strong> and <strong>coarse scrolling on X</strong> make up the displacement of the tile inside memory areas with name tables.  That is, taking the lower 12 bits of the internal register PPU and adding them to <code>0x2000</code> , you can find the address of the tile in the video memory.  And this is no coincidence!  This is exactly how a register should be processed: both as an address register and as a scrolling register. <br><br>  But there is one flaw. <br><br>  When processed as an address register, bits 12 and 13 are considered part of the address.  During rendering, PPU constantly rewrites the register with the address of the currently drawn tile.  Since the tiles are located in the name tables, and the tables are located in the memory area from <code>0x2000</code> to <code>0x2FFF</code> , PPU assigns values ‚Äã‚Äãfrom this interval to the register. <br><br>  When a game writes to <code>PPUADDR</code> in the middle of a frame, if it does not write the tile address in the name table, the PPU will try to read <em>from somewhere else</em> in the video memory.  Any bytes that he has to count will be perceived as tiles, which is likely to lead to undesirable results.  Therefore, all values ‚Äã‚Äãwritten in the middle of the frame in <code>PPUADDR</code> must be in the range from <code>0x2000</code> to <code>0x2FFF</code> .  Taking each number in this interval and taking into account its scrolling components, the value of <strong>Precision scrolling in Y</strong> should always be equal to 2. <br><br>  This restriction means that we cannot change the <strong>exact Y scrolling in the</strong> middle of the frame, that is, using this trick to implement vertical scrolling of the screen division, we are limited to scrolling 8 pixels at a time and always two-pixel vertical offset from the tile border.  The Legend of Zelda moves 4 pixels per frame for horizontal scrolling, but 8 pixels per frame for vertical scrolling, and now we know why. <br><br>  The artifact is also noticeable when scrolling down between rooms, but in this case it occurs at the end of the animation. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/77d/13b/89a/77d13b89abce5200d348de0379f409e5.gif" width="512"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/468/eb2/9c2/468eb29c2eb3a97d7e4dd2a62682f1b9.gif" width="1024"></div><br><h2>  Additional reading </h2><br><ul><li>  <a href="https://wiki.nesdev.com/">The NesDev Wiki</a> is an invaluable resource for learning about NES hardware.  In particular, <a href="https://wiki.nesdev.com/w/index.php/PPU_scrolling">PPU scrolling</a> pages are related to this post. <br>  and <a href="https://wiki.nesdev.com/w/index.php/PPU_registers">PPU registers</a> . </li><li>  My still very unfinished NES emulator is laid out <a href="https://github.com/stevebob/mos6502">here</a> . </li></ul><br><h2>  Notes </h2><br>  Until I learned about the internal register of PPU, my emulator showed the effect of erasing on the vertical transitions of the screen of The Legend of Zelda. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/932/2a0/a5a/9322a0a5a1522a0ae0f6fbd21080286e.gif" width="512"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d1a/078/755/d1a0787558999dd61ec2ba9dc9ba9026.gif" width="1024"></div><br>  The sprite of Link was transferred to the bottom of the screen, as it should be, but the background did not scroll.  The erasure was caused by the fact that the game gradually updated the name table so that it contained the graphics of the new room, but did not update the scrolling to keep the updates off-screen. </div><p>Source: <a href="https://habr.com/ru/post/460383/">https://habr.com/ru/post/460383/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../460361/index.html">Large FAQ on the cybersecurity of medical information systems</a></li>
<li><a href="../46037/index.html">jQuery in Action in Russian already on sale</a></li>
<li><a href="../460373/index.html">"Under the hood" Turbo Pages: architecture of fast loading web pages technology</a></li>
<li><a href="../460375/index.html">The book "Machine learning for business and marketing"</a></li>
<li><a href="../460381/index.html">What is assertiveness and why is it needed?</a></li>
<li><a href="../460387/index.html">SELinux Beginner's Guide</a></li>
<li><a href="../460393/index.html">Background: what to expect from Fedora Silverblue</a></li>
<li><a href="../460397/index.html">Quick start with WebComponents</a></li>
<li><a href="../460399/index.html">SVG download indicator on Vue.js</a></li>
<li><a href="../4604/index.html">Syndication reaction</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>