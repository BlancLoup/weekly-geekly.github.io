<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>See the hidden or how good to do even better</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A long time ago, even at the very beginning of my acquaintance with jQuery, I wanted to have a tool showing what elements on the page were attached to...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>See the hidden or how good to do even better</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/storage2/08d/a7e/0c0/08da7e0c07f6ed0d968a3af8193ae318.jpg" alt="All-seeing eye" align="left">  A long time ago, even at the very beginning of my acquaintance with jQuery, I wanted to have a tool showing what elements on the page were attached to events and what these events are.  At that moment I could not find anything like it.  Not to say that I was very much looking for, but neither FireBug nor the later appeared Dragonfly had such functionality. <br><br>  Periodically, I remembered this idea, but a quick glance at Google did not give anything interesting.  Until recently. <br><br>  When in January I again wanted to see if there was anything interesting on this subject, I found the wonderful <a href="http://www.sprymedia.co.uk/article/Visual%2BEvent%2B2">Visual Event 2 bookmark</a> written by <a href="http://www.sprymedia.co.uk/">Allan Jardine</a> .  The bookmarklet worked like a clock, but there were a couple of fly in the ointment, small but nasty. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      I use Opera and all the bookmarklets on the toolbar have the same icon: <img src="https://habrastorage.org/storage2/4f3/0d7/374/4f30d7374d22542f62a34d2b85e227f8.png" alt="Bookmarklet Icon">  .  It is worth adding a couple of these bookmarks and navigate among them to become very uncomfortable.  The second unpleasant moment is that the bookmarklet loaded all of its code from the developer‚Äôs site, which resulted in even minor delays. <br><br>  Therefore, it was decided to issue a bookmarklet in the form of an extension for the Opera browser.  In addition, I have long wanted to get acquainted with the Opera Extension API.  Here is a <a href="https://addons.opera.com/ru/addons/extensions/details/visual-event-2/1.0/">link to the expansion page</a> for the most impatient.  The rest I ask under the cat, which describes all the stages of converting a bookmarklet into an extension for Opera, the problems that I encountered and the methods for solving them. <br><a name="habracut"></a><br><h4>  What is it all for </h4><br><img src="https://habrastorage.org/storage2/9b6/54e/af6/9b654eaf6ae8a00398e5b93e14b1a56e.png" alt="Expansion button" align="right"><br>  First I want to introduce you to what eventually happened.  After installing the extension <br>  <a href="https://addons.opera.com/ru/addons/extensions/details/visual-event-2/1.0/%3Fdisplay%3Den">Visual Event</a> on the Opera toolbar will be a new button.  With it, you can enable and disable the VisualEvent mode. <br><br>  <b>Attention!</b>  The button will act only on pages loaded after the extension is installed! <br><br>  After activating the button, the open HTML page will be darkened and all elements on which any event handlers are hung will be highlighted with colored rectangles: <br><img src="https://habrastorage.org/storage2/b4b/22f/401/b4b22f401dcdee74acf2dbda5d2589ab.png" alt="VisualEvent mode"><br><br>  After pointing the cursor to any of the rectangles, you will see the code of the function-handler, the file name and the string in which it was declared: <br><img src="https://habrastorage.org/storage2/f61/4df/573/f614df573dd92896c995ce419d7fa0ee.png" alt="Output of the function handler code"><br><br>  A second click on the eye button will turn off VisualEvent.  On this, in fact, nothing more than the extension does not.  Interested, can install it from the <a href="https://addons.opera.com/ru/addons/extensions/details/visual-event-2/1.0/">directory Opera extensions</a> .  Those who are interested in the details of converting a bookmarklet into an extension, I invite you to the next section. <br><br><h4>  Parse the bookmarklet </h4><br>  Before porting something, it would be good to figure out how it still works.  To this end, let's look at the code of the bookmarklet itself. <br><br>  The bookmarklet consists of the code itself added to the link and a few additional files with the style sheet and the implementation of all the functionality.  The code of the bookmarlet is extremely simple: <br><br><pre><code class="javascript hljs">(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> url = <span class="hljs-string"><span class="hljs-string">'http://example.com/VisualEvent/builds/VisualEvent_Loader.js'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> VisualEvent!=<span class="hljs-string"><span class="hljs-string">'undefined'</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( VisualEvent.instance !== <span class="hljs-literal"><span class="hljs-literal">null</span></span> ) { VisualEvent.close(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> VisualEvent(); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> n=<span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createElement(<span class="hljs-string"><span class="hljs-string">'script'</span></span>); n.setAttribute(<span class="hljs-string"><span class="hljs-string">'language'</span></span>,<span class="hljs-string"><span class="hljs-string">'JavaScript'</span></span>); n.setAttribute(<span class="hljs-string"><span class="hljs-string">'src'</span></span>,url+<span class="hljs-string"><span class="hljs-string">'?rand='</span></span>+<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>().getTime()); <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.body.appendChild(n); } })();</code> </pre> <br>  The url variable contains the address of the script loader, which provides activation of all logic.  From the listing it is clear that the code checks <b>for the presence of the</b> VisualEvent <b>object</b> and, if it is not detected, initiates its loading.  If the object is detected, it is checked whether the VisualEvent mode is activated or not.  And, depending on the results of the test, it either turns it off or on. <br><br>  In fact, this script implements the functionality of the on / off button of the VisualEvent mode, and all the logic is stored separately and <b>loaded</b> when first activated.  But, since we want to make an extension, we will need to embed all the VisualEvent code into it, thereby completely eliminating access to third-party sites and reducing the time of first activation. <br><br>  All bookmarklet code is divided into three files: <br><ul><li>  VisualEvent_Loader.js </li><li>  VisualEvent.js </li><li>  VisualEvent-jQuery.js </li></ul><br>  <i>VisualEvent_Loader.js is</i> loaded first.  it checks again whether VisualEvent was loaded before and, if that was the case, activates or deactivates the debug mode.  In case, if VisualEvent has not previously loaded, it checks whether the page uses <b>jQuery</b> .  If jQuery is used, then the <i>VisualEvent.js</i> file with the code of the bookmarklet itself is loaded.  If jQuery is not loaded, then the <i>VisualEvent-jQuery.js</i> file is loaded, containing both the VisualEvent code and the jQuery library code. <br><br>  It is clear that we will have to implement both VisualEvent activation options in the extension: with and without jQuery.  And we <b>will not be able</b> to spread the code across multiple files. <br><br>  In addition to the JS files, the bookmark uses its own style sheet from the external VisualEvent.css file. <br><br><h4>  Making a button on the panel </h4><br>  The easiest way to start developing an extension is to add a button to the toolbar.  Firstly, it is much easier to debug the extension by clicking on the button, and secondly, the presence of the button in sight is an eye-catching and does not allow the wave of enthusiasm to quickly subside. <br><br>  How to create the basic structure of the extension, how to fill in the description file config.xml and how to add a button to the toolbar I will not tell, it is all in the <a href="http://www.opera.com/addons/extensions/develop/">official manual</a> , and it was <a href="http://habrahabr.ru/post/106609/">described</a> on Habr√©. <br><br>  Having safely created the <i>config.xml</i> file, finding the icon and adding a button to the toolbar, I moved on to the next step - adapting the scripts to work in the extension mode.  And here I was waiting for the first surprise.  It turns out the code that handles pressing the button on the toolbar <b>does not have access</b> to the page over which it was pressed.  At first, I was discouraged by this behavior and even tried to find some workaround, but after a couple of experiments, I realized that this problem could not be solved. <br><br>  And then I remembered about the remarkable <a href="https://addons.opera.com/ru/addons/extensions/details/cleanpages/1.0.2/%3Fdisplay%3Den">cleanPages</a> extension, which, at the press of a button on the toolbar, selects only significant content from the page and draws it up in a readable form.  Those.  by pressing a button, something is done with the page, scripts are loaded, code is modified, etc.  And this is exactly what we need! <br><br><blockquote>  <b>Lyrical digression</b> The extension file is actually a ZIP archive with all the scripts, style sheets and pictures used.  Therefore, having an extension file is not at all difficult to unzip and see how it works inside. </blockquote><br>  An autopsy revealed that the extension should consist of <b>two scripts</b> : a button handler on the toolbar and a background script that automatically connects to all loaded pages in all tabs.  The button handler simply sends a broadcast message to all tabs with the ID of the tab on which the button was pressed, and the background script listens to all messages and, when received, activates the extension logic. <br><br>  As a result, the function of processing the button presses took the form: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">buttonClicked</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tab = opera.extension.tabs.getFocused(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( tab ) { opera.extension.broadcastMessage( <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(opera.extension.tabs.getFocused().url)+ <span class="hljs-string"><span class="hljs-string">'|'</span></span> + <span class="hljs-string"><span class="hljs-string">'VisualEvent-1.0'</span></span>); } };</code> </pre> <br>  Where the call opera.extension.broadcastMessage () just sends the broadcast message.  And the background script got this logic: <br><br><pre> <code class="javascript hljs">opera.extension.onmessage = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dataArray = e.data.split(<span class="hljs-string"><span class="hljs-string">'|'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.top == <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.self &amp;&amp; e.data &amp;&amp; <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.parse(dataArray[<span class="hljs-number"><span class="hljs-number">0</span></span>]) == <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.decodeURI(<span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.location.href.replace(<span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.location.hash, <span class="hljs-string"><span class="hljs-string">''</span></span>)) ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( <span class="hljs-string"><span class="hljs-string">'VisualEvent-1.0'</span></span> == dataArray[<span class="hljs-number"><span class="hljs-number">1</span></span>] ) { enableVisualEvent(); } } };</code> </pre> <br>  Here you can see that after receiving a message, its format is checked and the URL of the page on which the button was pressed.  Yes, it is the URL that is being checked, so if you have several identical tabs open, then VisualEvent will be activated <b>on all at the same time</b> . <br><br>  The mechanism is not without flaws, so if anyone knows a simpler way of interacting buttons and pages, I will be glad to read about it in the comments. <br><br><h4>  We write a script to process the page </h4><br>  We have already started writing a script to process the page and added a message handler to it from the toolbar button.  And this script calls the function <b>enableVisualEvent ()</b> .  I put the bookmarklet code in this function with the only difference that instead of loading the loader file, it simply calls its code, which is designed as a separate function. <br><br>  The fact is that I couldn‚Äôt find a way to connect another JavaScript file from the backup script that belongs to the same extension, so I had to write the code for each of the three source bookmarklet files ( <i>VisualEvent</i> , <i>VisualEvent_loader</i> and <i>jQuery</i> ) into a separate function and single background script. <br><br><h5>  Adapt JavaScript </h5><br>  As stated in the <a href="http://dev.opera.com/articles/view/converting-userjs-to-extensions/">guide for converting UserJS to extensions</a> . <br><br><blockquote>  Sometimes the UserJS doesn‚Äôt work as an extension, for various reasons.  ( <i>Sometimes UserJS does not work in extension mode, for various reasons</i> ) </blockquote><br>  And this is true, at least it did not work for me :).  But the same guide also contains recipes for how to deal with this disgrace.  The main reason is that the extension works in its <b>sandbox</b> and has access to the global scope of the page only through the explicit indication of the window object.  Those.  Calling jQuery as ‚Äú <b>$</b> ‚Äù or ‚Äúj <b>Query</b> ‚Äù will not work; instead, use ‚Äú <b>window. $</b> ‚Äù or ‚Äú <b>window.jQuery</b> ‚Äù.  And such corrections must be made for all global variables used in scripts. <br><br>  After all replacements have been made the extension has fully earned.  But the style sheets are not connected. <br><br><h5>  We connect CSS </h5><br>  The source code used its own style sheet and loaded it from an external file.  As I said, it was not possible to connect additional files from the extension directory to the page. As a workaround, I simply included all the CSS code in the background script and at the first initialization I create a &lt;style&gt; tag in &lt;head&gt;, writing all the CSS into it -regulations: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initCss</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> css = <span class="hljs-string"><span class="hljs-string">'&lt; CSS-&gt;'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> n = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createElement(<span class="hljs-string"><span class="hljs-string">'style'</span></span>); n.type = <span class="hljs-string"><span class="hljs-string">'text/css'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> rules = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createTextNode(css); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( n.styleSheet ) { n.styleSheet.cssText = rules.nodeValue; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { n.appendChild(rules); } <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementsByTagName(<span class="hljs-string"><span class="hljs-string">'head'</span></span>)[<span class="hljs-number"><span class="hljs-number">0</span></span>].appendChild(n); };</code> </pre> <br>  As a result, the stylesheets worked fine.  The only disadvantage is that all the CSS code has to be included in one line and manually take care of escaping quotes. <br><br><h4>  findings </h4><br>  Thanks to everyone who read it!  :) <br><br>  I would like a couple of sentences to summarize the article.  Learning new is always useful, and sometimes even interesting.  People familiar with JavaScript will not encounter any special difficulties when developing extensions.  When developing extensions, you may encounter some of their unobvious features, but a convenient <a href="http://dev.opera.com/addons/extensions/">developer guide</a> and code for existing <a href="https://addons.opera.com/ru/addons/extensions/">extensions</a> will easily allow you to deal with everything. <br><br>  By the way, Chrome users can find a <a href="https://chrome.google.com/webstore/detail/pbmmieigblcbldgdokdjpioljjninaim">similar extension</a> for it. </div><p>Source: <a href="https://habr.com/ru/post/140576/">https://habr.com/ru/post/140576/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../140570/index.html">Email vs social networks or Eight myths about email marketing</a></li>
<li><a href="../140572/index.html">Authentication on Asp.net sites using Rutoken WEB</a></li>
<li><a href="../140573/index.html">REG.RU: time for change</a></li>
<li><a href="../140574/index.html">Technical assignment on the site. Practice</a></li>
<li><a href="../140575/index.html">Report from InterSystems Global Summit 2012</a></li>
<li><a href="../140578/index.html">Do you understand move semantics?</a></li>
<li><a href="../140579/index.html">Canobuvosti, 136th edition</a></li>
<li><a href="../140580/index.html">GlobalsDB Challenge. 4th run</a></li>
<li><a href="../140581/index.html">Stop writing classes</a></li>
<li><a href="../140582/index.html">IPad 3 disassembly</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>