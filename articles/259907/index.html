<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Creating games without canvas: Matreshka.js</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Good to all the readers! 

 In the last article, we looked at how to create card games using DOM manipulations, without using canvas, like HeartStone....">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Creating games without canvas: Matreshka.js</h1><div class="post__text post__text-html js-mediator-article">  Good to all the readers! <br><br>  In the last <a href="http://habrahabr.ru/post/252897/">article,</a> we looked at how to create card games using DOM manipulations, without using canvas, like HeartStone. <br><br>  Today we will continue this topic by connecting the most useful Matreshka.js library in our case to our case. <br><img src="https://habrastorage.org/files/bba/908/077/bba908077bd94137a5f2a7f6fb13175c.jpg" alt="image"><br><a name="habracut"></a><br><h2>  Introduction </h2>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Let me briefly remind you of what we came up with last time.  Communication with the server is carried out via WebSockets, we transfer JSON objects of the form: {‚Äúmethod‚Äù: method, ‚Äúargs‚Äù: arguments}. <br>  The server side is implemented using php, the script was launched as a daemon (infinite loop) into the null stream. <br>  The client accepts the same kind of JSON string, we call the methods of the Actions object (in more detail in the last article). <br><br><div class="spoiler">  <b class="spoiler_title">socket.onmessage</b> <div class="spoiler_text"><pre><code class="javascript hljs">socket.onmessage = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> e.data === <span class="hljs-string"><span class="hljs-string">"string"</span></span>){ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> request = <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.parse(e.data); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Response: '</span></span> + request.function); Actions[request.function](request.args); }; }</code> </pre> <br></div></div><br><br><h2>  We start to introduce the nested doll </h2><br>  The very first place where you can embed a matryoshka is a menu with a list of players.  In general, the lists in the matryoshka are made very conveniently, in my opinion. <br><br>  So, the task: we get a list of players in JSON, when we connect, we need to draw them and assign events. <br>  We do not bother with the design. <br><br>  The lists in the nested doll consist of a model and a class (well, and an object of a class). <br>  In our case <br><div class="spoiler">  <b class="spoiler_title">List model</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> listModel = Matreshka.Class({ <span class="hljs-comment"><span class="hljs-comment">//   'extends': Matreshka.Object, //   Matreshka.Object  constructor: function(data){ this.jset(data); this.on('render',function(){ //     this.bindNode('name',':sandbox .name',Matreshka.binders.innerHTML()); //    this.bindNode('letsFight',':sandbox .fightButton'); //      this.on('click::letsFight',function(){ Actions.figthRequest(this.name); }); }); } });</span></span></code> </pre><br></div></div><br><br>  Let's see what happened here, what does player bindim mean? <br>  For matryoshka design <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bindNode(<span class="hljs-string"><span class="hljs-string">'name'</span></span>,<span class="hljs-string"><span class="hljs-string">':sandbox .name'</span></span>,Matreshka.binders.innerHTML());</code> </pre><br>  means that we associate the name property, which is then available as an object property (Obj.name) and some html entity, in this case, an entity with the selector ': sandbox .name', where the sandbox is a sandbox, that is, the very element that we just rented.  Let me remind you that this event is a render of one particular list item. <br>  As the third argument, passes the type of dependency.  That is how they (property and essence) are interconnected. <br>  In the matryoshka there is a standard set of binders, and in this case Matreshka.binders.innerHTML () makes the value of the property and the contents of the html-container ': sandbox .name' dependent. <br>  What is the specific relationship between them?  The most obvious: change the property of the object - the contents of the container html change. <br><br>  The basics of the model are dismantled, we move on to the class <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> listArray = Matreshka.Class({ <span class="hljs-comment"><span class="hljs-comment">//   'extends': Matreshka.Array, Model: listModel, //   itemRenderer: '&lt;li class="player"&gt;&lt;span class="name"&gt;&lt;/span&gt;&lt;span class="fightButton"&gt;&lt;/span&gt;&lt;/li&gt;', //     constructor: function(){ this.bindNode('sandbox','#players'); //    } });</span></span></code> </pre><br><br>  In class it is worthwhile to focus on two things, albeit very simple ones.  The itemRenderer property shows how each item in the list will be rendered.  In the above example, /&gt; is: sandbox, from which we count other selekotry. <br><br>  Note <br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>: function(){ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bindNode(<span class="hljs-string"><span class="hljs-string">'sandbox'</span></span>,<span class="hljs-string"><span class="hljs-string">'#players'</span></span>); <span class="hljs-comment"><span class="hljs-comment">//    }</span></span></code> </pre><br>  says that all elements of the list will be drawn inside the '#players' container. <br><br><h2>  Matryoshka in battle mode </h2><br>  When the players connected and started the game, what we have (logically): <br><ul><li>  List of cards in my hand </li><li>  List of cards in the hand of the opponent </li><li>  List of my cards on the playing field </li><li>  List of enemy cards on the playing field </li></ul><br><br>  It remains to implement these lists with the help of a nesting doll and ask them some events. <br><br><h3>  Cards in my hand </h3><br><div class="spoiler">  <b class="spoiler_title">Cards in my hand</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> myCardsModel = Matreshka.Class({ <span class="hljs-comment"><span class="hljs-comment">//   'extends': Matreshka.Object, constructor: function(data){ this.jset(data); this.on('render',function(){ this.bindNode('name',':sandbox .title',Matreshka.binders.innerHTML()); this.bindNode('attack',':sandbox .attack .value',Matreshka.binders.innerHTML()); this.bindNode('health',':sandbox .health .value',Matreshka.binders.innerHTML()); this.bindNode('mana',':sandbox .mana .value',Matreshka.binders.innerHTML()); this.bindNode('picture',':sandbox .picture',{ setValue: function(v){ this.innerHTML = '&lt;img src="img/' + v + '"&gt;' } }); this.on('click::sandbox',function(){ myArenaCards.push(this); myCards.splice(myCards.indexOf(this),1); Actions.send('putCard',this.toJSON()); }); }); } }); var myCardsArray = Matreshka.Class({ //   'extends': Matreshka.Array, Model: myCardsModel, itemRenderer: '&lt;div class="card"&gt;' +'&lt;div class="title"&gt;&lt;/div&gt;' +'&lt;div class="health"&gt;&lt;div class="svg"&gt;' + $b('#icons #heart')[0].innerHTML + '&lt;/div&gt;&lt;div class="value"&gt;&lt;/div&gt;&lt;/div&gt;' +'&lt;div class="attack"&gt;&lt;div class="svg"&gt;' + $b('#icons #attack')[0].innerHTML + '&lt;/div&gt;&lt;div class="value"&gt;&lt;/div&gt;&lt;/div&gt;' +'&lt;div class="mana"&gt;&lt;div class="svg"&gt;' + $b('#icons #diamond')[0].innerHTML + '&lt;/div&gt;&lt;div class="value"&gt;&lt;/div&gt;&lt;/div&gt;' +'&lt;div class="picture"&gt;&lt;/div&gt;' +'&lt;/div&gt;', constructor: function(){ this.bindNode('sandbox','#myhand'); //    } }); var myCards = new myCardsArray; //   </span></span></code> </pre><br></div></div><br><br>  A similar list, we will not repeat, consider how binds are applied here. <br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bindNode(<span class="hljs-string"><span class="hljs-string">'name'</span></span>,<span class="hljs-string"><span class="hljs-string">':sandbox .title'</span></span>,Matreshka.binders.innerHTML()); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bindNode(<span class="hljs-string"><span class="hljs-string">'attack'</span></span>,<span class="hljs-string"><span class="hljs-string">':sandbox .attack .value'</span></span>,Matreshka.binders.innerHTML()); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bindNode(<span class="hljs-string"><span class="hljs-string">'health'</span></span>,<span class="hljs-string"><span class="hljs-string">':sandbox .health .value'</span></span>,Matreshka.binders.innerHTML()); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bindNode(<span class="hljs-string"><span class="hljs-string">'mana'</span></span>,<span class="hljs-string"><span class="hljs-string">':sandbox .mana .value'</span></span>,Matreshka.binders.innerHTML());</code> </pre><br><br>  As we discussed above, these strings link the contents of the html node and the properties of the object. <br>  By linking them in the above way, we can easily create a map by simply pushing into our list: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Actions = { ......... cardToHand: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">card</span></span></span><span class="hljs-function">)</span></span>{ myCards.push({ <span class="hljs-attr"><span class="hljs-attr">name</span></span>: card.name, <span class="hljs-attr"><span class="hljs-attr">attack</span></span>: card.attack, <span class="hljs-attr"><span class="hljs-attr">health</span></span>: card.health, <span class="hljs-attr"><span class="hljs-attr">picture</span></span>: card.picture, <span class="hljs-attr"><span class="hljs-attr">mana</span></span>: card.mana }); } ......... }</code> </pre><br><br>  Extremely simple.  But even easier is how we can change these properties: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.health = <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre><br>  Not only will set the health indicator equal to zero, but also draw it in html in the desired object. <br>  But that's not all, we need to track changes in health, and if it becomes less than one, initiate the death of the unit.  To do this, associate the object's health property with the map itself: <br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bindNode(<span class="hljs-string"><span class="hljs-string">'health'</span></span>,<span class="hljs-string"><span class="hljs-string">':sandbox'</span></span>,{ <span class="hljs-attr"><span class="hljs-attr">setValue</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">v</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (v &lt; <span class="hljs-number"><span class="hljs-number">1</span></span>){ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.className += <span class="hljs-string"><span class="hljs-string">' die'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> iot = myArenaCards.indexOf(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); setTimeout(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ myArenaCards.splice(iot,<span class="hljs-number"><span class="hljs-number">1</span></span>); },<span class="hljs-number"><span class="hljs-number">2000</span></span>); }; } });</code> </pre><br>  The third argument, as I said, sets the communication logic.  In this example, the logic is as follows: <br>  When the value of the object's health has changed (established), we run the function <br><pre> <code class="javascript hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">v</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (v &lt; <span class="hljs-number"><span class="hljs-number">1</span></span>){ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.className += <span class="hljs-string"><span class="hljs-string">' die'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> iot = myArenaCards.indexOf(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); setTimeout(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ myArenaCards.splice(iot,<span class="hljs-number"><span class="hljs-number">1</span></span>); },<span class="hljs-number"><span class="hljs-number">2000</span></span>); }; }</code> </pre><br>  This points to the entire map, to the sandbox (second argument: ': sandbox'). <br><br><h2>  Conclusion </h2><br>  In complex applications, where you really need two-way and multiple binding, the nested doll perfectly makes life easier and creates comfort during development. <br>  After all, you can link as you like, in one case we set processing only to the received value (setValue), in the other to change the property by event (on: 'click', getValue: function () {}). <br><br><ul><li>  <a href="http://141.8.196.181/PlayingCardsMatreshka/">Example</a> (shoals of the sea, the goal - to show the technology) </li><li>  <a href="https://github.com/seokirill/PlayingCardsMatreshka">Github</a> </li></ul></div><p>Source: <a href="https://habr.com/ru/post/259907/">https://habr.com/ru/post/259907/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../259891/index.html">Personal data protection -aaS</a></li>
<li><a href="../259897/index.html">Fuel level sensor (FLS). Assembly, schemes, production</a></li>
<li><a href="../259901/index.html">Testing RequireJS Modules in Symfony2</a></li>
<li><a href="../259903/index.html">Social networks in Russia, spring 2015. Figures, trends, forecasts</a></li>
<li><a href="../259905/index.html">Who Hacked the Electric Substation: Analysis of the Digital Substation Takeover Contest</a></li>
<li><a href="../259909/index.html">How-to: Typography in the design of email-letters</a></li>
<li><a href="../259911/index.html">How we tested a static analysis on our project of a training simulator of endovascular surgery</a></li>
<li><a href="../259915/index.html">Processing Russian text data in Azure Machine Learning</a></li>
<li><a href="../259917/index.html">Welcome to the Softlayer Workshop June 16</a></li>
<li><a href="../259919/index.html">USB adapter for a B7-28 digital voltmeter based on Arduino Mega</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>