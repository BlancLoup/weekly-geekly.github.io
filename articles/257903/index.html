<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Introduction to functional programming in Python</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Speaking about functional programming, people often begin to produce a bunch of "functional" characteristics. Immutable data, first class functions, a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Introduction to functional programming in Python</h1><div class="post__text post__text-html js-mediator-article">  Speaking about functional programming, people often begin to produce a bunch of "functional" characteristics.  Immutable data, first class functions, and tail recursion optimization.  These are language features that help write functional programs.  They mention mapping, currying, and using higher-order functions.  These are programming techniques used to write functional code.  They mention parallelization, lazy computation, and determinism.  These are the benefits of functional programs. <br><br>  Hammer in.  Functional code has one property: no side effects.  It does not rely on data outside the current function, and does not change data outside the function.  All other "properties" can be derived from this. <br><br>  Non-functional function: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre><code class="python hljs">a = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">increment1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">global</span></span> a a += <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br><br>  Functional function: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">increment2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a + <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre><br><br>  Instead of walking through the list, use map and reduce. <br><a name="habracut"></a><br><h4>  Map </h4><br>  Accepts function and data set.  Creates a new collection, performs a function at each data position, and adds the return value to the new collection.  Returns a new collection. <br><br>  A simple map that takes a list of names and returns a list of lengths: <br><br><pre> <code class="python hljs">name_lengths = map(len, [<span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> name_lengths <span class="hljs-comment"><span class="hljs-comment"># =&gt; [4, 4, 3]</span></span></code> </pre><br><br>  This map squares each element: <br><br><pre> <code class="python hljs">squares = map(<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> x: x * x, [<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> squares <span class="hljs-comment"><span class="hljs-comment"># =&gt; [0, 1, 4, 9, 16]</span></span></code> </pre><br><br>  It does not accept the named function, but takes an anonymous one defined via lambda.  The lambda parameters are defined to the left of the colon.  The function body is on the right.  The result is returned implicitly. <br><br>  The non-functional code in the following example takes a list of names and replaces them with random nicknames. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> random names = [<span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>] code_names = [<span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(len(names)): names[i] = random.choice(code_names) <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> names <span class="hljs-comment"><span class="hljs-comment"># =&gt; ['', '', '']</span></span></code> </pre><br><br>  The algorithm can assign the same nicknames to different secret agents.  Hopefully this will not be a source of problems during a secret mission. <br><br>  Rewrite it via map: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> random names = [<span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>] secret_names = map(<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> x: random.choice([<span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>]), names)</code> </pre><br><br>  <b>Exercise 1</b> .  Try rewriting the following code via map.  He takes a list of real names and replaces them with nicknames, using a more reliable method. <br><br><pre> <code class="python hljs">names = [<span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(len(names)): names[i] = hash(names[i]) <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> names <span class="hljs-comment"><span class="hljs-comment"># =&gt; [6306819796133686941, 8135353348168144921, -1228887169324443034]</span></span></code> </pre><br><br><div class="spoiler">  <b class="spoiler_title">My decision:</b> <div class="spoiler_text"><pre> <code class="python hljs">names = [<span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>] secret_names = map(hash, names)</code> </pre><br></div></div><br><br><h4>  Reduce </h4><br>  Reduce accepts function and set points.  Returns the value obtained by combining all items. <br><br>  An example of a simple reduce.  Returns the sum of all items in the set: <br><br><pre> <code class="python hljs">sum = reduce(<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> a, x: a + x, [<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> sum <span class="hljs-comment"><span class="hljs-comment"># =&gt; 10</span></span></code> </pre><br><br>  x - the current item, and - the battery.  This is the value that returns the lambda execution on the previous paragraph.  reduce () iterates over all values, and for each lambda at the current values ‚Äã‚Äãof a and x, and returns the result in a for the next iteration. <br><br>  And what is the same in the first iteration?  It is equal to the first element of the collection, and reduce () starts working from the second element.  That is, the first x will be equal to the second set item. <br><br>  The following example considers how often the word "captain" is found in the list of strings: <br><br><pre> <code class="python hljs">sentences = [<span class="hljs-string"><span class="hljs-string">'  '</span></span>, <span class="hljs-string"><span class="hljs-string">'  '</span></span>, <span class="hljs-string"><span class="hljs-string">'  , '</span></span>] cap_count = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> sentence <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> sentences: cap_count += sentence.count(<span class="hljs-string"><span class="hljs-string">''</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> cap_count <span class="hljs-comment"><span class="hljs-comment"># =&gt; 3</span></span></code> </pre><br><br>  The same code using reduce: <br><br><pre> <code class="python hljs">sentences = [<span class="hljs-string"><span class="hljs-string">'  '</span></span>, <span class="hljs-string"><span class="hljs-string">'  '</span></span>, <span class="hljs-string"><span class="hljs-string">'  , '</span></span>] cap_count = reduce(<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> a, x: a + x.count(<span class="hljs-string"><span class="hljs-string">''</span></span>), sentences, <span class="hljs-number"><span class="hljs-number">0</span></span>)</code> </pre><br><br>  And where does the initial value of a come from here?  It cannot be calculated from the number of repetitions in the first line.  Therefore, it is specified as the third argument to the reduce () function. <br><br><h4>  Why is map and reduce better? </h4><br>  First, they usually fit in one line. <br><br>  Second, the important parts of the iteration ‚Äî the collection, the operation, and the return value ‚Äî are always in the same place as map and reduce. <br><br>  Thirdly, the code in the loop can change the value of previously defined variables, or affect the code after it.  By convention, map and reduce are functional. <br><br>  Fourthly, map and reduce are elementary operations.  Instead of line-by-line reading of cycles, it is easier for the reader to perceive map and reduce, embedded in complex algorithms. <br><br>  Fifth, they have a lot of friends allowing the useful, slightly modified behavior of these functions.  For example, filter, all, any and find. <br><br>  <b>Exercise 2</b> : rewrite the following code using map, reduce, and filter.  Filter accepts function and collection.  Returns a collection of those things for which the function returns True. <br><br><pre> <code class="python hljs">people = [{<span class="hljs-string"><span class="hljs-string">''</span></span>: <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>: <span class="hljs-number"><span class="hljs-number">160</span></span>}, {<span class="hljs-string"><span class="hljs-string">'  '</span></span>: <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">'  '</span></span>: <span class="hljs-number"><span class="hljs-number">80</span></span>}, {<span class="hljs-string"><span class="hljs-string">'name'</span></span>: <span class="hljs-string"><span class="hljs-string">''</span></span>}] height_total = <span class="hljs-number"><span class="hljs-number">0</span></span> height_count = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> person <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> people: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-string"><span class="hljs-string">''</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> person: height_total += person[<span class="hljs-string"><span class="hljs-string">'  '</span></span>] height_count += <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> height_count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>: average_height = height_total / height_count <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> average_height <span class="hljs-comment"><span class="hljs-comment"># =&gt; 120</span></span></code> </pre><br><br><div class="spoiler">  <b class="spoiler_title">My decision:</b> <div class="spoiler_text"><pre> <code class="python hljs">people = [{<span class="hljs-string"><span class="hljs-string">''</span></span>: <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>: <span class="hljs-number"><span class="hljs-number">160</span></span>}, {<span class="hljs-string"><span class="hljs-string">'  '</span></span>: <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">'  '</span></span>: <span class="hljs-number"><span class="hljs-number">80</span></span>}, {<span class="hljs-string"><span class="hljs-string">'name'</span></span>: <span class="hljs-string"><span class="hljs-string">''</span></span>}] heights = map(<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> x: x[<span class="hljs-string"><span class="hljs-string">''</span></span>], filter(<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> x: <span class="hljs-string"><span class="hljs-string">''</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> x, people)) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(heights) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> operator <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> add average_height = reduce(add, heights) / len(heights)</code> </pre><br></div></div><br><br><h4>  Write declaratively, not imperatively </h4><br>  The following program emulates a three-car race.  At any given time, the car either moves forward or not.  Each time the program displays the path traveled by cars.  After five intervals, the race ends. <br><br>  Examples of output: <br><br><pre> <code class="bash hljs"> - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</code> </pre><br><br>  Program text: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> random <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> random time = <span class="hljs-number"><span class="hljs-number">5</span></span> car_positions = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> time: <span class="hljs-comment"><span class="hljs-comment"># decrease time time -= 1 print '' for i in range(len(car_positions)): # move car if random() &gt; 0.3: car_positions[i] += 1 # draw car print '-' * car_positions[i]</span></span></code> </pre><br><br>  Code is imperative.  The functional version would be declarative - it would describe what needs to be done, not how to do it. <br><br><h4>  We use functions </h4><br>  Declarativity can be achieved by inserting code into functions: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> random <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> random <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">move_cars</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i, _ <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> enumerate(car_positions): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> random() &gt; <span class="hljs-number"><span class="hljs-number">0.3</span></span>: car_positions[i] += <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">draw_car</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(car_position)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">'-'</span></span> * car_position <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run_step_of_race</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">global</span></span> time time -= <span class="hljs-number"><span class="hljs-number">1</span></span> move_cars() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">''</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> car_position <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> car_positions: draw_car(car_position) time = <span class="hljs-number"><span class="hljs-number">5</span></span> car_positions = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> time: run_step_of_race() draw()</code> </pre><br><br>  To understand the program, the reader scans the main loop.  ‚ÄúIf there is time, go through one step of the race and display the result.  Check the time again. ‚Äù  If the reader needs to figure out how the race step works, he will be able to read his code separately. <br><br>  Comments are not needed, the code explains itself. <br><br>  Breaking the code into functions makes the code more readable.  This technique uses functions, but only as subroutines.  They package the code, but do not make it functional.  Functions affect the code surrounding them and change global variables, rather than returning values.  If the reader encounters a variable, he will need to find where it came from. <br><br>  Here is the functional version of this program: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> random <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> random <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">move_cars</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(car_positions)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> map(<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> x: x + <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> random() &gt; <span class="hljs-number"><span class="hljs-number">0.3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> x, car_positions) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">output_car</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(car_position)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'-'</span></span> * car_position <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run_step_of_race</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(state)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {<span class="hljs-string"><span class="hljs-string">'time'</span></span>: state[<span class="hljs-string"><span class="hljs-string">'time'</span></span>] - <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'car_positions'</span></span>: move_cars(state[<span class="hljs-string"><span class="hljs-string">'car_positions'</span></span>])} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(state)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">''</span></span> <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">'\n'</span></span>.join(map(output_car, state[<span class="hljs-string"><span class="hljs-string">'car_positions'</span></span>])) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">race</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(state)</span></span></span><span class="hljs-function">:</span></span> draw(state) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> state[<span class="hljs-string"><span class="hljs-string">'time'</span></span>]: race(run_step_of_race(state)) race({<span class="hljs-string"><span class="hljs-string">'time'</span></span>: <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-string"><span class="hljs-string">'car_positions'</span></span>: [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>]})</code> </pre><br><br>  Now the code is divided into functional functions.  There are three signs.  The first is that there are no shared variables.  time and car_positions are passed directly to race ().  The second is that the functions take parameters.  The third is that the variables do not change inside the functions, all values ‚Äã‚Äãare returned.  Every time run_step_of_race () takes the next step, it is passed again to the next. <br><br>  Here are two functions zero () and one (): <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">zero</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> s[<span class="hljs-number"><span class="hljs-number">0</span></span>] == <span class="hljs-string"><span class="hljs-string">"0"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s[<span class="hljs-number"><span class="hljs-number">1</span></span>:] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">one</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> s[<span class="hljs-number"><span class="hljs-number">0</span></span>] == <span class="hljs-string"><span class="hljs-string">"1"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s[<span class="hljs-number"><span class="hljs-number">1</span></span>:]</code> </pre><br><br>  zero () takes the string s.  If the first character is 0, then returns the rest of the string.  If not, then None.  one () does the same if the first character is 1. <br><br>  Let's represent the rule_sequence () function.  It takes a string and a list of rule functions, consisting of the zero and one functions.  It calls the first rule, passing it the string.  If None is not returned, it takes the returned value and calls the next rule.  And so on.  If None is returned, rule_sequence () stops and returns None.  Otherwise, the value of the last rule. <br><br>  Examples of input and output data: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">print</span></span> rule_sequence(<span class="hljs-string"><span class="hljs-string">'0101'</span></span>, [zero, one, zero]) <span class="hljs-comment"><span class="hljs-comment"># =&gt; 1 print rule_sequence('0101', [zero, zero]) # =&gt; None</span></span></code> </pre><br><br>  Imperative version of rule_sequence (): <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rule_sequence</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s, rules)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> rule <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> rules: s = rule(s) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> s == <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s</code> </pre><br><br>  <b>Exercise 3</b> .  This code uses a loop.  Rewrite it in a declarative form using recursion. <br><br><div class="spoiler">  <b class="spoiler_title">My decision:</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rule_sequence</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s, rules)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> s == <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> rules: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rule_sequence(rules[<span class="hljs-number"><span class="hljs-number">0</span></span>](s), rules[<span class="hljs-number"><span class="hljs-number">1</span></span>:])</code> </pre><br></div></div><br><br><h4>  Use pipelines </h4><br>  Now we will rewrite another kind of cycles with the help of a technique called a conveyor. <br><br>  The next cycle changes the dictionaries containing the name, the wrong country of origin, and the status of some groups. <br><br><pre> <code class="python hljs">bands = [{<span class="hljs-string"><span class="hljs-string">'name'</span></span>: <span class="hljs-string"><span class="hljs-string">'sunset rubdown'</span></span>, <span class="hljs-string"><span class="hljs-string">'country'</span></span>: <span class="hljs-string"><span class="hljs-string">'UK'</span></span>, <span class="hljs-string"><span class="hljs-string">'active'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">False</span></span>}, {<span class="hljs-string"><span class="hljs-string">'name'</span></span>: <span class="hljs-string"><span class="hljs-string">'women'</span></span>, <span class="hljs-string"><span class="hljs-string">'country'</span></span>: <span class="hljs-string"><span class="hljs-string">'Germany'</span></span>, <span class="hljs-string"><span class="hljs-string">'active'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">False</span></span>}, {<span class="hljs-string"><span class="hljs-string">'name'</span></span>: <span class="hljs-string"><span class="hljs-string">'a silver mt. zion'</span></span>, <span class="hljs-string"><span class="hljs-string">'country'</span></span>: <span class="hljs-string"><span class="hljs-string">'Spain'</span></span>, <span class="hljs-string"><span class="hljs-string">'active'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>}] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">format_bands</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(bands)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> band <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> bands: band[<span class="hljs-string"><span class="hljs-string">'country'</span></span>] = <span class="hljs-string"><span class="hljs-string">'Canada'</span></span> band[<span class="hljs-string"><span class="hljs-string">'name'</span></span>] = band[<span class="hljs-string"><span class="hljs-string">'name'</span></span>].replace(<span class="hljs-string"><span class="hljs-string">'.'</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>) band[<span class="hljs-string"><span class="hljs-string">'name'</span></span>] = band[<span class="hljs-string"><span class="hljs-string">'name'</span></span>].title() format_bands(bands) <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> bands <span class="hljs-comment"><span class="hljs-comment"># =&gt; [{'name': 'Sunset Rubdown', 'active': False, 'country': 'Canada'}, # {'name': 'Women', 'active': False, 'country': 'Canada' }, # {'name': 'A Silver Mt Zion', 'active': True, 'country': 'Canada'}]</span></span></code> </pre><br><br>  The name of the function ‚Äúformat‚Äù is too general.  And in general, the code causes some concern.  Three different things happen in one cycle.  The value of the key 'country' is changed to 'Canada'.  Points are removed and the first letter of the name is changed to the capital.  It is difficult to understand what the code should do, and it is difficult to say whether it does it.  Its hard to use, test and parallelize. <br><br>  Compare: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">print</span></span> pipeline_each(bands, [set_canada_as_country, strip_punctuation_from_name, capitalize_names])</code> </pre><br><br>  It's simple.  Auxiliary functions look functional because they are chained together.  The previous output is the next input.  They are easy to check, reuse, check and parallelize. <br><br>  pipeline_each () iterates over groups one at a time, and passes them to conversion functions, like set_canada_as_country ().  After applying the function to all groups, pipeline_each () makes a list of them and passes it to the next one. <br><br>  Let's look at the conversion function. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">assoc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(_d, key, value)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> copy <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> deepcopy d = deepcopy(_d) d[key] = value <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> d <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set_canada_as_country</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(band)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> assoc(band, <span class="hljs-string"><span class="hljs-string">'country'</span></span>, <span class="hljs-string"><span class="hljs-string">"Canada"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">strip_punctuation_from_name</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(band)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> assoc(band, <span class="hljs-string"><span class="hljs-string">'name'</span></span>, band[<span class="hljs-string"><span class="hljs-string">'name'</span></span>].replace(<span class="hljs-string"><span class="hljs-string">'.'</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>)) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">capitalize_names</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(band)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> assoc(band, <span class="hljs-string"><span class="hljs-string">'name'</span></span>, band[<span class="hljs-string"><span class="hljs-string">'name'</span></span>].title())</code> </pre><br><br>  Each binds a group key with a new value.  Without changing the original data, it is hard to do, so we solve this with the help of assoc ().  It uses deepcopy () to create a copy of the transferred dictionary.  Each function converts a copy and returns that copy. <br><br>  Everything seems to be fine.  Data originals are protected from changes.  But in the code there are two potential places for data changes.  In strip_punctuation_from_name (), a name without dots is created by calling calling replace () with the original name.  In capitalize_names (), a name is created with the first capital letter based on the title () and the original name.  If replace and time are not functional, then strip_punctuation_from_name () with capitalize_names () is not functional. <br><br>  Fortunately, they are functional.  In Python, strings are immutable.  These functions work with copies of strings.  Uff, thank God. <br><br>  This contrast between strings and dictionaries (their variability) in Python demonstrates the advantages of languages ‚Äã‚Äãlike Clojure.  There the programmer does not need to think about whether he will change the data.  Will not change. <br><br>  <b>Exercise 4</b> .  Try to make the pipeline_each function.  Think about the sequence of operations.  Groups - in an array, are transferred one by one for the first conversion function.  Then the resulting array is transferred one by one for the second function, and so on. <br><br><div class="spoiler">  <b class="spoiler_title">My decision:</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pipeline_each</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data, fns)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> reduce(<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> a, x: map(x, a), fns, data)</code> </pre><br></div></div><br><br>  All three conversion functions as a result change the specific field of the group.  call () can be used to create an abstraction for this.  It accepts the function and key to which it will be applied. <br><br><pre> <code class="python hljs">set_canada_as_country = call(<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> x: <span class="hljs-string"><span class="hljs-string">'Canada'</span></span>, <span class="hljs-string"><span class="hljs-string">'country'</span></span>) strip_punctuation_from_name = call(<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> x: x.replace(<span class="hljs-string"><span class="hljs-string">'.'</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>), <span class="hljs-string"><span class="hljs-string">'name'</span></span>) capitalize_names = call(str.title, <span class="hljs-string"><span class="hljs-string">'name'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> pipeline_each(bands, [set_canada_as_country, strip_punctuation_from_name, capitalize_names])</code> </pre><br><br>  Or, sacrificing readability: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">print</span></span> pipeline_each(bands, [call(<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> x: <span class="hljs-string"><span class="hljs-string">'Canada'</span></span>, <span class="hljs-string"><span class="hljs-string">'country'</span></span>), call(<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> x: x.replace(<span class="hljs-string"><span class="hljs-string">'.'</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>), <span class="hljs-string"><span class="hljs-string">'name'</span></span>), call(str.title, <span class="hljs-string"><span class="hljs-string">'name'</span></span>)])</code> </pre><br><br>  The code for call (): <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">assoc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(_d, key, value)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> copy <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> deepcopy d = deepcopy(_d) d[key] = value <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> d <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(fn, key)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">apply_fn</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(record)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> assoc(record, key, fn(record.get(key))) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> apply_fn</code> </pre><br><br>  What is going on here? <br><br>  One.  call is a higher order function, since  takes another function as an argument and returns a function. <br><br>  Two.  apply_fn () is similar to conversion functions.  Gets a record (group).  Searches for record [key] value.  Causes fn.  Assigns the result to a copy of the record and returns it. <br><br>  Three.  The call itself does nothing.  All work is done by apply_fn ().  In the use case of pipeline_each (), a single instance of apply_fn () sets the 'country' value to 'Canada'.  Another - makes the first letter in capital. <br><br>  Four.  When executing the apply_fn () instance, the functions fn and key will not be available in scope.  These are not apply_fn () arguments or local variables.  But access to them will be.  When defining a function, it retains references to variables that it closes ‚Äî those that were defined outside the function, and are used internally.  When a function is started, variables are searched among local ones, then among arguments, and then among references to closed ones.  There are fn and key. <br><br>  Five.  There is no mention of groups in the call.  This is because call can be used to create any pipelines, regardless of their contents.  Functional programming, in particular, builds a library of common functions suitable for compositions and for reuse. <br><br>  Well done.  Closures, higher-order functions, and scope ‚Äî all in several paragraphs.  You can drink tea with cookies. <br><br>  There remains one more processing of these groups.  Remove everything except the name and country.  Function extract_name_and_country (): <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">extract_name_and_country</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(band)</span></span></span><span class="hljs-function">:</span></span> plucked_band = {} plucked_band[<span class="hljs-string"><span class="hljs-string">'name'</span></span>] = band[<span class="hljs-string"><span class="hljs-string">'name'</span></span>] plucked_band[<span class="hljs-string"><span class="hljs-string">'country'</span></span>] = band[<span class="hljs-string"><span class="hljs-string">'country'</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> plucked_band <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> pipeline_each(bands, [call(<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> x: <span class="hljs-string"><span class="hljs-string">'Canada'</span></span>, <span class="hljs-string"><span class="hljs-string">'country'</span></span>), call(<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> x: x.replace(<span class="hljs-string"><span class="hljs-string">'.'</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>), <span class="hljs-string"><span class="hljs-string">'name'</span></span>), call(str.title, <span class="hljs-string"><span class="hljs-string">'name'</span></span>), extract_name_and_country]) <span class="hljs-comment"><span class="hljs-comment"># =&gt; [{'name': 'Sunset Rubdown', 'country': 'Canada'}, # {'name': 'Women', 'country': 'Canada'}, # {'name': 'A Silver Mt Zion', 'country': 'Canada'}]</span></span></code> </pre><br><br>  extract_name_and_country () could be written in a generalized form called pluck ().  It would be used like this: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">print</span></span> pipeline_each(bands, [call(<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> x: <span class="hljs-string"><span class="hljs-string">'Canada'</span></span>, <span class="hljs-string"><span class="hljs-string">'country'</span></span>), call(<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> x: x.replace(<span class="hljs-string"><span class="hljs-string">'.'</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>), <span class="hljs-string"><span class="hljs-string">'name'</span></span>), call(str.title, <span class="hljs-string"><span class="hljs-string">'name'</span></span>), pluck([<span class="hljs-string"><span class="hljs-string">'name'</span></span>, <span class="hljs-string"><span class="hljs-string">'country'</span></span>])])</code> </pre><br><br>  <b>Exercise 5</b> .  pluck accepts a list of keys to extract from records.  Try to write it.  This will be a higher order function. <br><br><div class="spoiler">  <b class="spoiler_title">My decision:</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pluck</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(keys)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pluck_fn</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(record)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> reduce(<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> a, x: assoc(a, x, record[x]), keys, {}) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> pluck_fn</code> </pre><br></div></div><br><br>  And now what? <br><br>  Functional code is well combined with the traditional.  Transformations from this article can be used in any language.  Try it for your code. <br><br>  Think of Masha, Petya and Vasya.  Turn the iterations through the lists into maps and. <br><br>  Remember the race.  Break the code into functions, and make them functional.  Turn the cycle into recursion. <br><br>  Remember the group.  Turn the workflow into a pipeline. </div><p>Source: <a href="https://habr.com/ru/post/257903/">https://habr.com/ru/post/257903/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../257891/index.html">Escape from the dungeon types. We work with data, the type of which is determined dynamically.</a></li>
<li><a href="../257893/index.html">Place and conquer! Use host new to optimize C ++ code.</a></li>
<li><a href="../257895/index.html">The sad story of forgotten characters. How not to go crazy when working with encodings in C ++</a></li>
<li><a href="../257897/index.html">That's the point, sailed! We learn to work with floating-point numbers and develop an alternative with fixed decimal precision.</a></li>
<li><a href="../257899/index.html">Revelations metaprogrammer. We program the code at compile time, use C ++ templates for non-template solutions.</a></li>
<li><a href="../257905/index.html">Travel SIM + cloud PBX and new approaches to the IP-PBX interface</a></li>
<li><a href="../257909/index.html">Sergey Borisyuk: ‚ÄúThe most important thing in startups is the focus‚Äù</a></li>
<li><a href="../257911/index.html">Determining network topology at OSI levels 2/3</a></li>
<li><a href="../257913/index.html">As I wrote a Docker container launch audit on Go</a></li>
<li><a href="../257915/index.html">How to use progressive improvement for the layout of letters</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>