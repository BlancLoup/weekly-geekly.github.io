<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Why did I rip one CD 300 times</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I collect music: I buy CDs, digitize them with the Exact Audio Copy program, scan covers and inserts. Sometimes it is not easy if the CD is released i...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Why did I rip one CD 300 times</h1><div class="post__text post__text-html js-mediator-article">  I collect music: I buy CDs, digitize them with the <a href="http://www.exactaudiocopy.de/">Exact Audio Copy</a> program, scan covers and inserts.  Sometimes it is not easy if the CD is released in a limited edition abroad 10 years ago.  The hardest thing is if there is a manufacturing defect on the compact - and some tracks are not readable. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6f5/e32/a86/6f5e32a86569ad14e42c0ea28a8de301.jpg" align="left">  The <a href="https://altneuland.net/">Altneuland</a> <a href="https://altneuland.net/gallery/the-citadel-where-to-return/">Â∏∞ „Çã „Åπ „Åç Âüé</a> piano arrangement album was released in 2005.  I found it three years later (probably on YouTube), downloaded the best copy - and made the disc on my list of future purchases.  Recent advances in international mail technology allowed us to buy a second-hand disk last year.  Unfortunately, none of my CD drives could read track number 3. This often happens when buying old CDs, especially when they went through the USPS international delivery center.  I put it off and started looking for another copy that I found last month.  He arrived on Friday - and I immediately tried to rip him.  But with pushed with the <i>exact same mistake</i> .  It seems that it‚Äôs not a matter of wear or damage - the disk probably came out defective right from the factory. <br><br>  ADDITION: After the investigation, I no longer believe that this is a factory defect.  When I record the beginning or end of a failed track on an empty CD-R and copy it, the ripper gives the same error!  Try it yourself with the file <a href="">minimal.flac</a> . <br><a name="habracut"></a><br>  There are two options left: either to try sometime to find another copy that will be successfully copied (unlikely), or somehow restore the original sound data from damaged discs.  You already know which option I chose. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h1>  How does the ripper </h1><br><img src="https://habrastorage.org/getpro/habr/post_images/69e/9b0/ff6/69e9b0ff62e391da0701a6a4cd02b57d.png"><br>  <i><font color="gray">EAC could not read track number 3 from the disc [Â∏∞ „Çã „Åπ „Åç Âüé]</font></i> <br><br>  CDs store digital data, but there is a completely analog interface between disks, lasers and optical diodes.  Reading errors occur for various reasons: dirty media, scratches on the protective layer of polycarbonate, vibration of the drive itself.  Primitive error correction codes in <a href="https://en.wikipedia.org/wiki/Compact_Disc_Digital_Audio">the CDDA standard</a> help to minimize sound distortion on rarely used discs, but are not able to fully recover the bitstream on a CD with a large number of errors.  Modern rippers solve the problem using two important error detection methods: redundant reading and AccurateRip. <br><br>  The <a href="http://www.exactaudiocopy.de/en/index.php/overview/basic-technology/extraction-technology/">EAC: Extraction Technology</a> page describes how EAC performs redundant reading: <br><br><blockquote>  In safe mode, the program reads each sector at least twice [...] If an error occurs (read or synchronize), then the program continues to read this sector until 8 out of 16 attempts are identical.  This procedure is carried out a maximum of one, three or five times (in accordance with the chosen quality of error recovery).  So in the worst case, bad sectors are read 82 times! </blockquote><br>  It's simple.  If a read request sometimes returns incorrect data, read it again, and then be especially careful if the first two reads give different results.  <a href="https://wiki.hydrogenaud.io/index.php%3Ftitle%3DAccurateRip">AccurateRip</a> uses the same principle, but distributed: in this service, rippers send checksums of copied audio files.  The idea is that if a thousand people copied a track with the same bits, this is probably the right rip. <br><br>  This article is about what to do if both methods cannot help.  EAC does not give a result if each read returns a different data, and in the AccurateRip database there is only one record about a rare disk <a href="https://habr.com/ru/post/418995/">[1]</a> <a name="1_1"></a>  . <br><br><h1>  "I passed ten thousand passes, ten thousand passes to see you" </h1><br><img src="https://habrastorage.org/getpro/habr/post_images/44a/1ab/850/44a1ab850b96409640f45e9425f73652.jpg"><br>  <i><font color="gray">Optical Drives Asus, LG, Lite-On, Pioneer and Unknown OEM</font></i> <br><br>  If the CD is not copied, then it is logical to use another drive.  Sometimes a particular model is more condescending about the specifications of CDDA, or is there the best firmware for fixing errors, or something else.  The DBpoweramp forum has <a href="https://forum.dbpoweramp.com/showthread.php%3F37706-CD-DVD-Drive-Accuracy-List-2016">an accuracy rating of CD / DVD drives</a> to select the most suitable drive for rip. <br><br>  I bought five new CD drives from different manufacturers on Saturday morning <a href="https://habr.com/ru/post/418995/">[2]</a> <a name="2_2"></a>  , tried them all - and found one that could keep the sync on the beat track.  Unfortunately, the confirmation of the rip could not be obtained - between all the rips there were about 20,000 different bytes. <br><br>  But now I had .wav files on the disk, and from this you can benefit.  I reasoned that reading errors on a bad track are somewhere near the ‚Äúright‚Äù one.  Therefore, it makes sense to make a few rips and find a ‚Äúconsensus‚Äù value for unstable bytes.  This approach was ultimately successful, but it required much more work than I expected. <br><br><h1>  "Quantity goes into quality" </h1><br>  I started by repeatedly copying the disk on one of the drives, writing all the values ‚Äã‚Äãfor each byte and declaring the error ‚Äúcorrectable‚Äù if more than half of the rips produce a certain byte value for this position.  The start was good: the unrecoverable error was reduced from almost 6900 bytes with N = 4 to ~ 5000 bytes with N = 10.  The benefit from each additional rip decreased over time, until approximately by N = 80 the number of uncorrectable errors stabilized at ~ 3700.  I stopped rips at N = 100. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b87/aaa/809/b87aaa809a043eaeaa2d049258fe0cb9.png"><br>  <i><font color="gray">Corrected and unrecoverable errors on the number of rip</font></i> <br><br>  Then I tried to copy the disk 100 times on the second drive and use two correction cards to ‚Äúfill in‚Äù the uncorrectable error positions from the first drive.  But it didn't work: on each drive there were thousands of fixes that did not match the fixes on the other!  It turns out that you can not eliminate the noise by combining it with another, but related source of noise. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/911/6d5/c33/9116d5c339461cb286edc4537c712a71.png"><br>  <i><font color="gray">The same, but for two disks with cross-checking fixes</font></i> <br><br><h1>  Handicraft </h1><br><img src="https://habrastorage.org/getpro/habr/post_images/ec7/829/554/ec78295544b0a161b472598114e2be2d.jpg"><br><br>  On the EAC website there is another good resource: the <a href="http://www.exactaudiocopy.de/en/index.php/other-projects/dae-quality/">DAE quality test</a> , which determines the quality of the drive firmware by the level of correctable errors.  This is a lower level error handling when the drive <i>corrects</i> read errors and not just reports them.  The catch is that the EAC "safe mode" is available only when this built-in error correction code is turned off, assuming its malfunction. <br><br>  I prepared a test by burning a .wav file onto a CD-R, highlighting the exact sector on the data surface and carefully painting it with a black marker.  Here it is - guaranteed fatal errors on a deterministic pattern. <br><br>  I tested all the drives and got two interesting results: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/11f/4c6/f55/11f4c6f554062ec91d1f5d4160b40a43.png"><br><br>  I used the Lite-On Drive before to get around sync errors.  He happily chewed on the magic marker, but he was greatly embarrassed by the straight lines on the data surface.  You can see how instead of the three separate peaks on the right one giant crash blob. <br><br> <code>Errors total Num : 206645159 <br> Errors (Loudness) Num : 965075 - Avg : -21.7 dB(A) - Max : -5.5 dB(A) <br> Error Muting Num : 154153 - Avg : 99.1 Samples - Max : 3584 Samples <br> Skips Num : 103 - Avg : 417.3 Samples - Max : 2939 Samples <br> <br> Total Test Result : 45.3 points (of 100.0 maximum)</code> <br> <br><img src="https://habrastorage.org/getpro/habr/post_images/07b/beb/2d7/07bbeb2d7534a3eb062e176c8b059182.png"><br><br>  Drive Pioneer received the highest score on the test DAE.  In my opinion, the graph does not look any special, but the analysis tool said that it is the best firmware for fixing errors in my small set. <br><br> <code>Errors total Num : 2331952 <br> Errors (Loudness) Num : 147286 - Avg : -77.2 dB(A) - Max : -13.2 dB(A) <br> Error Muting Num : 8468 - Avg : 1.5 Samples - Max : 273 Samples <br> Skips Num : 50 - Avg : 6.5 Samples - Max : 30 Samples <br> <br> Total Test Result : 62.7 points (of 100.0 maximum)</code> <br> <br><h1>  ‚ÄúFrom a certain moment numbers matter‚Äù </h1><br>  How to use the Pioneer firmware with a good bug fix if the EAC "safe mode" ignores it?  Very simple: switch EAC to ‚Äúburst mode‚Äù (burst mode) and write a stream of bits to the disk in the form in which the firmware reports them.  How do you turn this bunch of unverified .wav files into a good quality file, like in "safe mode"?  Yes, the same error analysis tool that we used in Rips with Lite-On! <br><br>  After a few EAC configuration settings and after all, we get such a beautiful diagram. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/405/323/e9f/405323e9fad21af9069c1983e25a7025.png"><br>  <i><font color="gray">Corrected and unrecoverable errors on the number of rips (Pioneer)</font></i> <br><br>  What can be noted: <br><br><ul><li>  Uncorrectable bit errors quickly go to zero, but never reach it. </li><li>  Huge jump in bug fixes in 53‚Äì54 rips. </li><li>  The number of errors before and after this big jump practically does not change, which indicates areas of stability in the copied data. </li></ul><br><h1>  0xA595BC09 </h1><br>  Using Pioneer's near-perfect error correction, I generated the ‚ÄúBetter Assumption‚Äù file and began comparing it with Pioneer rips.  As expected, there were several poor quality sites that I fixed by making 10 more rips: <br><br> <code>$ for RIP_ID in $(seq -w 1 100); do echo -n "rip$RIP_ID: "; cmp -l analysis-out.wav rips-cd1-pioneer/rip${RIP_ID}/*.wav | wc -l ; done | sort -rgk2 | head -n 10 <br> rip054: 2865 <br> rip099: 974 <br> rip007: 533 <br> rip037: 452 <br> rip042: 438 <br> rip035: 404 <br> rip006: 392 <br> rip059: 381 <br> rip043: 327 <br> rip014: 323</code> <br> <br>  I also found something really interesting: several rips gave out <i>exactly the</i> same content!  Remember, this is precisely the criterion of success in the EAC "safe mode".  Command <code>shncat -q -e | rhash --print="%C"</code>  <code>shncat -q -e | rhash --print="%C"</code> used to calculate the CRC32 checksum of the raw audio data: this is what the EAC applies. <br><br> <code>$ for wav in rips-cd1-pioneer/*/*.wav; do shncat "$wav" -q -e | rhash --printf="%C $wav\n" - ; done | sort -k1 <br> [...] <br> 9DD05FFF rips-cd1-pioneer/rip059/rip.wav <br> 9F8D1B53 rips-cd1-pioneer/rip072/rip.wav <br> A2EA0283 rips-cd1-pioneer/rip082/rip.wav <br> A595BC09 rips-cd1-pioneer/rip021/rip.wav <br> A595BC09 rips-cd1-pioneer/rip022/rip.wav <br> A595BC09 rips-cd1-pioneer/rip023/rip.wav <br> A595BC09 rips-cd1-pioneer/rip024/rip.wav <br> A595BC09 rips-cd1-pioneer/rip025/rip.wav <br> A595BC09 rips-cd1-pioneer/rip026/rip.wav <br> A595BC09 rips-cd1-pioneer/rip027/rip.wav <br> A595BC09 rips-cd1-pioneer/rip028/rip.wav <br> A595BC09 rips-cd1-pioneer/rip030/rip.wav <br> A595BC09 rips-cd1-pioneer/rip031/rip.wav <br> A595BC09 rips-cd1-pioneer/rip040/rip.wav <br> A595BC09 rips-cd1-pioneer/rip055/rip.wav <br> A595BC09 rips-cd1-pioneer/rip058/rip.wav <br> AA3B5929 rips-cd1-pioneer/rip043/rip.wav <br> ABAAE784 rips-cd1-pioneer/rip033/rip.wav <br> [...]</code> <br> <br>  In the meantime, repeated rips of substandard areas allowed to complete the analysis with zero unrecoverable errors.  And when I checked this file, there was exactly the same audio content as in the ‚Äúnormal‚Äù rip!  This is enough to declare victory. <br><br>  I am 99% sure that I successfully copied this problem CD, and 0xA595BC09 is the correct CRC sum for track 3. <br><br><h1>  Appendix A: compare.rs </h1><br>  I used this tool to calculate probable byte errors.  It is not intended for long-term use, so it is a bit ugly, but may be interesting to those who stumbled upon this page, solving the same problem. <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">crate</span></span> memmap; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::cmp; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::collections::HashMap; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::env; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::fs; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::sync; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::sync::mpsc; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::thread; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> memmap::Mmap; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CHUNK_SIZE: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">20</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">suspect_positions</span></span></span></span>( mmaps: &amp;HashMap&lt;<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, Mmap&gt;, start_idx: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, end_idx: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, ) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> positions = <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>::new(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ii <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> start_idx..end_idx { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> first = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> byte: <span class="hljs-built_in"><span class="hljs-built_in">u8</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (_file_name, file_content) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> mmaps { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> first { byte = file_content[ii]; first = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> byte != file_content[ii] { positions.push(ii); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } } positions } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> args: <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>&gt; = env::args().collect(); args.remove(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> first = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> size: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> files: <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;fs::File&gt; = <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>::new(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> mmaps: HashMap&lt;<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, Mmap&gt; = HashMap::new(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> filename <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> args { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> file = fs::File::open(&amp;filename).unwrap(); files.push(file); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> mmap = <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> { Mmap::map(files.last().unwrap()).unwrap() }; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> first { first = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; size = mmap.len(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">assert!</span></span>(size == mmap.len()); } mmaps.insert(filename, mmap); } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> (suspects_tx, suspects_rx) = mpsc::channel(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> start_idx = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> mmaps_ref = sync::Arc::new(mmaps); <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> t_start_idx = start_idx; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> t_end_idx = cmp::min(start_idx + CHUNK_SIZE, size); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> start_idx == t_end_idx { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> mmaps_ref = mmaps_ref.clone(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> suspects_tx = suspects_tx.clone(); thread::spawn(<span class="hljs-keyword"><span class="hljs-keyword">move</span></span> || { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> suspects = suspect_positions(mmaps_ref.as_ref(), t_start_idx, t_end_idx); suspects_tx.send(suspects).unwrap(); }); start_idx = t_end_idx; } <span class="hljs-built_in"><span class="hljs-built_in">drop</span></span>(suspects_tx); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> suspects: <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt; = <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>::with_capacity(size); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> suspects_chunk <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> suspects_rx { suspects.append(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> suspects_chunk); } suspects.sort(); <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{{\"files\": ["</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> first_file = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (file_name, file_content) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> mmaps_ref.iter() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> file_comma = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> first_file { <span class="hljs-string"><span class="hljs-string">""</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-string"><span class="hljs-string">","</span></span> }; first_file = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{}{{\"name\": \"{}\", \"suspect_bytes\": ["</span></span>, file_comma, file_name); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (ii, position) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> suspects.iter().enumerate() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> comma = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ii == suspects.len() - <span class="hljs-number"><span class="hljs-number">1</span></span> { <span class="hljs-string"><span class="hljs-string">""</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-string"><span class="hljs-string">","</span></span> }; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"[{}, {}]{}"</span></span>, position, file_content[*position], comma); } <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"]}}"</span></span>); } <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"]}}"</span></span>); }</code> </pre> <br>  one. <a name="1"></a>  In this single AccurateRip record to my disk, the CRCs for all tracks are the same except for track No. 3: the sum is 0x84B9DD1A, and I have 0xA595BC09.  I suspect that the ripper did not understand that he has a bad disk.  <a href="https://habr.com/ru/post/418995/">[return]</a> <br><br>  2 <a name="2"></a>  The obvious question when buying a CD or DVD drive in 2018: "Damn, where can I buy them?".  And I needed not one, but <i>several</i> from <i>different brands</i> .  I know only one store nearby that has 5.25 "DVD drives available. Only one store is big enough not to regret space on the shelves for such drives, and strange enough so that they don't seem out of place there. Of course, I I'm talking about Frys Electronics. <a href="https://habr.com/ru/post/418995/">[back]</a> </div><p>Source: <a href="https://habr.com/ru/post/418995/">https://habr.com/ru/post/418995/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../418975/index.html">How to measure success. Monitoring strategies and their relationship to business issues</a></li>
<li><a href="../418979/index.html">As I flew across the country, implementing a project for several thousand jobs</a></li>
<li><a href="../418981/index.html">Numerical methods for solving elliptic equations</a></li>
<li><a href="../418985/index.html">Analytics and design as a whole</a></li>
<li><a href="../418987/index.html">Firefox easily bypasses protection in the new Gmail interface.</a></li>
<li><a href="../418997/index.html">Real contribution to real open source</a></li>
<li><a href="../418999/index.html">[Announcement, Peter] Meeting JUG.ru with Andrey Belyaev and Alexey Stukalov ‚Äî Troll oppression CUBA: FAQ</a></li>
<li><a href="../419001/index.html">5 "super skills" necessary for the work of the future</a></li>
<li><a href="../419003/index.html">Digest news from the sphere of blockchain technologies</a></li>
<li><a href="../419005/index.html">Excursion to the substation 220/110/20</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>