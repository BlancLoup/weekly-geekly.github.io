<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Optimization Planning with Unity</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Unity contains a number of settings and tools to achieve smooth graphics in games. For this project, we selected those with which difficulties may ari...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Optimization Planning with Unity</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/d39/830/b38/d39830b38c324d97bd35a72224f227dc.png"><br><br>  Unity contains a number of settings and tools to achieve smooth graphics in games.  For this project, we selected those with which difficulties may arise, and analyzed their impact on the performance of games on Intel GP. <br><br>  We are considering using Unity from the point of view of the game developer.  We sought to find areas of performance degradation, and then determine how to improve application performance using built-in Unity tools.  One of the advantages of Unity is the ability to quickly create content, but in order to achieve performance, especially on mobile devices and tablets, the developer will need to carefully plan the use of built-in performance optimization mechanisms.  In this article, new and existing Unity users are offered tips on improving performance when creating levels and games, and also describes new ways to create content. <br><a name="habracut"></a><br><h2>  <font color="#0071c5">Introduction</font> </h2><br>  Creating games using Unity is relatively easy.  Unity has a store where you can purchase various items, such as models, ready-made scripts, demos, or even full games.  For testing, I worked with an existing game to determine in which areas you can achieve improved performance, and in which not.  I used a Unity technical demo called Boot Camp (it can be downloaded for free at the resource store) to assess the complexity of the problem. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      I used Unity 3.0 to create game parameters and launch all scenes.  Testing was conducted on a computer with an Intel Core 3rd generation processor with Intel HD Graphics 4000. The test results are not applicable to mobile devices. <br><br><h2>  <font color="#0071c5">Quality manager</font> </h2><br>  In Unity, additional rendering options are available for games: Edit-&gt; Project Settings-&gt; Quality (Fig. 1).  These are customizable rendering options that can be customized individually.  Unity contains built-in documentation explaining quality parameters and their configuration using the Unity scripts API. <br><br><img src="https://habrastorage.org/files/c5f/dbf/4aa/c5fdbf4aa702498a95cadf4c746c013c.png"><br>  <i>Figure 1. Access to tags and layers through the menu Edit-&gt; Project Settings-&gt; Tag inspector</i> <br><br>  To find out how to optimize in Unity, I decided to try changing the quality settings in order to understand what could be won or lost, although I did not test all the available parameters. <br><br><h2>  <font color="#0071c5">Texture quality</font> </h2><br>  In the Quality Settings Inspector there is a drop-down menu where you can select rendering resolution for textures.  You can choose resolution 1/8, 1/4, 1/2 or full resolution.  To assess the gain or decline in performance with different texture resolutions, I measured the frame rate of the test scene with all the default quality settings available in Unity (Fastest, Fast, Good, etc.), changing only the quality of textures before each measurement. <br>  In fig.  Figures 2 and 3 show a comparison between scenes with 1/8 resolution of textures and full resolution textures. <br><br><img src="https://habrastorage.org/files/1d3/7c9/0f6/1d37c90f63d24ddd8dbfcce6774ea1b9.png"><br>  <i>Figure 2. Unity * Boot Camp Scene with 1/8 resolution</i> <br><br><img src="https://habrastorage.org/files/8f5/507/c6a/8f5507c6aaf544ca804d36e2bd20ace8.png"><br>  <i>Figure 3. Unity * Boot Camp Scene full resolution</i> <br><br>  We measured the frame rate (in frames per second) using Intel Graphics Performance Analyzers (Intel GPA) after changing the texture resolution.  At the quality level of Fantastic (table 1), it can be seen that the performance has not changed very much with changing texture size. <br><br><img src="https://habrastorage.org/files/f9f/57a/169/f9f57a16974f4fcda96caef75e683065.png"><br>  <i>Table 1. Frame rate change when switching between different texture quality in Unity</i> <br><br>  On computers with Intel GPUs, performance theoretically does not change depending on the size of the textures, but other factors should be taken into account, such as the total amount of device memory and the use of memory by the application. <br><br><h2>  <font color="#0071c5">Shadow Distance</font> </h2><br>  Shadow Distance is a parameter that determines the depth of rejection used for shadows of game objects.  If a game object is within a specified distance from the camera, then the shadows of this object are drawn, if the object is farther than this distance, then the shadows of such an object are not displayed (excluded from the drawing). <br>  Depending on the parameters used, shadows can adversely affect performance, since their calculation and rendering are resource-intensive operations.  Testing the effect of the Shadow Distance parameter <br><ul><li>  Create a test scene. </li><li>  Set the default Unity quality settings for this scene. </li><li>  Gradually increase the value of the Shadow Distance parameter and measure the frame rate using Intel GPA. </li><li>  Select another default quality value in Unity and repeat the frame rate measurement. </li></ul><br>  In this test, the Fastest and Fast quality levels were not used, since shadows are disabled in these modes. <br><br><img src="https://habrastorage.org/files/aae/66f/164/aae66f164ced44d8b38f0107c258928d.png"><br>  <i>Figure 4. This parameter is available in the Inspector menu: Edit-&gt; Project Settings-&gt; Quality</i> <br><br><img src="https://habrastorage.org/files/d39/830/b38/d39830b38c324d97bd35a72224f227dc.png"><br>  <i>Figure 5. Unity * Boot Camp technical demo</i> <br><br><img src="https://habrastorage.org/files/37b/86f/1c4/37b86f1c487340d5b51db078ba72505b.png"><br>  <i>Table 2. Frame rate change when the Shadow Distance parameter value changes in the technical demonstration of Unity * Boot Camp</i> <br><br>  Shadows significantly affect performance.  The test showed that the frame rate dropped by almost half when switching the distance from 0 to 50 in the Simple mode.  It is important to consider whether game objects are visible and to make sure that unnecessary shadows are not drawn.  Shadow rejection depth can be customized using Unity scripts for various situations.  We only checked the effect of shadow rejection depth, but similar performance changes may occur when setting other parameters for shadow quality. <br><br><h2>  <font color="#0071c5">Layers</font> </h2><br>  All game objects in Unity are assigned a layer when they are created.  Initially, all objects are assigned a default layer, as shown in Fig.  6, but you can create your own unique layers.  This can be done in two ways.  You can simply click the Layer field and select Add New Layer.  You can also use the menu Edit-&gt; Project Settings-&gt; Tags. <br><br><img src="https://habrastorage.org/files/fb2/cd2/24c/fb2cd224c6f84744be72ae3a328a0968.png"><br>  <i>Figure 6. The Layer menu in the Inspector game object</i> <br><br><img src="https://habrastorage.org/files/c86/e8e/e7d/c86e8ee7d7244ee6b2f74666200d1882.png"><br>  <i>Figure 7. Tag Manager in the Inspector window</i> <br><br>  In the Inspector window (Fig. 7), you can create a new layer and specify which layer number it should belong to.  Using both methods opens the same Tag Manager window.  After creating a layer, you can assign game objects to this layer by selecting the desired layer in the parameters window in the Inspector window of the game object in the Layer field.  In this way, you can group objects on the same layers in order to process them together.  Remember what layers are and how to create and customize them when I talk about some of the other layer features in this article. <br><br><h2>  <font color="#0071c5">Layer rejection distances</font> </h2><br>  The camera will not render game objects that are outside the clipping plane in Unity.  Using Unity scripts, you can set a shorter distance to the clipping plane for certain layers. <br><br><img src="https://habrastorage.org/files/b08/1b5/45d/b081b545da514fef9d18e2b8e9981a86.png"><br>  <i>Figure 8. Sample Scenario from Unity Documentation with Changing Layer Rejection Distance</i> <br><br>  Setting a shorter cull distance for game objects requires some work.  First you need to place the objects on the layer.  Then you need to write a script to change the rejection distance of this particular layer, and assign the script to the camera.  Sample script in fig.  8 shows how to create an array of 32 floating point values ‚Äã‚Äãcorresponding to the 32 available layers that can be created using the menu Edit-&gt; Project Settings-&gt; Tags.  If you change the index value in this array and assign it to <i>camera.layerCullDistances</i> , then the rejection distance will change for the corresponding layer.  If you do not assign a number to an index, the corresponding layer will use the far clipping plane of the camera. <br><br>  To test the performance of <i>layerCullDistances,</i> I created three scenes filled with objects of low, medium and high complexity.  In these scenes, identical game objects are grouped together and arranged in a row with a gradual distance from the camera.  I used Intel GPA to measure the frame rate while gradually increasing the layer rejection distance, adding groups of objects for each measurement (i.e., one group of objects for the first measurement, 6 groups of objects for the sixth measurement). <br><br>  Figures 9, 10, and 11 show scenes that I used for testing with objects of different types. <br><br>  <b>Boots: polygons - 278, peaks - 218</b> <br><img src="https://habrastorage.org/files/4ee/c4b/4f9/4eec4b4f92cf42abae3739101374e5fa.png"><br>  <i>Figure 9. Test scene with boots ‚Äî objects with a low number of polygons and vertices</i> <br><br>  <b>Dinosaurs: polygons - 4398, peaks - 4400</b> <br><img src="https://habrastorage.org/files/a2e/d87/df9/a2ed87df95054ca39cdd499016e65fd2.png"><br>  <i>Figure 10. Test scene with dinosaurs - objects with an average number of polygons and vertices</i> <br><br>  <b>Airplanes: polygons - 112 074, tops - 65 946</b> <br><img src="https://habrastorage.org/files/a81/e5f/c30/a81e5fc30f3941648a4fce884a887b26.png"><br>  <i>Figure 11. Test scene with airplanes - objects with a large number of polygons and vertices</i> <br><br>  Tables 3, 4 and 5 show the change in frame rate in all test scenes. <br><br><img src="https://habrastorage.org/files/4b0/a09/5ab/4b0a095ab32049a99ac2184da6b660c6.png"><br>  <i>Table 3. Data obtained in the scene with boots (Fig. 9)</i> <br><br><img src="https://habrastorage.org/files/7dd/b64/603/7ddb646038434fada32900f23edaf360.png"><br>  <i>Table 4. Data obtained in the scene with dinosaurs (Fig. 10)</i> <br><br><img src="https://habrastorage.org/files/adf/814/f55/adf814f55f45454b863e693e19ba9f56.png"><br>  <i>Table 5. Data obtained in the scene with the aircraft (Fig. 11)</i> <br><br><img src="https://habrastorage.org/files/b6f/863/cf7/b6f863cf7df0478e8b98a08428b88d38.png"><br>  <i>Table 6. Data from all test scenes in Fantastic mode</i> <br><br>  This data shows the performance gains that can be achieved with <i>layerCullDistances</i> in Unity. <br><br>  Table 6 shows how performance changes as the number of objects on the screen increases, especially if they are complex objects.  From the point of view of the game developer, the proper use of <i>layerCullDistances</i> can significantly improve performance.  For example, for small objects with a complex model that are located farther from the camera, you can adjust the drawing only with a sufficient approximation, when these objects can already be distinguished.  When planning and creating levels, the developer should take into account the complexity of the models and the visibility of objects located at a great distance from the camera.  Advance planning allows you to achieve better results when using <i>layerCullDistances</i> . <br><br><h2>  <font color="#0071c5">Camera</font> </h2><br>  I studied the possibilities of working with the camera in Unity and its settings.  I tried to select various parameters, worked with other components and additions. <br><br><img src="https://habrastorage.org/files/f87/80b/c76/f8780bc762c645838a5a0e533a43dcd1.png"><br>  <i>Figure 12. The Inspector menu that opens after selecting a camera.</i> <br><br>  When creating a new scene, by default, only one game camera object appears called Main Camera.  To add another camera, first create an empty game object: Game Object-&gt; Create Empty.  Then select this empty object and add the camera component: Components-&gt; Rendering-&gt; Camera. <br>  The cameras in Unity support extensive configuration options, as shown in Figure 2.  12. Here are the settings I considered: Rendering Path and HDR. <br><br><h2>  <font color="#0071c5">Render path</font> </h2><br>  Using the Render Path parameter, you can specify in Unity how to handle the rendering of light and shadows in the game.  Three types of rendering are supported in Unity, here they are in order from the most resource-intensive to the least resource-intensive: Deferred (delayed, only in Unity Pro), Forward (advanced) and Vertex Lit (vertex lighting).  In each case, shadows and light are handled a little differently, and they require different amounts of CPU and GP resources to process them.  It is important to understand for which platform and for which equipment is being developed to select the appropriate renderer.  If you select a renderer that is not supported by the graphics adapter, Unity automatically switches to a less resource-intensive rendering method. <br><br><img src="https://habrastorage.org/files/fe7/84c/5e5/fe784c5e5c384b38a6812c055473937b.png"><br>  <i>Figure 13. Player Settings Inspector window</i> <br><br>  You can adjust the Rendering Path in two ways.  The first way: <br>  Edit-&gt; Project Settings-&gt; Player (Fig. 13).  The Rendering Path drop-down list is located on the Others Settings tab.  The second way: using the Camera Inspector user interface (Fig. 14).  If you select any option other than Use Player Settings, the default settings will be replaced, but only for this camera.  Therefore, you can use different cameras with different render buffer settings for light and shadows. <br><br><img src="https://habrastorage.org/files/f75/167/ac1/f75167ac1c7242c8a3ae5fa6d39a511f.png"><br>  <i>Figure 14. Drop-down list when selecting the Rendering Path option in the Camera window</i> <br><br>  Developers need to know how the various lighting rendering modes that make up Unity work.  The reference section at the end of this document provides links to Unity documentation.  Make sure that you know the target audience of your game and the platform on which potential users will play this game.  This will help you choose the appropriate rendering method for this platform.  For example, if a game contains several light sources and graphic effects that use deferred rendering, then on computers with a low-power graphics adapter, playing such a game would be simply impossible.  If your target audience includes casual game lovers whose devices do not have high computing power, then problems may also arise.  Developers need to know the target platform for which their game is intended, and appropriately choose how to render and handle the lighting in the game. <br><br><h2>  <font color="#0071c5">HDR (extended dynamic range)</font> </h2><br>  In normal rendering, the values ‚Äã‚Äãof red, green (G) and blue (B) colors of each pixel are represented by a decimal number whose value is from 0 to 1. If you limit the range of values ‚Äã‚Äãfor these colors, the lighting will look unrealistic.  To achieve more natural lighting, you can enable High Dynamic Range (HDR) in Unity.  In this case, the R, G, and B values ‚Äã‚Äãof each pixel may fall outside the normal range.  HDR creates an image buffer that supports values ‚Äã‚Äãoutside the range from 0 to 1, and performs post-processing of graphic effects, such as blur and glare.  After calculating the post-processing effects, the R, G, and B values ‚Äã‚Äãin the image buffer are reset to values ‚Äã‚Äãwithin the range from 0 to 1 using Unity's shade map technology.  If the construction of hue maps is not performed using HDR, then the pixels may be outside the acceptable range, due to which some colors of the scene may look wrong compared to others. <br><br>  When using HDR, watch for parameters that affect performance.  When using advanced scene rendering, HDR will work only with graphic effects.  Otherwise, the inclusion of HDR will not affect anything.  With deferred rendering, HDR is always used. <br>  If the scene is processed using deferred rendering, and graphic effects are assigned to the camera, then HDR should be enabled.  In fig.  15 compares the number of render calls for a scene with effects and deferred rendering with HDR turned on and off.  Without HDR, the number of render calls is significantly higher than with HDR, if the scene contains effects.  In fig.  15, the number of rendering calls is represented by individual blue stripes, and the height of each strip corresponds to the load of each call to the GP. <br><br><img src="https://habrastorage.org/files/1b5/747/c1c/1b5747c1c3e54b7f80c6054df7e13e1b.png"><br>  <i>Figure 15. Measurement using Intel Graphics Performance Analyzers shows that when HDR is disabled, over 2000 render calls are performed, while HDR is on ‚Äî just over 900 render calls</i> <br><br>  Check out Unity's HDR documentation to understand how this functionality works.  You also need to know in which cases the extended dynamic range should be applied in order to get a performance boost due to this, and in which cases it does not make sense. <br><br><h2>  <font color="#0071c5">Graphic effects</font> </h2><br>  Unity Pro contains a number of graphical effects that enhance the look of the scene.  To add an Image Effects component after creating a project, use the Assets-&gt; Import Package-&gt; Image Effects menu.  After importing, you can add an effect to the camera in two ways.  Click the game object of the camera, in the camera window, select Add Component, and then Image Effects.  You can also click the camera object in the menu by selecting Component-&gt; Image Effect. <br><br><h2>  <font color="#0071c5">Broken Screen Shading - SSAO</font> </h2><br>  Screened Shading in Screen Space (SSAO) is a graphic effect as part of the Image Effect package in Unity Pro.  In fig.  16 shows the difference between enabled and disabled SSAO.  Images look similar, but performance varies significantly.  With a scene without SSAO, the frame rate was 32 frames per second, and with SSAO - 24 frames per second, that is, 25% lower. <br><br><img src="https://habrastorage.org/files/8a5/48c/294/8a548c294fd34d7dbd422b59beef436d.png"><br>  <i>Figure 16. Comparison of the same level with disabled SSAO (top) and SSAO enabled (bottom)</i> <br><br>  Be careful when adding graphic effects, as they may adversely affect performance.  In preparing this document, we tested only SSAO, but we should expect similar results when using other effects. <br><br><h2>  <font color="#0071c5">Exclusion of obstructed objects</font> </h2><br>  The exclusion of obscured objects is the shutdown of rendering not only those objects that are located beyond the clipping plane of the camera, but also objects hidden behind other objects.  This is very beneficial in terms of performance, since the amount of information that needs to be processed is significantly reduced.  However, setting the exclusion of obscured objects is not too easy.  Before setting up the scene to exclude obscured objects, you should understand the terminology used. <br>  A defensive object ‚Äî an object marked as a defensive object acts as a barrier: all objects blocked by it that are marked as blocked are not drawn. <br>  Shielded object - if you mark an object in this way, it will not be rendered in Unity if it is blocked by a shielding object. <br>  For example, if you mark all the objects inside the house as obscured, the house itself can be marked as obscuring.  If the game character is located outside this house, then all objects inside the house that are marked as obscured will not be drawn.  This speeds up processing on the CPU and GP. <br>  The use and configuration of eliminating obscured objects is documented in Unity.  Refer to the reference section for setup information. <br>  To demonstrate the change in performance (depending on the exclusion of obscured objects), I created a scene where a wall is in the foreground, and behind it are objects with complex models.  I measured the frame rate of the scene with the exception of obscured objects, and then without it.  In fig.  17 shows a scene with a different frame rate. <br><br><img src="https://habrastorage.org/files/ce2/283/296/ce2283296a9949a0bb1d0442ddf8c5c0.png"><br>  <i>Figure 17. In the image on the left, the exclusion of obstructed objects is disabled, all objects located behind the wall are drawn, so the frame rate is 31 frames per second.</i>  <i>In the image on the right, the exclusion of obscured objects is turned on, objects obscured by the wall are not drawn, so the speed has increased to 126 frames per second.</i> <br><br>  Exclusion of obscured objects must be manually configured by developers.  We should not forget about the exclusion of obscured objects when designing games, since this reduces equipment requirements and improves performance. <br><br><h2>  <font color="#0071c5">Level of Detail (LOD)</font> </h2><br>  Using the level of detail (LOD), you can assign several models of different complexity to one game object and switch between them depending on the distance between the object and the camera.  This can be beneficial in terms of performance for complex game objects that are far from the camera.  Using the level of detail you can automatically simplify the model.  For information on using and setting the level of detail, see the Unity documentation.  The link is given in the reference section. <br>  To test the performance gain when changing the level of detail, I created a scene with a group of houses, which were assigned 3 different models.  Placing the camera in the same place, I measured the frame rate of the scene with the houses when using the most complex model.  Then I changed the distance of detail to use models with a lower degree of detail, and took the measurement again.  I have done this procedure for the three levels of models and recorded the data in table 5. <br>  In fig.  18, 19, and 20 show three different levels of model complexity with the number of polygons and vertices in each model. <br><br><table><tbody><tr><th colspan="2">  Best quality - level of detail 0 </th></tr><tr><td>  Building A <br>  ‚Ä¢ Summits - 7065 <br>  ‚Ä¢ Polygons - 4999 <br>  Building B <br>  ‚Ä¢ Summits - 5530 <br>  ‚Ä¢ Polygons - 3694 <br></td><td> <a href=""><img src="https://habrastorage.org/files/9d1/c94/fa0/9d1c94fa01b5426094fc46338519ce92.jpg"></a> <br>  <i>Figure 18. The level of detail is 0. This is the highest</i> <i><br></i>  <i>the level of detail at which to use</i> <i><br></i>  <i>the most complex models (click to enlarge)</i> <br></td></tr><tr><th colspan="2">  Medium quality - level of detail 1 </th></tr><tr><td>  Building A <br>  ‚Ä¢ Summits - 6797 <br>  ‚Ä¢ Polygons - 4503 <br>  Building B <br>  ‚Ä¢ Polygons - 5476 <br>  ‚Ä¢ Summits - 3690 <br></td><td> <a href=""><img src="https://habrastorage.org/files/0a8/db2/068/0a8db20689284376885ad17899490b9e.jpg"></a> <br>  <i>Figure 19. Level of detail 1. This level is</i> <i><br></i>  <i>one step down the scale of detail on it</i> <i><br></i>  <i>Models of medium complexity are used (click to enlarge)</i> <br></td></tr><tr><th colspan="2">  Low quality - level of detail 2 </th></tr><tr><td>  Building A <br>  ‚Ä¢ Summits - 474 <br>  ‚Ä¢ Polygons - 308 <br>  Building B <br>  ‚Ä¢ Polygons - 450 <br>  ‚Ä¢ Summits - 320 <br></td><td> <a href=""><img src="https://habrastorage.org/files/381/f06/5a1/381f065a1c3941aeb71bdf371cf51172.jpg"></a> <br>  <i>Figure 20. Level of Detail 2. This is the last level.</i> <i><br></i>  <i>details, here are used the least complex models</i> <i><br></i>  <i>(click to enlarge)</i> <br></td></tr></tbody></table><br>  Switching between different levels of detail, I measured the frame rate for comparison (Table 7). <br><br><img src="https://habrastorage.org/files/a32/129/8ef/a321298ef7f843f38faef7844eacf4fc.png"><br>  <i>Table 7. Comparison of frame rate at different levels of detail</i> <br><br>  Table 7 shows an increase in performance when setting up and using different levels of detail.  Frame rate increases significantly when switching to less complex models.  However, this increases the amount of work of artists who will have to create several models of each object.  Game designers must decide for themselves whether they should spend extra time drawing additional models in order to increase their productivity. <br><br><h2>  <font color="#0071c5">Batch processing</font> </h2><br>  Excessive number of rendering calls can lead to excessive load on the CPU and decrease in performance.  The more objects on the screen, the more rendering calls need to be made.  In Unity, so-called batch processing is supported, allowing you to put several game objects into a single render call.  Static batch processing is designed for static objects, and dynamic - for moving objects.  Dynamic batch processing is performed automatically when all requirements are met (see the batch processing documentation), and static batch processing must be set manually. <br>  There are certain requirements for co-rendering objects for both dynamic and static batch processing.  All of these requirements are listed in the batch processing document referenced in the reference section. <br>  To test the performance gain in static batch processing, I created a scene with complex game objects in the form of airplanes (Fig. 21) and measured the frame rate with and without batch processing (Table 8). <br><br><img src="https://habrastorage.org/files/9db/838/fe2/9db838fe294f410ea6383e71c25d1b8f.png"><br>  <i>Figure 21. Static batch processing of a test scene with very complex aircraft models</i> <br><br><img src="https://habrastorage.org/files/048/fc6/23b/048fc623b9c14e54bc18b0788b4ebbf6.png"><br>  <i>Table 8. The difference in personnel rate and the number of rendering calls when the static batch processing is enabled and disabled (Fig. 21)</i> <br><br>  Unity supports two types of batch processing, dynamic and static.  To get the most benefit from batch processing, try to combine as many objects as possible into a batch for one render call.  For information on which objects are suitable for dynamic or static batch processing, see the Unity documentation. <br><br><h2>  <font color="#0071c5">Conclusion</font> </h2><br>  In Unity, you can easily start working on projects, but with no less ease, you can prevent the lack of application performance.  Unity supports a number of settings and tools that allow you to achieve smooth graphics in games, but not all of these tools are conveniently configured and intuitive.  In addition, some settings in Unity, if enabled or incorrectly used, can adversely affect the performance of games.  When developing with Unity, it is important to prepare a plan in advance, because for some performance related functions, manual tuning is required, which can be much more difficult if you do not plan it in advance (when creating a project). <br><br><h2>  <font color="#0071c5">Additional materials on the topic</font> </h2><br>  <a href="https://software.intel.com/en-us/articles/how-to-plan-optimizations-with-unity">Original article: How To Plan Optimizations with Unity *</a> <br><br>  <a href="http://docs.unity3d.com/Documentation/Components/class-QualitySettings.html">Quality Parameter Documentation</a> <br>  <a href="http://docs.unity3d.com/Documentation/ScriptReference/QualitySettings.html">Quality Parameter Script API</a> <br>  <a href="http://u3d.as/content/unity-technologies/bootcamp/28W">Technical demonstration Boot Camp</a> <br>  <a href="http://docs.unity3d.com/Documentation/Manual/LevelOfDetail.html">Level of detail documentation</a> <br>  <a href="http://docs.unity3d.com/Documentation/Manual/OcclusionCulling.html">Documentation on the exclusion of hidden parts</a> <br>  <a href="http://docs.unity3d.com/Documentation/Manual/DrawCallBatching.html">Batch Processing Documentation</a> <br>  <a href="http://docs.unity3d.com/Documentation/Manual/RenderingPaths.html">Rendering Path Documentation</a> <br><br>  <a href="http://software.intel.com/en-us/vcsource/tools/intel-gpa">Intel GPA</a> <br>  <a href="https://software.intel.com/ru-ru/articles/adding-multi-touch-support-to-unity-games-on-microsoft-windows-7-and-windows-8-desktop">Adding support for multitouch input to Unity * games for Microsoft Windows * 7 and classic Windows * 8 interface</a> <br>  <a href="https://software.intel.com/ru-ru/articles/implementing-gesture-sequences-in-unity-3d-with-touchscript">Implementing gesture sequences in Unity * 3D using the TouchScript library</a> <br>  <a href="https://software.intel.com/ru-ru/articles/using-touch-gestures">Using touch gestures to control physics parameters in Unity * 3D with TouchScript</a> <br>  <a href="https://software.intel.com/ru-ru/articles/using-unity-3d-standard-gui-with-touchscript-assets">Use standard GUI Unity * 3D in combination with TouchScript resources</a> </div><p>Source: <a href="https://habr.com/ru/post/254353/">https://habr.com/ru/post/254353/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../254339/index.html">Self resettable fuses. Myths and Reality</a></li>
<li><a href="../254343/index.html">Daniil Dubrovkin: "Open source does not mean that it is free and that it does not belong to anyone."</a></li>
<li><a href="../254345/index.html">New in Wolfram Language: WikipediaData feature for integrating with Wikipedia and processing its data</a></li>
<li><a href="../254349/index.html">How the process in Data Science works</a></li>
<li><a href="../254351/index.html">How to catch what is not. Part Three: Who are the judges?</a></li>
<li><a href="../254355/index.html">All about collections in Oracle</a></li>
<li><a href="../254357/index.html">Basket for product catalog (minibasket.js)</a></li>
<li><a href="../254361/index.html">Indoor "GPS" with an accuracy of -2 cm</a></li>
<li><a href="../254363/index.html">Analysis of the tasks of the first qualifying round of the Russian Code Cup 2015</a></li>
<li><a href="../254365/index.html">Correct insertion of C ++ preprocessor definitions in CMake</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>