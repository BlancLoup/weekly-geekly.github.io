<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Implementing a pseudo-random number generator on a FPGA using Vivado HLS 2014.4</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In many problems it becomes necessary to use a pseudo-random number generator. So we have such a need. In general, the task was to create a computing ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Implementing a pseudo-random number generator on a FPGA using Vivado HLS 2014.4</h1><div class="post__text post__text-html js-mediator-article">  In many problems it becomes necessary to use a pseudo-random number generator.  So we have such a need.  In general, the task was to create a computing platform based on the <a href="http://yandex.ru/search/%3Flr%3D213%26text%3DRB-8V7">RB8V7</a> unit, which was supposed to be used as an accelerator of calculations for a specific scientific task. <br><br>  <i>I will say a few words about this scientific problem: it was necessary to calculate the dynamics of biological microtubules at times of the order of a minute.</i>  <i>The calculations were calculations using a molecular-mechanical model of a microtubule developed in a scientific group.</i>  <i>It was planned that, based on the results of the calculations, it would be possible to conclude about the mechanisms of dynamic instability of microtubules.</i>  <i>The need to use an accelerator was due to the fact that a minute is equivalent to a sufficiently large number of calculation steps (~ 10 ^ 12) and, as a result, to a large amount of time spent on calculations.</i> <br><br>  So, returning to the topic of the article, in our case, pseudo-random number generators were needed to take into account the thermal motion of the molecules of the microtubules mentioned. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      As the basic architecture of the project was used <a href="http://habrahabr.ru/post/193646/">architecture with support for DMA transmissions</a> .  As a component of this computing platform, it was necessary to implement an IP core that would be able to generate a new pseudo-random, normally distributed float number every clock cycle and use as few resources as possible on the FPGA. <br><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Read more</b> <div class="spoiler_text">  The last requirement was due to the fact that, first of all, apart from this IP core, other computational modules + interface part had to be present on the FPGA, secondly, calculations in the task were performed on floating-point numbers of the float type, which in the case of FPGAs occupy quite a lot of resources, and, thirdly, several cores were assumed on FPGAs.  The requirement to generate a random number every clock was due to the architecture of the final computing module, which, in fact, used the data random numbers.  The architecture was a pipeline and, accordingly, required new random numbers every clock. <br></div></div><br>  I want to note that, as a result, everything turned out well for us, but the path to solving this problem was not without wrong steps and mistakes, which I also want to write below.  I hope this article will be useful. <br><br>  To solve this problem, we used a high-level language translator in RTL code.  To implement a complex computational problem, this approach allows one to obtain a result much faster (and often better) than using bare RTL.  We used the <a href="http://www.xilinx.com/products/design-tools/vivado/integration/esl-design.html">Vivado HLS</a> version 2014.4 program, which translates C / C ++ code using special directives into RTL code.  Examples of directives can be found <a href="https://rtslab.wikispaces.com/Vivado%2BHLS%2Bknowledge%2Bbase">here</a> . <br><br>  Taking into account the mentioned requirements for the solution being developed and the fact that the generator must include several stages of calculation, the most suitable architecture is a pipeline.  You can read more about the implementation of the FPGA conveyor <a href="http://habrahabr.ru/post/235037/">here</a> .  I want to note that the main characteristics of the computing pipeline are the initialization interval and latency.  The initialization interval is the number of cycles spent on the execution of the conveyor stage (the maximum among all the stages). <br><br>  Latency is the number of ticks elapsed from the moment the data arrived at the input of the pipeline until the result of the conveyor output.  In this case, the latency does not interest us very much, since it is negligible compared to the estimated total time of the pipeline, but the initialization interval should be taken very carefully, because it actually characterizes how often the pipeline is able to accept data and how often he is able to produce a new result. <br><br>  Initially, it was decided to use the following approach: <br><ul><li>  <a href="https://ru.wikipedia.org/wiki/%25D0%25A0%25D0%25B5%25D0%25B3%25D0%25B8%25D1%2581%25D1%2582%25D1%2580_%25D1%2581%25D0%25B4%25D0%25B2%25D0%25B8%25D0%25B3%25D0%25B0_%25D1%2581_%25D0%25BB%25D0%25B8%25D0%25BD%25D0%25B5%25D0%25B9%25D0%25BD%25D0%25BE%25D0%25B9_%25D0%25BE%25D0%25B1%25D1%2580%25D0%25B0%25D1%2582%25D0%25BD%25D0%25BE%25D0%25B9_%25D1%2581%25D0%25B2%25D1%258F%25D0%25B7%25D1%258C%25D1%258E">linear feedback shift registers</a> for obtaining independent integers of uniformly distributed random numbers.  In the beginning, each of them is initiated with the help of its ‚Äúseed‚Äù number, the so-called  seed. </li><li>  central limit theorem, which allows us to state that the sum of a large number of independent random variables has a distribution close to normal.  In our case, 12 numbers are added. <br></li></ul><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> HLS PIPELINE unsigned lsb = lfsr &amp; 1; lfsr &gt;&gt;= 1; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (lsb == 1) lfsr ^= 0x80400002; return lfsr;</span></span></code> </pre> <br></div></div><br>  From the advantages of this approach, it is worth noting that this generator of normal numbers is implemented in the final scheme very simply and doesn‚Äôt really take very much.  The main disadvantage of this approach is that it is wrong in our case.  =) Indeed, the sequential values ‚Äã‚Äãthat the generator produces are correlated.  This can be clearly demonstrated by building an autocorrelation function (see fig.), Or by plotting x [i + k] as a function of x [i], where k = 1,2,3 ... <br><br><div class="spoiler">  <b class="spoiler_title">Autocorrelation function</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/65d/b8a/522/65db8a522d294dd297d0ba1b0bc300f6.jpg"><br></div></div><br><br>  This error resulted in interesting effects in the dynamics of microtubules, the movement of which was modeled using this generator. <br><br><img src="https://habrastorage.org/files/ba9/c2e/011/ba9c2e0112ee47ddb5126af73a302601.gif"><br><br>  So, the algorithm for generating uniformly distributed integers needed to be changed.  The choice fell on the <a href="https://ru.wikipedia.org/wiki/%25D0%2592%25D0%25B8%25D1%2585%25D1%2580%25D1%258C_%25D0%259C%25D0%25B5%25D1%2580%25D1%2581%25D0%25B5%25D0%25BD%25D0%25BD%25D0%25B0">Mersenne Whirlwind</a> .  The fact that the algorithm values ‚Äã‚Äãof the generated numbers are not correlated with each other can be seen by looking at the autocorrelation function of the resulting sequence of numbers.  However, the implementation of this algorithm requires more resources, since it works with a field of numbers of size 612, rather than with one number as in the previous case (see the <a href="">code in the public domain</a> ). <br><br><div class="spoiler">  <b class="spoiler_title">autocorrelation function</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/0a0/9ff/4c0/0a09ff4c0ecc4d8b826165a9c215198f.jpg"><br></div></div><br>  <i>Immediately make a reservation that I understand by the words "the procedure takes n cycles (steps)."</i>  <i>This means that this procedure, when broadcasting in RTL, will be performed in n clock pulses.</i>  <i>For example, if at the next step of the pipeline we need to read two words from a single-port RAM memory, then this operation will be performed in two cycles, since the port is only one, that is, the memory can ensure that only one write or read request is executed per clock.</i> <br><br>  For optimal translation of this algorithm in RTL code it was necessary to rework.  First, in the initial implementation inside the generator, the following happens: when a new random number is requested, either the next matrix element is output, or when the matrix end is reached, the matrix elements are updated.  The update procedure consists of various bitwise operations using array elements.  The procedure takes at least 612 steps, since the value of each element is updated.  Then the output is the zero element of the matrix.  Thus, the procedure will take a different number of steps for different calls to this function.  Such a function cannot be pipelined. <br><br><div class="spoiler">  <b class="spoiler_title">Option 0</b> <div class="spoiler_text"><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> y; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mti &gt;= N) { <span class="hljs-comment"><span class="hljs-comment">/* generate N words at one time */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> kk; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mti == N+<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-comment"><span class="hljs-comment">/* if sgenrand() has not been called, */</span></span> sgenrand(<span class="hljs-number"><span class="hljs-number">4357</span></span>); <span class="hljs-comment"><span class="hljs-comment">/* a default initial seed is used */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (kk=<span class="hljs-number"><span class="hljs-number">0</span></span>;kk&lt;NM;kk++) { y = (mt[kk]&amp;UPPER_MASK)|(mt[kk+<span class="hljs-number"><span class="hljs-number">1</span></span>]&amp;LOWER_MASK); mt[kk] = mt[kk+M] ^ (y &gt;&gt; <span class="hljs-number"><span class="hljs-number">1</span></span>) ^ mag01[y &amp; <span class="hljs-number"><span class="hljs-number">0x1</span></span>]; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (;kk&lt;N<span class="hljs-number"><span class="hljs-number">-1</span></span>;kk++) { y = (mt[kk]&amp;UPPER_MASK)|(mt[kk+<span class="hljs-number"><span class="hljs-number">1</span></span>]&amp;LOWER_MASK); mt[kk] = mt[kk+(MN)] ^ (y &gt;&gt; <span class="hljs-number"><span class="hljs-number">1</span></span>) ^ mag01[y &amp; <span class="hljs-number"><span class="hljs-number">0x1</span></span>]; } y = (mt[N<span class="hljs-number"><span class="hljs-number">-1</span></span>]&amp;UPPER_MASK)|(mt[<span class="hljs-number"><span class="hljs-number">0</span></span>]&amp;LOWER_MASK); mt[N<span class="hljs-number"><span class="hljs-number">-1</span></span>] = mt[M<span class="hljs-number"><span class="hljs-number">-1</span></span>] ^ (y &gt;&gt; <span class="hljs-number"><span class="hljs-number">1</span></span>) ^ mag01[y &amp; <span class="hljs-number"><span class="hljs-number">0x1</span></span>]; mti = <span class="hljs-number"><span class="hljs-number">0</span></span>; } y = mt[mti++]; y ^= (y &gt;&gt; <span class="hljs-number"><span class="hljs-number">11</span></span>); y ^= (y &lt;&lt; <span class="hljs-number"><span class="hljs-number">7</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x9d2c5680</span></span>UL; y ^= (y &lt;&lt; <span class="hljs-number"><span class="hljs-number">15</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0xefc60000</span></span>UL; y ^= (y &gt;&gt; <span class="hljs-number"><span class="hljs-number">18</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( (<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>)y * <span class="hljs-number"><span class="hljs-number">2.3283064370807974e-10</span></span> ); <span class="hljs-comment"><span class="hljs-comment">/* reals */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* return y; */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* for integer generation */</span></span></code> </pre><br></div></div><br>  Let's change this procedure: now, in one call to the function, the previous element of the array is updated and the current element is returned.  Now this procedure always takes the same number of cycles.  At the same time, the result is the same in both implementations: at the end of the matrix traversal, it will already be filled with the updated values ‚Äã‚Äãand you can simply return to the zero element of the array.  Now this procedure is really pipelined. <br><div class="spoiler">  <b class="spoiler_title">Option 1</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> HLS PIPELINE #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> HLS INLINE float y; unsigned long mt_temp,reg1; unsigned long temper, temper1; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (mti</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;N_period-M_period) { mt_temp = (mt[mti]&amp;UPPER_MASK)|(mt[mti+1]&amp;LOWER_MASK); mt[mti] = mt[mti+M_period] ^ (mt_temp &gt;&gt; 1) ^ mag01[mt_temp &amp; 0x1UL]; }else{ if (mti&lt;N_period-1) { mt_temp = (mt[mti]&amp;UPPER_MASK)|(mt[mti+1]&amp;LOWER_MASK); mt[mti] = mt[mti+(M_period-N_period)] ^ (mt_temp &gt;&gt; 1) ^ mag01[mt_temp &amp; 0x1UL]; }else{ mt_temp = (mt[N_period-1]&amp;UPPER_MASK)|(mt[0]&amp;LOWER_MASK); mt[N_period-1] = mt[M_period-1] ^ (mt_temp &gt;&gt; 1) ^ mag01[mt_temp &amp; 0x1UL]; } } reg1 = mt[mti]; if (mti == (N_period - 1)) mti = 0; else mti=mti+1; temper=tempering(reg1); temper1 = (temper==0) ? 1 : temper; y=(float) temper1/4294967296.0; return y;</span></span></span></span></code> </pre><br></div></div><br>  Now let us ask ourselves how often such a pipeline will be able to produce a new random number?  For this we need to add some extra clarity.  What resources should the array be used with (mt)?  It can be implemented either using registers or using memory.  Implementation using registers is the easiest from the point of view of the final code optimization to achieve a single initialization interval.  Unlike memory cells, each register can be accessed independently. <br><br>  However, in the case of using a large number of registers, there is a high probability of time delays on the paths between the registers, which leads to the need to reduce the operating frequency for the generated IP core.  In the case of memory use, there is a limit on the number of simultaneous requests to a memory block, the cause of which is the limited number of block ports.  However, problems with time delays, as a rule, do not arise.  Due to resource constraints in our case, it would be preferable to implement an array using memory.  Consider whether we have access memory conflicts and whether it is possible to resolve them. <br><br>  So, how many simultaneous from the point of view of FPGA are array element requests occurring per clock?  First, we note that at every clock cycle we work with four cells of the array.  That is, in the first approximation, we need to provide four simultaneous requests to the memory: three reads and one write.  Moreover, one read and one write occur in the same cell. <br><br><div class="spoiler">  <b class="spoiler_title">Option 2</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> HLS PIPELINE #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> HLS INLINE float y; unsigned long mt_temp,reg1,reg2,reg3,result; unsigned long temper, temper1; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (mti</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;N_period-M_period) { reg2=mt[mti+1]; // read 0 reg3=mt[mti+M_period]; // read 1 }else{ if (mti&lt;N_period-1) { reg2=mt[mti+1]; //read 0 reg3=mt[mti+(M_period-N_period)]; //read 1 }else{ reg2=mt[0]; //read 0 reg3=mt[M_period-1]; //read 1 } } reg1 = mt[mti]; //read 2 mt_temp = (reg1&amp;UPPER_MASK)|(reg2&amp;LOWER_MASK); result = reg3 ^ (mt_temp &gt;&gt; 1) ^ mag01[mt_temp &amp; 0x1UL]; mt[mti]=result; //write if (mti == (N_period - 1)) mti = 0; else mti=mti+1; temper=tempering(result); temper1 = (temper==0) ? 1 : temper; y=(float) temper1/4294967296.0; return y;</span></span></span></span></code> </pre><br></div></div><br>  The first problem that needs to be solved is to remove the read / write conflict in the same cell.  This can be done by noting that, as a result of successive calls to a function, it is just reading from the same cell, thus, for the previous call, it is enough to read the value and save the read in the register, and the next one just take the necessary number from the register.  Now it is necessary to provide three simultaneous requests to the memory: two reads and one write (in different memory cells). <br><br><div class="spoiler">  <b class="spoiler_title">Option 3</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> HLS PIPELINE #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> HLS INLINE float y; unsigned long mt_temp,reg1,reg2,reg3,result; unsigned long temper, temper1; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (mti</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;N_period-M_period) { reg2=mt[mti+1]; //read 0 reg3=mt[mti+M_period]; //read1 }else{ if (mti&lt;N_period-1) { reg2=mt[mti+1]; //read 0 reg3=mt[mti+(M_period-N_period)]; //read 1 }else{ reg2=mt[0]; //read 0 reg3=mt[M_period-1]; //read 1 } } reg1 = prev_val; mt_temp = (reg1&amp;UPPER_MASK)|(reg2&amp;LOWER_MASK); result = reg3 ^ (mt_temp &gt;&gt; 1) ^ mag01[mt_temp &amp; 0x1UL]; mt[mti]=result; //write prev_val=reg2; if (mti == (N_period - 1)) mti = 0; else mti=mti+1; temper=tempering(result); temper1 = (temper==0) ? 1 : temper; y=(float) temper1/4294967296.0; return y;</span></span></span></span></code> </pre><br></div></div><br>  There are several techniques for resolving memory requests conflicts in Vivado HLS: first, add a directive that tells the translator to implement an array through dual-port RAM memory, so you can afford two simultaneous requests to the memory block, provided that they do not access to the same cell. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> HLS RESOURCE variable=mt1 core=RAM_2P_BRAM</span></span></code> </pre><br>  Secondly, there is a directive that tells the translator to implement an array not through one block of memory, but through several.  This can increase the total number of ports, and thus increase the maximum possible number of simultaneous requests.  For example, it is possible to make so that the elements of an array with indices 0 ... N / 2 lay in one memory block, and the elements with indices N / 2 + 1 ... N-1 lay in the second memory block.  Or, for example, elements with indices 2 * k lay in one block, and elements with indices 2 * k + 1 lay in another block.  I note that the number of blocks may be&gt; 2.  It also allows in some cases to increase the number of possible simultaneous requests to the array. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> HLS array_partition variable=AB block factor=4</span></span></code> </pre><br>  Unfortunately, the latter approach in our case was not applicable in its pure form, since we had to split our array into several blocks of unequal size, which the directive does not know how to do.  If you carefully look at which elements in the array are accessed during the passage through all indexes, you can see that the array can be divided into three parts so that each part has no more than two simultaneous queries. <br><br><img src="https://habrastorage.org/files/380/070/394/3800703948304083b1a575bcec41abcc.jpg"><br><br>  In fact, this stage took the greatest amount of time, since the Vivado HLS translator stubbornly did not want to understand what we wanted from it and the final initialization interval was more than 1. It helped that we just presented and drew the final scheme and wrote it in accordance with it code.  Earned! <br><br><div class="spoiler">  <b class="spoiler_title">Scheme</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/851/892/730/85189273084343c685148c6f4d3119bd.jpg"><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Final version</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> HLS PIPELINE #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> HLS RESOURCE variable=mt1 core=RAM_2P_BRAM #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> HLS RESOURCE variable=mt2 core=RAM_2P_BRAM #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> HLS RESOURCE variable=mt3 core=RAM_2P_BRAM #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> HLS INLINE float y; unsigned long mt_temp,reg1,reg2,reg3,result, m1_temp,m2_temp, m3_temp; unsigned long temper, temper1; unsigned int a1,a2, a3,s2,s3; int mti_next=0; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (mti == (N_period - 1)) mti_next = 0; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> mti_next=mti+1; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (mti_next==0) { s2=1; s3=2; a1=mti_next; a2=2*M_period-N_period-1; a3=0; } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (mti_next </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt; (N_period - M_period)) { s2 = 1; s3 = 3; a1 = mti_next; a2 = 0; a3 = mti_next-1; }else if (mti_next== (N_period - M_period)){ s2 = 2; s3 = 3; a2 = 0; a1 = 0; a3 = N_period-M_period-1; } else if (mti_next &lt; M_period) { s2 = 2; s3 = 1; a1 = mti_next - (N_period - M_period)-1; a2 = mti_next - (N_period - M_period); a3 = 0; } else if (mti_next &lt; (2*(N_period-M_period)+1)) { s2 = 3; s3 = 1; a1 = mti_next - (N_period - M_period)-1; a2 = 0; a3 = mti_next - M_period; } else { s2 = 3; s3 = 2; a1 = 0; a2 = mti_next - (2*(N_period-M_period)+1); a3 = mti_next - M_period; } // read data from bram m1_temp = mt1[a1]; m2_temp = mt2[a2]; m3_temp = mt3[a3]; if (s2 == 1) reg2 = m1_temp; else if (s2 == 2) reg2 = m2_temp; else reg2 = m3_temp; if (s3 == 1) reg3 = m1_temp; else if (s3 == 2) reg3 = m2_temp; else reg3 = m3_temp; reg1 = prev_val; mt_temp = (reg1&amp;UPPER_MASK)|(reg2&amp;LOWER_MASK); result = reg3 ^ (mt_temp &gt;&gt; 1) ^ mag01[mt_temp &amp; 0x1UL]; // write process if (mti &lt; (N_period - M_period)) mt1[mti] = result; else if (mti &lt; M_period) mt2[mti-(N_period-M_period)] = result; else mt3[mti-M_period] = result; //save into reg prev_val=reg2; mti=mti_next; temper=tempering(result); temper1 = (temper==0) ? 1 : temper; y=(float) temper1/4294967296.0; return y;</span></span></span></span></code> </pre><br></div></div><br>  Thus, we implemented our array through 3 blocks of dual-port RAM memory, which allowed us to pipe our function and provide a single initialization interval.  That is, now we have a working generator of uniformly distributed pseudo-random numbers.  Now you need to get from these numbers normally distributed pseudo-random numbers.  One could take advantage of the previous approach using the central limit theorem.  However, I remind you that now the generator of uniformly distributed random numbers takes up much more resources, and for the central limit theorem, it would be necessary to implement 12 such generators. <br><br>  Our choice fell on <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D1%2580%25D0%25B5%25D0%25BE%25D0%25B1%25D1%2580%25D0%25B0%25D0%25B7%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5_%25D0%2591%25D0%25BE%25D0%25BA%25D1%2581%25D0%25B0_%25E2%2580%2594_%25D0%259C%25D1%258E%25D0%25BB%25D0%25BB%25D0%25B5%25D1%2580%25D0%25B0">the Box-Muller transformation</a> , which allows us to obtain two normally distributed random numbers from two uniformly distributed random variables on the segment (0.1]. And unlike the approach with the CLT, where 12 is actually not a very large number, in the case of a transformation, we get numbers for which the distribution is analytically exactly Gaussian. A little more detail can be found <a href="http://habrahabr.ru/post/208684/">here</a> . I just want to note that this transformation exists in two versions: one uses less computation, but  This result is not given every time the generator is called, the second approach uses more calculations, but the result is guaranteed with each call. <br><br>  As a result, we need every measure, a second hike was used.  In addition, a directive was applied to each computational operation, which instructs the translator to NOT implement this operation using DSP blocks.  By default, Vivado HLS implements computational operations using the maximum number of DSP blocks.  The fact is that, taking into account pipelining, the number of necessary DSP blocks would be quite large compared to the total number of available DSP blocks.  Considering their location on the chip, long time delays would have been obtained. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> HLS RESOURCE variable=d0 core=FMul_nodsp</span></span></code> </pre><br>  As a result, we got a kernel using the following hike: <br><br><ul><li>  two generators of uniformly distributed random numbers using the Mersenne's "vortex" algorithm </li><li>  the Box-Muller transform, which of the two randomly uniformly distributed on the interval (0,1] gets two normally distributed random numbers </li></ul><br><img src="https://habrastorage.org/getpro/habr/post_images/386/b1f/d98/386b1fd9828a4afa96afd4cd215af4d1.jpg" alt="image"><br><br>  I also bring in a visualization of the microtubule dynamics using this generator. <br><br><img src="https://habrastorage.org/files/4f3/f23/8d1/4f3f238d141141438a0f44a601af8fa9.gif"><br><br>  <b>PS:</b> <i>In fact, after it turned out that the use of the ‚ÄúMersenne Vortex‚Äù approach + the Box-Muller transformation is indeed a working approach for obtaining normally distributed random numbers [1].</i> <br><br>  The project is available on <a href="https://github.com/RostaTasha/RandomGenIP">github</a> . <br><br>  I welcome any questions or comments. <br><br>  [1] High-Performance Computing Using FPGAs Editors: Vanderbauwhede, Wim, Benkrid, Khaled (Eds.) 2013 pp.  20-30 </div><p>Source: <a href="https://habr.com/ru/post/266897/">https://habr.com/ru/post/266897/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../266883/index.html">How Russian cloud services for business inhibit their own market</a></li>
<li><a href="../266885/index.html">Google's Faces API Example</a></li>
<li><a href="../266891/index.html">Inoventica Services on Habr√©</a></li>
<li><a href="../266893/index.html">Creating a native iOS plugin for Unity3d. Undocumented features</a></li>
<li><a href="../266895/index.html">HTML5 customization customization element</a></li>
<li><a href="../266899/index.html">Reinforced.Typings is a library for automatically generating TypeScript-taipings and not only</a></li>
<li><a href="../266901/index.html">Using handle and intrusive reference counter-s in multi-threaded environments in the C language</a></li>
<li><a href="../266903/index.html">PSR-2, the analysis of one item of the standard. Spaces or tabs</a></li>
<li><a href="../266905/index.html">FP on Scala: What is a functor?</a></li>
<li><a href="../266907/index.html">HP TippingPoint ATA Network and HP TippingPoint ATA Mail</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>