<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Managed by PageFault in the Linux kernel</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Exception handling takes an important place in the process of functioning of software systems. Indeed, ensuring timely and correct response to abnorma...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Managed by PageFault in the Linux kernel</h1><div class="post__text post__text-html js-mediator-article">  Exception handling takes an important place in the process of functioning of software systems.  Indeed, ensuring timely and correct response to abnormal events is one of the key tasks performed by the operating system and, in particular, its core.  Being modern, the Linux kernel provides the ability to control the process of exception handling, however, due to the limitations of its interface, this mechanism is not common among developers of kernel modules. <br><br>  Further, on the example of PageFault, some features of the exception handling process will be considered, as well as a description of the method allowing to use this feature in the development of Linux kernel modules for the x86 architecture. <br><br><a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Kernel exceptions </h4><br><br>  As an example of where and how exceptions are used in the kernel, it is worth considering copying data between kernel space and user space.  Usually, the <a href="">copy_from_user</a> and <a href="">copy_to_user</a> functions are responsible for this, a feature of which, in <a href="">contrast</a> to <code>memcpy</code> is that they correctly handle exceptions that occur during data transfer between different address spaces. <br><br>  Indeed, if we consider the situation when data is copied from the kernel to the user ( <code>copy_to_user</code> function), it is possible that situations arise when the user‚Äôs process page into which the recording is attempted is in a swap or is inaccessible to the process.  And if in the first case the correct solution to the problem is to load this page and continue copying, in the second case it is necessary to interrupt the operation and return the error code to the user (for example, <code>-EINVAL</code> ). <br><br>  It is obvious that the execution of the command that accesses the address corresponding to the missing page causes an exception, namely the <i>exception of the page</i> fault, or Page Fault ( <code>#PF</code> ).  At this moment, the kernel saves the context of the current task and executes the code of the corresponding handler, <a href="">do_page_fault</a> .  Anyway, by eliminating the problem, the kernel restores the context of the interrupted task.  However, depending on the result of processing the exception, the return address may differ from the address of the instruction that caused the exception.  In other words, thanks to the mechanism provided for in the kernel, it is possible to set an address for a potentially ‚Äúdangerous‚Äù instruction from which work will be continued in the event of an exception generated during its execution. <br><br><h4>  Exception handling interface </h4><br><br>  To understand how the indicated mechanism is implemented, it is worth considering the implementation of the primitive of copying 4 bytes from the kernel to the user - the function <a href="">__put_user_4</a> : <br><br><pre> <code class="cpp hljs"><span class="hljs-number"><span class="hljs-number">62</span></span> ENTRY(__put_user_4) <span class="hljs-number"><span class="hljs-number">63</span></span> ENTER <span class="hljs-number"><span class="hljs-number">64</span></span> <span class="hljs-function"><span class="hljs-function">mov </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TI_addr_limit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(%_ASM_BX)</span></span></span><span class="hljs-function">,%_ASM_BX 65 sub $3,%_ASM_BX 66 cmp %_ASM_BX,%_ASM_CX 67 jae bad_put_user 68 ASM_STAC 69 3: movl %eax,</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(%_ASM_CX)</span></span></span><span class="hljs-function"> &lt;-     70 xor %eax,%eax 71 EXIT 72 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ENDPROC</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(__put_user_4)</span></span></span><span class="hljs-function"> ... 89 bad_put_user: 90 CFI_STARTPROC 91 movl $-EFAULT,%eax 92 EXIT ... 98 _</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ASM_EXTABLE</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">3b</span></span></span></span><span class="hljs-function"><span class="hljs-params">,bad_put_user)</span></span></span></span></code> </pre><br><br>  As can be seen, in addition to checking the range of addresses, this function directly <code>movl</code> data (the <code>movl</code> instruction on line 69).  It is here that an exception can be expected, since  in addition to the fact that the target address really belongs to the range of user-space addresses, nothing more is known about it.  Next, you should pay attention to the <a href="">_ASM_EXTABLE</a> macro, which is the following: <br><br><pre> <code class="cpp hljs"><span class="hljs-number"><span class="hljs-number">43</span></span> <span class="hljs-meta"><span class="hljs-meta"># </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _ASM_EXTABLE(from,to) \ 44 .pushsection </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"__ex_table"</span></span></span><span class="hljs-meta">,</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"a"</span></span></span><span class="hljs-meta"> ; \ 45 .balign 8 ; \ 46 .long (from) - . ; \ 47 .long (to) - . ; \ 48 .popsection</span></span></code> </pre><br><br>  The action of this macro is to add to the special section <code>__ex_table</code> two values ‚Äã‚Äã- <code>from</code> and <code>to</code> , which, as it is not difficult to see, correspond to the addresses of the ‚Äúsuspicious‚Äù instruction in line 69 and the instruction that will be executed after processing the exception, namely, <code>bad_put_user</code> .  Adding an entry to the <code>__ex_table</code> table makes the point of failure manageable, since  This table is used by the kernel when handling exceptions. <br><br><h4>  Exception tables and their handling </h4><br><br>  So, as noted, the exception table is a central place where information is stored about those instructions, the error in the execution of which must be processed separately.  Looking ahead, it is worth noting that in addition to the table of the kernel itself, an individual table is also provided for each module.  However, now it is worth considering the structure of its element, described by the structure <a href="">exception_table_entry</a> : <br><br><pre> <code class="cpp hljs"><span class="hljs-number"><span class="hljs-number">97</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">exception_table_entry</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-number"><span class="hljs-number">98</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> insn, fixup; <span class="hljs-number"><span class="hljs-number">99</span></span> };</code> </pre><br><br>  As you can see, the format of the table element corresponds to what was revealed when reviewing the <code>_ASM_EXTABLE</code> macro.  The first element describes the instruction, the second - the code to which control will be transferred in the event of an exception.  Each time a page <code>__ex_table</code> occurs, the Linux kernel, among other things, checks whether the address of the command that caused the exception is in the <code>__ex_table</code> kernel table, or in one of the tables of loaded modules.  If such a record is found, then the corresponding action is taken.  Otherwise, the kernel executes some kind of standard logic for completing exception handling. <br><br>  As for the individual exception tables of the kernel modules, the format of the elements of these tables is standard and corresponds to that for the kernel.  The reference to such a table for each module is available by the pointer <code>THIS_MODULE-&gt;extable</code> , whereas the number of elements of the table is contained in the variable <code>THIS_MODULE-&gt;num_exentries</code> .  The macro <a href="">itself THIS_MODULE</a> gives a link to the structure-descriptor of the module: <br><br><pre> <code class="cpp hljs"><span class="hljs-number"><span class="hljs-number">223</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">module</span></span></span><span class="hljs-class"> 224 {</span></span> ... <span class="hljs-number"><span class="hljs-number">276</span></span> <span class="hljs-comment"><span class="hljs-comment">/* Exception table */</span></span> <span class="hljs-number"><span class="hljs-number">277</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> num_exentries; <span class="hljs-number"><span class="hljs-number">278</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">exception_table_entry</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">extable</span></span></span><span class="hljs-class">;</span></span> ... <span class="hljs-number"><span class="hljs-number">378</span></span> };</code> </pre><br><br>  The following is a key kernel function that searches for a handler that matches the statement that caused the exception.  Here is its <a href="">code</a> : <br><br><pre> <code class="cpp hljs"> <span class="hljs-number"><span class="hljs-number">50</span></span> <span class="hljs-comment"><span class="hljs-comment">/* Given an address, look for it in the exception tables. */</span></span> <span class="hljs-number"><span class="hljs-number">51</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> struct exception_table_entry *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">search_exception_tables</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> addr)</span></span></span><span class="hljs-function"> 52 </span></span>{ <span class="hljs-number"><span class="hljs-number">53</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">exception_table_entry</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">e</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-number"><span class="hljs-number">54</span></span> <span class="hljs-number"><span class="hljs-number">55</span></span> e = search_extable(__start___ex_table, __stop___ex_table<span class="hljs-number"><span class="hljs-number">-1</span></span>, addr); <span class="hljs-number"><span class="hljs-number">56</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!e) <span class="hljs-number"><span class="hljs-number">57</span></span> e = search_module_extables(addr); <span class="hljs-number"><span class="hljs-number">58</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> e; <span class="hljs-number"><span class="hljs-number">59</span></span> }</code> </pre><br><br>  As you can see, really, first of all, the search is performed in the base table of the <code>__ex_table</code> kernel and only then, if there is no result, continues among the exception tables of the modules.  If none of the handlers matches the instruction address, the result of the kernel‚Äôs execution of this function is <code>NULL</code> .  Otherwise, the result will be a pointer to the corresponding element of the exception table. <br><br><h4>  Exception handling in the kernel module </h4><br><br>  So, if the procedure for handling exceptions is in general clear, then for training you can create a module whose purpose is to create exceptions and handle them.  The code I have already <a href="https://github.com/milabs/kmod_extable">written</a> is available on <a href="https://github.com/milabs">github</a> .  Further I will give a brief description of the code and give some comments. <br><br>  So, let the PageFault exception generation be handled by a function that makes the usual NULL pointer dereference: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">raise_page_fault</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ debug(<span class="hljs-string"><span class="hljs-string">" %s enter\n"</span></span>, __func__); ((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *)<span class="hljs-number"><span class="hljs-number">0</span></span>)[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-number"><span class="hljs-number">0xdeadbeef</span></span>; debug(<span class="hljs-string"><span class="hljs-string">" %s leave\n"</span></span>, __func__); }</code> </pre><br><br>  Obviously, an attempt to write on a null pointer will lead to a fall.  And this is exactly what you need.  In order to properly respond, you must: <br><br><ul><li>  determine the address of the instruction that causes the exception </li><li>  create a valid <code>exception_table_entry</code> element </li><li>  add the created element to the table of the <code>extable</code> module </li></ul><br><br>  Below is a function that performs the above steps using disassembly using <a href="https://github.com/vmt/udis86">udis86</a> : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fixup_page_fault</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct exception_table_entry * entry)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">ud_t</span></span> ud; ud_initialize(&amp;ud, BITS_PER_LONG, \ UD_VENDOR_ANY, (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *)raise_page_fault, <span class="hljs-number"><span class="hljs-number">128</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (ud_disassemble(&amp;ud) &amp;&amp; ud.mnemonic != UD_Iret) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ud.mnemonic == UD_Imov &amp;&amp; \ ud.operand[<span class="hljs-number"><span class="hljs-number">0</span></span>].type == UD_OP_MEM &amp;&amp; ud.operand[<span class="hljs-number"><span class="hljs-number">1</span></span>].type == UD_OP_IMM) { <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> address = \ (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)raise_page_fault + ud_insn_off(&amp;ud); extable_make_insn(entry, address); extable_make_fixup(entry, address + ud_insn_len(&amp;ud)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -EINVAL; }</code> </pre><br><br>  As you can see, the disassembler is set up first (analysis start - <code>raise_page_fault</code> ).  Further, with a given search depth, commands are searched.  The required command (what the operation is translated into <code>((int *)0)[0] = 0xdeadbeef;</code> ) is the usual <code>movl $0xdeadbeef, 0</code> with the first operand of the <code>UD_OP_MEM</code> type and the second one of the <code>UD_OP_IMM</code> type.  As soon as the address of the command is found, a table element is formed.  At the same time, the following functions are performed: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">extable_make_insn</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct exception_table_entry * entry, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> addr)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> LINUX_VERSION_CODE &gt;= KERNEL_VERSION(3,5,0) entry-&gt;insn = (unsigned int)((addr - (unsigned long)&amp;entry-&gt;insn)); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> entry-&gt;insn = addr; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> } static void extable_make_fixup(struct exception_table_entry * entry, unsigned long addr) { #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> LINUX_VERSION_CODE &gt;= KERNEL_VERSION(3,5,0) entry-&gt;fixup = (unsigned int)((addr - (unsigned long)&amp;entry-&gt;fixup)); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> entry-&gt;fixup = addr; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> }</span></span></code> </pre><br><br>  The first of these, forms the address of the instructions in the structure.  The second is the fixup address, i.e.  commands to which control will be transferred.  It is important to note that since the 3.5 kernel, small changes have occurred in the structure of the <code>exception_table_entry</code> , namely, the dimension of its fields has been reduced - <code>insn</code> and <code>fixup</code> for 64-bit architectures.  This made it possible to reduce the amount of memory required for storing addresses, but the logic of calculation has changed slightly.  So, after the 3.5 kernel, the <code>insn</code> and <code>fixup</code> store 32-bit values ‚Äã‚Äãcorresponding to the address offsets relative to these elements.  For those who are interested, I bring a commit, which spoiled everything <a href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/%3Fid%3D706276543b699d80f546e45f8b12574e7b18d952">706276543b699d80f546e45f8b12574e7b18d952</a> . <br><br><h4>  Conclusion </h4><br><br>  This example demonstrates the ability to handle exception handling in the Linux kernel using a kernel module.  In the test case, the exception (PageFault) was called in the previously prepared environment, namely the configured table of the <code>exables</code> module.  The latter circumstance made it possible to eliminate the abnormal termination and continue the execution of the program with the command following the emergency instruction. <br><br>  In addition, the prepared <a href="https://github.com/milabs/kmod_extable">test case</a> allows us to evaluate the possibility of processing some other exceptions, such as <i>division error</i> (#DE) and <i>undefined opcode</i> (#UD): <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> * name; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> (* fixup)(struct exception_table_entry *); <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> (* raise)(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>); } exceptions[] = { { .name = <span class="hljs-string"><span class="hljs-string">"0x00 - div0 error (#DE)"</span></span>, .fixup = fixup_div0_error, .raise = raise_div0_error, }, { .name = <span class="hljs-string"><span class="hljs-string">"0x06 - undefined opcode (#UD)"</span></span>, .fixup = fixup_undefined_opcode, .raise = raise_undefined_opcode, }, { .name = <span class="hljs-string"><span class="hljs-string">"0x14 - page fault (#PF)"</span></span>, .fixup = fixup_page_fault, .raise = raise_page_fault, }, };</code> </pre></div><p>Source: <a href="https://habr.com/ru/post/196952/">https://habr.com/ru/post/196952/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../196938/index.html">LG G2: outside and inside the new Korean flagship</a></li>
<li><a href="../196940/index.html">Police London City successfully fights with the largest torrent trackers</a></li>
<li><a href="../196942/index.html">MSI Slidebook S20 Ultrabook Transformer Video Review</a></li>
<li><a href="../196946/index.html">Disney developed the technology of sensing three-dimensional surfaces on smooth screens.</a></li>
<li><a href="../196948/index.html">How the emergency notification is arranged</a></li>
<li><a href="../196956/index.html">‚ÄúPVS-Studio developers, have you heard about Clang at all?‚Äù, Or a comparison of PVS-Studio and Clang without code</a></li>
<li><a href="../196958/index.html">Application Developer Days - for creative programmers</a></li>
<li><a href="../196960/index.html">Commands in MVVM</a></li>
<li><a href="../196962/index.html">iON Air Pro Wi-Fi vs GoPro HERO3: White Edition: the battle of "younger" Americans</a></li>
<li><a href="../196964/index.html">Designing a site as a consulting service</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>