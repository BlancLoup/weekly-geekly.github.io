<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Const and optimization in C</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Today , / r / C_Programming was asked about the effect of const in C on optimization. I have heard many times the variants of this question during the...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Const and optimization in C</h1><div class="post__text post__text-html js-mediator-article"><p> Today <a href="https://redd.it/4udqwj">, / r / C_Programming was asked</a> about the effect of <code>const</code> in C on optimization.  I have heard many times the variants of this question during the last twenty years.  Personally, I blame the entire naming <code>const</code> . </p><a name="habracut"></a><br><p>  Consider this program: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">10</span></span>; i++) { foo(&amp;x); y += x; <span class="hljs-comment"><span class="hljs-comment">// this load not optimized out } return y; }</span></span></code> </pre> <br><p>  The <code>foo</code> function accepts a pointer to const, which promises on behalf of <code>foo</code> that the value of <code>x</code> will not be changed.  It may seem that the compiler can assume that <code>x</code> always zero, and therefore also <code>y</code> . </p><br><p>  However, if we look at the assembler code generated by several different compilers, we will see that <code>x</code> loaded at each iteration of the loop.  This is what gcc 4.9.2 s produced with -O3, with my comments: </p><br><pre> <code class="hljs perl">bar: <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> rbp <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> rbx <span class="hljs-keyword"><span class="hljs-keyword">xor</span></span> ebp, ebp ; <span class="hljs-keyword"><span class="hljs-keyword">y</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span> mov ebx, <span class="hljs-number"><span class="hljs-number">0xa</span></span> ;    i <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rsp</span></span></span><span class="hljs-function">, 0</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">x18</span></span></span><span class="hljs-function"> </span></span>; allocate <span class="hljs-keyword"><span class="hljs-keyword">x</span></span> mov dword [rsp+<span class="hljs-number"><span class="hljs-number">0xc</span></span>], <span class="hljs-number"><span class="hljs-number">0</span></span> ; <span class="hljs-keyword"><span class="hljs-keyword">x</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span> .L<span class="hljs-number"><span class="hljs-number">0</span></span>: lea rdi, [rsp+<span class="hljs-number"><span class="hljs-number">0xc</span></span>] ;  &amp;<span class="hljs-keyword"><span class="hljs-keyword">x</span></span> call foo add ebp, dword [rsp+<span class="hljs-number"><span class="hljs-number">0xc</span></span>] ; <span class="hljs-keyword"><span class="hljs-keyword">y</span></span> += <span class="hljs-keyword"><span class="hljs-keyword">x</span></span> ( ?) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ebx</span></span></span><span class="hljs-function">, 1 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">jne</span></span></span><span class="hljs-function"> .</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">L0</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rsp</span></span></span><span class="hljs-function">, 0</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">x18</span></span></span><span class="hljs-function"> </span></span>; deallocate <span class="hljs-keyword"><span class="hljs-keyword">x</span></span> mov eax, ebp ;  <span class="hljs-keyword"><span class="hljs-keyword">y</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> rbx <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> rbp ret</code> </pre> <br><p>  clang 3.5 (with -fno-unroll-loops) gave roughly the same thing, only ebp and ebx were swapped, and the calculation of <code>&amp;x</code> removed from the loop in <code>r14</code> . </p><br><p>  Are both compilers unable to use this useful information?  Unless if <code>foo</code> changes <code>x</code> , it will not be undefined behavior?  Oddly enough, the answer is no.  <em>In this situation</em> , this will be the absolutely correct definition of <code>foo</code> . </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *readonly_x)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *x = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *)readonly_x; <span class="hljs-comment"><span class="hljs-comment">// cast away const (*x)++; }</span></span></code> </pre> <br><p>  It is important to remember that <a href="http://yarchive.net/comp/const.html"><code>const</code> does not mean constant</a> .  Take note of the fact that this is the wrong name.  This is not a tool for optimization.  It is needed to inform the programmer - and not the compiler - as a tool to help catch a certain class of errors at compile time.  I like it when it is used in the API because it tells how the function will use its arguments, or how the caller should handle the returned pointers.  Usually it is not strict enough to change the behavior of the compiler. </p><br><p>  Despite what I said, sometimes the compiler <em>can</em> use <code>const</code> for optimization.  In the C99 specification, in ¬ß6.7.3¬∂5, there is one sentence about this: </p><br><blockquote><pre> <code class="hljs objectivec">        <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>   lvalue   <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>,  .</code> </pre> <br></blockquote><br><p>  The original <code>x</code> was without a const modifier, so this rule did not apply.  And there is no rule against casting to a non- <code>const</code> type in order to change an object that is not itself a <code>const</code> .  This means that the <code>foo</code> behavior above is not an undefined behavior <em>for this call</em> .  Note that the <code>foo</code> uncertainty depends on how it was called. </p><br><p>  With one change in <code>bar</code> I can make this rule applicable, allowing the optimizer to work. </p><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br><p>  The compiler can now assume that <strong>changing <code>x</code> in <code>foo</code> is an undefined behavior, and therefore <em>never happens</em></strong> .  Anyway, basically so optimizer C talks about your programs.  The compiler can assume that <code>x</code> never changes, allowing it to optimize both loading in each iteration, and <code>y</code> . </p><br><pre> <code class="hljs perl">bar: <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> rbx mov ebx, <span class="hljs-number"><span class="hljs-number">0xa</span></span> ;   i <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rsp</span></span></span><span class="hljs-function">, 0</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">x10</span></span></span><span class="hljs-function"> </span></span>; allocate <span class="hljs-keyword"><span class="hljs-keyword">x</span></span> mov dword [rsp+<span class="hljs-number"><span class="hljs-number">0xc</span></span>], <span class="hljs-number"><span class="hljs-number">0</span></span> ; <span class="hljs-keyword"><span class="hljs-keyword">x</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span> .L<span class="hljs-number"><span class="hljs-number">0</span></span>: lea rdi, [rsp+<span class="hljs-number"><span class="hljs-number">0xc</span></span>] ;  &amp;<span class="hljs-keyword"><span class="hljs-keyword">x</span></span> call foo <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ebx</span></span></span><span class="hljs-function">, 1 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">jne</span></span></span><span class="hljs-function"> .</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">L0</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rsp</span></span></span><span class="hljs-function">, 0</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">x10</span></span></span><span class="hljs-function"> </span></span>; deallocate <span class="hljs-keyword"><span class="hljs-keyword">x</span></span> <span class="hljs-keyword"><span class="hljs-keyword">xor</span></span> eax, eax ;  <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> rbx ret</code> </pre> <br><p>  The load disappears, <code>y</code> disappears, and the function always returns zero. </p><br><p>  Curiously, the specification allows the compiler to go even further.  It can place <code>x</code> somewhere out of the stack, even in read-only memory.  For example, he can produce such a transformation: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> __x = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">10</span></span>; i++) foo(&amp;__x); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><p>  Or on x86-64 ( <a href="http://eli.thegreenplace.net/2012/01/03/understanding-the-x64-code-models">-fPIC, small memory model</a> ), where it turns out to get rid of a few more instructions: </p><br><pre> <code class="hljs perl">section .rodata <span class="hljs-keyword"><span class="hljs-keyword">x</span></span>: dd <span class="hljs-number"><span class="hljs-number">0</span></span> section .text bar: <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> rbx mov ebx, <span class="hljs-number"><span class="hljs-number">0xa</span></span> ;   i .L<span class="hljs-number"><span class="hljs-number">0</span></span>: lea rdi, [rel <span class="hljs-keyword"><span class="hljs-keyword">x</span></span>] ;  &amp;<span class="hljs-keyword"><span class="hljs-keyword">x</span></span> call foo <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ebx</span></span></span><span class="hljs-function">, 1 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">jne</span></span></span><span class="hljs-function"> .</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">L0</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">xor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">eax</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">eax</span></span></span><span class="hljs-function"> </span></span>;  <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> rbx ret</code> </pre> <br><p>  Neither clang nor gcc go so far, apparently because it is more dangerous for poorly written code. </p><br><p>  Even with a special rule on <code>const</code> rule, use <code>const</code> for yourself and your fellow programmers.  Let the optimizer decide for itself what is constant and what is not. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/307266/">https://habr.com/ru/post/307266/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../307252/index.html">Basics of computer networks. Subject number 1. Basic network terms and network models</a></li>
<li><a href="../307256/index.html">Interface calculations (and a couple of small tips, how not to screw up, choosing a product)</a></li>
<li><a href="../307258/index.html">Pro shops and introverts: a number of implicit things</a></li>
<li><a href="../307260/index.html">The most important thing about neural networks. Lecture in Yandex</a></li>
<li><a href="../307262/index.html">Cold Storage in the cloud: Amazon, Google, Microsoft are changing the cloud storage services market</a></li>
<li><a href="../307268/index.html">Super slow and super fast benchmark</a></li>
<li><a href="../307270/index.html">New technologies CRM integration in 3CX v15</a></li>
<li><a href="../307272/index.html">EA Global 2016 Effective Altruism Conference - Live Broadcast</a></li>
<li><a href="../307278/index.html">Sending and receiving SMS using Laravel and Nexmo</a></li>
<li><a href="../307280/index.html">A bit about VPN: A brief overview of software implementations</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>