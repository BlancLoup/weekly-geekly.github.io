<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How to search for patterns in stock data and use them in trading?</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Today I propose to reflect on how to look for patterns in stock data and how to use them for successful trading. 

 We will receive Forex exchange dat...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How to search for patterns in stock data and use them in trading?</h1><div class="post__text post__text-html js-mediator-article">  Today I propose to reflect on how to look for patterns in stock data and how to use them for successful trading. <br><br>  We will receive Forex exchange data from one of the brokers, save it to the PostgreSQL database and try to find patterns using machine learning algorithms. <br><br>  The article has some nice bonuses in the form of Python code - you can analyze any (almost) stock data (or indicator values) yourself, run your own trading robot and test any trading strategy. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      All the conditions and definitions of patterns in the article are for example, you can use any criteria. <br><a name="habracut"></a><br><h2>  What is a pattern and how to use it? </h2><br>  <b>A pattern</b> is a stable, repetitive pattern of consecutive stock data, after the occurrence of which the price is likely to change in the right direction. <br><br>  Analyzing statistics in order to find repetitive patterns is not an easy task, but if dependencies can be found, then the price movement can be predicted quite accurately.  Using the methods of machine learning, the search for patterns comes down to choosing the best classifier - an algorithm that learns from historical data and predicts price movement with a certain probability. <br><br>  Such a mechanism may well become part of a successful trading strategy in combination with other methods of market analysis. <br><br><h2>  Training </h2><br><ol><li>  In order to receive historical data and submit applications for Forex through the RESTv20 API, we will need a demo account from a <a href="http://oanda.com/">well-known broker</a> .  Registration takes a minute, after which you get token (a unique key for access) and account number. </li><li>  Python version 2.7 with installed libraries is required: oandapyV20, sklearn, matplotlib, numpy, psycopg2.  They can be installed via pip. <br></li><li>  PostgreSQL is required, I have version 9.6. <br></li></ol><br><h2>  Model Description </h2><br>  The very first thing to describe is the historical data itself. <br><br>  Create a class Candle, which will store information about each candle: <br><br><pre><code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Candle</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, datetime, ask, bid, volume)</span></span></span><span class="hljs-function">:</span></span> self.datetime = datetime self.ask = ask self.bid = bid self.volume = volume</code> </pre> <br>  The description of the pattern will be as follows: <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Pattern</span></span></span><span class="hljs-class">:</span></span> result = <span class="hljs-string"><span class="hljs-string">''</span></span> serie = list() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, serie, result)</span></span></span><span class="hljs-function">:</span></span> self.serie = serie self.result = result</code> </pre><br>  Each series of data will correspond to the result, in our case, the purchase or sale. <br>  Here you need to not forget that we are interested in the <b>form</b> .  This means that it is not true to describe the pattern simply by prices, their normalization is necessary.  About this below. <br><br><img align="left" src="https://habrastorage.org/files/6c2/79c/b44/6c279cb448414a7286f6c65e0467ec74.jpg">  We introduce two more parameters: <br><br><ol><li>  Series length ( <b>Length</b> ) - the number of consecutive elements in the pattern series </li><li>  Window width ( <b>window</b> size) - the number of consecutive elements after the series, for at least one of which the <i><b>condition for choosing a pattern</b></i> is <i><b>met</b></i> </li></ol><br>  <b>What are the conditions for choosing patterns</b> ?  - so as to make a profit: <br><br>  If we buy at the <b>ask</b> = X price, then we should sell at the increased <b>bid</b> &gt; X price. And vice versa, if we sell at the <b>bid</b> = Y price, then we should buy at the <b>ask</b> &lt;Y price. In this, the price change will be greater than the spread at the time of purchase and we will make a profit. <br>  <i>Today I propose to use these simple rules for selecting patterns, but in fact, in order for everything to work well, you need to add a few filters to them.</i>  <i>I suggest that you do it yourself later.</i>  Do not forget that the choice of source data (period, market, instrument, etc.) is very important - somewhere there are patterns, and somewhere there are not.  Or you need to change the conditions of their selection. <br><br><h2>  Get the data </h2><br>  We will receive data from the broker and save it in the PostgreSQL database.  First of all, let's create a class that will load data: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> pandas <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> oandapyV20.endpoints <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> instruments <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StockDataDownloader</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_data_from_finam</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, ticker, period, marketCode, insCode, dateFrom, dateTo)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""Downloads data from FINAM.ru stock service"""</span></span> addres = <span class="hljs-string"><span class="hljs-string">'http://export.finam.ru/data.txt?market='</span></span> + str(marketCode) + <span class="hljs-string"><span class="hljs-string">'&amp;em='</span></span> + str(insCode) + <span class="hljs-string"><span class="hljs-string">'&amp;code='</span></span> + ticker + <span class="hljs-string"><span class="hljs-string">'&amp;df='</span></span> + str(dateFrom.day) + <span class="hljs-string"><span class="hljs-string">'&amp;mf='</span></span> + str(dateFrom.month<span class="hljs-number"><span class="hljs-number">-1</span></span>) + <span class="hljs-string"><span class="hljs-string">'&amp;yf='</span></span> + str(dateFrom.year) + <span class="hljs-string"><span class="hljs-string">'&amp;dt='</span></span> + str(dateTo.day) + <span class="hljs-string"><span class="hljs-string">'&amp;mt='</span></span> + str(dateTo.month<span class="hljs-number"><span class="hljs-number">-1</span></span>) + <span class="hljs-string"><span class="hljs-string">'&amp;yt='</span></span> + str(dateTo.year) + <span class="hljs-string"><span class="hljs-string">'&amp;p='</span></span> + str(period + <span class="hljs-number"><span class="hljs-number">2</span></span>) + <span class="hljs-string"><span class="hljs-string">'data&amp;e=.txt&amp;cn=GAZP&amp;dtf=4&amp;tmf=4&amp;MSOR=1&amp;sep=1&amp;sep2=1&amp;datf=5&amp;at=1'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> pandas.read_csv(addres) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_data_from_oanda_fx</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, API, insName, timeFrame, dateFrom, dateTo)</span></span></span><span class="hljs-function">:</span></span> params = <span class="hljs-string"><span class="hljs-string">'granularity=%s&amp;from=%s&amp;to=%s&amp;price=BA'</span></span> % (timeFrame, dateFrom.isoformat(<span class="hljs-string"><span class="hljs-string">'T'</span></span>) + <span class="hljs-string"><span class="hljs-string">'Z'</span></span>, dateTo.isoformat(<span class="hljs-string"><span class="hljs-string">'T'</span></span>) + <span class="hljs-string"><span class="hljs-string">'Z'</span></span>) r = instruments.InstrumentsCandles(insName, params=params) API.request(r) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> r.response</code> </pre><br>  <b>Bonus:</b> I left in this class a method that loads any historical data from Finam.  This is very convenient, because you can analyze both the Forex and MICEX and FORTS markets.  The only minus is that the data can be loaded with a period of at least 1 minute, while the second method can load 5-second candles. <br><br>  Now let's make a simple script that loads data into the database: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> psycopg2 <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> StockDataDownloader <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> StockDataDownloader <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> Conf <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> DbConfig, Config <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> datetime <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> datetime, timedelta <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> oandapyV20 <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> re step = <span class="hljs-number"><span class="hljs-number">60</span></span>*<span class="hljs-number"><span class="hljs-number">360</span></span> <span class="hljs-comment"><span class="hljs-comment"># download step, s daysTotal = 150 # download period, days dbConf = DbConfig.DbConfig() conf = Config.Config() connect = psycopg2.connect(database=dbConf.dbname, user=dbConf.user, host=dbConf.address, password=dbConf.password) cursor = connect.cursor() print 'Successfully connected' cursor.execute("SELECT * FROM pg_tables WHERE schemaname='public';") tables = list() for row in cursor: tables.append(row[1]) for name in tables: cmd = "DROP TABLE " + name print cmd cursor.execute(cmd) connect.commit() tName = conf.insName.lower() cmd = ('CREATE TABLE public."{0}" (' \ 'datetimestamp TIMESTAMP WITHOUT TIME ZONE NOT NULL,' \ 'ask FLOAT NOT NULL,' \ 'bid FLOAT NOT NULL,' \ 'volume FLOAT NOT NULL,' \ 'CONSTRAINT "PK_ID" PRIMARY KEY ("datetimestamp"));' \ 'CREATE UNIQUE INDEX timestamp_idx ON {0} ("datetimestamp");').format(tName) cursor.execute(cmd) connect.commit() print 'Created table', tName downloader = StockDataDownloader.StockDataDownloader() oanda = oandapyV20.API(environment=conf.env, access_token=conf.token) def parse_date(ts): # parse date in UNIX time stamp return datetime.fromtimestamp(float(ts)) date = datetime.utcnow() - timedelta(days=daysTotal) dateStop = datetime.utcnow() candleDiff = conf.candleDiff if conf.candlePeriod == 'M': candleDiff = candleDiff * 60 if conf.candlePeriod == 'H': candleDiff = candleDiff * 3600 last_id = datetime.min while date &lt; dateStop - timedelta(seconds=step): dateFrom = date dateTo = date + timedelta(seconds=step) data = downloader.get_data_from_oanda_fx(oanda, conf.insName, '{0}{1}'.format(conf.candlePeriod, conf.candleDiff), dateFrom, dateTo) if len(data.get('candles')) &gt; 0: cmd = '' cmd = ('INSERT INTO {0} VALUES').format(tName) cmd_bulk = '' for candle in data.get('candles'): id = parse_date(candle.get('time')) volume = candle.get('volume') if volume != 0 and id!=last_id: cmd_bulk = cmd_bulk + ("(TIMESTAMP '{0}',{1},{2},{3}),\n" .format(id, candle.get('ask')['c'], candle.get('bid')['c'], volume)) last_id = id if len(cmd_bulk) &gt; 0: cmd = cmd + cmd_bulk[:-2] + ';' cursor.execute(cmd) connect.commit() print ("Saved candles from {0} to {1}".format(dateFrom, dateTo)) date = dateTo cmd = "REINDEX INDEX timestamp_idx;" print cmd cursor.execute(cmd) connect.commit() connect.close()</span></span></code> </pre><br>  If you look closely at the data from Oanda, you will see that some candles are missing.  Moreover, the smaller the period of loaded data, the greater the gaps.  This is not a mistake, but due to the fact that the price has not changed during the passes.  Therefore, there are two ways to load such data - save as is, or add missing candles with values ‚Äã‚Äãsimilar to the last candlestick from a zero-volume broker.  Both options are implemented in the <a href="https://github.com/antonkorbalev/StockDataProcessing">repository on Github</a> , the latter is commented out.  Also, if you consider it necessary to add the missing candles, there is a DbCheck.py script that checks the correct sequence of candles for this case. <br><br><h3>  Data analysis </h3><br>  Let's make a simple class that will contain methods for searching patterns and convert them into vectors for machine learning algorithms: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> psycopg2 <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> Conf <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> DbConfig, Config <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> Desc.Candle <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Candle <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> Desc.Pattern <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Pattern <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_patterns_for_window_and_num</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(window, length, limit=None)</span></span></span><span class="hljs-function">:</span></span> conf = Config.Config() dbConf = DbConfig.DbConfig() connect = psycopg2.connect(database=dbConf.dbname, user=dbConf.user, host=dbConf.address, password=dbConf.password) cursor = connect.cursor() <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">'Successfully connected'</span></span> tName = conf.insName.lower() cmd = <span class="hljs-string"><span class="hljs-string">'SELECT COUNT(*) FROM {0};'</span></span>.format(tName) cursor.execute(cmd) totalCount = cursor.fetchone()[<span class="hljs-number"><span class="hljs-number">0</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">'Total items count {0}'</span></span>.format(totalCount) cmd = <span class="hljs-string"><span class="hljs-string">'SELECT * FROM {0} ORDER BY datetimestamp'</span></span>.format(tName) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> limit <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: cmd = <span class="hljs-string"><span class="hljs-string">'{0};'</span></span>.format(cmd) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: cmd = <span class="hljs-string"><span class="hljs-string">'{0} LIMIT {1};'</span></span>.format(cmd, limit) cursor.execute(cmd) wl = list() patterns = list() profits = list() indicies = list() i = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> row <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> cursor: nextCandle = Candle(row[<span class="hljs-number"><span class="hljs-number">0</span></span>], row[<span class="hljs-number"><span class="hljs-number">1</span></span>], row[<span class="hljs-number"><span class="hljs-number">2</span></span>], row[<span class="hljs-number"><span class="hljs-number">3</span></span>]) wl.append(nextCandle) <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">'Row {0} of {1}, {2:.3f}% total'</span></span>.format(i, totalCount, <span class="hljs-number"><span class="hljs-number">100</span></span>*(float(i)/float(totalCount))) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(wl) == window+length: <span class="hljs-comment"><span class="hljs-comment"># find pattern of 0..length elements # that indicates price falls / grows # in the next window elements to get profit candle = wl[length-1] ind = length + 1 # take real data only if candle.volume != 0: while ind &lt;= window + length: iCandle = wl[ind-1] # define patterns for analyzing iCandle if iCandle.volume != 0: if iCandle.bid &gt; candle.ask: # buy pattern p = Pattern(wl[:length],'buy') patterns.append(p) indicies.append(ind - length) profits.append(iCandle.bid - candle.ask) break if iCandle.ask &lt; candle.bid: # sell pattern p = Pattern(wl[:length],'sell') patterns.append(p) indicies.append(ind - length) profits.append(candle.bid - iCandle.ask) break ind = ind + 1 wl.pop(0) i = i + 1 print 'Total patterns: {0}'.format(len(patterns)) print 'Mean index[after]: {0}'.format(numpy.mean(indicies)) print 'Mean profit: {0}'.format(numpy.mean(profits)) connect.close() return patterns def pattern_serie_to_vector(pattern): sum = 0 for candle in pattern.serie: sum = sum + float(candle.ask + candle.bid) / 2; mean = sum / len(pattern.serie) vec = [] for candle in pattern.serie: vec = numpy.hstack((vec, [ (candle.ask+candle.bid) / (2 * mean) ])) return vec def get_x_y_for_patterns(patterns, expected_result): X = [] y = [] for p in patterns: X.append(pattern_serie_to_vector(p)) if (p.result == expected_result): y.append(1) else: y.append(0) return X, y</span></span></code> </pre><br>  In the first method, the conditions for selecting patterns are described, and the latter returns vectors for algorithms.  Notice the <b>pattern_serie_to_vector</b> method, which normalizes the data.  As mentioned above, the prices may be different, and the <i><u>shape is the same</u></i> (the analogue in those analyzes is the triangle pattern, no matter what prices, the mutual arrangement of consecutive candles is important). <br><br>  And now the most interesting, let's check the result of the work of two classifiers - gradient boosting and linear regression.  We will estimate the area under the ROC curve (AUC_ROC) for cross-qualification in 5 blocks, depending on the settings of the algorithm. <br><br>  I remind you that the area under the ROC curve changes its value from 0.5 (the worst classifier) ‚Äã‚Äãto 1 (the best classifier).  Our goal is to get at least 0.8. <br><br>  We will check several classifiers and choose the best, as well as the length of the pattern and window series. <br><br>  Gradient boosting with possible search over the length of the series and the window (in a good model with an increase in the number of trees, the accuracy should increase, so you need to choose the appropriate length of the series and the window): <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># gradient boosting import numpy as np import matplotlib.pyplot as plt from sklearn.model_selection import KFold, cross_val_score from sklearn.ensemble import GradientBoostingClassifier from PatternsCollector import get_patterns_for_window_and_num, get_x_y_for_patterns import seaborn nums = [2,5,10] i = 0 wrange = [1,5,10] lrange = [5,10] values = list() legends = list() for wnd in wrange: for l in lrange: scores = [] patterns = get_patterns_for_window_and_num(wnd, l) X, y = get_x_y_for_patterns(patterns, 'buy') for n in nums: i = i+1 kf = KFold(n_splits=5, shuffle=True, random_state=100) model = GradientBoostingClassifier(n_estimators=n, random_state=100) ms = cross_val_score(model, X, y, cv=kf, scoring='roc_auc') scores.append(np.mean(ms)) print 'Calculated {0}-{1}, num={2}, {3:.3f}%'.format(wnd, l, n, 100 * i/float((len(nums)*len(wrange)*len(lrange)))) values.append(scores) legends.append('{0}-{1}'.format(wnd, l)) plt.xlabel('estimators count') plt.ylabel('accuracy') for v in values: plt.plot(nums, v) plt.legend(legends) plt.show()</span></span></code> </pre><br><img src="https://habrastorage.org/files/15b/6d8/551/15b6d85517b14f98899f448ed2faada5.png"><br><br>  Similarly, linear regression with parameter settings: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># logistic regression from sklearn.linear_model import LogisticRegression from sklearn.preprocessing import StandardScaler from PatternsCollector import get_patterns_for_window_and_num, get_x_y_for_patterns from sklearn.model_selection import KFold, cross_val_score import numpy as np import matplotlib.pyplot as plt import seaborn cr = [10.0 ** i for i in range(-3, 1)] i = 0 wrange = [1,5,10] lrange = [5, 10] values = list() legends = list() for wnd in wrange: for l in lrange: scores = [] patterns = get_patterns_for_window_and_num(wnd, l) X, y = get_x_y_for_patterns(patterns, 'buy') sc = StandardScaler() X_sc = sc.fit_transform(X) for c in cr: i = i+1 kf = KFold(n_splits=5, shuffle=True, random_state=100) model = LogisticRegression(C=c, random_state=100) ms = cross_val_score(model, X_sc, y, cv=kf, scoring='roc_auc') scores.append(np.mean(ms)) print 'Calculated {0}-{1}, C={2}, {3:.3f}%'.format(wnd, l, c, 100 * i/float((len(cr)*len(wrange)*len(lrange)))) values.append(scores) legends.append('{0}-{1}'.format(wnd, l)) plt.xlabel('C value') plt.ylabel('accuracy') for v in values: plt.plot(cr, v) plt.legend(legends) plt.show()</span></span></code> </pre><br><img src="https://habrastorage.org/files/747/2b5/0bc/7472b50bcace4bc2bcd9a4d43b732f34.png"><br><br>  As I said, the conditions are incomplete.  Therefore, we obtain an accuracy of only 0.52.  But if you complement them, then accuracy will be better.  You can try other algorithms - neural networks, random forest and many others.  One should not forget about the problem of retraining - for example, with a large number of trees in a gradient boosting. <br><br>  Check for errors in the code: if instead of real data in the database we take sin () from them, then for both classifiers AUC_ROC for cross-qualification will be 0.96. <br><br><h3>  Trading robot </h3><br>  In conclusion, I offer you the code of a trading robot that can place bids both on a demo account and on a real one.  The most important thing is that when closing deals, he builds a histogram of profits on the deal, based on information received from the broker.  That is, you can actually check how your trading strategy works. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> datetime <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> datetime <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> datetime <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> os <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> path <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> matplotlib.pyplot <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> plt <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> oandapyV20 <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> oandapyV20.endpoints.orders <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> orders <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> oandapyV20.endpoints.positions <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> positions <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> oandapyV20.contrib.requests <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> MarketOrderRequest <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> oandapyV20.contrib.requests <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> TakeProfitDetails, StopLossDetails <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> oandapyV20.endpoints.accounts <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> AccountDetails <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> oandapyV20.endpoints.pricing <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> PricingInfo <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> Conf.Config <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Config <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> seaborn config = Config() oanda = oandapyV20.API(environment=config.env, access_token = config.token) pReq = PricingInfo(config.account_id, <span class="hljs-string"><span class="hljs-string">'instruments='</span></span>+config.insName) asks = list() bids = list() long_time = datetime.now() short_time = datetime.now() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> config.write_back_log: f_back_log = open(path.relpath(config.back_log_path + <span class="hljs-string"><span class="hljs-string">'/'</span></span> + config.insName + <span class="hljs-string"><span class="hljs-string">'_'</span></span> + datetime.datetime.now().strftime(<span class="hljs-string"><span class="hljs-string">"%Y%m%d-%H%M%S"</span></span>))+<span class="hljs-string"><span class="hljs-string">'.log'</span></span>, <span class="hljs-string"><span class="hljs-string">'a'</span></span>); time = <span class="hljs-number"><span class="hljs-number">0</span></span> times = list() last_ask = <span class="hljs-number"><span class="hljs-number">0</span></span> last_bid = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> config.write_back_log: <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">'Backlog file name:'</span></span>, f_back_log.name f_back_log.write(<span class="hljs-string"><span class="hljs-string">'DateTime,Instrument,ASK,BID,Price change,Status, Spread, Result \n'</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">process_data</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ask, bid, status)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">global</span></span> last_result <span class="hljs-keyword"><span class="hljs-keyword">global</span></span> last_ask <span class="hljs-keyword"><span class="hljs-keyword">global</span></span> last_bid <span class="hljs-keyword"><span class="hljs-keyword">global</span></span> long_time <span class="hljs-keyword"><span class="hljs-keyword">global</span></span> short_time <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> status != <span class="hljs-string"><span class="hljs-string">'tradeable'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> config.insName, <span class="hljs-string"><span class="hljs-string">'is halted.'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> asks.append(ask) bids.append(bid) times.append(time) <span class="hljs-comment"><span class="hljs-comment"># --- begin strategy here --- # --- end strategy here --- if len(asks) &gt; config.maxLength: asks.pop(0) if len(bids) &gt; config.maxLength: bids.pop(0) if len(times) &gt; config.maxLength: times.pop(0) if config.write_back_log: f_back_log.write('%s,%s,%s,%s,%s,%s,%s \n' % (datetime.datetime.now(), config.insName, pReq.response.get('prices')[0].get('asks')[1].get('price'), pReq.response.get('prices')[0].get('bids')[1].get('price'), pChange, ask-bid, result)) def do_long(ask): if config.take_profit_value!=0 or config.stop_loss_value!=0: order = MarketOrderRequest(instrument=config.insName, units=config.lot_size, takeProfitOnFill=TakeProfitDetails(price=ask+config.take_profit_value).data, stopLossOnFill=StopLossDetails(price=ask-config.stop_loss_value).data) else: order = MarketOrderRequest(instrument=config.insName, units=config.lot_size) r = orders.OrderCreate(config.account_id, data=order.data) resp = oanda.request(r) print resp price = resp.get('orderFillTransaction').get('price') print time, 's: BUY price =', price return float(price) def do_short(bid): if config.take_profit_value!=0 or config.stop_loss_value!=0: order = MarketOrderRequest(instrument=config.insName, units=-config.lot_size, takeProfitOnFill=TakeProfitDetails(price=bid+config.take_profit_value).data, stopLossOnFill=StopLossDetails(price=bid-config.stop_loss_value).data) else: order = MarketOrderRequest(instrument=config.insName, units=-config.lot_size) r = orders.OrderCreate(config.account_id, data=order.data) resp = oanda.request(r) print resp price = resp.get('orderFillTransaction').get('price') print time, 's: SELL price =', price return float(price) def do_close_long(): try: r = positions.PositionClose(config.account_id, 'EUR_USD', {"longUnits": "ALL"}) resp = oanda.request(r) print resp pl = resp.get('longOrderFillTransaction').get('pl') real_profits.append(float(pl)) print time, 's: Closed. Profit = ', pl, ' price = ', resp.get('longOrderFillTransaction').get('price') except: print 'No long units to close' def do_close_short(): try: r = positions.PositionClose(config.account_id, 'EUR_USD', {"shortUnits": "ALL"}) resp = oanda.request(r) print resp pl = resp.get('shortOrderFillTransaction').get('tradesClosed')[0].get('realizedPL') real_profits.append(float(pl)) print time, 's: Closed. Profit = ', pl, ' price = ', resp.get('shortOrderFillTransaction').get('price') except: print 'No short units to close' def get_bal(): r = AccountDetails(config.account_id) return oanda.request(r).get('account').get('balance') plt.ion() plt.grid(True) do_close_long() do_close_short() real_profits = list() while True: try: oanda.request(pReq) ask = float(pReq.response.get('prices')[0].get('asks')[0].get('price')) bid = float(pReq.response.get('prices')[0].get('bids')[0].get('price')) status = pReq.response.get('prices')[0].get('status') process_data(ask, bid, status) plt.clf() plt.subplot(1,2,1) plt.plot(times, asks, color='red', label='ASK') plt.plot(times, bids, color='blue', label='BID') if last_ask!=0: plt.axhline(last_ask, linestyle=':', color='red', label='curr ASK') if last_bid!=0: plt.axhline(last_bid, linestyle=':', color='blue', label='curr BID') plt.xlabel('Time, s') plt.ylabel('Price change') plt.legend(loc='upper left') plt.subplot(1, 2, 2) plt.hist(real_profits, label='Profits') plt.legend(loc='upper left') plt.xlabel('Profits') plt.ylabel('Counts') plt.tight_layout() except Exception as e: print e plt.pause(config.period) time = time + config.period</span></span></code> </pre><br>  Full source code <a href="https://github.com/antonkorbalev/StockDataProcessing">here</a> . <br><br>  I hope that I saved time for those who are interested in algotrading.  After all, now to check your ideas you only need to change the code a bit, run the robot and get statistics on your transactions from the broker.  And you can analyze almost any stock data. <br><br>  Special thanks I want to say to the authors of the course Yandex for machine learning on Coursera.  And also Andrew Ng for the wonderful lectures on the same resource. <br><br>  UPDATE: <br>  But what happens on the gradient boosting on the glued SI futures from the final over the last year (if the criterion for choosing a pattern is a 1% price jump to the right direction): <br><img src="https://habrastorage.org/files/d74/e3f/b52/d74e3fb520824ab2841d36b2ab4457fc.png"><br>  And this is a good result.  Expectation plus. <br>  And just then Alpha Direct has released a new server API :) </div><p>Source: <a href="https://habr.com/ru/post/324244/">https://habr.com/ru/post/324244/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../324234/index.html">Security Week 11: 38 infected smartphones, FBI crying for encryption, Google again patched up Chrome</a></li>
<li><a href="../324236/index.html">MIPT launched an online course on innovative project management</a></li>
<li><a href="../324238/index.html">J-Bird, or as a bummer game sold</a></li>
<li><a href="../324240/index.html">We assemble your OpenShift Origin Cluster</a></li>
<li><a href="../324242/index.html">Replacing Oracle with PostgreSQL and the ability to work with partitioning inside a DLP system</a></li>
<li><a href="../324246/index.html">Active Directory Recycle Bin: Usage Guidelines</a></li>
<li><a href="../324250/index.html">Calling Go functions from other languages</a></li>
<li><a href="../324256/index.html">Segmental</a></li>
<li><a href="../324258/index.html">How the dislike for the code helped me to ‚Äúpump over‚Äù designer skills</a></li>
<li><a href="../324260/index.html">Creating Web Applications with Scala.js and React - Part 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>