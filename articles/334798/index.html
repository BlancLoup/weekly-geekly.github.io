<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>1C and ETL</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="ETL and 1C. Data retrieval 
 First look 
 If you, as an ETL specialist, are faced with the need to obtain data from 1C, then this is the first thing y...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>1C and ETL</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/web/63e/12c/ad4/63e12cad448a4623bf4c962e46ef1983.png"></div><br><h1>  ETL and 1C.  Data retrieval </h1><br><h3>  First look </h3><br>  If you, as an ETL specialist, are faced with the need to obtain data from 1C, then this is the first thing you can see when trying to figure out the structure of the database (this is from the MSSQL case, the picture is similar for other DBMS): <br><br><img src="https://habrastorage.org/web/103/d69/4e7/103d694e718f43d9b102e73854621d56.png"><br><br>  Business meaning in the names of tables and fields is missing, there are no foreign keys. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      A couple of affectionate about 1C itself.  Real DBMS tables in it are hidden behind objects that the developer sees, who often do not know about the real structure of the database.  Yes ... And all the code is in Russian.  In addition, there are enumerations, the string representations of which using SQL are almost impossible to obtain.  <a href="https://habrahabr.ru/post/220863/">More on</a> this <a href="https://habrahabr.ru/post/220863/">here</a> . <br><br>  <i>There are cases when there is no database (and 1C in the file version), but this, of course, orients you towards integration without using the means of the DBMS.</i> <br><a name="habracut"></a><br>  However, do not despair, because everything is not as bad as it seems. <br><br><h3>  Attentive look </h3><br>  To capture data from 1C, you have 2 ways: <br><br><h4>  The implementation of the "high-level" interface </h4><br>  You can use file uploads, web / json services and other 1C capabilities that will be compatible with your ETL. <br><br>  + <br><ol><li>  You do not have to climb in 1C.  Everything that 1C should do on the side of 1C </li><li>  You do not violate the licensing policy of 1C </li></ol><br>  - <ol><li>  There is another source for errors in the form of additional uploads, downloads, <br>  schedules, robotization </li><li>  This will work significantly slower due to the peculiarities of 1C interfaces. </li><li>  With any changes in the captured data, you will have to make changes to the upload (but this can be bypassed by the tuning system) </li><li>  This will cause more errors in data integrity than working directly with the DBMS. </li></ol><br><h4>  Implementation on the DBMS </h4><br>  + <br><ol><li>  Faster </li><li>  Allows you to guarantee the completeness of data in the repository with the right approach </li></ol><br>  - <ol><li>  Violates the license agreement with 1C </li></ol><br>  So, after weighing the pros and cons, you decide to build integration through a DBMS, or at least <br>  think about how you will do this further. <br><br><h3>  Data mapping </h3><br>  In order to link business data, as they are understood on the 1C side with real database tables, you need to do some magic in 1C itself, namely, to get a description of 1C metadata in a usable form (in connection of business objects and tables). <br>  Again, there are at least 3 approaches: <br><br><ol><li>  Using the com-connection, web / json service to get the correspondence table from 1 </li><li>  Do the same on the 1C side by forming a metadata table </li><li>  Parse a binary file that is stored in the same database </li></ol><br>  The third way seems to me somewhat risky due to the fact that 1C has a habit of making changes to its insides without warning.  And, at the same time, quite complicated. <br>  The choice between 1 and 2 is not so obvious, but for my taste it is much more convenient to use a pre-formed table, and more reliable in daily use, and there is no need to use something other than pure SQL. <br><br>  It is more convenient to keep and maintain the relevance of the table using 1C, updating after each configuration update.  At the same time, ETL can use View, which will show the data already in a more digestible form. <br><br><h4>  Preparing a metadata table </h4><br>  Create an object in 1C that contains configuration metadata (unfortunately, the script does not do this, but you can give the 1C instruction to a nickname) <br><br>  Register of Information. Structure Configurations <br>  Fields: <br>  NameTableStorage <br>  NameTable <br>  Synonym Tables <br>  Purpose <br>  FieldName <br>  SynonymPole <br><br>  All lines 150 characters <br><br><img src="https://habrastorage.org/web/3e0/fb6/23d/3e0fb623d88c482182e6bbc88497135d.png"><br><br>  It turns out to be denormalized, but quite comfortable and simple. <br><br>  Code 1C to fill the structure: <br><br><pre><code class="1c hljs"> = <span class="hljs-built_in"><span class="hljs-built_in"></span></span>(,<span class="hljs-literal"><span class="hljs-literal"></span></span>);  = <span class="hljs-built_in"><span class="hljs-built_in"></span></span>..(); <span class="hljs-keyword"><span class="hljs-keyword"></span></span> <span class="hljs-keyword"><span class="hljs-keyword"></span></span>  <span class="hljs-keyword"><span class="hljs-keyword"></span></span>  <span class="hljs-keyword"><span class="hljs-keyword"></span></span> <span class="hljs-keyword"><span class="hljs-keyword"></span></span> <span class="hljs-keyword"><span class="hljs-keyword"></span></span>  <span class="hljs-keyword"><span class="hljs-keyword"></span></span> . <span class="hljs-keyword"><span class="hljs-keyword"></span></span>  = .(); . = .; . = .; . = <span class="hljs-built_in"><span class="hljs-built_in"></span></span>.(.<span class="hljs-built_in"><span class="hljs-built_in"></span></span>); . = .; . = .; . = <span class="hljs-built_in"><span class="hljs-built_in"></span></span>.(.<span class="hljs-built_in"><span class="hljs-built_in"></span></span>); <span class="hljs-keyword"><span class="hljs-keyword"></span></span>; <span class="hljs-keyword"><span class="hljs-keyword"></span></span>; .(<span class="hljs-literal"><span class="hljs-literal"></span></span>);</code> </pre> <br>  Again, everything is quite simple and obvious, despite the Russian language.  You need to run this code every time you update the configuration.  This can be done by hand in processing or with the help of a routine task. <br><br>  The table can be viewed both in client mode and from SQL, knowing their names. <br><br><pre> <code class="hljs pgsql"> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> _InfoReg27083 <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> _Fld27085</code> </pre> <br>  (_InfoReg27083 - the name that 1C gave the register table with the structure, _Fld27085 - the name of the field with the name of the storage table) <br><br>  You can make the View more convenient. <br><br>  If there is no possibility to make changes to the configuration, you can make a table by connecting via com, or adding unloading into the table of the database that is involved in ETL in processing. <br><br>  <a href="https://its.1c.ru/db/pubapplied">And here about what types of tables are, and why they are needed (need access to ITS 1C)</a> . <br><br>  The next step is to create a data map and description of the transformation. <br><br><table><tbody><tr><th>  Field </th><th>  Field1c </th><th>  Transformation </th><th>  ... </th></tr><tr><th>  _Fld15704 </th><th>  Document. Realization of Goods Services. Weight </th><th>  Check&gt; = 0, round (10,2), ... </th><th>  ... </th></tr></tbody></table><br>  Here we have a mapping table that can be used in further work. <br><br><h3>  Capture data changes </h3><br>  Now in terms of a strategy for capturing data changes.  Here again there are several options.  It is easier to take the tables entirely, which of course can cost the server significant additional costs. <br><br>  However, there are other ways: <br><br><ol><li>  Use object versions </li><li>  Use exchange plan </li></ol><br><h4>  Use object versions </h4><br>  For objects of "reference" type 1C supports version.  The version number of the object is written to the <b>_version</b> binary field, which is updated neatly with each record update.  In MSSQL, for example, this is a timestamp type field.  Versions are supported for objects of the following types: ‚ÄúDocument‚Äù, ‚ÄúReference book‚Äù, ‚ÄúBusiness process‚Äù, ‚ÄúTask‚Äù, ‚ÄúChart of accounts‚Äù, ‚ÄúPlan of types of characteristics‚Äù, ‚ÄúConstants‚Äù.  It is quite simple to use the version, having saved the value of the latest version for the object in the staging area, and on the next update, select objects larger than the version field.  Together with the ‚Äúmain‚Äù object, you need to remember to pick up its tabular parts (see Purpose - ‚ÄúTabular Part‚Äù) in the structure (field type _DocumentXXX_IDRRef or _ReferenceXXX_IDRRef - link to the main table). <br><br><h4>  Use exchange plan </h4><br>  For non-reference types, this approach is not suitable, but you can use the ‚Äúexchange plan‚Äù object.  In the structure table, their purpose = 'Registration of Changes'.  A separate exchange plan table is created for each configuration object. <br><br>  At the database level, this is a table, such a structure: <br><br>  _NodeTRef, - the type identifier of the ‚Äúnode‚Äù of the exchange plan.  It is not very interesting to us. <br>  _NodeRRef, - exchange plan node identifier <br>  _MessageNo, - message number <br><br>  Next come the key fields of the ‚Äúmain‚Äù table.  They differ depending on the type of table with which the exchange plan table is associated: <br><br>  _IDRRef - in this case, the ID of the directory or document <br>  maybe so here: <br>  _RecorderTRef <br>  _RecorderRRef <br><br>  This will be a table of changes in the accumulation register, information register, subordinate to the registrar, or the accounting register.  There can also be a key of the information register table if it is not subordinate to the registrar. <br><br>  In order for such a table of change registration to exist, you need to include in the 1C configurator the object we need in the exchange plan.  In addition, you need to be created node exchange plan, identifier (_IDRRef) which we will need to use. <br><br>  The exchange plan table can be found in the structure (see above).  Since  in terms of the exchange, changes are recorded for all nodes, and not just for the storage, we need to limit the selection to the <b>_NodeRRef</b> we <b>need</b> .  The exchange plan can also be used for reference objects, but in my opinion it is a meaningless waste of resources. <br><br>  How to collect data through the exchange plan: <br><br>  To begin with, we write an update to the exchange plan, where we put an arbitrary _MessageNO (always better 1). <br><br>  for example <br><br> <code>UPDATE _DocumentChangeRec18901 set _MessageNO = 1 WHERE _NodeRRef = @_NodeRRef</code> <br> <br>  Next, select data from the data table, linking it with the key to the exchange plan table <br><br> <code>SELECT [fieldslist] FROM _Document18891 inner join _DocumentChangeRec18901 ON _Document18891._IDRRef = _DocumentChangeRec18901._IDRRef and _MessageNO = 1 AND _NodeRRef = @_NodeRRef</code> <br> <br>  And confirm the selection of changes by deleting the change table entries. <br><br> <code>DELETE FROM _DocumentChangeRec18901 WHERE _MessageNO = 1 AND _NodeRRef = @_NodeRRef</code> <br> <br>  Total: We learned to read on the side of ETL 1C metadata, learned to perform data capture.  The remaining steps of the ETL process are well known.  For example, you can <a href="https://habrahabr.ru/post/248231/">read here</a> . </div><p>Source: <a href="https://habr.com/ru/post/334798/">https://habr.com/ru/post/334798/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../334788/index.html">Offshore and foreign trade transactions: advantages and pitfalls</a></li>
<li><a href="../334790/index.html">As I made the fastest resize of images. Part 3, fixed-point numbers</a></li>
<li><a href="../334792/index.html">Microsoft did not isolate Windows Defender in the sandbox, so I did</a></li>
<li><a href="../334794/index.html">Bluetooth mesh - network architecture and security</a></li>
<li><a href="../334796/index.html">How Android works, part 1</a></li>
<li><a href="../334800/index.html">DataGrip 2017.2: Supports Redshift and Azure, several databases in PostgreSQL, transaction control and more</a></li>
<li><a href="../334802/index.html">Music licensing for indie developers</a></li>
<li><a href="../334804/index.html">Finding the best place in the world for a windmill</a></li>
<li><a href="../334806/index.html">New V8 and Node.js speed: optimization techniques today and tomorrow</a></li>
<li><a href="../334810/index.html">Self-orginizing map on TensorFlow</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>