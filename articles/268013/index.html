<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Troika Hoare</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I have been using the Hoare logic for more than 15 years in programming and find this approach very useful and I want to share my experience. Naturall...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Troika Hoare</h1><div class="post__text post__text-html js-mediator-article">  I have been using the <a href="http://ru.wikipedia.org/wiki/%25D0%259B%25D0%25BE%25D0%25B3%25D0%25B8%25D0%25BA%25D0%25B0_%25D0%25A5%25D0%25BE%25D0%25B0%25D1%2580%25D0%25B0">Hoare logic for</a> more than 15 years in programming and find this approach very useful and I want to share my experience.  Naturally, it is not necessary to ‚Äúshoot a gun at the sparrows‚Äù, but when writing fairly complex algorithms or nontrivial pieces of code, applying Hoare‚Äôs logic will save you time and allow you to add elements of some ‚Äúindustrial‚Äù standard during programming. <br><a name="habracut"></a><br>  Hoar's logic contains a set of axioms for the basic constructions of an imperative programming language: empty operator, assignment operator, compound operator, branch operator, and cycle.  There are many formulas in them and so that they do not cause rejection, I will first ask a small puzzle. <br><br><h4>  Binary exponentiation algorithm </h4><br>  Consider the recursive version.  We assume that the problem has a solution if <b>a</b> , <b>n</b> are not equal to zero at the same time and <b>n&gt; = 0</b> . <br>  I don‚Äôt like pseudo-code (I‚Äôll probably write a separate topic why), so I‚Äôll give an example of a <b>Python</b> solution: <br><br><pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">power</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a, n)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> n &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> (a != <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> n != <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> n == <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: a2 = power(a, n/<span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> n &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a*a2*a2 <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a2*a2</code> </pre> <br>  And in <b>C / C ++</b> : 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">power</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ assert(n &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> || (a != <span class="hljs-number"><span class="hljs-number">0</span></span> || n != <span class="hljs-number"><span class="hljs-number">0</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a2 = power(a, n/<span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a*a2*a2; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a2*a2; } }</code> </pre><br>  Now try writing a non-recursive version.  In case of luck, try to explain to someone how it works. <br><br>  The main idea of ‚Äã‚ÄãHoare is to give for each construction an imperative language <b>pre</b> and a <b>post</b> condition written in the form of a logical formula.  Therefore, there is a <b>triple</b> in the name - a <b>precondition</b> , a language construction, a <b>post</b> - <b>condition</b> . <br><br><ul><li>  It is clear that for an empty operator, the <b>pre</b> and <b>postconditions</b> coincide. </li><li>  For an assignment operator in a <b>postcondition,</b> in addition to the <b>precondition</b> , the fact that the value of the variable has <b>changed is</b> taken into account. </li><li>  For a compound operator (in <b>Python,</b> this is indentation, in <b>C,</b> this is <i>{}</i> ) we have a chain of <b>pre</b> and <b>postconditions</b> .  As a result, for a compound operator one can leave the first <b>precondition</b> and the last <b>postcondition</b> . </li><li>  The output rule says that we can strengthen the <b>pre</b> and weaken the <b>post-condition</b> if we need it.  It makes no sense to drag through the whole program some kind of statement that does not help to solve the problem. </li><li>  A branch statement or just an <b>if</b> .  It can be divided into two branches <b>then</b> and <b>else</b> .  If we add to the <b>precondition the</b> truth of the logical condition (what is under the <b>if</b> ), then after the execution of the <b>then</b> branch, the <b>postcondition</b> must follow.  Similarly, if the negation of the logical condition is added to the <b>precondition</b> (what is under the <b>if</b> ), then after the execution of the <b>else</b> branch the <b>postcondition</b> must follow </li><li>  Loop operator  This is the most nontrivial and difficult, since the cycle can be executed many times and does not even end.  To solve the problem of possibly repeated repetition of the loop body, a loop <b>invariant</b> is introduced.  <b>The loop invariant</b> is what is true before its execution, true after each execution of the body of the cycle, and therefore true after its completion.  <b>The precondition</b> for a cycle operator is simply its <b>cycle invariant</b> .  If the condition of continuation of the cycle is true (that which is under the <b>while</b> ), then after the execution of the loop body, the truth of <b>the loop invariant</b> should follow.  As a result, after the end of the cycle, we have as a <b>postcondition the</b> truth of <b>the cycle invariant</b> and the negation of the condition for the continuation of the cycle. </li><li>  Cycle operator with full correctness.  To this end, a limiting function is added to the preceding paragraph, with which it is easy to prove that the cycle will be executed a limited number of times.  Conditions are imposed on it that it is always&gt; = 0, it strictly decreases after each execution of the loop body and exactly = 0 when the loop ends. </li></ul><br>  A properly working program can be written in many ways, and it will also be effective in a large number of cases.  This arbitrariness and precisely it complicates programming.  For this style is introduced.  But this is not enough.  For many programs (for example, related indirectly to human life), it is necessary to prove their correctness.  It turned out that the proof of correctness makes the program more expensive by an order of magnitude (about 10 times). <br><br>  Hoare actually suggested: <br><blockquote>  Let's use arbitrariness when writing programs and write them so that it is easier to prove their correctness.  As a result, the program is easier to write, and the proof of correctness is immediately obtained. <br></blockquote>  These are my words. <br><br>  About the proof of the correctness of the algorithm.  There is a set of tools in mathematics that allows one to prove theorems.  I will call well-known: the method of mathematical induction, by contradiction.  So, Hoar's logic is a tool for proving the correctness of programs (more correctly partial correctness, but these are nuances), which in principle can be used to prove the correctness of the algorithm if it is written in the basic constructions of imperative programming for which there are Troika Hoare. <br><br><div class="spoiler">  <b class="spoiler_title">Full version</b> <div class="spoiler_text">  I included the <b>pre</b> and <b>post conditions</b> in the comments.  Before a cycle, I define it through <b>:</b> cycle <i>invariant</i> and <i>bounding function,</i> and then I simply refer to them.  <b>Python</b> : <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># -*- coding: utf-8 -*- #      def power(a, n): """  a   n """ assert n &gt; 0 or (a != 0 or n != 0) r, a0, n0 = 1, a, n # r == 1 and a0 == a and n0 == n and n &gt;= 0 # _: a0**n0 == r*a**n # _(n): n while n &gt; 0: # n &gt; 0 and # _(n) &gt; 0 and # _ if n &amp; 1: r *= a #(n -  and a0**n0*a == r*a**n) or # _ n &gt;&gt;= 1 # _(n) &gt; _(n/2) and # a0**n0 == r*a**(2*n) a *= a # _ # n == 0 and # _ and # _(n) == 0 # a0**n0 == r return r if __name__ == '__main__': for i in range(14): print "2**%d" % i ,"=", power(2, i) print "2**%d" % i ,"=", power(-2, i)</span></span></code> </pre><br>  <b>C / C ++</b> : <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;cassert&gt; #include &lt;cstdlib&gt; #include &lt;iostream&gt; //      int power(int a, int n) { //  a   n assert(n &gt; 0 || (a != 0 || n != 0)); int r = 1, a0 = a, n0 = n; /* r == 1 and a0 == a and n0 == n and n &gt;= 0 _: a0**n0 == r*a**n _(n): n */ while(n &gt; 0) { /* n &gt; 0 and _(n) &gt; 0 and _ */ if (n &amp; 1) r *= a; /* (n -  and a0**n0*a == r*a**n) or _ */ n &gt;&gt;= 1; /* _(n) &gt; _(n/2) and a0**n0 == r*a**(2*n) */ a *= a; // _ } /* n == 0 and _ and _(n) == 0 */ // a0**n0 == r return r; } int main(int argc, char *argv[]) { for(int i=0; i &lt; 14; i++) { std::cout &lt;&lt; "2**" &lt;&lt; i &lt;&lt; " = " &lt;&lt; power(2, i) &lt;&lt; std::endl; std::cout &lt;&lt; "(-2)**" &lt;&lt; i &lt;&lt; " = " &lt;&lt; power(-2, i) &lt;&lt; std::endl; } return EXIT_SUCCESS; }</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Reasonable version</b> <div class="spoiler_text">  It is clear that it does not make sense to write in such detail with ordinary programming.  Too cumbersome, the code is cluttered with comments and becomes almost unreadable.  All these logical reasoning should be carried out in my head, leaving the most non-trivial in the form of comments.  Then it will always be possible, when returning to the code, to quickly restore all the reasoning and most importantly.  Another programmer who owns this approach, in the same way, reasoning and examining your code with the most important comments left, will be able to restore your reasoning and, for example, find an error in them or change the code for a new problem statement.  And these are elements of an industrial approach. <br><br>  The most important and non-trivial in the example with binary exponentiation was the cycle invariant.  I would write as follows. <br><br>  <b>Python</b> : <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># -*- coding: utf-8 -*- #      def power(a, n): """  a   n """ assert n &gt; 0 or (a != 0 or n != 0) r = 1 # _: a0**n0 == r*a**n while n &gt; 0: if n &amp; 1: r *= a n &gt;&gt;= 1 a *= a return r if __name__ == '__main__': for i in range(14): print "2**%d" % i ,"=", power(2, i) print "2**%d" % i ,"=", power(-2, i)</span></span></code> </pre><br>  <b>C / C ++</b> : <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;cassert&gt; #include &lt;cstdlib&gt; #include &lt;iostream&gt; //      int power(int a, int n) { //  a   n assert(n &gt; 0 || (a != 0 || n != 0)); int r = 1; // _: a0**n0 == r*a**n while(n &gt; 0) { if (n &amp; 1) r *= a; n &gt;&gt;= 1; a *= a; } return r; } int main(int argc, char *argv[]) { for(int i=0; i &lt; 14; i++) { std::cout &lt;&lt; "2**" &lt;&lt; i &lt;&lt; " = " &lt;&lt; power(2, i) &lt;&lt; std::endl; std::cout &lt;&lt; "(-2)**" &lt;&lt; i &lt;&lt; " = " &lt;&lt; power(-2, i) &lt;&lt; std::endl; } return EXIT_SUCCESS; }</span></span></span></span></code> </pre><br>  <b>a0, n0</b> are initial values.  Inside the cycle body <b>r, a, n</b> are changed in such a way that after the cycle body is executed, the relation (cycle invariant) <b>a0 ** n0 == r * a ** n is</b> true.  At the end of the cycle, <b>a0 ** n0 == r * a ** n is</b> true and <b>n == 0</b> means <b>a0 ** n0 == r</b> and <b>r</b> contains the answer. <br><br>  Writing statements in the comments is certainly a matter of agreement, but I see no reason to write somewhere else.  It is better to write a statement in the comments directly in the code to which they are directly related and sometimes, if possible, it is better to replace them with assertions. <br></div></div><br><h4>  Binary search </h4><br>  Try yourself when solving a very similar binary search problem.  Here <b>a</b> is a linearly ordered array, <b>v</b> is the element number we are looking for, <b>l</b> is the lower bound with which we are looking for (it comes in), <b>r</b> is the upper limit up to which we are looking for (it is not included).  For simplicity, we assume that the first call to <b>bSearch</b> does not go beyond the bounds of array <b>a</b> .  Returns -1 if the search could not be found, or the number of the element found&gt; = 0. <br><br><div class="spoiler">  <b class="spoiler_title">Python</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bSearch</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a, v, l, r)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> l &gt;= r: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: m = (l + r)/<span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> l &lt;= m &lt; r <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> v &gt; a[m]: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bSearch(a, v, m + <span class="hljs-number"><span class="hljs-number">1</span></span>, r) <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> v &lt; a[m]: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bSearch(a, v, l, m) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> v == a[m] <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m</code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">C / C ++</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bSearch</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> l, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> r)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (l &gt;= r) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m=(l + r)/<span class="hljs-number"><span class="hljs-number">2</span></span>; assert(l &lt;= m &amp;&amp; m &lt; r); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (v &gt; a[m]) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bSearch(a, v, m + <span class="hljs-number"><span class="hljs-number">1</span></span>, r); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (v &lt; a[m]) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bSearch(a, v, l, m); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { assert(v == a[m]); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m; } } }</code> </pre><br></div></div><br>  Write a non-recursive version with Hoare triples. <br><br>  Consider a more complex case with nested loops on the example of different sorting algorithms. <br><br><h4>  Pyramidal sorting </h4><br>  The pyramid sorting algorithm for an <b>array</b> of <b>n-</b> elements <b>array</b> consists of two main steps: <br><br><ol><li>  We build array elements in the form of a sorting tree: <br>  <b>‚àÄ i, 0 ‚â§ i ‚àß (2i + 1) &lt;n ‚àß array [i] ‚â• array [2i + 1],</b> <b><br></b>  <b>‚àÄ i, 0 ‚â§ i ‚àß (2i + 2) &lt;n ‚àß array [i] ‚â• array [2i + 2]</b> . </li><li>  We will remove elements from the root one at a time and rebuild the tree.  Those.  in the first step, exchange <b>array [0]</b> and <b>array [n-1]</b> and convert <b>array [0], ..., array [n-2]</b> into the sorting tree.  Then we rearrange <b>array [0]</b> and <b>array [n-2]</b> and transform <b>array [0], ..., array [n-3]</b> into the sorting tree.  The process continues until one item remains in the sorting tree.  Then <b>array [0], ..., array [n-1]</b> is an ordered sequence. </li></ol><br>  This is the original article of the author of the algorithm. <br>  JWJ Williams.  Algorithm 232 ‚Äî Heapsort, 1964, Communications of the ACM 7 (6): 347‚Äì348. <br>  This <a href="http://ru.wikipedia.org/wiki/%25D0%259F%25D0%25B8%25D1%2580%25D0%25B0%25D0%25BC%25D0%25B8%25D0%25B4%25D0%25B0%25D0%25BB%25D1%258C%25D0%25BD%25D0%25B0%25D1%258F_%25D1%2581%25D0%25BE%25D1%2580%25D1%2582%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25BA%25D0%25B0">wiki</a> description <br><br><div class="spoiler">  <b class="spoiler_title">Python</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># -*- coding: utf-8 -*- # C a    def heapsort(a): """ C a     """ k, n = 1, len(a) # k == 1 and # _1: a[(i - 1)/2] &gt;= a[i]  i=1..k # _1(k, n): n - k while k &lt; n: # k &lt; n # and _1 # and _1(k, n) &gt; 0 leaf = k k += 1 # k &lt;= n # and _1  i == leaf # and _1(k, n) &gt; _1(k+1, n) # _2: _1  i == leaf # _2(leaf): (_1  0)  leaf-1 while leaf &gt; 0: # leaf &gt; 0 # and _2 # and _2(leaf) &gt; 0 root = (leaf - 1)/2 if a[root] &gt;= a[leaf]: # _2 # and _1 # and _(child) == 0 break else: a[root], a[leaf] = a[leaf], a[root] leaf = root # _2(leaf) &gt; _2((leaf - 1)/2) # and _2 # _2 # and _2(child) == 0 # _1 # k == n # and _1 # and _1(k, n) == 0 # _3: a[(i - 1)/2] &gt;= a[i]  i=1..k # and a[j-1] &lt;= a[j]  j=k..n # and a[m] &lt;= a[l]  m=0..k, l=k..n # _3(k): k - 1 while k &gt; 0: # k &gt; 0 # and _3 # and _3(k) &gt; 0 # and a[0] &gt;= a[i]  i=0..k k -= 1 a[k], a[0] = a[0], a[k] # _3  i=0 # and _3(k) &gt; _3(k-1) root = 0 # _4: _3  i=root # _4(root, k): (_3  0)  (k-(2*root+1)) while 2*root + 1 &lt; k: # 2*root + 1 &lt; k # and _4 # and _4(root, k) &gt; 0 leaf = 2*root + 1 # _4 # and leaf == 2*root + 1 if (leaf + 1) &lt; k and a[leaf] &lt; a[leaf + 1]: leaf += 1 # _4 # and (2*((leaf-1)/2)+2 == k # or a[leaf] == max(a[2*((leaf-1)/2)+1], a[2*((leaf-1)/2)+2])) if a[root] &gt;= a[leaf]: # _4 # and _3 # and _4(root, k) == 0 break else: a[root], a[leaf] = a[leaf], a[root] root = leaf # _4 # and _4(root, k) &gt; _4(2*root + 1, k) # _4 # and _4(root, k) == 0 # _3 # k == 0 # and _3 # and _3(k) == 0 # a[j-1] &lt;= a[j]  j=0..n if __name__ == '__main__': import random a = map(lambda x: random.randint(-100, 100), range(20)) print a heapsort(a) print a</span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">C / C ++</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;cassert&gt; #include &lt;cstdlib&gt; #include &lt;ctime&gt; #include &lt;iostream&gt; // C a    void sortHeap(int *a, int n) { // C a     assert(n &gt;= 0); int k = 1; /* k == 1 and _1: a[(i - 1)/2] &gt;= a[i]  i=1..k _1(k, n): n - k */ while(k &lt; n) { /* k &lt; n and _1 and _1(k, n) &gt; 0 */ int leaf = k; ++k; /* k &lt;= n and _1  i == leaf and _1(k, n) &gt; _1(k+1, n) */ /* _2: _1  i == leaf _2(leaf): (_1  0)  leaf-1 */ while(leaf &gt; 0) { /* leaf &gt; 0 and _2 and _2(leaf) &gt; 0 */ int root = (leaf - 1)/2; if (a[root] &gt;= a[leaf]) /* _2 and _1 and _(child) == 0 */ break; else { int tmp = a[root]; a[root] = a[leaf]; a[leaf] = tmp; leaf = root; /* _2(leaf) &gt; _2((leaf - 1)/2) and _2*/ } /* _2 and _2(child) == 0 */ } // _1 } /* k == n and _1 and _1(k, n) == 0 */ /* _3: a[(i - 1)/2] &gt;= a[i]  i=1..k and a[j-1] &lt;= a[j]  j=k..n and a[m] &lt;= a[l]  m=0..k, l=k..n _3(k): k - 1 */ while(k &gt; 0) { /* k &gt; 0 and _3 and _3(k) &gt; 0 and a[0] &gt;= a[i]  i=0..k */ --k; int tmp = a[k]; a[k] = a[0]; a[0] = tmp; /* _3  i=0 and _3(k) &gt; _3(k-1) */ int root = 0; /* _4: _3  i=root _4(root, k): (_3  0)  (k-(2*root+1)) */ while(2*root + 1 &lt; k) { /* 2*root + 1 &lt; k and _4 and _4(root, k) &gt; 0 */ int leaf = 2*root + 1; /* _4 and leaf == 2*root + 1 */ if ((leaf + 1) &lt; k and a[leaf] &lt; a[leaf + 1]) leaf += 1; /* _4 and (2*((leaf-1)/2)+2 == k or a[leaf] == max(a[2*((leaf-1)/2)+1], a[2*((leaf-1)/2)+2])) */ if (a[root] &gt;= a[leaf]) /* _4 and _3 and _4(root, k) == 0 */ break; else { int tmp = a[root]; a[root] = a[leaf]; a[leaf] = tmp; root = leaf; /* _4 and _4(root, k) &gt; _4(2*root + 1, k) */ } /* _4 and _4(root, k) == 0 */ } // _3 } /* k == 0 and _3 and _3(k) == 0 */ // a[j-1] &lt;= a[j]  j=0..n } int main(int argc, char *argv[]) { srand((unsigned)time(NULL)); const int n = 20; int a[n]; for(int i=0; i &lt; 20; i++) a[i] = rand()/(RAND_MAX/200) - 100; for(int i=0; i &lt; 20; i++) std::cout &lt;&lt; a[i] &lt;&lt; ' '; std::cout &lt;&lt; std::endl; sortHeap(a, n); for(int i=0; i &lt; 20; i++) std::cout &lt;&lt; a[i] &lt;&lt; ' '; std::cout &lt;&lt; std::endl; return EXIT_SUCCESS; }</span></span></span></span></code> </pre><br></div></div><br><h4>  At last </h4><br>  Try yourself when solving a very similar <a href="http://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25BE%25D1%2580%25D1%2582%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25BA%25D0%25B0_%25D0%25A8%25D0%25B5%25D0%25BB%25D0%25BB%25D0%25B0">Shell sorting</a> problem. <br><br>  An <b>array is given</b> of <b>n</b> elements.  The array is divided into subarrays with a step <b>k0</b> <br>  <b>{a [0], a [k0], a [2k0], ...}, {a [1], a [1 + k0], a [1 + 2k0], ...}, ..., {a [k0-1 ], a [2k0-1], a [3k0-1], ...}</b> <br>  and if the neighboring elements in the subarray violate the order, then they change places.  Then the procedure is repeated with step <b>k1</b> , etc. <br>  The last step should be equal to <b>1</b> . <br><br>  As steps you can take, for example, the following sequence <br>  <b>steps [16] = [1391376, 463792, 198768, 86961, 33936, 13776, 4592, 1968, 861, 336, 112, 48, 21, 7, 3, 1].</b> <br><br>  This is the original article of the author of the algorithm. <br>  Donald Lewis Shell, A High-Speed ‚Äã‚ÄãSorting Procedure, CACM, 2 (7): 30-32, July 1959. <br><br><h4>  Literature </h4><br>  This is the main book in Russian <br>  O.-J.  Dahl, EW Dijkstra and CAR Hoare, Structured Programming.  Academic Press, 1972. ISBN 0-12-200550-3.  Translation: Dal U., Dijkstra E., Hoor K., Structured programming.  M .: Mir, 1975. <br><br>  This is the original article. <br>  CAR Hoare.  " <a href="http://sunnyday.mit.edu/16.355/Hoare-CACM-69.pdf">An axiomatic basis for computer programming</a> ".  Communications of the ACM, 12 (10): 576‚Äì580,583 October 1969. DOI: 10.1145 / 363235.363259 <br><br>  S.A.  Abramov  Elements of programming.  - M .: Science, 1982. P. 85-94. <br><br>  Wikipedia <a href="http://ru.wikipedia.org/wiki/%25D0%259B%25D0%25BE%25D0%25B3%25D0%25B8%25D0%25BA%25D0%25B0_%25D0%25A5%25D0%25BE%25D0%25B0%25D1%2580%25D0%25B0">Logic Hoare</a> . <br><br>  From <a href="http://bourabai.ru/library/texnologia_progr-nia.pdf">lectures</a> VMiK MSU on "Programming Technologies". </div><p>Source: <a href="https://habr.com/ru/post/268013/">https://habr.com/ru/post/268013/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../268003/index.html">Elasticweb is the most democratic shared hosting</a></li>
<li><a href="../268005/index.html">Sonic Pi music programming language, All-Russian programming contest and volunteer meeting this Friday</a></li>
<li><a href="../268007/index.html">Linux botnet organizes DDoS attacks with 150 Gbps traffic and higher</a></li>
<li><a href="../268009/index.html">We teach employees English: the experience of Edison</a></li>
<li><a href="../268011/index.html">PyNSK # 3 - the third meeting of the Novosibirsk Python community</a></li>
<li><a href="../268015/index.html">Scalable JSON serialization / deserialization library</a></li>
<li><a href="../268017/index.html">Porting a C # / XAML Windows 8.1 application to UWP</a></li>
<li><a href="../268019/index.html">Network for the smallest. Micro issue ‚Ññ5. Networking FAQ</a></li>
<li><a href="../268021/index.html">Microsoft scared users of Windows 7</a></li>
<li><a href="../268023/index.html">The story of a "hack" or How Yahoo gave me a login and password from someone else's mail</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>