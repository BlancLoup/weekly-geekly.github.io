<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We write DXE-driver for taking screenshots from BIOS Setup and other UEFI-applications</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the last article about SecureBoot, I really missed the opportunity to take a screenshot when setting up UEFI via BIOS Setup, but then I was redirec...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We write DXE-driver for taking screenshots from BIOS Setup and other UEFI-applications</h1><div class="post__text post__text-html js-mediator-article"><img align="left" src="https://habrastorage.org/files/2a8/8f3/b41/2a88f3b415b54f1ea653f2b5aad91306.png">  In the last <a href="http://habrahabr.ru/post/273497/">article about SecureBoot,</a> I really missed the opportunity to take a screenshot when setting up UEFI via BIOS Setup, but then I was redirected to a text console to the serial port.  This is an excellent solution, but it is available on a few server motherboards, and through it you can only get pseudographics, but I would like to get a real one - it looks nicer, and you don‚Äôt need to cut it out every time from the terminal window. <br>  That‚Äôs exactly what we‚Äôll do in this article, and at the same time I‚Äôll tell you what a DXE driver is and how to write, build and test it yourself, how keyboard input and screen output in UEFI work, how to find among connected storage devices where you can write files, how to save something to a file from UEFI and how to adapt some external C code to work as part of the firmware. <br>  If you're still interested, I'm waiting for you under the cut. <br><a name="habracut"></a><br><br><h4>  <b>Denial of responsibility</b> </h4><br>  Before we talk about writing and debugging drivers for UEFI, we should immediately say that experiments with firmware are dangerous, they can lead to a ‚Äúbrick‚Äù, and in the most unfortunate rare cases - to failure of equipment, so I warn you in advance: Everything that you read here, you use at your own risk and risk, I do not bear and I will not be responsible for the loss of the performance of your firmware or board.  Before starting any experiments with the firmware, it is necessary to make a complete copy of the entire contents of the SPI flash using the programmer.  This is the only way you can guarantee successful recovery of the firmware after any software failure. <br>  If you do not have a programmer, but you really want to try to write and debug a <abbr title="Driver Execution Environment">DXE</abbr> driver, use <a href="http://www.tianocore.org/ovmf/">OVMF</a> , VmWare Workstation 12 or any other virtualization systems with UEFI support of your choice. <br><br><h4>  <b>What is needed and why is it a DX driver?</b> </h4><br>  Our task is to take a screenshot from the entire screen while running a UEFI application, for example BIOS Setup, pressing a certain key combination, find a file system with write access and save the resulting screenshot to it.  It would also be nice to get some indication of the status.  Since  to take a screenshot, you need to interrupt the work of UEFI applications, the program itself cannot be removed by the application, because there is no preemptive multitasking in UEFI yet, so we need a DXE driver. <br>  The scheme of his work is planned approximately as follows: <br>  <b>0</b>  We load only after the appearance of text input (to handle keystrokes) and graphic output (so that there was something to take screenshots with). <br>  <b>1</b> .  We hang up the handler for pressing the <i>LCtrl + LAlt + F12</i> combination (or whatever you like) on all available text input consoles. <br>  <b>2</b>  In the handler, we find all the output graphic consoles, take a screenshot from them and re-encode it into <abbr title="Portable Network Graphics">PNG format</abbr> (since UEFI applications usually do not use millions of colors, in this format, the screenshots are tens of kilobytes in size instead of several megabytes in BMP). <br>  <b>3</b>  In the same handler, we find the first FS that is found with the ability to write to the root and save the resulting files there. <br>  You can expand the functionality by choosing not the first available file system, but, for example, only USB-devices or only <abbr title="EFI System Partition">ESP</abbr> partitions, let's leave it to the reader for independent work. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  <b>Choosing an SDK</b> </h4><br>  For writing new code to work in UEFI, there are two different SDKs - the newer <a href="http://www.tianocore.org/edk2/">EDK2</a> from the UEFI Forum and the <a href="http://www.tianocore.org/edk2/">third-party</a> <a href="http://sourceforge.net/projects/gnu-efi/">GNU-EFI</a> , based on the old Intel code.  Both solutions imply that you will write code in C and / or assembler, in our case we will try to do with pure C. <br>  It's not for me to judge which SDK is better, but I suggest using EDK2, since  It is official and cross-platform, and new features (along with fixing old bugs) appear in it much faster due to its proximity to the source of changes, plus it is used by all <abbr title="Independent BIOS Vendor">IBVs</abbr> I know to write my code. <br>  EDK2 is in the process of continuous development, and its trunk is steadily added by 2-3 commits per day, but since we are not pursuing the latest trends here (they still don't work for anyone), so we will use the latter for this moment stable cut EDK2, which is called <a href="http://www.tianocore.org/udk/udk2015/">UDK2015</a> . <br>  To provide cross-platform and buildability with different compilers, EDK2 generates makefiles for each platform using TXT (environment configuration), DEC, DSC, and FDF (package configuration) and INF (component configuration) configuration files, I‚Äôll tell you more about them story, and now you need to get EDK2 and build HelloWorld, which we will do, but if you can‚Äôt wait to find out more details right now, <a href="https://github.com/tianocore/tianocore.github.io/wiki/EDK-II-Specifications">go to the documentation</a> . <br><br><h4>  <b>Customize the build environment</b> </h4><br>  It is understood that the necessary to build the code in C and assembler software is already installed on your machine.  If not, I suggest Windows users install Visual Studio 2013 Express for Windows Desktop, Linux and OSX users will need GCC 4.4-4.9 and NASM. <br>  If all this is already installed, it remains only to <a href="https://sourceforge.net/projects/edk2/files/UDK2015_Releases/UDK2015/UDK2015.Complete.MyWorkSpace.zip/download">download UDK2015</a> , unpack the entire contents of <i>UDK2015.MyWorkSpace.zip</i> where you have the right to create files (yes, even directly to the desktop or into your home directory), and then unpack the contents of <i>BaseTools (Windows) .zip</i> or <i>BaseTools (Unix.zip)</i> into the <i>MyWorkSpace</i> directory that was <i>created</i> in the previous step, which you then rename to something decent, for example, <i>UDK2015</i> . <br>  Now open the terminal, go to the newly created directory <i>UDK2015</i> and execute the <i>edksetup.bat</i> (or <i>.sh</i> ) <i>script there</i> , which will copy a set of text files to the <i>Conf</i> subdirectory, we will be interested in <i>tools_def.txt</i> and <i>target.txt</i> . <br>  The first file is quite large; it contains definitions of environment variables with paths to the C and <abbr title="ACPI Source Language">ASL</abbr> compilers required for the build environment, assemblers, linkers, etc.  If you need, you can fix the paths specified there or add your own set of utilities (so-called <i>ToolChain</i> ), but if you listened to my advice, then either VS2013 (if you have 32-bit Windows) or VS2013x86 (in case of 64-bit Windows), or GCC44 | ... |  GCC49 (depending on your version of GCC, which he kindly shows in response to <i>gcc --version</i> ). <br>  The second file contains the default build settings, I recommend setting the following values ‚Äã‚Äãin it: <pre><code class="bash hljs">ACTIVE_PLATFROM = MdeModulePkg/MdeModulePkg.dsc <span class="hljs-comment"><span class="hljs-comment">#      TARGET = RELEASE #   TARGET_ARCH = X64 # DXE     64-,       TOOL_CHAN_TAG = VS2013x86 # | VS2013 | GCC44 | ... | GCC49 | YOUR_FANCY_TOOLCHAIN,      </span></span></code> </pre>  Open another terminal in UDK2015 and in Linux / OSX, execute the command: <pre> <code class="bash hljs">. edksetup.sh BaseTools</code> </pre>  In the case of Windows, the usual <i>edksetup.bat</i> without parameters is sufficient. <br>  Now let's test the <i>build</i> environment with the <i>build</i> command, if everything was done correctly, then after a certain time, it will end up with a message like <pre> <code class="bash hljs">- Done - Build end time: ... Build total time: ...</code> </pre>  If instead of <i>Done</i> you see <i>Failed</i> , then something is wrong with your settings.  I checked the above on VS2013x86 on Windows and GCC48 on Xubuntu 04/14/3 - <abbr title="Everything works">MWRD</abbr> . <br><br><h4>  <b>Project structure</b> </h4><br>  Applications and drivers in EDK2 are not assembled separately, but as part of a so-called <i>Package</i> , i.e.  package.  In addition to the applications themselves, the package also includes libraries, sets of header files and files describing the configuration of the package and its contents.  This is done in order to allow different drivers and applications to use different implementations of libraries, to have access to different header files and GUIDs.  We will use MdeModulePkg, this is a very general package without any dependencies on architecture and hardware, and if our driver can be assembled in it, it will almost certainly work on any implementations of UEFI 2.1 and newer.  The disadvantage of this approach is that most of the libraries in it (for example, DebugLib, used to get debugging output) are just stubs, and you have to write them yourself if the need arises. <br>  To build our driver, you will need an .inf file with information about which libraries, protocols and files it needs for assembly, as well as adding the path to this .inf file to the DSC package file so that the build system knows that such an INF file there is a file. <br>  Let's start from the end: open the <i>UDK2015 / MdeModulePkg / MdeModulePkg.dsc file</i> and scroll it to the [Components] section (you can find it by searching - this is faster).  The section lists in order all the files belonging to the package, looks like the beginning of the section like this: <pre> <code class="bash hljs">[Components] MdeModulePkg/Application/HelloWorld/HelloWorld.inf MdeModulePkg/Application/MemoryProfileInfo/MemoryProfileInfo.inf ...</code> </pre>  Add there your future .inf file along with the path to it relative to <i>UDK2015</i> .  I propose to create for it directly in <i>MdeModulePkg the</i> folder <i>CrScreenshotDxe</i> , and the INF file to call <i>CrScreenshotDxe.inf</i> .  As you may have guessed, Cr is from CodeRush, and the author of this article is modesty itself.  The result is something like this: <pre> <code class="bash hljs">[Components] MdeModulePkg/CrScreenshotDxe/CrScreenshotDxe.inf MdeModulePkg/Application/HelloWorld/HelloWorld.inf MdeModulePkg/Application/MemoryProfileInfo/MemoryProfileInfo.inf ...</code> </pre>  We save the changes and close the DSC-file, we will not change it again, if we don‚Äôt want to set up a debug output, but this is a completely different story. <br>  Now you need to fill in the INF file itself: <br><div class="spoiler">  <b class="spoiler_title">It will look like this</b> <div class="spoiler_text"><pre> <code class="bash hljs">[Defines] <span class="hljs-comment"><span class="hljs-comment">#   INF_VERSION = 0x00010005 #  ,   1.5 BASE_NAME = CrScreenshotDxe #   FILE_GUID = cab058df-e938-4f85-8978-1f7e6aabdb96 # GUID  MODULE_TYPE = DXE_DRIVER #   VERSION_STRING = 1.0 #   ENTRY_POINT = CrScreenshotDxeEntry #    [Sources.common] #   , common -     CrScreenshotDxe.c #    #... #  ,   - ,   PNG,   [Packages] #   MdePkg/MdePkg.dec #  ,        UEFI MdeModulePkg/MdeModulePkg.dec #   ,     [LibraryClasses] #   UefiBootServicesTableLib #    UEFI Boot Services   gBS UefiRuntimeServicesTableLib #      UEFI Runtime services   gRT UefiDriverEntryPoint #    UEFI-,      ,    DebugLib #   DEBUG PrintLib #  UnicodeSPrint,   snprintf [Protocols] #   gEfiGraphicsOutputProtocolGuid #     gEfiSimpleTextInputExProtocolGuid #     gEfiSimpleFileSystemProtocolGuid #     [Depex] #  ,    ,    gEfiGraphicsOutputProtocolGuid AND #       ,       gEfiSimpleTextInputExProtocolGuid #</span></span></code> </pre></div></div>  It remains to create the above mentioned file <i>CrScreenshotDxe.c</i> : <div class="spoiler">  <b class="spoiler_title">With this content</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;Uefi.h&gt; #include &lt;Library/DebugLib.h&gt; #include &lt;Library/PrintLib.h&gt; #include &lt;Library/UefiDriverEntryPoint.h&gt; #include &lt;Library/UefiBootServicesTableLib.h&gt; #include &lt;Library/UefiRuntimeServicesTableLib.h&gt; #include &lt;Protocol/GraphicsOutput.h&gt; #include &lt;Protocol/SimpleTextInEx.h&gt; #include &lt;Protocol/SimpleFileSystem.h&gt; EFI_STATUS EFIAPI CrScreenshotDxeEntry ( IN EFI_HANDLE ImageHandle, IN EFI_SYSTEM_TABLE *SystemTable ) { return EFI_SUCCESS; }</span></span></span></span></code> </pre></div></div>  If you now repeat the <i>build</i> command, it must be successful, otherwise you did something wrong. <br>  Now we finally have a blank for our driver, and you can go directly to writing code.  It is absolutely clear that such an assembly system is no good, and working with it through editing text files is not very pleasant, so each IBV has its own solution for integrating the EDK2 assembly system into some modern IDE, for example, AMI Visual eBIOS so hung with Eclipse plugins, and Phoenix and Insyde weighed them by Visual Studio. <br>  There is also a wonderful project <a href="https://github.com/ionescu007/VisualUefi">VisualUefi</a> for authorship of well-known computer security specialist Alex Ionescu, and if you also like Visual Studio, I suggest we try it, and for the time being we continue to frighten hardcore, maintain the spirit of the old school and all that. <br><br><h4>  <b>We respond to keystrokes</b> </h4><br>  Everything is quite simple here: when loading the driver, we search through all instances of the <a href="http://wiki.phoenix.com/wiki/index.php/EFI_SIMPLE_TEXT_INPUT_EX_PROTOCOL">SimpleTextInputEx</a> protocol, which is published by the keyboard driver and most often exactly one, even in the case when several keyboards are connected to the system ‚Äî the buffer is common, unless something is specifically changed.  However, just in case, we will sort through all the available instances, calling each function <a href="http://wiki.phoenix.com/wiki/index.php/EFI_SIMPLE_TEXT_INPUT_EX_PROTOCOL">RegisterKeyNotify</a> , which takes as a parameter a key combination to which we intend to react, and a pointer to the callback function that will be called after pressing the combination you need, and already and will be carried out all the main work. <br><div class="spoiler">  <b class="spoiler_title">Translate from Russian to C</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">EFI_STATUS EFIAPI </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CrScreenshotDxeEntry</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( IN EFI_HANDLE ImageHandle, IN EFI_SYSTEM_TABLE *SystemTable )</span></span></span><span class="hljs-function"> </span></span>{ EFI_STATUS Status; EFI_KEY_DATA KeyStroke; UINTN HandleCount; EFI_HANDLE *HandleBuffer = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; UINTN i; <span class="hljs-comment"><span class="hljs-comment">// Set keystroke to be LCtrl+LAlt+F12 KeyStroke.Key.ScanCode = SCAN_F12; KeyStroke.Key.UnicodeChar = 0; KeyStroke.KeyState.KeyShiftState = EFI_SHIFT_STATE_VALID | EFI_LEFT_CONTROL_PRESSED | EFI_LEFT_ALT_PRESSED; KeyStroke.KeyState.KeyToggleState = 0; // Locate all SimpleTextInEx protocols Status = gBS-&gt;LocateHandleBuffer(ByProtocol, &amp;gEfiSimpleTextInputExProtocolGuid, NULL, &amp;HandleCount, &amp;HandleBuffer); if (EFI_ERROR (Status)) { DEBUG((-1, "CrScreenshotDxeEntry: gBS-&gt;LocateHandleBuffer returned %r\n", Status)); return EFI_UNSUPPORTED; } // For each instance for (i = 0; i &lt; HandleCount; i++) { EFI_HANDLE Handle; EFI_SIMPLE_TEXT_INPUT_EX_PROTOCOL *SimpleTextInEx; // Get protocol handle Status = gBS-&gt;HandleProtocol (HandleBuffer[i], &amp;gEfiSimpleTextInputExProtocolGuid, (VOID **) &amp;SimpleTextInEx); if (EFI_ERROR (Status)) { DEBUG((-1, "CrScreenshotDxeEntry: gBS-&gt;HandleProtocol[%d] returned %r\n", i, Status)); continue; } // Register key notification function Status = SimpleTextInEx-&gt;RegisterKeyNotify( SimpleTextInEx, &amp;KeyStroke, TakeScreenshot, &amp;Handle); if (EFI_ERROR (Status)) { DEBUG((-1, "CrScreenshotDxeEntry: SimpleTextInEx-&gt;RegisterKeyNotify[%d] returned %r\n", i, Status)); } } // Free memory used for handle buffer if (HandleBuffer) gBS-&gt;FreePool(HandleBuffer); // Show driver loaded ShowStatus(0xFF, 0xFF, 0xFF); // White return EFI_SUCCESS; }</span></span></code> </pre></div></div>  For successful compilation, there are not enough features of <i>TakeScreenshot</i> and <i>ShowStatus</i> , which are described below. <br><br><h4>  <b>We are looking for FS with write access, write data to a file</b> </h4><br>  Before looking for available graphic consoles and taking screenshots of them, you need to find out if these same screenshots can be saved somewhere.  To do this, find all instances of the <a href="http://wiki.phoenix.com/wiki/index.php/EFI_SIMPLE_FILE_SYSTEM_PROTOCOL">SimpleFileSystem</a> protocol, which is published by the PartitionDxe driver for each detected volume, the FS of which is known to the firmware.  Most often, the only known FSs are the FAT12 / 16/32 family (sometimes only FAT32), which, according to the UEFI standard, can be used for ESP.  Next you need to check that you can write to the found file system, you can do it in different ways, the easiest way is to try to create a file on it and open it for reading and writing, if you can, you can write to this file system.  The solution, of course, is not the most optimal, but I suggest that readers work as a good implementation as an exercise. <br><div class="spoiler">  <b class="spoiler_title">Again translate from Russian to C</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">EFI_STATUS EFIAPI </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindWritableFs</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( OUT EFI_FILE_PROTOCOL **WritableFs )</span></span></span><span class="hljs-function"> </span></span>{ EFI_HANDLE *HandleBuffer = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; UINTN HandleCount; UINTN i; <span class="hljs-comment"><span class="hljs-comment">// Locate all the simple file system devices in the system EFI_STATUS Status = gBS-&gt;LocateHandleBuffer(ByProtocol, &amp;gEfiSimpleFileSystemProtocolGuid, NULL, &amp;HandleCount, &amp;HandleBuffer); if (!EFI_ERROR (Status)) { EFI_FILE_PROTOCOL *Fs = NULL; // For each located volume for (i = 0; i &lt; HandleCount; i++) { EFI_SIMPLE_FILE_SYSTEM_PROTOCOL *SimpleFs = NULL; EFI_FILE_PROTOCOL *File = NULL; // Get protocol pointer for current volume Status = gBS-&gt;HandleProtocol(HandleBuffer[i], &amp;gEfiSimpleFileSystemProtocolGuid, (VOID **) &amp;SimpleFs); if (EFI_ERROR (Status)) { DEBUG((-1, "FindWritableFs: gBS-&gt;HandleProtocol[%d] returned %r\n", i, Status)); continue; } // Open the volume Status = SimpleFs-&gt;OpenVolume(SimpleFs, &amp;Fs); if (EFI_ERROR (Status)) { DEBUG((-1, "FindWritableFs: SimpleFs-&gt;OpenVolume[%d] returned %r\n", i, Status)); continue; } // Try opening a file for writing Status = Fs-&gt;Open(Fs, &amp;File, L"crsdtest.fil", EFI_FILE_MODE_CREATE | EFI_FILE_MODE_READ | EFI_FILE_MODE_WRITE, 0); if (EFI_ERROR (Status)) { DEBUG((-1, "FindWritableFs: Fs-&gt;Open[%d] returned %r\n", i, Status)); continue; } // Writable FS found Fs-&gt;Delete(File); *WritableFs = Fs; Status = EFI_SUCCESS; break; } } // Free memory if (HandleBuffer) { gBS-&gt;FreePool(HandleBuffer); } return Status; }</span></span></code> </pre></div></div>  This code doesn't need anything else, it works as it is. <br><br><h4>  <b>We are looking for a graphical console and take a picture of its screen.</b> </h4><br>  Checking what screenshots to save is what, let's take them down.  To do this, you need to go through all instances of the <a href="http://wiki.phoenix.com/wiki/index.php/EFI_GRAPHICS_OUTPUT_PROTOCOL">GOP</a> protocol, which is published by GOP drivers and VideoBIOSs (more precisely, not VBIOS itself, which knows nothing about any protocols, but the ConSplitter driver, which implements the layer between the old VBIOS and UEFI) for each output device with graphics.  This protocol has the <a href="http://wiki.phoenix.com/wiki/index.php/EFI_GRAPHICS_OUTPUT_PROTOCOL">Blt</a> function for copying an image from and to the framebuffer until we need only the first one.  Using the <i>Mode</i> object of the same protocol, you can get the current screen resolution, which is needed to highlight the buffer of the desired size and take a screenshot from the entire screen, and not from some part of it.  Having received a screenshot, it is worth checking that it is not completely black, for saving such data is a waste of time and space on the file system, a black rectangle of the desired size can be drawn in Paint.  Then you need to convert the image from BGR (in which Blt gives it) to RGB (which the PNG encoder needs), otherwise the colors on the screenshots will be incorrect.  We encode the image obtained after the conversion and save it to a file on the file system that we found in the previous step.  We will collect the file name in 8.3 format from the current date and time, so there is less chance that one screenshot will overwrite another. <br><div class="spoiler">  <b class="spoiler_title">Again translate from Russian to C</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">EFI_STATUS EFIAPI </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TakeScreenshot</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( IN EFI_KEY_DATA *KeyData )</span></span></span><span class="hljs-function"> </span></span>{ EFI_FILE_PROTOCOL *Fs = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; EFI_FILE_PROTOCOL *File = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; EFI_GRAPHICS_OUTPUT_PROTOCOL *GraphicsOutput = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; EFI_GRAPHICS_OUTPUT_BLT_PIXEL *Image = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; UINTN ImageSize; <span class="hljs-comment"><span class="hljs-comment">// Size in pixels UINT8 *PngFile = NULL; UINTN PngFileSize; // Size in bytes EFI_STATUS Status; UINTN HandleCount; EFI_HANDLE *HandleBuffer = NULL; UINT32 ScreenWidth; UINT32 ScreenHeight; CHAR16 FileName[8+1+3+1]; // 0-terminated 8.3 file name EFI_TIME Time; UINTN i, j; // Find writable FS Status = FindWritableFs(&amp;Fs); if (EFI_ERROR (Status)) { DEBUG((-1, "TakeScreenshot: Can't find writable FS\n")); ShowStatus(0xFF, 0xFF, 0x00); // Yellow return EFI_SUCCESS; } // Locate all instances of GOP Status = gBS-&gt;LocateHandleBuffer(ByProtocol, &amp;gEfiGraphicsOutputProtocolGuid, NULL, &amp;HandleCount, &amp;HandleBuffer); if (EFI_ERROR (Status)) { DEBUG((-1, "ShowStatus: Graphics output protocol not found\n")); return EFI_SUCCESS; } // For each GOP instance for (i = 0; i &lt; HandleCount; i++) { do { // Break from do used instead of "goto error" // Handle protocol Status = gBS-&gt;HandleProtocol(HandleBuffer[i], &amp;gEfiGraphicsOutputProtocolGuid, (VOID **) &amp;GraphicsOutput); if (EFI_ERROR (Status)) { DEBUG((-1, "ShowStatus: gBS-&gt;HandleProtocol[%d] returned %r\n", i, Status)); break; } // Set screen width, height and image size in pixels ScreenWidth = GraphicsOutput-&gt;Mode-&gt;Info-&gt;HorizontalResolution; ScreenHeight = GraphicsOutput-&gt;Mode-&gt;Info-&gt;VerticalResolution; ImageSize = ScreenWidth * ScreenHeight; // Get current time Status = gRT-&gt;GetTime(&amp;Time, NULL); if (!EFI_ERROR(Status)) { // Set file name to current day and time UnicodeSPrint(FileName, 26, L"%02d%02d%02d%02d.png", Time.Day, Time.Hour, Time.Minute, Time.Second); } else { // Set file name to scrnshot.png UnicodeSPrint(FileName, 26, L"scrnshot.png"); } // Allocate memory for screenshot Status = gBS-&gt;AllocatePool(EfiBootServicesData, ImageSize * sizeof(EFI_GRAPHICS_OUTPUT_BLT_PIXEL), (VOID **)&amp;Image); if (EFI_ERROR(Status)) { DEBUG((-1, "TakeScreenshot: gBS-&gt;AllocatePool returned %r\n", Status)); break; } // Take screenshot Status = GraphicsOutput-&gt;Blt(GraphicsOutput, Image, EfiBltVideoToBltBuffer, 0, 0, 0, 0, ScreenWidth, ScreenHeight, 0); if (EFI_ERROR(Status)) { DEBUG((-1, "TakeScreenshot: GraphicsOutput-&gt;Blt returned %r\n", Status)); break; } // Check for pitch black image (it means we are using a wrong GOP) for (j = 0; j &lt; ImageSize; j++) { if (Image[j].Red != 0x00 || Image[j].Green != 0x00 || Image[j].Blue != 0x00) break; } if (j == ImageSize) { DEBUG((-1, "TakeScreenshot: GraphicsOutput-&gt;Blt returned pitch black image, skipped\n")); ShowStatus(0x00, 0x00, 0xFF); // Blue break; } // Open or create output file Status = Fs-&gt;Open(Fs, &amp;File, FileName, EFI_FILE_MODE_CREATE | EFI_FILE_MODE_READ | EFI_FILE_MODE_WRITE, 0); if (EFI_ERROR (Status)) { DEBUG((-1, "TakeScreenshot: Fs-&gt;Open of %s returned %r\n", FileName, Status)); break; } // Convert BGR to RGBA with Alpha set to 0xFF for (j = 0; j &lt; ImageSize; j++) { UINT8 Temp = Image[j].Blue; Image[j].Blue = Image[j].Red; Image[j].Red = Temp; Image[j].Reserved = 0xFF; } // Encode raw RGB image to PNG format j = lodepng_encode32(&amp;PngFile, &amp;PngFileSize, (CONST UINT8*)Image, ScreenWidth, ScreenHeight); if (j) { DEBUG((-1, "TakeScreenshot: lodepng_encode32 returned %d\n", j)); break; } // Write PNG image into the file and close it Status = File-&gt;Write(File, &amp;PngFileSize, PngFile); File-&gt;Close(File); if (EFI_ERROR(Status)) { DEBUG((-1, "TakeScreenshot: File-&gt;Write returned %r\n", Status)); break; } // Show success ShowStatus(0x00, 0xFF, 0x00); // Green } while(0); // Free memory if (Image) gBS-&gt;FreePool(Image); if (PngFile) gBS-&gt;FreePool(PngFile); Image = NULL; PngFile = NULL; } // Show error if (EFI_ERROR(Status)) ShowStatus(0xFF, 0x00, 0x00); // Red return EFI_SUCCESS; }</span></span></code> </pre></div></div>  To work is not enough <i>lodepng_encode32</i> and the above-mentioned <i>ShowStatus</i> , we continue. <br><br><h4>  <b>We encode the image in PNG format</b> </h4><br>  The best way to write code is not to write it, so let's take a ready-made library for encoding and decoding a PNG called <a href="http://lodev.org/lodepng/">lodepng</a> .  Download, put next to our C-file, add our lo line to the INF file in the [Sources.common] section, <i>lodepng.h</i> and <i>lodepng.c</i> , include the header file, and ... nothing compiles, because lodepng does not expect A standard C language library can take it entirely without it.  Nothing, finish, not the first time. <br>  Add the following to the beginning of <i>lodepng.h</i> : <pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;Uefi.h&gt; //      UEFI #define LODEPNG_NO_COMPILE_DECODER //   PNG #define LODEPNG_NO_COMPILE_DISK //    , .. fopen/fwrite    #define LODEPNG_NO_COMPILE_ALLOCATORS //   malloc/realloc/free, ..     #define LODEPNG_NO_COMPILE_ERROR_TEXT //     #define LODEPNG_NO_COMPILE_ANCILLARY_CHUNKS //     PNG, ..   #if !defined(_MSC_VER) //   size_t  GCC,  MS        #define size_t UINTN #endif</span></span></span></span></code> </pre>  And comment out the line with <i>#include &lt;string.h&gt;</i> , which we don't have either.  You can, of course, create a local file with the same name, defining the type size_t there, but since we started to change it, we will change it. <br>  With <i>lodepng.c it is a</i> little more difficult, because  from the standard library, besides size_t, it also needs memset, memcpy, malloc, realloc, free, qsort, and also it uses floating point calculations.  The implementation of qsort can be <a href="">dragged off from Apple</a> , the memory management functions can be <a href="http://wiki.phoenix.com/wiki/index.php/EFI_BOOT_SERVICES">wrapped</a> on <a href="http://wiki.phoenix.com/wiki/index.php/EFI_BOOT_SERVICES">gBS-&gt; CopyMem</a> , <a href="http://wiki.phoenix.com/wiki/index.php/EFI_BOOT_SERVICES">gBS-&gt; SetMem</a> , <a href="http://wiki.phoenix.com/wiki/index.php/EFI_BOOT_SERVICES">gBS-&gt; AllocatePool</a> and <a href="http://wiki.phoenix.com/wiki/index.php/EFI_BOOT_SERVICES">gBS-&gt; FreePool,</a> respectively, and in order to signal the operation of FPU, you must define the constant <i>CONST INT32 _fltused = 0;</i>  otherwise the linker will swear at her absence.  I‚Äôm not even talking about commenting files with standard #includes - everything is clear. <br>  Similarly, <i>qsort.c</i> is also <i>included</i> in the normal combat, just remember to add it to the INF file. <br><br><h4>  <b>Display status</b> </h4><br>  It remains to write the ShowStatus function and our driver is ready.  This very status can be obtained in various ways, for example, output numbers from 0x00 to 0xFF to a CPU IO-port 80h, which is connected to the POST-coder, but not everyone has it, and it doesn‚Äôt occur on laptops.  You can squeak the speaker, but this is, firstly, platform-dependent, and secondly - wildly enrages after a couple of screenshots.  You can blink lights on the keyboard, this is an additional task for the reader, and we will show the status of work with the graphic console directly through this graphic console - displaying a small square of the desired color in the upper left corner of the screen.  At the same time, a white square will mean ‚Äúthe driver is successfully loaded,‚Äù yellow - ‚ÄúFS cannot be found,‚Äù blue - ‚ÄúScreenshot of the current console is completely black, there is no sense to save‚Äù, red - ‚Äúan error has occurred‚Äù and, finally, green - ‚Äú screenshot taken and saved.  It is necessary to display this square on all consoles, and after a short time to restore that piece of the image that they have been erased. <br><div class="spoiler">  <b class="spoiler_title">Last time we translate from Russian to C</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">EFI_STATUS EFIAPI </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ShowStatus</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( IN UINT8 Red, IN UINT8 Green, IN UINT8 Blue )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Determines the size of status square #define STATUS_SQUARE_SIDE 5 UINTN HandleCount; EFI_HANDLE *HandleBuffer = NULL; EFI_GRAPHICS_OUTPUT_PROTOCOL *GraphicsOutput = NULL; EFI_GRAPHICS_OUTPUT_BLT_PIXEL Square[STATUS_SQUARE_SIDE * STATUS_SQUARE_SIDE]; EFI_GRAPHICS_OUTPUT_BLT_PIXEL Backup[STATUS_SQUARE_SIDE * STATUS_SQUARE_SIDE]; UINTN i; // Locate all instances of GOP EFI_STATUS Status = gBS-&gt;LocateHandleBuffer(ByProtocol, &amp;gEfiGraphicsOutputProtocolGuid, NULL, &amp;HandleCount, &amp;HandleBuffer); if (EFI_ERROR (Status)) { DEBUG((-1, "ShowStatus: Graphics output protocol not found\n")); return EFI_UNSUPPORTED; } // Set square color for (i = 0 ; i &lt; STATUS_SQUARE_SIDE * STATUS_SQUARE_SIDE; i++) { Square[i].Blue = Blue; Square[i].Green = Green; Square[i].Red = Red; Square[i].Reserved = 0x00; } // For each GOP instance for (i = 0; i &lt; HandleCount; i ++) { // Handle protocol Status = gBS-&gt;HandleProtocol(HandleBuffer[i], &amp;gEfiGraphicsOutputProtocolGuid, (VOID **) &amp;GraphicsOutput); if (EFI_ERROR (Status)) { DEBUG((-1, "ShowStatus: gBS-&gt;HandleProtocol[%d] returned %r\n", i, Status)); continue; } // Backup current image GraphicsOutput-&gt;Blt(GraphicsOutput, Backup, EfiBltVideoToBltBuffer, 0, 0, 0, 0, STATUS_SQUARE_SIDE, STATUS_SQUARE_SIDE, 0); // Draw the status square GraphicsOutput-&gt;Blt(GraphicsOutput, Square, EfiBltBufferToVideo, 0, 0, 0, 0, STATUS_SQUARE_SIDE, STATUS_SQUARE_SIDE, 0); // Wait 500ms gBS-&gt;Stall(500*1000); // Restore the backup GraphicsOutput-&gt;Blt(GraphicsOutput, Backup, EfiBltBufferToVideo, 0, 0, 0, 0, STATUS_SQUARE_SIDE, STATUS_SQUARE_SIDE, 0); } return EFI_SUCCESS; }</span></span></code> </pre></div></div>  Now everything is ready and successfully assembled, if not, saw until it is <a href="https://github.com/NikolajSchlej/CrScreenshotDxe">ready</a> , or <a href="https://github.com/NikolajSchlej/CrScreenshotDxe">download my ready-made driver from GitHub</a> and compare it with yours, maybe I forgot to describe any changes. <br><br><h4>  <b>We test the result in UEFI Shell</b> </h4><br>  Taking our driver collected from <i>UDK2015 / Build / MdeModulePkg / RELEASE /</i> X64 / MdeModulePkg / CrScreenshotDxe / CrScreenshotDxe / OUTPUT, will be needed there only two files - <i>CrScreenshotDxe.efi</i> driver itself and the section dependencies for him <i>CrScreenshotDxe.depex</i> <br>  First, let's test the driver from the UEFI Shell.  Copy the file <i>CrScreenshotDxe.efi</i> to a USB flash drive from the UEFI Shell, boot into it, go to the root of the flash drive with the command <i>fs0:</i> (the number may change depending on the number of disks connected to your system) and execute the <i>load</i> command <i>CrScreenshotDxe.efi</i> .  If you see a success message and a white square flashed in the upper corner of the screen, then the driver is loaded and working.  It looks like this to me: <br><div class="spoiler">  <b class="spoiler_title">UEFI Shell</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/a9a/833/22e/a9a83322e5754e719e6f02228f625dd6.png"><br>  This screenshot, like all subsequent ones, was taken by our driver, so the square in the corner is not visible on it. <br></div></div>  Then feel free to click <i>LCtrl + LAlt + F12</i> and watch the status.  On my systems with AMI, the graphical console is one, and therefore I see a flashed green square and get one screenshot for one press of the combination.  On my systems with Phoenix and Insyde, there were two graphic consoles, one of which is empty, so I see first a blue square and then a green one, while the screenshot is also only one.  The test result from UEFI Shell for them looks the same, only the resolution there is no longer 800x600, but 1366x768. <br>  Well, from the shell everything works and you can take screenshots from UEFI applications, these are: <br><div class="spoiler">  <b class="spoiler_title">RU.efi</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/225/da4/676/225da4676be34619b7e2194b5d9d2334.png"><br></div></div><br><h4>  <b>We test the result in a modified firmware</b> </h4><br>  Unfortunately, the screenshot from BIOS Setup cannot be removed in this way - the driver loads too late.    ,  ‚Äî         DXE-    <a href="https://github.com/LongSoft/UEFITool">UEFITool</a> ,  ‚Äî     OptionROM - PCIe-,      .       ,    ,       . , , ,  ,   BIOS Setup,  <i>LCtrl + LAlt + F12</i> ‚Äî ,     ,  .    : <br><div class="spoiler"> <b class="spoiler_title">  </b> <div class="spoiler_text"><img src="https://habrastorage.org/files/0f2/8d4/3fa/0f28d43fa44f4f7d8b9833a72aa39b01.png"><br></div></div><div class="spoiler"> <b class="spoiler_title"> Information</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/cd5/1ce/93c/cd51ce93c42245c6bf57dcad930bec10.png"><br></div></div><div class="spoiler"> <b class="spoiler_title"> Main</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/d7c/3dd/10d/d7c3dd10d8634630a628b44c8937d0c9.png"><br></div></div><div class="spoiler"> <b class="spoiler_title"> Security</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/6fb/552/a84/6fb552a84f2b4e329c7f6c05d3ecfd18.png"><br></div></div><div class="spoiler"> <b class="spoiler_title"> Boot</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/fdd/9d8/fb5/fdd9d8fb566a4302b695d7aa96fb8ed7.png"><br></div></div><div class="spoiler"> <b class="spoiler_title"> Exit</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/b9b/7ba/774/b9b7ba7747cf44b9abb0af1c94c936f6.png"><br></div></div>  , . <br><br><h4>  <b>Conclusion</b> </h4><br>  , <a href="https://github.com/NikolajSchlej/CrScreenshotDxe">   GitHub</a> ,     OptionROM,  ,  , . <br>     ,    ,     ,     , ,  UEFI  ,      legacy BIOS ‚Äî    . <br>    ,   DXE-. </div><p>Source: <a href="https://habr.com/ru/post/274463/">https://habr.com/ru/post/274463/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../274451/index.html">Expansion of sections without data loss</a></li>
<li><a href="../274453/index.html">Black Hat USA 2015: the full story of the hacking of the very Jeep</a></li>
<li><a href="../274455/index.html">Creating a function on Rust that accepts a String or & str</a></li>
<li><a href="../274457/index.html">Defending Revel from CSRF attacks</a></li>
<li><a href="../274461/index.html">The tale of the compressor, which can be called, but I do not remember how</a></li>
<li><a href="../274469/index.html">BlackEnergy Trojan is used in cyber attacks on media and industrial facilities in Ukraine</a></li>
<li><a href="../274471/index.html">Multiplication tables ... kind of</a></li>
<li><a href="../274473/index.html">Draw Elliptic Curves with SQL</a></li>
<li><a href="../274475/index.html">Rip network dictionaries using Node.js, part 1: static pages; CLI; DSL -> TXT, PDF, DjVu; related tasks</a></li>
<li><a href="../274477/index.html">Localization of WPF applications and instant culture change</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>