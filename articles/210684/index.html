<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Cryptanalysis hash functions GOST R 34.11-2012</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="At the end of 2013, the Technical Committee for Standardization "Cryptographic Information Protection" (TC 26), the Academy of Cryptography of the Rus...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Cryptanalysis hash functions GOST R 34.11-2012</h1><div class="post__text post__text-html js-mediator-article">  <em>At the end of 2013, the Technical Committee for Standardization "Cryptographic Information Protection" (TC 26), the Academy of Cryptography of the Russian Federation and OJSC InfoTeKS announced a contest for cryptanalysis of the national hash standard GOST R 34.11-2012.</em>  <em>A detailed description of the conditions of the competition is published on the website <a href="http://www.streebog.info/">www.streebog.info</a> .</em>  <em>Thus, we can assume that the existing work on the analysis of this cryptostandard became the subject of heightened interest of cryptanalysts, since they are the starting point for further research of the algorithm GOST R 34.11-2012.</em> <em><br></em>  <em>To date, there are several works dedicated to cryptoanalysis of GOST R 34.11-2012.</em>  <em>But it was in the work of Zongyue Wang, Hongbo Yu and Xiaoyun Wang ‚Äú <a href="https://eprint.iacr.org/2013/584.pdf">Cryptanalysis of GOST R Hash Function</a> ‚Äù that the most effective attacks on this algorithm were proposed.</em>  <em>Therefore, in my opinion, this work is of the greatest interest among the works on this topic;</em>  <em>its translation is what I bring to your attention.</em> <em><br></em>  <em>The translation preserved the author's names of the hashing standards: under the name ‚ÄúGOST‚Äù I mean the 1994 standard GOST R 34.11-94, and ‚ÄúGOST R‚Äù refers to the GOST R 34.11-2012 algorithm studied in this paper.</em> <em><br></em>  <em>The work has been translated and published in Russian with the permission of its authors.</em> <br><a name="habracut"></a><br><h1>  annotation </h1><br>  GOST R is a standard for hash function in Russia.  This paper presents some results of GOST R cryptanalysis. Using the techniques of rebound attacks, we obtained attacks that allow us to find collisions of the compression function with a reduced number of rounds.  An attack on 9.5 rounds with a labor-intensive rate of <sup>2,176</sup> operations and memory requirements of <sup>2,128</sup> bytes was proposed.  On the basis of this attack, a discriminator has been proposed ( <em>Approx. Transl</em> .: Discriminator is an algorithm that allows to distinguish the attacked function from a randomly and equally likely selected function).  Moreover, a design method for <em>k-</em> collisions is presented for the 512-bit version of GOST R, which shows the weakness of the structure used in GOST R. As far as we know, these are the first results of the analysis of GOST R. <br>  <em>Keywords</em> : hash function, GOST R, rebound attack, multicollision. <br><br><h1>  1. Introduction </h1><br>  Hash functions play an important role in cryptography and are used in many applications, such as electronic signature, authentication, and data integrity.  Since the MD5 and SHA-1 algorithms [1, 2] have been hacked, cryptographers have been looking for strong and efficient hash functions.  The successor of the algorithm GOST, GOST R is the standard of hashing in Russia [3].  Similar in structure to Whirlpool [4], it also uses the AES-like block cipher in its compression function. <br>  Rebound-attack is a technology using degrees of freedom, which can be used to search for collisions for hashing algorithms based on both permutations and block ciphers.  This technology was first proposed in the work of Mendel (et al.) And others to form collision search attacks for the truncated Whirlpool and Gr√∏stl algorithms [5].  It aims to effectively search for pairs of values ‚Äã‚Äãthat correspond to a predetermined truncated differential.  The search procedure is divided into two phases: the internal (inbound) phase and the external (outbound) phase.  In the internal phase, the attacker fully utilizes the available degrees of freedom and generates quite a few pairs of values ‚Äã‚Äãthat satisfy the paths of the truncated differential of the internal phase, used as starting points.  Subsequently, in the external phase, these starting points are checked to find pairs of values ‚Äã‚Äãthat satisfy the paths of the truncated differential of the external phase. <br>  Lamberger et al. Strengthened this technology in [6] and obtained improved results for Whirlpool.  The available degrees of freedom in the key scheme are used to extend the internal phase of a rebound attack by up to two rounds.  The best results of [6] are near-collision for the 9.5 round of the compression function with the complexity of <sup>2,176</sup> .  This result was then used to construct the first distinguishing algorithm for the full 10-round compression function of the Whirlpool algorithm.  At the same time, Gilbert et al. Proposed an advanced replacement technology (Super-Sbox) for a rebound attack in [7], where two rounds of AES-like transformations were considered as one level of advanced replacement.  In addition, the rebound attack can also be used to analyze AES and AES-like block ciphers [8, 9], as well as ARX ciphers ( <em>Note</em> : ARX is an abbreviation of Add-Rotate-Xor, these operations are basic in ARX-ciphers).  [ten].  Recently, using the adapted technology of rebound attacks, Duc (Duc) and others have constructed differential characteristics for Keccak in [11]. <br>  As an alternative to collision searching for hash functions, Joux proposed a method for constructing multicollisions in [12].  He showed that for an iterative hash function, the search for a multicollision is no more difficult than the search for a single collision.  This method can be applied in most cases to analyze the stability of the structure of the hash function. <br><br><h2>  1.1.  Our contribution </h2><br>  Due to the similarity of the GOST R and Whirlpool structure, the rebound attack used in [6] for the Whirlpool analysis can also be applied to GOST R. However, GOST P uses a matrix permutation instead of ShiftRows operation in AES-like structures.  We will show that this difference leads to greater vulnerability. <br>  In this paper, we present the first results of the GOST R analysis. More precisely, using the methods of rebound attacks, similar to those given in [6], we have received collision search attacks for 4.5, 5.5, 7.5 and 9.5 Round compression function GOST R. Our attacks on the search for collisions for the compression function GOST R are given in Table.  1. We further demonstrated that an attack on 9.5 rounds can be subsequently converted into a 10-round discriminator.  In addition, we proposed a method for constructing multicollisions for the full 512-bit version of GOST R. This result shows that the structure used in GOST R is not ideal. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <em>Tab.</em>  <em>1. Summary results for the GOST R compression function. The resource capacity indicated in brackets refers to modified attacks using a precomputed table, which requires <sup>2,128</sup> units of time and memory to fill.</em> <br><table border="1"><tbody><tr><td width="86">  <em>Rounds</em> </td><td width="210">  <em>Complexity / memory</em> </td><td width="106">  <em>Type of</em> </td><td width="118">  <em>Description</em> </td></tr><tr><td width="86">  4.5 </td><td width="210">  2 <sup>64/2</sup> <sup>16</sup> </td><td width="106">  Collision </td><td width="118">  Section 3.3 </td></tr><tr><td width="86">  5.5 </td><td width="210">  2 <sup>64/2</sup> <sup>64</sup> </td><td width="106">  Collision </td><td width="118">  Section 3.4 </td></tr><tr><td width="86">  7.5 </td><td width="210">  2 <sup>128/2</sup> <sup>16</sup> </td><td width="106">  Collision </td><td width="118">  Section 3.5 </td></tr><tr><td width="86">  9.5 </td><td width="210">  2 <sup>240/2</sup> <sup>16</sup> (2 <sup>176/2</sup> <sup>128</sup> ) </td><td width="106">  Collision </td><td width="118">  Section 3.6 </td></tr></tbody></table><br><br><h2>  1.2.  The content of the work </h2><br>  Summary of this work: in Chapter 2, we briefly describe the GOST R hash function. Then we give a detailed description of the rebound attack in Chapter 3;  A description of the discriminator will be given in Chapter 4. In Chapter 5, we will present a method for constructing multicollisions.  Finally, in chapter 6 we summarize the work. <br><br><h1>  2. Hash function GOST R </h1><br>  GOST R is the hash standard in Russia [3].  It processes 512-bit message blocks and calculates 512-bit or 256-bit hash values.  <em>The l-</em> bit message is first supplemented to a size multiple of 512 bits.  A single bit joins the end of the message;  it is followed by 512 - 1 - ( <em>l</em> mod 512) zero bits.  Let <em>M</em> = <em>M <sub>t</sub></em> ||  <em>M</em> <sub><em>t</em> -1</sub> || ... ||  <em>M</em> <sub>1</sub> is a message consisting of <em>t</em> blocks after a supplement, presented in big-endian form.  Then, as shown in fig.  1, the calculation of <em>H</em> ( <em>M</em> ) can be described as follows: <br><br><img width="488" height="133" src="https://habrastorage.org/getpro/habr/post_images/d56/851/b29/d56851b29ddefa3500587bceebb27a75.jpg"><br>  <em>Fig.</em>  <em>1. Hash function GOST R</em> <br><br><img width="557" height="87" src="https://habrastorage.org/getpro/habr/post_images/564/391/e54/564391e54ee68b0a143edcc03267ab5e.jpg"><br>  where <em>IV</em> is a predetermined initial value, and <img width="10" height="10" src="https://habrastorage.org/getpro/habr/post_images/4ef/c56/912/4efc56912e303d954d092a7506d5a869.jpg">  denotes the operation of addition in the ring <img width="27" height="11" src="https://habrastorage.org/getpro/habr/post_images/f22/8f7/1e6/f228f71e6c3b68ea65d97b97dc7070ab.jpg">  .  <em>g <sub>N</sub></em> ( <em>h</em> , <em>m</em> ) is a compression function of the GOST R algorithm, which is based on a 512-bit block cipher and is calculated as follows: <br><img width="554" height="18" src="https://habrastorage.org/getpro/habr/post_images/86b/a5c/b4e/86ba5cb4eb90132138d957cf25bef59e.jpg"><br>  The block cipher <em>E</em> used in GOST R is a variant of AES, which updates the 64-byte state (represented as an 8 x 8 array - the state can also be represented as 64 x 64 in the <em>GF</em> (2) field) and a round key, performing 12 rounds.  In each round, the state is updated by performing a round transform <em>r <sub>i</sub></em> as follows: <br><img width="135" height="18" src="https://habrastorage.org/getpro/habr/post_images/777/255/c52/777255c523ece2321cb887425128b3aa.jpg"><br>  Round conversion consists of: <br><ul><li>  the level of nonlinear transformations <em>S</em> , where a table replacement is applied independently to each state byte; </li><li>  byte permutation <em>P</em> , rearranging the elements of the state matrix; </li><li>  linear transformation <em>L</em> , which is an independent multiplication on the right of each status line by 64 x 64 matrix A in the field <em>GF</em> (2); </li><li>  operations <em>X</em> [ <em>k <sub>i</sub></em> <sub>+1</sub> ] performing the imposition of a round key <em>k <sub>i</sub></em> <sub>+1</sub> on the state by an XOR operation. </li></ul><br>  The round key <em>k <sub>i is</sub></em> calculated as follows: <br><img width="225" height="19" src="https://habrastorage.org/getpro/habr/post_images/8f6/ebc/e40/8f6ebce402f9f3aad7954287ab17d596.jpg"><br>  where <em>C <sub>i</sub></em> - constants of the algorithm GOST R, and the initial value of <em>k</em> <sub>1</sub> is defined as <img width="138" height="17" src="https://habrastorage.org/getpro/habr/post_images/081/eb4/eb1/081eb4eb191415845db62813026a5330.jpg"><br>  After the last round of the state update transform, the output value of the block cipher <em>E</em> , the previous state value <em>h <sub>j</sub></em> <sub>-1,</sub> and the message block <em>M <sub>j</sub></em> are combined by the XOR operation as the output value of the compression function. <br>  We denote the result of the round transformation <em>r <sub>i</sub></em> as <em>R <sub>i</sub></em> <sub>+1</sub> , and the intermediate states after the transformations <em>S</em> , <em>P</em> and <em>L</em> as, respectively, <em>R <sub>i</sub> <sup>S</sup></em> , <em>R <sub>i</sub> <sup>P</sup></em> and <em>R <sub>i</sub> <sup>L.</sup></em>  Initial state <img width="74" height="19" src="https://habrastorage.org/getpro/habr/post_images/a14/1db/ea4/a141dbea47f5cb51a7222ff3b1de4ced.jpg">  . <br><br><h1>  3. Rebound-attack on the compression function GOST R </h1><br>  Rebound-attack is a hash function analysis technology that was first proposed by Mendel et al. [5] to attack Gr√∏stl and Whirlpool with a truncated number of rounds.  The main idea of ‚Äã‚Äãthis technology is to build a differential path using the available degrees of freedom to match fragments with low probability.  Usually it consists of an internal phase, including a search for a match in the middle (match-in-the-middle), and a subsequent probabilistic external phase. <br>  Using the rebound technology, we find collisions for the 4.5 and 5.5-round GOST R compression function. Moreover, using the available degrees of freedom of the key expansion scheme, as in [6], we amplify the results before the collisions for 7.5 and 9.5 rounds. <br><br><h2>  3.1.  Original rebound attack </h2><br>  In a rebound attack, the block cipher or hash function permutation used in the compression function is divided into three parts.  Let <em>E</em> be a block cipher, then <img width="106" height="16" src="https://habrastorage.org/getpro/habr/post_images/d53/9c6/b42/d539c6b429f70d91c457c1f621b2d7d3.jpg">  .  Rebound-attack is divided into two phases: <br><ul><li>  <strong>Internal phase</strong> : this phase starts with several selected input / output differences in <em>E <sub>in</sub></em> , which propagate through the linear level in the forward and reverse direction.  Then all possible pairs of actual values ‚Äã‚Äãare generated, which satisfy the required difference and correspond to the differences after one level of table replacement.  These actual value pairs are starting points for the external phase. </li><li>  <strong>Outer phase</strong> : matched pairs of the inner phase are used in forward and reverse calculations via <em>E <sub>fw</sub></em> and <em>E <sub>bw</sub></em> to obtain the desired collisions or near-collisions.  Usually <em>E <sub>fw</sub></em> and <em>E <sub>bw</sub></em> have a low probability, so it is necessary to repeat the internal phase to get more start points. </li></ul><br><br><h2>  3.2.  Preliminary calculations for rebound attacks </h2><br>  Before describing the rebound attack on the GOST R algorithm, we briefly describe some of the properties of its linear transformation <em>L</em> and the table replacement of the compression function. <br><ul><li>  <em>Distribution of the difference in</em> <em>L</em> : since <em>L</em> is a linear transformation, a certain input difference in <em>L</em> leads to a certain output difference.  Since <em>L</em> acts on each status line independently, the output difference of a specific line depends only on the input difference of this line.  With the only active byte of the string, the <em>L</em> transform always results in eight active bytes, both in the forward and reverse directions, regardless of the position of the active byte. </li><li>  <em>Differential properties</em> <em>S</em> : for certain <img width="79" height="20" src="https://habrastorage.org/getpro/habr/post_images/cda/cd4/a13/cdacd4a13b9c48ce0b73dc06bb8ee848.jpg">  the number of equality solutions </li></ul><br><img width="558" height="18" src="https://habrastorage.org/getpro/habr/post_images/7f9/581/72b/7f958172baa8193da8f8c75b89bbbf4e.jpg"><br>  there can be only 0, 2, 4, 6, 8 and 256, which occurs with a frequency of 38235, 22454, 4377, 444, 25 and 1, respectively.  On average, for a randomly selected differential ( <em>a</em> , <em>b</em> ), we can expect to find a single value as a solution.  And a 256 x 256 input / output difference table can help find solutions with a little computation. <br><br><h2>  3.3.  Finding collisions for the 4.5-round compression function GOST R </h2><br>  In this section, we describe the use of a rebound attack on the compression function of the GOST R algorithm, truncated to 4.5 rounds.  The core of the attack is a 4-round differential path with the following sequence of active S-boxes: <br><img width="146" height="21" src="https://habrastorage.org/getpro/habr/post_images/c1b/3c5/96a/c1b3c596a21e9e7f70548ebb9120a443.jpg"><br><br><img width="541" height="202" src="https://habrastorage.org/getpro/habr/post_images/e7f/3d7/179/e7f3d71798f67528055768984f993707.jpg"><br>  <em>Fig.</em>  <em>2. Schematic representation of the attack on 4.5 rounds of the GOST R compression function. Active status bytes are highlighted in black.</em> <br><br>  In a rebound attack, we primarily divide the block cipher <em>E</em> into three sub-codes <img width="106" height="18" src="https://habrastorage.org/getpro/habr/post_images/960/27a/548/96027a54815a6602636a18fa6abdd51b.jpg">  .  As shown in fig.  2, the most resource-intensive part of the differential path is hidden in the internal phase.  Available degrees of freedom are used to maintain the differential path in <em>E <sub>in</sub></em> . <br><br><h3>  3.3.1.  Internal phase </h3><br>  In the first step of the internal phase, we start with an 8-byte difference simultaneously at the stages <em>R</em> <sub>2</sub> <sup><em>P</em></sup> and <em>R</em> <sub>3</sub> <em><sup>L</sup></em> and move forward and backward to <em>R</em> <sub>3</sub> and <em>R</em> <sub>3</sub> <sup><em>S,</em></sup> respectively (see Fig. 2).  According to the propagation properties of the difference operation <em>L</em> , described in Section 3.2, we obtain the fully active state in both <em>R</em> <sub>3</sub> and <em>R</em> <sub>3</sub> <sup><em>S.</em></sup> <br>  In the second step of the internal phase, we perform a search for a match at the <em>S</em> level in <em>r</em> <sub>3</sub> in order to find a suitable combination of input / output difference.  As shown in section 3.2, we expect to find on average one solution for a given differential path.  It is worth noting that there are a total of <sup>2,128</sup> different differential paths, and we can get no more than <sup>2,128</sup> actual values ‚Äã‚Äãfor <em>R</em> <sub>3</sub> and <em>R</em> <sub>3</sub> <sup><em>S.</em></sup>  Since <em>k</em> <sub>3</sub> can have any value, the maximum number of start points is <sup>2,128 + 512</sup> = <sup>2,640</sup> . <br><br><h3>  3.3.2.  External phase </h3><br>  In the external phase, we use the starting points developed in the internal phase and process their values ‚Äã‚Äãin the forward and reverse directions.  As shown in fig.  2, differences in <em>R</em> <sub>2</sub> <sup><em>P</em></sup> and <em>R</em> <sub>3</sub> <sup><em>L</em></sup> lead to differences only in the first columns in <em>R</em> <sub>1</sub> and <em>R</em> <sub>5</sub> <sup><em>P,</em></sup> respectively. <br>  You can easily construct a collision for the GOST R compression function, truncated to 4.5 rounds, using the values ‚Äã‚Äãgenerated in the previous step.  Insofar as <img width="119" height="15" src="https://habrastorage.org/getpro/habr/post_images/1f7/59d/7f7/1f759d7f7e6caec88c6f6e75b7af126c.jpg">  , for identical values ‚Äã‚Äãof <em>h</em> and <em>k</em> , the same difference for <em>m</em> and <em>E</em> ( <em>k</em> , <em>m</em> ) always leads to a collision.  For a pair of values ‚Äã‚Äãgenerated on the external phase, the difference is equivalent for <em>m</em> and <em>E</em> ( <em>k</em> , <em>m</em> ) with a probability of 2 <sup>-64</sup> .  Therefore, we need to generate about 2 <sup>64</sup> start points to construct collisions.  The complexity of this is about 2 <sup>64</sup> .  Since we only need to store a table of 256 x 256 input / output differences for the replacement table, the memory requirements are only 2 <sup>16</sup> bytes. <br><br><h2>  3.4.  Finding collisions for the 5.5-round compression function GOST R </h2><br>  Using advanced replacement technology [7], we can enhance the 4.5 round result by adding one round to the internal phase.  This leads to an attack on the 5.5-round compression function of GOST R. The external phase of this attack is the same as in the attack on 4.5 rounds, and the new sequence of active S-boxes is as follows: <br><img width="185" height="18" src="https://habrastorage.org/getpro/habr/post_images/2f6/4e9/fb8/2f64e9fb8f2240c0afbc98569a1eaea5.jpg"><br><br><img width="502" height="103" src="https://habrastorage.org/getpro/habr/post_images/2ae/343/896/2ae343896792a29a9e9e5cf9a6562e77.jpg"><br>  <em>Fig.</em>  <em>3. The internal phase of the attack on the 5.5-round compression function GOST R</em> <br><br>  As shown in fig.  3, the values ‚Äã‚Äãin each row of <em>R</em> <sub>4</sub> <sup><em>S</em></sup> depend only on the corresponding column of <em>R</em> <sub>3</sub> .  In other words, knowing the pair of column values ‚Äã‚Äãat stage <em>R</em> <sub>3</sub> , since we know <em>k</em> <sub>4</sub> , we can calculate the values ‚Äã‚Äãof the corresponding row <em>R</em> <sub>4</sub> <sup><em>S.</em></sup>  Consequently, we can assume that the correspondence between each column of <em>R</em> <sub>3</sub> and the corresponding row of <em>R</em> <sub>4</sub> <sup><em>S is an</em></sup> extended replacement.  For each extended replacement with a randomly specified input and output difference, we expect to find an average of one real value. <br>  Next, we describe the attack on 5.5 rounds in detail. <br><br><h3>  3.4.1.  Internal phase </h3><br>  The internal phase of the rebound attack on 5.5 rounds of GOST R can be described as follows: <br><ol><li>  We start with a difference of 8 active bytes in the first column of <em>R</em> <sub>2</sub> <sup><em>P</em></sup> and move forward to <em>R</em> <sub>3</sub> . </li><li>  For each independent extended replacement, knowing its input difference, we process all 2 <sup>64</sup> pairs of input values ‚Äã‚Äãand calculate the forward replacement.  This gives us 2 <sup>64</sup> output difference values.  For each difference obtained, we save the corresponding pairs of input values ‚Äã‚Äãleading to it.  This phase requires about 2 <sup>64</sup> operations and memory. </li><li>  For each 8-byte difference in <em>R</em> <sub>4</sub> <sup><em>L,</em></sup> move back to <em>R</em> <sub>4</sub> <sup><em>S.</em></sup>  We check all the previously saved values ‚Äã‚Äãfor the presence of the required difference. </li></ol><br>  We can choose other differences in the <em>R</em> <sub>2</sub> <sup><em>P</em></sup> stage to get more valid values ‚Äã‚Äãthat satisfy the differences.  For the input difference in <em>R</em> <sub>2</sub> <sup><em>P,</em></sup> we propose to find about 2 <sup>64</sup> start points. <br><br><h3>  3.4.2.  External phase </h3><br>  The outer phase is the same as in the 4.5 round attack, where we need 2 <sup>64</sup> start points.  Consequently, the complexity and memory requirements for finding a 5.5-round collision are 2 <sup>64 each</sup> . <br><br><h2>  3.5.  Finding collisions for the 7.5-round compression function GOST R </h2><br>  We can improve 4.5 round results by adding 3 rounds to the internal phase by using degrees of freedom at the expense of a key expansion scheme, as in [6].  The main idea is to divide the internal phase into two subphases.  These two subphases can be subsequently combined by fully using the degrees of freedom in the key expansion procedure.  As a result, we get a collision for the compression function of GOST R, truncated to 7.5 rounds. <br>  For enhanced internal phase, we use the following sequence of active bytes: <br><img width="184" height="18" src="https://habrastorage.org/getpro/habr/post_images/d1e/d6a/b03/d1ed6ab033bea22af094a525c3b07220.jpg"><br>  The internal phase, in turn, is divided into two subphases in order to find the input values ‚Äã‚Äãcorresponding to the differential path (Fig. 4).  In the first subphase, we perform a matching search for rounds 1-2 and 4-5.  And in the second subphase, we combine the active state values ‚Äã‚Äãbetween <em>r</em> <sub>2</sub> and <em>r</em> <sub>4</sub> using degrees of freedom by selecting the value of the round key. <br><br><img width="507" height="85" src="https://habrastorage.org/getpro/habr/post_images/9f6/ebe/6f4/9f6ebe6f43bc3ede70ecf4ff62717809.jpg"><br>  <em>Fig.</em>  <em>4. The internal phase of the collision search for the 7.5-round compression function GOST R</em> <br><br><h3>  3.5.1.  Internal subphase 1 </h3><br>  In this subphase, we perform a matching search for rounds 1-2 and 4-5, which can be described as follows: <br>  1. Rounds 1-2: <br><ul><li>  We start with a difference of 8 bytes in the first column of <em>R</em> <sub>3</sub> and move in the opposite direction to <em>R</em> <sub>2</sub> <sup><em>S.</em></sup> </li><li>  For each difference of 8 bytes in the first column of <em>R</em> <sub>1</sub> <sup><em>P, we</em></sup> move forward to <em>R</em> <sub>2</sub> .  Since there are only 2 <sup>64</sup> different difference values ‚Äã‚Äãin <em>R</em> <sub>1</sub> <sup><em>P</em></sup> , we can get 2 <sup>64</sup> differences for <em>R</em> <sub>2</sub> .  After matching, these differences result in approximately 2 <sup>64</sup> valid values.  However, we can perform a match search for each row independently and get 2 to <sup>8</sup> valid values ‚Äã‚Äãfor the row.  Consequently, the laboriousness of generating 2 <sup>64</sup> actual values ‚Äã‚Äãcorresponding to the differential path is only 2 <sup>8</sup> round conversions. </li></ul><br>  2. Rounds 4-5: do the same as for rounds 1-2. <br>  Now, after performing the first subphase of the attack with a labor intensity of about 2 <sup>9</sup> round transformations, we have 2 <sup>64</sup> candidates for <em>R</em> <sub>2</sub> <sup><em>S</em></sup> , as well as for <em>R</em> <sub>5</sub> . <br><br><h3>  3.5.2.  Internal subphase 2 </h3><br>  Within the framework of the second subphase, we must combine the differences in <em>R</em> <sub>2</sub> <sup><em>S</em></sup> and the differences in <em>R</em> <sub>5</sub> , as well as the actual values, using the degrees of freedom in the key expansion scheme.  This means that we must solve the following equation: <br><img width="553" height="16" src="https://habrastorage.org/getpro/habr/post_images/259/a6f/79b/259a6f79ba9abe9dea01d71d3f6d219c.jpg"><br>  at <br><img width="557" height="33" src="https://habrastorage.org/getpro/habr/post_images/16c/e3c/fae/16ce3cfaeb0038dadee5571ecd230aad.jpg"><br>  For 2 <sup>64</sup> candidates for <em>R</em> <sub>2</sub> <sup><em>S</em></sup> and 2 <sup>64</sup> candidates for <em>R</em> <sub>5</sub> , taking into account 512 degrees of freedom of the values ‚Äã‚Äãof <em>k</em> <sub>3</sub> , <em>k</em> <sub>4</sub> and <em>k</em> <sub>5,</sub> we expect to find 2 <sup>64</sup> solutions.  Since <em>LP</em> ( <em>R</em> <sub>2</sub> <sup><em>S</em></sup> ) = <em>R</em> <sub>2</sub> <sup><em>L</em></sup> and ( <em>X</em> [ <em>k</em> <sub>5</sub> ]) <sup>-1</sup> = <em>X</em> [ <em>k</em> <sub>5</sub> ], we can rewrite (8) as follows: <br><img width="558" height="15" src="https://habrastorage.org/getpro/habr/post_images/bfe/707/fc4/bfe707fc42e0a9927b2930830894b8ec.jpg"><br>  Since we can always change the order of <em>P</em> and <em>S</em> and <br><img width="554" height="31" src="https://habrastorage.org/getpro/habr/post_images/0bf/06c/99a/0bf06c99a7d0997a6707099efd0b6d17.jpg"><br>  we get the following equation: <br><img width="557" height="19" src="https://habrastorage.org/getpro/habr/post_images/87e/5ae/78f/87e5ae78f85e682907fda445c60e76af.jpg"><br>  Enter the notation <img width="238" height="22" src="https://habrastorage.org/getpro/habr/post_images/7ea/f64/73e/7eaf6473ec22db08aab2e3d9ce51c83a.jpg">  and <em>T</em> = <em>P</em> <em><sup>-1</sup></em> <em>L <sup>-1</sup></em> ( <em>R</em> <sub>5</sub> ), then the above equation can be rewritten as: <br><img width="558" height="16" src="https://habrastorage.org/getpro/habr/post_images/b49/c48/a9b/b49c48a9bc4c34667c2a6729683dde74.jpg"><br>  The solution of this equation is equivalent to combining the differences and the values ‚Äã‚Äãof <em>R</em> <sub>2</sub> <sup><em>S</em></sup> and <em>R</em> <sub>5</sub> .  We describe the method used to solve the equation, below. <br><br><img width="503" height="71" src="https://habrastorage.org/getpro/habr/post_images/acc/be3/4bf/accbe34bf70a9c2791bd1de72fddc715.jpg"><br>  <em>Fig.</em>  <em>5. Internal subphase 2 attack by finding a collision for the 7.5-round compression function GOST R</em> <br><br>  Since the difference in <em>R</em> <sub>2</sub> <sup><em>L</em></sup> and <em>R</em> <sub>4</sub> <sup><em>S</em></sup> is fixed within subphase 1, the differences in <em>R</em> <sub>2</sub> <sup>*</sup> and <em>T are</em> also fixed.  And 2 <sup>64</sup> values ‚Äã‚Äãfor the states of <em>R</em> <sub>2</sub> <sup><em>S</em></sup> and <em>R</em> <sub>5</sub> generated on subphase 1, directly lead to 2 <sup>64</sup> values ‚Äã‚Äãfor <em>R</em> <sub>2</sub> <sup>*</sup> and <em>T,</em> respectively.  Now we can solve (15) for each row independently, as shown in fig.  5, which can be described as follows: <br>  1. Calculate 8-byte differences and 2 <sup>64</sup> values ‚Äã‚Äãfor <em>R</em> <sub>2</sub> <sup>*</sup> from <em>R</em> <sub>2</sub> <sup><em>S</em></sup> and calculate 8-bytes differences and corresponding 2 <sup>64</sup> values ‚Äã‚Äãfor <em>T</em> from <em>R</em> <sub>5</sub> .  We only need to calculate and save the string of values ‚Äã‚Äãfor <em>R</em> <sub>2</sub> <sup>*</sup> and <em>T</em> , since we can solve the equation line by line.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The complexity and memory requirements of this step are 2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">9</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> instead of 2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">65</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2. For all 2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">64</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> values ‚Äã‚Äãof the first row </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R </font></font></em> <sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3 </font></font></sub> <sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">*</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> repeat the following steps:</font></font><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Since the difference in </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R </font></font></em> <sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3 </font></font></sub> <sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">* is</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> known, for the selected value of the first row of </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R </font></font></em> <sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3 </font></font></sub> <sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">*</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> we calculate in the forward direction the values ‚Äã‚Äãof the first row of </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R </font></font></em> <sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3 </font></font></sub> <sup><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L</font></font></em></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and the difference for the first row of </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R </font></font></em> <sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></li><li>         <em>R</em> <sub>4</sub>  <em>R</em> <sub>4</sub> <sup><em>S</em></sup>        <em>R</em> <sub>4</sub> .     <em>R</em> <sub>3</sub> <sup><em>L</em></sup>  ,        <em>k</em> <sub>4</sub> . </li><li>     <em>k</em> <sub>3</sub> <sup>*</sup> , <em>R</em> <sub>2</sub> <sup>*</sup> , <em>R</em> <sub>4</sub> <sup><em>S</em></sup>  <em>T</em> .      <em>R</em> <sub>2</sub> <sup>*</sup> ,   <em>R</em> <sub>4</sub> <sup><em>S</em></sup>    2 <sup>64</sup> ,      .  ,     ,     . </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3. In this step, we combine the values ‚Äã‚Äãof rows 2‚Äì8 for the corresponding </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R </font></font></em> <sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2 </font></font></sub> <sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">*</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> obtained in the previous step. For each row, an exhaustive search is performed independently over all 2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">64</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> values ‚Äã‚Äãof the corresponding key string </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k </font></font></em> <sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3 </font></font></sub> <sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">*</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Note that we want to connect 64-bit values, and by checking 2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">64</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> key values, we expect to always find a solution. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">After all these steps, we get 2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">64</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> corresponding values, linking </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R </font></font></em> <sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2 </font></font></sub> <sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">*</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . In other words, we get 2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">64</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">starting points for the outer phase. The complexity is about 2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">128</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> of round transformations with the memory requirements of about 2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">16</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> bytes. On average, we expect to find a starting point with a labor intensity of 2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">64</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Step 3 can be skipped by using a </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2,128</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> lookup table </font><font style="vertical-align: inherit;">. Using the lookup table, we expect to find the starting point with an average complexity of 1. However, the complexity of building a lookup table is </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2,128</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , and the memory requirements are </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2,128</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> bytes. Note that there are 2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">64</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> differences for </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R </font></font></em> <sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and 2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">64</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> differences for </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R </font></font></em> <sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4 </font></font></sub> <sup><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">S</font></font></em></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">For a fixed pair of differences in </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R </font></font></em> <sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R </font></font></em> <sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4 </font></font></sub> <sup><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">S,</font></font></em></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> we expect to find 2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">64</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> starting points. </font><font style="vertical-align: inherit;">Thus, in total, we need to generate no more than 2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">192</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> start points for the external phase.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.5.3. </font><font style="vertical-align: inherit;">External phase</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The outer phase of a 7.5 round attack is similar to a 4.5 round attack. </font><font style="vertical-align: inherit;">The collision search attack for 7.5 rounds uses the following sequence of active bytes: </font></font><br><img width="251" height="19" src="https://habrastorage.org/getpro/habr/post_images/bb1/648/1dc/bb16481dce9490213d8bb6be93a7305a.jpg"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The complexity of collision search for 7.5 rounds of the GOST R compression function is about 2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">64 + 64</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = 2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">128,</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> with memory requirements of 2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">16</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> bytes.</font></font><br><br><h2>  3.6.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Finding collisions for a 9.5-round compression function GOST R </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Although we can get over 2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">192</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> start points, only 2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">64</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> of them are </font><font style="vertical-align: inherit;">required for the outer phase of the 7.5 round attack </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">We can expand the external phase by adding one round at the beginning and one round at the end to construct an attack to find collisions for a 9.5 round. </font><font style="vertical-align: inherit;">Such an attack uses the following sequence of active bytes: </font></font><br><img width="316" height="18" src="https://habrastorage.org/getpro/habr/post_images/340/167/bc6/340167bc6d557a34e0d0d65f3a63927c.jpg"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Next, we describe the external phase of the 9.5 round attack in detail.</font></font><br><br><img width="533" height="78" src="https://habrastorage.org/getpro/habr/post_images/9df/ced/d6f/9dfcedd6fbc6186bbca7ac392a792c63.jpg"><br>  <em>Fig.</em> <em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6. Schematic image of the attack for a 9.5-round compression function GOST R</font></font></em> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.6.1. </font><font style="vertical-align: inherit;">External phase</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In contrast to the external phase of the attack for 7.5 rounds, here we use truncated differentials. After the internal phase is completed, the generated values ‚Äã‚Äãresult in an 8-byte difference in </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R </font></font></em> <sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R </font></font></em> <sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , as shown in Fig. 6. We want to match the truncated differential path 8 ‚Üí 1 in both directions. The probability of this truncated differential path is 2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-56</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . A 1-byte difference in </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R </font></font></em> <sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R </font></font></em> <sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">9</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> always results in 8 active bytes for </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R </font></font></em> <sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R </font></font></em> <sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Therefore, the probability of the external phase is 2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-112</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Therefore, we must generate in 2</font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">112</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> times the starting points. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Since the collision of the compression function, truncated to 9.5 rounds, requires the same difference in </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and in </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R </font></font></em> <sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10 </font></font></sub> <sup><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P</font></font></em></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , we have to generate a total of </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2,112 + 64</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2,176</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> starting points. </font><font style="vertical-align: inherit;">As described in section 3.5, we expect to find one starting point with a complexity of 2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">64</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Therefore, the complexity of finding a collision for a 9.5 round is approximately 2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">64 + 176</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = 2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">240</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , and the memory requirements are 2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">16</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> bytes. </font><font style="vertical-align: inherit;">When using a lookup table with </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2,128</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> values, the work is </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2,176</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">with memory requirements of </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2,128</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> bytes.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 4. Distributor for 10 rounds </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In this chapter, we present the discriminator for the GOST R compression function, truncated to 10 rounds. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The type of discriminators proposed by Gilbert et al. [7] can be described as follows: for a random function that performs </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -bit permutation, mapping the input difference from a subspace of size </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> to the output difference from a subspace of size </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">J</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> requires only max { </font></font><img width="52" height="26" src="https://habrastorage.org/getpro/habr/post_images/c6b/cd0/9b5/c6bcd09b545bac4d07bbf71f7c0fecd8.gif"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, 2 </font></font><em><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b</font></font></sup></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> / ( </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IJ</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )} function calls (without loss of generality, we assume that </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ‚â§ </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">J</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">By applying </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [ </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k </font></font></em> <sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">11</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">] to the previous result for the 9.5 round, we extend the differential path to 10 rounds. Even though </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R </font></font></em> <sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">11</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is fully active in terms of truncated differentials, the differences in </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R </font></font></em> <sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">11</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> still belong to a subspace of dimension less than 64. Since the input differences of the compression function belong to a subspace of 2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">64</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , the output differences belong to a subspace of 2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">128</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . For a random function, we need </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2,512- (64 + 128)</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2,320</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> calculations to fully determine the correspondence of the input and output differences of this kind. But for the compression function, truncated to 10 rounds, the complexity is only </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2,176</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">with memory requirements of 2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">16</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> or 2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">128</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> with memory requirements of 2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">128</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">The complexity required for the compression function is much less than that for a random function. </font><font style="vertical-align: inherit;">This property can be used to distinguish the GOST-R compression function from a random function.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 5. Multicollision hash function GOST R </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now we consider the stability of the structure of the GOST R hash function. For a structure of this type, we propose a method for constructing </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k-</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> collisions. In this case, the laboriousness is substantially less than the laboriousness of constructing a </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k-</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> collision for an ideal structure. In other words, we prove that this kind of structure is not ideal. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For an ideal hash function with an </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -bit output value, the complexity of finding a pair that gives a collision is approximately 2 </font></font><sup><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> / 2</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , and for searching for </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k-</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> collisions (multicollisions) - 2 </font></font><sup><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ( </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -1) / </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k</font></font></em></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. However, based on pairwise collisions, Joux on Crypto'04 [12] proposed a method of constructing 2 </font></font><em><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t-</font></font></sup></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> collisions for an iterative structure with a total complexity of </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> x 2 </font></font><sup><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> / 2</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . As shown in fig. 7, the attacker first generates </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> different pairwise collisions {( </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B </font></font></em> <sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B </font></font></em> <sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 </font></font></sub> <sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">*</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), ( </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B </font></font></em> <sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B </font></font></em> <sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2 </font></font></sub> <sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">*</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), ..., ( </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t</font></font></sub></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t</font></font></sub></em> <sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> *</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )}. Then, the attacker can immediately get a 2 </font></font><em><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t</font></font></sup></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> collision of the form ( </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b </font></font></em> <sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b</font></font></em> <sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , ..., </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t</font></font></sub></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), where </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></sub></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is one of the two blocks </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></sub></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></sub></em> <sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> *</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><img width="294" height="81" src="https://habrastorage.org/getpro/habr/post_images/1b2/649/eae/1b2649eaead272f5f0577cf97196fad7.jpg"><br>  <em>Fig.</em> <em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7. Scheme 2 </font></font></em> <em><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t-</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jouay collisions. </font><font style="vertical-align: inherit;">2 </font></font></em> <em><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> messages have the form ( </font></font></em> <em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font></em> <em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , ..., </font></font></em> <em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), where </font></font></em> <em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is one of the two blocks </font></font></em> <em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font></em> <em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i </font></font></sub> <sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">*</font></font></sup></em> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Despite the fact that the structure of GOST R is not iterative, for it we can also construct </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k-</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> collision. </font><font style="vertical-align: inherit;">This method is as follows: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1. As shown in Fig. </font><font style="vertical-align: inherit;">8, we generate 2 </font></font><em><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t</font></font></sup></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> messages leading to the same value of </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">h </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t</font></font></sub></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">h </font></font></em> <sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> be the initial value of the </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IV</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> algorithm GOST R.</font></font></li><li>  <em>i</em>  1  <em>t</em> : <br><ul><li>   <em>B <sub>i</sub></em>  <em>B <sub>i</sub></em> <sup>*</sup> ,   <em>g <sub>N</sub></em> ( <em>h</em> <sub><em>i</em> -1</sub> , <em>B <sub>i</sub></em> ) = <em>g <sub>N</sub></em> ( <em>h</em> <sub><em>i</em> -1</sub> , <em>B <sub>i</sub></em> *),  <em>B <sub>i</sub></em>  <em>B <sub>i</sub></em> <sup>*</sup>   0 <sup>256</sup> || {0, 1} <sup>256</sup> .    2 <sup>256</sup>   ,           [13]. </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Compiling the resulting 2 </font></font><em><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t</font></font></sup></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> messages in the form ( </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b </font></font></em> <sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , ..., </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t</font></font></sub></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), where </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></sub></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is one of two blocks: </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></sub></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> or </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></sub></em> <sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> *</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></li></ul><br></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2. Among the 2 </font></font><em><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t</font></font></sup></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> messages generated in step 1, we are trying to find </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> collisions in ‚àë and get </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> messages as a result. </font><font style="vertical-align: inherit;">Note that all 2 </font></font><em><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t</font></font></sup></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> messages have the same </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> value </font><font style="vertical-align: inherit;">, and these </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> messages always result in a </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k-</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> collision hash function GOST R.</font></font><br><br><img width="435" height="92" src="https://habrastorage.org/getpro/habr/post_images/886/618/426/88661842628a18971ee89547593f7c0e.jpg"><br>  <em>Fig.</em> <em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8. Schematic representation of the construction of </font></font></em> <em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k collisions for GOST R.</font></font></em> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Since all the message blocks of step 1 are of the form 0 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">256</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> || </font><font style="vertical-align: inherit;">{0, 1} </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">256</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and ‚àë = </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b </font></font></em> <sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 </font></font></sub> <img width="10" height="10" src="https://habrastorage.org/getpro/habr/post_images/4ef/c56/912/4efc56912e303d954d092a7506d5a869.jpg"> <em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b </font></font></em> <sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sub> <img width="10" height="10" src="https://habrastorage.org/getpro/habr/post_images/4ef/c56/912/4efc56912e303d954d092a7506d5a869.jpg">  ... <img width="10" height="10" src="https://habrastorage.org/getpro/habr/post_images/4ef/c56/912/4efc56912e303d954d092a7506d5a869.jpg"> <em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t</font></font></sub></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , meaning bits in ‚àë no more than log </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2 </font></font></sub> <em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + 256. In the ideal model, step 2 requires </font></font><img width="99" height="18" src="https://habrastorage.org/getpro/habr/post_images/28f/581/a68/28f581a68110b3941bd95e3f2fe949b3.jpg"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">messages to construct </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> collisions ‚àë, which requires compliance with the following inequalities, in which </font></font><img width="52" height="16" src="https://habrastorage.org/getpro/habr/post_images/5e1/247/9d8/5e12479d83784c967908cd35beeda529.jpg"><br><img width="556" height="54" src="https://habrastorage.org/getpro/habr/post_images/ff2/b29/37f/ff2b2937fe06a754078f816a6ee5124e.jpg"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Solving the above inequalities, we have: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">176 ‚â§ </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ‚â§ 2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">256</font></font></sup> <br>  and <br><img width="395" height="50" src="https://habrastorage.org/getpro/habr/post_images/e4d/b5f/689/e4db5f689463f2c0e358a5cf26493e52.jpg"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In other words, for a </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t-</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> block message, where 176 ‚â§ </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ‚â§ 2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">256</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , we can find the </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k-</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> collision of the GOST R hash function by running only</font></font><img width="99" height="18" src="https://habrastorage.org/getpro/habr/post_images/28f/581/a68/28f581a68110b3941bd95e3f2fe949b3.jpg">  calculations<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This complexity is significantly less than the complexity of finding </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k-</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> collisions for the hash function of an ideal structure.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 6. Conclusion </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In this paper, we presented some cryptanalytic results for GOST R. At first, we described our attack on the GOST-R 4.5 compression feature using rebound attack technology. </font><font style="vertical-align: inherit;">Further, this result was enhanced to 5.5 rounds using advanced replacement technology. </font><font style="vertical-align: inherit;">Then the degrees of freedom of the key expansion scheme were used to achieve attacks on 7.5 rounds and 9.5 rounds. </font><font style="vertical-align: inherit;">Moreover, using the result of a 9.5-round attack, we presented a 10-round discriminator for the GOST R compression function. </font><font style="vertical-align: inherit;">Finally, </font><font style="vertical-align: inherit;">we presented a </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k-</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> collision </font><font style="vertical-align: inherit;">design method </font><font style="vertical-align: inherit;">for the GOST R hash function, which shows the weakness of the structure used in GOST R .</font></font><br><br><h1>  Literature </h1><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X. Wang, H. Yu. How to Break MD5 and Other Hash Functions, in: Advances in Cryptology ‚Äì EUROCRYPT 2005, Springer, 2005, pp. </font><font style="vertical-align: inherit;">19‚Äì35.</font></font></li><li> X. Wang, YL Yin, H. Yu, Finding Collisions in the Full SHA-1, in: Advances in Cryptology‚ÄìCRYPTO 2005, Springer, 2005, pp. 17‚Äì36. </li><li> V. Dolmatov, Gost R 34.11-94: Hash function algorithm. </li><li> P. Barreto, V. Rijmen, The Whirlpool Hashing Function, in: First open NESSIE Workshop, Leuven, Belgium, Vol. 13, 2000, p.  14. </li><li> F. Mendel, C. Rechberger, M. Schl√§ffer, SS Thomsen, The Rebound Attack: Cryptanalysis of Reduced Whirlpool and Gr√∏stl, in: Fast Software Encryption, Springer, 2009, pp. 260‚Äì276. </li><li> M. Lamberger, F. Mendel, C. Rechberger, V. Rijmen, M. Schl√§ffer, Rebound Distinguishers: Results on the Full Whirlpool Compression Function, in: Advances in Cryptology‚ÄìASIACRYPT 2009, Springer, 2009, pp. 126‚Äì143. </li><li> H. Gilbert, T. Peyrin, Super-sbox Cryptanalysis: Improved Attacks for AES-like Permutations, in: Fast Software Encryption, Springer, 2010, pp. 365‚Äì383. </li><li> O. Dunkelman, N. Keller, A. Shamir, Improved Single-Key Attacks on 8-Round AES-192 and AES-256, in: Advances in Cryptology-ASIACRYPT 2010, Springer, 2010, pp. 158‚Äì176. </li><li> F. Mendel, T. Peyrin, C. Rechberger, M. Schl√§ffer, Improved Cryptanalysis of the Reduced Gr√∏stl Compression Function, Echo Permutation and AES Block Cipher, in: Selected Areas in Cryptography, Springer, 2009, pp. 16‚Äì35. </li><li> D. Khovratovich, I. Nikoliƒá, C. Rechberger, Rotational Rebound Attacks on Reduced Skein, in: Advances in Cryptology-ASIACRYPT 2010, Springer, 2010, pp. 1‚Äì19. </li><li> A. Duc, J. Guo, T. Peyrin, L. Wei, Unaligned Rebound Attack: Application to Keccak, in: Fast Software Encryption, Springer, 2012, pp. 402‚Äì421. </li><li> A. Joux, Multicollisions in Iterated Hash Functions: Application to Cascaded Constructions, in: Advances in Cryptology‚ÄìCRYPTO 2004, Springer, 2004, pp. 306‚Äì316. </li><li> D. Wagner, A Generalized Birthday Problem, in: Advances in Cryptology‚ÄìCRYPTO 2002, Springer, 2002, pp. 288‚Äì304. </li></ol></div><p>Source: <a href="https://habr.com/ru/post/210684/">https://habr.com/ru/post/210684/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../210668/index.html">Two or more jobs on the same computer - free solution</a></li>
<li><a href="../210672/index.html">10 obscure Objective-C features</a></li>
<li><a href="../210676/index.html">Smartphone / clock video review iconBIT Callisto 100</a></li>
<li><a href="../210680/index.html">Do you use web components?</a></li>
<li><a href="../210682/index.html">Escene ES620 IP Phone Review with Escene ESM 32 Expansion Module</a></li>
<li><a href="../210690/index.html">The biggest battle in the history of EVE Online: destroyed ships at $ 200,000</a></li>
<li><a href="../210696/index.html">Build your dream building from LEGO right in Google Chrome</a></li>
<li><a href="../210700/index.html">How would you look for a contractor for the design and design of interfaces?</a></li>
<li><a href="../210702/index.html">[Translation] We are looking for who sent the letter from the general mailbox. Using the Microsoft Exchange Event Log</a></li>
<li><a href="../210706/index.html">Selection of random documents from the MongoDB collection</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>