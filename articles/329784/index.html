<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Node.js and cote: simple and convenient development of microservices</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Many consider that microservices are very difficult. In fact, with the right approach, this is not at all the case. 

 Microservices today are very po...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Node.js and cote: simple and convenient development of microservices</h1><div class="post__text post__text-html js-mediator-article">  Many consider that microservices are very difficult.  In fact, with the right approach, this is not at all the case. <br><br>  Microservices today are very popular, and the real adherents of this architecture almost bow to everything on which it is written "microservice."  However, if we reject fanaticism, such an approach to software development is a worthy step forward, microservices can forever change how server-side software applications are created.  Around microservices there is a lot of information noise, so it is worth highlighting the truly important properties of this architecture and work on simplifying its implementation and use where it is really needed. <br><br> <a href="https://habrahabr.ru/company/ruvds/blog/329784/"><img src="https://habrastorage.org/getpro/habr/post_images/f3a/8fd/aa8/f3a8fdaa82957e2de184c0c6b6a54fa9.jpg" alt="image"></a> <br><a name="habracut"></a><br>  If you treat microservices with caution, or feel that you are confused in this thread, know that you are not alone.  From an architectural point of view, microservices are not so simple.  The matter is aggravated by the ecosystem around them.  Instead of directly solving the complex tasks associated with working with microservices, those who are engaged in it try to get away from direct solutions, simplifying one thing and complicating the other.  As a result, this leads to the fact that we have to maintain a large set of technologies and deal with errors that cannot be debugged because of the complexity of the whole structure.  It is not easy even to check the performance of the application.  It's time to fix this situation. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Here we will step by step analyze the development of a web application based on microservices.  This example may well be your first such project, and if you are good at developing for Node.js, it will take a few minutes to get everything working. <br><br>  Before we get down to business, I would like to clarify that I am the author of the library for Node.js <a href="https://github.com/dashersw/cote">cote</a> , which simplifies and accelerates the development of microservice-based applications. <br><br><h2>  <font color="#3AC1EF">An example implementation of an application based on microservices</font> </h2><br>  There are many ways to demonstrate the implementation of microservice architecture, and, in fact, a well-developed <a href="https://github.com/dashersw/cote-workshop">example</a> is all that an experienced developer needs.  However, this material is designed for programmers with different levels of training, including beginners, so a simple but full-fledged example was chosen for the demonstration: an application for currency conversion.  We will create a system of four services, the joint work of which will allow to organize the conversion in terms of currency fluctuations. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4ec/089/2ba/4ec0892ba10f339d6b2d171ba2831e6c.png"><br>  <i><font color="#999999">Overview of services.</font></i>  <i><font color="#999999">Each of them can scale independently.</font></i>  <i><font color="#999999">Arrows indicate the direction of data flows.</font></i> <br><br>  We will create a system consisting of the following parts. <br><br><ol><li>  The client of the currency converter (conversion client) - he can request the conversion of a certain amount of money in one currency into another currency. <br><br></li><li>  Service of the currency converter (conversion service) - currency rates are known to him, he can respond to customer requests.  In addition, this microservice can accept updates regarding currency conversion rates. <br><br></li><li>  Arbitration service (arbitration service) - it maintains current exchange rate information, and, when changed, publishes updates. <br><br></li><li>  The arbitration service administration tool (arbitration admin) is a service that you can implement yourself as a home task.  It is needed to manage the arbitration service, allowing you to inform it of the need to update any currency conversion rate. </li></ol><br>  Before we get down to business, let's talk a little about the history of microservices. <br><br><h2>  <font color="#3AC1EF">Subjective view of microservice history</font> </h2><br>  Let's take a look at the past.  Ten years ago, when microservices still did not appear, service-oriented architecture (SOA, service-oriented architecture) was in high esteem.  There were hundreds of solutions for building service-oriented applications, and around this, a serious consulting business was built. <br><br>  We are going to be seven years closer to our time, here we will meet microservices.  Although at a fundamental level, they are very different from SOA, those who had previously built service-oriented applications switched to a new technology.  Everything is good, but behind these developers was luggage from the past, in which a lot of excess. <br><br>  Overnight, existing development approaches were transferred to the new environment.  Although the basic assumptions underlying microservices differed from SOA, these first solutions based on old technologies were presented to the public as ‚Äúthe only true ones‚Äù.  As a result, among other things, we had AMQP, HTTP, or even, God forbid, SOAP.  These were nginx, zookeeper, etcd, consul and several other solutions that were tried to give the appearance of the tools vital for creating microservices. <br><br>  The problem with all this was that these technologies were originally created to solve very different problems.  They were, so to speak, ‚Äúsoldered‚Äù to microservices.  However, after the developers used some of these tools to build their own services, they, at best, left a sense of temporary improvised means.  It looked like nailing with pliers.  When there is nothing more at hand, you can hammer a nail, but is it not better to look for a normal hammer? <br><br>  It was always obvious that the barrier to entry into the field of microservices is too high, although the transition to them and promised economic benefits.  However, outside the window of 2017, we all deserve better than the old technologies, with the help of which they solve new problems.  It's time to declare that in order to study, create and use microservices, in order to achieve their scaling when solving real problems, you need only Node.js. <br><br>  Now let's talk about the architecture of modern microservices. <br><br><h2>  <font color="#3AC1EF">Five requirements for microservices</font> </h2><br>  Here are the requirements that modern systems based on microservices must meet. <br><br><ol><li>  <b>Automatic system configuration</b> .  Any system based on microservices is likely to include hundreds of services.  Manual configuration of IP addresses, ports and API capabilities is almost impossible task. <br><br></li><li>  <b>High system redundancy</b> .  In the above-described system, microservices failures are quite possible, therefore, it is very important to have a mechanism for emergency switching to reserve capacity, the creation of which should not cause any special troubles and costs. <br><br></li><li>  <b>Fault tolerance of the system</b> .  The system must withstand and adequately handle abnormal events, such as network failures, errors in processing messages, timeouts, and so on.  Even if some services have ceased to function, all the rest, not connected with them, should work. <br><br></li><li>  <b>Self-healing system</b> .  Failures and all sorts of errors should be treated as completely expected phenomena.  In the implementation of the system should be incorporated automatic recovery of any lost due to a functional failure or service. <br><br></li><li>  <b>Automatic discovery of services</b> .  Existing services should automatically identify new services entered into the system, start interacting with them without manual intervention or downtime. <br></li></ol><br>  If your architecture meets these requirements and if you split the execution of most of your API requests into several independent services, then what you did is microservices. <br><br><h2>  <font color="#3AC1EF">These are not microservices.</font> </h2><br>  I would like to emphasize once again one important thing: the architecture of microservices is not tied to any particular technology.  Say, good old working queues and consumer flows are not microservices.  Mail demons, notification mechanisms, any auxiliary services that only consume events and do nothing to process user requests are not microservices. <br><br>  Is some administrative application and client program different?  This separation also does not mean the use of microservice architecture.  Server daemons that can receive and process HTTP requests ... And these are not microservices.  And what if we have a cluster of servers, the computers in which are named after the moons of Jupiter?  Does an administrator need to interfere with their work?  If yes, then there are no microservices. <br><br>  It is clear that in the wake of the popularity of the new technology it is tempting to call everything ‚Äúmicroservice architectures‚Äù everything.  However, this only creates information noise and does not allow other people to understand what microservices are and, therefore, use them in their developments. <br><br>  Microservices have always strived for minimalism.  ‚ÄúHeavy‚Äù technologies, about which they say that only they make it possible to create microservices, is the direct opposite of them. <br><br><h2>  <font color="#3AC1EF">Cote library and microservices</font> </h2><br>  Microservices built on the basis of the cote library are configured automatically.  The library uses broadcast or multicast IP-distribution, as a result, the demons on the same network find each other and automatically exchange the information necessary for setting up the connection.  In this regard, cote meets the requirements of ‚Ññ1 and ‚Ññ5: "Automatic system configuration" and "Automatic discovery of services." <br><br>  With the help of cote, it is possible to create multiple copies of services very efficiently, with low resources, while processing requests is scaled automatically.  This means that the library also corresponds to requirement No. 2: ‚ÄúHigh level of system redundancy.‚Äù <br><br>  If there are no services in the system to satisfy a certain request, cote caches it and waits until the required service is available.  Since services are usually independent, such an organization of a system means its fault tolerance, and this corresponds to requirement No. 3: ‚ÄúFault tolerance of the system‚Äù. <br><br>  The remaining requirement # 4: ‚ÄúSystem self-recovery‚Äù is fulfilled due to the use of Docker, giving the opportunity to restart services in case of failures.  Since the system runs automatic discovery of services, even if Docker decides to deploy a dropped service on a new machine, all remaining services will find it and interact with it. <br><br>  Thus, cote gives the developer complete freedom in terms of infrastructure, taking care of fulfilling the basic requirements for systems built on the basis of microservices. <br><br>  With cote, you can focus on the most important aspects of application development, leaving the library to perform supporting tasks. <br><br>  I suppose I have told in an accessible and understandable manner what real microservices are.  Now let's talk about how to implement all this. <br><br><h3>  <font color="#3AC1EF">‚ñçInstalling cote</font> </h3><br>  We will create a system based on microservices in the Node.js environment, using the <a href="https://github.com/dashersw/cote">cote</a> library, the main features of which we discussed above.  It is available as a <a href="https://npmjs.org/package/cote">npm package</a> for Node.js. <br><br>  Install the cote: <br><br><pre><code class="hljs sql">npm <span class="hljs-keyword"><span class="hljs-keyword">install</span></span> cote</code> </pre> <br><h3>  <font color="#3AC1EF">‚ñçFirst acquaintance with cote</font> </h3><br>  Whether you want to integrate cote with an existing web application, for example, based on express.js, as shown <a href="">here</a> , whether you are going to rewrite some of the monolithic application, or decide to transfer several existing microservices to cote, the job will be to create several instances cote components and use them according to your needs.  Among these components, for example - <a href="https://github.com/dashersw/cote">Responder</a> , <a href="https://github.com/dashersw/cote">Requester</a> , <a href="https://github.com/dashersw/cote">Publisher</a> , <a href="https://github.com/dashersw/cote">Subscriber</a> , you will learn more about them below.  These components are designed to interact with each other, allowing you to implement the most common application development scenarios. <br><br>  A simple application, or a very small microservice, may well be built so that one Node.js process will have to implement one cote component.  However, more complex projects require closer communication and joint work of many components and microservices.  The cote library also supports such scripts. <br><br>  Let's start with the client, whose file we call <code>conversion-client.js</code> .  Its role is to request a currency conversion operation and, upon receiving a response, perform some actions. <br><br><h2>  <font color="#3AC1EF">Implementation of the request and response mechanism</font> </h2><br>  The most common scenario of interaction between components, implemented in many applications, is a request-response cycle.  Usually, a certain microservice requests the execution of a task from another microservice, or executes a request to it and receives a response from it.  We implement a similar interaction scheme using cote. <br><br>  To begin with, in the file <code>conversion-client.js</code> , we will connect cote. <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> cote = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'cote'</span></span>);</code> </pre> <br>  Nothing special happens here - the usual library call. <br><br><h3>  <font color="#3AC1EF">‚ñçCreating Requester Component</font> </h3><br>  Let's start with the <code>Requester</code> component, which will request the execution of a currency conversion operation.  Both <code>Requester</code> and other components are constructor functions in the cote module, so they are created using the <code>new</code> keyword. <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> requester = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> cote.Requester({ name: <span class="hljs-string"><span class="hljs-string">'currency conversion requester'</span></span> });</code> </pre> <br>  As the first argument, the constructors of the cote components take an object in which, at a minimum, the <code>name</code> property must be contained, which is the name of the component that serves to identify it.  The name is mainly used as an identifier for the purpose of monitoring components; it turns out to be very useful when reading logs, since, by default, each component logs the names of other components it finds. <br><br>  The components created by the <code>Requester</code> constructor are designed to send requests, it is assumed that they will be used together with the objects that the <code>Responder</code> constructor creates that respond to requests.  If no such components are found, the <code>Requester</code> component will accumulate requests in the queue until the <code>Responder</code> appears, to which you can send these requests.  If there are several <code>Responder</code> components, <code>Requester</code> will access them using the round-robin algorithm, balancing the load on them. <br><br>  Let's create a query of type <code>convert</code> , which is designed to convert a certain amount, expressed in US dollars, into euros. <br><br><pre> <code class="hljs coffeescript">const request = { type: <span class="hljs-string"><span class="hljs-string">'convert'</span></span>, from: <span class="hljs-string"><span class="hljs-string">'usd'</span></span>, to: <span class="hljs-string"><span class="hljs-string">'eur'</span></span>, amount: <span class="hljs-number"><span class="hljs-number">100</span></span> }; requester.send(request, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(res)</span></span></span><span class="hljs-function"> =&gt;</span></span> {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(res); });</code> </pre> <br>  Recall that so far we have worked in the file <code>conversion-client.js</code> .  Here, just in case, its full code. <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> cote = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'cote'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> requester = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> cote.Requester({ <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'currency conversion requester'</span></span> }); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> request = { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'convert'</span></span>, <span class="hljs-attr"><span class="hljs-attr">from</span></span>: <span class="hljs-string"><span class="hljs-string">'usd'</span></span>, <span class="hljs-attr"><span class="hljs-attr">to</span></span>: <span class="hljs-string"><span class="hljs-string">'eur'</span></span>, <span class="hljs-attr"><span class="hljs-attr">amount</span></span>: <span class="hljs-number"><span class="hljs-number">100</span></span> }; requester.send(request, (res) =&gt; {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(res); });</code> </pre> <br>  To execute this file, use the following command: <br><br><pre> <code class="hljs pgsql">node <span class="hljs-keyword"><span class="hljs-keyword">conversion</span></span>-client.js</code> </pre> <br>  Now, the query does not lead to anything useful, there is not even a log in the console, because in our system there is still no component capable of responding to the request and returning something in response. <br><br>  Let this node.js process be executed, but for now let's deal with the <code>Responder</code> component, which can respond to requests. <br><br><h3>  <font color="#3AC1EF">‚ñç Creating the Responder component</font> </h3><br>  First, like last time, we connect the cote and create an instance of the <code>Responder</code> object using the <code>new</code> keyword. <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> cote = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'cote'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> responder = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> cote.Responder({ <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'currency conversion responder'</span></span> });</code> </pre> <br>  This part of our system will be represented by the file <code>conversion-service.js</code> .  Each <code>Responder</code> , among other things, is an instance of an <code>EventEmitter2</code> object.  The answer to a certain request, say, of the type <code>convert</code> , is the same as listening for the <code>convert</code> event and processing it with a function that takes two parameters ‚Äî the request and the callback function.  The request parameter contains information about a single request; in general, it is the same <code>request</code> object that was sent by the <code>Requester</code> component discussed above.  The second parameter is a callback function that is called with the transfer of what should be sent in response. <br><br>  Here is how a simple implementation of the above mechanism looks like. <br><br><pre> <code class="hljs coffeescript">const rates = { usd_eur: <span class="hljs-number"><span class="hljs-number">0.91</span></span>, eur_usd: <span class="hljs-number"><span class="hljs-number">1.10</span></span> }; responder.<span class="hljs-literal"><span class="hljs-literal">on</span></span>(<span class="hljs-string"><span class="hljs-string">'convert'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(req, cb)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  ,           cb(req.amount * rates[`<span class="javascript"><span class="javascript">${req.from}_${req.to}</span></span>`]); });</code> </pre> <br>  Here is the complete code for the file <code>conversion-service.js</code> . <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> cote = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'cote'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> responder = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> cote.Responder({ <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'currency conversion responder'</span></span> }); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> rates = { <span class="hljs-attr"><span class="hljs-attr">usd_eur</span></span>: <span class="hljs-number"><span class="hljs-number">0.91</span></span>, <span class="hljs-attr"><span class="hljs-attr">eur_usd</span></span>: <span class="hljs-number"><span class="hljs-number">1.10</span></span> }; responder.on(<span class="hljs-string"><span class="hljs-string">'convert'</span></span>, (req, cb) =&gt; {   cb(req.amount * rates[<span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${req.</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">from</span></span></span></span><span class="hljs-string"><span class="hljs-subst">}</span></span></span><span class="hljs-string">_</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${req.to}</span></span></span><span class="hljs-string">`</span></span>]); });</code> </pre> <br>  Save the file, and, in the new terminal, execute it with the node: <br><br><pre> <code class="hljs pgsql">node <span class="hljs-keyword"><span class="hljs-keyword">conversion</span></span>-service.js</code> </pre> <br>  Immediately after starting the service, you will see how the first request received from <code>conversion-client.js</code> will be executed.  Information about this will go to the log.  As a matter of fact, knowing everything that we just talked about, you can already start creating your own microservices. <br><br>  Note that we did not configure IP addresses, ports, host names, or anything else.  And also - congratulations!  You have just created your first set of microservices. <br><br>  Now, in different terminals, you can run multiple copies of each service and make sure that all this works fine.  Stop several conversion services, restart them, and you will see that the system we have created meets the requirements for modern microservices.  If you want to scale a project, deploy it on several servers or in several data centers, you can either use your own solution or use Docker features that allow you to solve many problems of infrastructure management. <br><br>  Let us further develop our currency converter. <br><br><h2>  <font color="#3AC1EF">Tracking system changes using the publisher-subscriber mechanism</font> </h2><br>  One of the advantages of systems built on the basis of microservices is that it is very easy to implement mechanisms in them that used to require serious investments in infrastructure.  Among the tasks solved by such mechanisms are the management of updates and tracking changes in the system.  Previously, this required, at a minimum, a branching queue infrastructure.  Such things are not easy to scale, they are difficult to manage, it was one of the limiting factors for the development of such systems. <br><br>  The cote library solves such problems in a completely natural and intuitive way. <br><br>  Suppose we need an arbitration service that sets currency rates, and, if there are changes, notifies all instances of the converter services that they need to use the new rate values. <br><br>  The most important thing here is the notification of all instances of the converter services.  In a highly available application based on microservices, we can expect the presence of several identical services between which the load is distributed.  When currency rates are updated, all these services should be informed of the changes.  If there was only one converter service in the application, it would be easy to implement this with the help of the request-response mechanism.  But since we are striving for a scalable architecture, we don‚Äôt want to limit ourselves to the number of simultaneously running services, we need a mechanism that notifies each of these services, moreover, it is necessary that they all receive such notifications at the same time.  In cote, this is achievable through the mechanism of publishers and subscribers. <br><br>  Of course, the arbitration service itself is not independent, it must be managed through some kind of API, so that it can receive information about new courses through special requests.  As a result, for example, the administrator will be able to enter information about new courses into the system, which, as a result, will reach the converter services.  In order to achieve this, the arbitration service must include two components.  One of them is the <code>Responder</code> component, which is responsible for implementing the course update API from an external source, and the second is the <code>Publisher</code> component, which publishes updates notifying the converter services.  In addition to this, the converter services themselves must include the <code>Subscriber</code> component, which will allow them to sign up for course updates.  Let's see how to do it all. <br><br><h3>  <font color="#3AC1EF">‚ñçCreation of arbitration service</font> </h3><br>  Develop arbitration service.  First, let's connect the cote and create a <code>Responder</code> object for the API.  And now - a small, but very important detail regarding the creation of microservices using cote.  Since <code>Requester</code> objects are configured automatically, each of them connects to each <code>Responder</code> object that it can detect, regardless of the types of requests that this <code>Responder</code> can respond to.  This means that each <code>Responder</code> must respond to exactly the same set of requests, since <code>Requester</code> objects will distribute the load among all <code>Responder</code> objects to which they are connected, regardless of their capabilities, that is, without paying attention to whether they can handle requests of a particular type. <br><br>  In this case, we are going to create a <code>Responder</code> component for a set of requests that is different from the one that microservices existing in the system can handle.  This means that we need the new <code>Responder</code> different from the usual services that serve requests of type <code>convert</code> .  In cote, you can do this by specifying the component key.  Keys - the easiest way to control the interaction of services.  Here's how to create a <code>Responder</code> component for arbitration service. <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> cote = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'cote'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> responder = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> cote.Responder({ <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'arbitration API'</span></span>, <span class="hljs-attr"><span class="hljs-attr">key</span></span>: <span class="hljs-string"><span class="hljs-string">'arbitration'</span></span> });</code> </pre> <br>  Now we need a mechanism for tracking currency rates in the system.  Let's say they are stored in a local variable in the scope of the module.  This may well be the database to which the service is accessed, but in order not to complicate the example, let it be a local variable. <br><br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> rates = {};</code> </pre> <br>  Now the <code>Responder</code> component will have to respond to requests such as <code>update rate</code> , allowing the administrator to update currency rates using the service application.  At the moment, the integration of our system with an auxiliary application, something like an administrator's office, is not important, however, here is <a href="https://github.com/dashersw/cote-workshop/tree/master/admin">an example</a> of how such an application can interact with <code>Responder</code> components implemented using cote running on the server.  The arbitration service must have a <code>Responder</code> component that can receive information about new exchange rates. <br><br><pre> <code class="hljs coffeescript">responder.<span class="hljs-literal"><span class="hljs-literal">on</span></span>(<span class="hljs-string"><span class="hljs-string">'update rate'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(req, cb)</span></span></span><span class="hljs-function"> =&gt;</span></span> {   rates[req.currencies] = req.rate; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> { currencies: <span class="hljs-string"><span class="hljs-string">'usd_eur'</span></span>, rate: <span class="hljs-number"><span class="hljs-number">0.91</span></span> }   cb(<span class="hljs-string"><span class="hljs-string">'OK!'</span></span>); });</code> </pre> <br>  As an exercise, you can create the <code>Requester</code> component so that, for example, it periodically makes requests like <code>update rate</code> , changing courses.  Name the file with this mechanism <code>arbitration-admin.js</code> and inject something like a timer based on <code>setInterval</code> , which gives out different currency exchange rates for the arbitration service each time. <br><br><h3>  <font color="#3AC1EF">‚ñçCreate a Publisher component</font> </h3><br>  Now we have a mechanism for updating currency rates, but the rest of the system knows nothing about it.  In particular, we are talking about currency conversion services.  In order to inform them of course changes, it is necessary, in the arbitration service, to use the <code>Publisher</code> component. <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> publisher = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> cote.Publisher({ name: <span class="hljs-string"><span class="hljs-string">'arbitration publisher'</span></span> });</code> </pre> <br>  Now, when updating courses, you need to take advantage of the features of this component.  As a result, an <code>update rate</code> request handler will need to be edited as shown below. <br><br><pre> <code class="hljs coffeescript">responder.<span class="hljs-literal"><span class="hljs-literal">on</span></span>(<span class="hljs-string"><span class="hljs-string">'update rate'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(req, cb)</span></span></span><span class="hljs-function"> =&gt;</span></span> {   rates[req.currencies] = req.rate;   cb(<span class="hljs-string"><span class="hljs-string">'OK!'</span></span>);   publisher.publish(<span class="hljs-string"><span class="hljs-string">'update rate'</span></span>, req); });</code> </pre> <br>  Now the work on the arbitration service is completed, below, as usual, its full code is shown, which should be in the <code>arbitration-service.js</code> file. <br><br><pre> <code class="hljs php"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> cote = <span class="hljs-keyword"><span class="hljs-keyword">require</span></span>(<span class="hljs-string"><span class="hljs-string">'cote'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> responder = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> cote.Responder({ name: <span class="hljs-string"><span class="hljs-string">'arbitration API'</span></span>, key: <span class="hljs-string"><span class="hljs-string">'arbitration'</span></span> }); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> publisher = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> cote.Publisher({ name: <span class="hljs-string"><span class="hljs-string">'arbitration publisher'</span></span> }); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> rates = {}; responder.on(<span class="hljs-string"><span class="hljs-string">'update rate'</span></span>, (req, cb) =&gt; {   rates[req.currencies] = req.rate;   cb(<span class="hljs-string"><span class="hljs-string">'OK!'</span></span>);   publisher.publish(<span class="hljs-string"><span class="hljs-string">'update rate'</span></span>, req); });</code> </pre> <br>  As long as there are no subscribers to the course update events in the system, the converter services do not recognize that the currency rates have changed.  In order for the publisher-subscriber mechanism to work, you need to return to the <code>conversion-service.js</code> file that you already know and add the <code>Subscriber</code> component to it. <br><br><h3>  <font color="#3AC1EF">‚ñçCreate a Subscriber component</font> </h3><br>  The order of working with components of the <code>Subscriber</code> type is no different from other components.  Create, in the file <code>conversion-service.js</code> , a new instance of the corresponding object. <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> subscriber = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> cote.Subscriber({ name: <span class="hljs-string"><span class="hljs-string">'arbitration subscriber'</span></span> });</code> </pre> <br>  <code>Subscriber</code> objects extend the functionality of <code>EventEmitter2</code> objects, and although these services can run on computers located on different continents, any new data coming from the publisher will ultimately be perceived by the subscriber as an event that needs to be processed. <br><br>  Let's add the following code to <code>conversion-service.js</code> , which will allow listening to updates that the arbitration service publishes. <br><br><pre> <code class="hljs pgsql">subscriber.<span class="hljs-keyword"><span class="hljs-keyword">on</span></span>(<span class="hljs-string"><span class="hljs-string">'update rate'</span></span>, (<span class="hljs-keyword"><span class="hljs-keyword">update</span></span>) =&gt; {   rates[<span class="hljs-keyword"><span class="hljs-keyword">update</span></span>.currencies] = <span class="hljs-keyword"><span class="hljs-keyword">update</span></span>.rate; });</code> </pre> <br>  That's all.  After all our microservices are launched, the conversion services will be synchronized with the arbitration service, receiving messages published by it.  Conversion requests coming after updating courses will be executed with fresh data in mind. <br><br>  We have just created three services, the joint work of which allowed us to implement a currency conversion system based on a microservice architecture.  Here is a <a href="https://github.com/dashersw/cote-examples-currency-conversion">repository</a> on GitHub, in which you can find all three microservices we were involved in here, and a service for automatic updating of currency rates.  If you want, clone the repository and experiment with its contents. <br><br><h2>  <font color="#3AC1EF">What's next?</font> </h2><br>  If the topic of developing microservices using cote is interesting for you, take a look at <a href="https://github.com/dashersw/cote">the</a> library <a href="https://github.com/dashersw/cote">repository</a> on GitHub, <a href="http://slack.cotejs.org/">join</a> our community on Slack.  The project needs active participants, so if you want to make a contribution to turning microservices into a widespread, accessible tool for everyone, let us know. <br><br>  Here is another <a href="https://github.com/dashersw/cote-workshop">repository</a> in which you can find an advanced example representing the implementation of a simple cote based e-commerce application.  In this example, in particular, there is the following. <br><br><ul><li>  An administrative application with real-time updates to manage your product catalog and display sales information using the RESTful API (express.js). <br><br></li><li>  The page for customer users, through which they can buy goods.  It is also updated in real time, using WebSockets (socket.io) technology. <br><br></li><li>  Microservice to serve the needs of users performing CRUD operations. <br></li><li>  Microservice for working with products, again, implementing CRUD operations. <br></li><li>  Microservice, allowing customers to make purchases. <br></li><li>  Payment microservice that deals with the processing of financial transactions arising as a result of purchases of goods. <br></li><li>  Docker Compose configuration for local system startup. <br></li><li>  Docker cloud configuration to run the system in Docker Cloud. <br></li></ul><br>  If you want to experiment with a cote at Docker or Docker Cloud, here <a href="https://youtu.be/r_ijnhvrUD4">‚Äôs a</a> webinar <a href="https://youtu.be/r_ijnhvrUD4">recording</a> .  Here you will find a step-by-step guide, which, from scratch, demonstrates the creation of a working system based on microservices that supports scaling and continuous integration. <br><br><h2>  <font color="#3AC1EF">Results</font> </h2><br>  In this article we, very briefly, discussed the topic of developing applications based on microservices.  This is an introduction to microservice architecture, a general overview of the development methodology.  However, although the application we created here consists of only a few lines of code, the same approach can be used on much larger projects.  It should be noted that we considered the cote library only in general terms. <br><br>  I suppose we are on the verge of very interesting times when you can observe a change in approaches to software development.  I warmly support the simplification path that the web development industry is following.  The <a href="https://github.com/dashersw/cote">cote</a> library is one of the steps along this path, and, in fact, this is just the beginning.  I hope this material helped those who thought about microservices, but did not dare to introduce them into their projects. <br><br>  Dear readers!  Do you use microservices in your development? </div><p>Source: <a href="https://habr.com/ru/post/329784/">https://habr.com/ru/post/329784/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../329774/index.html">Biometrics: not as difficult as it seems</a></li>
<li><a href="../329776/index.html">Why it was worth visiting OS Day 17</a></li>
<li><a href="../329778/index.html">Brief history of random numbers</a></li>
<li><a href="../329780/index.html">Chrome won</a></li>
<li><a href="../329782/index.html">Create your own Angular 2</a></li>
<li><a href="../329786/index.html">WebVR: the rebirth of virtual reality</a></li>
<li><a href="../329788/index.html">HexRaysPyTools: decompile with pleasure</a></li>
<li><a href="../329792/index.html">SCCM Inventory</a></li>
<li><a href="../329794/index.html">Once again about storing logs in Zabbix</a></li>
<li><a href="../329796/index.html">Many pointless conversations</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>