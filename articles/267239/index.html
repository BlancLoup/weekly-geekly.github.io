<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>In the wake of C ++ Siberia: a dragon in a bag</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Conferences are different. Some gather huge crowds of spectators, others may be of interest only to one and a half specialists. 

 Another thing is fu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>In the wake of C ++ Siberia: a dragon in a bag</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/4d2/e5f/b4a/4d2e5fb4a3b64e31977ad3c5de2a34ca.png" align="left">  Conferences are different.  Some gather huge crowds of spectators, others may be of interest only to one and a half specialists. <br><br>  Another thing is funny: it often happens that the hall gathers a large number of listeners who are curious about the topic, they ask questions and later enthusiastically talk about their experiences to their colleagues.  At the same time, the recording of this event collects disproportionately less views than the seals on YouTube.  I suppose that videos are banal lost in the vast video hosting sites and cannot find viewers.  This annoying fact must be corrected! <br><br>  In fact, the post is not about that. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      It just so happened that I had the opportunity to speak at the <a href="http://meetingcpp.ru/%3Fpage_id%3D722">aforementioned conference</a> , where I told my fingers and priples <a href="http://llvm.org/pubs/2008-10-04-ACAT-LLVM-Intro.html">what LLVM is</a> , why <a href="https://en.wikipedia.org/wiki/Static_single_assignment_form">SSA notation is</a> interesting, what <a href="http://llvm.org/docs/LangRef.html">IR code is</a> and, finally, how does it seem that C ++ programs that are seemingly at first glance It turns out to provoke <a href="https://en.wikipedia.org/wiki/Undefined_behavior">indefinite behavior</a> . <br><br>  By the way, this report can be put in the fifth number in a series of articles about <a href="https://github.com/0x7CFE/llst">the Smalltalk virtual machine</a> .  Many asked for more details about LLVM.  In general, we kill all the hares at once.  Interested, I suggest to ‚Äúsit back‚Äù, optionally pour something interesting and listen.  I promise that I will not take more than an hour. <br><br>  Oh yeah, under the cut, you can find explanations of those moments that were not given due attention at the conference.  I tried to answer the frequently asked questions and analyze the LLVM IR listings in detail.  In principle, the text part of the article can be read as an independent work, however, I hoped that the reader would turn to it after watching the video. <br><br><iframe width="560" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/dM2BfeppYcM%3Ffeature%3Doembed&amp;xid=17259,15700023,15700186,15700191,15700248,15700253&amp;usg=ALkJrhggA0wTC_NRjZPo_qTjxezBJp_kfw" frameborder="0" allowfullscreen=""></iframe><br><a name="habracut"></a><br><h4>  Problem with strict aliasing violation </h4><br>  In the report, I mentioned the situation with the conversion of pointers to different types, which can violate the rule strict aliasing.  Unfortunately, I called the problem, but there is no solution. <br><br>  So, the code: <br><br><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">invert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> f)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>* raw = <span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>*&gt;(&amp;f); *raw ^= (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">31</span></span>); <span class="hljs-comment"><span class="hljs-comment">//   return * reinterpret_cast&lt;float*&gt;(raw); }</span></span></code> </pre> <br>  As mentioned, the problem is the unsafe conversion of a pointer to <code>float</code> to a pointer to <code>uint32_t</code> .  If the <code>-no-strict-aliasing</code> option was specified during compilation, then the code will work exactly as intended, but if not ... How to solve the problem without shooting the limbs? <br><br>  There are three solutions to this problem - two are correct and one is conditionally safe. <br><br><h4>  The correct solution is number one - copy </h4><br>  Copying memory regions is guaranteed safe operation.  In this case, the compiler will not try to make assumptions about the nature of pointers and the possibility of their intersection in memory: <br><br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">invert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> f)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> raw = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">memcpy</span></span>(&amp;raw, &amp;f, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)); raw ^= (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">31</span></span>); <span class="hljs-comment"><span class="hljs-comment">//   memcpy(&amp;f, &amp;raw, sizeof(float)); return f; }</span></span></code> </pre><br>  What's interesting: the compiler will definitely notice that the copied regions are always set uniquely and with a fixed size, and therefore can replace the call to the system function <code>memcpy()</code> with register operations, if both values ‚Äã‚Äãare on his hands (and so, most likely will be).  Thus, there is no overhead to use a function call. <br><br><h4>  The correct solution is number two - use char * </h4><br>  The <code>char</code> type and pointers to it are interpreted by the compiler in a special way.  First, the standard requires that the <code>char</code> type <b>always</b> occupies <b>exactly 1 byte of</b> memory.  Unlike numeric types, the size of <code>char</code> is set strictly. <br><br>  Secondly, the compiler allows the <code>char*</code> pointer to store addresses of arbitrary chunks of memory, that is, to point to objects of different types.  By standard, <code>char*</code> is considered compatible (‚Äúaliases everything‚Äù) with all other pointers in strict aliasing terms.  Working with memory through <code>char*</code> safe, subject to <a href="https://en.wikipedia.org/wiki/Endianness">endianness</a> and alignment. <br><br>  So with <i>great reservations</i> (on x86), you can write this: <br><br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">invert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> f)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> raw = <span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*&gt;(&amp;f) + <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>) - <span class="hljs-number"><span class="hljs-number">1</span></span>; *raw ^= <span class="hljs-number"><span class="hljs-number">0x80</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   return * reinterpret_cast&lt;float*&gt;(raw); }</span></span></code> </pre><br>  Of course, the real code must take into account the order of bytes on the platform and select the desired byte for the operation. <br><br><h4>  Conditionally safe solution - use union </h4><br>  We come to the most controversial part, which has always caused a lot of controversy. <br><br>  First, I‚Äôll give the code: <br><br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">invert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> f)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> as_int; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> as_float; }; as_float = f; <span class="hljs-comment"><span class="hljs-comment">//   as_int ^= (1 &lt;&lt; 31); //   return as_float; //   }</span></span></code> </pre><br>  So, the standard says that you can not do that.  According to the standard, <b>union</b> can only be used to save and reuse memory for different types of data.  The standard considers that only the value that was written before should always be read.  Writing one type and then reading another - undefined behavior. <br><br>  In nature, there is a huge amount of code that violates this rule.  If compilers followed the letter of the law, then everything would be absolutely bad.  Fortunately, and perhaps unfortunately, all compilers known to me turn a blind eye to such a prank.  Accordingly, the code will work.  But the decision is bad because it is based on a blind belief that everything will be fine and ‚Äúit works for me‚Äù. <br><br>  Such are the kitty pies ... <br><br><h4>  Debriefing with IR code </h4><br>  In the second part of the article, I will give a detailed analysis of the IR code for the array counting algorithm discussed in the report. <br><br>  To begin with, the listing itself in the form in which it was presented on slide 21: <br><br><pre> <code class="hljs mel"><span class="hljs-number"><span class="hljs-number">1</span></span> ; Function Attrs: nounwind readonly <span class="hljs-number"><span class="hljs-number">2</span></span> define i32 @sum_array(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>*, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(i32* nocapture readonly %input, i32 %length) #<span class="hljs-number"><span class="hljs-number">0</span></span> { <span class="hljs-number"><span class="hljs-number">3</span></span> %1 = icmp sgt i32 %length, <span class="hljs-number"><span class="hljs-number">0</span></span> ;     ? <span class="hljs-number"><span class="hljs-number">4</span></span> br i1 %1, label %.lr.ph, label %._crit_edge <span class="hljs-number"><span class="hljs-number">5</span></span> ._crit_edge: <span class="hljs-number"><span class="hljs-number">6</span></span> %sum<span class="hljs-number"><span class="hljs-number">.0</span></span>.lcssa = phi i32 [ <span class="hljs-number"><span class="hljs-number">0</span></span>, %0 ], [ %4, %.lr.ph ] <span class="hljs-number"><span class="hljs-number">7</span></span> ret i32 %sum<span class="hljs-number"><span class="hljs-number">.0</span></span>.lcssa ;   <span class="hljs-number"><span class="hljs-number">8</span></span> .lr.ph: <span class="hljs-number"><span class="hljs-number">9</span></span> %i<span class="hljs-number"><span class="hljs-number">.02</span></span> = phi i32 [ %5, %.lr.ph ], [ <span class="hljs-number"><span class="hljs-number">0</span></span>, %0 ] <span class="hljs-number"><span class="hljs-number">10</span></span> %sum<span class="hljs-number"><span class="hljs-number">.01</span></span> = phi i32 [ %4, %.lr.ph ], [ <span class="hljs-number"><span class="hljs-number">0</span></span>, %0 ] <span class="hljs-number"><span class="hljs-number">11</span></span> ;            <span class="hljs-number"><span class="hljs-number">12</span></span> %2 = getelementptr inbounds i32, i32* %input, i32 %i<span class="hljs-number"><span class="hljs-number">.02</span></span> <span class="hljs-number"><span class="hljs-number">13</span></span> %3 = load i32, i32* %2, <span class="hljs-keyword"><span class="hljs-keyword">align</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-number"><span class="hljs-number">14</span></span> ;      <span class="hljs-number"><span class="hljs-number">15</span></span> %4 = add nsw i32 %3, %sum<span class="hljs-number"><span class="hljs-number">.01</span></span> ;   sum <span class="hljs-number"><span class="hljs-number">16</span></span> %5 = add nuw nsw i32 %i<span class="hljs-number"><span class="hljs-number">.02</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span> ;   i <span class="hljs-number"><span class="hljs-number">17</span></span> ;   <span class="hljs-number"><span class="hljs-number">18</span></span> %exitcond = icmp eq i32 %5, %length <span class="hljs-number"><span class="hljs-number">19</span></span> ;      <span class="hljs-number"><span class="hljs-number">20</span></span> br i1 %exitcond, label %._crit_edge, label %.lr.ph <span class="hljs-number"><span class="hljs-number">21</span></span> }</code> </pre><br>  So, the listing starts with a function declaration with the name " <code>sum_array(int*, int)</code> ", which takes two parameters with the types <code>i32*</code> and <code>i32</code> and returns <code>i32</code> .  Yes, all that is written in quotes and there is a name.  LLVM does not impose restrictions on naming identifiers.  The only requirement is the uniqueness of the string.  Therefore, clang for simplicity of perception places the entire prototype of the function in the name. <br><br>  As in C-like languages, the function declaration first comes with the return value type, then the name itself, and then the parameters.  The second pair of parentheses is a section describing the function parameters.  About the types we have already said, it remains to deal with keywords. <br><br>  The <b>nocapture keyword</b> tells LLVM that the function does not save the passed pointer and does not write it to external memory.  This information can be used by the analyzer to determine the fact that the pointer does not ‚Äúleak‚Äù.  A typical use is <a href="https://en.wikipedia.org/wiki/Escape_analysis">escape analysis</a> and optimization, which turns heap allocation into a stack, if the optimizer can prove that the pointer does not leave the execution context.  The result is a minus one memory allocation for each call. <br><br>  The <b>readonly</b> keyword has the same semantics as the <b>const</b> specifier when declaring a pointer to a constant in C ++.  Thus it is guaranteed that the function does not change the contents of the memory according to such a pointer. <br><br>  Lines <b>3</b> and <b>4</b> are the quick cut-off, if 0 was passed to the <code>%length</code> parameter, lines <b>6</b> and <b>7</b> are the exit point of the function. <br><br><pre> <code class="hljs mel"><span class="hljs-number"><span class="hljs-number">3</span></span> %1 = icmp sgt i32 %length, <span class="hljs-number"><span class="hljs-number">0</span></span> ;   %length   <span class="hljs-number"><span class="hljs-number">4</span></span> br i1 %1, label %.lr.ph, label %._crit_edge ;   ,    %.lr.ph,   %._crit_edge <span class="hljs-number"><span class="hljs-number">5</span></span> ._crit_edge: ;    <span class="hljs-number"><span class="hljs-number">0</span></span>,       %0  %4,    %.lr.ph (. ) <span class="hljs-number"><span class="hljs-number">6</span></span> %sum<span class="hljs-number"><span class="hljs-number">.0</span></span>.lcssa = phi i32 [ <span class="hljs-number"><span class="hljs-number">0</span></span>, %0 ], [ %4, %.lr.ph ] ;  %sum<span class="hljs-number"><span class="hljs-number">.0</span></span>.lcssa     <span class="hljs-number"><span class="hljs-number">7</span></span> ret i32 %sum<span class="hljs-number"><span class="hljs-number">.0</span></span>.lcssa</code> </pre><br>  The following is the main body of the function - the algorithm itself for counting the sum of the elements of an array: <br><br><pre> <code class="hljs mel"><span class="hljs-number"><span class="hljs-number">8</span></span> .lr.ph: <span class="hljs-number"><span class="hljs-number">9</span></span> %i<span class="hljs-number"><span class="hljs-number">.02</span></span> = phi i32 [ %5, %.lr.ph ], [ <span class="hljs-number"><span class="hljs-number">0</span></span>, %0 ] ;   ‚Äî  <span class="hljs-number"><span class="hljs-number">0</span></span>,       (%5) <span class="hljs-number"><span class="hljs-number">10</span></span> %sum<span class="hljs-number"><span class="hljs-number">.01</span></span> = phi i32 [ %4, %.lr.ph ], [ <span class="hljs-number"><span class="hljs-number">0</span></span>, %0 ] ;   ‚Äî  <span class="hljs-number"><span class="hljs-number">0</span></span>,      (%4) <span class="hljs-number"><span class="hljs-number">11</span></span> ;      %input   %i<span class="hljs-number"><span class="hljs-number">.02</span></span> <span class="hljs-number"><span class="hljs-number">12</span></span> %2 = getelementptr inbounds i32, i32* %input, i32 %i<span class="hljs-number"><span class="hljs-number">.02</span></span> <span class="hljs-number"><span class="hljs-number">13</span></span> %3 = load i32, i32* %2, <span class="hljs-keyword"><span class="hljs-keyword">align</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-number"><span class="hljs-number">14</span></span> ;      <span class="hljs-number"><span class="hljs-number">15</span></span> %4 = add nsw i32 %3, %sum<span class="hljs-number"><span class="hljs-number">.01</span></span> ;    ‚Äî     (%3)   (%sum<span class="hljs-number"><span class="hljs-number">.01</span></span>) <span class="hljs-number"><span class="hljs-number">16</span></span> %5 = add nuw nsw i32 %i<span class="hljs-number"><span class="hljs-number">.02</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span> ;    ‚Äî  <span class="hljs-number"><span class="hljs-number">1</span></span>     %i<span class="hljs-number"><span class="hljs-number">.02</span></span> <span class="hljs-number"><span class="hljs-number">17</span></span> ;   ‚Äî        %length <span class="hljs-number"><span class="hljs-number">18</span></span> %exitcond = icmp eq i32 %5, %length <span class="hljs-number"><span class="hljs-number">19</span></span> ;     ‚Äî    %._crit_edge,    %.lr.ph <span class="hljs-number"><span class="hljs-number">20</span></span> br i1 %exitcond, label %._crit_edge, label %.lr.ph</code> </pre><br>  I think everything here should be clear from the comments in the listing itself.  Nevertheless, it is worth noting a couple of points. <br><br>  First, novice LLVM programmers are often confused by the ‚Äúmagic‚Äù <a href="http://llvm.org/docs/GetElementPtr.html">instruction <b>getelementpointer</b></a> (GEP).  In fact, all it does is calculate the offset of the field in the data type, taking into account the base address of the object and a series of indices - the paths to the elements.  In the case of an array, we have only one dimension ‚Äî a linear sequence of elements.  Accordingly, the element offset by index is calculated trivially.  In the case of a complex structure with nested elements, it is necessary to set the field index at each nesting level. <br><br>  For details, I suggest contacting the <a href="http://llvm.org/docs/LangRef.html">LLVM manual for this instruction</a> and a <a href="http://llvm.org/docs/GetElementPtr.html">special article</a> designed to resolve misunderstandings. <br><br>  Secondly, you should pay attention to the specifiers <b>nsw</b> and <b>nuw</b> in the <b>add</b> instructions <b>on</b> lines <b>15</b> and <b>16</b> . <br><br>  Literally, they tell LLVM that the execution result does not imply signed ( <b>n</b> o <b>s</b> igned <b>w</b> rap) and unsigned ( <b>n</b> o <b>u</b> nsigned <b>w</b> rap) overflows.  They allow you to speed up the code at the cost of undefined behavior, if the assumption is false. <br><br>  The concept of <a href="http://llvm.org/docs/LangRef.html">value poisoning</a> is closely associated with these concepts and with UB, about which one should also be read. <br><br><h4>  Conclusion </h4><br>  Finally, I want to sincerely thank Sergey Platonov - <a href="https://habrahabr.ru/users/sermp/" class="user_link">sermp</a> .  Without him, this event would not take place.  Especially when you consider what it cost him.  Thank you, Seryoga! <br><br>  From my point of view, C ++ Siberia is one of the best C ++ conferences in Siberia.  The level of reports is very high, almost everything is interesting to hear. <br><br>  I especially liked the reports: <br><br><ul><li>  Of course, the <a href="http://meetingcpp.ru/%3Fpage_id%3D795">report by Eric Niebler</a> , which allows you to take a fresh look at C ++ </li><li>  <a href="http://meetingcpp.ru/%3Fpage_id%3D803">An excellent introduction to future concepts was</a> given by Alexander Fokin </li><li>  Alexander Granin once again blew the whole brain with functionalism!  <a href="http://meetingcpp.ru/%3Fpage_id%3D801">Lenses in C ++</a> , how do you, eh? </li><li>  An interesting <a href="http://meetingcpp.ru/%3Fpage_id%3D797">solution to the ODR problem was</a> suggested by Alexey Kutumov (by the way, he also overlaps with clang / LLVM!) </li><li>  Finally, Yevgeny Ryzhkov from all here at the well-known PVS Studio team <a href="http://meetingcpp.ru/%3Fpage_id%3D872">spoke</a> about the use of static analysis on the example of the Unreal Engine.  The report should be of interest primarily to project managers, since it mainly affects management issues.  But I also highly recommend programmers to listen to it. </li></ul><br>  ... That's all.  I hope you enjoyed the show and learned something new for yourself.  If not, it is always helpful to repeat and test yourself.  See you! <br><br>  PS: It would be great if the authors of the above reports wrote their articles with additions.  It is definitely worth it. <br><br>  PPS: The guys from Novosibirsk State University (NSU) were asked to tell about LLVM in a more accessible form for students.  The <a href="http://techtalks.nsu.ru/64/">lecture</a> itself <a href="http://techtalks.nsu.ru/64/">will be</a> next week.  If anyone wants to attend - welcome.  The event will also stream online. </div><p>Source: <a href="https://habr.com/ru/post/267239/">https://habr.com/ru/post/267239/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../267229/index.html">DoS exploit Chrome and some other browsers</a></li>
<li><a href="../267231/index.html">Functional C #: work with errors</a></li>
<li><a href="../267233/index.html">Managing complexity in ruby ‚Äã‚Äãon rails projects. Part 2</a></li>
<li><a href="../267235/index.html">RailsClub 2015: Competition from Vexor'a and the story of the CI-service in a large project</a></li>
<li><a href="../267237/index.html">About UEFI security, part three</a></li>
<li><a href="../267241/index.html">Maintenance code. How to ‚Äúsell‚Äù refactoring to business</a></li>
<li><a href="../267243/index.html">RxJava. Fighting the challenges of harsh reality</a></li>
<li><a href="../267245/index.html">RailsClub 2015: Interview with Nikolai Ryzhikov</a></li>
<li><a href="../267247/index.html">How many tweets do you need to know your character?</a></li>
<li><a href="../267253/index.html">In the Chinese AppStore, 39 infected applications were detected due to a modified version of Xcode.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>