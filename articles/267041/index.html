<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Dissect t-SNE</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="While working on the article ‚ÄúDeep Learning in R ...‚Äù , I repeatedly mentioned the mention of t-SNE - the mysterious technique of nonlinear dimension ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Dissect t-SNE</h1><div class="post__text post__text-html js-mediator-article">  While working on the article <a href="http://habrahabr.ru/post/258983/">‚ÄúDeep Learning in R ...‚Äù</a> , I repeatedly mentioned the mention of t-SNE - the mysterious technique of nonlinear dimension reduction and visualization of multidimensional variables (for example, <a href="http://habrahabr.ru/post/253227/">here</a> ), I was intrigued and decided to understand everything in detail.  <a href="https://en.wikipedia.org/wiki/T-distributed_stochastic_neighbor_embedding">t-SNE</a> is <b>t-distributed stochastic neighbor embedding</b> .  The Russian version with the ‚Äúintroduction of neighbors‚Äù to some extent sounds ridiculous, so I will continue to use the English acronym. <br><br><a name="habracut"></a><br>  The t-SNE algorithm, also referred to as multi-featured training, was published in 2008 (ref. 1 at the end of the article) by Dutch researcher Lawrence van der Maaten (currently working on Facebook AI Research) and neuron network magician Jeffrey Hinton.  The classic SNE was proposed by Hinton and Rowis in 2002 (Ref. 2).  The 2008 article describes several ‚Äútricks‚Äù that simplify the process of finding global minima and improve the quality of visualization.  One of these was the replacement of the normal distribution with the Student‚Äôs distribution for low-dimensional data.  In addition, a successful implementation of the algorithm was made (the article has a link to MatLab), which was then ported to other popular <a href="http://lvdmaaten.github.io/tsne/">environments</a> . <br><br><h4>  A bit of math </h4><br>  Let's start with the ‚Äúclassic‚Äù SNE and formulate the problem.  We have a data set with points that are described by a multidimensional variable with the dimension of space substantially greater than three.  It is necessary to obtain a new variable that exists in two-dimensional or three-dimensional space, which would maximally preserve the structure and patterns in the original data.  SNE begins with the conversion of the multidimensional Euclidean distance between points into conditional probabilities, reflecting the similarity of points.  Mathematically, it looks like this (formula 1): 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/files/b82/325/699/b82325699a1d41c2ac51732e9b3c40ec.gif"><br><br>  This formula shows how close the point X <sub>j</sub> is to point X <sub>i</sub> with a Gaussian distribution around X <sub>i</sub> with a given deviation œÉ.  Sigma will be different for each point.  It is chosen so that the points in areas with higher density have less variance.  For this purpose, the evaluation of <a href="https://en.wikipedia.org/wiki/Perplexity">perplexia is used</a> : <br><br><img src="https://habrastorage.org/files/7d9/984/e83/7d9984e835d34f81bcbc1c2e8a7aa9a8.png"><br><br>  Where H (Pi) - Shannon entropy in bits (formula 2): <br><br><img src="https://habrastorage.org/files/572/0b8/fbe/5720b8fbe4bb4e70b6be154854bca533.gif"><br><br>  In this case, the perplexion can be interpreted as a smoothed estimate of the effective number of "neighbors" for point X <sub>i</sub> .  It is set as a parameter of the method.  The authors recommend using a value in the range from 5 to 50. Sigma is determined for each pair of X <sub>i</sub> and X <sub>j</sub> using <a href="https://en.wikipedia.org/wiki/Binary_search_algorithm">a binary search algorithm</a> . <br><br>  For two-dimensional or three-dimensional "colleagues" of the pair X <sub>i</sub> and X <sub>j</sub> , let's call them for clarity Y <sub>i</sub> and Y <sub>j</sub> , it is not difficult to estimate the conditional probability using the same formula 1. The standard deviation is proposed to be set to 1 / ‚àö2: <br><br><img src="https://habrastorage.org/files/b89/625/a81/b89625a81094436aa09d4532158efaec.png"><br><br>  If the mapping points Y <sub>i</sub> and Y <sub>j</sub> correctly simulate the similarity between the original points of high dimension X <sub>i</sub> and X <sub>j</sub> , then the corresponding conditional probabilities p <sub>j | i</sub> and q <sub>j | i</sub> will be equivalent.  As an obvious assessment of the quality with which q <sub>j | i</sub> reflects p <sub>j | i</sub> , divergence or <a href="https://en.wikipedia.org/wiki/Kullback%25E2%2580%2593Leibler_divergence">a Kullback-Leibler distance is</a> used.  SNE minimizes the sum of such distances for all display points with a gradient descent.  The loss function for this method will be determined by the formula 3: <br><br><img src="https://habrastorage.org/files/a1d/f0b/bd3/a1df0bbd38a2495dbf16a879f816fc8a.png"><br><br>  At the same time, the gradient looks surprisingly simple: <br><br><img src="https://habrastorage.org/files/686/787/c58/686787c586fe44818e162e8b8cffd01d.png"><br><br>  The authors propose the following physical analogy for the optimization process: All display points are connected by springs.  The stiffness of the spring connecting points i and j depends on the difference between the similarity of two points in a multidimensional space and two points in a display space.  In this analogy, the gradient is the resultant force acting on a point in the display space.  If the system is ‚Äúlet go‚Äù, after some time it will come into balance, this will be the desired distribution.  Algorithmically, the search for equilibrium is proposed to take into account the moments: <br><br><img src="https://habrastorage.org/files/9cd/8f5/45b/9cd8f545bc994265ac64710522ebd55b.png"><br><br>  where Œ∑ is the parameter that determines the learning rate (step length), and Œ± is the coefficient of inertia.  Using the classic SNE allows you to get good results, but can be associated with difficulties in optimizing the loss function and the problem of crowding (in the original - the crowding problem).  t-SNE, if it does not solve these problems at all, it makes it much easier.  The t-SNE loss function has two principal differences.  First, t-SNE has a symmetric form of similarity in a multidimensional space and a simpler version of the gradient.  Secondly, instead of the Gaussian distribution for points from the display space, the t-distribution (Student) is used, whose ‚Äúheavy‚Äù tails facilitate optimization and solve the problem of crowding. <br><br>  As an alternative to minimizing the sum of Kullback-Leibler divergences between the conditional probabilities p <sub>i | j</sub> and q <sub>i | j, it is</sub> proposed to minimize a single divergence between the joint probability P in the multidimensional space and the joint probability Q in the display space: <br><br><img src="https://habrastorage.org/files/3f9/717/18d/3f971718d0e742dda20fb647a3608328.png"><br><br>  where p <sub>ii</sub> and q <sub>ii</sub> = 0, p <sub>ij</sub> = p <sub>ji</sub> , q <sub>ij</sub> = q <sub>ji</sub> for any i and j, and p <sub>ij</sub> is determined by the formula: <br><br><img src="https://habrastorage.org/files/677/556/952/6775569524534717a39d1a9fb7e25a6d.png"><br><br>  where n is the number of points in the data set.  The gradient for symmetric SNE is much simpler than for the classic: <br><br><img src="https://habrastorage.org/files/31a/26f/f04/31a26ff04dc84ca7a8685360587528ec.png"><br><br>  The problem of crowding is that the distance between two points in the display space corresponding to two middle-distance points in a multidimensional space must be significantly larger than the distance that allows us to obtain a Gaussian distribution.  Problem solve student's tails.  In t-SNE, a t-distribution with one degree of freedom is used.  The joint probability for the display space in this case will be determined by formula 4: <br><br><img src="https://habrastorage.org/files/c12/fd1/df8/c12fd1df8e3f4aa19a7af1babd8fadf3.png"><br><br>  And the corresponding gradient is 5: <br><br><img src="https://habrastorage.org/files/256/734/5f2/2567345f27ea44b4a29f33b459bf8be3.png"><br><br>  Returning to the physical analogy, the resultant force, defined by formula 5, will significantly tighten the points of the display space for nearby points of the multidimensional space, and push them away for the remote ones. <br><br><h4>  Algorithm </h4><br>  In a simplified form, the t-SNE algorithm can be represented by the following pseudocode: <br><br><pre> Data: data set X = {x1, x2, ..., xn},
 loss function parameter: Perp perplex
 Optimization parameters: the number of iterations T, the learning rate Œ∑, the moment Œ± (t).
 Result: data representation Y (T) = {y1, y2, ..., yn} (in 2D or 3D).
 begin
	 calculate the pairwise similarity of pj | ic by Perp perplexion (using formula 1)
	 set pij = (pj | i + pi | j) / 2n
	 initialize Y (0) = {y1, y2, ..., yn} points of normal distribution (mean = 0, sd = 1e-4)
	 for t = 1 to T do
 		 calculate the similarity of points in the space of the map qij (according to formula 4)
		 calculate the gradient Œ¥Cost / Œ¥y (according to the formula 5)
		 set Y (t) = Y (t-1) + Œ∑Œ¥Cost / Œ¥y + Œ± (t) (Y (t-1) - Y (t-2))
	 end
 end
</pre><br><br>  To improve the result it is proposed to use two tricks.  The first authors called the "early compression."  His task is to make the points in the display space at the beginning of the optimization be as close as possible to each other.  When the distance between the display points is small, it is much easier to move one cluster across another.  It is much easier to explore the optimization space and ‚Äúaim‚Äù at global minima.  Early compression is created due to the additional L2-penalty as a function of losses, which is proportional to the sum of the squares of the display point distances from the origin (I did not find this in the source code). <br><br>  The second trick is less obvious - ‚Äúearly hyper-strength‚Äù (in the original - ‚Äúearly exaggeration‚Äù).  It consists in multiplying at the beginning of the optimization of all p <sub>ij</sub> by some integer number, for example, by 4. The idea is to get larger q <sub>ij</sub> for large p <sub>ij</sub> .  This will allow for clusters in the source data to obtain dense and widely separated clusters in the display space. <br><br><h4>  Implementation on R </h4><br>  As the source code, I took the original MatLab <a href="">implementation of</a> van der Maaten.  However, my MatLab academic license is long over, so I ported all the code to R. The code is available in the <a href="https://github.com/khmelkoff/Xtsne">repository</a> .  Also at my disposal was the code from the archive of the <a href="https://cran.r-project.org/web/packages/tsne/index.html">tsne</a> R-package, took from there a couple of ideas. <br><br>  For experiments it is proposed to use the following parameters: <br>  Number of iterations: 1000; <br>  Perplexia: 40; <br>  Early hypergrowth: x4 for the first 50 iterations; <br>  Moment Œ±: 0.5 for the first 250 iterations, 0.8 for the remaining 750; <br>  Learning rate Œ∑: originally 100 (in the original code - 500) and changes after each iteration in accordance with the scheme described by Robert Jacobs in 1988 (ref. 3). <br><br>  The algorithm can be divided into three logical parts: <br><ol><li>  Calculation of perplexion and Gaussian kernel for the vector of current values ‚Äã‚Äãof sigma (or rather gamma, I used the variable, inverse of the square of sigma) </li><li>  Calculation of pairwise similarity p <sub>ij</sub> in a multidimensional space using a binary search for a given perplexion </li><li>  Calculate pairwise similarity for display space, loss function, and gradient </li></ol><br><br>  I will illustrate only the most important constructions.  First of all, it is necessary to calculate the matrix of squares of the Euclidean distance for the initial data set.  For this, it is better to use the <i>rdist ()</i> function from the fields package.  It works many times faster than the popular <i>dist ()</i> from the basic stats package.  Perhaps this is due to the fact that it is optimized for the Euclidean distance.  Next, you need to initialize the display space.  This can be done with the help of <i>rnorm ()</i> with a zero mat.  expectation and standard deviation 1e-4. <br><br>  The calculation of the logarithm of perplexia and the Gaussian core is as follows: <br><br><pre><code class="hljs pgsql">P &lt;- exp(-Di * gamma) # kernel calc sumP &lt;- sum(P) PP &lt;- log(sumP) + gamma * sum(Di * P) / sumP</code> </pre> <br>  The last expression is obtained if formula (1) for p <sub>j | i is</sub> substituted with formula (2) for perplexion.  Let n be the number of points in the source data.  Di is the vector of length n-1, with squares of pairwise distances for the line of the original data.  It turns out with the help of the construction <i>Di &lt;- D [i, -i]</i> , where D is the matrix of squares of distances nxn, and if i = 1, then Di is the first row of the matrix D without the first column.  The kernel, P is a vector, the length is n-1, and the logarithm of perplexion is a real number (due to the sum of elementary products).  The original code uses the natural logarithm, I decided to do the same. <br><br>  For the search for gamma, there are the following restrictions - the number of attempts (divisions) is no more than 50, the threshold difference between the logarithms of a given and the calculated perplexion is 1e-5.  One iteration of the binary search is as follows: <br><br><pre> <code class="hljs matlab"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (perpDiff &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>){ gammamin = <span class="hljs-built_in"><span class="hljs-built_in">gamma</span></span>[<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (is.infinite(gammamax)) <span class="hljs-built_in"><span class="hljs-built_in">gamma</span></span>[<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>] = <span class="hljs-built_in"><span class="hljs-built_in">gamma</span></span>[<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>] * <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-built_in"><span class="hljs-built_in">gamma</span></span>[<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>] = (<span class="hljs-built_in"><span class="hljs-built_in">gamma</span></span>[<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>] + gammamax)/<span class="hljs-number"><span class="hljs-number">2</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>{ gammamax = <span class="hljs-built_in"><span class="hljs-built_in">gamma</span></span>[<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (is.infinite(gammamin)) <span class="hljs-built_in"><span class="hljs-built_in">gamma</span></span>[<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>] = <span class="hljs-built_in"><span class="hljs-built_in">gamma</span></span>[<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>]/ <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-built_in"><span class="hljs-built_in">gamma</span></span>[<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>] = ( <span class="hljs-built_in"><span class="hljs-built_in">gamma</span></span>[<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>] + gammamin) / <span class="hljs-number"><span class="hljs-number">2</span></span> }</code> </pre><br>  gammamin and gammamax are initially set to - and + <i>Inf</i> . <br><br>  The loss function is calculated as the sum of the rows of the elementwise product of two nxn matrices: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">cost</span></span> = sum(apply(P * log(P/Q),<span class="hljs-number"><span class="hljs-number">1</span></span>,sum))</code> </pre><br>  P is a symmetric version of the joint probability for a multidimensional space, calculated as P = .5 * (P + t (P)) from the conditional pairwise probability, t is the matrix transposition operator.  Q - joint probability for the display space: <br><br><pre> <code class="hljs lisp"> num = <span class="hljs-number"><span class="hljs-number">1</span></span>/(<span class="hljs-number"><span class="hljs-number">1</span></span> + (<span class="hljs-name"><span class="hljs-name">rdist</span></span>(<span class="hljs-name"><span class="hljs-name">Y</span></span>))^<span class="hljs-number"><span class="hljs-number">2</span></span>) diag(<span class="hljs-name"><span class="hljs-name">num</span></span>)=0 # Set diagonal to zero Q = num / sum(<span class="hljs-name"><span class="hljs-name">num</span></span>) # Normalize to get probabilities</code> </pre><br>  Y is the initialized matrix of points nx 2 for the two-dimensional mapping space.  Q is obtained by the nxn matrix by using <i>rdist ()</i> . <br><br>  The gradient is calculated in vectorized form for all Yi at once: <br><br><pre> <code class="hljs lisp">L = (<span class="hljs-name"><span class="hljs-name">P</span></span> - Q) * num<span class="hljs-comment"><span class="hljs-comment">; grads = 4 * (diag(apply(L, 1, sum)) - L) %*% Y</span></span></code> </pre><br>  Here, grads is a matrix, the size of nx 2, which is formed by the matrix product.  The construction in parentheses is an nxn matrix, on the main diagonal of which are row-by-line sums of the matrix L, and all other elements are taken with a minus sign.  The matrix product allows us to multiply by the difference Y <sub>i</sub> and Y <sub>j</sub> and immediately calculate the sums of j (formula 4).  True gradient is obtained opposite sign. <br><br>  To search for optimal Y values, something similar to the delta-bar-delta heuristics is used.  Its meaning is to adaptively change the step of learning.  If the gradient does not change its sign at the next iteration, the step increases linearly (0.2 is added to the gain), if the sign changes, it decreases exponentially (the coefficient is multiplied by 0.8).  Given that the gradient we have is the opposite sign: <br><br><pre> <code class="hljs pgsql">gains = (gains + <span class="hljs-number"><span class="hljs-number">.2</span></span>) * abs(sign(grads) != sign(incs)) + gains * <span class="hljs-number"><span class="hljs-number">.8</span></span> * abs(sign(grads) == sign(incs)) gains[gains &lt; min_gain] = min_gain incs = momentum * incs - gains * epsilon * grads Y = Y + incs</code> </pre><br><br><h4>  Experiments </h4><br>  I could not try to repeat the experiment described in the article (link 1).  The idea of ‚Äã‚Äãthis experiment is to visualize the cluster structure for a set of MNIST images.  One part of this set contains 60000 images of handwritten numbers from 0 to 9, 28x28 pixels.  The data set can be downloaded from the <a href="http://yann.lecun.com/exdb/mnist/">site of the</a> neuron network guru, Jan Lekun. <br><br>  With loading in R it is necessary to tinker, but the readBin function () which allows to read (and write) the binary data helps.  20 random numbers: <br><br><img src="https://habrastorage.org/files/f51/a56/36e/f51a5636e831431ead3715ed9c8b7020.png"><br><br>  As in the original experiment, I did not use the entire set, but only 6000 images selected randomly using the <i>sample ()</i> function.  1000 iterations took a little less than one and a half hours on x64 c Intel Core i7 2.4 GHz.  Result on the picture: <br><br><img src="https://habrastorage.org/files/911/dbc/c27/911dbcc27e524b14bccc58809d2cc227.png"><br><br>  Colors are set using labels, MNIST is a marked set of data.  The result can be significantly improved.  As the authors advise, for the initial set of points, the main component analysis (PCA) should be done and the first 30 should be selected: <br><br><img src="https://habrastorage.org/files/f72/e03/d4d/f72e03d4d4f446ff9222d4b2b84dd548.png"><br><br>  There are several PCA implementations for R. The simplest version is in two lines: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">pca</span></span> &lt;- prcomp(X) X &lt;- pca<span class="hljs-variable"><span class="hljs-variable">$x</span></span>[,<span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">30</span></span>]</code> </pre><br>  The speed of the algorithm is proportional to the square of the number of points.  If this amount is reduced, the result will not be as obvious, but quite acceptable.  Let's say 2000 points are processed in just 9 minutes. <br><br>  The t-SNE technique would probably not be so popular if it were not for the ability to visualize the distributed representation of words.  In this experiment, I used a relatively small model (about 900 words and a 300-dimensional feature space), trained with the help of <a href="https://code.google.com/p/word2vec/">word2vec</a> . <br><br><img src="https://habrastorage.org/files/a0f/74d/d74/a0f74dd74d9444ab9f3af33279a74b6a.png"><br><br>  <a href="">Here the</a> size is bigger.  A three-dimensional display space is used, the third dimension is represented by color.  Words can be considered close if they are located side by side and have the same shade. <br><br>  It turns out that with a distributed representation of words prepared on real data, everything is not so simple.  There are two problems: as a rule, a very large number of clusters and significant differences in their size.  For visualization, you can make a random sample, but the result will most likely not be representative.  The authors explain this with the following example: If A, B and C are equidistant points in multidimensional space, but there are points between A and B and there is no point between B and C, the algorithm is more likely to combine A and B into one cluster than B and C. <br><br>  But it so happens that it is visibility that is important, not the fullness of the picture.  Then, instead of a random sample of points, you can try to select interesting clusters.  Clustering is built into the original word2vec, besides you can use k-means.  Perhaps this option does not seem quite "fair", but, in my opinion, has the right to exist.  Sampling data for a distributed representation of words from fifteen clusters does not look so confusing: <br><br><img src="https://habrastorage.org/files/96f/6bf/3bf/96f6bf3bf0664113889c0c4b4a540321.png"><br><br>  For large data sets, there is a special implementation of t-SNE, in which the nearest-neighbor trees and the random walk method are used to calculate the similarity in multidimensional space (described in article 1).  In practice, you can use the <a href="https://cran.r-project.org/web/packages/Rtsne/index.html">Rtsne</a> package, a wrapper for the C ++ implementation of the Barnes-Hut-SNE.  Rtsne can process all 60000 MNIST images in less than an hour.  Details can be found in publication 6. <br><br>  I have not experimented with Rtsne yet, but I have tested tsne (MatLab port of R code).  The visualization is much worse than my version.  Looking into the package <a href="">archive,</a> I discovered two things: First, when calculating the Gaussian core, the distance is used without a square, and second, the matrix product is used in the expression for perplexion.  In my version and in the code for MatLab, it is elementwise.  It is strange that generally turned out visible clusters.  I explain this by the ‚Äúsurvivability‚Äù of the algorithm, but I admit that I did not fully understand something.  I would be happy to comment and wish you all impressive multidimensional visualizations. <br><br>  Formulas for this article are prepared using the online formula editor <a href="http://primat.org/index/0-89">LATEX</a> . <br><br><h4>  References: </h4><br><ol><li>  LJP van der Maaten and GE Hinton.  Visualizing High-Dimensional Data Using t-SNE.  Journal of Machine Learning Research 9 (Nov): 2579-2605, 2008. <a href="http://lvdmaaten.github.io/publications/papers/JMLR_2008.pdf">PDF</a> </li><li>  GE Hinton and ST Roweis.  Stochastic Neighbor Embedding.  In Advances in Neural Information.  Processing Systems, volume 15, pages 833‚Äì840, Cambridge, MA, USA, 2002. The MIT Press.  <a href="http://www.cs.toronto.edu/~fritz/absps/sne.pdf">PDF</a> </li><li>  RA Jacobs.  Increased rates of convergence through learning rate adaptation.  Neural Networks, 1: 295‚Äì307, 1988. <a href="http://www.bcs.rochester.edu/people/robbie/jacobs.nn88.pdf">PDF</a> </li><li>  Experiments with t-SNE in Python: Algorithm t-SNE.  Illustrated introductory course (translation of the original article on <a href="https://beta.oreilly.com/learning/an-illustrated-introduction-to-the-t-sne-algorithm%3Fimm_mid%3D0d3385%26cmp%3Dem-data-na-na-newsltr_20150610">O'Reilly</a> ).  <a href="http://datareview.info/article/algoritm-t-sne-illyustrirovannyiy-vvodnyiy-kurs/">datareview.info/article/algoritm-t-sne-illyustrirovannyiy-vvodnyiy-kurs</a> </li><li>  Rtsne versus tsne: <a href="http://www.codeproject.com/Tips/788739/Visualization-of-High-Dimensional-Data-using-t-SNE">www.codeproject.com/Tips/788739/Visualization-of-High-Dimensional-Data-using-t-SNE</a> A set of data is also available for experiments with a distributed representation of words. </li><li>  LJP van der Maaten.  Accelerating t-SNE using Tree-Based Algorithms.  Journal of Machine Learning Research 15 (Oct): 3221-3245, 2014. <a href="http://lvdmaaten.github.io/publications/papers/JMLR_2014.pdf">PDF</a> </li></ol></div><p>Source: <a href="https://habr.com/ru/post/267041/">https://habr.com/ru/post/267041/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../267029/index.html">We make a network printer from HP LJ1000</a></li>
<li><a href="../267033/index.html">Simple Optimization Technique Using Intel System Studio</a></li>
<li><a href="../267035/index.html">The time series forecasting model for the maximum similarity sample: an explanation and an example</a></li>
<li><a href="../267037/index.html">A simple algorithm for determining the intersection of two segments</a></li>
<li><a href="../267039/index.html">Private Cloud Appliance - the best virtualization and private cloud for data centers</a></li>
<li><a href="../267045/index.html">System backup of virtual machines or how to save money organization</a></li>
<li><a href="../267047/index.html">Bot for sapper with a twist</a></li>
<li><a href="../267049/index.html">Ice started off: KC published a draft document on paperless transfer of .RU domains between registrars</a></li>
<li><a href="../267051/index.html">We are switching from STM32 to the Russian K1986BE92QI microcontroller. Practical application: We interrogate keys, we generate PWM. Comparison of CMSIS and SPL code (PWM + TIM + PORT). Part one</a></li>
<li><a href="../267053/index.html">What can I learn from WhatsApp</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>