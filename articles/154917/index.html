<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>About using WebKit .NET</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 
 A bunch of HTML + CSS + JavaScript today has established itself as a universal way to build user interfaces. And not only in web applic...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>About using WebKit .NET</h1><div class="post__text post__text-html js-mediator-article"><h4>  Introduction </h4><br>  A bunch of HTML + CSS + JavaScript today has established itself as a universal way to build user interfaces.  And not only in web applications, but also in desktop and mobile applications.  Examples of this are metro-applications in Windows 8, the <a href="http://phonegap.com/">PhoneGap</a> framework for creating mobile applications. <br><br>  Interface implementation using HTML, CSS, and JavaScript primarily means that the interface will be displayed in a browser.  If we are considering a desktop or mobile application, then, obviously, the browser must be embedded. <br><br>  In this article we will look at using <a href="http://sourceforge.net/projects/webkitdotnet/">WebKit .NET</a> in a desktop C # application for Windows. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <a name="habracut"></a><br><h4>  Embedded Browser Requirements </h4><br>  Identify the basic requirements for embedded browser. <br><br>  First of all, from C #, we should be able to set up an arbitrary content for the HTML document ‚Äî that is, our interface.  Next, there naturally arises the need for communication between C # and JavaScript.  You must be able to call C # from JavaScript and JavaScript from C #, and in two ways - synchronously and asynchronously.  Our desktop application with an interface implemented in an embedded browser is in many ways similar to a traditional web application that has a client-server architecture.  Therefore, the presence of asynchronous C # calls from JavaScript is very important.  These calls are analogous to AJAX requests in a traditional web application. <br><br>  Web Inspector and Debugger is the best friend of every web developer.  And what about this here?  Let's say right away - here it is not so simple.  We were unable to find a way to debug a javaScript running in an embedded browser, but we found an opportunity to explore the dom and got a javascript console. <br><br>  Thus, the basic requirements for WebKit .NET were the presence of the following things: <br><ul><li>  ability to set HTML document any content </li><li>  JavaScript calls from C # synchronously or asynchronously </li><li>  C # calls from javascript synchronously or asynchronously </li><li>  web inspector </li></ul><br><br>  Next, we consider what of the above was present in WebKit .NET and how the missing features were implemented. <br><br><h4>  Setting HTML Document Contents </h4><br>  The <a href="http://webkitdotnet.sourceforge.net/docs/html/P_WebKit_WebKitBrowser_DocumentText.htm">WebKitBrowser.DocumentText</a> property allows <a href="http://webkitdotnet.sourceforge.net/docs/html/P_WebKit_WebKitBrowser_DocumentText.htm">you</a> to set arbitrary content for an HTML document.  Our interface is completely independent of external resources, we include all JavaScript and CSS directly in HTML.  To increase performance, all scripts are included in the minifitsirovanny form. <br><br><h4>  JavaScript calls from C # </h4><br>  For JavaScript calls from C # in WebKit .NET there is a <a href="http://webkitdotnet.sourceforge.net/docs/html/M_WebKit_DOM_Document_InvokeScriptMethod.htm">Document.InvokeScriptMethod</a> method with the following signature: <br><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Object </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InvokeScriptMethod</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Method, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">params</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Object[] args </span></span></span><span class="hljs-function">)</span></span></code> </pre> <br>  Unfortunately, this method has a problem with passing parameters to the JavaScript function - it just does not work. <br><br>  To solve this problem, we had to develop our own JavaScript call protocol from C #.  The idea is this: <br><br><ul><li>  To pass parameters, use a div with the specified identifier. </li><li>  C # serializes the name and an array of parameters for the JavaScript function into a JSON string and places it in the specified div </li><li>  JavaScript extracts JSON, deserializes it and calls the specified function. </li></ul><br><br>  The code for invoking a JavaScript function in C # is as follows: <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">object</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CallJS</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> functionName, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] arguments, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">async</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dict = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>&gt;(); dict[<span class="hljs-string"><span class="hljs-string">"arguments"</span></span>] = arguments; dict[<span class="hljs-string"><span class="hljs-string">"functionName"</span></span>] = functionName; dict[<span class="hljs-string"><span class="hljs-string">"async"</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">async</span></span>; SetJsBuffer(dict); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> webKitBrowser.Document.InvokeScriptMethod(<span class="hljs-string"><span class="hljs-string">"JS_CALL_HANDLER"</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetJsBuffer</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> data</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> id = <span class="hljs-string"><span class="hljs-string">"cs-js-buffer"</span></span>; Element elem = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { elem = webKitBrowser.Document.GetElementById(id); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception) { } <span class="hljs-comment"><span class="hljs-comment">//  ,     if (elem == null) { elem = webKitBrowser.Document.CreateElement("div"); elem.SetAttribute("id", id); webKitBrowser.Document.GetElementsByTagName("body")[0].AppendChild(elem); } elem.TextContent = Newtonsoft.Json.JsonConvert.SerializeObject(data); }</span></span></code> </pre><br><br>  And in JavaScript, the call is handled like this: <br><pre> <code class="javascript hljs">JS_CALL_HANDLER = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//       div var dataFromCSharp = getDataFromDOM("cs-js-buffer"); if (!dataFromCSharp) { return; } if (!dataFromCSharp.async) { return window[dataFromCSharp.functionName].apply( window, dataFromCSharp.arguments ); } else { Ext.Function.defer(function () { window[dataFromCSharp.functionName].apply( window, dataFromCSharp.arguments ); }, 1); } }</span></span></code> </pre><br><br>  To make the call asynchronous, we simply call the specified function with <br>  a delay of 1ms.  Since we do not need asynchronous calls that return a value, <br>  then such a solution fully satisfies us. <br><br><h4>  C # Calls from JavaScript </h4><br>  There is no regular C # call mechanism from JavaScript in WebKit .NET.  After a close look at the documentation, the <a href="http://webkitdotnet.sourceforge.net/docs/html/E_WebKit_WebKitBrowser_DocumentTitleChanged.htm">WebKitBrowser.DocumentTitleChanged</a> event was found.  This is probably the only event that JavaScript can easily generate at any time by setting document.title. <br><br>  There are two things that make this event attractive: <br><ul><li>  document.title can be set large enough, more than 16Kb </li><li>  The installation of document.title in JavaScript is completed only after the execution of all event handlers for the DocumentTitleChanged event in C # </li></ul><br><br>  This formed the basis of our C # call protocol from JavaScript. <br>  The following listing shows JavaScript code intended for C # calls. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> callMap = {}; <span class="hljs-comment"><span class="hljs-comment">//   callback  /** * If call is synchronous, function returns response, received from c#, * otherwise - response data will be passed to callback. * * @param {Object} config Call properties * @param {String} config.name Name of C# function to call * @param {Object[]} config.arguments Array of arguments, that will be passed to C# function * @param {Boolean} config.async True, if this request must be performed asynchronously, * in this case callback and scope must be specified * @param {Function} config.callback Callback function * @param {Object} config.scope Scope for callback */ callCSharp = function(config) { var id = generateId(); //    var callObject = { id : id, name : config.name, arguments : config.arguments, async : config.async }; if (config.async) { callObject.callbackHandler = "COMMON_ASYNC_HANDLER"; callMap[id] = { callback: config.callback, scope : config.scope }; } // invoke C# by triggering WebKitBrowser.DocumentTitleChanged event document.title = Ext.encode(callObject); // elegant, isn't it! // execution continues only after all C# handlers will finish if (!config.async) { var csharpResponse = getDataFromDOM(id); return csharpResponse.response; } }</span></span></code> </pre><br><br>  As you can see from the listing, each call is provided with a unique identifier. <br>  It is then used as the identifier of the div element in which C # places the result. <br><br>  If the call is synchronous, just before its completion, the C # handler can <br>  put your result in the body of the HTML document.  In this case, the callCSharp method can <br>  extract the result from the dom immediately after setting document.title. <br><br>  For asynchronous calls, C # should initiate the start of callback functions upon completion. <br>  handlers.  In this case, from C # we call the special JavaScript method shown in the following listing: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** * Handler for all C# async requests. * It calls real callback according to passed id. * * C# provides JSON of special format in div with passed id: * { * response : {...}, * success : true or false * } * * response and success are passed to callback function * @param {String} id Id of C# call */</span></span> COMMON_ASYNC_HANDLER = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">id</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dataFromCSharp = getDataFromDOM(id); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> callbackParams = callMap[id]; <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> callMap[id]; callbackParams.callback.apply(callbackParams.scope, [ dataFromCSharp.response, dataFromCSharp.success ]); }</code> </pre><br><br>  On the C # side, we have a CallManager class that controls the subscription to calls from JavaScript.  CallManager has a single handler for the WebKitBrowser.DocumentTitleChanged event, which deserializes the value of the <a href="http://webkitdotnet.sourceforge.net/docs/html/P_WebKit_WebKitBrowser_DocumentTitle.htm">WebKitBrowser.DocumentTitle</a> property and, depending on the name specified in JavaScript (config.name), calls the corresponding registered handler with the passed parameters.  CallManager also takes into account the type of call: synchronous or asynchronous.  Depending on the type, the handler is called either synchronously or asynchronously. <br><br><h4>  Web Inspector </h4><br>  We develop the interface in two stages.  At the first stage, we develop it as a traditional web application using a browser and a web server.  Only after achieving the desired result, we proceed to the second stage - packaging scripts and integration with C #. <br><br>  At the first stage, we actively used developer tools in the browser and had full control over dom and JavaScript.  But after the transition to the second stage, the entire interface simply turned into a black box.  Problems with layout and JavaScript became difficult to detect.  We were forced to look for at least some kind of web inspector. <br><br>  Unfortunately, WebKit .NET does not allow the use of the native WebKit web inspector and no remote debugging is supported here.  Therefore, we decided to use <a href="http://getfirebug.com/firebuglite">Firebug Lite</a> (1.4.0), an embedded debugger based on <a href="https://getfirebug.com/">Firebug</a> . <br><br>  In the HTML page of Firebug Lite we connect as follows: <br><pre> <code class="html hljs xml"><span class="hljs-meta"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">html</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">head</span></span></span><span class="hljs-tag">&gt;</span></span> ... <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'text/javascript'</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'/path/to/firebug-lite.js'</span></span></span><span class="hljs-tag">&gt;</span></span><span class="actionscript"><span class="actionscript"> { overrideConsole: </span><span class="hljs-literal"><span class="actionscript"><span class="hljs-literal">true</span></span></span><span class="actionscript">, startInNewWindow: </span><span class="hljs-literal"><span class="actionscript"><span class="hljs-literal">true</span></span></span><span class="actionscript">, startOpened: </span><span class="hljs-literal"><span class="actionscript"><span class="hljs-literal">true</span></span></span><span class="actionscript">, enableTrace: </span><span class="hljs-literal"><span class="actionscript"><span class="hljs-literal">true</span></span></span><span class="actionscript"> } </span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span> ... <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">head</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">body</span></span></span><span class="hljs-tag">&gt;</span></span>...<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">body</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">html</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br><br>  When working with the embedded browser, it is more convenient when Firebug Lite opens in a new window, which is set by the startInNewWindow option.  But in order for this to happen, some manipulations in C # are needed: <br><pre> <code class="cs hljs">browser.Url = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Uri( <span class="hljs-string"><span class="hljs-string">"http://localhost/path/to/debug-version-of-interface.html"</span></span>, System.UriKind.Absolute); browser.NewWindowCreated += <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NewWindowCreatedEventHandler( (sender, newWindowEventArgs) =&gt; { <span class="hljs-comment"><span class="hljs-comment">// create new form with single item - Firebug Lite window debuggerForm = new DebuggerForm(newWindowEventArgs.WebKitBrowser); debuggerForm.Show(); });</span></span></code> </pre><br><br>  Of course, Firebug Lite does not support debugging of scripts, but it gives the opportunity to explore the dom and gives us a JavaScript console, and this already facilitates development. <br><br><h4>  Conclusion </h4><br>  After all the improvements described above, WebKit .NET has become a completely usable embedded browser that works stably and copes with a fairly large dom. <br><br>  Of course, the implementation of the interface in this way is associated with certain difficulties, which are mostly caused by the absence of a full-fledged web inspector, but there are also advantages.  For example, you can reuse JavaScript code from other parts of the application, or even implement the same interface in a mobile, desktop and web application.  Therefore, efforts can be considered justified. </div><p>Source: <a href="https://habr.com/ru/post/154917/">https://habr.com/ru/post/154917/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../154901/index.html">We write the Gameboy emulator, part 1</a></li>
<li><a href="../154905/index.html">MySQL Select random strings in one query</a></li>
<li><a href="../154907/index.html">Building a recovery chain for MS SQL databases</a></li>
<li><a href="../154909/index.html">DropBox re-distributes to students / teachers</a></li>
<li><a href="../154911/index.html">Slit survey: time compression horizontally</a></li>
<li><a href="../154919/index.html">Patrons of Wikipedia. Who are they?</a></li>
<li><a href="../154921/index.html">Antivirus service will be built into Google Play</a></li>
<li><a href="../154923/index.html">New HabrAjax Theme</a></li>
<li><a href="../154929/index.html">New Node Subsite Names</a></li>
<li><a href="../154931/index.html">A little trick to display a large amount of data in a ListView</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>