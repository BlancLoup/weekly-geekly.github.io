<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Java.util.concurrent. * Overview</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In everyday work, it‚Äôs not often the case that the java.util.concurrent package for multi-threading is encountered. Sometimes there are design restric...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Java.util.concurrent. * Overview</h1><div class="post__text post__text-html js-mediator-article">  In everyday work, it‚Äôs not often the case that the java.util.concurrent package for multi-threading is encountered.  Sometimes there are design restrictions on using java 1.4.2, where there is no this package, but most often there is enough normal synchronization and nothing supernatural is required.  Fortunately, sometimes there are tasks that make you think a little about brains and either write a bicycle, or rummage through javadocs and find something more suitable.  There are no problems with a bicycle - you just take it and write, since there is nothing super-complex in multithreading.  On the other hand, less code - less bugs.  Moreover, nobody in their right mind writes a multi-threading unit, since  These are already complete integration tests with all the ensuing consequences. <br><br>  What to choose for a particular case?  In terms of parking and deadlines, it is quite difficult to cover the entire java.util.concurrent.  Something similar is selected and go!  So, gradually, ArrayBlockingQueue, ConcurrentHashMap, AtomicInteger, Collections.synchronizedList (new LinkedList ()) and other interesting things appear in the code.  Sometimes right, sometimes not.  At some point in time you begin to realize that more than 95% of the standard classes in java are not used at all in product development.  Collections, primitives, shifting from one place to another, hibernate, spring or EJB, some other library and, voila, the application is ready. <br><br>  In order to somehow streamline knowledge and facilitate entry into the topic, below is a review of classes for working with multithreading.  I write primarily as a cheat sheet for myself.  And if anyone else is fit, it is generally wonderful. <a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h1>  For seed </h1><br>  Immediately bring a couple of interesting links.  The first is for those who float a little in multithreading.  The second for "advanced" programmers - maybe there is something useful here. <br><ul><li>  <a href="http://docs.oracle.com/javase/tutorial/essential/concurrency/index.html">Java Concurrency Tutorials</a> </li><li>  <a href="http://www.cs.umd.edu/class/fall2002/cmsc433-0201/lectures/cpjslides.pdf">Concurrent Programming in Java by Doug Lea</a> </li></ul><br><br><h1>  A little about the author of the java.util.concurrent package </h1><br>  If anyone ever opened the source code for the classes java.util.concurrent, they could not help but notice in the authors Doug Lea (Doug Lee), professor Oswego (Osuigo) of the University of New York.  The list of his most famous developments included java <a href="http://gee.cs.oswego.edu/dl/classes/collections/index.html">collections</a> and <a href="http://gee.cs.oswego.edu/dl/classes/EDU/oswego/cs/dl/util/concurrent/intro.html">util.concurrent</a> , which in one form or another were reflected in existing JDKs.  He also wrote a <a href="http://en.wikipedia.org/wiki/Malloc">dlmalloc</a> implementation for dynamic memory allocation.  <a href="http://www.informit.com/store/concurrent-programming-in-java-design-principles-and-9780201310092">Concurrent Programming in Java: Design Principles and Pattern, 2nd Edition</a> .  More information can be found on his <a href="http://g.oswego.edu/">homepage</a> . <br><br><img src="https://habrastorage.org/storage2/57d/237/064/57d2370647eb56837d5652db3eecd406.jpg"><br>  Speech by Doug Lea at the <a href="http://wiki.jvmlangsummit.com/2010_Main_Page">JVM Language Summit</a> in 2010. <br><br><h1>  According to the chords </h1><br>  Probably many had a feeling of some chaos with a quick glance at java.util.concurrent.  In the same package, different classes are mixed with completely different functionalities, which makes it somewhat difficult to understand what it is and how it works.  Therefore, it is possible to schematically divide classes and interfaces according to a functional attribute, and then run through the implementation of specific parts. <br><br><img src="https://habrastorage.org/storage2/ff8/e9d/719/ff8e9d719402e1b164febae3fd8c0ff5.png"><br><br>  <b>Concurrent Collections</b> is a collection of collections that work more effectively in a multithreaded environment than standard universal collections from the java.util package.  Instead of the base wrapper Collections.synchronizedList with blocking access to the entire collection, blocking by data segments is used, or work is optimized for parallel reading of data on <a href="http://ru.wikipedia.org/wiki/%25D0%259D%25D0%25B5%25D0%25B1%25D0%25BB%25D0%25BE%25D0%25BA%25D0%25B8%25D1%2580%25D1%2583%25D1%258E%25D1%2589%25D0%25B0%25D1%258F_%25D1%2581%25D0%25B8%25D0%25BD%25D1%2585%25D1%2580%25D0%25BE%25D0%25BD%25D0%25B8%25D0%25B7%25D0%25B0%25D1%2586%25D0%25B8%25D1%258F">wait-free</a> algorithms. <br><br>  <b>Queues</b> - non-blocking and blocking queues with multithreading support.  Non-blocking queues are sharpened for speed and operation without blocking threads.  Blocking queues are used when you need to ‚Äúslow down‚Äù the ‚ÄúProducer‚Äù or ‚ÄúConsumer‚Äù streams, if some conditions are not met, for example, the queue is empty or replayed, or there is no free ‚ÄúConsumer‚Äù 'a. <br><br>  <b>Synchronizers</b> are helper utilities for thread synchronization.  Represent a powerful weapon in "parallel" calculations. <br><br>  <b>Executors</b> - contains excellent frameworks for creating thread pools, scheduling work of asynchronous tasks with getting results. <br><br>  <b>Locks</b> - is an alternative and more flexible thread synchronization mechanisms compared to the basic synchronized, wait, notify, notifyAll. <br><br>  <b>Atomics</b> - classes with support for atomic operations on primitives and references. <br><br><br><br><h1>  1. Concurrent Collections </h1><br><br><h4>  CopyOnWrite collections </h4><br><img src="https://habrastorage.org/storage2/324/0ee/2cf/3240ee2cf87d7582e7d721ee7e0be951.png"><br><br>  The name speaks for itself.  All operations to modify the collection (add, set, remove) lead to the creation of a new copy of the internal array.  This ensures that when iterating through the collection, ConcurrentModificationException is not thrown.  It should be remembered that when copying an array, only references (references) to objects (shallow copy) are copied, including  access to fields of elements is not thread-safe.  CopyOnWrite collections are useful when write operations are quite rare, for example, when implementing the listeners subscription mechanism and passing through them. <br><br>  <b>CopyOnWriteArrayList &lt;E&gt;</b> <b><img src="https://habrastorage.org/storage2/0fb/43e/259/0fb43e259847760ecf54027457005e30.png"><img src="https://habrastorage.org/storage2/d73/4a3/deb/d734a3deb05965b8207c68b307cadba8.png"></b>  - Thread safe analog ArrayList, implemented with CopyOnWrite algorithm. <div class="spoiler">  <b class="spoiler_title">Additional methods and constructor</b> <div class="spoiler_text"><table><tbody><tr><td>  CopyOnWriteArrayList (E [] toCopyIn) </td><td>  A constructor that takes an array as input. </td></tr><tr><td>  int indexOf (E e, int index) </td><td>  Returns the index of the first found item, starting the search with the specified index. </td></tr><tr><td>  int lastIndexOf (E e, int index) </td><td>  Returns the index of the first element found in the reverse search, starting at the specified index. </td></tr><tr><td>  boolean addIfAbsent (E e) </td><td>  Add an item if it is not in the collection.  To compare elements, use the equals method. </td></tr><tr><td>  int addAllAbsent (Collection &lt;? extends E&gt; c) </td><td>  Add items if they are missing from the collection.  Returns the number of elements added. </td></tr></tbody></table></div></div><br>  <b>CopyOnWriteArraySet &lt;E&gt;</b> <b><img src="https://habrastorage.org/storage2/0fb/43e/259/0fb43e259847760ecf54027457005e30.png"><img src="https://habrastorage.org/storage2/d73/4a3/deb/d734a3deb05965b8207c68b307cadba8.png"></b>  - Implementation of the Set interface, using CopyOnWriteArrayList as the basis.  Unlike CopyOnWriteArrayList, there are no additional methods. <br><br><h4>  Scalable Maps </h4><br><img src="https://habrastorage.org/storage2/5b8/765/fe7/5b8765fe74c096ef78942ba450b82765.png"><br><br>  Improved implementations of HashMap, TreeMap with better support for multithreading and scalability. <br><br>  <b>ConcurrentMap &lt;K, V&gt;</b> <b><img src="https://habrastorage.org/storage2/36b/c31/fa2/36bc31fa2bdf7a08f3a85dff79ee4eef.png"><img src="https://habrastorage.org/storage2/d73/4a3/deb/d734a3deb05965b8207c68b307cadba8.png"></b>  - An interface that extends the Map with several additional atomic operations. <br><div class="spoiler">  <b class="spoiler_title">Additional methods</b> <div class="spoiler_text"><table><tbody><tr><td>  V putIfAbsent (K key, V value) </td><td>  Adds a new key-value pair only if the key is not in the collection.  Returns the previous value for the specified key. </td></tr><tr><td>  boolean remove (Object key, Object value) </td><td>  Removes a key-value pair only if the specified key matches the specified value in the Map.  Returns true if the item was successfully deleted. </td></tr><tr><td>  boolean replace (K key, V oldValue, V newValue) </td><td>  Replaces the old value with the new one by key only if the old value corresponds to the specified value in the Map.  Returns true if the value has been replaced with a new one. </td></tr><tr><td>  V replace (K key, V value) </td><td>  Replaces the old value with the new one by key only if the key is associated with any value.  Returns the previous value for the specified key. </td></tr></tbody></table></div></div><br>  <b>ConcurrentHashMap &lt;K, V&gt;</b> <b><img src="https://habrastorage.org/storage2/0fb/43e/259/0fb43e259847760ecf54027457005e30.png"><img src="https://habrastorage.org/storage2/d73/4a3/deb/d734a3deb05965b8207c68b307cadba8.png"></b>  - Unlike Hashtable and synhronized blocks on a HashMap, data is presented in the form of segments, divided by hash keys.  As a result, data access is tracked by segments, and not by one object.  In addition, iterators provide data for a specific time slice and do not throw a ConcurrentModificationException.  In more detail ConcurrentHashMap is described in habratopik <a href="http://habrahabr.ru/post/132884/">here</a> . <div class="spoiler">  <b class="spoiler_title">Additional constructor</b> <div class="spoiler_text"><table><tbody><tr><td>  ConcurrentHashMap (int initialCapacity, float loadFactor, int concurrencyLevel) </td><td>  The 3rd parameter of the constructor is the expected number of simultaneously writing streams.  The default value is 16. Affects the size of the collection in memory and performance. </td></tr></tbody></table></div></div><br>  <b>ConcurrentNavigableMap &lt;K, V&gt;</b> <b><img src="https://habrastorage.org/storage2/36b/c31/fa2/36bc31fa2bdf7a08f3a85dff79ee4eef.png"><img src="https://habrastorage.org/storage2/c29/5ad/47f/c295ad47f86291abd7e8fe2b91b9621c.png"></b>  - Extends the NavigableMap interface and forces the use of ConcurrentNavigableMap objects as return values.  All iterators are declared safe to use and do not throw a ConcurrentModificationException. <br><br>  <b>ConcurrentSkipListMap &lt;K, V&gt;</b> <b><img src="https://habrastorage.org/storage2/0fb/43e/259/0fb43e259847760ecf54027457005e30.png"><img src="https://habrastorage.org/storage2/c29/5ad/47f/c295ad47f86291abd7e8fe2b91b9621c.png"></b>  - Is an analogue of a treemap with multithreading support.  The data is also sorted by key and the average log (N) performance is guaranteed for containsKey, get, put, remove, and other similar operations.  Algorithm SkipList described on the <a href="http://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25BF%25D0%25B8%25D1%2581%25D0%25BE%25D0%25BA_%25D1%2581_%25D0%25BF%25D1%2580%25D0%25BE%25D0%25BF%25D1%2583%25D1%2581%25D0%25BA%25D0%25B0%25D0%25BC%25D0%25B8">Wiki</a> and <a href="http://habrahabr.ru/post/139870/">Habr√©</a> . <br><br>  <b>ConcurrentSkipListSet &lt;E&gt;</b> <b><img src="https://habrastorage.org/storage2/0fb/43e/259/0fb43e259847760ecf54027457005e30.png"><img src="https://habrastorage.org/storage2/c29/5ad/47f/c295ad47f86291abd7e8fe2b91b9621c.png"></b>  - Implementation of the Set interface, made on the basis of ConcurrentSkipListMap. <br><br><br><br><h1>  2. Queues </h1><br><h4>  Non-Blocking Queues </h4><br><img src="https://habrastorage.org/storage2/bc7/78f/458/bc778f4581a3bd53e28ab87c0ca1a0ed.png"><br><br>  Thread-safe and non-blocking implementation of Queue on linked nodes. <br><br>  <b>ConcurrentLinkedQueue &lt;E&gt;</b> <b><img src="https://habrastorage.org/storage2/0fb/43e/259/0fb43e259847760ecf54027457005e30.png"><img src="https://habrastorage.org/storage2/d73/4a3/deb/d734a3deb05965b8207c68b307cadba8.png"></b>  - The implementation uses the wait-free algorithm from Michael &amp; Scott, adapted for working with the garbage collector.  This algorithm is quite effective and, most importantly, very fast, because  built on <a href="http://en.wikipedia.org/wiki/Compare-and-swap">CAS</a> .  The size () method can work for a long time, t.ch.  better not to jerk it all the time.  A detailed description of the algorithm can be found <a href="http://www.cs.rochester.edu/u/michael/PODC96.html">here</a> . <br><br>  <b>ConcurrentLinkedDeque &lt;E&gt;</b> <b><img src="https://habrastorage.org/storage2/0fb/43e/259/0fb43e259847760ecf54027457005e30.png"><img src="https://habrastorage.org/storage2/968/b76/9b1/968b769b1a83359a83e5fd169d8dbde4.png"></b>  - Deque stands for Double ended queue and reads like ‚ÄúDeck‚Äù.  This means that data can be added and pulled from both sides.  Accordingly, the class supports both modes of operation: FIFO (First In First Out) and LIFO (Last In First Out).  In practice, ConcurrentLinkedDeque should be used only if it is necessary to use LIFO, since  due to the bidirectional node, this class loses in performance by 40% compared with the ConcurrentLinkedQueue. <br><br><h4>  Blocking queues </h4><br><img src="https://habrastorage.org/storage2/009/d00/33b/009d0033b5c6bf14fa31d66cf7ea1980.png"><br><br>  <b>BlockingQueue &lt;E&gt;</b> <b><img src="https://habrastorage.org/storage2/36b/c31/fa2/36bc31fa2bdf7a08f3a85dff79ee4eef.png"><img src="https://habrastorage.org/storage2/d73/4a3/deb/d734a3deb05965b8207c68b307cadba8.png"></b>  - When processing large data streams through queues, it is clearly not enough to use ConcurrentLinkedQueue.  If the threads clearing the queue no longer cope with the influx of data, then you can quickly get out of memory or overload IO / Net so that performance drops by several times until the system fails due to timeouts or because there are no free descriptors in the system.  For such cases, you need a queue with the ability to set the size of the queue or with locks on the conditions.  This is where the BlockingQueue interface appears, opening the way to a whole set of useful classes.  In addition to the ability to set the queue size, new methods have been added that react differently to the non-filling or queue overflow.  So, for example, when adding an item to an overflowing queue, one method will throw IllegalStateException, another will return false, the third will block the stream until a place appears, the fourth will block the stream with timeout and return false if the place does not appear.  It is also worth noting that blocking queues do not support null values, since  This value is used in the poll method as a timeout indicator. <br><br>  <b>ArrayBlockingQueue &lt;E&gt;</b> <b><img src="https://habrastorage.org/storage2/0fb/43e/259/0fb43e259847760ecf54027457005e30.png"><img src="https://habrastorage.org/storage2/d73/4a3/deb/d734a3deb05965b8207c68b307cadba8.png"></b>  - A blocking queue class built on a classic circular buffer.  In addition to the size of the queue, it is possible to manage the "integrity" of locks.  If fair = false (by default), then the order of the threads is not guaranteed.  More details about ‚Äúhonesty‚Äù can be found in the description of ReentrantLock. <br><br>  <b>DelayQueue &lt;E extends Delayed&gt;</b> <b><img src="https://habrastorage.org/storage2/0fb/43e/259/0fb43e259847760ecf54027457005e30.png"><img src="https://habrastorage.org/storage2/d73/4a3/deb/d734a3deb05965b8207c68b307cadba8.png"></b>  - A rather specific class that allows you to pull items out of the queue only after a certain delay defined in each item through the Delayed interface‚Äôs getDelay method. <br><br>  <b>LinkedBlockingQueue &lt;E&gt;</b> <b><img src="https://habrastorage.org/storage2/0fb/43e/259/0fb43e259847760ecf54027457005e30.png"><img src="https://habrastorage.org/storage2/d73/4a3/deb/d734a3deb05965b8207c68b307cadba8.png"></b>  - Blocking queue on connected nodes, implemented on the ‚Äútwo lock queue‚Äù algorithm: one lock to add, the other to pull out the element.  Due to the two locks, compared with ArrayBlockingQueue, this class shows better performance, but it also has a higher memory consumption.  The queue size is set through the constructor and the default is Integer.MAX_VALUE. <br><br>  <b>PriorityBlockingQueue &lt;E&gt;</b> <b><img src="https://habrastorage.org/storage2/0fb/43e/259/0fb43e259847760ecf54027457005e30.png"><img src="https://habrastorage.org/storage2/d73/4a3/deb/d734a3deb05965b8207c68b307cadba8.png"></b>  - Is a multi-threaded wrapper over a PriorityQueue.  When an element is inserted into a queue, its order is determined in accordance with the logic of the Comparator or the implementation of the Comparable interface for the elements.  The first out of the queue is the smallest element. <br><br>  <b>SynchronousQueue &lt;E&gt;</b> <b><img src="https://habrastorage.org/storage2/0fb/43e/259/0fb43e259847760ecf54027457005e30.png"><img src="https://habrastorage.org/storage2/d73/4a3/deb/d734a3deb05965b8207c68b307cadba8.png"></b>  - This queue works on the principle of one entered, one out.  Each insertion operation blocks the Producer stream until the Consumer thread pulls the item out of the queue and vice versa, the Consumer waits until the Producer inserts the item. <br><br>  <b>BlockingDeque &lt;E&gt;</b> <b><img src="https://habrastorage.org/storage2/36b/c31/fa2/36bc31fa2bdf7a08f3a85dff79ee4eef.png"><img src="https://habrastorage.org/storage2/c29/5ad/47f/c295ad47f86291abd7e8fe2b91b9621c.png"></b>  - An interface describing additional methods for a bidirectional blocking queue.  Data can be inserted and pulled from both sides of the queue. <br><br>  <b>LinkedBlockingDeque &lt;E&gt;</b> <b><img src="https://habrastorage.org/storage2/0fb/43e/259/0fb43e259847760ecf54027457005e30.png"><img src="https://habrastorage.org/storage2/c29/5ad/47f/c295ad47f86291abd7e8fe2b91b9621c.png"></b>  - Bidirectional blocking queue on connected nodes, implemented as a simple bidirectional list with one lock.  The queue size is set through the constructor and the default is Integer.MAX_VALUE. <br><br>  <b>TransferQueue &lt;E&gt;</b> <b><img src="https://habrastorage.org/storage2/36b/c31/fa2/36bc31fa2bdf7a08f3a85dff79ee4eef.png"><img src="https://habrastorage.org/storage2/968/b76/9b1/968b769b1a83359a83e5fd169d8dbde4.png"></b>  - This interface can be interesting in that when adding an item to a queue, it is possible to block the inserting ‚ÄúProducer‚Äù stream until another ‚ÄúConsumer‚Äù flow pulls the item out of the queue.  A lock can be either with a timeout or it can be replaced by checking for the presence of waiting ‚ÄúConsumer‚Äù s.  Thus, it becomes possible to implement a message transfer mechanism that supports both synchronous and asynchronous messages. <br><br>  <b>LinkedTransferQueue &lt;E&gt;</b> <b><img src="https://habrastorage.org/storage2/0fb/43e/259/0fb43e259847760ecf54027457005e30.png"><img src="https://habrastorage.org/storage2/968/b76/9b1/968b769b1a83359a83e5fd169d8dbde4.png"></b>  - Implementing TransferQueue based on Dual Queues with Slack algorithm.  Actively uses <a href="http://en.wikipedia.org/wiki/Compare-and-swap">CAS</a> and <a href="">parking</a> flows when they are in standby mode. <br><br><br><br><h1>  3. Synchronizers </h1><br><img src="https://habrastorage.org/storage2/632/495/7bd/6324957bdddacafa30f5751a27db917c.png"><br><br>  This section presents classes for active thread management. <br><br>  <b>Semaphore</b> <b><img src="https://habrastorage.org/storage2/0fb/43e/259/0fb43e259847760ecf54027457005e30.png"><img src="https://habrastorage.org/storage2/d73/4a3/deb/d734a3deb05965b8207c68b307cadba8.png"></b>  - <a href="http://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25B5%25D0%25BC%25D0%25B0%25D1%2584%25D0%25BE%25D1%2580_(%25D0%25B8%25D0%25BD%25D1%2584%25D0%25BE%25D1%2580%25D0%25BC%25D0%25B0%25D1%2582%25D0%25B8%25D0%25BA%25D0%25B0)">Semaphores are</a> most often used to limit the number of threads when working with hardware resources or a file system.  Access to a shared resource is controlled by a counter.  If it is greater than zero, then access is allowed, and the value of the counter decreases.  If the counter is zero, the current thread is blocked until another thread releases the resource.  The number of permissions and "honesty" of the release of threads is set through the constructor.  The bottleneck when using semaphores is setting the number of permissions, since  often this number has to be selected depending on the power of the ‚Äúiron‚Äù. <br><br>  <b>CountDownLatch</b> <b><img src="https://habrastorage.org/storage2/0fb/43e/259/0fb43e259847760ecf54027457005e30.png"><img src="https://habrastorage.org/storage2/d73/4a3/deb/d734a3deb05965b8207c68b307cadba8.png"></b>  - Allows one or more threads to wait until a certain number of operations are completed, performing in other threads.  The classic driver example describes the class logic quite well: The threads that call the driver will hang in the await method (with or without timeout) until the driver stream initializes and then calls the countDown method.  This method reduces the count down counter by one.  As soon as the counter becomes zero, all the waiting threads in await will continue their work, and all subsequent await calls will pass without waiting.  The count down counter is one-time and cannot be reset to its original state. <br><br>  <b>CyclicBarrier</b> <b><img src="https://habrastorage.org/storage2/0fb/43e/259/0fb43e259847760ecf54027457005e30.png"><img src="https://habrastorage.org/storage2/d73/4a3/deb/d734a3deb05965b8207c68b307cadba8.png"></b>  - Can be used to synchronize a specified number of threads at one point.  The barrier is reached when N-threads call the await (...) method and block.  After that, the counter is reset to its original value, and the waiting threads are freed.  Additionally, if needed, it is possible to run a special code before unlocking threads and resetting the counter.  For this, an object with the implementation of the Runnable interface is passed through the constructor. <br><br>  <b>Exchanger &lt;V&gt;</b> <b><img src="https://habrastorage.org/storage2/0fb/43e/259/0fb43e259847760ecf54027457005e30.png"><img src="https://habrastorage.org/storage2/d73/4a3/deb/d734a3deb05965b8207c68b307cadba8.png"></b>  - As the name implies, the main purpose of this class is the exchange of objects between two streams.  At the same time, null values ‚Äã‚Äãare also supported, which allows using this class to transfer only one object or simply as a synchronizer of two streams.  The first thread that calls the exchange (...) method will block until the same method calls the second thread.  As soon as this happens, the threads will exchange values ‚Äã‚Äãand continue their work. <br><br>  <b>Phaser</b> <b><img src="https://habrastorage.org/storage2/0fb/43e/259/0fb43e259847760ecf54027457005e30.png"><img src="https://habrastorage.org/storage2/968/b76/9b1/968b769b1a83359a83e5fd169d8dbde4.png"></b>  - Improved implementation of the barrier to synchronize threads, which combines the functionality of CyclicBarrier and CountDownLatch, incorporating the best of them.  Thus, the number of threads is not strictly specified and can dynamically change.  The class can be reused and report the readiness of a thread without blocking it.  More details can be found in habratopik <a href="http://habrahabr.ru/post/117185/">here</a> . <br><br><br><br><h1>  4. Executors </h1><br>  So we got to the biggest part of the package.  Interfaces for running asynchronous tasks with the ability to get results through Future and Callable interfaces, as well as services and factories for creating thread pools: ThreadPoolExecutor, ScheduledPoolExecutor, ForkJoinPool will be described here.  For better understanding, let's make a small decomposition of interfaces and classes. <br><br><h4>  Future and callable </h4><br><img src="https://habrastorage.org/storage2/b68/d1c/1d0/b68d1c1d05c8ae15bcc8bb3d5ca09bc9.png"><br><br>  <b>Future &lt;V&gt;</b> <b><img src="https://habrastorage.org/storage2/36b/c31/fa2/36bc31fa2bdf7a08f3a85dff79ee4eef.png"><img src="https://habrastorage.org/storage2/d73/4a3/deb/d734a3deb05965b8207c68b307cadba8.png"></b>  - A great interface for getting the results of an asynchronous operation.  The key method here is the get method, which blocks the current thread (with or without timeout) until the asynchronous operation completes on another thread.  Also, in addition, there are methods for canceling the operation and checking the current status.  The FutureTask class is often used as implementation. <br><br>  <b>RunnableFuture &lt;V&gt;</b> <b><img src="https://habrastorage.org/storage2/36b/c31/fa2/36bc31fa2bdf7a08f3a85dff79ee4eef.png"><img src="https://habrastorage.org/storage2/c29/5ad/47f/c295ad47f86291abd7e8fe2b91b9621c.png"></b>  - If Future is an interface for the Client API, then the RunnableFuture interface is already used to start the asynchronous part.  Successful completion of the run () method completes the asynchronous operation and allows you to pull the results through the get method. <br><br>  <b>Callable &lt;V&gt;</b> <b><img src="https://habrastorage.org/storage2/36b/c31/fa2/36bc31fa2bdf7a08f3a85dff79ee4eef.png"><img src="https://habrastorage.org/storage2/d73/4a3/deb/d734a3deb05965b8207c68b307cadba8.png"></b>  - Enhanced analogue interface Runnable for asynchronous operations.  Allows you to return a typed value and throw a checked exception.  Although there is no run () method in this interface, many java.util.concurrent classes support it along with Runnable. <br><br>  <b>FutureTask &lt;V&gt;</b> <b><img src="https://habrastorage.org/storage2/0fb/43e/259/0fb43e259847760ecf54027457005e30.png"><img src="https://habrastorage.org/storage2/d73/4a3/deb/d734a3deb05965b8207c68b307cadba8.png"></b>  - Future / RunnableFuture interface implementation.  An asynchronous operation is taken to the input of one of the constructors in the form of Runnable or Callable objects.  The very same FutureTask class is designed to run in a worker thread, for example, through new Thread (task) .start (), or through ThreadPoolExecutor.  The results of an asynchronous operation are pulled out via the get (...) method. <br><br>  <b>Delayed</b> <b><img src="https://habrastorage.org/storage2/36b/c31/fa2/36bc31fa2bdf7a08f3a85dff79ee4eef.png"><img src="https://habrastorage.org/storage2/d73/4a3/deb/d734a3deb05965b8207c68b307cadba8.png"></b>  - Used for asynchronous tasks that should start in the future, as well as in the DelayQueue.  Allows you to set the time to start an asynchronous operation. <br><br>  <b>ScheduledFuture &lt;V&gt;</b> <b><img src="https://habrastorage.org/storage2/36b/c31/fa2/36bc31fa2bdf7a08f3a85dff79ee4eef.png"><img src="https://habrastorage.org/storage2/d73/4a3/deb/d734a3deb05965b8207c68b307cadba8.png"></b>  - Marker interface, combining Future and Delayed interfaces. <br><br>  <b>RunnableScheduledFuture &lt;V&gt;</b> <b><img src="https://habrastorage.org/storage2/36b/c31/fa2/36bc31fa2bdf7a08f3a85dff79ee4eef.png"><img src="https://habrastorage.org/storage2/c29/5ad/47f/c295ad47f86291abd7e8fe2b91b9621c.png"></b>  - Interface that combines RunnableFuture and ScheduledFuture.  Additionally, you can specify whether the task is a one-time task or it should be launched at a specified frequency. <br><br><h4>  Executor services </h4><br><img src="https://habrastorage.org/storage2/e0c/38d/f25/e0c38df25d2fd1d705976554c6452cb4.png"><br><br>  <b>Executor</b> <b><img src="https://habrastorage.org/storage2/36b/c31/fa2/36bc31fa2bdf7a08f3a85dff79ee4eef.png"><img src="https://habrastorage.org/storage2/d73/4a3/deb/d734a3deb05965b8207c68b307cadba8.png"></b>  - It is a basic interface for classes that run runnable tasks.  This ensures the isolation between adding a task and the way it is launched. <br><br>  <b>ExecutorService</b> <b><img src="https://habrastorage.org/storage2/36b/c31/fa2/36bc31fa2bdf7a08f3a85dff79ee4eef.png"><img src="https://habrastorage.org/storage2/d73/4a3/deb/d734a3deb05965b8207c68b307cadba8.png"></b>  - An interface that describes a service for running Runnable or Callable tasks.  The submit methods on an input accept a task in the form of Callable or Runnable, and the return value is the Future, through which you can get the result.  The invokeAll methods work with task lists with blocking the thread until all tasks in the passed list are completed or the specified timeout period expires.  The invokeAny methods block the calling thread until the completion of any transferred tasks.  Additionally, the interface contains methods for graceful shutdown.  After calling the shutdown method, this service will no longer accept tasks, throwing a RejectedExecutionException when trying to throw a task into the service. <br><br>  <b>ScheduledExecutorService</b> <b><img src="https://habrastorage.org/storage2/36b/c31/fa2/36bc31fa2bdf7a08f3a85dff79ee4eef.png"><img src="https://habrastorage.org/storage2/d73/4a3/deb/d734a3deb05965b8207c68b307cadba8.png"></b>  - In addition to the methods ExecutorService, this interface adds the ability to run pending tasks. <br><br>  <b>AbstractExecutorService</b> <b><img src="https://habrastorage.org/storage2/0fb/43e/259/0fb43e259847760ecf54027457005e30.png"><img src="https://habrastorage.org/storage2/93e/530/ead/93e530ead57ae1e70e6d067602e05095.png"><img src="https://habrastorage.org/storage2/d73/4a3/deb/d734a3deb05965b8207c68b307cadba8.png"></b>  - Abstract class for building ExecutorService.  The implementation contains the basic implementation of the methods submit, invokeAll, invokeAny.  ThreadPoolExecutor, ScheduledThreadPoolExecutor, and ForkJoinPool are inherited from this class. <br><br><h4>  ThreadPoolExecutor &amp; Factory </h4><br><img src="https://habrastorage.org/storage2/125/385/1e3/1253851e3b0952109c8282990ad9dbab.png"><br><br>  <b>Executors</b> <b><img src="https://habrastorage.org/storage2/0fb/43e/259/0fb43e259847760ecf54027457005e30.png"><img src="https://habrastorage.org/storage2/d73/576/c72/d73576c72fd0c51fe4fffbda47fd2791.png"><img src="https://habrastorage.org/storage2/d73/4a3/deb/d734a3deb05965b8207c68b307cadba8.png"></b>  - Factory class for creating ThreadPoolExecutor, ScheduledThreadPoolExecutor.  If you need to create one of these pools, this factory is exactly what you need.  Also, it contains various adapters Runnable-Callable, PrivilegedAction-Callable, PrivilegedExceptionAction-Callable and others. <br><br>  <b>ThreadPoolExecutor</b> <b><img src="https://habrastorage.org/storage2/0fb/43e/259/0fb43e259847760ecf54027457005e30.png"><img src="https://habrastorage.org/storage2/d73/4a3/deb/d734a3deb05965b8207c68b307cadba8.png"></b>  - Very powerful and important class.  Used to run asynchronous tasks in the thread pool.  Thus, the overhead to raise and stop flows is almost completely absent.  And due to the fixed maximum of threads in the pool, the projected application performance is ensured.  As previously stated, it is preferable to create this pool through one of the methods of the Executors factory.  If the standard configuration is not enough, then through the designers or setters you can set all the basic parameters of the pool.  More information can be found in this <a href="http://habrahabr.ru/post/116363/">topic</a> . <br><br>  <b>ScheduledThreadPoolExecutor</b> <b><img src="https://habrastorage.org/storage2/0fb/43e/259/0fb43e259847760ecf54027457005e30.png"><img src="https://habrastorage.org/storage2/d73/4a3/deb/d734a3deb05965b8207c68b307cadba8.png"></b>  - In addition to the methods ThreadPoolExecutor, allows you to run tasks after a certain delay, as well as with a certain frequency, which allows you to implement Timer Service on the basis of this class. <br><br>  <b>Threadfactory</b> <b><img src="https://habrastorage.org/storage2/36b/c31/fa2/36bc31fa2bdf7a08f3a85dff79ee4eef.png"><img src="https://habrastorage.org/storage2/d73/4a3/deb/d734a3deb05965b8207c68b307cadba8.png"></b>  - By default, ThreadPoolExecutor uses a standard thread factory, obtained through Executors.defaultThreadFactory ().  If you need something more, for example, setting a priority or a thread name, then you can create a class with the implementation of this interface and pass it to ThreadPoolExecutor. <br><br>  <b>RejectedExecutionHandler</b> <b><img src="https://habrastorage.org/storage2/36b/c31/fa2/36bc31fa2bdf7a08f3a85dff79ee4eef.png"><img src="https://habrastorage.org/storage2/d73/4a3/deb/d734a3deb05965b8207c68b307cadba8.png"></b>  - Allows you to define a handler for tasks that for some reason can not be performed through ThreadPoolExecutor.  Such a case can occur when there are no free threads or the service is shutting down or shutting down (shutdown).  Several standard implementations are in the ThreadPoolExecutor class: CallerRunsPolicy - runs the task in the calling thread;  AbortPolicy - throws an extra;  DiscardPolicy - ignores the task;  DiscardOldestPolicy - removes the oldest unallocated task from the queue, then tries to add a new task again. <br><br><h4>  Fork join </h4><br><img src="https://habrastorage.org/storage2/442/afd/335/442afd335b6fc6bf036109c65c4821c5.png"><br><br>  In java 1.7, a new Fork Join framework for solving recursive tasks using the <a href="http://en.wikipedia.org/wiki/Divide_and_conquer_algorithm">divide and manage</a> or <a href="http://ru.wikipedia.org/wiki/MapReduce">Map Reduce</a> algorithms has <a href="http://en.wikipedia.org/wiki/Divide_and_conquer_algorithm">appeared</a> .  To make it clearer, you can give a visual example of the quicksort sorting algorithm: <br> <a href="http://en.wikipedia.org/wiki/Quicksort"><img src="https://habrastorage.org/getpro/habr/post_images/32b/7ee/094/32b7ee0946a84e4038f357a4b668d5ad.gif"></a> <br>  So, due to splitting into parts, it is possible to achieve their parallel processing in different streams.  To solve this problem, you can use the usual ThreadPoolExecutor, but due to frequent context switching and tracking the execution control, all this does not work very effectively.  This is where the Fork Join framework comes to the rescue. It is based on the <a href="http://classes.engineering.wustl.edu/cse566s/presentations/WorkStealing.pdf">work-stealing</a> algorithm.  Most well reveals itself in systems with a large number of processors.  More information can be found on the blog <a href="http://www.igvita.com/2012/02/29/work-stealing-and-recursive-partitioning-with-fork-join/">here</a> or the <a href="http://gee.cs.oswego.edu/dl/papers/fj.pdf">publication of</a> Doug Lea.  Pro performance and scalability can be read <a href="http://letitcrash.com/post/17607272336/scalability-of-fork-join-pool">here</a> . <br><br>  <b>ForkJoinPool</b> <b><img src="https://habrastorage.org/storage2/0fb/43e/259/0fb43e259847760ecf54027457005e30.png"><img src="https://habrastorage.org/storage2/968/b76/9b1/968b769b1a83359a83e5fd169d8dbde4.png"></b>  - It is an entry point for running root (main) ForkJoinTask tasks.  Subtasks are launched through the methods of the task from which you want to shoot (fork).  By default, a thread pool is created with the number of threads equal to the number of cores available for JVM processors. <br><br>  <b>ForkJoinTask</b> <b><img src="https://habrastorage.org/storage2/0fb/43e/259/0fb43e259847760ecf54027457005e30.png"><img src="https://habrastorage.org/storage2/93e/530/ead/93e530ead57ae1e70e6d067602e05095.png"><img src="https://habrastorage.org/storage2/968/b76/9b1/968b769b1a83359a83e5fd169d8dbde4.png"></b>  - Base class for all Fork Join tasks.  Key methods include: fork () - adds a task to the current thread's queue ForkJoinWorkerThread for asynchronous execution;  invoke () - runs the task in the current thread;  join () - waits for completion of the subtask with the return of the result;  invokeAll (...) - combines all three previous previous operations, performing two or more tasks in one go;  adapt (...) - creates a new task ForkJoinTask from Runnable or Callable objects. <br><br>  <b>RecursiveTask</b> <b><img src="https://habrastorage.org/storage2/0fb/43e/259/0fb43e259847760ecf54027457005e30.png"><img src="https://habrastorage.org/storage2/93e/530/ead/93e530ead57ae1e70e6d067602e05095.png"><img src="https://habrastorage.org/storage2/968/b76/9b1/968b769b1a83359a83e5fd169d8dbde4.png"></b>  - Abstract class from ForkJoinTask, with the declaration of the compute method, in which an asynchronous operation should be performed in the heir. <br><br>  <b>RecursiveAction</b> <b><img src="https://habrastorage.org/storage2/0fb/43e/259/0fb43e259847760ecf54027457005e30.png"><img src="https://habrastorage.org/storage2/93e/530/ead/93e530ead57ae1e70e6d067602e05095.png"><img src="https://habrastorage.org/storage2/968/b76/9b1/968b769b1a83359a83e5fd169d8dbde4.png"></b>  - Differs from RecursiveTask in that it does not return a result. <br><br>  <b>ForkJoinWorkerThread</b> <b><img src="https://habrastorage.org/storage2/0fb/43e/259/0fb43e259847760ecf54027457005e30.png"><img src="https://habrastorage.org/storage2/968/b76/9b1/968b769b1a83359a83e5fd169d8dbde4.png"></b>  - Used as default implementation in ForkJoinPoll.  If desired, you can follow and overload the initialization and completion methods of the worker flow. <br><br><h4>  Completion Service </h4><br><img src="https://habrastorage.org/storage2/d26/de6/de1/d26de6de112cf6e1b8475162e54016c4.png"><br><br>  <b>CompletionService</b> <b><img src="https://habrastorage.org/storage2/36b/c31/fa2/36bc31fa2bdf7a08f3a85dff79ee4eef.png"><img src="https://habrastorage.org/storage2/d73/4a3/deb/d734a3deb05965b8207c68b307cadba8.png"></b>  - Service interface with decoupling the launch of asynchronous tasks and obtaining results.  So, for adding tasks, the submit methods are used, and for pulling the results of <i>completed</i> tasks, the blocking take method and non-blocking poll are used. <br><br>  <b>ExecutorCompletionService</b> <b><img src="https://habrastorage.org/storage2/0fb/43e/259/0fb43e259847760ecf54027457005e30.png"><img src="https://habrastorage.org/storage2/d73/4a3/deb/d734a3deb05965b8207c68b307cadba8.png"></b>  - In fact, it is a wrapper over any class that implements the Executor interface, for example ThreadPoolExecutor or ForkJoinPool.  It is used mainly when you want to abstract from the method of launching tasks and controlling their execution.  If there are completed tasks - pull them out, if not - wait in take until something is completed.  The default service is based on LinkedBlockingQueue, but any other implementation of BlockingQueue can be transmitted. <br><br><br><br><h1>  5. Locks </h1><br><img src="https://habrastorage.org/storage2/4f1/edf/0f8/4f1edf0f8640f54475bf37ff72d04895.png"><br><br>  <b>Condition</b> <b><img src="https://habrastorage.org/storage2/36b/c31/fa2/36bc31fa2bdf7a08f3a85dff79ee4eef.png"><img src="https://habrastorage.org/storage2/d73/4a3/deb/d734a3deb05965b8207c68b307cadba8.png"></b>  - An interface that describes alternative methods to the standard wait / notify / notifyAll.  An object with a condition is most often obtained from locks via the lock.newCondition () method.  Thereby it is possible to get several sets of wait / notify for one object. <br><br>  <b>Lock</b> <b><img src="https://habrastorage.org/storage2/36b/c31/fa2/36bc31fa2bdf7a08f3a85dff79ee4eef.png"><img src="https://habrastorage.org/storage2/d73/4a3/deb/d734a3deb05965b8207c68b307cadba8.png"></b>  - The base interface of the lock framework, which provides a more flexible approach to limit access to resources / blocks rather than using synchronized.  So, when using multiple locks, the order of their release can be arbitrary.  Plus there is an opportunity to go on an alternative scenario, if the lock is already captured by someone. <br><br>  <b>Reentrant lock</b> <b><img src="https://habrastorage.org/storage2/0fb/43e/259/0fb43e259847760ecf54027457005e30.png"><img src="https://habrastorage.org/storage2/d73/4a3/deb/d734a3deb05965b8207c68b307cadba8.png"></b>  - Lock on entry.  Only one thread can enter a protected block.  The class supports ‚Äúfair‚Äù (fair) and ‚Äúunfair‚Äù (non-fair) unblocking of threads.  When ‚Äúfair‚Äù unlocking, the order of freeing the threads calling lock () is observed.  With ‚Äúunfair‚Äù unlocking, the order of freeing threads is not guaranteed, but, as a bonus, such unlocking works faster.  By default, ‚Äúunfair‚Äù unlocking is used. <br><br>  <b>ReadWriteLock</b> <b><img src="https://habrastorage.org/storage2/36b/c31/fa2/36bc31fa2bdf7a08f3a85dff79ee4eef.png"><img src="https://habrastorage.org/storage2/d73/4a3/deb/d734a3deb05965b8207c68b307cadba8.png"></b>  - Additional interface for creating read / write locks.  Such locks are extremely useful when the system has many reads and few write operations. <br><br>  <b>ReentrantReadWriteLock</b> <b><img src="https://habrastorage.org/storage2/0fb/43e/259/0fb43e259847760ecf54027457005e30.png"><img src="https://habrastorage.org/storage2/d73/4a3/deb/d734a3deb05965b8207c68b307cadba8.png"></b>  - Very often used in multithreaded services and caches, showing a very good performance boost compared to synchronized blocks.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In fact, the class works in 2 mutually exclusive modes: many readers read data in parallel and when only 1 writer writes data. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ReentrantReadWriteLock.ReadLock</font></font><img src="https://habrastorage.org/storage2/0fb/43e/259/0fb43e259847760ecf54027457005e30.png"><img src="https://habrastorage.org/storage2/d73/4a3/deb/d734a3deb05965b8207c68b307cadba8.png"></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Read lock for readers, obtained through readWriteLock.readLock (). </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ReentrantReadWriteLock.WriteLock</font></font><img src="https://habrastorage.org/storage2/0fb/43e/259/0fb43e259847760ecf54027457005e30.png"><img src="https://habrastorage.org/storage2/d73/4a3/deb/d734a3deb05965b8207c68b307cadba8.png"></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Write lock for writers, obtained through readWriteLock.writeLock (). </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LockSupport</font></font><img src="https://habrastorage.org/storage2/0fb/43e/259/0fb43e259847760ecf54027457005e30.png"><img src="https://habrastorage.org/storage2/d73/4a3/deb/d734a3deb05965b8207c68b307cadba8.png"></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Designed for building classes with locks. Contains methods for parking threads instead of obsolete methods Thread.suspend () and Thread.resume (). </font></font><br><br><img src="https://habrastorage.org/storage2/928/8f8/e77/9288f8e777b62ff96c4c953471e27f60.png"><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AbstractOwnableSynchronizer</font></font><img src="https://habrastorage.org/storage2/0fb/43e/259/0fb43e259847760ecf54027457005e30.png"><img src="https://habrastorage.org/storage2/c29/5ad/47f/c295ad47f86291abd7e8fe2b91b9621c.png"></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - The base class for building mechanisms for synchronization. It contains only one pair of getter / setter for storing and reading an exclusive stream that can work with data.</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AbstractQueuedSynchronizer</font></font><img src="https://habrastorage.org/storage2/0fb/43e/259/0fb43e259847760ecf54027457005e30.png"><img src="https://habrastorage.org/storage2/d73/4a3/deb/d734a3deb05965b8207c68b307cadba8.png"></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Used as the base class for the synchronization mechanism in FutureTask, CountDownLatch, Semaphore, ReentrantLock, ReentrantReadWriteLock. </font><font style="vertical-align: inherit;">It can be used to create new synchronization mechanisms that rely on single and atomic int values. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AbstractQueuedLongSynchronizer</font></font><img src="https://habrastorage.org/storage2/0fb/43e/259/0fb43e259847760ecf54027457005e30.png"><img src="https://habrastorage.org/storage2/c29/5ad/47f/c295ad47f86291abd7e8fe2b91b9621c.png"></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - An </font><b><font style="vertical-align: inherit;">AbstractQueuedSynchronizer</font></b><font style="vertical-align: inherit;"> variation that supports an atomic long value.</font></font><br><br><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 6. Atomics </font></font></h1><br><img src="https://habrastorage.org/storage2/5be/563/489/5be563489a039bcb4033edecd3ed0cca.png"><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AtomicBoolean</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AtomicInteger</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AtomicLong</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AtomicIntegerArray</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AtomicLongArray</font></font><img src="https://habrastorage.org/storage2/0fb/43e/259/0fb43e259847760ecf54027457005e30.png"><img src="https://habrastorage.org/storage2/d73/4a3/deb/d734a3deb05965b8207c68b307cadba8.png"></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - What if a class needs to synchronize access to one simple int variable? You can use constructions with synchronized, and when using atomic set / get operations, volatile is also suitable. But you can do even better by using the new Atomic classes *. Through the use of </font></font><a href="http://en.wikipedia.org/wiki/Compare-and-swap"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CAS</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , operations with these classes work faster than if synchronized via synchronized / volatile. Plus, there are methods for atomic addition by a given amount, as well as increment / decrement. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AtomicReference</font></font><img src="https://habrastorage.org/storage2/0fb/43e/259/0fb43e259847760ecf54027457005e30.png"><img src="https://habrastorage.org/storage2/d73/4a3/deb/d734a3deb05965b8207c68b307cadba8.png"></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - A class for atomic operations with an object reference.</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AtomicMarkableReference</font></font><img src="https://habrastorage.org/storage2/0fb/43e/259/0fb43e259847760ecf54027457005e30.png"><img src="https://habrastorage.org/storage2/d73/4a3/deb/d734a3deb05965b8207c68b307cadba8.png"></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - A class for an atomic operation with the following pair of fields: an object reference and a bit flag (true / false). </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AtomicStampedReference</font></font><img src="https://habrastorage.org/storage2/0fb/43e/259/0fb43e259847760ecf54027457005e30.png"><img src="https://habrastorage.org/storage2/d73/4a3/deb/d734a3deb05965b8207c68b307cadba8.png"></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - A class for an atomic operation with the following pair of fields: an object reference and an int value. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AtomicReferenceArray</font></font><img src="https://habrastorage.org/storage2/0fb/43e/259/0fb43e259847760ecf54027457005e30.png"><img src="https://habrastorage.org/storage2/d73/4a3/deb/d734a3deb05965b8207c68b307cadba8.png"></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - An array of object references that can be atomically updated. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AtomicIntegerFieldUpdater</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AtomicLongFieldUpdater</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AtomicReferenceFieldUpdater</font></font><img src="https://habrastorage.org/storage2/0fb/43e/259/0fb43e259847760ecf54027457005e30.png"><img src="https://habrastorage.org/storage2/d73/4a3/deb/d734a3deb05965b8207c68b307cadba8.png"></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Classes for the atomic update of fields by their names through reflection. The offset fields for CAS is determined in the constructor and cached, t.ch. there is no dramatic drop in performance due to reflection.</font></font><br><br><h1>  Instead of conclusion </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thank you for reading to the end, or at least leafing through the article to the end. </font><font style="vertical-align: inherit;">I just want to emphasize that there is only a brief description of the classes without any examples. </font><font style="vertical-align: inherit;">This was done deliberately so as not to clutter the article with excessive code inserts. </font><font style="vertical-align: inherit;">The basic idea: to give a quick overview of the classes in order to know which direction to go and what to use. </font><font style="vertical-align: inherit;">Examples of using classes can be easily found on the Internet or in the source code of the classes themselves. </font><font style="vertical-align: inherit;">I hope this post will help to quickly and efficiently solve interesting problems with multithreading.</font></font><br><img src="http://habr.habrastorage.org/post_images/afa/19d/045/afa19d045b2bce238895a5f2856f9174.gif" alt="image"></div><p>Source: <a href="https://habr.com/ru/post/157273/">https://habr.com/ru/post/157273/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../157259/index.html">Test suite to help a freelancer survive on Elance.com</a></li>
<li><a href="../157263/index.html">Ocean robot Mercury withstood the onslaught of Hurricane Sandy</a></li>
<li><a href="../157265/index.html">Control flow abstraction</a></li>
<li><a href="../157267/index.html">Entity Framework 6 - ALPHA</a></li>
<li><a href="../157271/index.html">What caused general dissatisfaction with the state of innovation?</a></li>
<li><a href="../157275/index.html">Minix NEO G4 - a miniature PC with a dual-core processor for 76 $.</a></li>
<li><a href="../157279/index.html">A selection of tools for creating web interfaces in the style of Metro</a></li>
<li><a href="../157281/index.html">OpenCV 2.4.3</a></li>
<li><a href="../157283/index.html">About different Linux and Unix shells</a></li>
<li><a href="../157285/index.html">IDC excluded Nokia from the top manufacturers of smartphones</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>