<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Python Testing with pytest. CHAPTER 3 pytest Fixtures</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Back Next 


 This book is the missing chapter, missing from every comprehensive Python book. 


 Frank Ruiz 
 Principal Site Reliability Engineer, Bo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Python Testing with pytest. CHAPTER 3 pytest Fixtures</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/webt/jl/jn/bb/jljnbbjr-ejh473xy_eccsmknpk.png">  <a href="https://habr.com/ru/post/448788/">Back</a> <a href="https://habr.com/ru/post/448792/">Next</a> <img src="https://habrastorage.org/webt/rw/dy/-g/rwdy-grsvbpcetjttrmecdkxtlk.png"></p><br><p>  This book is the missing chapter, missing from every comprehensive Python book. </p><br><p>  Frank Ruiz <br>  Principal Site Reliability Engineer, Box, Inc. </p><br><p><img src="https://habrastorage.org/webt/hd/--/9w/hd--9w134j0rxhmxftrflbbdopy.png"></p><a name="habracut"></a><br><p>  The examples in this book are written using Python 3.6 and pytest 3.2.  pytest 3.2 supports Python 2.6, 2.7 and Python 3.3+ </p><br><blockquote>  The source code for the Tasks project, as well as for all the tests shown in this book, is available via the <a href="https://pragprog.com/titles/bopytest/source_code" title="https://pragprog.com/titles/bopytest/source_code">link</a> on the book's web page at <a href="https://pragprog.com/titles/bopytest" title="https://pragprog.com/titles/bopytest">pragprog.com</a> .  You do not need to download the source code to understand the test code;  The test code is presented in a convenient form in the examples.  But to follow along with the project objectives, or to adapt test examples to test your own project (your hands are untied!), You should go to the book‚Äôs web page and download the work.  In the same place, on the book‚Äôs web page there is a link for <a href="https://pragprog.com/titles/bopytest/errata" title="https://pragprog.com/titles/bopytest/errata">errata</a> messages and a <a href="https://forums.pragprog.com/forums/438" title="https://forums.pragprog.com/forums/438">discussion forum</a> . </blockquote><p>  Under the spoiler is a list of articles in this series. </p><br><div class="spoiler">  <b class="spoiler_title">Table of contents</b> <div class="spoiler_text"><ul><li>  <a href="https://habr.com/ru/post/426699/"><strong>Introduction</strong></a> </li><li>  <a href="https://habr.com/ru/post/448782/"><strong>Chapter 1: Getting Started with pytest</strong></a> </li><li>  <a href="https://habr.com/ru/post/448788/"><strong>Chapter 2: Writing Test Functions</strong></a> </li><li>  <a href="https://habr.com/ru/post/448786/"><strong>Chapter 3: Pytest Fixtures</strong></a> (This article) </li><li>  <a href="https://habr.com/ru/post/448792/"><strong>Chapter 4: Builtin Fixtures</strong></a> </li><li>  <a href="https://habr.com/ru/post/448794/"><strong>Chapter 5: Plugins</strong></a> </li><li>  <a href="https://habr.com/ru/post/448796/"><strong>Chapter 6: Configuration</strong></a> </li><li>  <a href="https://habr.com/ru/post/448798/"><strong>Chapter 7: Using pytest with other tools</strong></a> </li></ul></div></div><br><p>  Now that you have seen the basics of pytest, let's turn our attention to fixtures, which are necessary for structuring test code for almost any non-trivial software system.  Fixtures are functions performed by pytest before (and sometimes after) the actual test functions.  Code in fixture can do everything you need.  You can use fixtures to get a dataset for testing.  You can use Fixtures to get the system in a known state before running the test.  Fixtures are also used to retrieve data for multiple tests. </p><br><p>  Here is a simple fixture example that returns a number: </p><br><blockquote> <strong>ch3 / <code>test_fixtures.py</code></strong> </blockquote><br><pre> <code class="plaintext hljs">import pytest @pytest.fixture() def some_data(): """Return answer to ultimate question.""" return 42 def test_some_data(some_data): """Use fixture return value in a test.""" assert some_data == 42</code> </pre> <br><p>  The <code>@pytest.fixture()</code> decorator is used to tell pytest that a function is a fixture.  When you include the name of the fixture in the parameter list of the test function, pytest knows how to start it before running the test.  Fixtures can do work, and can return data to a test function. </p><br><p>  The test <code>test_some_data()</code> has as a parameter the name of the <code>some_data</code> .  pytest will detect this and find a fixture with that name.  The name is significant in pytest.  pytest will search for a fixture with that name in the test module.  He will also search the <em>conftest.py</em> file if he does not find it in it. </p><br><p>  Before we begin our study of fixtures (and the conftest.py file), I need to consider the fact that the term fixture has many meanings in the programming and testing community, and even in the Python community.  I use the <code>fixture</code> , <code>fixture function</code> , and <code>fixture method</code> interchangeably to refer to the <code>@pytest.fixture()</code> functions described in this chapter.  Fixture can also be used to refer to a resource that is referenced by a fixture function.  Fixture functions often set up or extract some data that a test can work with.  Sometimes these data are considered fixture.  For example, the Django community often uses fixture to indicate some source data that is loaded into a database at the beginning of an application. </p><br><p>  Regardless of other meanings, in pytest and in this book, test fixtures refer to the mechanism that pytest provides to separate the ‚Äúpreparing for (getting ready for)‚Äù and ‚Äúcleaning up after‚Äù codes from your test functions. </p><br><p>  pytest fixtures is one of the unique pieces that raise the pytest over other test environments, and are the reason why many respected people switch to ... and stay with pytest.  However, the fixtures in pytest are different from those in Django and differ from the setup and teardown procedures found in unittest and nose.  There are many features and nuances if we talk about fixtures.  Once you get a good mental model of how they work, you will feel better.  However, you need to play around with them for a while to enter, so let's get started. </p><br><h2 id="obmen-fixtures-cherez-conftestpy">  Sharing Fixtures via conftest.py </h2><br><p>  You can place fixtures in separate test files, but to share fixtures in several test files, it is better to use the <em>conftest.py</em> file somewhere in a common place, centralized for all tests.  For the task project, all fixtures will be in <code>tasks_proj/tests/conftest.py</code> . </p><br><p>  From there, fixtures can be separated by any dough.  You can put fixtures in separate test files if you want fixture to be used only in tests of this file.  Similarly, you can have other <em>conftest.py</em> files in the subdirectories of the <em>top tests</em> directory.  If you do this, the fixtures defined in these low-level conftest.py files will be available for tests in this directory and subdirectories.  However, until now the fixtures in the ‚ÄúTasks‚Äù project were intended for any test.  Therefore, using all our tools in the <em>conftest.py</em> file in the root of the test, <code>tasks_proj/tests</code> , makes the most sense. </p><br><p>  Although conftest.py is a Python module, it should not be imported by test files.  Do not import the conftest or when!  The conftest.py file is read by pytest and is considered a local plug-in, which will become clear when we start talking about plug-ins in chapter 5 ‚ÄúPlug-ins‚Äù on page 95. For now, <code>tests/conftest.py</code> as a place where we can put fixtures to use all tests in the test directory.  Then let's rework some of our tests for <code>task_proj</code> to use fixtures correctly. </p><br><h2 id="ispolzovanie--fixtures-dlya-setup-i-teardown">  Using Fixtures for Setup and Teardown </h2><br><p>  Most of the tests in the Tasks project assume that the Tasks database is already configured, running, and ready.  And we have to remove some records at the end if there is any need for cleaning.  And you may also need to disconnect from the database.  Fortunately, most of this is taken care of in the tasks code with <code>tasks.start_tasks_db(&lt;directory to store db\&gt;, 'tiny' or 'mongo')</code> and <code>tasks.stop_tasks_db()</code> ;  we just need to call them at the right time, and we also need a temporary directory. </p><br><p>  Fortunately, pytest includes an excellent fixture called tmpdir.  We can use it for testing and do not have to worry about cleaning.  This is not magic, just a good coding practice from the most inquisitive people.  (Do not worry; we will analyze tmpdir and write it out in more detail using tmpdir_factory in the section ‚ÄúUsing tmpdir and tmpdir_factory‚Äù on page 71.) </p><br><p>  With all these components, this fixture works great: </p><br><blockquote>  <strong>ch3 / a / <code>tasks_proj</code> / <code>tasks_proj</code> /conftest.py</strong> </blockquote><br><pre> <code class="plaintext hljs">import pytest import tasks from tasks import Task @pytest.fixture() def tasks_db(tmpdir): """    ,  .""" # Setup : start db tasks.start_tasks_db(str(tmpdir), 'tiny') yield #    # Teardown : stop db tasks.stop_tasks_db()</code> </pre> <br><p>  The value of <em>tmpdir is</em> not a string ‚Äî it is an object that represents a directory.  However, it implements <code>__str__</code> , so we can use <code>str()</code> to get the string to pass to <code>start_tasks_db()</code> .  For now, we still use tiny for TinyDB. </p><br><p>  The fixture function is run before the tests that use it.  However, if the function has <em>yield</em> , then there will be a stop, the control will be passed to the tests and the line following the <em>yield</em> will be executed after the tests are completed.  Therefore, think of the code above <em>yield</em> as ‚Äúsetup‚Äù, and of the code after <em>yield</em> as ‚Äúteardown‚Äù.  The code after the <em>yield</em> "teardown" will be executed regardless of what happens during the tests.  We do not return data with the release in this fixture.  But you can. </p><br><p>  Let's change one of our tests to <code>tasks.add()</code> to use this fixture: </p><br><blockquote>  h3 / a / <code>tasks_proj</code> / tests / func / <code>test_add</code> .py </blockquote><br><pre> <code class="plaintext hljs">import pytest import tasks from tasks import Task def test_add_returns_valid_id(tasks_db): """tasks.add(&lt;valid task&gt;)    .""" # GIVEN    # WHEN    # THEN  task_id  int new_task = Task('do something') task_id = tasks.add(new_task) assert isinstance(task_id, int)</code> </pre> <br><p>  The main change here is that the additional fixture in the file has been removed, and we added <code>tasks_db</code> to the list of test parameters.  I like to structure tests in the <em>GIVEN / WHEN / THEN</em> format (DANO / WHEN / AFTER) using comments, especially if it is not obvious from the code what is happening.  I think this is useful in this case.  I hope GIVEN initialized db tasks can help you figure out why <code>tasks_db</code> used as a tool for the test. </p><br><hr><br><p>  Make sure Tasks is installed. </p><br><hr><br><p>  We are still writing tests for the Tasks project in this chapter, which was first installed in chapter 2. If you missed this chapter, be sure to install the tasks with the cd code;  <code>pip install ./tasks_proj/</code> . </p><br><hr><br><h2 id="trassirovka-fixture-execution-s-setup-show">  Tracing Fixture Execution with ‚Äìsetup-show </h2><br><p>  If you run the test from the last section, you will not see which fixtures are running: </p><br><pre> <code class="plaintext hljs">$ cd /path/to/code/ $ pip install ./tasks_proj/ #      $ cd /path/to/code/ch3/a/tasks_proj/tests/func $ pytest -v test_add.py -k valid_id ===================== test session starts ====================== collected 3 items test_add.py::test_add_returns_valid_id PASSED ====================== 2 tests deselected ====================== ============ 1 passed, 2 deselected in 0.02 seconds ============</code> </pre> <br><p>  When I develop fixtures, I need to see what works and when.  Luckily, pytest provides this command line flag, <code>-- setup-show</code> , which does just that: </p><br><pre> <code class="plaintext hljs">$ pytest --setup-show test_add.py -k valid_id ============================= test session starts ============================= collected 3 items / 2 deselected test_add.py SETUP S tmpdir_factory SETUP F tmpdir (fixtures used: tmpdir_factory) SETUP F tasks_db (fixtures used: tmpdir) func/test_add.py::test_add_returns_valid_id (fixtures used: tasks_db, tmpdir, tmpdir_factory). TEARDOWN F tasks_db TEARDOWN F tmpdir TEARDOWN S tmpdir_factory =================== 1 passed, 2 deselected in 0.18 seconds ====================</code> </pre> <br><p>  Our test is in the middle, and the pytest designated part of the SETUP and TEARDOWN for each fixture.  Starting with <code>test_add_returns_valid_id</code> , you can see that <code>tmpdir</code> worked before the test.  And before that <code>tmpdir_factory</code> .  Apparently, <code>tmpdir</code> uses it as a fixture. </p><br><p>  <strong>F</strong> and <strong>S</strong> in front of the fixture names indicate the area.  <strong>F</strong> for scope and <strong>S</strong> for session area.  I will talk about the scope in the ‚ÄúScope of Fixture‚Äù section on page 56. </p><br><h2 id="ispolzovanie-fixtures-dlya-test-data">  Using Fixtures for Test Data </h2><br><p>  Fixtures are a great place to store data for testing.  You can return anything.  Here is the fixture returning a mixed tuple: </p><br><blockquote>  <strong>ch3 / test_fixtures.py</strong> </blockquote><br><pre> <code class="plaintext hljs">@pytest.fixture() def a_tuple(): """ -  """ return (1, 'foo', None, {'bar': 23}) def test_a_tuple(a_tuple): """Demo the a_tuple fixture.""" assert a_tuple[3]['bar'] == 32</code> </pre> <br><p>  Since <code>test_a_tuple()</code> should fail <em>(23! = 32)</em> , we will see what happens when the fixture test fails: </p><br><pre> <code class="plaintext hljs">$ cd /path/to/code/ch3 $ pytest test_fixtures.py::test_a_tuple ============================= test session starts ============================= collected 1 item test_fixtures.py F [100%] ================================== FAILURES =================================== ________________________________ test_a_tuple _________________________________ a_tuple = (1, 'foo', None, {'bar': 23}) def test_a_tuple(a_tuple): """Demo the a_tuple fixture.""" &gt; assert a_tuple[3]['bar'] == 32 E assert 23 == 32 test_fixtures.py:38: AssertionError ========================== 1 failed in 0.17 seconds ===========================</code> </pre> <br><p>  Together with the stack trace section, pytest displays the parameters of the function's value that caused the exception or did not pass assert.  In the case of tests, fixtures are the parameters for the test, so they are reported using the stack trace.  What happens if assert (or exception) happens in fixture? </p><br><pre> <code class="plaintext hljs">$ pytest -v test_fixtures.py::test_other_data ============================= test session starts ============================= test_fixtures.py::test_other_data ERROR [100%] =================================== ERRORS ==================================== ______________________ ERROR at setup of test_other_data ______________________ @pytest.fixture() def some_other_data(): """Raise an exception from fixture.""" x = 43 &gt; assert x == 42 E assert 43 == 42 test_fixtures.py:21: AssertionError =========================== 1 error in 0.13 seconds ===========================</code> </pre> <br><p>  A couple of things happen.  The stack trace correctly indicates that assert occurred in a fixture function.  In addition, <code>test_other_data</code> is not reported as <strong>FAIL</strong> , but as <strong>ERROR</strong> .  This is a big difference.  If the test suddenly fails, you know that the failure occurred in the test itself, and does not depend on some kind of fixture. </p><br><p>  But what about the Tasks project?  For the Tasks project, we could probably use some data fixtures, perhaps different task lists with different properties: </p><br><blockquote>  <strong>ch3 / a / tasks_proj / tests / conftest.py</strong> </blockquote><br><pre> <code class="plaintext hljs">#    Task constructor # Task(summary=None, owner=None, done=False, id=None) # summary    # owner  done   # id    @pytest.fixture() def tasks_just_a_few(): """    .""" return ( Task('Write some code', 'Brian', True), Task("Code review Brian's code", 'Katie', False), Task('Fix what Brian did', 'Michelle', False)) @pytest.fixture() def tasks_mult_per_owner(): """     .""" return ( Task('Make a cookie', 'Raphael'), Task('Use an emoji', 'Raphael'), Task('Move to Berlin', 'Raphael'), Task('Create', 'Michelle'), Task('Inspire', 'Michelle'), Task('Encourage', 'Michelle'), Task('Do a handstand', 'Daniel'), Task('Write some books', 'Daniel'), Task('Eat ice cream', 'Daniel'))</code> </pre> <br><p>  You can use them directly from tests, or from other fixtures.  Let's create with them non-empty databases for testing. </p><br><h2 id="ispolzovanie-multiple-fixtures">  Using Multiple Fixtures </h2><br><p>  You have already seen that tmpdir uses tmpdir_factory.  And you used tmpdir in our task_db fixture.  Let's continue the chain and add some specialized fixtures for the non-empty tasks project database: </p><br><blockquote>  <strong>ch3 / a / tasks_proj / tests / conftest.py</strong> </blockquote><br><pre> <code class="plaintext hljs">@pytest.fixture() def db_with_3_tasks(tasks_db, tasks_just_a_few): """   3 ,  .""" for t in tasks_just_a_few: tasks.add(t) @pytest.fixture() def db_with_multi_per_owner(tasks_db, tasks_mult_per_owner): """   9 , 3 owners,  3   .""" for t in tasks_mult_per_owner: tasks.add(t)</code> </pre> <br><p>  All these fixtures include two fixtures in their parameter list: <code>tasks_db</code> and a data set.  The data set is used to add tasks to the database.  Now tests can use them if you want the test to start with a non-empty database, for example: </p><br><blockquote>  <strong>ch3 / a / tasks_proj / tests / func / test_add.py</strong> </blockquote><br><pre> <code class="plaintext hljs">def test_add_increases_count(db_with_3_tasks): """Test tasks.add()    tasks.count().""" # GIVEN db  3  # WHEN     tasks.add(Task('throw a party')) # THEN    1 assert tasks.count() == 4</code> </pre> <br><p>  It also demonstrates one of the main reasons for using fixtures: to focus the test on what you are actually testing, and not on what you had to do to prepare for the test.  I like to use comments for GIVEN / WHEN / THEN and try to push as much data (GIVEN) as possible into fixtures for two reasons.  First, it makes the test more readable and, therefore, more maintainable.  Secondly, an assert or exception in a fixture results in an error (ERROR), while an assert or exception in a test function causes an error (FAIL).  I do not want <code>test_add_increases_count()</code> to <code>test_add_increases_count()</code> if the database initialization failed.  It is just confusing.  I want the failure (FAIL) <code>test_add_increases_count()</code> to be possible only if <code>add ()</code> really could not change the counter.  Let's run and see how all fixtures work: </p><br><pre> <code class="plaintext hljs">$ cd /path/to/code/ch3/a/tasks_proj/tests/func $ pytest --setup-show test_add.py::test_add_increases_count ============================= test session starts ============================= collected 1 item test_add.py SETUP S tmpdir_factory SETUP F tmpdir (fixtures used: tmpdir_factory) SETUP F tasks_db (fixtures used: tmpdir) SETUP F tasks_just_a_few SETUP F db_with_3_tasks (fixtures used: tasks_db, tasks_just_a_few) func/test_add.py::test_add_increases_count (fixtures used: db_with_3_tasks, tasks_db, tasks_just_a_few, tmpdir, tmpdir_factory). TEARDOWN F db_with_3_tasks TEARDOWN F tasks_just_a_few TEARDOWN F tasks_db TEARDOWN F tmpdir TEARDOWN S tmpdir_factory ========================== 1 passed in 0.20 seconds ===========================</code> </pre> <br><p>  We received again a bunch of Fs and S for the function and scope of the session.  Let's see what it is. </p><br><h2 id="specifikaciya-oblasteyscope-fixture">  Area Specification (Scope) Fixture </h2><br><p>  Fixtures include an optional parameter called <strong>scope</strong> , which determines how often the fixture gets setup and torndown.  The <em>scope</em> parameter for <code>@ pytest.fixture()</code> can be a function, class, module, or session.  <em>The</em> default <em>scope</em> is a function.  The tasks_db settings and all fixtures do not yet define an area.  Thus, they are functional fixtures. </p><br><p>  The following is a brief description of each <em>Scope</em> value: </p><br><ul><li><p>  <em>scope = 'function'</em> </p><br><p>  Runs once for each test function.  The setup part is run before each test using fixture.  The teardown part is started after each test using fixture.  This is the default scope if the scope parameter is not specified. </p><br></li><li><p>  <em>scope = 'class'</em> </p><br><p>  It is executed once for each test class, regardless of the number of test methods in the class. </p><br></li><li><p>  <em>scope = 'module'</em> </p><br><p>  It is executed once for each module, regardless of how many test functions or methods or other fixtures are used when using the module. </p><br></li><li><p>  <em>scope = 'session'</em> </p><br><p>  Runs once per session.  All testing methods and functions that use the session area fixture use the same setup and teardown calls. </p><br></li></ul><br><p>  Here is what the scope values ‚Äã‚Äãlook like in action: </p><br><blockquote>  <strong>ch3 / test_scope.py</strong> </blockquote><br><pre> <code class="plaintext hljs">"""Demo fixture scope.""" import pytest @pytest.fixture(scope='function') def func_scope(): """A function scope fixture.""" @pytest.fixture(scope='module') def mod_scope(): """A module scope fixture.""" @pytest.fixture(scope='session') def sess_scope(): """A session scope fixture.""" @pytest.fixture(scope='class') def class_scope(): """A class scope fixture.""" def test_1(sess_scope, mod_scope, func_scope): """   ,   .""" def test_2(sess_scope, mod_scope, func_scope): """     .""" @pytest.mark.usefixtures('class_scope') class TestSomething(): """Demo class scope fixtures.""" def test_3(self): """Test using a class scope fixture.""" def test_4(self): """Again, multiple tests are more fun."""</code> </pre> <br><p>  Let's use <code>--setup-show</code> to demonstrate that the number of fixture and setup calls paired with teardown are performed depending on the area: </p><br><pre> <code class="plaintext hljs">$ cd /path/to/code/ch3/ $ pytest --setup-show test_scope.py ============================= test session starts ============================= collected 4 items test_scope.py SETUP S sess_scope SETUP M mod_scope SETUP F func_scope test_scope.py::test_1 (fixtures used: func_scope, mod_scope, sess_scope). TEARDOWN F func_scope SETUP F func_scope test_scope.py::test_2 (fixtures used: func_scope, mod_scope, sess_scope). TEARDOWN F func_scope SETUP C class_scope test_scope.py::TestSomething::()::test_3 (fixtures used: class_scope). test_scope.py::TestSomething::()::test_4 (fixtures used: class_scope). TEARDOWN C class_scope TEARDOWN M mod_scope TEARDOWN S sess_scope ========================== 4 passed in 0.11 seconds ===========================</code> </pre> <br><p>  Now you can see not only <strong>F</strong> and <strong>S</strong> for the function and session, but also <strong>C</strong> and <strong>M</strong> for the class and module. </p><br><p>  The scope is determined using the fixture.  I know that this is obvious from the code, but this is an important point to make sure that you are completely grokate. ( <em>Translator‚Äôs note</em> : <strong>groaning</strong> - most likely the author means a term from Robert Heinlein‚Äôs novel The Stranger in a Foreign Country. Approximate meaning) deeply and intuitively understand").  The scope is specified in the fixture definition, and not in the place where it was called.  Test functions that use fixture do not control how often SETUP and fixture breaks (TEARDOWN). </p><br><p>  Fixtures can depend only on other fixtures from the same or more extended scope.  Thus, function scope fixture may depend on other function scope fixture (by default, it is still used in the Tasks project).  The function scope fixture may also depend on the class, module and fixtures of the session area, but never in the reverse order. </p><br><h3 id="smena-scope-dlya-tasks-project-fixtures">  Change Scope for Tasks Project Fixtures </h3><br><p>  Given this knowledge of scope, let's now change the scope of some of the Task project fixtures. </p><br><p>  Until now, we have not had problems with testing time.  But, you see, it is useless to create a temporary directory and a new database connection for each test.  As long as we can provide an empty database when necessary, this should be enough. </p><br><p>  To use something like <code>tasks_db</code> as a session area, you need to use <code>tmpdir_factory</code> , since <code>tmpdir</code> is the scope of the function and <code>tmpdir_factory</code> is the scope of the session.  Fortunately, this is just one line of code change (well, two, if you <code>tmpdir-&gt;tmpdir_factory</code> in the parameter list): </p><br><blockquote>  <strong>ch3 / b / tasks_proj / tests / conftest.py</strong> </blockquote><br><pre> <code class="plaintext hljs">"""Define some fixtures to use in the project.""" import pytest import tasks from tasks import Task @pytest.fixture(scope='session') def tasks_db_session(tmpdir_factory): """Connect to db before tests, disconnect after.""" temp_dir = tmpdir_factory.mktemp('temp') tasks.start_tasks_db(str(temp_dir), 'tiny') yield tasks.stop_tasks_db() @pytest.fixture() def tasks_db(tasks_db_session): """An empty tasks db.""" tasks.delete_all()</code> </pre> <br><p>  Here we changed <code>tasks_db</code> depending on <code>tasks_db_session</code> , and we deleted all the entries to make sure that it is empty.  Since we have not changed its name, none of the fixtures or tests that already include it should be changed. </p><br><p>  Data fixtures simply return value, so there‚Äôs really no reason for them to work all the time.  Once per session is enough: </p><br><blockquote>  <strong>ch3 / b / tasks_proj / tests / conftest.py</strong> </blockquote><br><pre> <code class="plaintext hljs"># Reminder of Task constructor interface # Task(summary=None, owner=None, done=False, id=None) # summary is required # owner and done are optional # id is set by database @pytest.fixture(scope='session') def tasks_just_a_few(): """All summaries and owners are unique.""" return ( Task('Write some code', 'Brian', True), Task("Code review Brian's code", 'Katie', False), Task('Fix what Brian did', 'Michelle', False)) @pytest.fixture(scope='session') def tasks_mult_per_owner(): """Several owners with several tasks each.""" return ( Task('Make a cookie', 'Raphael'), Task('Use an emoji', 'Raphael'), Task('Move to Berlin', 'Raphael'), Task('Create', 'Michelle'), Task('Inspire', 'Michelle'), Task('Encourage', 'Michelle'), Task('Do a handstand', 'Daniel'), Task('Write some books', 'Daniel'), Task('Eat ice cream', 'Daniel'))</code> </pre> <br><p>  Now let's see if all these changes will work with our tests: </p><br><pre> <code class="plaintext hljs">$ cd /path/to/code/ch3/b/tasks_proj $ pytest ===================== test session starts ====================== collected 55 items tests/func/test_add.py ... tests/func/test_add_variety.py ............................ tests/func/test_add_variety2.py ............ tests/func/test_api_exceptions.py ....... tests/func/test_unique_id.py . tests/unit/test_task.py .... ================== 55 passed in 0.17 seconds ===================</code> </pre> <br><p>  Looks like everything's fine.  Let's follow the fixtures for a single test file to see that different areas work according to our expectations: </p><br><pre> <code class="plaintext hljs">$ pytest --setup-show tests/func/test_add.py ============================= test session starts ============================= platform win32 -- Python 3.6.5, pytest-3.9.3, py-1.7.0, pluggy-0.8.0 rootdir: c:\_BOOKS_\pytest_si\bopytest-code\code\ch3\b\tasks_proj\tests, inifile: pytest.ini collected 3 items tests\func\test_add.py SETUP S tmpdir_factory SETUP S tasks_db_session (fixtures used: tmpdir_factory) SETUP F tasks_db (fixtures used: tasks_db_session) func/test_add.py::test_add_returns_valid_id (fixtures used: tasks_db, tasks_db_session, tmpdir_factory). TEARDOWN F tasks_db SETUP F tasks_db (fixtures used: tasks_db_session) func/test_add.py::test_added_task_has_id_set (fixtures used: tasks_db, tasks_db_session, tmpdir_factory). TEARDOWN F tasks_db SETUP S tasks_just_a_few SETUP F tasks_db (fixtures used: tasks_db_session) SETUP F db_with_3_tasks (fixtures used: tasks_db, tasks_just_a_few) func/test_add.py::test_add_increases_count (fixtures used: db_with_3_tasks, tasks_db, tasks_db_session, tasks_just_a_few, tmpdir_factory). TEARDOWN F db_with_3_tasks TEARDOWN F tasks_db TEARDOWN S tasks_db_session TEARDOWN S tmpdir_factory TEARDOWN S tasks_just_a_few ========================== 3 passed in 0.24 seconds ===========================</code> </pre> <br><p>  Yeah.  . <code>tasks_db_session</code>     ,    <code>task_db</code>        . </p><br><h3 id="specifying-fixtures-with-usefixtures"> Specifying Fixtures with usefixtures </h3><br><p>   ,   ,    ,       .  ,        <code>@pytest.mark.usefixtures('fixture1', 'fixture2')</code> . <em>usefixtures</em>  ,    ,  .          ‚Äî     .       : </p><br><blockquote> <strong>ch3/test_scope.py</strong> </blockquote><br><pre> <code class="plaintext hljs">@pytest.mark.usefixtures('class_scope') class TestSomething(): """Demo class scope fixtures.""" def test_3(self): """Test using a class scope fixture.""" def test_4(self): """Again, multiple tests are more fun."""</code> </pre> <br><p>  <em>usefixtures</em>    ,         .     ,       ,       . ,   -  <em>usefixtures</em> ,      . </p><br><h2 id="ispolzovanie--autouse-dlya-fixtures-that-always-get-used-kotorye-ispolzuyutsya-nepreryvno">  autouse  Fixtures That Always Get Used (  ) </h2><br><p>        ,  ,    (  <em>usefixtures</em>     ).     <em>autouse=True</em> ,    .     ,       ,              .    : </p><br><blockquote> <strong>ch3/test_autouse.py</strong> </blockquote><br><pre> <code class="plaintext hljs">""" autouse fixtures.""" import pytest import time @pytest.fixture(autouse=True, scope='session') def footer_session_scope(): """    session().""" yield now = time.time() print('--') print('finished : {}'.format(time.strftime('%d %b %X', time.localtime(now)))) print('-----------------') @pytest.fixture(autouse=True) def footer_function_scope(): """     .""" start = time.time() yield stop = time.time() delta = stop - start print('\ntest duration : {:0.3} seconds'.format(delta)) def test_1(): """   .""" time.sleep(1) def test_2(): """    .""" time.sleep(1.23)</code> </pre> <br><p>         ,         .     : </p><br><pre> <code class="plaintext hljs">$ cd /path/to/code/ch3 $ pytest -v -s test_autouse.py ===================== test session starts ====================== collected 2 items test_autouse.py::test_1 PASSED test duration : 1.0 seconds test_autouse.py::test_2 PASSED test duration : 1.24 seconds -- finished : 25 Jul 16:18:27 ----------------- =================== 2 passed in 2.25 seconds ===================</code> </pre> <br><p>  <em>autouse</em>  .  But this is the exception rather than the rule.    ,          . </p><br><p> ,    <em>autouse</em>  ,   ,       <code>tasks_db</code>   .   Tasks  ,     ,  ,      API   .      .      ,     . </p><br><h2 id="pereimenovanie-fixtures">  Fixtures </h2><br><p>  ,        ,  ,      . , <em>pytest</em>       name  <code>@pytest.fixture()</code> : </p><br><blockquote> <strong>ch3/ <code>test_rename_fixture.py</code></strong> </blockquote><br><pre> <code class="plaintext hljs">""" fixture renaming.""" import pytest @pytest.fixture(name='lue') def ultimate_answer_to_life_the_universe_and_everything(): """  .""" return 42 def test_everything(lue): """   .""" assert lue == 42</code> </pre> <br><p>  <em>lue</em>    <code>fixture</code> ,   <code>fixture_with_a_name_much_longer_than_lue</code> .    ,       <code>--setup-show</code> : </p><br><pre> <code class="plaintext hljs">$ pytest --setup-show test_rename_fixture.py ======================== test session starts ======================== collected 1 items test_rename_fixture.py SETUP F lue test_rename_fixture.py::test_everything (fixtures used: lue). TEARDOWN F lue ===================== 1 passed in 0.01 seconds ======================</code> </pre> <br><p>    ,   <em>lue</em> ,    pytest <code>--fixtures</code>       .     ,   ,    ,   : </p><br><pre> <code class="plaintext hljs">$ pytest --fixtures test_rename_fixture.py ======================== test session starts ======================= ... ------------------ fixtures defined from test_rename_fixture ------------------ lue Return ultimate answer. ================= no tests ran in 0.01 seconds =================</code> </pre> <br><p>      ‚Äî   .  , ,   ,  ,   ,   .    ,    <em>lue</em> .      ¬´Tasks¬ª: </p><br><pre> <code class="plaintext hljs">$ cd /path/to/code/ch3/b/tasks_proj $ pytest --fixtures tests/func/test_add.py ======================== test session starts ======================== ... tmpdir_factory Return a TempdirFactory instance for the test session. tmpdir Return a temporary directory path object which is unique to each test function invocation, created as a sub directory of the base temporary directory. The returned object is a `py.path.local`_ path object. ----------------------- fixtures defined from conftest ------------------------ tasks_db An empty tasks db. tasks_just_a_few All summaries and owners are unique. tasks_mult_per_owner Several owners with several tasks each. db_with_3_tasks Connected db with 3 tasks, all unique. db_with_multi_per_owner Connected db with 9 tasks, 3 owners, all with 3 tasks. tasks_db_session Connect to db before tests, disconnect after. =================== no tests ran in 0.01 seconds ====================</code> </pre> <br><p>  Cool!     <em>conftest.py</em> .        <code>tmpdir</code>  <code>tmpdir_factory</code> ,    . </p><br><h2 id="parametrizaciya-fikstur">   </h2><br><p>  [Parametrized Testing] ,  . 42,   .     .  -    ,      ,   : </p><br><blockquote> <code>ch3/b/tasks_proj/tests/func/test_add_variety2.py</code> <br> <br> """Test the tasks.add() API function.""" <br><br> import pytest <br> import tasks <br> from tasks import Task <br><br> tasks_to_try = (Task('sleep', done=True), <br> Task('wake', 'brian'), <br> Task('breathe', 'BRIAN', True), <br> Task('exercise', 'BrIaN', False)) 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     task_ids = ['Task({},{},{})'.format(t.summary, t.owner, t.done) <br> for t in tasks_to_try] <br><br> def equivalent(t1, t2): <br> """Check two tasks for equivalence.""" <br> return ((t1.summary == t2.summary) and <br> (t1.owner == t2.owner) and <br> (t1.done == t2.done)) </blockquote><p>  ,   ,      <code>a_task</code> : </p><br><blockquote> <strong>ch3/b/tasks_proj/tests/func/ <code>test_add_variety2.py</code></strong> <br><br> @pytest.fixture(params=tasks_to_try) <br> def a_task(request): <br> """ .""" <br> return request.param <br><br> def test_add_a(tasks_db, a_task): <br> """  a_task ( ids).""" <br> task_id = tasks.add(a_task) <br> t_from_db = tasks.get(task_id) <br> assert equivalent(t_from_db, a_task) </blockquote><p> ,    fixture,    ,    .      .    param,      ,  params  <code>@pytest.fixture(params=tasks_to_try)</code> . </p><br><p>  <code>a_task</code>   ‚Äî    <code>request.param</code>     ,  .        ,     ,       : </p><br><pre> <code class="plaintext hljs">$ cd /path/to/code/ch3/b/tasks_proj/tests/func $ pytest -v test_add_variety2.py::test_add_a ===================== test session starts ====================== collected 4 items test_add_variety2.py::test_add_a[a_task0] PASSED test_add_variety2.py::test_add_a[a_task1] PASSED test_add_variety2.py::test_add_a[a_task2] PASSED test_add_variety2.py::test_add_a[a_task3] PASSED =================== 4 passed in 0.03 seconds ===================</code> </pre> <br><p>    ,  pytest   ,   ()   .        ,       : </p><br><blockquote> <strong>ch3/b/tasks_proj/tests/func/ <code>test_add_variety2.py</code></strong> <br><br> @pytest.fixture(params=tasks_to_try, ids=task_ids) <br> def b_task(request): <br> """  .""" <br> return request.param <br><br> def test_add_b(tasks_db, b_task): <br> """  b_task,  .""" <br> task_id = tasks.add(b_task) <br> t_from_db = tasks.get(task_id) <br> assert equivalent(t_from_db, b_task) </blockquote><p>      : </p><br><pre> <code class="plaintext hljs">$ pytest -v test_add_variety2.py::test_add_b ===================== test session starts ====================== collected 4 items test_add_variety2.py::test_add_b[Task(sleep,None,True)] PASSED test_add_variety2.py::test_add_b[Task(wake,brian,False)] PASSED test_add_variety2.py::test_add_b[Task(breathe,BRIAN,True)] PASSED test_add_variety2.py::test_add_b[Task(exercise,BrIaN,False)] PASSED =================== 4 passed in 0.04 seconds ===================</code> </pre> <br><p>      <code>ids</code>  ,   ,   .    ,       : </p><br><blockquote> <strong>ch3/b/tasks_proj/tests/func/ <code>test_add_variety2.py</code></strong> <br><br> def id_func(fixture_value): <br> """   .""" <br> t = fixture_value <br> return 'Task({},{},{})'.format(t.summary, t.owner, t.done) <br><br> @pytest.fixture(params=tasks_to_try, ids=id_func) <br> def c_task(request): <br> """  (id_func)   .""" <br> return request.param <br><br> def test_add_c(tasks_db, c_task): <br> """    .""" <br> task_id = tasks.add(c_task) <br> t_from_db = tasks.get(task_id) <br> assert equivalent(t_from_db, c_task) </blockquote><p>         .       Task, <code>id_func()</code>     <em>Task</em> ,       <em>namedtuple</em>      <em>Task</em>      <em>Task</em>  .   ,      ,   : </p><br><pre> <code class="plaintext hljs">$ pytest -v test_add_variety2.py::test_add_c ===================== test session starts ====================== collected 4 items test_add_variety2.py::test_add_c[Task(sleep,None,True)] PASSED test_add_variety2.py::test_add_c[Task(wake,brian,False)] PASSED test_add_variety2.py::test_add_c[Task(breathe,BRIAN,True)] PASSED test_add_variety2.py::test_add_c[Task(exercise,BrIaN,False)] PASSED =================== 4 passed in 0.04 seconds ===================</code> </pre> <br><p>          .       ,   ,    .    , ! </p><br><h3 id="parametrizaciya-fixtures-v-tasks-project">  Fixtures  Tasks Project </h3><br><p>   ,         Tasks.      <em>TinyDB</em>   .   ,        .   ,   ,   ,   ,     <em>TinyDB</em> ,    <em>MongoDB</em> . </p><br><p>  ( ),     ,    <code>start_tasks_db()</code>   <code>tasks_db_session</code> : </p><br><blockquote> <a href="https://media.pragprog.com/titles/bopytest/code/ch3/b/tasks_proj/tests/conftest.py">ch3/b/tasks_proj/tests/conftest.py</a> <br><br> """      .""" <br><br> import pytest <br> import tasks <br> from tasks import Task <br><br> @pytest.fixture(scope='session') <br> def tasks_db_session(tmpdir_factory): <br> """    ,  .""" <br> temp_dir = tmpdir_factory.mktemp('temp') <br> tasks.start_tasks_db(str(temp_dir), 'tiny') <br> yield <br> tasks.stop_tasks_db() <br><br> @pytest.fixture() <br> def tasks_db(tasks_db_session): <br> """   tasks.""" <br> tasks.delete_all() </blockquote><p>  <code>db_type</code>   <code>start_tasks_db()</code>   .      ,        : </p><br><blockquote> <a href="https://media.pragprog.com/titles/bopytest/code/tasks_proj/src/tasks/api.py"><strong>tasks_proj/src/tasks/api.py</strong></a> </blockquote><br><pre> <code class="python hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">start_tasks_db</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(db_path, db_type)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># type: (str, str) -None """  API  .""" if not isinstance(db_path, string_types): raise TypeError('db_path must be a string') global _tasksdb if db_type == 'tiny': import tasks.tasksdb_tinydb _tasksdb = tasks.tasksdb_tinydb.start_tasks_db(db_path) elif db_type == 'mongo': import tasks.tasksdb_pymongo _tasksdb = tasks.tasksdb_pymongo.start_tasks_db(db_path) else: raise ValueError("db_type   'tiny'  'mongo'")</span></span></code> </pre> <br><p>   MongoDB,       db_type  mongo.  : </p><br><blockquote> <a href="https://media.pragprog.com/titles/bopytest/code/ch3/c/tasks_proj/tests/conftest.py"><strong>ch3/c/tasks_proj/tests/conftest.py</strong></a> </blockquote><br><pre> <code class="python hljs"> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> pytest <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> tasks <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> tasks <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Task <span class="hljs-comment"><span class="hljs-comment"># @pytest.fixture(scope='session', params=['tiny',]) @pytest.fixture(scope='session', params=['tiny', 'mongo']) def tasks_db_session(tmpdir_factory, request): """Connect to db before tests, disconnect after.""" temp_dir = tmpdir_factory.mktemp('temp') tasks.start_tasks_db(str(temp_dir), request.param) yield # this is where the testing happens tasks.stop_tasks_db() @pytest.fixture() def tasks_db(tasks_db_session): """An empty tasks db.""" tasks.delete_all()</span></span></code> </pre> <br><p>    params=['tiny',' mongo']  -.   <code>request</code>    <em>temp_db</em>   <em>db_type</em>  <code>request.param</code>  ,    "tiny"  "mongo". </p><br><p>   <code>--verbose</code>   <code>-v</code>    pytest     , pytest        .      ,   . </p><br><hr><br><p>  <strong>Installing MongoDB</strong> </p><br><hr><br><p>    MongoDB, ,   MongoDB  <em>pymongo</em> .       MongoDB,   <a href="https://www.mongodb.com/download-center">https://www.mongodb.com/download-center</a> . pymongo   pip‚Äî <em>pip install pymongo</em> .   MongoDB       ;           <strong> 7</strong> . </p><br><hr><br><p>     : </p><br><pre> <code class="plaintext hljs"> $ cd /path/to/code/ch3/c/tasks_proj $ pip install pymongo $ pytest -v --tb=no ===================== test session starts ====================== collected 92 items test_add.py::test_add_returns_valid_id[tiny] PASSED test_add.py::test_added_task_has_id_set[tiny] PASSED test_add.py::test_add_increases_count[tiny] PASSED test_add_variety.py::test_add_1[tiny] PASSED test_add_variety.py::test_add_2[tiny-task0] PASSED test_add_variety.py::test_add_2[tiny-task1] PASSED ... test_add.py::test_add_returns_valid_id[mongo] FAILED test_add.py::test_added_task_has_id_set[mongo] FAILED test_add.py::test_add_increases_count[mongo] PASSED test_add_variety.py::test_add_1[mongo] FAILED test_add_variety.py::test_add_2[mongo-task0] FAILED ... ============= 42 failed, 50 passed in 4.94 seconds =============</code> </pre> <br><p>  Hm  Bummer. ,     ,     -   Mongo.  ,     pdb:   ,  . 125.        TinyDB. </p><br><h2 id="uprazhneniya">  Exercises </h2><br><ol><li>    <code>test_fixtures.py</code> . <br> 2.  fixtures‚Äîfunctions     <code>@pytest.fixture()</code> ,     . ,   ,  . </li><li>         ,   . </li><li>   ,       . </li><li>  <code>pytest --setup-show test_fixtures.py</code> .      ? </li><li>  <code>scope= 'module'</code>     4. </li><li>   <code>pytest --setup-show test_fixtures.py</code> .  ? </li><li>     6  <code>return &lt;data&gt;</code>  <code>yield &lt;data&gt;</code> . </li><li>       <code>yield</code> . </li><li>  <code>pytest -s -v test_fixtures.py</code> .    ? </li></ol><br><h2 id="chto-dalshe">  What's next </h2><br><p>  pytest fixture  ,   ,   <em>building blocks</em> ,    <em>setup</em>  <em>teardown</em> ,        (,  Mongo  TinyDB).    ,      ,         . </p><br><p>       pytest,   ,    (builtin)  tmpdir  tmpdir_factory.        (builtin) . </p><br><p><img src="https://habrastorage.org/webt/jl/jn/bb/jljnbbjr-ejh473xy_eccsmknpk.png">  <a href="https://habr.com/ru/post/448788/">Back</a> <a href="https://habr.com/ru/post/448792/">Next</a> <img src="https://habrastorage.org/webt/rw/dy/-g/rwdy-grsvbpcetjttrmecdkxtlk.png"></p></div><p>Source: <a href="https://habr.com/ru/post/448786/">https://habr.com/ru/post/448786/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../448766/index.html">Create a mono-repository with lerna & yarn workspaces</a></li>
<li><a href="../448768/index.html">Multi-level lighting control: fault tolerance solutions and products</a></li>
<li><a href="../448774/index.html">SQL to CSV using DBMS_SQL</a></li>
<li><a href="../448780/index.html">What gives software for recruiting money</a></li>
<li><a href="../448782/index.html">Python Testing with pytest. Getting started with pytest, Chapter 1</a></li>
<li><a href="../448788/index.html">Python Testing with pytest. Chapter 2, Writing Test Functions</a></li>
<li><a href="../448790/index.html">SpaceVIL - cross-platform GUI framework for development on .Net Core, .Net Standard and JVM</a></li>
<li><a href="../448792/index.html">Python Testing with pytest. Builtin Fixtures, Chapter 4</a></li>
<li><a href="../448794/index.html">Python Testing with pytest. Plugins, CHAPTER 5</a></li>
<li><a href="../448796/index.html">Python Testing with pytest. Configuration, CHAPTER 6</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>