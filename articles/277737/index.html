<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Lazy list in C ++</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In Scala there is an interesting collection - Stream. The container, which is a list, whose elements are calculated (and saved after this) at the firs...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Lazy list in C ++</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/05b/f52/ba9/05bf52ba931046cfade822f59a25b399.png"><br>  In Scala there is an interesting collection - Stream.  The container, which is a list, whose elements are calculated (and saved after this) at the first call: <br><br><blockquote>  Stream implements lazy lists where elements are only evaluated when they are needed. </blockquote><br>  I wanted to implement something similar in C ++. <br><a name="habracut"></a><br><h1>  purpose </h1><br>  I want to get a container that can be used with standard algorithms and that its elements can be generated as they are accessed. <br><br><div class="spoiler">  <b class="spoiler_title">Looking ahead, I will give an example of use:</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> lazy::<span class="hljs-built_in"><span class="hljs-built_in">list</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; list_type; <span class="hljs-function"><span class="hljs-function">list_type </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fibonacci</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n2)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> next = n1 + n2; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"fibonacci("</span></span> &lt;&lt; n1 &lt;&lt; <span class="hljs-string"><span class="hljs-string">", "</span></span> &lt;&lt; n2 &lt;&lt; <span class="hljs-string"><span class="hljs-string">") -&gt; "</span></span> &lt;&lt; n1 &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> list_type(n1, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::bind(&amp;fibonacci, n2, next)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-function"><span class="hljs-function">list_type </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">list</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(fibonacci(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">))</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> res3 = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::find_if(<span class="hljs-built_in"><span class="hljs-built_in">list</span></span>.begin(), <span class="hljs-built_in"><span class="hljs-built_in">list</span></span>.end(), [](<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> v){<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> v &gt; <span class="hljs-number"><span class="hljs-number">3</span></span>;}); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"first number greater 3 is "</span></span> &lt;&lt; *res3 &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> res10 = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::find_if(<span class="hljs-built_in"><span class="hljs-built_in">list</span></span>.begin(), <span class="hljs-built_in"><span class="hljs-built_in">list</span></span>.end(), [](<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> v){<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> v &gt; <span class="hljs-number"><span class="hljs-number">10</span></span>;}); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"first number greater 10 is "</span></span> &lt;&lt; *res10 &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br>  The output will be: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="hljs lisp">fibonacci(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) -&gt; <span class="hljs-number"><span class="hljs-number">0</span></span> fibonacci(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) -&gt; <span class="hljs-number"><span class="hljs-number">1</span></span> fibonacci(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>) -&gt; <span class="hljs-number"><span class="hljs-number">1</span></span> fibonacci(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>) -&gt; <span class="hljs-number"><span class="hljs-number">2</span></span> fibonacci(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>) -&gt; <span class="hljs-number"><span class="hljs-number">3</span></span> fibonacci(<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>) -&gt; <span class="hljs-number"><span class="hljs-number">5</span></span> first number greater <span class="hljs-number"><span class="hljs-number">3</span></span> is <span class="hljs-number"><span class="hljs-number">5</span></span> fibonacci(<span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">13</span></span>) -&gt; <span class="hljs-number"><span class="hljs-number">8</span></span> fibonacci(<span class="hljs-number"><span class="hljs-number">13</span></span>, <span class="hljs-number"><span class="hljs-number">21</span></span>) -&gt; <span class="hljs-number"><span class="hljs-number">13</span></span> first number greater <span class="hljs-number"><span class="hljs-number">10</span></span> is <span class="hljs-number"><span class="hljs-number">13</span></span></code> </pre> <br></div></div><br>  As you can see from the example, the function of generating an element is called only once for each element, the resulting value is stored in the container and is not recalculated. <br><br><h1>  Restrictions </h1><br>  Suppose we want to do something like: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> iter = --<span class="hljs-built_in"><span class="hljs-built_in">list</span></span>.end();</code> </pre> <br>  To get the element preceding the end, you must go around all the elements generated by the function, and this is infinity (for the example above).  Accordingly, the lazy list iterator will be unidirectional - ForwardIterator.  A similar situation will occur when getting the number of items in the list, and when deleting the last item (pop_back).  Thus, the container will not have these methods. <br><br>  For simplicity, I did not implement the insertion in an arbitrary place and the removal of an arbitrary element.  Exclusively from the consideration that the sequence of elements can be generated by some function, and when inserting / deleting this sequence will be broken.  From the same considerations, the elements are not modifiable.  But this is already a convention. <br><br><h1>  What happened? </h1><br>  The result is a list in which you can add both elements and functors that generate a lazy list, which in turn can contain elements and functors.  You can delete either the first element (pop_front) or all elements (clear).  Elements are inserted at the beginning or end of the list. <br><br>  The list iterator is unidirectional, not allowing to modify the elements of the list. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Allocator = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::allocator&lt;T&gt; &gt; class <span class="hljs-built_in"><span class="hljs-built_in">list</span></span>;</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">list definition</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Allocator = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::allocator&lt;T&gt; &gt; class <span class="hljs-built_in"><span class="hljs-built_in">list</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-built_in"><span class="hljs-built_in">list</span></span>&lt;T, Allocator&gt; self_type; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> T value_type; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::function&lt;self_type ()&gt; func_type; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> __details_lazy_list::const_iterator&lt;self_type&gt; iterator; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> __details_lazy_list::const_iterator&lt;self_type&gt; const_iterator; <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> __details_lazy_list::const_iterator&lt;self_type&gt;; <span class="hljs-built_in"><span class="hljs-built_in">list</span></span>(); <span class="hljs-built_in"><span class="hljs-built_in">list</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> self_type&amp; that); <span class="hljs-built_in"><span class="hljs-built_in">list</span></span>(self_type&amp;&amp; that); <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ... Args&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">list</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Args&amp;&amp;... args)</span></span></span><span class="hljs-function"> </span></span>{ push_others(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;Args&gt;(args)...); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">push_back</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value_type&amp; value)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">push_back</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(value_type&amp;&amp; value)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">push_back</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> func_type&amp; func)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">push_back</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(func_type&amp;&amp; func)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">push_back</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> self_type&amp; that)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">push_back</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self_type&amp;&amp; that)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">push_front</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value_type&amp; value)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">push_front</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(value_type&amp;&amp; value)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">push_front</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> func_type&amp; func)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">push_front</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(func_type&amp;&amp; func)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">push_front</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> self_type&amp; that)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">push_front</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self_type&amp;&amp; that)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">clear</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">empty</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">const_iterator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">begin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">const_iterator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">end</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">list</span></span>&lt;value_type, Allocator&gt; container_type; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> container_type::iterator inner_iterator; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> value_type <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> * funcs_map_key_type; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair&lt;funcs_map_key_type, func_type&gt; funcs_map_value_type; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>&lt;funcs_map_key_type, func_type&gt; funcs_map_type; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">forward</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(const_iterator&amp; iter)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">insert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(inner_iterator pos, self_type&amp;&amp; that)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Arg, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ...Args&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">push_others</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Arg&amp;&amp; arg, Args&amp;&amp;... args)</span></span></span><span class="hljs-function"> </span></span>{ push_back(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;Arg&gt;(arg)); push_others(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;Args&gt;(args)...); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Arg&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">push_others</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Arg&amp;&amp; arg)</span></span></span><span class="hljs-function"> </span></span>{ push_back(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;Arg&gt;(arg)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">push_others</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{} <span class="hljs-keyword"><span class="hljs-keyword">mutable</span></span> container_type _cont; <span class="hljs-keyword"><span class="hljs-keyword">mutable</span></span> funcs_map_type _funcs; };</code> </pre> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">iterator definition</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> lazy_list_type &gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const_iterator</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::iterator&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::input_iterator_tag, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> lazy_list_type::value_type&gt; { <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> lazy_list_type; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::iterator&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::input_iterator_tag, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> lazy_list_type::value_type&gt; base_type; const_iterator(); <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> base_type::reference <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>* () <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> base_type::pointer <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>-&gt; () <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>; const_iterator&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>++(); const_iterator <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>++(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>== (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> const_iterator&amp; that); <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>!= (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> const_iterator&amp; that); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> lazy_list_type::inner_iterator inner_iterator; const_iterator(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> lazy_list_type* owner, inner_iterator iter); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> lazy_list_type* _owner; inner_iterator _iter; };</code> </pre> <br></div></div><br>  At the end of the article there is a link to the repository, where you can get the implementation with unit tests. <br><br><h2>  Template parameters. </h2><br>  <strong>T</strong> - type of stored items <br><br>  <strong>Allocator</strong> - <strong>Allocator</strong> used to place elements. <br><br><h2>  Internal types </h2><br><table><thead><tr><th>  Type of </th><th>  Description </th></tr></thead><tbody><tr><td>  value_type </td><td>  T </td></tr><tr><td>  self_type </td><td>  own type </td></tr><tr><td>  func_type </td><td>  The type of functor used to generate the element.  The functor returns a self_type object. </td></tr><tr><td>  iterator </td><td>  constant forward iterator </td></tr><tr><td>  const_iterator </td><td>  constant forward iterator </td></tr></tbody></table><br><h2>  Methods </h2><br><table><thead><tr><th>  Method </th><th>  Description </th></tr></thead><tbody><tr><td>  push_front </td><td>  insert in the beginning </td></tr><tr><td>  push_back </td><td>  insert at the end </td></tr><tr><td>  empty </td><td>  check if the container is empty </td></tr><tr><td>  clear </td><td>  delete all items </td></tr><tr><td>  pop_front </td><td>  delete first item </td></tr></tbody></table><br>  The push_front and push_back methods accept a functor that generates elements, the value of a stored element, or another object of type self_type. <br><br><h2>  Constructors </h2><br><table><thead><tr><th>  Signature </th><th>  Description </th></tr></thead><tbody><tr><td> <code>list();</code> </td> <td>  Creates an empty container </td></tr><tr><td> <code>template&lt;typename ... Args&gt; explicit list(Args&amp;&amp;... args)</code> </td> <td>  Creates a container and puts the transferred items into it. <br>  Values ‚Äã‚Äãof the following types can be transferred: <br> <code>value_type</code> <br> <code>func_type</code> <br> <code>self_type</code> </td> </tr></tbody></table><br><h2>  How it works </h2><br>  Inside, two standard containers are used - std :: list for storing values ‚Äã‚Äãand std :: map for storing functors.  The functor should return a lazy list, i.e.  self_type  This allows, first, to calculate several elements at once if necessary, and secondly, not to care about the case when there is no next value ‚Äî the sequence has ended, in this case, you can simply return the empty container. <br><br>  With the addition of a new element, everything is simple - it is immediately added to the internal list. <br><br>  When adding a functor, it is checked whether there is a functor associated with the element after which it is added (push_back).  If there is no functor, then the passed functor is added to the map, and the pointer to the previous element is taken as the key.  When adding to the beginning, in an empty container or after an element with which an associated functor already exists, the operator () method of the functor is simply called, and the values ‚Äã‚Äãfrom the resulting container are inserted in the right place (at the beginning or end), new functors are added to the map, they are in the returned container. <br><br>  One could store in the list a pair of "value - functor", but it seems to me that in the process of work the number of functors will be significantly less than the number of calculated elements, and the memory costs in the case of storing pairs will be higher. <br>  Again, since I assume that the number of functors will not be very large, there is no particular difference what to use - map or unordered_map.  The only thing is that when using map memory costs will be slightly less, I think so. <br><br>  When an iterator is incremented, the presence of the functor for the current element is checked, if it exists, the value returned by it is added to the container, and the functor is deleted.  After that, the iterator is incremented to the internal list.  If there is no functor or it returns an empty container, then it simply moves to the next element in the internal list. <br><br><h1>  Why all this? </h1><br>  The implementation of such a list pushed me to the task of Water Pouring, presented in a lecture on the language of Scala.  The point is this: there are several glasses of fixed volume, a faucet from which any glass can be filled (we can only fill the glass completely), and a sink where you can pour the contents of the glasses.  Filling, emptying and pouring water from one glass to another, you need to get the specified amount of water in one of the glasses.  The solution is a sequence of actions to obtain such a state. <br><br>  For example, there are two glasses of 3 and 5 liters, we want to get 4 liters. <br><br><img src="https://habrastorage.org/files/4b6/260/5bb/4b62605bb72c426d97b1785f5da609eb.png" width="600"><br>  We will consider the current amount of water in each of the glasses as a state.  From each state, you can get a new set of possible states by applying one of the possible operations: fill, pour, pour.  From each set of states you can get a new set.  In order not to loop, we will separately store the obtained states and discard them when receiving a set of new states. <br><br><img src="https://habrastorage.org/files/bea/e70/a9d/beae70a9ddcb4a1c97fe81902d4f9886.png" width="600"><br>  In each set of states, we will look at whether the desired state is a glass with the desired water level. <br><br>  We will need possible options to influence the current state.  Each water transfer option will inherit the imove interface: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">imove</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> state </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> state&amp; cur)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;imove&gt; clone() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">to_string</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~imove() {} };</code> </pre> <br>  The <code>to_string</code> method is <code>to_string</code> needed to display information on the screen. <br><br>  The following types of movement are possible for this task: <br><br><div class="spoiler">  <b class="spoiler_title">Fill the glass - fill</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fill</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> imove { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: fill(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> glass, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> capacity); <span class="hljs-function"><span class="hljs-function">state </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> state&amp; cur)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> override</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;imove&gt; clone() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> override; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">to_string</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> override</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> _glass; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> _capacity; }; fill::fill(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> glass, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> capacity) : _glass(glass), _capacity(capacity) {} state fill::<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>()(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> state&amp; cur) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { assert(cur.size() &gt; _glass); <span class="hljs-function"><span class="hljs-function">state </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">next</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(cur)</span></span></span></span>; next[_glass] = _capacity; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> next; } <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;imove&gt; fill::clone() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;imove&gt;(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> fill(_glass, _capacity)); } <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> fill::to_string() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"fill("</span></span> + <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::to_string(_glass) + <span class="hljs-string"><span class="hljs-string">")"</span></span>; }</code> </pre> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Empty water from the glass - empty</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">empty</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> fill { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: empty(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> glass); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;imove&gt; clone() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> override; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">to_string</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> override</span></span>; }; empty::empty(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> glass) : fill(glass, <span class="hljs-number"><span class="hljs-number">0</span></span>) {} <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;imove&gt; empty::clone() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;imove&gt;(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> empty(_glass)); } <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> empty::to_string() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"empty("</span></span> + <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::to_string(_glass) + <span class="hljs-string"><span class="hljs-string">")"</span></span>; }</code> </pre> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Pour from one glass to another - pour</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pour</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> imove { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: pour(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> from, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> to, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> capacity_to); <span class="hljs-function"><span class="hljs-function">state </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> state&amp; cur)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> override</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;imove&gt; clone() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> override; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">to_string</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> override</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> _from; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> _to; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> _capacity_to; }; pour::pour(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> from, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> to, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> capacity_to) : _from(from), _to(to), _capacity_to(capacity_to) {} state pour::<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>()(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> state&amp; cur) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { assert((cur.size() &gt; _from) &amp;&amp; (cur.size() &gt; _to)); assert(_capacity_to &gt;= cur[_to]); <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> amount = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::min(cur[_from], _capacity_to - cur[_to]); <span class="hljs-function"><span class="hljs-function">state </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">next</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(cur)</span></span></span></span>; next[_from] -= amount; next[_to] += amount; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> next; } <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;imove&gt; pour::clone() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;imove&gt;(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> pour(_from, _to, _capacity_to)); } <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> pour::to_string() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"pour("</span></span> + <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::to_string(_from) + <span class="hljs-string"><span class="hljs-string">", "</span></span> + <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::to_string(_to) + <span class="hljs-string"><span class="hljs-string">")"</span></span>; }</code> </pre> <br></div></div><br>  You also need to store information about the new state, namely the state and the set of movements that led to it.  The <code>path</code> class will be responsible for this: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">path</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: path(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> state&amp; initial_state); path(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> path&amp; that); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">extend</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(imove_ptr move)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> state&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">end_state</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">to_string</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">empty</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">list</span></span>&lt;imove_ptr&gt; _history; state _end_state; };</code> </pre> <br>  And the class itself, which uses the lazy list and the above-mentioned auxiliary classes to find a solution: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">list</span></span>&lt;path&gt; paths_list; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">water_pouring</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: water_pouring(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">initializer_list</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span>&gt; capacities); <span class="hljs-function"><span class="hljs-function">path </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">solve</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> target)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> lazy::<span class="hljs-built_in"><span class="hljs-built_in">list</span></span>&lt;paths_list&gt; list_of_paths_type; <span class="hljs-function"><span class="hljs-function">list_of_paths_type </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">extend</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> paths_list&amp; paths)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span>&gt; _capacities; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;imove_ptr&gt; _posible_moves; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> state _initial; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">set</span></span>&lt;state&gt; _explored_states; list_of_paths_type _paths; };</code> </pre> <br>  The class has two public methods ‚Äî a constructor that takes the capacity of the glasses, and a method that returns the path to achieve the desired state. <br><br>  The private extend method is used to generate lazy list items. <br><br>  It stores the capacity of the glasses, a set of possible displacements, the initial state, the already ‚Äúfound‚Äù states and the actually lazy list of states with a history of their receipt. <br><br><div class="spoiler">  <b class="spoiler_title">For possible movements, use the create_moves function.</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;imove_ptr&gt; create_moves(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span>&gt;&amp; capacities) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;imove_ptr&gt; moves; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; capacities.size(); ++i) { moves.emplace_back(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> empty(i)); moves.emplace_back(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> fill(i, capacities[i])); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; capacities.size(); ++j) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i != j) moves.emplace_back(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> pour(i, j, capacities[j])); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> moves; }</code> </pre> <br></div></div><br>  Method <code>water_pouring::extend</code> : <br><br><pre> <code class="cpp hljs">water_pouring::list_of_paths_type water_pouring::extend(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> paths_list&amp; paths) { paths_list next; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; cur_path: paths) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> move: _posible_moves) { state next_state = (*move)(cur_path.end_state()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_explored_states.find(next_state) == _explored_states.end()) { <span class="hljs-function"><span class="hljs-function">path </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">new_path</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(cur_path)</span></span></span></span>; new_path.extend(move); next.push_back(new_path); _explored_states.insert(next_state); } } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (next.empty()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> list_of_paths_type(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> list_of_paths_type(next, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::bind(&amp;water_pouring::extend, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, next)); }</code> </pre> <br>  Method <code>water_pouring::solve</code> : <br><br><pre> <code class="cpp hljs">path water_pouring::solve(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> target) { paths_list::const_iterator solution; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> it = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::find_if( _paths.begin(), _paths.end(), [target, &amp;solution](<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> paths_list&amp; paths) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> { solution = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::find_if( paths.begin(), paths.end(), [target](<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> path&amp; p) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> it = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::find( p.end_state().begin(), p.end_state().end(), target); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> it != p.end_state().end(); }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> solution != paths.end(); }); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (it != _paths.end()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *solution; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> path(state({<span class="hljs-number"><span class="hljs-number">0</span></span>})); }</code> </pre> <br>  Actually, to find a solution, the function std :: find_if is used, and the predicate is a lambda function, which looks at the paths to the presence of the required state.  Lambda captures the solution link so that once again it does not go through the list of solutions that will be pointed to by it if the solution has been found. <br><br>  As a result, the program will display the following solution: <br><br><pre> <code class="hljs lisp">fill(<span class="hljs-number"><span class="hljs-number">1</span></span>) pour(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) empty(<span class="hljs-number"><span class="hljs-number">0</span></span>) pour(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) fill(<span class="hljs-number"><span class="hljs-number">1</span></span>) pour(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) --&gt; (<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>)</code> </pre> <br>  I could not come up with another task where the lazy list could be useful.  I hope the idea will attract someone. <br><br><h1>  Links </h1><br><ul><li>  <a href="https://bitbucket.org/hokum/lazy_list">Source code lazy_list</a> </li><li>  <a href="https://bitbucket.org/hokum/waterpouringcpp">C ++ Water Pouring Solution Source Code</a> </li><li>  <a href="https://bitbucket.org/hokum/waterpouringscala">Scala Water Pouring Source Code</a> </li><li>  <a href="https://www.coursera.org/course/progfun">A lecture course on Functional Programming Principles in Scala, within the framework of which the Water Pouring task was reviewed</a> </li><li>  <a href="https://github.com/philsquared/Catch">For unit tests used the Catch framework</a> </li></ul></div><p>Source: <a href="https://habr.com/ru/post/277737/">https://habr.com/ru/post/277737/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../277723/index.html">Asymmetric solutions. ICS Information Security in Energy</a></li>
<li><a href="../277725/index.html">Microsoft Android emulator cooling beer with IoT and Windows 10 and The Maker Show for those who like to solder</a></li>
<li><a href="../277727/index.html">Another implementation of the is_function <T> metafunction for C ++ 98/03</a></li>
<li><a href="../277729/index.html">Build a hybrid Android application</a></li>
<li><a href="../277733/index.html">The history of one configuration "umbrella"</a></li>
<li><a href="../277739/index.html">Zabbix 3.0: Encryption</a></li>
<li><a href="../277741/index.html">Backup and transfer of data in the browser Vivaldi</a></li>
<li><a href="../277743/index.html">IP PBX Askozia and Push Notifications in Telegram</a></li>
<li><a href="../277747/index.html">Anatomy of ransomware for Android, part 1</a></li>
<li><a href="../277751/index.html">How our techies in the army served</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>