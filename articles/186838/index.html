<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>GSM network security: data encryption</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Disclaimer This article is published for informational purposes only; the author is not responsible for the use of materials published in this article...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>GSM network security: data encryption</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/storage2/2f2/3e1/dc4/2f23e1dc40eee5d59d58bf78676c6089.jpg"></div><br>  <b>Disclaimer</b> This article is published for informational purposes only; the author is not responsible for the use of materials published in this article. <br>  I also want to immediately warn you that if you expect to find a step-by-step guide to listening to GSM traffic in this article, or hope to read this article to get access to telephone conversations of your friends, acquaintances, <s>pets</s> , then it is better to ignore it.  Here you will not find anything interesting.  There is no truth, do not go under the cut, there is boredom. <a name="habracut"></a><br><br><h4>  Part 1: GSM Security Highlights </h4><br>  Before proceeding to the description of the encryption algorithm used in GSM networks, we consider how the user is authenticated and the encryption key is generated.  To do this, we will use a picture borrowed from Wikipedia (I apologize for the quality, I did not find anything better). <br><img src="https://habrastorage.org/storage2/634/340/655/63434065507d7703b854ea37f6b580d2.jpg"><br><br>  This figure shows the following steps schematically: <br><ol><li>  The operator‚Äôs phone connects to the network. </li><li>  To confirm its authenticity, the phone sends a special identification code called Temporary Mobile Subscriber Identity (TMSI). </li><li>  The Authentication Center (CA) generates a 128-bit random number RAND and sends it to the Mobile Station (MS). </li><li>  The MS encrypts the received RAND number using its secret key K <sub>i</sub> and the authentication algorithm A3. </li><li>  The MC takes the first 32 bits from the sequence obtained in the previous step (let's call them SRES (signed response)) and sends them back to Central Asia. </li><li>  Central Asia performs the same operation and receives a 32 bit XRES (expected response) sequence. </li><li>  After that, CA compares SRES and XRES.  In case both values ‚Äã‚Äãare equal, the phone is considered authenticated. </li><li>  MS and CA calculate the session encryption key using the secret key K <sub>i</sub> and the key generation algorithm A8 K <sub>c</sub> = A8 <sub>ki</sub> (RAND) </li></ol>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Speaking about the A3 authentication algorithms and the A8 key generation algorithm, it should be noted that in practice most cellular operators use one algorithm for this purpose, called COMP128 (it has many modifications COMP128-1, COMP128-2, COMP128-3). <br>  COMP128 is an ordinary hash function, at the input that accepts a 128-bit sequence and returns 96-bit at the output. <br>  So, instead of using different algorithms for authentication and the formation of the session key, the following scheme is used: <br>  SRES = First 32 bits from COMP128 (K <sub>i</sub> || RAND) <br>  K <sub>c</sub> = Last 64 bits of COMP128 (K <sub>i</sub> || RAND). <br>  As always in cryptography, the attempt to save time for developers turned into a complete failure.  The security of GSM networks was initially based on the principle ‚Äúsecurity at the expense of obscurity‚Äù.  And when, in 1998, the algorithm was uncovered by a group of researchers consisting of Marc Briceno, Ian Goldberg and David Wagner, one interesting feature was cut off: the last 10 bits of the secret key K <sub>i were</sub> always zero.  Using this curious property, as well as the COMP128 vulnerability to Marc Briceno's ‚Äúbirthday days attack‚Äù, Ian Goldberg and David Wagner were able to extract the secret key K <sub>i</sub> from the SIM card. <br>  The result of this study was the widespread rejection of the COMP128 algorithm and its replacement with more reliable modifications COMP128-2 and COMP128-3, the technical details of which are kept secret.  Hmm ... does this remind you of anything? <br><br><h4>  Part 2: A5 / 1 encryption algorithm </h4><br>  Let's now move on from things more general to more private things and talk about how phone call encryption is implemented in GSM. <br>  As an encryption algorithm in GSM, algorithms from the A5 family are used.  Today, there are only 3 of them: <br><ul><li>  <b>A5 / 1</b> - stream cipher, the most common today. </li><li>  <b>A5 / 2 is a</b> variant of the previous algorithm "for the poor."  It is very similar to its ‚Äúelder brother‚Äù, but initially it was thought of how greatly weakened the A5 / 1 version was.  Currently not used </li><li>  <b>A5 / 3</b> block cipher.  Developed in 2002 to replace the outdated A5 / 1.  However, currently used only in 3GPP networks.  A number of vulnerabilities have been found for the algorithm, but there is no talk about practical attacks yet. </li></ul><br>  Let us consider the algorithm A5 / 1. <br>  So, as mentioned above, A5 / 1 is a stream cipher.  And once again a picture from Wikipedia is in a hurry: <br><img src="https://habrastorage.org/storage2/29e/333/e51/29e333e51a5a74267fe2cba10f440ad7.png"><br>  The internal state of the cipher A5 / 1 consists of three linear shift registers with feedback R1, R2, R3, 19, 22 and 23 bits in length, respectively (total 64 bits). <br>  The shift in the registers R1, R2, R3 occurs only when a certain condition is met.  Each register contains a clocking control bit.  In R1 it is the 8th bit, and in R2 and R3 - the 10th.  At each step, only those registers whose sync bit value is equal to most of the sync bit values ‚Äã‚Äãof all three registers are shifted. <br><br>  Before the algorithm is executed, the registers are initialized.  It happens as follows: <br><ol><li>  R1 = R2 = R3 = 0 </li><li>  For i = 0 to 63 do <br>  R1 [0] = R1 [0] ‚äïKc [i] <br>  R2 [0] = R2 [0] ‚äïKc [i] <br>  R2 [0] = R2 [0] ‚äïKc [i] <br>  Shift all registers by one position, ignoring sync bits. </li><li>  For i = 0 to 22 do <br>  R1 [0] = R1 [0] ‚äï FrameCount [[i] <br>  R2 [0] = R2 [0] ‚äïFrameCount [[i] <br>  R2 [0] = R2 [0] ‚äïFrameCount [[i] <br>  Shift all registers by one position, ignoring sync bits. </li><li>  For i = 0 to 99 do <br>  Shift registers by one position, taking into account the synchronization bits. </li></ol><br>  Where FrameCount 32-bit record the number of the current frame. <br><br>  After initialization, 228 bits of the output sequence are calculated.  114 bits are used to encrypt data coming out of the network to the mobile phone, the remaining 114 bits are used to encrypt data from the phone to the network.  Encryption itself is an ordinary XOR between the data and the key stream produced by the A5 / 1 algorithm. <br>  After the data transfer, the frame number is incremented by one and the registers are initialized again. <br><br>  We use the description above and implement A5 / 1 encryption in C #. <br><div class="spoiler">  <b class="spoiler_title">Class A5Enc on C #</b> <div class="spoiler_text"><pre><code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">System</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">System</span></span>.Collections.Generic; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">System</span></span>.Linq; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">System</span></span>.Text; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">System</span></span>.Collections; namespace A5project { <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> A5Enc { private <span class="hljs-type"><span class="hljs-type">bool</span></span>[] reg = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> <span class="hljs-type"><span class="hljs-type">bool</span></span>[<span class="hljs-number"><span class="hljs-number">19</span></span>]; private <span class="hljs-type"><span class="hljs-type">bool</span></span>[] reg2 = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> <span class="hljs-type"><span class="hljs-type">bool</span></span>[<span class="hljs-number"><span class="hljs-number">22</span></span>]; private <span class="hljs-type"><span class="hljs-type">bool</span></span>[] reg3 = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> <span class="hljs-type"><span class="hljs-type">bool</span></span>[<span class="hljs-number"><span class="hljs-number">23</span></span>]; //,           <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> A5Enc(<span class="hljs-type"><span class="hljs-type">bool</span></span>[][] startState) { reg = startState[<span class="hljs-number"><span class="hljs-number">0</span></span>]; reg2 = startState[<span class="hljs-number"><span class="hljs-number">1</span></span>]; reg3 = startState[<span class="hljs-number"><span class="hljs-number">2</span></span>]; } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> A5Enc() { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">19</span></span>; i++) reg[i] = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">22</span></span>; i++) reg2[i] = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">23</span></span>; i++) reg3[i] = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } //  ,      A5 <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">void</span></span> KeySetup(byte[] key, <span class="hljs-type"><span class="hljs-type">int</span></span>[] frame) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">19</span></span>; i++) reg[i] = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">22</span></span>; i++) reg2[i] = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">23</span></span>; i++) reg3[i] = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; BitArray KeyBits = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> BitArray(key); BitArray FrameBits = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> BitArray(frame); <span class="hljs-type"><span class="hljs-type">bool</span></span>[] b = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> <span class="hljs-type"><span class="hljs-type">bool</span></span>[<span class="hljs-number"><span class="hljs-number">64</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">64</span></span>; i++) { clockall(); reg[<span class="hljs-number"><span class="hljs-number">0</span></span>] = reg[<span class="hljs-number"><span class="hljs-number">0</span></span>] ^ KeyBits[i]; reg2[<span class="hljs-number"><span class="hljs-number">0</span></span>] = reg2[<span class="hljs-number"><span class="hljs-number">0</span></span>] ^ KeyBits[i]; reg3[<span class="hljs-number"><span class="hljs-number">0</span></span>] = reg3[<span class="hljs-number"><span class="hljs-number">0</span></span>] ^ KeyBits[i]; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">22</span></span>; i++) { clockall(); reg[<span class="hljs-number"><span class="hljs-number">0</span></span>] = reg[<span class="hljs-number"><span class="hljs-number">0</span></span>] ^ FrameBits[i]; reg2[<span class="hljs-number"><span class="hljs-number">0</span></span>] = reg2[<span class="hljs-number"><span class="hljs-number">0</span></span>] ^ FrameBits[i]; reg3[<span class="hljs-number"><span class="hljs-number">0</span></span>] = reg3[<span class="hljs-number"><span class="hljs-number">0</span></span>] ^ FrameBits[i]; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">100</span></span>; i++) { clock(); } } // ,       <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">void</span></span> KeySetup(<span class="hljs-type"><span class="hljs-type">int</span></span>[] frame) { BitArray FrameBits = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> BitArray(frame); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">22</span></span>; i++) { clockall(); reg[<span class="hljs-number"><span class="hljs-number">0</span></span>] = reg[<span class="hljs-number"><span class="hljs-number">0</span></span>] ^ FrameBits[i]; reg2[<span class="hljs-number"><span class="hljs-number">0</span></span>] = reg2[<span class="hljs-number"><span class="hljs-number">0</span></span>] ^ FrameBits[i]; reg3[<span class="hljs-number"><span class="hljs-number">0</span></span>] = reg3[<span class="hljs-number"><span class="hljs-number">0</span></span>] ^ FrameBits[i]; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">100</span></span>; i++) { clock(); } } private <span class="hljs-type"><span class="hljs-type">void</span></span> clock() { <span class="hljs-type"><span class="hljs-type">bool</span></span> majority = ((reg[<span class="hljs-number"><span class="hljs-number">8</span></span>] &amp; reg2[<span class="hljs-number"><span class="hljs-number">10</span></span>]) | (reg[<span class="hljs-number"><span class="hljs-number">8</span></span>] &amp; reg3[<span class="hljs-number"><span class="hljs-number">10</span></span>]) | (reg2[<span class="hljs-number"><span class="hljs-number">10</span></span>] &amp; reg3[<span class="hljs-number"><span class="hljs-number">10</span></span>])); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (reg[<span class="hljs-number"><span class="hljs-number">8</span></span>] == majority) clockone(reg); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (reg2[<span class="hljs-number"><span class="hljs-number">10</span></span>] == majority) clocktwo(reg2); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (reg3[<span class="hljs-number"><span class="hljs-number">10</span></span>] == majority) clockthree(reg3); } //     private <span class="hljs-type"><span class="hljs-type">bool</span></span>[] clockone(<span class="hljs-type"><span class="hljs-type">bool</span></span>[] RegOne) { <span class="hljs-type"><span class="hljs-type">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">temp</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span> i = RegOne.Length - <span class="hljs-number"><span class="hljs-number">1</span></span>; i &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>; i<span class="hljs-comment"><span class="hljs-comment">--) { if (i == RegOne.Length - 1) temp = RegOne[13] ^ RegOne[16] ^ RegOne[17] ^ RegOne[18]; RegOne[i] = RegOne[i - 1]; if (i == 1) RegOne[0] = temp; } return RegOne; } private bool[] clocktwo(bool[] RegTwo) { bool temp = false; for (int i = RegTwo.Length - 1; i &gt; 0; i--) { if (i == RegTwo.Length - 1) temp = RegTwo[20] ^ RegTwo[21]; RegTwo[i] = RegTwo[i - 1]; if (i == 1) RegTwo[0] = temp; } return RegTwo; } private bool[] clockthree(bool[] RegThree) { bool temp = false; for (int i = RegThree.Length - 1; i &gt; 0; i--) { if (i == RegThree.Length - 1) temp = RegThree[7] ^ RegThree[20] ^ RegThree[21] ^ RegThree[22]; RegThree[i] = RegThree[i - 1]; if (i == 1) RegThree[0] = temp; } return RegThree; } private void clockall() { reg = clockone(reg); reg2 = clocktwo(reg2); reg3 = clockthree(reg3); } //  114    public bool[] A5() { bool[] FirstPart = new bool[114]; for (int i = 0; i &lt; 114; i++) { clock(); FirstPart[i] = (reg[18] ^ reg2[21] ^ reg3[22]); } return FirstPart; } //   228     public bool[] A5(bool AsFrame) { bool[] FirstPart = new bool[228]; for (int i = 0; i &lt; 228; i++) { clock(); FirstPart[i] = (reg[18] ^ reg2[21] ^ reg3[22]); } return FirstPart; } public byte[] FromBoolToByte(bool[] key, bool lsb) { int bytes = key.Length / 8; if ((key.Length % 8) != 0) bytes++; byte[] arr2 = new byte[bytes]; int bitIndex = 0, byteIndex = 0; for (int i = 0; i &lt; key.Length; i++) { if (key[i]) { if(lsb) arr2[byteIndex] |= (byte)(((byte)1) &lt;&lt; (7 - bitIndex)); else arr2[byteIndex] |= (byte)(((byte)1) &lt;&lt; (bitIndex)); } bitIndex++; if (bitIndex == 8) { bitIndex = 0; byteIndex++; } } return arr2; } } }</span></span></code> </pre> </div></div><br>  You can check the correctness of the code by running the program with the key {0x12, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF} and the frame number 0x134.  Two generated sequences of 114 bits each, should be equal, respectively {0x53, 0x4E, 0xAA, 0x58, 0x2F, 0xE8, 0x15, 0x1A, 0xB6, 0xE1, 0x85, 0x5A, 0x72, 0x8C, 0x00} and {0x24, 0xFD, 0x35 , 0xA3, 0x5D, 0x5F, 0xB6, 0x52, 0x6D, 0x32, 0xF9, 0x06, 0xDF, 0x1A, 0xC0}. <br>  These are the test data used by Marc Briceno, Ian Goldberg and David Wagner in their very first implementation of the algorithm written in C. <br><br>  The encryption / decryption function using this class will look like this: <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">byte</span></span></span><span class="hljs-function">[] </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">A5Encyptor</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] msg,</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] key</span></span></span><span class="hljs-function">)</span></span> { A5Enc a5 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> A5Enc(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] frame = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[<span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>[] resbits = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>[msg.Count]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> framesCount = msg.Length / <span class="hljs-number"><span class="hljs-number">228</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((msgbits.Length % <span class="hljs-number"><span class="hljs-number">228</span></span>) != <span class="hljs-number"><span class="hljs-number">0</span></span>) framesCount++; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; framesCount; i++) { frame[<span class="hljs-number"><span class="hljs-number">0</span></span>] = i; a5.KeySetup(key, frame); <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>[] KeyStream = a5.A5(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; <span class="hljs-number"><span class="hljs-number">228</span></span>; j++) { resbits[i * <span class="hljs-number"><span class="hljs-number">228</span></span> + j] = msgbits[i * <span class="hljs-number"><span class="hljs-number">228</span></span> + j] ^ KeyStream[j]; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a5.FromBoolToByte(resbits, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); }</code> </pre><br><br>  Now that we have a function that allows us to encrypt and decrypt data, let's talk about the vulnerabilities of the A5 / 1 algorithm. <br>  Today, a large number of successful attacks on GSM encryption are known, and all of them belong to known-plaintext attacks, i.e.  to recover the key, the attacker, in addition to the encrypted frames, also needs to know the unencrypted data that corresponds to these frames.  At first glance, such a requirement may seem fantastic, but due to the specifics of the GSM standard, in which, in addition to voice traffic, various system messages are transmitted, such attacks from the theoretical level become practical.  GSM system messages contain duplicate data and can be used by an attacker.  In particular, the method proposed by Karsten Nohl in 2010 is based on the search for such data in a ciphertext and a simple search for various variants of keys stored in rainbow tables until a key is generated that generates the desired ciphertext for a previously known system message. . <br><br><h4>  Part 3: Attack on the A5 / 1 algorithm </h4><br>  However, we do not have the enormous resources needed to compute rainbow tables, so we implement a simpler attack related to the so-called  "Correlation attacks". <br>  The attack we were considering was first described in 2002 by two researchers: Patrik Ekdahl and Thomas Johansson. <br>  From the definition of the initialization procedure, we can conclude that the initial state of the registers is a linear function of the session key K and the frame number F <sub>n</sub> . <br>  Knowing that the generator output bit is the XOR of the output bits of all three registers, we can write the following equation: <br><br><img src="http://habrastorage.org/storage2/057/88c/b8c/05788cb8cdf42ee000ff2ce2a81a774c.png">  ( <b>1</b> ) <br><br>  where s <sub>i is the</sub> sequence generated by registers after loading only the bits of the key K into them. f <sub>i is the</sub> sequence, after loading only the bits of the frame number, and the x-output bit of the register. <br><br>  We also know from the definition of initialization that the first 100 cycles of the algorithm work ‚Äúidle‚Äù, i.e.  produces no output bits, and the first bit of the output sequence is in fact the 101st generated bit.  Thus, if we consider that at each step the probability of a shift for each register is 3/4, we can assume that after step 101, each register has shifted exactly 76 times.  Therefore, formula (1) is converted to: <br><br><img src="http://habrastorage.org/storage2/082/1cf/322/0821cf322805327854cab91dd449b9f2.png">  ( <b>2</b> ) <br><br>  Denoting the right part (2) as <img src="http://habrastorage.org/storage2/fa3/7e9/c98/fa37e9c981b46ec0cee22dd98dc5a6fb.png">  rewrite the formula: <br><br><img src="http://habrastorage.org/storage2/88c/566/d28/88c566d28dcd9ae198e790d77dd44b89.png">  ( <b>3</b> ) <br><br>  Because  the expression in the right part of (3) we know, we get 1 bit of information about the key sequence S, namely about the state of the 76th position of each register after initialization.  Acting in a similar way, we can assume that at 102 position R1 remained also at position 76, and registers R2 and R3 moved to position 77, so we get information about the 77th position of the register, etc.  In total, we need to open 64 bits to successfully restore the initial state. <br><br>  Of course, the situation (76,76,76) arises exactly at the 101st step with an extremely low probability, and if we decided to act in this way, we would need to go through a huge number of frames, until finally one in which after 101 shifts the register scrolled to 76 positions.  In order to reduce the required number of frames Ekdahl and Johansson proposed the following method. <br><br>  There is no need to guess the specific position in which the registers rotate (cl <sub>1</sub> , cl <sub>2</sub> , cl <sub>3</sub> ) times.  It is enough just to know that with a high degree of probability each register will turn from 76 to 102 on the interval I = [100,140] output bits of each frame. <br>  Thus, for each frame we can calculate the probability: <img src="http://habrastorage.org/storage2/8a9/c08/8ae/8a9c088aeed5f777d2c6b2eab4212c66.png">  as <br><br><img src="http://habrastorage.org/storage2/5d6/32b/78e/5d632b78e3b021627a5613736237cf31.png">  ( <b>4</b> ) <br><br>  Where <br><br><img src="http://habrastorage.org/storage2/067/b30/789/067b30789e0eadb9f63b821837fd73ee.png"><br><br>  and denotes the probability that the tth bit was generated by register positions (cl1, cl2, cl3). <br><br>  By calculating (4) for each available frame we average the probabilities obtained using the logarithm: <br><br><img src="http://habrastorage.org/storage2/bf6/c0f/933/bf6c0f933c23c50068c58f05dbcec861.png">  (five). <br><br>  If (5)&gt; 0, then s <sub>1</sub> (cl1) ‚äïs <sub>2</sub> (cl2) s <sub>3</sub> (cl3) = 0, otherwise s <sub>1</sub> (cl1) s <sub>2</sub> (cl2) s <sub>3</sub> (cl3) = 1 . <br><br>  We describe the attack completely in the form of an algorithm: <br><ol><li>  Select interval C. For example, C = [79.86] </li><li>  Let the variables cl <sub>1</sub> , cl <sub>2</sub> , cl <sub>3</sub> run through all the values ‚Äã‚Äãfrom interval C, for each frame we calculate (4) </li><li>  For all obtained values, we calculate (5) </li><li>  Based on the value of Œî, we choose the value of s <sub>1</sub> (cl1) ‚äïs <sub>2</sub> (cl2) ‚äïs <sub>3</sub> (cl3) </li></ol><br>  The result of the execution of this algorithm will be 512 equations of the form s <sub>1</sub> (79) ‚äïs <sub>2</sub> (79) ‚äïs <sub>3</sub> (79) = 0, consisting of 8 unknowns.  Solving this system of equations by simple enumeration, we get 8 bits of the initial value of each register. <br>  Repeating the algorithm two more times for the intervals [87, 94] and [95, 102] we get 24 bits of the initial state of each of the registers.  This is more than enough for us.  Scrolling each of the registers 101 times back we will get just the state of the registers that was after the second initialization step, i.e.  after loading into the key bit registers.  And now we can generate the entire key sequence entirely. <br><br><div class="spoiler">  <b class="spoiler_title">C # class A5attack</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Linq; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Text; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections; <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">A5project</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">A5attack</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[] factorials = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[<span class="hljs-number"><span class="hljs-number">150</span></span>]; <span class="hljs-comment"><span class="hljs-comment">// Pr(cl1,cl2,cl3   v) private double PinVth(int cl1, int cl2, int cl3, int v) { double y=0; double x = 0; double z = 0; double w = 0; if((v - (v - cl1) - (v - cl2) - (v - cl3))&gt;=0) y=factorials[v - (v - cl1) - (v - cl2) - (v - cl3)]; else y=1; if ((v - cl1) &gt;= 0) x = factorials[v - cl1]; else x = 1; if ((v - cl3) &gt;= 0) z = factorials[v - cl3]; else z = 1; if ((v - cl2) &gt;= 0) w = factorials[v - cl2]; else w = 1; double a = factorials[v] / (x * factorials[v - (v - cl1)]); double b = factorials[v - (v - cl1)] / (w * factorials[v - (v - cl1) - (v - cl2)]); double c = factorials[v - (v - cl1) - (v - cl2)] / (z * y); double d = Math.Pow(4, v); return (a * b * c) / d; } private double factorial(int x) { double result=1; for (int i = x; i &gt; 1; i--) result = result * i; return result; } private bool[] reg = new bool[19]; private bool[] reg2 = new bool[22]; private bool[] reg3 = new bool[23]; // ,         public void KeySetup(int[] frame) { for (int i = 0; i &lt; 19; i++) reg[i] = false; for (int i = 0; i &lt; 22; i++) reg2[i] = false; for (int i = 0; i &lt; 23; i++) reg3[i] = false; BitArray FrameBits = new BitArray(frame); for (int i = 0; i &lt; 22; i++) { clockall(); reg[0] = reg[0] ^ FrameBits[i]; reg2[0] = reg2[0] ^ FrameBits[i]; reg3[0] = reg3[0] ^ FrameBits[i]; } } //     private void clock() { bool majority = ((reg[8] &amp; reg2[10]) | (reg[8] &amp; reg3[10]) | (reg2[10] &amp; reg3[10])); if (reg[8] == majority) clockone(reg); if (reg2[10] == majority) clocktwo(reg2); if (reg3[10] == majority) clockthree(reg3); } private bool[] clockone(bool[] RegOne) { bool temp = false; for (int i = RegOne.Length - 1; i &gt; 0; i--) { if (i == RegOne.Length - 1) temp = RegOne[13] ^ RegOne[16] ^ RegOne[17] ^ RegOne[18]; RegOne[i] = RegOne[i - 1]; if (i == 1) RegOne[0] = temp; } return RegOne; } private bool[] clocktwo(bool[] RegTwo) { bool temp = false; for (int i = RegTwo.Length - 1; i &gt; 0; i--) { if (i == RegTwo.Length - 1) temp = RegTwo[20] ^ RegTwo[21]; RegTwo[i] = RegTwo[i - 1]; if (i == 1) RegTwo[0] = temp; } return RegTwo; } private bool[] clockthree(bool[] RegThree) { bool temp = false; for (int i = RegThree.Length - 1; i &gt; 0; i--) { if (i == RegThree.Length - 1) temp = RegThree[7] ^ RegThree[20] ^ RegThree[21] ^ RegThree[22]; RegThree[i] = RegThree[i - 1]; if (i == 1) RegThree[0] = temp; } return RegThree; } private void clockall() { reg = clockone(reg); reg2 = clocktwo(reg2); reg3 = clockthree(reg3); } //  ,      cl1, cl2  cl3 public bool Oj(int cl1,int cl2, int cl3) { for (int i = 0; i &lt; cl1; i++) { clockone(reg); } for (int i = 0; i &lt; cl2; i++) { clocktwo(reg2); } for (int i = 0; i &lt; cl3; i++) { clockthree(reg3); } return (reg[18] ^ reg2[21] ^ reg3[22]); } // ,     XOR      public double Pj(int cl1, int cl2, int cl3, int j, bool[] frame) { double result = 0; double rightPart = 0; int[] framenumb=new int[1]{j}; KeySetup(framenumb); bool[] tempReg = new bool[19]; bool[] tempReg2 = new bool[22]; bool[] tempReg3 = new bool[23]; Array.Copy(reg, tempReg, 19); Array.Copy(reg2, tempReg2, 22); Array.Copy(reg3, tempReg3, 23); bool FramesBit = Oj(cl1, cl2, cl3); for (int i = 100; i &lt; 100 + 50; i++) { Array.Copy(tempReg, reg, 19); Array.Copy(tempReg2, reg2, 22); Array.Copy(tempReg3, reg3, 23); double temp = PinVth(cl1, cl2, cl3, i); rightPart += temp; if((FramesBit^frame[i-100])==false) temp=temp*1; else temp=0; result += temp; } result = result + ((1 - rightPart) / 2); return result; } //  ,   cl1, cl2, cl3    0.  &gt;0     0 //  ,  1 public double LikehoodRatio(int cl1, int cl2, int cl3, bool[] keystream) { double result = 0; for (int i = 0; i &lt; keystream.Length/228; i++) { bool[] temp=new bool[228]; Array.Copy(keystream,i*228,temp,0,228); double x=Pj(cl1, cl2, cl3, i, temp); result = result + Math.Log(( x/ (1 - x))); } return result; } public bool FindKeyBit(int cl1, int cl2, int cl3, bool[] keystream) { for (int i = 0; i &lt; 150; i++) factorials[i] = factorial(i); if (LikehoodRatio(cl1, cl2, cl3, keystream) &gt;= 0) return false; else return true; } //         public bool[][] checkSol(byte[] first, byte[] second, byte[] third) { byte[] newFirst = new byte[3]; newFirst[0] = first[0]; newFirst[1] = second[0]; newFirst[2] = third[0]; byte[] newSecond = new byte[3]; newSecond[0] = first[1]; newSecond[1] = second[1]; newSecond[2] = third[1]; byte[] newThird = new byte[3]; newThird[0] = first[2]; newThird[1] = second[2]; newThird[2] = third[2]; bool[] firstArr1 = new BitArray(newFirst).Cast&lt;bool&gt;().ToArray().Reverse().ToArray(); bool[] firstArr = new bool[19]; Array.Copy(firstArr1, 5, firstArr, 0, 19); bool[] secondArr1 = new BitArray(newSecond).Cast&lt;bool&gt;().ToArray().Reverse().ToArray(); bool[] secondArr = new bool[22]; Array.Copy(secondArr1, 2, secondArr, 0, 22); bool[] thirdArr1 = new BitArray(newThird).Cast&lt;bool&gt;().ToArray().Reverse().ToArray(); bool[] thirdArr = new bool[23]; Array.Copy(thirdArr1, 1, thirdArr, 0, 23); for (int i = 0; i &lt; 101; i++) { BackClockone(firstArr); } for (int i = 0; i &lt; 101; i++) { BackClocktwo(secondArr); } for (int i = 0; i &lt; 101; i++) { BackClockthree(thirdArr); } bool[][] result = new bool[3][]; result[0] = firstArr; result[1] = secondArr; result[2] = thirdArr; return result; } private void BackClockone(bool[] RegOne) { bool temp = false; for (int i = 0; i &lt; RegOne.Length-1; i++) { if (i == 0) temp = RegOne[0]; RegOne[i] = RegOne[i+1]; if (i == (RegOne.Length-2)) RegOne[RegOne.Length - 1] = temp ^ RegOne[13] ^ RegOne[16] ^ RegOne[17]; } } private void BackClocktwo(bool[] RegTwo) { bool temp = false; for (int i = 0; i &lt; RegTwo.Length-1; i++) { if (i == 0) temp = RegTwo[0]; RegTwo[i] = RegTwo[i + 1]; if (i == (RegTwo.Length-2)) RegTwo[RegTwo.Length - 1] = temp ^ RegTwo[20]; } } private void BackClockthree(bool[] RegThree) { bool temp = false; for (int i = 0; i &lt; RegThree.Length-1; i++) { if (i == 0) temp = RegThree[0]; RegThree[i] = RegThree[i + 1]; if (i == (RegThree.Length-2)) RegThree[RegThree.Length - 1] = temp ^ RegThree[7] ^ RegThree[20] ^ RegThree[21]; } } } }</span></span></code> </pre></div></div><br><br>  Using the <b>FindKeyBit</b> function as follows: <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function">[] </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">attack</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>[] keypart=<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>[<span class="hljs-number"><span class="hljs-number">512</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> count = <span class="hljs-number"><span class="hljs-number">0</span></span>; A5attack tryattack = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> A5attack(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">79</span></span>; i&lt;<span class="hljs-number"><span class="hljs-number">87</span></span>;i++) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j=<span class="hljs-number"><span class="hljs-number">79</span></span>; j&lt;<span class="hljs-number"><span class="hljs-number">87</span></span>; j++) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> k = <span class="hljs-number"><span class="hljs-number">79</span></span>; k &lt; <span class="hljs-number"><span class="hljs-number">87</span></span>; k++) { <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> temp=tryattack.FindKeyBit(i, j, k, keystream); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> time = finish - start; keypart[count] = temp; count++; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> keypart; }</code> </pre><br>  we get an array of 512 values ‚Äã‚Äãin which the XOR key bits are written from position 79 to position 86. <br><br>  Having received all 24 bits from each register, and translating them into byte arrays, we check our solution: <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-function">Private </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">checkSolution</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { A5attack LetsAttack = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> A5attack(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] testframe = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[<span class="hljs-number"><span class="hljs-number">1</span></span>] { <span class="hljs-number"><span class="hljs-number">0</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>[][] startState = LetsAttack.checkSol(first, second, third); A5Enc a5check = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> A5Enc(startState); <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>[] TempFrame = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>[<span class="hljs-number"><span class="hljs-number">228</span></span>]; a5check.KeySetup(testframe); TempFrame = a5check.A5(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> l = <span class="hljs-number"><span class="hljs-number">0</span></span>; l &lt; <span class="hljs-number"><span class="hljs-number">228</span></span>; l++) { find = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (keystream[l] != TempFrame[l]) { find = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } }</code> </pre><br>  If the received frame coincides with the first frame of the known key stream, then the attack was implemented successfully and we opened the session key of the algorithm A5 / 1. <br><br><h4>  Part 4: Final </h4><br>  To summarize, I want to note that the attack described is one of the first such attacks.  The most advanced of them allows you to open a session key of a total of 2000 frames with a 90% chance (9 seconds of conversation).  Thus, correlation attacks are a very serious threat not only in theory, but also in practice. <br><br><h4>  Literature and links </h4><br><ul><li>  Marcin Olawski.  "Security in the GSM network". </li><li>  Patrik Ekdahl and Thomas Johansson.  "Another Attack on A5 / 1". </li><li>  Karsten Nohl.  ‚ÄúAttacking phone privacy‚Äù. </li><li>  <a href="http://www.scard.org/gsm/a51.html">Marc Briceno, Ian Goldberg, and David Wagner.</a>  <a href="http://www.scard.org/gsm/a51.html">A pedagogical implementation of A5 / 1.</a> </li></ul><br><br>  <b>PS: the</b> author will be grateful if someone will share the work of Barkan, Elad;  Eli Biham (2005).  "Conditional Estimators: An Effective Attack on A5 / 1".  It describes the attack that I mentioned in the final part. <br>  UPD: all question cleared, thanks to the user <a href="https://habrahabr.ru/users/whitequark/" class="user_link">whitequark</a> . </div><p>Source: <a href="https://habr.com/ru/post/186838/">https://habr.com/ru/post/186838/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../186828/index.html">Defining MIME Types</a></li>
<li><a href="../18683/index.html">Steal this movie 2. If pirates pay, then they pay generously</a></li>
<li><a href="../186832/index.html">IPv6 PTR Converter</a></li>
<li><a href="../186834/index.html">Evaluation of user satisfaction as a way to find customers</a></li>
<li><a href="../186836/index.html">Personal access to files on the site made by MODx</a></li>
<li><a href="../18684/index.html">Get a Mac: Time Machine</a></li>
<li><a href="../186840/index.html">The history of the scener and the biggest releaser of EliteTorrents, which ‚Äúgot off‚Äù with a suspended sentence</a></li>
<li><a href="../186842/index.html">Kinoglaz - in your pocket. And then what?</a></li>
<li><a href="../186844/index.html">On what to store backups: Tape VS Disk Storage</a></li>
<li><a href="../186846/index.html">Good user interface</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>