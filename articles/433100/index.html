<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Work with a database from the application</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the beginning I will identify some of the problems and features when working with the database, show the holes in the abstractions. Next, we analyz...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Work with a database from the application</h1><div class="post__text post__text-html js-mediator-article"><p>  In the beginning I will identify some of the problems and features when working with the database, show the holes in the abstractions.  Next, we analyze a simpler abstraction based on immutability. </p><br><p>  It is assumed that the reader is somewhat familiar with the patterns of <a href="https://martinfowler.com/eaaCatalog/activeRecord.html">Active Record</a> , <a href="https://martinfowler.com/eaaCatalog/dataMapper.html">Data Maper</a> , <a href="https://martinfowler.com/eaaCatalog/identityMap.html">Identity Map</a> and <a href="https://martinfowler.com/eaaCatalog/unitOfWork.html">Unit of Work</a> . </p><br><p>  Problems and solutions are considered in the context of sufficiently large projects that can not be thrown out and quickly rewritten. </p><a name="habracut"></a><br><h2 id="identity-map">  Identity map </h2><br><p>  The first problem is the problem of preserving identity.  Identity is something that uniquely defines an entity.  In the database it is the primary key, and in memory the reference (pointer).  Well, when the links point to only one object. </p><br><p>  For the <a href="https://guides.rubyonrails.org/active_record_basics.html">ActiveRecord</a> ruby library, this is not the case: </p><br><pre><code class="ruby hljs">post_a = Post.find <span class="hljs-number"><span class="hljs-number">1</span></span> post_b = Post.find <span class="hljs-number"><span class="hljs-number">1</span></span> post_a.object_id != post_b.object_id <span class="hljs-comment"><span class="hljs-comment"># true post_a.title = "foo" post_b.title != "foo" # true</span></span></code> </pre> <br><p>  Those.  we get 2 references to 2 different objects in memory. </p><br><p>  In this way, we can lose changes if, through carelessness, we start working with the same entity, but represented by different objects. </p><br><p>  <a href="http://hibernate.org/orm/">Hibernate</a> has a session, in fact, a first-level cache, which stores an entity identifier mapping to an object in memory.  If we re-request the same entity, we get a link to an existing object.  Those.  Hibernate implements the <a href="https://martinfowler.com/eaaCatalog/identityMap.html">Identity Map</a> pattern. </p><br><h2 id="dolgie-tranzakcii">  Long transactions </h2><br><p>  But what if we do not sample by id?  To prevent out of sync with the state of objects and the state of the database, Hibernate <a href="https://docs.jboss.org/hibernate/stable/core.old/reference/en/html/objectstate-flushing.html">flush</a> before requesting the sample, <br>  those.  flushes dirty objects to the database so that the query reads the agreed data. </p><br><p>  This approach forces you to keep the database transaction open while the business transaction is in progress. <br>  If a business transaction is long, then the process responsible for the connection in the database itself is idle, too.  For example, this can happen if a business transaction requests data over a network or performs complex calculations. </p><br><h2 id="n1">  N + 1 </h2><br><p>  Perhaps the biggest "hole" in the ORM abstraction is the problem of N + 1 queries. </p><br><p>  An example of a ruby ‚Äã‚Äãfor the ActiveRecord library: </p><br><pre> <code class="ruby hljs">posts = Post.all <span class="hljs-comment"><span class="hljs-comment"># select * from posts posts.each do |post| like = post.likes.order(id: :desc).first # SELECT * FROM likes WHERE post_id = ? ORDER BY id DESC LIMIT 1 # ... end</span></span></code> </pre> <br><p>  ORM inclines the programmer to the idea that he works simply with objects in memory.  But it works with a service available over the network, and for connection and data transfer. <br>  it takes time.  Even if the request is executed 50ms, then 20 requests will be executed a second. </p><br><h2 id="dopolnitelnye-dannye">  Additional data </h2><br><p>  Let's say to avoid the N + 1 problem described above, you write such <br>  <a href="https://www.db-fiddle.com/f/6m5FACAHWCeRSmKrTXriVH/2">request</a> : </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> posts <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> LATERAL ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> likes <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> post_id = posts.id <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> likes.id <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LIMIT</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> last_like <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>;</code> </pre> <br><p>  Those.  besides the post attributes, all the attributes of the last like are also selected.  On which entity to display this data?  In this case, you can return a couple of the post and Like, because  the result contains all the necessary attributes. </p><br><p>  But what if we chose only a part of the fields, or chose fields that are missing in the model, for example, the number of publication likes?  Do I really need to map them to entities?  Maybe leave them just data? </p><br><h2 id="state--identity">  State &amp; identity </h2><br><p>  Consider the js code: </p><br><pre> <code class="plaintext hljs">const alice = { id: 0, name: 'Alice' };</code> </pre> <br><p>  Here the object link was given the name <code>alice</code> .  Since  this is a constant, then there is no possibility to call Alice another object.  At the same time, the object itself remained mutable. </p><br><p>  For example, we can assign an existing identifier: </p><br><pre> <code class="plaintext hljs">const bob = { id: 1, name: 'Bob' }; alice.id = bob.id;</code> </pre> <br><p>  Recall that an entity has 2 identities: a link and a primary key in the database.  And constants cannot prevent Alice from making Bob, even after saving. </p><br><p>  The object referred to as <code>alice</code> performs two duties: it simultaneously models identity and state.  A state is a value that describes an entity at a given point in time. </p><br><p>  But what if we divide these 2 responsibilities and use <a href="http://facebook.github.io/immutable-js/">immutable structures</a> for the state? </p><br><pre> <code class="plaintext hljs">function Ref(initialState, validator) { let state = initialState; this.deref = () =&gt; state; this.swap = (updater) =&gt; { const newState = updater(state); if (! validator(state, newState) ) throw "Invalid state"; state = newState; return newState; }; } const UserState = Immutable.Record({ id: null, name: '' }); const aliceState = new UserState({id: 0, name: 'Alice'}); const alice = new Ref( aliceState, (oldS, newS) =&gt; oldS.id === newS.id ); alice.swap( oldS =&gt; oldS.set('name', 'Queen Alice') ); alice.swap( oldS =&gt; oldS.set('id', 1) ); // BOOM!</code> </pre> <br><p>  <code>Ref</code> - a container for an unchangeable state, allowing its controlled replacement.  <code>Ref</code> models identity in the same way that we give names to objects.  We call the river "Volga", but at each moment of time it has a different unchanging state. </p><br><h2 id="storage">  Storage </h2><br><p>  Consider the following API: </p><br><pre> <code class="plaintext hljs">storage.tx( t =&gt; { const alice = t.get(0); const bobState = new UserState({id: 1, name: 'Bob'}); const bob = t.create(bobState); alice.swap( oldS =&gt; oldS.update('friends', old =&gt; old.push(bob.deref.id)) ); });</code> </pre> <br><p>  <code>t.get</code> and <code>t.create</code> return an instance of <code>Ref</code> . </p><br><p>  We open a business transaction <code>t</code> , find Alice by her ID, create Bob, and indicate that Alice considers Bob to be her friend. </p><br><p>  Object <code>t</code> controls the creation of <code>ref</code> . </p><br><p>  <code>t</code> can store within itself the mapping of entity identifiers to the state containing them <code>ref</code> .  Those.  can implement Identity Map.  In this case, <code>t</code> acts as a cache; if Alice re-queries, there will be no query in the database. </p><br><p>  <code>t</code> can memorize the initial state of the entities in order to track at the end of the transaction what changes need to be written to the database.  Those.  can implement <a href="https://martinfowler.com/eaaCatalog/unitOfWork.html">Unit of Work</a> .  Or, if we add observer support to <code>Ref</code> , it becomes possible to reset changes to the database with each <code>ref</code> change.  These are optimistic and pessimistic approaches to fixing changes. </p><br><p>  With an optimistic approach, you need to keep track of the versions of the states of the entities. <br>  When changing from the database, we must remember the version, and when committing changes, check that the version of the entity in the database does not differ from the initial one.  Otherwise, you need to repeat the business transaction.  This approach allows the use of group insert and delete operations and very short DB transactions, which saves resources. </p><br><p>  With a pessimistic approach, a DB transaction fully corresponds to a business transaction.  Those.  we are forced to take the connection from the pool all while the business transaction is being executed. </p><br><p>  The API allows you to extract entities one by one, which is not very optimal.  Since  we have implemented the <a href="https://martinfowler.com/eaaCatalog/identityMap.html">Identity Map</a> pattern, then we can enter the <code>preload</code> method into the API: </p><br><pre> <code class="plaintext hljs">storage.tx( t =&gt; { t.preload([0, 1, 2, 3]); const alice = t.get(0); // from cache });</code> </pre> <br><h2 id="queries">  Queries </h2><br><p>  If we don‚Äôt want long transactions, we can‚Äôt make samples using an arbitrary key, since  the memory may contain dirty objects and the sample will return an unexpected result. </p><br><p>  We can use Queries and retrieve any data (state) outside the transaction and re-read the data while in the transaction. </p><br><pre> <code class="plaintext hljs">const aliceId = userQuery.findByEmail('alice@mail.com'); storage.tx( t =&gt; { const alice = t.getOne(aliceId); });</code> </pre> <br><p>  In this case there is a division of responsibility.  For queries we can use search engines, scale reading with the help of replicas.  And the storage API always works with the main storage (master).  Naturally, the replicas will contain outdated data, rereading the data in the transaction solves this problem. </p><br><h2 id="commands">  Commands </h2><br><p>  There are situations where an operation can be performed without reading the data.  For example, write off the monthly fee from all customers.  Or insert and update if the conflict data (upsert). </p><br><p>  In case of performance problems, a bunch of Storage and Query can be replaced with such a command. </p><br><h2 id="svyazi">  Connections </h2><br><p>  If entities randomly link to each other, it is difficult to ensure consistency when they change.  Relationships are trying to simplify, streamline, abandon unnecessary. </p><br><p>  <a href="https://martinfowler.com/bliki/DDD_Aggregate.html">Aggregates</a> - a way to organize communications.  Each unit has a root entity and nested entities.  Any external entity can only refer to the aggregate root.  The root ensures the integrity of the entire unit.  A transaction cannot cross the border of an aggregate; in other words, the entire aggregate participates in a transaction. </p><br><p>  An aggregate may, for example, consist of a Post (root) and its translations.  Or the Order and its Positions. </p><br><p>  Our API works with whole units.  At the same time ensuring referential integrity between the units rests on the application.  The API does not support lazy link loading. <br>  But we can choose the direction of relationships.  Consider the one-to-many relationship User - Post.  We can store the user ID in the post, but will it be convenient?  We will get much more information if we store an array of post IDs in the user. </p><br><h2 id="zaklyuchenie">  Conclusion </h2><br><p>  I focused on the problems when working with the database, showed the option of using immunity. <br>  The format of the article does not allow to disclose the topic in detail. </p><br><p>  If you are interested in this approach, then pay attention to my book <a href="https://app-from-scratch.darkleaf.ru/">app from scratch</a> , which describes the creation of a web application from scratch with a focus on architecture.  It understands SOLID, Clean Architecture, patterns of working with the database.  The code examples in the book and the <a href="https://github.com/darkleaf/publicator">application</a> itself are written in Clojure, which is imbued with ideas of immunity and convenience of data processing. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/433100/">https://habr.com/ru/post/433100/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../433088/index.html">How do you like it, Ilon Musk: BMW and Porsche have developed a charge that adds 100 km of travel in 3 minutes</a></li>
<li><a href="../433090/index.html">Oracle Bitmap Index Techniques</a></li>
<li><a href="../433092/index.html">Level 80 CG-modeling: photorealistic real-time characters in Unreal</a></li>
<li><a href="../433094/index.html">Numerical modeling in a large industrial company</a></li>
<li><a href="../433098/index.html">Story about DDR3, SPD and original Chinese manufacturers</a></li>
<li><a href="../433102/index.html">Why scientists believe that the Ninth Planet does not exist</a></li>
<li><a href="../433104/index.html">The Foobar challenge: Google's secret test for developers</a></li>
<li><a href="../433106/index.html">SpaceX and NASA reaffirm their intentions to make the debut launch of the ship Crew Dragon in January 2019</a></li>
<li><a href="../433108/index.html">ld -z separate-code</a></li>
<li><a href="../433110/index.html">Creating high-performance organizations: The strategic importance of collaboration software</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>