<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Anatomy of KD-Trees</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This article is fully devoted to KD-Trees: I describe the subtleties of constructing KD-Trees, the subtleties of implementing the 'near' search functi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Anatomy of KD-Trees</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a14/d86/7a9/a14d867a9476c993bf0cc57179f1df6e.jpg" alt="image"></div><br>  This article is fully devoted to KD-Trees: I describe the subtleties of constructing KD-Trees, the subtleties of implementing the 'near' search functions in the KD-Tree, as well as possible 'pitfalls' that arise in the process of solving certain subtasks of the algorithm.  In order not to confuse the reader with terminology (plane, hyper-plane, etc.), and indeed for convenience, it is assumed that the main action takes place in three-dimensional space.  However, where necessary, I note that we are working in a space of another dimension.  In my opinion, the article will be useful both to programmers and to all those who are interested in learning the algorithms: someone will find something new for themselves, and someone will simply repeat the material and perhaps add comments to the article in the comments.  In any case, I ask everyone under the cat. <br><a name="habracut"></a><br><h3>  Introduction </h3><br>  <i>KD-Tree</i> (K-dimensional tree), a special 'geometric' data structure that allows you to split the K-dimensional space into 'smaller parts', by means of a cross section of this very space by hyperplanes ( <b>K&gt; 3</b> ), planes ( <b>K = 3</b> ), straight lines ( <b>K = 2</b> ) well, and in the case of a one-dimensional space-point (performing a search in such a tree, we get something similar to <i>binary search</i> ). <br>  It is logical that such a partition is usually used to narrow the search range in K-dimensional space.  For example, searching for a near object (vertex, sphere, triangle, etc.) to a point, projecting points onto a 3D grid, ray tracing (actively used in Ray Tracing), etc.  At the same time, space objects are placed in special parallelepipeds - <i>bounding boxes.</i> (A bounding box is a parallelepiped that describes the original set of objects or the object itself if we build a bounding box only for it. For points, the bounding box is taken as the bounding box. box with zero surface area and zero volume), the sides of which are parallel to the coordinate axes. <br><br><h3>  The process of dividing the node </h3><br>  So, before using the KD-Tree, you need to build it.  All objects are placed in one large bounding box, describing the objects of the original set (each object is limited to its bounding box), which is then divided (divided) by a plane parallel to one of its sides into two.  Two new nodes are added to the tree.  In the same way, each of the parallelepipeds obtained is divided into two, etc.  The process is completed either by a special criterion (see <i>SAH</i> ), or when a certain depth of the tree is reached, or when a certain number of elements are reached inside the tree node.  Some elements can simultaneously enter both left and right nodes (for example, when triangles are considered as tree elements). <br><br>  I will illustrate this process with the example of the set of triangles in 2D: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/00c/28d/4d0/00c28d4d0e3a048c79914cccfd808390.jpg" alt="image"></div><br>  <i><b>Figure 1</b> shows the original set of triangles.</i>  <i>Each triangle is placed in its own bounding box, and the entire set of triangles is inscribed in one large root bounding box.</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fa0/4c2/301/fa04c2301d9c7ae82b5cec7ab0f2d460.jpg" alt="image"></div><br>  <i>In <b>Fig.2, we</b> divide the root node into two nodes (OX): triangles 1, 2, 5 fall into the left node, and 3, 4, 5 into the right node.</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1f5/fd5/c94/1f5fd5c943365e15873a3ddfebf416fb.jpg" alt="image"></div><br>  <i>In <b>Figure 3</b> , the resulting nodes are again divided into two, and triangle 5 is included in each of them.</i>  <i>When the process ends, we get 4 leaf nodes.</i> <br><br>  Of great importance is the choice of the plane to divide the tree node.  There are a huge number of ways to do this, I cite only some of the most frequently used methods in practice (it is assumed that the initial objects are placed in one large bounding box, and the separation takes place parallel to one of the coordinate axes): <br><br>  ‚¶Å <b>Method 1</b> : Select the largest side of the bounding box.  Then the cutting plane will pass through the middle of the selected side. <br><br>  ‚¶Å <b>Method 2</b> : Cut by median: we will sort all primitives by one of the coordinates, and by the median we call the element (or center of the element), which is in the middle position in the sorted list.  The secant plane will pass through the median so that the number of elements on the left and right will be approximately equal. <br><br>  ‚¶Å <b>Method 3</b> : Using the alternation of sides when splitting: at a depth of 0, beat through the middle of the side parallel to OX, the next level is through the middle of the side parallel to OY, then through OZ, etc.  If we 'walked through all the axes', then we start the process again.  The exit criteria are described above. <br><br>  ‚¶Å <b>Method 4</b> : The most 'smart' option is to use the <i>SAH (Surface Area Heuristic)</i> bounding box separation evaluation function.  (This will be discussed in detail below).  SAH also provides a universal criterion for stopping the division of a node. <br><br>  <i>Methods 1 and 3</i> are good when it comes to the speed of building a tree (as it is trivial to find the middle of the side and draw a plane through it, sifting out the elements of the original set 'to the left' and 'to the right').  At the same time, they quite often give an incomplete representation of the partitioning of space, which can negatively affect the basic operations in the KD-Tree (especially when tracking a ray in a tree). <br><br>  <i>Method 2</i> allows you to achieve good results, but requires a considerable amount of time that is spent on sorting node elements.  Like methods 1, 3, it is quite simple to implement. <br><br>  Of greatest interest is the method using the 'smart' SAH heuristics (method 4). <br><br>  The bounding box of a tree node is divided by N (parallel axes) planes to N + 1 parts (the parts are usually equal) on each side (in fact, the number of planes for each side can be any, but for simplicity and efficiency they take a constant) .  Further, at the possible points of intersection of the plane with the bounding box, the value of the special function is calculated: SAH.  The division is made by the plane with the smallest value of the SAH function (in the figure below, I assumed that the minimum is reached in SAH [7], therefore, the division will be performed by this plane (although here 2D space is so direct)): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f59/cf0/a91/f59cf0a91ef7cae7ebeaca1e30bf35db.jpg" alt="image"></div><br><br>  The value of the SAH function for the current plane is calculated as follows: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b70/28c/d6c/b7028cd6cb9a49c8f4086f51c0de1842.jpg" alt="image"></div><br><br>  In my KD-Tree implementation, I divide each side into 33 equal parts using 32 planes.  Thus, according to the results of the tests, I managed to find the 'golden' mid-speed of the basic functions of the tree / speed of building the tree. <br><br>  As SAH heuristics, I use the function shown in the figure above. <br><br>  It is worth noting that for making a decision, only a minimum of this function is required for all cutting planes.  Consequently, using the simplest mathematical properties of inequalities, as well as discarding multiplication by 2 when calculating the surface area of ‚Äã‚Äãa node (in 3D) ( <i>SAR, SAL, SA</i> ), this formula can be significantly simplified.  To the full extent, calculations are made only once per node: when evaluating the criterion for exiting the division function.  Such a simple optimization gives a significant increase in the speed of building a tree ( <i>x2.5</i> ). <br><br>  To effectively calculate the value of the SAH function, you must be able to quickly determine how many node elements are to the right of this plane, and how many are to the left.  The results will be unsatisfactory if the rough, so-called <i>brute force</i> approach with quadratic asymptotics is used as an algorithm.  However, with the use of the <i>'binned'</i> method, the situation changes significantly for the better.  The description of this method is given below: <br><br>  Suppose that we divide the side of the bounding box into N equal parts (the number of planes- (N-1)), the bounding box is stored by a pair of coordinates (pointMin, pointMax-see. <b>Fig. 1</b> ), then in one pass through all elements of the node we can accurately determine for each plane how many elements lie to the right and how many to the left of it.  Create two arrays of N elements each, and initialize with zeros.  Let it be arrays with the names <i>aHigh</i> and <i>aLow</i> .  Consistently run through all the elements of the site.  For the current element, we check which of the parts pointMin and pointMax of its bounding box falls into.  Accordingly, we obtain two indices per set element.  Let it be indexes with the names <i>iHigh</i> (for pointMax) and <i>iLow</i> (for pointMin).  After that, do the following: aHigh [iHigh] + = 1, aLow [iLow] + = 1. <br><br>  After going through all the elements, we get the filled arrays aHigh and aLow.  For the aHigh array, we calculate the partial-postfix (suffix) sums, and for aLow, we calculate the partial-prefix (prefix) sums (see the figure).  It turns out that the number of elements to the right ( <u>and only to the right!</u> ) From the plane with the index i will be equal to aLow [i + 1], the number of elements to the left ( <u>and only to the left!</u> ): AHigh [i], the number of elements that come in as to the left and to the right nodes: AllElements-aLow [i + 1] -aHigh [i]. <br><br>  The problem is solved, and an illustration of this simple process is given below: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/187/e70/f0b/187e70f0b727aa58b22ce95130a1fc08.jpg" alt="image"></div><br><br>  I would like to note that obtaining a predetermined number of elements to the left and right of the 'beating' plane allows us to pre-allocate the necessary amount of memory for them (after all, after obtaining the minimum of SAH, we need to go through all the elements once more and place each in the required array , (and the use of banal push_back (if reserve is not called) results in a permanent allocation of memory, a very expensive operation), which has a positive effect on the speed of the tree-building algorithm (x3.3). <br><br>  Now I would like to describe in more detail the purpose of the constants used in the SAH calculation formula, and also tell about the criteria for stopping the division of this node. <br><br>  Looking through the constants <i>cI</i> and <i>cT</i> , it is possible to achieve a more dense tree structure (or vice versa), sacrificing the running time of the algorithm.  In many articles devoted primarily to building a KD-Tree for a Ray Tracing render, the authors use the values <i>cI = 1., cT = [1;</i>  <i>2]</i> : the greater the value of cT, the faster the tree is built, and the worse the results of ray tracing in such a tree. <br><br>  In my own implementation, I use the tree to search for 'near', and, paying due attention to the results of testing and searching for the necessary coefficients, it can be noted that high cT values ‚Äã‚Äãgive us nodes that are not densely filled with elements.  To avoid this situation, I decided to set the value of cT to 1., and the value of cI to test on different-large data units.  As a result, we managed to get a fairly dense tree structure, having paid off with a significant increase in time during construction.  This action was reflected positively on the results of the search for ‚Äúnear‚Äù; the search speed increased. <br><br>  The criterion for stopping the division of a node is quite simple: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dcc/d8b/b96/dccd8bb96fe81e3f5f8b4473be83d8d8.jpg" alt="image"></div><br><br>  In other words: <i>if the cost of tracking the child nodes is greater than the cost of tracking the parent node, then the division needs to be stopped.</i> <br><br>  Now that we have learned how to divide a KD-Tree node, I‚Äôll tell you about the initial cases where the number of elements in a node is quite large, and the stopping criteria for the number of elements lead the algorithm to infinity.  Actually, all the attention to the picture (for example, triangles in 2D): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2d9/1a1/2fc/2d91a12fcb5d9fd3e3b34842f365808c.jpg" alt="image"></div><br><br>  I call such situations <i>"fan-shaped"</i> (they have a common point of contact, coinciding objects, I also attribute to this category).  It can be seen that no matter how we perform the cutting plane, the central point somehow falls into one of the nodes, and with it the triangles for which it is common. <br><br><h3>  Tree building process </h3><br>  We learned how to divide a tree node, now it remains to apply the knowledge gained to the process of building the entire tree.  Below I give a description of my implementation of building a KD-Tree. <br><br>  The tree is built from the root.  In each node of the tree, I store pointers to the left and right subtrees, if there is no such node, then it is considered <i>leaf</i> (leaf ie).  Each node stores a bounding box that describes the objects of this node.  In leaf ( <u>and only in leaf!</u> ) Nodes I store the indices of those objects that are included in this node.  However, in the process of building, memory for nodes is allocated in chunks (i.e., immediately for K nodes: firstly, it is more efficient to work with the memory manager, secondly, contracting elements are ideal for caching).  Such an approach prohibits storing tree nodes in a vector, because the addition of new elements to a vector can lead to memory allocation for all existing elements to another place. <br><br>  Accordingly, pointers to subtrees lose all meaning.  I use a container of type list (std :: list), each element of which is a vector (std :: vector), with a predetermined size (constant).  I build a tree multithreadedly (I use Open MP), that is, each subtree is built in a separate thread (x4 to speed).  For copying indexes into a leaf node, use the move semantics (C ++ 11) (+ 10% of the speed) is ideal. <br><br><h3>  Search 'near' to a point in KD-Tree </h3><br>  So, the tree is built, let's go on to the description of the implementation of the search operation in the KD-Tree. <br><br>  Suppose that we search in the set of triangles: given a point, it is required to find the nearest triangle to it. <br><br>  Solving the problem with the use of bruteforce is unprofitable: for a set of N points and M triangles, the assymptotics will be O (N * M).  In addition, I would like the algorithm to calculate the distance from the point to the triangle 'honestly' and do it quickly. <br><br>  Use the KD-Tree and do the following: <br><br>  ‚¶Å <b>Step 1</b> .  Find the closest leaf node to this point (at each node, as you know, we store the bounding box, and we can safely calculate the distance to the center ((pointMax + pointMin) * 0.5) the bounding box of the node) and denote it by the nearestNode. <br><br>  ‚¶Å <b>Step 2</b> .  The search method among all elements of the found node (nearestNode).  The resulting distance is denoted minDist. <br><br>  ‚¶Å <b>Step 3</b> .  Construct a sphere with center at the initial point and radius of length minDist.  Check whether this sphere is completely inside (that is, without any intersection of the sides of the bounding box-node) nearestNode.  If it is, then the near element is found, if not, then go to step 4. <br><br>  ‚¶Å <b>Step 4</b> .  Run from the root of the tree, search for the near element in the radius: going down the tree, we check whether the right or left nodes intersect (in addition, the node can lie completely inside the sphere or the sphere inside the node ...) this sphere.  If a node has been crossed, then we perform a similar check for the internal nodes of the same node.  If we come to a leaf node, then we perform an over-search for the neighbor in this node and compare the result with the length of the sphere radius.  If the radius of the sphere is greater than the distance found, update the length of the sphere radius with the calculated minimum value.  Further descents through the tree occur with the updated length of the sphere radius (if we use a recursive algorithm, then the radius is simply passed to the function by reference, and then, where necessary, updated). <br><br>  The following figure helps to understand the essence of the algorithm described above: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d75/114/31d/d7511431db15e7dbafaeb3b6a429229c.jpg" alt="image"></div><br><br>  <i>According to the picture</i> : suppose we found the nearest leaf node (blue in the picture) to this point (highlighted in red), then, having performed the search for the nearest leaf in the node, we get that the triangle with ichounks 1 is, however, as you can see, this is not so .  A circle with radius R intersects the adjacent node, therefore, the search must be performed in this node, and then compare the newly found minimum with what is already there.  As a result, it becomes obvious that the neighbor is a triangle with index 2. <br><br>  Now I would like to talk about the effective implementation of intermediate operations used in the search algorithm of the "neighbor". <br><br>  When searching for a neighbor in a node, you must be able to quickly calculate the distance from a point to a triangle.  I will describe the simplest algorithm: <br><br>  We find the projection of the point A (the point to which we are looking for the proximal one) on the plane of the triangle.  The found point is denoted by P. If P lies inside the triangle, then the distance from A to the triangle is equal to the length of the segment AP, otherwise we find the distances from A to each of the sides (segments) of the triangle, choose a minimum.  Problem solved. <br><br>  The described algorithm is not the most effective.  A more efficient approach relies on the search and analysis (finding the minimum of a gradient, etc.) of a function whose values ‚Äã‚Äãare all possible distances from a given point to any point in the triangle.  The method is rather complicated in perception and, I think, deserves a separate article (for the time being it is implemented in my code, and you will find a link to the code below).  You can get acquainted with the method according to <b>[1]</b> .  According to the test results, this method turned out to be <i>10 times</i> faster than what I described earlier. <br><br>  Determining whether a sphere is centered at point O and radius R inside a specific node represented by a bounding box is simple (3D): <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isSphereInBBox</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> SBBox&amp; bBox, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> D3&amp; point, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; radius)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (bBox.m_minBB[<span class="hljs-number"><span class="hljs-number">0</span></span>] &lt; point[<span class="hljs-number"><span class="hljs-number">0</span></span>] - radius &amp;&amp; bBox.m_maxBB[<span class="hljs-number"><span class="hljs-number">0</span></span>] &gt; point[<span class="hljs-number"><span class="hljs-number">0</span></span>] + radius &amp;&amp; bBox.m_minBB[<span class="hljs-number"><span class="hljs-number">1</span></span>] &lt; point[<span class="hljs-number"><span class="hljs-number">1</span></span>] - radius &amp;&amp; bBox.m_maxBB[<span class="hljs-number"><span class="hljs-number">1</span></span>] &gt; point[<span class="hljs-number"><span class="hljs-number">1</span></span>] + radius &amp;&amp; bBox.m_minBB[<span class="hljs-number"><span class="hljs-number">2</span></span>] &lt; point[<span class="hljs-number"><span class="hljs-number">2</span></span>] - radius &amp;&amp; bBox.m_maxBB[<span class="hljs-number"><span class="hljs-number">2</span></span>] &gt; point[<span class="hljs-number"><span class="hljs-number">2</span></span>] + radius); }</code> </pre> <br>  With the algorithm for determining the intersection of a sphere with a bounding box of a node, finding a node inside a sphere, or a sphere inside a node, things are somewhat different.  I will illustrate again (picture taken from [2]) and give the correct code that allows you to perform this procedure (in 2D, 3D-like): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c8e/8b3/d19/c8e8b3d19f5f3f8022758668ab37cbb9.jpg" alt="image"></div><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">intersects</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(CircleType circle, RectType rect)</span></span></span><span class="hljs-function"> </span></span>{ circleDistance.x = <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(circle.x - rect.x); circleDistance.y = <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(circle.y - rect.y); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (circleDistance.x &gt; (rect.width/<span class="hljs-number"><span class="hljs-number">2</span></span> + circle.r)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (circleDistance.y &gt; (rect.height/<span class="hljs-number"><span class="hljs-number">2</span></span> + circle.r)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (circleDistance.x &lt;= (rect.width/<span class="hljs-number"><span class="hljs-number">2</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (circleDistance.y &lt;= (rect.height/<span class="hljs-number"><span class="hljs-number">2</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } cornerDistance_sq = (circleDistance.x - rect.width/<span class="hljs-number"><span class="hljs-number">2</span></span>)^<span class="hljs-number"><span class="hljs-number">2</span></span> + (circleDistance.y - rect.height/<span class="hljs-number"><span class="hljs-number">2</span></span>)^<span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (cornerDistance_sq &lt;= (circle.r^<span class="hljs-number"><span class="hljs-number">2</span></span>)); }</code> </pre><br>  First (the first couple of lines) we reduce the calculations of 4 quadrants to one.  In the next pair of lines, check if the circle is in the green area.  If it lies, then there is no intersection.  The next couple of lines will check if the circle is in the orange or gray area of ‚Äã‚Äãthe picture.  If included, then the intersection is detected. <br><br>  Next you need to check whether the circle intersects the corner of the rectangle (this is done by the following lines of code). <br><br>  Actually, this calculation returns <i>'false'</i> for all circles whose center is within the red area, and <i>'true'</i> for all circles whose center is in the white area. <br><br>  In general, this code provides what we need (I provided the implementation of the code for 2D here, but in my KD-Tree code I use the 3D version). <br><br>  It remains to talk about the speed of the search algorithm, as well as critical situations that slow down the search in KD-Tree. <br><br>  As mentioned above, the <i>'fan'</i> situations generate a large number of elements inside the node, the more they are, the slower the search.  Moreover, if all elements are equidistant from the given point, then the search will be carried out behind <i>O (N)</i> (the set of points that lie on the surface of the sphere, and the nearest one is searched to the center of the sphere).  However, if these situations are removed, then an average search will be equivalent to descending a tree with enumerating elements in several nodes, i.e.  for <i>O (log (N))</i> .  It is clear that the speed of the search depends on the number of visited leaf nodes of the tree. <br><br>  Consider the following two figures: <br><div style="text-align:center;"><img src="https://pp.vk.me/c604528/v604528129/340da/0YHhNjBtUYM.jpg" alt="image"></div><br>  The essence of these figures is that if the point to which we are looking for the near element is very, very far from the original bounding box of the set, then a sphere with a radis of length minDist (distance to the near) will cross many more nodes than if we looked at the same sphere, but with a center at a point much closer to the original bounding box of the set (of course, minDist changes).  In general, the search for the nearest to a highly distant point is slower than the search for a point close to the original set.  My tests confirmed this information. <br><br><h3>  Results and summation </h3><br>  As a summary, I would like to add a few words about my KD-Tree implementation and give the results.  Actually, the code design was developed so that it could be easily adapted to any objects of the original set (triangles, spheres, points, etc.).  All you need is to create a class inheritor, with overridden virtual functions.  Moreover, my implementation also provides for the transfer of a special class <i>Splitter</i> , user-defined.  This class, or rather its virtual split method, determines where exactly the cutting plane will pass.  In my implementation, I provide a SAH-based decision making class.  Here, I will note that in many articles devoted to accelerating the construction of a KD-Tree based on SAH, many authors use the simplest techniques for searching for a cutting plane (like dividing by center or median) for initial depths of a tree (generally, when the number of elements in a tree node is large). ), and SAH heuristics are used only at the moment when the number of elements in a node is small. <br><br>  My implementation does not contain such tweaks, but allows you to quickly add them (you just need to expand the KD-Tree constructor with a new parameter and call the member function of the construction with the necessary splitter, controlling the necessary restrictions).  Search in a tree I carry out multi-threaded.  I make all calculations in numbers with double precision ( <i>double</i> ).  The maximum depth of a tree is set by a constant (by default-32).  Some <i>#defines are defined</i> that allow, for example, to traverse the tree when searching without recursion (with recursion, though the output is faster ‚Äî all nodes are elements of a certain vector (that is, they are located next to each other in memory), which means they are well cached).  Together with the code, I provide test datasets (3D models of the 'changed format OFF' with different numbers of triangles inside (from 2 to 3,000,000)).  The user can dump the constructed tree (DXF format) and view it in the corresponding graphical program.  The program also logs (you can turn on / off) the quality of building a tree: the tree <i>depth is reset, the maximum number of elements in a leaf node, the average number of elements in leaf nodes, the operation time</i> .  In no case do I claim that the resulting implementation is perfect, but what‚Äôs really there, I myself know the places where I missed (for example, I don‚Äôt pass the allocator to the template parameter, the frequent presence of the C code (I do not read and write files using streams) , unnoticed bugs, etc. are possible ‚Äî it's time to fix it).  And of course, the tree is made and optimized strictly for working in 3D space. <br><br>  I tested the code on a laptop with the following characteristics: <i>Intel Core I7-4750HQ, 4 core (8 threads) 2 GHz, RAM-8gb, Win x64 app on Windows 10</i> .  I took the following coefficients for calculating SAH: <u><i>cT = 1., cI = 1.5</i> .</u>  And, if we talk about the results, it turned out that at <i>1, 5 million.</i>  triangles tree is built in less than 1.5 seconds.  At <i>3 million</i> in 2.4 seconds.  For <i>1.5 million</i>  points and <i>1.5 million</i> triangles (the points are located not very far from the original model), the search was completed in 0.23 seconds, and if the points are removed from the model, the time increases, up to 3 seconds.  For <i>3 million</i> points (again, close to the model) and <i>3 million</i> triangles, the search takes about 0.7 seconds.  I hope nothing is confused.  Finally, an illustration of the visualization of the constructed KD-Tree: <br><br><div style="text-align:center;"><img src="https://pp.vk.me/c604528/v604528129/340e2/atFFQQ15fxs.jpg" alt="image"></div><br><br><h3>  useful links </h3><br>  <b>[0]</b> : <a href="https://github.com/IvanKamynin/KDTree">My KD-Tree implementation on GitHub</a> <br>  <b>[1]</b> : <a href="https://www.geometrictools.com/Documentation/DistancePoint3Triangle3.pdf">Search for distance from point to triangle</a> <br>  <b>[2]</b> : <a href="http://stackoverflow.com/questions/401847/circle-rectangle-collision-detection-intersection">Definitions of intersections of a circle and a rectangle</a> <br>  <b>[3]</b> : <a href="https://ru.wikipedia.org/wiki/K-%25D0%25BC%25D0%25B5%25D1%2580%25D0%25BD%25D0%25BE%25D0%25B5_%25D0%25B4%25D0%25B5%25D1%2580%25D0%25B5%25D0%25B2%25D0%25BE">KD-Tree Description on Wikipedia</a> <br>  <b>[4]</b> : <a href="https://graphics.cg.uni-saarland.de/fileadmin/cguds/Users/cygnus/Danilewsk-GPU-kdTree.pdf">Interesting SAH article</a> <br>  <b>[5]</b> : <a href="http://www.ray-tracing.ru/articles181.html">Description KD-Tree on ray-tracing.ru</a> </div><p>Source: <a href="https://habr.com/ru/post/312882/">https://habr.com/ru/post/312882/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../312872/index.html">Cremes rootkit scan</a></li>
<li><a href="../312874/index.html">Package for working with Firebird in Laravel</a></li>
<li><a href="../312876/index.html">Hybrid Android apps for kids</a></li>
<li><a href="../312878/index.html">ASP.NET Core: Creating your first web API using ASP.NET Core MVC and Visual Studio</a></li>
<li><a href="../312880/index.html">Math in javascript</a></li>
<li><a href="../312884/index.html">A brief history of the gaming industry by platform</a></li>
<li><a href="../312886/index.html">Telegram bots: to help the editor</a></li>
<li><a href="../312888/index.html">IoT market. There are many grades, no consensus</a></li>
<li><a href="../312890/index.html">Kerosene vs. Patriots: How American military programmers learned how to round correctly</a></li>
<li><a href="../312892/index.html">We introduce a full-fledged system of feedback about each other on "Freelance"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>