<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>About expanding lines in .Net / C # and not only</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Let's talk about strings, more precisely about turning them over using .Net / C #. It so happened that in the standard library there is no correspondi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>About expanding lines in .Net / C # and not only</h1><div class="post__text post__text-html js-mediator-article">  Let's talk about strings, more precisely about turning them over using .Net / C #.  It so happened that in the standard library there is no corresponding function.  And as I am told, writing the line reversal function is quite a popular question at job interviews.  Let's see how you can effectively flip a string using this platform. <br><br>  Under the cat a comparative analysis of the performance of different methods of string reversal is given. <br><br><a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <i>Khrr-rr ... - said the chainsaw.</i> <i><br></i>  <i>Tyuyuyu ... - said the men.</i> <i><br></i>  <i>¬© Old joke.</i> <br><br>  Well, let's start.  All implementations were tested for performance with one line of 256 megabytes (128 √ó 1024 √ó 1024 characters) and 1024 √ó 1024 lines of 256 bytes (128 characters) in size.  Before each measurement, garbage collection was forced (which is important with this amount of test data), the measurement was performed 50 times, the last 20 were discarded, the remaining values ‚Äã‚Äãwere averaged.  Conditional parrots were selected the number of ticks, issued by the object class Stopwatch. <br><br>  The test was conducted on two computers: Athlon64 x2 4200+, 2GB Dual-Channel DDR2 RAM and Pentium4 HT 3GHz, 3GB DDR RAM.  The main difference between the configurations in this test is the memory-cache ligament speed ‚Äî the second system is much slower in this respect. <br><br>  The technical formalities are done, now let's move on to the actual implementation.  For greater clarity, <a href="http://en.wikipedia.org/wiki/Mapping_of_Unicode_characters">unicode surrogate code points</a> are not included here.  We will consider approaches in the order of logic and ‚Äúbeautiful‚Äù implementation in the context of the surrounding ‚Äúecosystem‚Äù. <br><br>  Comparative results of measurements are in the last part of this note.  In the general case, the <i>ReverseUnsafeCopy</i> function turned out to be <i>optimal</i> , but if we restrict only the safe code - <i>ReverseArrayManual</i> .  If you need a safe code and huge strings - you will have to suffer with <i>ReverseStringBuilder</i> . <br><br><h4>  Part one: ‚Äúnormal‚Äù methods. </h4><br><h5>  1. ReverseStringBuilder </h5><br>  We will follow the recommendations and build a ‚Äúbig‚Äù string and take a special tool - the class StringBuilder.  The idea is simple to horror: create a builder of the desired size and go along the line in reverse order, adding characters to the new line. <br><br><blockquote><code><a href="http://s-c.me/1688/s"></a> <a href="http://s-c.me/1688/h"></a> <font color="black">Copy Source | Copy HTML <font color="#0000ff">static string</font> ReverseStringBuilder( <font color="#0000ff">string</font> str) { <font color="#2b91af">StringBuilder</font> sb = <font color="#0000ff">new</font> <font color="#2b91af">StringBuilder</font> (str.Length); <font color="#0000ff">for</font> ( <font color="#0000ff">int</font> i = str.Length; i-- != <font color="#A31515">0</font> ; ) sb.Append(str[i]); <font color="#0000ff">return</font> sb.ToString(); }</font></code> <ol> <li> <code><font color="black"><a href="http://s-c.me/1688/s"></a> <a href="http://s-c.me/1688/h"></a> Copy Source | Copy HTML <font color="#0000ff">static string</font> ReverseStringBuilder( <font color="#0000ff">string</font> str) { <font color="#2b91af">StringBuilder</font> sb = <font color="#0000ff">new</font> <font color="#2b91af">StringBuilder</font> (str.Length); <font color="#0000ff">for</font> ( <font color="#0000ff">int</font> i = str.Length; i-- != <font color="#A31515">0</font> ; ) sb.Append(str[i]); <font color="#0000ff">return</font> sb.ToString(); }</font></code> </li> <li> <code><font color="black"><a href="http://s-c.me/1688/s"></a> <a href="http://s-c.me/1688/h"></a> Copy Source | Copy HTML <font color="#0000ff">static string</font> ReverseStringBuilder( <font color="#0000ff">string</font> str) { <font color="#2b91af">StringBuilder</font> sb = <font color="#0000ff">new</font> <font color="#2b91af">StringBuilder</font> (str.Length); <font color="#0000ff">for</font> ( <font color="#0000ff">int</font> i = str.Length; i-- != <font color="#A31515">0</font> ; ) sb.Append(str[i]); <font color="#0000ff">return</font> sb.ToString(); }</font></code> </li> <li> <code><font color="black"><a href="http://s-c.me/1688/s"></a> <a href="http://s-c.me/1688/h"></a> Copy Source | Copy HTML <font color="#0000ff">static string</font> ReverseStringBuilder( <font color="#0000ff">string</font> str) { <font color="#2b91af">StringBuilder</font> sb = <font color="#0000ff">new</font> <font color="#2b91af">StringBuilder</font> (str.Length); <font color="#0000ff">for</font> ( <font color="#0000ff">int</font> i = str.Length; i-- != <font color="#A31515">0</font> ; ) sb.Append(str[i]); <font color="#0000ff">return</font> sb.ToString(); }</font></code> </li> <li> <code><font color="black"><a href="http://s-c.me/1688/s"></a> <a href="http://s-c.me/1688/h"></a> Copy Source | Copy HTML <font color="#0000ff">static string</font> ReverseStringBuilder( <font color="#0000ff">string</font> str) { <font color="#2b91af">StringBuilder</font> sb = <font color="#0000ff">new</font> <font color="#2b91af">StringBuilder</font> (str.Length); <font color="#0000ff">for</font> ( <font color="#0000ff">int</font> i = str.Length; i-- != <font color="#A31515">0</font> ; ) sb.Append(str[i]); <font color="#0000ff">return</font> sb.ToString(); }</font></code> </li> <li> <code><font color="black"><a href="http://s-c.me/1688/s"></a> <a href="http://s-c.me/1688/h"></a> Copy Source | Copy HTML <font color="#0000ff">static string</font> ReverseStringBuilder( <font color="#0000ff">string</font> str) { <font color="#2b91af">StringBuilder</font> sb = <font color="#0000ff">new</font> <font color="#2b91af">StringBuilder</font> (str.Length); <font color="#0000ff">for</font> ( <font color="#0000ff">int</font> i = str.Length; i-- != <font color="#A31515">0</font> ; ) sb.Append(str[i]); <font color="#0000ff">return</font> sb.ToString(); }</font></code> </li> <li> <code><font color="black"><a href="http://s-c.me/1688/s"></a> <a href="http://s-c.me/1688/h"></a> Copy Source | Copy HTML <font color="#0000ff">static string</font> ReverseStringBuilder( <font color="#0000ff">string</font> str) { <font color="#2b91af">StringBuilder</font> sb = <font color="#0000ff">new</font> <font color="#2b91af">StringBuilder</font> (str.Length); <font color="#0000ff">for</font> ( <font color="#0000ff">int</font> i = str.Length; i-- != <font color="#A31515">0</font> ; ) sb.Append(str[i]); <font color="#0000ff">return</font> sb.ToString(); }</font></code> </li> <li> <code><font color="black"><a href="http://s-c.me/1688/s"></a> <a href="http://s-c.me/1688/h"></a> Copy Source | Copy HTML <font color="#0000ff">static string</font> ReverseStringBuilder( <font color="#0000ff">string</font> str) { <font color="#2b91af">StringBuilder</font> sb = <font color="#0000ff">new</font> <font color="#2b91af">StringBuilder</font> (str.Length); <font color="#0000ff">for</font> ( <font color="#0000ff">int</font> i = str.Length; i-- != <font color="#A31515">0</font> ; ) sb.Append(str[i]); <font color="#0000ff">return</font> sb.ToString(); }</font></code> </li> </ol></blockquote><br>  We try, we launch, yes ... Somehow it works slowly, we will dig further. <br><br><h5>  2. ReverseArrayFramework </h5><br>  Ha!  So this builder is furnished with checks to ensure thread safety from all sides, no, we don‚Äôt need this.  But the string is after all an array of symbols.  So give it and turn it around, and convert the result back to a string: <br><br><blockquote> <code><a href="http://s-c.me/1687/s"></a> <a href="http://s-c.me/1687/h"></a> <font color="black">Copy Source | Copy HTML</font></code> <ol> <li>  <font color="#0000ff">static string</font> ReverseArrayFramework ( <font color="#0000ff">string</font> str) </li><li>  { </li><li>  <font color="#0000ff">char</font> [] arr = str.ToCharArray (); </li><li>  <font color="#2b91af">Array</font> .Reverse (arr); </li><li>  <font color="#0000ff">return new</font> <font color="#2b91af">String</font> (arr); </li><li>  } </li></ol></blockquote><br>  It is quite another thing, it turned out 3.5 times faster.  Hmm, maybe even better? <br><br><h5>  3. ReverseArrayManual </h5><br>  So we think.  First, we have the data copied twice: first, from the string to the array, then inside the array.  Secondly, Array.Reverse is a library method, so it has input data checks.  Moreover, for atomic types, it is explicitly implemented as a native method, and this is an additional switching of the execution context.  Let's try to turn the string into an array manually: <br><br><blockquote> <code><a href="http://s-c.me/1689/s"></a> <a href="http://s-c.me/1689/h"></a> <font color="black">Copy Source | Copy HTML</font></code> <ol> <li>  <font color="#0000ff">static string</font> ReverseArrayManual ( <font color="#0000ff">string</font> originalString) </li><li>  { </li><li>  <font color="#0000ff">char</font> [] reversedCharArray = <font color="#0000ff">new char</font> [originalString.Length]; </li><li>  <font color="#0000ff">for</font> ( <font color="#0000ff">int</font> i = originalString.Length - <font color="#A31515">1</font> ; i&gt; - <font color="#A31515">1</font> ; i--) </li><li>  reversedCharArray [originalString.Length - i - <font color="#A31515">1</font> ] = originalString [i]; </li><li>  <font color="#0000ff">return new string</font> (reversedCharArray); </li><li>  } </li></ol></blockquote><br><h5>  4. ReverseManualHalf </h5><br>  Go ahead.  In our case, the actions are symmetrical with respect to the middle of the line, which means you can put two indices in front of you and double the number of iterations: <br><br><blockquote> <code><a href="http://s-c.me/1690/s"></a> <a href="http://s-c.me/1690/h"></a> <font color="black">Copy Source | Copy HTML</font></code> <ol> <li>  <font color="#0000ff">static string</font> ReverseManualHalf ( <font color="#0000ff">string</font> originalString) </li><li>  { </li><li>  <font color="#0000ff">char</font> [] reversedCharArray = <font color="#0000ff">new char</font> [originalString.Length]; </li><li>  <font color="#0000ff">int</font> i = <font color="#A31515">0</font> ; </li><li>  <font color="#0000ff">int</font> j = originalString.Length - <font color="#A31515">1</font> ; </li><li>  <font color="#0000ff">while</font> (i &lt;= j) </li><li>  { </li><li>  reversedCharArray [i] = originalString [j]; </li><li>  reversedCharArray [j] = originalString [i]; </li><li>  i ++;  j--; </li><li>  } </li><li>  <font color="#0000ff">return new string</font> (reversedCharArray); </li><li>  } </li></ol></blockquote><br>  Hmm ... Something went wrong, on a system with slow memory, the speed dropped one and a half times.  Considering the specifics of configurations and implementations, we can assume that the memory speed and the processor cache are to blame: we used to work with two remote memory areas at the same time, now there are four, respectively, data pickup is performed more often. <br><br><h5>  LINQ and Reverse method </h5><br>  There is still a relatively beautiful and short way with LINQ, but it does not hold water in terms of performance - it works 3-3.5 times slower than the method based on StringBuilder.  The reason is pumping data through IEnumerable and a virtual call for each iteration.  For those who wish, the following is the implementation: <br><br><blockquote> <code><a href="http://s-c.me/1691/s"></a> <a href="http://s-c.me/1691/h"></a> <font color="black">Copy Source | Copy HTML</font></code> <ol> <li>  <font color="#0000ff">static string</font> ReverseStringLinq ( <font color="#0000ff">string</font> originalString) </li><li>  { </li><li>  <font color="#0000ff">return new string</font> (originalString.Reverse (). ToArray ()); </li><li>  } </li></ol></blockquote><br><h5>  Memory usage </h5><br>  The problem is not so critical in most cases, but all the ‚Äúquick‚Äù of the considered methods make an intermediate copy of the string as an array of characters.  On synthetic tests, this is manifested in the fact that only the first method was able to wrap a 512MB string, the rest fell down due to System.OutOfMemoryException.  Also, we should not forget that unnecessary temporary objects increase the frequency of GC, and although it is optimized to the horror, it still eats.  In the next part, in addition to speed optimizations, we will also look for a solution to this problem. <br><br><h4>  Part two: when you want faster and more efficiently, or unsafe code. </h4><br>  Using unsafe code gives us one interesting advantage: the lines that were previously <a href="http://msdn.microsoft.com/en-us/library/system.string.aspx">immutable</a> can now be changed, but you need to be extremely careful and <i>change only the copies of the lines</i> - the library minimizes the number of copies of one line, and along with the <a href="http://msdn.microsoft.com/en-us/library/system.string.intern.aspx">internment of lines</a> this can lead to sad consequences for applications. <br><br>  So, by creating a new line of the desired size, we can look at it as an array and fill it with the necessary data.  Well, do not forget about the lack of checks on the validity of indices, which also speed up the work of the code.  However, due to the specificity of strings in .Net, we cannot simply create a string of the desired length.  You can either make a string from a duplicate character (such as a blank) using the String constructor (char, int), or copy the source string using String.Copy (String). <br><br>  Armed with this knowledge, we write the following two implementations. <br><br><h5>  5. ReverseUnsafeFill </h5><br>  Make a string of spaces and fill it in reverse order: <br><br><blockquote> <code><a href="http://s-c.me/1684/s"></a> <a href="http://s-c.me/1684/h"></a> <font color="black">Copy Source | Copy HTML</font></code> <ol> <li>  <font color="#0000ff">static unsafe string</font> ReverseUnsafeFill ( <font color="#0000ff">string</font> str) </li><li>  { </li><li>  <font color="#0000ff">if</font> (str.Length &lt;= <font color="#A31515">1</font> ) <font color="#0000ff">return</font> str; </li><li>  <font color="#2b91af">String</font> copy = <font color="#0000ff">new</font> <font color="#2b91af">String</font> ( <font color="#A31515">''</font> , str.Length); </li><li>  <font color="#0000ff">fixed</font> ( <font color="#0000ff">char</font> * buf_copy = copy) </li><li>  { </li><li>  <font color="#0000ff">fixed</font> ( <font color="#0000ff">char</font> * buf = str) </li><li>  { </li><li>  <font color="#0000ff">int</font> i = <font color="#A31515">0</font> ; </li><li>  <font color="#0000ff">int</font> j = str.Length - <font color="#A31515">1</font> ; </li><li>  <font color="#0000ff">while</font> (i &lt;= j) </li><li>  { </li><li>  buf_copy [i] = buf [j]; </li><li>  buf_copy [j] = buf [i]; </li><li>  i ++;  j--; </li><li>  } </li><li>  } </li><li>  } </li><li>  <font color="#0000ff">return</font> copy; </li><li>  } </li></ol></blockquote><br><h5>  6. ReverseUnsafeCopy </h5><br>  Copy and flip the line: <br><br><blockquote> <code><a href="http://s-c.me/1685/s"></a> <a href="http://s-c.me/1685/h"></a> <font color="black">Copy Source | Copy HTML</font></code> <ol> <li>  <font color="#0000ff">static unsafe string</font> ReverseUnsafeCopy ( <font color="#0000ff">string</font> str) </li><li>  { </li><li>  <font color="#0000ff">if</font> (str.Length &lt;= <font color="#A31515">1</font> ) <font color="#0000ff">return</font> str; </li><li>  <font color="#0000ff">char</font> tmp; </li><li>  <font color="#2b91af">String</font> copy = <font color="#2b91af">String</font> .Copy (str); </li><li>  <font color="#0000ff">fixed</font> ( <font color="#0000ff">char</font> * buf = copy) </li><li>  { </li><li>  <font color="#0000ff">char</font> * p = buf; </li><li>  <font color="#0000ff">char</font> * q = buf + str.Length - <font color="#A31515">1</font> ; </li><li>  <font color="#0000ff">while</font> (p &lt;q) </li><li>  { </li><li>  tmp = * p; </li><li>  * p = * q; </li><li>  * q = tmp; </li><li>  p ++;  q--; </li><li>  } </li><li>  } </li><li>  <font color="#0000ff">return</font> copy; </li><li>  } </li></ol></blockquote><br>  As the measurements showed, the second version runs noticeably faster on slow memory and slightly slower on fast :) There are several reasons for this: operating with two remote memory areas instead of four and the difference in the speed of copying a memory block and simply filling it in a loop.  Those interested can try to make a full pass version of ReverseUnsafeFill (this can reduce the number of data captures from the memory into the cache) and try it out on a slow memory, but I have reason to believe that it will be anyway slower (although I may be mistaken). <br><br><h5>  7. ReverseUnsafeXorCopy </h5><br>  What's next?  It is rumored that the <a href="http://en.wikipedia.org/wiki/XOR_swap_algorithm">exchange using the XOR operator</a> works faster than copying through the third variable (by the way, it also looks quite nice in the pluses: ‚Äúa ^ = b ^ = a ^ = b;‚Äù, in C #, alas, this line does not work) .  Well, let's check in practice. <br><br><blockquote> <code><a href="http://s-c.me/1693/s"></a> <a href="http://s-c.me/1693/h"></a> <font color="black">Copy Source | Copy HTML</font></code> <ol> <li>  <font color="#0000ff">static unsafe string</font> ReverseUnsafeXorCopy ( <font color="#0000ff">string</font> str) </li><li>  { </li><li>  <font color="#0000ff">if</font> (str.Length &lt;= <font color="#A31515">1</font> ) <font color="#0000ff">return</font> str; </li><li>  <font color="#2b91af">String</font> copy = <font color="#2b91af">String</font> .Copy (str); </li><li>  <font color="#0000ff">fixed</font> ( <font color="#0000ff">char</font> * buf = copy) </li><li>  { </li><li>  <font color="#0000ff">char</font> * p = buf; </li><li>  <font color="#0000ff">char</font> * q = buf + str.Length - <font color="#A31515">1</font> ; </li><li>  <font color="#0000ff">while</font> (p &lt;q) </li><li>  { </li><li>  * p ^ = * q; </li><li>  * q ^ = * p; </li><li>  * p ^ = * q; </li><li>  p ++;  q--; </li><li>  } </li><li>  } </li><li>  <font color="#0000ff">return</font> copy; </li><li>  } </li></ol></blockquote><br>  The result is 1.2-1.5 times slower than the exchange of copies.  The trick, which worked for the rapid exchange of values ‚Äã‚Äãon registers, did not justify itself for variables (which is characteristic, in many C / C ++ compilers, it also does not win). <br><br>  Looking for explanations of this fact, we will go inside the application and read the resulting CIL code. <br><br><h4>  Part Three: we climb into CIL and .Net library codes. </h4><br><h5>  Why sharing through XOR was worse </h5><br>  For an answer to this question, it is worth looking at the CIL code generated for the two ways to exchange.  To make these instructions seem clearer, <b>let <i>me</i></b> explain their purpose: <b>ldloc <i>.N</i></b> - loads a local variable <i>N</i> on the stack, <b>stloc <i>.N</i></b> - reads the top of the stack into a local variable <i>N</i> , <b>xor</b> - calculates the value of the XOR operation for two values ‚Äã‚Äãat the top of the stack and loads the result on the stack instead. <br><br><table><tbody><tr><th>  Copy Exchange </th><th>  Exchange based on XOR </th><th>  Perfect exchange CIL </th></tr><tr><td><ol><li>  <font color="#0000ff">int</font> a, b; </li><li>  <font color="#0000ff">int</font> tmp = a; </li><li>  a = b; </li><li>  b = tmp; </li></ol></td><td><ol><li>  <font color="#0000ff">int</font> a, b; </li><li>  a ^ = b; </li><li>  b ^ = a; </li><li>  a ^ = b; </li></ol></td><td></td></tr><tr><td> <code><font color="black">.locals init (&lt;br/&gt; <br> [0] <font color="#2b91af">int32</font> a,&lt;br/&gt; <br> [1] <font color="#2b91af">int32</font> b,&lt;br/&gt; <br> [2] <font color="#2b91af">int32</font> tmp) <br></font></code> </td><td> <code><font color="black">.locals init (&lt;br/&gt; <br> [0] <font color="#2b91af">int32</font> a,&lt;br/&gt; <br> [1] <font color="#2b91af">int32</font> b)&lt;br/&gt; <br></font></code> </td><td> <code><font color="black">.locals init (&lt;br/&gt; <br> [0] <font color="#2b91af">int32</font> a,&lt;br/&gt; <br> [1] <font color="#2b91af">int32</font> b)&lt;br/&gt; <br></font></code> </td></tr><tr><td> <code><font color="black">L_0004: <font color="#0000ff">ldloc</font> .0&lt;br/&gt; <br> L_0005: <font color="#0000ff">stloc</font> .2&lt;br/&gt; <br> L_0006: <font color="#0000ff">ldloc</font> .1&lt;br/&gt; <br> L_0007: <font color="#0000ff">stloc</font> .0&lt;br/&gt; <br> L_0008: <font color="#0000ff">ldloc</font> .2&lt;br/&gt; <br> L_0009: <font color="#0000ff">stloc</font> .1&lt;br/&gt; &lt;br/&gt; &lt;br/&gt; &lt;br/&gt; &lt;br/&gt; &lt;br/&gt; <br></font></code> </td><td> <code><font color="black">L_0004: <font color="#0000ff">ldloc</font> .0&lt;br/&gt; <br> L_0005: <font color="#0000ff">ldloc</font> .1&lt;br/&gt; <br> L_0006: <font color="#0000ff">xor</font> &lt;br/&gt; <br> L_0007: <font color="#0000ff">stloc</font> .0&lt;br/&gt; <br> L_0008: <font color="#0000ff">ldloc</font> .1&lt;br/&gt; <br> L_0009: <font color="#0000ff">ldloc</font> .0&lt;br/&gt; <br> L_000a: <font color="#0000ff">xor</font> &lt;br/&gt; <br> L_000b: <font color="#0000ff">stloc</font> .1&lt;br/&gt; <br> L_000c: <font color="#0000ff">ldloc</font> .0&lt;br/&gt; <br> L_000d: <font color="#0000ff">ldloc</font> .1&lt;br/&gt; <br> L_000e: <font color="#0000ff">xor</font> &lt;br/&gt; <br> L_000f: <font color="#0000ff">stloc</font> .0&lt;br/&gt; <br></font></code> </td><td> <code><font color="black">L_0004: <font color="#0000ff">ldloc</font> .0&lt;br/&gt; <br> L_0005: <font color="#0000ff">ldloc</font> .1&lt;br/&gt; <br> L_0006: <font color="#0000ff">stloc</font> .0&lt;br/&gt; <br> L_0007: <font color="#0000ff">stloc</font> .1&lt;br/&gt; &lt;br/&gt; &lt;br/&gt; &lt;br/&gt; &lt;br/&gt; &lt;br/&gt; &lt;br/&gt; &lt;br/&gt; <br></font></code> </td></tr></tbody></table><br>  As you can easily see, the version with the XOR operator requires more virtual machine operations.  Moreover, during subsequent compilation into the native code, it is likely that there is optimization, which will replace the typical exchange via the third variable with a more efficient exchange operation, taking into account the capabilities of the processor used.  As a side effect of the analysis, we get a hypothetical ‚Äúperfect‚Äù exchange for CIL, it would be interesting to check whether its use will give any effect, but for this you need to mess with ilasm or reflection / emit, maybe even get together.  However, the resulting code will be even less applicable than unsafe c # so there is not much practical interest. <br><br><h5>  How does Array.Reverse work? </h5><br>  Well, while we are looking at the insides of the assemblies with a reflector, it makes sense to look at the implementation of the library methods used in the first part.  Apart here is Array.Reverse, which relies on a certain function Array.TrySZReverse, implemented as a native method.  So, download <a href="http://www.microsoft.com/downloads/details.aspx%3FFamilyID%3D8c09fd61-3f26-4555-ae17-3121b4f51d4d%26displaylang%3Den">Shared Source Common Language Infrastructure 2.0</a> - source .net 2.0 and see what kind of animal it is :) After a brief search, in the file ‚Äússcli20 \ clr \ src \ vm \ comarrayhelpers.h‚Äù there is a template function Reverse (in this the case of KIND will correspond to UINT16), which (surprise!) is terribly like the implementation of ReverseUnsafeCopy. <br><br><blockquote> <code><a href="http://s-c.me/1692/s"></a> <a href="http://s-c.me/1692/h"></a> <font color="black">Copy Source | Copy HTML</font></code> <ol> <li>  <font color="#0000ff">static void</font> Reverse ( <font color="#2b91af">KIND</font> array [], <font color="#2b91af">UNIT32</font> index, <font color="#2b91af">UNIT32</font> count) { </li><li>  LEAF_CONTRACT; </li><li></li><li>  _ASSERTE (array! = NULL); </li><li>  <font color="#0000ff">if</font> (count == 0) { </li><li>  <font color="#0000ff">return</font> ; </li><li>  } </li><li>  <font color="#2b91af">UNIT32</font> i = index; </li><li>  <font color="#2b91af">UNIT32</font> j = index + count - <font color="#A31515">1</font> ; </li><li>  <font color="#0000ff">while</font> (i &lt;j) { </li><li>  <font color="#2b91af">KIND</font> temp = array [i]; </li><li>  array [i] = array [j]; </li><li>  array [j] = temp; </li><li>  i ++; </li><li>  j--; </li><li>  } </li><li>  } </li></ol></blockquote><br><h4>  Part Four: Binary Marathon Results </h4><br>  The analysis of the measurement results is given in the first two parts, here only comparative diagrams depicting the performance ratio of the above functions are shown.  The exact numbers in the ‚Äúticks‚Äù are too dependent on the configuration and it is unlikely to be of particular interest, everyone can independently measure the speed using the provided pieces of code. <br><br><h5>  Comparison of the best methods from the first two parts </h5><br>  On fast memory <br> <a href="http://tinypic.com/"><img src="https://habrastorage.org/getpro/habr/post_images/d5b/927/6e4/d5b9276e4d295679a380332b8fc3a2ca.png" alt="Image and video hosting by TinyPic"></a> <br>  On slow memory <br> <a href="http://tinypic.com/"><img src="https://habrastorage.org/getpro/habr/post_images/85b/8cb/72a/85b8cb72a256b0d35cf9cfefaf87eb77.png" alt="Image and video hosting by TinyPic"></a> <br><br><h5>  Comparison of all methods in debug and release configurations on fast memory </h5><br>  Large lines <br> <a href="http://tinypic.com/"><img src="https://habrastorage.org/getpro/habr/post_images/7f6/252/a9d/7f6252a9d041750eb10a2c8fc888c56a.png" alt="Image and video hosting by TinyPic"></a> <br>  Short strings <br> <a href="http://tinypic.com/"><img src="https://habrastorage.org/getpro/habr/post_images/b16/ec3/9a6/b16ec39a6077e48365425edc3aa6ecdf.png" alt="Image and video hosting by TinyPic"></a> <br><br><h5>  Comparison of all methods in debug and release configurations on slow memory </h5><br>  Large lines <br> <a href="http://tinypic.com/"><img src="https://habrastorage.org/getpro/habr/post_images/fdc/bff/b5f/fdcbffb5fb6bbed9bc3a27a5bfa209ed.png" alt="Image and video hosting by TinyPic"></a> <br>  Short strings <br> <a href="http://tinypic.com/"><img src="https://habrastorage.org/getpro/habr/post_images/790/e62/aa3/790e62aa3472f163c60e6f77b8ef4051.png" alt="Image and video hosting by TinyPic"></a> </div><p>Source: <a href="https://habr.com/ru/post/58333/">https://habr.com/ru/post/58333/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../58323/index.html">Freelance builders received "their" Internet exchange</a></li>
<li><a href="../58324/index.html">On the handles of IT-nick say a word</a></li>
<li><a href="../58326/index.html">iPod Chief Pirate Device</a></li>
<li><a href="../58328/index.html">Reverse card sorting method, on the example of Skype</a></li>
<li><a href="../58329/index.html">Desktop Fan - especially for the 2009 Ice Hockey World Championship!</a></li>
<li><a href="../58334/index.html">JuffEd 0.7.528 or What version 0.8.0 prepares for us</a></li>
<li><a href="../58336/index.html">Webby Awards uses Silverlight</a></li>
<li><a href="../58339/index.html">Samuel Morse's Birthday</a></li>
<li><a href="../58340/index.html">Korea created a fluorescent puppy</a></li>
<li><a href="../58342/index.html">The first global computer virus is 10 years old</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>