<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Fast Fixed Point Math for Java Financial Applications</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="It is no secret that financial information (invoices, transactions, and other bookkeeping) is not very friendly with floating point numbers, and many ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Fast Fixed Point Math for Java Financial Applications</h1><div class="post__text post__text-html js-mediator-article"><p>  It is no secret that financial information (invoices, transactions, and other bookkeeping) is not very friendly with floating point numbers, and many articles recommend using a fixed point (fixed point arithmetic).  In Java, this format is represented, in fact, only by the BigDecimal class, which cannot always be used for performance reasons.  You have to look for alternatives.  This article describes a self-written Java library for performing arithmetic operations on fixed-precision numbers.  The library was created to work in high-performance financial applications and allows you to work with an accuracy of up to 9 decimal places while maintaining acceptable performance.  A link to the source code and benchmarks is provided at the end of the article. </p><a name="habracut"></a><br><h1 id="arifmetika-s-plavayuschey-tochkoy">  Floating point arithmetic </h1><br><p>  Modern computers can perform arithmetic operations only with limited accuracy.  These are discrete devices that may not work with all possible numbers, but only with some of their countable subsets.  The most common format for working with real numbers in the computer's memory is a floating (binary) point - floating (binary) point, when numbers are stored as M * 2 ^ E, where M and E are integer mantissa and the order of the numbers.  But some numbers, such as 0.1, cannot be accurately represented in this format.  Therefore, in the course of complex calculations, some error inevitably accumulates.  That is, the result of the machine calculation, say 0.1 + 0.1 + 0.1, does not coincide with the mathematically correct 0.3.  Given the above, when programming complex arithmetic, you can follow several strategies: </p><br><p>  Strategy 1 - ignore.  Do not pay attention to the error, consider all operations ideally mathematical, and hope that the accuracy available will suffice for acceptable results.  The most common option. </p><br><p>  Strategy 2 - scrupulously calculate.  Formulas for calculating machine errors have been known for more than a decade.  They allow us to estimate from above the relative error of any arithmetic operation.  Probably, and it is necessary to do for serious numerical modeling.  The problem is that it is very time consuming.  In fact, every + - * / character in the code must be accompanied by an error calculation.  It is necessary to take into account all the dependencies between the calculations and repeat the procedure every time the code changes. </p><br><p>  Strategy 3 - use a decimal point (floating decimal point) instead of a binary one.  That is, store numbers in the form of M * 10 ^ E.  This does not solve the problems with an error (the mantissa is still rounded to a finite number of significant digits), but at least all the ‚Äúsimple‚Äù numbers for a person (like 1.1) are now accurately represented in the memory.  Payback will be performance.  Any normalization of numbers (that is, an equivalent reduction of the mantissa and an increase in order) requires division by degree 10, which is not very fast, unlike division by degree 2. And there is a lot to normalize ‚Äî with each addition or subtraction with different orders. </p><br><p>  Strategy 4 - use a fixed point (fixed decimal point).  Simplify strategy 3 when we fix order E. In this case, normalization is not needed for addition / subtraction.  In addition, all calculations will have the same absolute error.  This strategy is devoted to the article. </p><br><h1 id="arifmetika-s-fiksirovannoy-tochkoy">  Fixed point arithmetic </h1><br><p>  In contrast to physics, where relative error is important, in finance, an absolute is needed.  If, after conducting a complex financial transaction, a customer is billed at $ 1000000.23 while he expects $ 1000000.18, then there may be some difficulties.  An explanation of the ‚Äúyes, why do you need an accuracy of 8 significant digits ??‚Äù may not roll.  And it's not a loss of 5 cents (to make a mistake on the contrary, ‚Äúin favor‚Äù of the client is not much better), but in the inconsistencies of accounting.  Therefore, the rules of computation and rounding are clearly stipulated between the parties, and artifacts from the use of double and float variables sometimes complicate life. </p><br><p>  In Java, there is a standard class for fixed point arithmetic - BigDecimal.  There are two problems with him: he is slow (because of his versatility) and he is not mutable.  Non-confusion means that any operation allocates an object on the heap.  The selection and release in terms of the object takes a little time, but intensive calculations in the hot code create a decent load on the GC, which is unacceptable in some cases.  You can hope for escape analysis and scalarization, but they are very unstable in the sense that even a minor change in the code or in the JIT (such as lazy loading of the new interface implementation) can turn the entire inline structure upside down, and the method that worked normally a minute ago, suddenly begin to allocate memory madly. <br>  UPD because of the questions in the comments: <strong>The main reason for the</strong> rejection of BigDecimal and BigInteger is not at all the poor performance of calculations, but the inconsistency and allocation of objects. </p><br><p>  The described library is the result of the fact that I was tired of rewriting non-allocating memory fixed arithmetic from scratch for each new employer, and I decided to write my own library for later insourcing. </p><br><p>  Immediately show an example of use, before moving on to the details of implementation: </p><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Sample</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Decimal margin; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Quantity cumQuantity = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Quantity(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Quantity contraQuantity = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Quantity(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Quantity cumContraQuantity = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Quantity(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Price priceWithMargin = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Price(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Price avgPrice = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Price(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Sample</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> marginBp)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// 1 + margin / 10000 this.margin = Decimal.create(marginBp).divRD(10000L).add(1); } public Price calculateAvgPrice(Quantity[] quantities, Price[] prices) { cumQuantity.set(0); contraQuantity.set(0); // avg = sum(q * p * margin) / sum(q) for (int i = 0; i &lt; quantities.length; i++) { cumQuantity.add(quantities[i]); priceWithMargin.set(prices[i]).mulRD(margin); contraQuantity.set(quantities[i]).mulRD(priceWithMargin); cumContraQuantity.add(contraQuantity); } return avgPrice.quotientRD(cumContraQuantity, cumQuantity); } public static void main(String[] args) throws ParseException { Price p1 = Price.create("1.5"); Price p2 = Price.create(1.6); Quantity q1 = Quantity.create("100"); Quantity q2 = Quantity.create(200); // apply 0.05% margin to the prices Sample sample = new Sample(5); System.out.println(sample.calculateAvgPrice(new Quantity[]{q1, q2}, new Price[]{p1, p2})); } }</span></span></code> </pre> <br><h1 id="ideya-realizacii">  Idea implementation </h1><br><p>  So, we need a mutable wrapper for an integer primitive, more precisely, a long, which will give us nearly 19 significant digits (enough for the whole and for the fractional part).  In long, we mean N decimal places.  For example, when N = 2, the number 2.56 is stored as 256 (binary 100000000).  Negative numbers are stored in the standard, in the additional code: </p><br><p>  <em>-2.56</em> <br>  <strong>-256</strong> </p><br><p>  (Hereinafter, ‚Äúmathematical‚Äù numbers and calculations are indicated <em>in italics</em> , and their internal representation is <strong>bold</strong> ) </p><br><p>  It also seemed to me useful to enter NaN as a separate value, which is returned in case of arithmetic errors (instead of elimination or garbage).  <em>NaN</em> is represented internally as <strong>Long.MIN_VALUE</strong> , ‚Äúpropagates‚Äù (propagated) through all operations and allows you to determine the sign inversion for all the remaining numbers. </p><br><p>  Let us try to estimate the algorithms of arithmetic operations for the case when N = 2. </p><br><p>  Addition and subtraction do not require any extra gestures, just use the values ‚Äã‚Äãas is: </p><br><p>  <em>1.20 + 2.30 = 3.50</em> <br>  <strong>120 + 230 = 350</strong> </p><br><p>  Multiplication and division require additional normalization, that is, multiplication / division by 10 ^ N (by 100 in our example) </p><br><p>  <em>1.20 * 2.00 = 2.40</em> <br>  <strong>120 * 200/100 = 240</strong> </p><br><p>  <em>1.20 / 2.00 = 0.60</em> <br>  <strong>100 * 120/200 = 60</strong> </p><br><p>  Additional division is not the fastest operation.  But in this case, this division by a constant, because we fixed N = 2 and 10 ^ N = 100 in advance.  The division by a constant, especially the ‚Äúbeautiful‚Äù (type 10), is intensively optimized in the CPU and much faster than the division by a random number.  We do a lot of divisions by 10 each time we convert any number to a string (for example, in logs), and CPU manufacturers know about this ( <a href="https://en.wikipedia.org/wiki/Division_algorithm">for more information,</a> see "Division by a constant" <a href="https://en.wikipedia.org/wiki/Division_algorithm">for optimization</a> ). </p><br><p>  To consolidate the understanding of what we are doing, I will give one more operation: a unary inversion of a number, that is, 1 / x.  This is a special case of division, you just need to submit 1.00 in our format and do not forget to normalize: </p><br><p>  <em>1.00 / 2.00 = 0.50</em> <br>  <strong>100 * 100/200 = 50</strong> </p><br><p>  Well, so far everything is pretty simple, let's try to get into the details. </p><br><h1 id="okruglenie">  Rounding </h1><br><p>  Let's try to draw another number: </p><br><p>  <em>1.00 / 3.00 = 0.33</em> <br>  <strong>100 * 100/300 = 33</strong> </p><br><p>  An honest mathematical result lies between 0.33 and 0.34, but we cannot accurately represent it.  Which way to round?  Usually rounded to 0, and this is the fastest way (supported by hardware).  But, returning to the real financial problems, this is not always the case.  Usually, when processing transactions with a client, rounding is ‚Äúin favor of the client‚Äù.  That is, the price is rounded up if the customer sells, and down if the customer buys.  But other options may be required, for example, arithmetic rounding to the nearest number with subtypes (half-up, half-down, half-even) to minimize accounting inconsistencies.  Or rounding to ¬± infinity for negative prices (for some financial instruments).  Java BigDecimal already contains a list of standard rounding modes, and the described library supports them all.  UNNECESSARY returns NaN if the operation unexpectedly requires rounding. </p><br><p>  In rounding up mode, our calculation should yield: </p><br><p>  <em>1.00 / 3.00 = 0.34</em> <br>  <strong>100 * 100/300 + 1 = 34</strong> </p><br><p>  How do I know if I need to add one?  You need the remainder of the division of 10000% 300 = 100. Which is as slow as the division itself.  Fortunately, if you write in succession in the code "a / b; a% b", then JIT will figure out that 2 divisions are not necessary, just one assembler command div returning 2 numbers (quotient and remainder). </p><br><p>  Other rounding options are a bit more complicated, but they can also be calculated based on the remainder and the divisor. </p><br><p>  In the API, I deliberately made mentioning rounding wherever it occurs, either as a parameter or as a suffix <strong>R</strong> ound <strong>D</strong> own in methods where it defaults to zero. </p><br><h1 id="perepolnenie">  Overflow </h1><br><p>  We come to the most difficult part.  Remember once again our multiplication: </p><br><p>  <em>1.20 * 2.00 = 2.40</em> <br>  <strong>120 * 200/100 = 240</strong> </p><br><p>  Now imagine that we are in the 1980s and we have 16-bit processors.  That is, only short is available to us with a maximum value of 65535. The first multiplication will overflow and will be equal to 240000 &amp; 0xFFFF = 44392 (this is if without a sign, with a sign it will also be negative), which will break the result. </p><br><p>  Will not work.  We have 2 normal (values ‚Äã‚Äãthat fit into our range) arguments, and the same normal expected result, but we fill up halfway.  Exactly the same situation is possible with 64-bit long, just the numbers need more. </p><br><p>  In the 1980s, we would need a multiplication, giving a 32-bit result.  Today we need multiplication with a 128-bit result.  The most annoying thing is that both multiplications are available in assemblers 8086 and x86-64, respectively, but we cannot use them from Java!  JNI, even in the case of a hack with fast JavaCritical, gives the overhead in tens of nanoseconds, introduces problems with deployment and compatibility, freezes the GC for the duration of the call.  In addition, we would somehow have to return a 128-bit result from the native method, and writing by reference to the array (to memory) is an additional delay. </p><br><p>  In general, I had to write manual multiplication and division.  Column.  I needed 2 auxiliary operations: </p><br><ol><li>  A (64) * B (64) = T (128);  T (128) / N (32) = Q (64), R (32) - as part of the fixed point multiplication A * B </li><li>  N (32) * A (64) = T (96);  T (96) / B (64) = Q (64), R (64) - as part of the fixed point of division A / B <br>  (the data in bits is indicated in brackets, T is a temporary variable that should not be overflowed) </li></ol><br><p>  Both operations return a quotient and a remainder (one - as the result of the method, the second - in the field of the object).  They too can overflow, but only at the last step, when it is inevitable.  Here is an example (from the 1980s): </p><br><p>  <em>500.00 / 0.50 = 1000.00</em> <br>  <strong>100 * 50,000 / 50 = 100,000</strong> - overflow! </p><br><p>  Dividing the column a la Knut is not the easiest algorithm.  Plus, it should all be relatively fast.  Therefore, the code of both operations is hundreds of lines of fairly harsh bit magic, it will take a long time for me to remember again what exactly is happening there.  I pulled them into a separate class and commented in detail as I could. </p><br><p>  The multiplication algorithm is not limited to calling operation 1, but the remaining code is not so complicated and simply adds support for negative numbers, rounding, and NaN. </p><br><p>  Usually (with the exception of special cases), both operations contain 4 multiplications and 2 divisions.  Operation 1 is significantly faster than 2, since in it these divisions are by a constant. </p><br><p>  By the way, if anyone noticed, N (32) is our 10 ^ N for normalization.  It is 32-bit, which means that N can be a maximum of 9. In the real applications I saw, 2, 4, or 8 decimal places were used.  More than 9 I have not met, so that should be enough.  If you make 10 ^ N 64-bit, the code becomes more complicated (and slows down) even more. </p><br><h1 id="neskolko-raznyh-tochnostey">  Several different accuracy </h1><br><p>  Sometimes it is necessary to perform an operation on arguments with a different number of decimal places.  At a minimum, enter transactions involving the usual long. </p><br><p>  For example: </p><br><p>  <em>2.0000 (N = 4) + 3.00 (N = 2) = 5.0000 (N = 4)</em> <br>  <strong>20,000 + 300 * 100 = 50000</strong> </p><br><p>  <em>3.00 (N = 2) + 2.0000 (N = 4) = 5.00 (N = 2)</em> <br>  <strong>300 + 20000/100 = 500</strong> </p><br><p>  In this case, additional normalization of one of the arguments is required.  Note that mathematically both operations are equivalent, but because of the other accuracy of the result, they are calculated differently.  It is also worth noting that the second operation generally requires rounding. </p><br><p>  The number of decimal places is NOT stored in the object.  Instead, a separate subclass is assumed for each accuracy.  Class names can be business oriented, for example Price (N = 8), Quantity (N = 2).  And they can be generalized: Decimal1, Decimal2, Decimal3, ... The greater the accuracy, the smaller the range of stored values, the minimum range has Decimal9: ¬± 9223372036.  It is assumed that one or two classes will be enough to cover the necessary functionality, in which case the abstract getScale method will most likely be virtualized and inline.  Subclasses (instead of an additional field) allow you to strictly typify the accuracy of the arguments and the result, as well as to signal possible rounding at the compilation stage. </p><br><p>  The library allows for operations in which a maximum of 2 (but not 3) of different accuracy are involved.  That is, either the accuracy of the two arguments must match, or the accuracy of one of the arguments and the result.  Again, support for 3 different precisions would slow the code down and complicate the API.  As arguments, you can pass the usual long, for which the accuracy is assumed to be N = 0. </p><br><p>  <em>2.0000 / 3.0 = 0.6667</em> - ok (2 different accuracy) <br>  <em>2/3 = 0.6667</em> - ok (long arguments, decimal result) <br>  <em>2 / 3.0 = 0.6667</em> - impossible!  (3 different accuracy) </p><br><h1 id="dostoinstva-i-nedostatki">  Advantages and disadvantages </h1><br><p>  Obviously, the calculations of increased bitness carried out by the library are slower than the hardware supported.  However, the overhead projector is not so large (see benchmarks below). </p><br><p>  In addition, due to the lack of operator overloading in Java, using methods instead of arithmetic operators complicates code perception. </p><br><p>  Based on this, the library is usually used in places where the loss of absolute accuracy is critical.  For example, calculating accurate financial statistics, accounting for current financial indicators (trading positions, PnL, executing orders).  In the case of network exchange of financial information between systems, it is also more convenient to use formats with a decimal point (instead of binary). </p><br><p>  Complex mathematical algorithms (modeling, statistics, forecasting) are usually simpler to perform as standard in double, since their result is not absolutely accurate in any case. </p><br><h1 id="kod-i-benchmarki">  Code and benchmarks </h1><br><p>  <a href="https://github.com/maxtomin/decimal">Code</a> </p><br><table><tbody><tr><th>  Benchmark </th><th>  Mode </th><th>  Cnt </th><th>  Score </th><th>  Error </th><th>  Units <br></th></tr><tr><td>  DecimalBenchmark.control </td><td>  avgt </td><td>  200 </td><td>  10.072 </td><td>  ¬± 0.074 </td><td>  ns / op <br></td></tr><tr><td>  DecimalBenchmark.multiplyNative </td><td>  avgt </td><td>  200 </td><td>  10.625 </td><td>  ¬± 0.142 </td><td>  ns / op <br></td></tr><tr><td>  DecimalBenchmark.multiplyMyDecimal </td><td>  avgt </td><td>  200 </td><td>  35.840 </td><td>  ¬± 0.121 </td><td>  ns / op <br></td></tr><tr><td>  DecimalBenchmark.multiplyBigDecimal </td><td>  avgt </td><td>  200 </td><td>  126.098 </td><td>  ¬± 0.408 </td><td>  ns / op <br></td></tr><tr><td>  DecimalBenchmark.quotientNative </td><td>  avgt </td><td>  200 </td><td>  70.728 </td><td>  ¬± 0.230 </td><td>  ns / op <br></td></tr><tr><td>  DecimalBenchmark.quotientMyDecimal </td><td>  avgt </td><td>  200 </td><td>  138.581 </td><td>  ¬± 7.102 </td><td>  ns / op <br></td></tr><tr><td>  DecimalBenchmark.quotientBigDecimal </td><td>  avgt </td><td>  200 </td><td>  179.650 </td><td>  ¬± 0.849 </td><td>  ns / op <br></td></tr></tbody></table><br><p>  In general, multiplication is 4 times faster than BigDecimal, division - in 1.5.  The division rate depends <em>strongly</em> on the arguments, hence the spread of values. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/425565/">https://habr.com/ru/post/425565/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../425555/index.html">Charles Nutter on Dynamic Languages ‚Äã‚Äãin JVM on jug.msk.ru</a></li>
<li><a href="../425557/index.html">MIT course "Computer Systems Security". Lecture 10: "Symbolic execution", part 1</a></li>
<li><a href="../425559/index.html">MIT course "Computer Systems Security". Lecture 10: "Symbolic Execution", part 3</a></li>
<li><a href="../425561/index.html">MIT course "Computer Systems Security". Lecture 10: "Symbolic execution", part 2</a></li>
<li><a href="../425563/index.html">California bans the sale of IoT devices with simple passwords or no passwords.</a></li>
<li><a href="../425569/index.html">Functional PCB Testing</a></li>
<li><a href="../425571/index.html">Protecting the web server on Linux</a></li>
<li><a href="../425575/index.html">Neurospine</a></li>
<li><a href="../425581/index.html">Jetpack October 11, 1961: The President opened his mouth ...</a></li>
<li><a href="../425583/index.html">Everything that still baffles robobomili, starting with gulls</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>