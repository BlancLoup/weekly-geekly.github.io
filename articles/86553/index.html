<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>FreeBSD Netgraph on the example of an Ethernet tunnel</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello. 

 I think many system administrators working with FreeBSD are aware of the existence of the nuclear subsystem Netgraph. But not many know / un...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>FreeBSD Netgraph on the example of an Ethernet tunnel</h1><div class="post__text post__text-html js-mediator-article">  Hello. <br><br>  I think many system administrators working with FreeBSD are aware of the existence of the nuclear subsystem Netgraph.  But not many know / understand how it works, and what can be built from this. <br><br>  I'll tell you what it is, as well as analyze a simple example of an Ethernet bridge assembly via the Internet. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <a name="habracut"></a><br><br><h3>  A bit of theory. </h3><br>  Wikipedia tells <a title="Wikipedia" href="http://ru.wikipedia.org/wiki/Netgraph">http://ru.wikipedia.org/wiki/Netgraph</a> <br><br>  <em>Netgraph is the modular network subsystem of the FreeBSD kernel, based on graph principle.</em>  <em>In Netgraph, a graph is constructed from nodes of various types, each node type has a certain number of inputs / outputs (hereinafter referred to as hooks).</em>  <em>The netgraph node allows you to perform certain actions on a packet passing through it.</em>  <em>Some Netgraph nodes provide support for various protocols, encapsulations, such as L2TP, PPTP, PPPoE, PPP, ATM, bluetooth, others are used for connecting modules and sorting / routing between netgraph nodes, such as bpf, split.</em> <br><br>  The Netgraph subsystem is a set of modules, each with its own specific task.  This is such a handful of Lego cubes that can always be connected. <br><br>  A striking example of using multiple netgraph modules is the massively used Russian <a title="Demon MPD" href="http://mpd.sourceforge.net/">mpd</a> demon providers to terminate client tunnels, such as PPPoE, PPTP, PPP, and so on.  In versions of the 3 mpd branches, I did many operations myself, but by 5 of the current version, I mainly deal with switching netgraph modules. <br><br><h3>  Let's look at our cubes. </h3><br> <code>[root@bsd1] /boot/kernel/&gt; ls | grep ng_ <br> ng_UI.ko <br> ng_async.ko <br> ng_atm.ko <br> ng_atmllc.ko <br> ng_bluetooth.ko <br> ng_bpf.ko <br> ng_bridge.ko <br> ng_bt3c.ko <br> ng_btsocket.ko <br> ng_car.ko <br> ng_ccatm.ko <br> ng_cisco.ko <br> ng_deflate.ko <br> ng_device.ko <br> ng_echo.ko <br> ng_eiface.ko <br> ng_etf.ko <br> ng_ether.ko <br> ng_fec.ko <br> ng_frame_relay.ko <br> ng_gif.ko <br> ng_gif_demux.ko <br> ng_h4.ko <br> ng_hci.ko <br> ng_hole.ko <br> ng_hub.ko <br> ng_iface.ko <br> ng_ip_input.ko <br> ng_ipfw.ko <br> ng_ksocket.ko <br> ng_l2cap.ko <br> ng_l2tp.ko <br> ng_lmi.ko <br> ng_mppc.ko <br> ng_nat.ko <br> ng_netflow.ko <br> ng_one2many.ko <br> ng_ppp.ko <br> ng_pppoe.ko <br> ng_pptpgre.ko <br> ng_pred1.ko <br> ng_rfc1490.ko <br> ng_socket.ko <br> ng_source.ko <br> ng_split.ko <br> ng_sppp.ko <br> ng_sscfu.ko <br> ng_sscop.ko <br> ng_sync_ar.ko <br> ng_sync_sr.ko <br> ng_tag.ko <br> ng_tcpmss.ko <br> ng_tee.ko <br> ng_tty.ko <br> ng_ubt.ko <br> ng_uni.ko <br> ng_vjc.ko <br> ng_vlan.ko <br> [root@bsd1] /boot/kernel/&gt; ls | grep ng_ | wc -l <br> 58 <br> [root@bsd1] /boot/kernel/&gt; <br></code> <br>  Currently 58 modules +1 main module netgraph.ko (FreeBSD 7.3).  All of them can be built into the kernel statically, or dynamically loaded.  Since the modules are nuclear, they also work right in the core, due to which you can get amazingly productive results. <br><br>  For each module there is a man, which describes the capabilities of the module, inputs / outputs (hook, hooks, hooks, I will call them ‚Äúhooks‚Äù), received control messages and their actions. <br>  To control the netgraph subsystem, there is a ngctl utility that accepts various commands, such as list, mkpeer, connect, name, etc., you can read about them separately in man ngctl. <br><br><h3>  Task. </h3><br>  Let's set a simple task: it is necessary to connect two physical Ethernet networks via the Internet. <br>  We have 2 servers. <br><br>  BSD1 <br>  2 network interfaces <br>  Interface 1 em0 - external IP 1.1.1.1 <br>  Interface 2 em1 - internal IP 192.168.1.1 <br><br>  BSD2 <br>  2 network interfaces <br>  Interface 1 em0 - external IP 2.2.2.2 <br>  Interface 2 em1 - internal IP 192.168.1.2 <br><br>  Between the servers there is a routable Internet connection through external interfaces. <br>  You need to connect the network on the em1 interfaces of both servers. <br><br><h3>  Let's look at our cubes. </h3><br>  We will need: <br><br>  <b>netgraph.ko</b> - the foundation. <br><br><img title="Ng_ether job" alt="ng_ether.gif" src="http://img.habreffect.ru/lmik/ng_ether.gif" align="left">  <b>ng_ether.ko</b> is a module for connecting to physical network interfaces.  When this module is loaded in graph space, one node is automatically created for each physical interface, which has the name of this interface.  In our case it will be "em0:", "em1:".  Each ng_ether node has 3 hooks: lower, upper, orphans.  The lower hook is a direct exit to the location of the network interface driver, from where the packets are sent or received by the device.  The upper hook is a direct access to the place of the system kernel, from where packets should be sent or received by the network device driver.  Hook orphans, this is the same lower one, only erroneous, corrupted packets from a network device get into it.  We do not take it into account. <br><br>  In simple terms: when ng_ether is connected, a gap appears in the exchange between the kernel and the network card driver.  On the side of the core, this gap is called upper, on the side of the network device driver, lower.  This gap is connected, until the moment when the netgraph subsystem connects to the lower or upper subsystem. <br><br><br><img title="Job ng_bridge" alt="ng_bridge.gif" src="http://img.habreffect.ru/lmik/ng_bridge.gif" align="left">  <b>ng_bridge.ko</b> - the module of the most real Ethernet switch.  Everyone, I think, can imagine (and someone even now sees) a box with Ethernet ports, blinking lights, standing on a table and connecting computers to a network.  ng_bridge is the box in the netgraph subsystem.  ng_bridge is a simple implementation of an Ethernet switch, equipped with an arp table and a simple loop detection algorithm.  Hooks ng_bridge are called link0, link1, etc.  We will connect our ng_ether hooks to them.  The module accepts control messages such as setconfig, getconfig, reset, getstats, clrstats, getclrstats, gettable.  Message actions are intuitive, details in man ng_bridge. <br><br><br><img title="Work ng_ksocket" alt="ng_ksocket.gif" src="http://img.habreffect.ru/lmik/ng_ksocket.gif" align="left">  <b>ng_ksocket.ko</b> is a module that allows you to <b>listen</b> to a socket directly from the kernel (any socket supported by the system function socket ()) and connect to another socket.  Accepts the only connection to the hook "&lt;family&gt; / &lt;type&gt; / &lt;proto&gt;".  In man socket it is told what are family, type, proto.  In our case it will be "inet / dgram / udp".  inet - ipv4, dgram - datagrams, proto - udp.  The module also accepts several control messages, such as bind, listen, connect, accept, getname, getpeername, setopt, getopt.  Read more in man ng_ksocket.  Using the message ‚Äúconnect‚Äù we can connect our inet ‚Äúinet / dgram / udp‚Äù to a remote one that was created in the same way, but with the ‚Äúbind‚Äù command. <br><br><h3>  We make the graph. </h3><br>  For a better understanding of the work of your graph system, it is advisable to draw them before assembling in the system. <br><br><div style="text-align:center;"><img title="The scheme of interaction modules." alt="ethernet_over_udp_scheme.gif" src="http://img.habreffect.ru/lmik/ethernet_over_udp_scheme.gif"></div><br><br>  1. We connect both hooks of the ng_ether module of em1 interface to ng_bridge so that the system can see both the physical network connected to the interface and our virtual network.  It is done the same on both servers. <br>  2. The next free ng_bridge link is connected to ng_ksocket with inet / dgram / udp parameters.  (Why did I choose UDP? Because no one guarantees the successful delivery of a signal in a cable or radio network, just as in the IP protocol, no one guarantees delivery of UDP.) It is done the same on both servers. <br>  3. Commanding the ng_ksocket module to take a specific port, on a specific IP address, and also connect to a remote IP using the required port.  We do this on both servers, in the difference that IP addresses and ports are changing to opposite to each other. <br><br><br><h3>  We collect the graph in the system. </h3><br>  I have already mentioned the ngctl utility above.  With its help, we will create our modules in the system and link them. <br>  We need the commands mkpeer, connect, name, msg.  I will describe them in simple language. <br><br>  <b>Mkpeer command</b> <br>  Syntax: <i>ngctl mkpeer module1 module_type2 hook1 hook2</i> <br>  Creates a ‚Äúmodule2‚Äù with the specified type and connects its hook ‚Äúhook‚Äù to the ‚Äúhook 1‚Äù of the module ‚Äúmodule 1‚Äù <br><br>  <b>Command connect.</b> <br>  Syntax: <i>ngctl connect module1 module2 hook1 hook2</i> <br>  It connects the "hook1" of the module "module1" to the "hook2" of the module "module 2". <br><br>  <b>Command name.</b> <br>  Syntax: <i>ngctl name module: hook name</i> <br>  Assigns a name to the module created via mkpeer. <br><br>  <b>The msg command.</b> <br>  Syntax: <i>ngctl msg module: message parameters</i> <br>  Transmits a control ‚Äúmessage‚Äù to a ‚Äúmodule‚Äù with ‚Äúparameters‚Äù. <br><br>  Well, now what our graph will look like live for the server "bsd1".  For the tunnel we will use udp port 7777 <br><br>  Create a node ng_bridge and connect to its hook ‚Äúlink0‚Äù hook of the network interface ‚Äúem1‚Äù ‚Äúlower‚Äù. <br>  <b>ngctl mkpeer em1: bridge lower link0</b> <br>  We call the newly created node the name "switch", it can be found along the path "em1: lower". <br>  <b>ngctl name em1: lower switch</b> <br>  We connect to the "link1" of our "switch" upper network interface "em1". <br>  <b>ngctl connect switch: em1: link1 upper</b> <br>  Create the ng_ksocket node and connect to its hook ‚Äúinet / dgram / udp‚Äù ‚Äúlink2‚Äù of our ‚Äúswitch‚Äù <br>  <b>ngctl mkpeer switch: ksocket link2 inet / dgram / udp</b> <br>  Call the newly created ksocket "switch_socket", it can be found along the path "switch: link2" <br>  <b>ngctl name switch: link2 switch_socket</b> <br>  We send the command "bind" to our "switch_socket", with parameters.  ksocket will take port 7777 on IP 1.1.1.1. <br>  <b>ngctl msg switch_socket: bind inet / 1.1.1.1: 7777</b> <br>  We send the "connect" command to our "switch_socket", with parameters.  ksocket will connect to port 7777 at the IP address 2.2.2.2. <br>  <b>ngctl msg switch_socket: connect inet / 2.2.2.2: 7777</b> <br>  We send a command to the ng_ether module of the em1 network interface to switch to the listening mode for packets not addressed to it.  We now need to accept packets for devices located in our virtual network. <br>  <b>ngctl msg em1: setpromisc 1</b> <br>  <b>ngctl msg em1: setautosrc 0</b> <br><br>  For the server "bsd2" we just need to swap the parameters of the bind and connect commands in places. <br><br>  For ease of use, I designed this into a sh script. <br>  The script uses another command ngctl shutdown.  This command sends a special control message to the module specified in the parameter.  This message is received by each module, in more detail in the "man module".  Usually this command causes the destruction of the module and the rupture of all its connections. <br><br><pre>  #! / bin / sh
 self = 1.1.1.1
 peer = 2.2.2.2
 port = 7777
 if = em1

 case "$ 1" in
         start)
             echo "Starting netgraph switch."
             ngctl mkpeer $ {if}: bridge lower link0
             ngctl name $ {if}: lower switch
             ngctl connect switch: $ {if}: link1 upper
             ngctl mkpeer switch: ksocket link2 inet / dgram / udp
             ngctl name switch: link2 switch_socket
             ngctl msg switch_socket: bind inet / $ {self}: $ {port}
             ngctl msg switch_socket: connect inet / $ {peer}: $ {port}
             ngctl msg $ {if}: setpromisc 1
             ngctl msg $ {if}: setautosrc 0
             echo "Ok."
             exit 0
             ;;
         stop)
             echo "Stopping netgraph switch."
             ngctl shutdown switch_socket:
             ngctl shutdown switch:
             ngctl shutdown $ {if}:
             echo "Ok."
             exit 0
             ;;
         restart)
             sh $ 0 stop
             sh $ 0 start
             ;;
         *)
             echo "Usage:` basename $ 0` {start | stop | restart} "
             exit 64
             ;;
 esac
</pre><br>  Let's see what happened <br> <code>[root@bsd1] /usr/local/etc/rc.d/&gt; ngctl list <br> There are 5 total nodes: <br> Name: em0 Type: ether ID: 00000001 Num hooks: 0 <br> Name: em1 Type: ether ID: 00000002 Num hooks: 2 <br> Name: switch Type: bridge ID: 000000f6 Num hooks: 3 <br> Name: ngctl16408 Type: socket ID: 00000100 Num hooks: 0 <br> Name: switch_socket Type: ksocket ID: 000000fa Num hooks: 1 <br></code> <br><br>  The ngctl16408 module with the socket type is used by ngctl for management, do not pay attention to it. <br><br>  Bags run: <br><pre> [root @ bsd1] / root /&gt; ping 192.168.1.2
 PING 192.168.1.2 (192.168.1.2): 56 data bytes
 64 bytes from 192.168.1.2: icmp_seq = 0 ttl = 64 time = 3.760 ms
 64 bytes from 192.168.1.2: icmp_seq = 1 ttl = 64 time = 3.527 ms
 64 bytes from 192.168.1.2: icmp_seq = 2 ttl = 64 time = 3.479 ms
 64 bytes from 192.168.1.2: icmp_seq = 3 ttl = 64 time = 4.052 ms

 [root @ bsd1] / root /&gt; ngctl msg switch: getstats 2
 Rec'd response "getstats" (4) from "[f6]:":
 Args: {recvOctets = 49333 recvPackets = 532 recvMulticast = 467 recvBroadcast = 63 xmitOctets = 580 xmitPackets = 12 xmitMulticasts = 10 xmitBroadcasts = 1}
</pre><br><br><h3>  the end </h3><br>  Wrote a lot of text, hopefully understandable.  In practice, such a tunnel will seem to someone unprotected, because bags will run openly over the Internet, but no one bothers you to forward this tunnel inside a VPN connection.  For example, I use such a bundle to pass multicast IPTV to a work network. <br><br>  In the next article I will describe a few more modules of the netgraph - traffic count ng_netflow, nat ng_nat, add shaping via ng_car to the scheme today, or maybe invent something else interesting. <br><br>  Thanks for attention. </div><p>Source: <a href="https://habr.com/ru/post/86553/">https://habr.com/ru/post/86553/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../86544/index.html">Evernote 3.5 Update for Windows</a></li>
<li><a href="../86545/index.html">The first meeting of the club DZ - MongoDB, Clojure, MapReduce and Azure</a></li>
<li><a href="../86547/index.html">Fur and Apple</a></li>
<li><a href="../86549/index.html">Search for colors from Yandex or "Buffalo Skin Color"</a></li>
<li><a href="../86550/index.html">Axillary fighters</a></li>
<li><a href="../86554/index.html">Fraud on the popularity of Opera Mini and Jimm</a></li>
<li><a href="../86555/index.html">Work on two screens - increasing productivity or dispersing attention?</a></li>
<li><a href="../86558/index.html">And how many hours a day do you,%% user_name% rest?</a></li>
<li><a href="../86563/index.html">Announcement Portal 2</a></li>
<li><a href="../86567/index.html">Habr broke</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>