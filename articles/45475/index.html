<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>PostgreSQL horizontal scaling using PL / Proxy.</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Very hard to start writing an article. Ie very hard to come up with an opening statement. I want to tell everything at once :) But no. We will be cons...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>PostgreSQL horizontal scaling using PL / Proxy.</h1><div class="post__text post__text-html js-mediator-article">  Very hard to start writing an article.  Ie very hard to come up with an opening statement.  I want to tell everything at once :) But no.  We will be consistent. <br>  I'll start with the fact that quite recently passed Highload ++ 2008 on which I was able to visit. <br>  I will say right away - the event was held at the highest level, there were many reports and all were very interesting. <br>  One of the most memorable presentations was Asko Oya's lecture on the infrastructure of database servers on Skype.  The lecture was more concerned with the various means by which such server performance is achieved. <br>  According to Asko, the Skype database will withstand even if all the inhabitants of the Earth want to connect to Skype in one moment. <br><br>  Arriving home really wanted to try it all live.  What I will tell you now.  Immediately make a reservation - the database structure for the test is taken from the example on the site of the developers themselves and naturally has nothing to do with the actual download. <br>  The article will describe how to distribute the load should be done after it is already hot and the base falls, but this is not quite so.  With the help of this article, I just want to prepare beginners and not experienced developers and at the same time get them to think about the fact that the possibility of load distribution between servers must be provided when designing the system.  And this will not be considered the very ‚Äúpremature optimization‚Äù about which they write so much and which they are so afraid of. <br><br>  <b>UPD: As habraiser <a href="https://habrahabr.ru/users/descentspb/" class="user_link">descentspb</a> correctly <a href="http://habrahabr.ru/blogs/postgresql/45475/">noted</a> , the article has an annoying error.</b>  <b>Due to my carelessness, I thought that the PgBouncer should be installed between the proxy and the client.</b>  <b>But, as it turned out, the problem that I solved with the help of PgBouncer will not be solved if you install it that way.</b>  <b>Correctly it is necessary to establish a bouncer between the nodes and the proxy.</b>  <b>Moreover, this is exactly what is recommended in the official manual on the PL / Proxy website.</b> <b><br></b>  <b>In any case, using PgBouncer as indicated in my diagram will also give a performance boost.</b>  <b>(Unload proxy).</b> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <a name="habracut"></a><br><br><h4>  1. Who is to blame? </h4><br>  So, if you are a developer and create something big and high enough, you will sooner or later encounter the fact that the database does not withstand the load.  Requests come a lot and the iron is simply not able to cope with them. <br>  Methods for solving this problem have already been discussed more than once; I will only give a list of what seems to me the most effective. <br><br>  - Optimize the code. <br>  - We increase the server capacity. <br>  - Caching (looking for articles on memcache tags). <br>  - We distribute the load between the servers. <br><br>  Let's stop on the last point. <br><br><h4>  2. What to do? </h4><br>  So the code is optimized, the server has no place to get the whole database in the cache and nevertheless it falls off from a single request.  It's time to do horizontal scaling. <br>  Oh yeah, I still haven't mentioned that PostgreSQL article.  And what are you still using MySQL?  Then we go to you :) <br>  In my humble opinion, if the project is really serious, then the base should be a bit more serious than MySQL.  All the more so for Postgres there are such wonderful scaling tools.  (Maybe for MySQL there? Waiting for the response article :)). <br><br><h4>  3. And what does it eat with? </h4><br>  PL / Proxy is a language for remotely calling functions on PostgreSQL database servers, as well as for partitioning data. <br>  The scheme of work is shown in the picture.  About PgBouncer I will tell below. <br><div style="text-align:center;"><img src="http://xmages.net/out.php/i53760_databasesvg.png" alt="image"></div><br>  Usually your application simply makes a database request.  In our case, the application also makes a normal database request.  It just calls not pure SQL-code, but a previously written function. <br>  Next, the database determines on which of the nodes the required data is located. <br>  And redirects the request to the desired server. <br>  The request is executed and returned to the main server, after which the data is returned to the application. <br><br>  Everything seems to be fine, but with a large number of requests, PL / Proxy creates a large <br>  the number of connections to the nodes, and this creates a new process, Postgres (fork), which does not affect performance very well.  To solve this problem you need PgBouncer. <br>  PgBouncer is ... mm ... how can I say this so as not to establish ... connections multiplexer.  It looks like a normal Postgres process, but inside it manages the request queues, which makes it possible to speed up the server times.  Of the thousands of requests received by PgBouncer to the database will reach only a few dozen. <br>  To evaluate the bonus from using this great tool, just look at the schedule for loading the database server on two sites before and after turning on PgBouncer.  The picture is taken from the performance of Postgres by Nikolay Samokhvalov. <br><div style="text-align:center;"><img src="http://xmages.net/out.php/i53763_pgbouncer.png" alt="image"></div><br><h4>  4. Give me these soft French buns. </h4><br><h5>  4.1. Installing PgBouncer </h5><br>  The installation process is not at all original: <br>  Downloading the package (as of this writing, the latest version was 1.2.3) <br>  <a href="http://pgfoundry.org/frs/%3Fgroup_id%3D1000258">pgfoundry.org/frs/?group_id=1000258</a> <br>  Unpack: <br> <code>#tar -xzvf pgbouncer-1.2.3.tgz <br>   : <br> #cd pgbouncer-1.2.3 <br> #./configure <br> #make <br> #make install</code> <br> <br>  Create a configuration file: <br> <code>/etc/pgbouncer/pgbouncer.ini <br> <br> [databases] <br> testdb = host=localhost port=5432 dbname=testdb <br> <br> [pgbouncer] <br> listen_port = 6543 <br> listen_addr = 127.0.0.1 <br> auth_type = md5 <br> auth_file = users.txt <br> logfile = /var/log/pgbouncer.log <br> pidfile = /var/run/pgbouncer/pgbouncer.pid <br> pool_mode = statement #     PL/Proxy      <br> admin_users = root <br></code> <br>  Create a file with authentication. <br> <code>/etc/pgbouncer/users.txt <br> "testdb_user" "testdb_user_password" <br></code> <br>  Run: <br> <code>/usr/local/bin/pgbouncer -d /etc/pgbouncer/pgbouncer.ini -u postgres</code> <br>  The -d switch indicates what needs to be started in daemon mode, and the -u switch indicates on whose behalf the pgbouncer process should be run. <br><br>  For gentoo users, a pleasant surprise in the form of a start script: <br> <code>/etc/init.d/pgbouncer <br> #!/sbin/runscript <br> <br> depend() { <br> need postgresql <br> use pgsql <br> } <br> start() { <br> ebegin "Starting Pgbouncer" <br> start-stop-daemon --start --background --exec /usr/local/bin/pgbouncer --chdir /etc/pgbouncer/ -- -d pgbouncer.ini -u postgres <br> eend $? "Failed to start Pgbouncer" <br> } <br> stop() { <br> ebegin "Stopping Pgbouncer" <br> start-stop-daemon --pidfile /var/run/pgbouncer/pgbouncer.pid --stop <br> eend $? "Failed to stop Pgbouncer" <br> } <br></code> <br><br>  Now, as a DSN in your application, you will need to change only the port to which you connect to the database from 5432 to 6543 and begin to compare server load before and after. <br><br><h5>  4.2 Installing Pl / Proxy </h5><br>  To conduct this experiment, we need 3 Postgres servers. <br>  One of them, let's call his proxy, will proxify requests for the other two. <br>  Let's call them node1 and node2. <br>  For pl / proxy to work correctly, it is recommended to use a number of nodes equal to powers of two. <br>  I assume that you have already installed Postgres. <br>  Install PL / Proxy on the proxy server. <br>  Downloading the latest version of pl / proxy: <a href="http://pgfoundry.org/frs/%3Fgroup_id%3D1000207">pgfoundry.org/frs/?group_id=1000207</a> <br>  As usual: <br>  #. / configure <br>  #make <br>  #make install <br>  This is where Postgres itself needs to be restarted. <br>  And now the fun begins. <br><br>  For the test, we will create a new proxytest database on each node: <br><blockquote> <code><font color="black"><font color="#0000ff">CREATE</font> <font color="#0000ff">DATABASE</font> proxytest <br> <font color="#0000ff">WITH</font> OWNER = postgres <br> ENCODING = <font color="#A31515">'UTF8'</font> ;</font> <br></code> </blockquote><br>  And inside this database we will create Schema with the name plproxy.  The official instructions did not have this item, but for some reason all the called functions tried to be called exactly like this: plproxy.functioname (). <br><blockquote> <code><font color="black"><font color="#0000ff">CREATE</font> <font color="#0000ff">SCHEMA</font> plproxy <br> <font color="#0000ff">AUTHORIZATION</font> postgres; <br> <font color="#0000ff">GRANT</font> <font color="#0000ff">ALL</font> <font color="#0000ff">ON</font> <font color="#0000ff">SCHEMA</font> plproxy <font color="#0000ff">TO</font> postgres; <br> <font color="#0000ff">GRANT</font> <font color="#0000ff">ALL</font> <font color="#0000ff">ON</font> <font color="#0000ff">SCHEMA</font> plproxy <font color="#0000ff">TO</font> <font color="#0000ff">public</font> ;</font> <br></code> </blockquote><br><br>  And add one label to it: <br><blockquote> <code><font color="black"><font color="#0000ff">CREATE</font> <font color="#0000ff">TABLE</font> plproxy.users <br> ( <br> user_id bigint <font color="#0000ff">NOT</font> <font color="#0000ff">NULL</font> <font color="#0000ff">DEFAULT</font> nextval( <font color="#A31515">'plproxy.user_id_seq'</font> ::regclass), <br> username <font color="#0000ff">character</font> <font color="#0000ff">varying</font> (255), <br> email <font color="#0000ff">character</font> <font color="#0000ff">varying</font> (255), <br> <font color="#0000ff">CONSTRAINT</font> users_pkey <font color="#0000ff">PRIMARY</font> <font color="#0000ff">KEY</font> (user_id) <br> ) <br> <font color="#0000ff">WITH</font> (OIDS= <font color="#0000ff">FALSE</font> ); <br> <font color="#0000ff">ALTER</font> <font color="#0000ff">TABLE</font> plproxy.users OWNER <font color="#0000ff">TO</font> postgres;</font> <br></code> </blockquote><br><br>  Now create a function to add data to these tables: <br><blockquote> <code><font color="black"><font color="#0000ff">CREATE</font> <font color="#0000ff">OR</font> REPLACE <font color="#0000ff">FUNCTION</font> plproxy.insert_user(i_username text, i_emailaddress   text) <br> <font color="#0000ff">RETURNS</font> <font color="#0000ff">integer</font> <font color="#0000ff">AS</font> <br> $BODY$ <br> <font color="#0000ff">INSERT</font> <font color="#0000ff">INTO</font> plproxy.users (username, email) <font color="#0000ff">VALUES</font> ($1,$2); <br> <font color="#0000ff">SELECT</font> 1; <br> $BODY$ <br> <font color="#0000ff">LANGUAGE</font> <font color="#A31515">'sql'</font> VOLATILE; <br> <font color="#0000ff">ALTER</font> <font color="#0000ff">FUNCTION</font> plproxy.insert_user(text, text) OWNER <font color="#0000ff">TO</font> postgres;</font> <br></code> </blockquote><br><br>  With the notes over.  Let's start setting up the server. <br>  As with all nodes, there should be a database on the main server (proxy): <br><blockquote> <code><font color="black"><font color="#0000ff">CREATE</font> <font color="#0000ff">DATABASE</font> proxytest <br> <font color="#0000ff">WITH</font> OWNER = postgres <br> ENCODING = <font color="#A31515">'UTF8'</font> ;</font> <br></code> </blockquote><br><br>  And the corresponding schema: <br><blockquote> <code><font color="black"><font color="#0000ff">CREATE</font> <font color="#0000ff">SCHEMA</font> plproxy <br> <font color="#0000ff">AUTHORIZATION</font> postgres; <br> <font color="#0000ff">GRANT</font> <font color="#0000ff">ALL</font> <font color="#0000ff">ON</font> <font color="#0000ff">SCHEMA</font> plproxy <font color="#0000ff">TO</font> postgres; <br> <font color="#0000ff">GRANT</font> <font color="#0000ff">ALL</font> <font color="#0000ff">ON</font> <font color="#0000ff">SCHEMA</font> plproxy <font color="#0000ff">TO</font> <font color="#0000ff">public</font> ;</font> <br></code> </blockquote><br><br>  Now you need to tell the server that this database is managed by pl / proxy: <br><blockquote> <code><font color="black"><font color="#0000ff">CREATE</font> <font color="#0000ff">OR</font> REPLACE <font color="#0000ff">FUNCTION</font> plproxy.plproxy_call_handler() <br> <font color="#0000ff">RETURNS</font> language_handler <font color="#0000ff">AS</font> <br> <font color="#A31515">'$libdir/plproxy'</font> , <font color="#A31515">'plproxy_call_handler'</font> <br> <font color="#0000ff">LANGUAGE</font> <font color="#A31515">'c'</font> VOLATILE <br> COST 1; <br> <font color="#0000ff">ALTER</font> <font color="#0000ff">FUNCTION</font> plproxy.plproxy_call_handler() OWNER <font color="#0000ff">TO</font> postgres; <br> <font color="#008000">-- language</font> <br> <font color="#0000ff">CREATE</font> <font color="#0000ff">LANGUAGE</font> plproxy HANDLER plproxy_call_handler;</font> <br></code> </blockquote><br><br>  Also, in order for the server to know where and which nodes it has, you need to create 3 service functions that pl / proxy will use in its work: <br><blockquote> <code><font color="black"><font color="#0000ff">CREATE</font> <font color="#0000ff">OR</font> REPLACE <font color="#0000ff">FUNCTION</font> plproxy.get_cluster_config( <font color="#0000ff">IN</font> cluster_name text, <font color="#0000ff">OUT</font> " <font color="#0000ff">key</font> " text, <font color="#0000ff">OUT</font> val text) <br> <font color="#0000ff">RETURNS</font> SETOF record <font color="#0000ff">AS</font> <br> $BODY$ <br> <font color="#0000ff">BEGIN</font> <br> <font color="#008000">-- lets use same config for all clusters</font> <br> <font color="#0000ff">key</font> := <font color="#A31515">'connection_lifetime'</font> ; <br> val := 30*60; <font color="#008000">-- 30m</font> <br> <font color="#0000ff">RETURN</font> <font color="#0000ff">NEXT</font> ; <br> <font color="#0000ff">RETURN</font> ; <br> <font color="#0000ff">END</font> ; <br> $BODY$ <br> <font color="#0000ff">LANGUAGE</font> <font color="#A31515">'plpgsql'</font> VOLATILE <br> COST 100 <br> <font color="#0000ff">ROWS</font> 1000; <br> <font color="#0000ff">ALTER</font> <font color="#0000ff">FUNCTION</font> plproxy.get_cluster_config(text) OWNER <font color="#0000ff">TO</font> postgres;</font> <br></code> </blockquote><br><br>  An important function whose code will need to be corrected.  It will need to specify the DSN node: <br><blockquote> <code><font color="black">REATE <font color="#0000ff">OR</font> REPLACE <font color="#0000ff">FUNCTION</font> plproxy.get_cluster_partitions(cluster_name text) <br> <font color="#0000ff">RETURNS</font> SETOF text <font color="#0000ff">AS</font> <br> $BODY$ <br> <font color="#0000ff">BEGIN</font> <br> <font color="#0000ff">IF</font> cluster_name = <font color="#A31515">'clustertest'</font> <font color="#0000ff">THEN</font> <br> <font color="#0000ff">RETURN</font> <font color="#0000ff">NEXT</font> <font color="#A31515">'dbname=proxytest host=node1 user=postgres'</font> ; <br> <font color="#0000ff">RETURN</font> <font color="#0000ff">NEXT</font> <font color="#A31515">'dbname=proxytest host=node2 user=postgres'</font> ; <br> <font color="#0000ff">RETURN</font> ; <br> <font color="#0000ff">END</font> <font color="#0000ff">IF</font> ; <br> RAISE <font color="#0000ff">EXCEPTION</font> <font color="#A31515">'Unknown cluster'</font> ; <br> <font color="#0000ff">END</font> ; <br> $BODY$ <br> <font color="#0000ff">LANGUAGE</font> <font color="#A31515">'plpgsql'</font> VOLATILE <br> COST 100 <br> <font color="#0000ff">ROWS</font> 1000; <br> <font color="#0000ff">ALTER</font> <font color="#0000ff">FUNCTION</font> plproxy.get_cluster_partitions(text) OWNER <font color="#0000ff">TO</font> postgres;</font> <br></code> </blockquote><br><br>  And last: <br><blockquote> <code><font color="black"><font color="#0000ff">CREATE</font> <font color="#0000ff">OR</font> REPLACE <font color="#0000ff">FUNCTION</font> plproxy.get_cluster_version(cluster_name text) <br> <font color="#0000ff">RETURNS</font> <font color="#0000ff">integer</font> <font color="#0000ff">AS</font> <br> $BODY$ <br> <font color="#0000ff">BEGIN</font> <br> <font color="#0000ff">IF</font> cluster_name = <font color="#A31515">'clustertest'</font> <font color="#0000ff">THEN</font> <br> <font color="#0000ff">RETURN</font> 1; <br> <font color="#0000ff">END</font> <font color="#0000ff">IF</font> ; <br> RAISE <font color="#0000ff">EXCEPTION</font> <font color="#A31515">'Unknown cluster'</font> ; <br> <font color="#0000ff">END</font> ; <br> $BODY$ <br> <font color="#0000ff">LANGUAGE</font> <font color="#A31515">'plpgsql'</font> VOLATILE <br> COST 100; <br> <font color="#0000ff">ALTER</font> <font color="#0000ff">FUNCTION</font> plproxy.get_cluster_version(text) OWNER <font color="#0000ff">TO</font> postgres;</font> <br></code> </blockquote><br><br>  Well, actually the most important function that will be called directly in the application: <br><blockquote> <code><font color="black"><font color="#0000ff">CREATE</font> <font color="#0000ff">OR</font> REPLACE <font color="#0000ff">FUNCTION</font> plproxy.insert_user(i_username text, i_emailaddress text) <br> <font color="#0000ff">RETURNS</font> <font color="#0000ff">integer</font> <font color="#0000ff">AS</font> <br> $BODY$ <br> CLUSTER <font color="#A31515">'clustertest'</font> ; <br> RUN <font color="#0000ff">ON</font> hashtext(i_username); <br> $BODY$ <br> <font color="#0000ff">LANGUAGE</font> <font color="#A31515">'plproxy'</font> VOLATILE <br> COST 100; <br> <font color="#0000ff">ALTER</font> <font color="#0000ff">FUNCTION</font> plproxy.insert_user(text, text) OWNER <font color="#0000ff">TO</font> postgres;</font> <br></code> </blockquote><br><br>  Questions on the function code are accepted in the comments, but please note that I am not a Postgres guru, but just a student. <br><br>  And now we test!  :) <br><br>  We connect to the proxy server on port 6543 (we will immediately work via PgBouncer). <br>  And we enter the data into the database: <br><blockquote> <code><font color="black"><font color="#0000ff">SELECT</font> insert_user( <font color="#A31515">'Sven'</font> , <font color="#A31515">'sven@somewhere.com'</font> ); <br> <font color="#0000ff">SELECT</font> insert_user( <font color="#A31515">'Marko'</font> , <font color="#A31515">'marko@somewhere.com'</font> ); <br> <font color="#0000ff">SELECT</font> insert_user( <font color="#A31515">'Steve'</font> , <font color="#A31515">'steve@somewhere.com'</font> );</font> <br></code> </blockquote><br><br>  Now you can connect to each of the nodes and if you did everything correctly and without errors, then the first two entries will be on node1 node, and the third entry will be on node2 node. <br><br>  We try to extract data. <br>  To do this, we write a new server function: <br><blockquote> <code><font color="black"><font color="#0000ff">CREATE</font> <font color="#0000ff">OR</font> REPLACE <font color="#0000ff">FUNCTION</font> plproxy.get_user_email(i_username text) <br> <font color="#0000ff">RETURNS</font> SETOF text <font color="#0000ff">AS</font> <br> $BODY$ <br> CLUSTER <font color="#A31515">'clustertest'</font> ; <br> RUN <font color="#0000ff">ON</font> hashtext(i_username) ; <br> <font color="#0000ff">SELECT</font> email <font color="#0000ff">FROM</font> plproxy.users <font color="#0000ff">WHERE</font> username = i_username; <br> $BODY$ <br> <font color="#0000ff">LANGUAGE</font> <font color="#A31515">'plproxy'</font> VOLATILE <br> COST 100 <br> <font color="#0000ff">ROWS</font> 1000; <br> <font color="#0000ff">ALTER</font> <font color="#0000ff">FUNCTION</font> plproxy.get_user_email(text) OWNER <font color="#0000ff">TO</font> postgres; <br></font> <br></code> </blockquote><br><br>  And try to call it: <br><blockquote> <code><font color="black"><font color="#0000ff">select</font> plproxy.get_user_email( <font color="#A31515">'Steve'</font> );</font></code> </blockquote> <br><br>  In other words, I did it all. <br><br><h4>  5.And why are you so poor once so smart? </h4><br>  As you can see on the test example, there is nothing difficult in working with pl / proxy.  But, I think everyone who was able to read this line up already understood that in real life, things are not so simple. <br>  Imagine you have 16 nodes.  Same it is necessary to synchronize somehow the code of functions.  And what if the error creeps in - how to fix it quickly? <br>  This question was also asked at the conference, to which Asko replied that the corresponding funds have already been implemented within Skype itself, but are not yet ready to give them to the opensource community. <br>  The second problem that God forbid touches you when developing such a system is the problem of data redistribution at the moment when we want to add another node to the cluster. <br>  This large-scale operation will have to be planned very carefully, having prepared all the servers in advance, having entered the data and then at one moment replacing the function code get_cluster_partitions. <br><br><h4>  6. Additional materials </h4><br>  Projects <a href="https://developer.skype.com/SkypeGarage/DbProjects/PlProxy">PlProxy</a> and <a href="https://developer.skype.com/SkypeGarage/DbProjects/PgBouncer">PgBouncer</a> on the Skype developer site. <br><br>  <a href="http://highload.ru/papers2008/7171.html">Asco's presentation on Highload ++</a> <br>  <a href="http://highload.ru/papers2008/7659.html">Postgres performance</a> Nikolay Samokhvalov (Postgresmen) <br><br><h4>  7. Bonus for attentive </h4><br>  Already after I published the article I found one mistake in it and one defect. <br>  I will describe here as it is difficult to edit an already written article. <br>  1) In tables it uses a sequence named user_id_seq.  But the SQL code for it is not given anywhere.  Accordingly, if someone will just copy-paste the code, nothing will come of it.  Correcting: <br><blockquote> <code><font color="black"><font color="#0000ff">CREATE</font> <font color="#0000ff">SEQUENCE</font> plproxy.user_id_seq <br> INCREMENT 1 <br> MINVALUE 0 <br> MAXVALUE 9223372036854775807 <br> <font color="#0000ff">START</font> 1 <br> CACHE 1; <br> <font color="#0000ff">ALTER</font> <font color="#0000ff">TABLE</font> plproxy.user_id_seq OWNER <font color="#0000ff">TO</font> postgres; <br></font> <br></code> </blockquote><br>  2) During the insertion of data into the database, a sequence is generated for the user_id field.  However, these sequences are two.  And each works on its own node.  Which will inevitably lead to two different users having the same user_id. <br>  Accordingly, the insert_user function must be fixed in such a way that the new user_id would be taken from the sequence hosted on the proxy server and not on the nodes.  In this way, duplication in the user_id field can be avoided. <br><br>  ZY: All SQL code is highlighted in <a href="http://source.virtser.net/default.aspx">Source Code Highliter</a> </div><p>Source: <a href="https://habr.com/ru/post/45475/">https://habr.com/ru/post/45475/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../45463/index.html">Too easy.</a></li>
<li><a href="../45465/index.html">Best startups in November</a></li>
<li><a href="../45467/index.html">How to promote your video on YouTube</a></li>
<li><a href="../45468/index.html">US Army buys new game</a></li>
<li><a href="../45473/index.html">Multiplication table</a></li>
<li><a href="../45476/index.html">My city.ru - a social network in an urban environment</a></li>
<li><a href="../45477/index.html">What kind of Internet startup students can come up with in one hour?</a></li>
<li><a href="../45478/index.html">In a galaxy far far away VTB24</a></li>
<li><a href="../45480/index.html">Automate client optimization</a></li>
<li><a href="../45482/index.html">HTTP_StaticMerger - automatic gluing of CSS and JS files for quick loading</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>