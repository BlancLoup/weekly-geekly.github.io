<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>The whole truth about the RTOS. Article # 21. Mailboxes: Introduction and Basic Services</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Mailboxes have been mentioned in a previous article (# 5). They are the second most simple, after signals, method of inter-task communication, which i...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>The whole truth about the RTOS. Article # 21. Mailboxes: Introduction and Basic Services</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/pj/yd/r0/pjydr0sj2zrtqop5hhxum0q2vki.jpeg"><br><br>  Mailboxes have been mentioned in a previous article (# 5).  They are the second most simple, after signals, method of inter-task communication, which is supported in the Nucleus SE, and provide a low-cost and flexible way to transfer simple messages between tasks. <br><a name="habracut"></a><br>  Previous articles in the series: <br>  <a href="https://habr.com/post/429588/">Article # 20.</a>  <a href="https://habr.com/post/429588/">Semaphores: helper services and data structures</a> <br>  <a href="https://habr.com/post/429156/">Article # 19.</a>  <a href="https://habr.com/post/429156/">Semaphores: introduction and basic services</a> <br>  <a href="https://habr.com/post/428890/">Article # 18.</a>  <a href="https://habr.com/post/428890/">Event flag groups: helper services and data structures</a> <br>  <a href="https://habr.com/post/428131/">Article # 17.</a>  <a href="https://habr.com/post/428131/">Event flag groups: introduction and basic services</a> <br>  <a href="https://habr.com/post/427439/">Article # 16.</a>  <a href="https://habr.com/post/427439/">Signals</a> <br>  <a href="https://habr.com/post/426477/">Article # 15.</a>  <a href="https://habr.com/post/426477/">Memory sections: services and data structures</a> <br>  <a href="https://habr.com/post/426425/">Article # 14.</a>  <a href="https://habr.com/post/426425/">Memory sections: introduction and basic services</a> <br>  <a href="https://habr.com/post/425353/">Article # 13.</a>  <a href="https://habr.com/post/425353/">Task data structures and unsupported API calls</a> <br>  <a href="https://habr.com/post/424713/">Article # 12.</a>  <a href="https://habr.com/post/424713/">Task Services</a> <br>  <a href="https://habr.com/post/424481/">Article # 11.</a>  <a href="https://habr.com/post/424481/">Tasks: configuration and introduction to the API</a> <br>  <a href="https://habr.com/post/423967/">Article # 10.</a>  <a href="https://habr.com/post/423967/">Scheduler: additional features and context preservation</a> <br>  <a href="https://habr.com/post/422615/">Article # 9.</a>  <a href="https://habr.com/post/422615/">Scheduler: implementation</a> <br>  <a href="https://habr.com/post/422617/">Article # 8.</a>  <a href="https://habr.com/post/422617/">Nucleus SE: Inside and Deployment</a> <br>  <a href="https://habr.com/post/418601/">Article # 7.</a>  <a href="https://habr.com/post/418601/">Nucleus SE: introduction</a> <br>  <a href="https://habr.com/post/418677/">Article # 6.</a>  <a href="https://habr.com/post/418677/">Other RTOS services</a> <br>  <a href="https://habr.com/post/415429/">Article # 5.</a>  <a href="https://habr.com/post/415429/">Interaction between tasks and synchronization</a> <br>  <a href="https://habr.com/post/415427/">Article # 4.</a>  <a href="https://habr.com/post/415427/">Tasks, context switching and interrupts</a> <br>  <a href="https://habr.com/post/415329/">Article # 3.</a>  <a href="https://habr.com/post/415329/">Tasks and planning</a> <br>  <a href="https://habr.com/post/414093/">Article # 2.</a>  <a href="https://habr.com/post/414093/">RTOS: Structure and Real Time</a> <a href="https://habr.com/post/414093/"><br></a>  <a href="https://habr.com/post/414093/">Article # 1.</a>  <a href="https://habr.com/post/414093/">RTOS: introduction.</a> <a href="https://habr.com/post/414093/"><br></a> <br><h2>  Mailbox Usage </h2><br>  In Nucleus SE, mailboxes are defined during the build phase.  Up to 16 mailboxes can exist in an application.  If the application does not have mailboxes, the service call code and data structures associated with the mailboxes will not be included in the application. <br><br>  A mailbox is simply a place to store data, the size of which is enough to store a variable of type <b>ADDR</b> and secure access to which is controlled so that several tasks can use it.  The task can send data to the mailbox.  As a result, the box will become full, and no task will be able to send data to it until a task completes the mailbox read operation or until the box is cleared.  Attempting to send data to a full mailbox or attempting to read an empty mailbox will result in an error or task suspension, depending on the selected API call settings and the configuration of the Nucleus SE. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  Mailboxes and Queues </h2><br>  In some implementations of the OS, mailboxes are not implemented, and alternatively, it is proposed to use a queue.  This sounds logical, since such a queue will provide the same functionality as the mailbox.  However, a queue is a more complex data structure and carries much more service data, code, and has a longer service time. <br><br>  In Nucleus SE, as in Nucleus RTOS, you can select any of these types of objects. <br>  If your application has several queues and one mailbox, then it makes sense to consider replacing the mailbox with a queue.  This will slightly increase the amount of service data, but will get rid of all the API code associated with mailboxes.  Alternatively, you can configure the application with both methods and compare the data volume and performance. <br><br>  Queues will be covered in future articles. <br><br><h2>  Mailbox Setup </h2><br><h3>  Number of mailboxes </h3><br>  As with most Nucleus SE objects, mailbox configuration is mainly set by the <b>#define</b> directives in the <b>nuse_config.h</b> file.  The main parameter is <b>NUSE_MAILBOX_NUMBER</b> , which determines the number of mailboxes in the application.  The default value is zero (that is, there are no mailboxes) and can take values ‚Äã‚Äãup to 16. An incorrect value will cause a compile-time error, which will be generated by checking in <b>nuse_config_check.h</b> (it is included in the <b>nuse_config.c</b> file and compiled with it ), which will trigger the <b>#error</b> directive. <br><br>  The choice of a non-zero value is the main activator for mailboxes.  This parameter is used when defining data structures and their size depends on its value (for more details, in the next article).  In addition, a non-zero value activates the API settings. <br><br><h3>  Activate API calls </h3><br>  Each API function (service call) in the Nucleus SE is activated by the <b>#define</b> directive in the <b>nuse_config.h</b> file.  For mailboxes, these directives are: <br><br><pre><code class="plaintext hljs">NUSE_MAILBOX_SEND NUSE_MAILBOX_RECEIVE NUSE_MAILBOX_RESET NUSE_MAILBOX_INFORMATION NUSE_MAILBOX_COUNT</code> </pre> <br>  By default, they are assigned the value <b>FALSE</b> , thus disabling all service calls and blocking the inclusion of the code implementing them.  To set up mailboxes in the application, you need to select the necessary API calls and set them to <b>TRUE</b> . <br><br>  Below is a section of code from the file <b>nuse_config.h</b> . <br><br><pre> <code class="plaintext hljs">/* Number of mailboxes in the system - 0-16 */ #define NUSE_MAILBOX_NUMBER 0 /* Service call enablers: */ #define NUSE_MAILBOX_SEND FALSE #define NUSE_MAILBOX_RECEIVE FALSE #define NUSE_MAILBOX_RESET FALSE #define NUSE_MAILBOX_INFORMATION FALSE #define NUSE_MAILBOX_COUNT FALSE</code> </pre><br>  If the mailbox API function is activated, and there are no mailboxes in the application (except <b>NUSE_Mailbox_Count ()</b> , which is always allowed), an error occurs during compilation.  If your code uses an API call that has not been activated, a build error will occur because the implementation code was not included in the application. <br><br><h2>  Mailbox Calls </h2><br>  Nucleus RTOS supports nine service calls that are associated with mailboxes and provide the following functionality: <br><br><ul><li>  Sending messages to the mailbox.  Nucleus SE is implemented in the <b>NUSE_Mailbox_Send ()</b> function. </li><li>  Reading a message from the mailbox.  Nucleus SE is implemented as a <b>NUSE_Mailbox_Receive ()</b> function. </li><li>  Mailbox recovery to unused state with the release of all suspended tasks (reset).  In Nucleus SE, implemented in <b>NUSE_Mailbox_Reset ()</b> . </li><li>  Providing information about a specific mailbox.  In Nucleus SE, implemented in <b>NUSE_Mailbox_Information ()</b> . </li><li>  Return the number of currently configured mailboxes in the application.  In Nucleus SE, it is implemented in <b>NUSE_Mailbox_Count ()</b> . </li><li>  Add a new mailbox (create).  Nucleus SE is not implemented. </li><li>  Delete mailbox.  Nucleus SE is not implemented. </li><li>  Return pointers to all mailboxes in the application.  Nucleus SE is not implemented. </li><li>  Sending a message to all tasks suspended on the mailbox (broadcast).  Nucleus SE is not implemented. </li></ul><br>  Consider in detail the implementation of each service call. <br><br><h2>  Utility calls read and write mailboxes </h2><br>  The basic operations that can be performed on mailboxes are writing and reading data (sending and receiving).  Nucleus RTOS and Nucleus SE provide two basic API calls for these operations, which will be described below. <br><br><h3>  Mailbox Record </h3><br>  Calling the Nucleus RTOS API to write to the mailbox is very flexible, which allows you to suspend the task implicitly or with a timeout if the operation cannot be completed immediately (for example, when you try to write to the full mailbox).  Nucleus SE provides a similar service call, only pausing the task is optional, and the timeout is not implemented. <br><br>  Nucleus RTOS also offers a service call for translating data to a mailbox, this call is not supported in Nucleus SE and will be described in the ‚ÄúUnrealized API calls‚Äù section in the next article. <br><br>  <b><i>Call to write to the mailbox in the Nucleus RTOS</i></b> <br>  Service Call Prototype: <br>  <b>STATUS NU_Send_To_Mailbox (NU_MAILBOX * mailbox, VOID * message, UNSIGNED suspend);</b> <br><br>  Options: <br>  <b>mailbox</b> - pointer to the mailbox; <br>  <b>message</b> is a pointer to the message to be sent, consisting of four <b>unsigned</b> elements; <br>  <b>suspend</b> - the specification of the suspension of the task, can be <b>NU_NO_SUSPEND</b> , <b>NU_SUSPEND,</b> or the timeout value. <br><br>  Return value: <br>  <b>NU_SUCCESS</b> - the call was successfully completed; <br>  <b>NU_INVALID_MAILBOX</b> - invalid mailbox pointer; <br>  <b>NU_INVALID_POINTER</b> - null pointer to the message ( <b>NULL</b> ); <br>  <b>NU_INVALID_SUSPEND</b> - an attempt to pause from a <b>thread that</b> is not associated with the task; <br>  <b>NU_MAILBOX_FULL</b> - the mailbox is full, and the type of suspension is not specified; <br>  <b>NU_TIMEOUT</b> ‚Äî the mailbox is still full, even after being suspended for a specified period; <br>  <b>NU_MAILBOX_DELETED</b> - the mailbox was deleted while the task was suspended; <br>  <b>NU_MAILBOX_WAS_RESET</b> - the mailbox was reset while the task was suspended. <br><br>  <b><i>Call to write to the mailbox in Nucleus SE</i></b> <br>  This API call supports the core Nucleus RTOS API. <br><br>  Service Call Prototype: <br>  <b>STATUS NUSE_Mailbox_Send (NUSE_MAILBOX mailbox, ADDR * message, U8 suspend);</b> <br><br>  Options: <br>  <b>mailbox</b> - <b>mailbox</b> index; <br>  <b>message</b> - a pointer to the message to be sent, is a single variable of type <b>ADDR</b> ; <br>  <b>suspend</b> - task suspension specification, can be <b>NUSE_NO_SUSPEND</b> or <b>NUSE_SUSPEND</b> . <br><br>  Return value: <br>  <b>NUSE_SUCCESS</b> - the call was successfully completed; <br>  <b>NUSE_INVALID_MAILBOX</b> - invalid mailbox index; <br>  <b>NUSE_INVALID_POINTER</b> - null pointer to the message ( <b>NULL</b> ); <br>  <b>NUSE_INVALID_SUSPEND</b> - an attempt to suspend from a <b>thread that</b> is not associated with the task or when the API call blocking functionality is deactivated <br>  <b>NUSE_MAILBOX_FULL</b> - the mailbox is full, and the type of suspension is not specified; <br>  <b>NUSE_MAILBOX_WAS_RESET</b> - the mailbox was reset while the task was suspended. <br><br>  <b><i>Writing to the mailbox in Nucleus SE</i></b> <br>  The code variant of the <b>NUSE_Mailbox_Send ()</b> API function (after checking the parameters) is selected using conditional compilation, depending on whether support for API calls is activated to block (suspend tasks) or not.  Consider both options. <br><br>  If task blocking is disabled, the logic of this API call is quite simple, and the code does not require an explanation: <br><br><pre> <code class="plaintext hljs">if (NUSE_Mailbox_Status[mailbox]) /* mailbox full */ { return_value = NUSE_MAILBOX_FULL; } else /* mailbox empty */ { NUSE_Mailbox_Data[mailbox] = *message; NUSE_Mailbox_Status[mailbox] = TRUE; return_value = NUSE_SUCCESS; }</code> </pre><br>  The message is stored in the corresponding <b>NUSE_Mailbox_Data []</b> element, and the mailbox is marked as used. <br><br>  If task lock is activated, the code becomes more complex: <br><br><pre> <code class="plaintext hljs">do { if (!NUSE_Mailbox_Status[mailbox]) /* mailbox empty */ { NUSE_Mailbox_Data[mailbox] = *message; NUSE_Mailbox_Status[mailbox] = TRUE; if (NUSE_Mailbox_Blocking_Count[mailbox] != 0) { U8 index; /* check whether a task is blocked */ /* on this mailbox */ NUSE_Mailbox_Blocking_Count[mailbox]--; for (index=0; index&lt;NUSE_TASK_NUMBER; index++) { if ((LONIB(NUSE_Task_Status[index]) == NUSE_MAILBOX_SUSPEND) &amp;&amp; (HINIB(NUSE_Task_Status[index]) == mailbox)) { NUSE_Task_Blocking_Return[index] = NUSE_SUCCESS; NUSE_Wake_Task(index); break; } } } return_value = NUSE_SUCCESS; suspend = NUSE_NO_SUSPEND; } else /* mailbox full */ { if (suspend == NUSE_NO_SUSPEND) { return_value = NUSE_MAILBOX_FULL; } else { /* block task */ NUSE_Mailbox_Blocking_Count[mailbox]++; NUSE_Suspend_Task(NUSE_Task_Active, (mailbox &lt;&lt; 4) | NUSE_MAILBOX_SUSPEND); return_value = NUSE_Task_Blocking_Return[NUSE_Task_Active]; if (return_value != NUSE_SUCCESS) { suspend = NUSE_NO_SUSPEND; } } } } while (suspend == NUSE_SUSPEND);</code> </pre><br>  Some explanations may be helpful. <br><br>  The code is enclosed in a <b>do ... while loop</b> , which runs until the <b>suspend</b> parameter is <b>NUSE_SUSPEND</b> . <br><br>  If the mailbox is empty, the message is recorded, and the mailbox status is changed to indicate that it is full.  Checks for suspended tasks (that are waiting to be read) on this mailbox.  If there are such tasks, the first one resumes.  The variable suspend is assigned the value <b>NUSE_NO_SUSPEND</b> , and the API call ends and returns <b>NUSE_SUCCESS</b> . <br><br>  If the mailbox is full and suspend is <b>NUSE_NO_SUSPEND</b> , the API call will return <b>NUSE_MAILBOX_FULL</b> .  If suspend is <b>NUSE_SUSPEND</b> , the task is suspended.  After the function completes (for example, when the task is resumed), if the return value is <b>NUSE_SUCCESS</b> (which indicates that the task was resumed because the message was read, and not that the mailbox was reset), the cycle starts from the beginning. <br><br><h3>  Reading mailbox </h3><br>  The Nucleus RTOS API service call for reading a mailbox is very flexible and allows you to suspend tasks implicitly or with a timeout if the operation cannot be completed immediately (for example, when reading from an empty mailbox).  Nucleus SE provides a similar service, only task suspension is optional, and timeout is not implemented. <br><br>  <b><i>Call to read the mailbox in the Nucleus RTOS</i></b> <br>  Service Call Prototype: <br>  <b>STATUS NU_Receive_From_Mailbox (NU_MAILBOX * mailbox, VOID * message, UNSIGNED suspend);</b> <br><br>  Options: <br>  <b>mailbox</b> - pointer to the mailbox control unit provided by the user; <br>  <b>message</b> is a pointer to the repository for the received message, which has a size equal to four <b>unsigned</b> variables; <br>  <b>suspend</b> - task suspension specification, can be <b>NUSE_NO_SUSPEND</b> , <b>NUSE_SUSPEND,</b> or timeout value. <br><br>  Return value: <br>  <b>NU_SUCCESS</b> - the call was successfully completed; <br>  <b>NU_INVALID_MAILBOX</b> - invalid mailbox pointer; <br>  <b>NU_INVALID_POINTER</b> - null pointer to the message ( <b>NULL</b> ); <br>  <b>NU_INVALID_SUSPEND</b> ‚Äî attempt to suspend from an incorrect stream (not associated with a task stream); <br>  <b>NU_MAILBOX_EMPTY</b> - the mailbox is empty and the type of suspension has not been specified; <br>  <b>NU_TIMEOUT</b> - the mailbox is still empty, even after pausing the task for the specified timeout value; <br>  <b>NU_MAILBOX_DELETED</b> - the mailbox was deleted while the task was suspended; <br>  <b>NU_MAILBOX_WAS_RESET</b> - the mailbox was reset while the task was suspended. <br><br>  <b><i>Call to read mailbox in Nucleus SE</i></b> <br>  This API call supports the core Nucleus RTOS API. <br><br>  Service Call Prototype: <br>  <b>STATUS NUSE_Mailbox_Receive (NUSE_MAILBOX mailbox, ADDR * message, U8 suspend);</b> <br><br>  Options: <br>  <b>mailbox</b> - <b>mailbox</b> index; <br>  <b>message</b> - a pointer to the repository of the received message, it is a single variable of the type <b>ADDR</b> ; <br>  <b>suspend</b> - task suspension specification, can be <b>NUSE_NO_SUSPEND</b> or <b>NUSE_SUSPEND</b> . <br><br>  Return value: <br>  <b>NUSE_SUCCESS</b> - the call was successfully completed; <br>  <b>NUSE_INVALID_MAILBOX</b> - invalid mailbox index; <br>  <b>NUSE_INDALID_POINTER</b> - null pointer to the message ( <b>NULL</b> ); <br>  <b>NUSE_INVALID_SUSPEND</b> ‚Äî attempt to pause from an incorrect thread or when API calls to block tasks are disabled; <br>  <b>NUSE_MAILBOX_EMPTY</b> - the mailbox is empty and the type of task suspension is not specified; <br>  <b>NUSE_MAILBOX_WAS_RESET</b> - the mailbox was reset while the task was suspended. <br><br>  <b><i>Implementing Reading Mailboxes in Nucleus SE</i></b> <br>  The code variant of the <b>NUSE_Mailbox_Receive ()</b> API function (after checking the parameters) is selected using conditional compilation, depending on whether API calls are activated for blocking (pausing tasks) or not.  We will consider both options. <br><br>  If task blocking is disabled, the logic of this API call is quite simple, and the code does not require an explanation: <br><br><pre> <code class="plaintext hljs">if (!NUSE_Mailbox_Status[mailbox]) /* mailbox empty */ { return_value = NUSE_MAILBOX_EMPTY; } else { /* mailbox full */ *message = NUSE_Mailbox_Data[mailbox]; NUSE_Mailbox_Status[mailbox] = FALSE; return_value = NUSE_SUCCESS; }</code> </pre><br>  The message is read from the corresponding <b>NUSE_Mailbox_Data []</b> element, and the mailbox is marked as empty. <br><br>  If task lock is activated, the code becomes more complex: <br><br><pre> <code class="plaintext hljs">do { if (NUSE_Mailbox_Status[mailbox]) /* mailbox full */ { *message = NUSE_Mailbox_Data[mailbox]; NUSE_Mailbox_Status[mailbox] = FALSE; if (NUSE_Mailbox_Blocking_Count[mailbox] != 0) { U8 index; /* check whether a task is blocked */ /* on this mailbox */ NUSE_Mailbox_Blocking_Count[mailbox]--; for (index=0; index&lt;NUSE_TASK_NUMBER; index++) { if ((LONIB(NUSE_Task_Status[index]) == NUSE_MAILBOX_SUSPEND) &amp;&amp; (HINIB(NUSE_Task_Status[index]) == mailbox)) { NUSE_Task_Blocking_Return[index] = NUSE_SUCCESS; NUSE_Wake_Task(index); break; } } } return_value = NUSE_SUCCESS; suspend = NUSE_NO_SUSPEND; } else /* mailbox empty */ { if (suspend == NUSE_NO_SUSPEND) { return_value = NUSE_MAILBOX_EMPTY; } else { /* block task */ NUSE_Mailbox_Blocking_Count[mailbox]++; NUSE_Suspend_Task(NUSE_Task_Active, (mailbox &lt;&lt; 4) | NUSE_MAILBOX_SUSPEND); return_value = NUSE_Task_Blocking_Return[NUSE_Task_Active]; if (return_value != NUSE_SUCCESS) { suspend = NUSE_NO_SUSPEND; } } } } while (suspend == NUSE_SUSPEND);</code> </pre><br>  Some explanations may be helpful. <br><br>  The code is enclosed in a <b>do ... while loop</b> , which runs until the <b>suspend</b> parameter is <b>NUSE_SUSPEND</b> . <br><br>  If the mailbox is full, the stored message is returned, and the mailbox status is changed to indicate that it is empty.  Checks for suspended tasks (which are waiting for recording) on ‚Äã‚Äãthis mailbox.  If there are such tasks, the first one resumes.  The variable suspend is assigned the value <b>NUSE_NO_SUSPEND</b> , and the API call ends and returns <b>NUSE_SUCCESS</b> . <br><br>  If the mailbox is empty and the <b>suspend</b> parameter is <b>NUSE_NO_SUSPEND</b> , the API call returns <b>NUSE_MAILBOX_EMPTY</b> .  If suspend is <b>NUSE_SUSPEND</b> , the task is suspended.  If at the end of the call the return value is <b>NUSE_SUCCESS</b> , which indicates that the task was resumed because the message was sent (and not that the mailbox was reset), the cycle starts from the beginning. <br><br>  The next article will look at additional API calls related to mailboxes, as well as the corresponding data structures. <br><br>  <b>About the author:</b> Colin Walls has been working in the electronics industry for more than thirty years, spending a significant amount of time on embedded software.  He is now an embedded software engineer in Mentor Embedded (a division of Mentor Graphics).  Colin Walls often speaks at conferences and seminars, author of numerous technical articles and two books on embedded software.  Lives in the UK.  <a href="http://blogs.mentor.com/colinwalls">Colin's</a> professional <a href="http://blogs.mentor.com/colinwalls">blog</a> , e-mail: colin_walls@mentor.com. </div><p>Source: <a href="https://habr.com/ru/post/430856/">https://habr.com/ru/post/430856/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../430844/index.html">How to choose a battery for UPS</a></li>
<li><a href="../430846/index.html">What's New: Details on the implementation of the new Zen 2 architecture have become known</a></li>
<li><a href="../430850/index.html">Apple Metal in MAPS.ME</a></li>
<li><a href="../430852/index.html">Consistency and ACID guarantees in distributed storage systems</a></li>
<li><a href="../430854/index.html">‚ÄúJS is becoming more mature‚Äù: interview with the HolyJS 2018 Moscow program committee</a></li>
<li><a href="../430860/index.html">Download, save and view PDF in Swift</a></li>
<li><a href="../430862/index.html">"Monsters in games - how to make a player hate you"</a></li>
<li><a href="../430864/index.html">Matches is not a toy?</a></li>
<li><a href="../430866/index.html">Beijing will introduce a social rating for residents of the city in 2020</a></li>
<li><a href="../430868/index.html">What you need to remember when buying NGFW? Check list</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>