<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Uninvented story about performance, reflection and java.lang.Boolean</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Once, in the icy winter season (although it was March in the yard) I needed to dig in a heap (of what is called a heap dump, and not what you thought)...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Uninvented story about performance, reflection and java.lang.Boolean</h1><div class="post__text post__text-html js-mediator-article"><p>  Once, in the icy winter season (although it was March in the yard) I needed to dig in a heap (of what is called a heap dump, and not what you thought).  Having uncovered VisualVM, I opened the required file and went to the OQL console.  While the court is the case, my attention was drawn to requests that are available out of the box.  One of them, entitled "Too many Booleans", was especially conspicuous.  In his description in English and white it says: </p><br><blockquote>  Check if there is a boolean on the heap (only Boolean.TRUE and Boolean.FALSE are necessary). </blockquote><p>  Feel right?  Here I am penetrated. </p><a name="habracut"></a><br><p> Where can the extra "big" <code>Boolean</code> come from if Java has been able to wrap simple types in wrappers on its own long ago and vice versa?  If the code is written correctly, all the <code>Boolean.TRUE/Boolean.FALSE</code> <code>boolean</code> to the object will use <code>Boolean.TRUE/Boolean.FALSE</code> , created at the first call to the <code>java.lang.Boolean</code> class.  This is where the request comes from, which I noticed: </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> toHtml(a) + <span class="hljs-string"><span class="hljs-string">" = "</span></span> + a.value <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> java.lang.Boolean a <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> objectid(a.clazz.statics.TRUE) != objectid(a) &amp;&amp; objectid(a.clazz.statics.FALSE) != objectid(a)</code> </pre> <br><p>  Having executed it, I was surprised to find many separate objects of the <code>jlBoolean</code> class.  The heap didn‚Äôt say anything about their origin, so I wanted to figure out where they came from.  Memory profiling showed a curious picture: new <code>Boolean-</code> constantly appeared, accumulated and after some time disappeared into the mouth of the GC.  At certain points in time, their account could go to tens of thousands, and they occupied about 1 MB of memory. </p><br><p><img src="https://habrastorage.org/webt/ld/yd/vg/ldydvgbdcgk9nvgk-c-eshnlips.png"></p><br><p>  Strictly speaking, they were not a problem, because they did not create leaks, they were quickly cleared, and what is 1 MB these days?  However, the mechanism of the emergence of new objects was interesting in itself, so I began to dig. </p><br><p>  First, let's see how to get an object of class <code>Boolean</code> .  JDK gives us the following features: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">/*1*/</span></span> Boolean b1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Boolean(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); <span class="hljs-comment"><span class="hljs-comment">//@Deprecated   Java 9 /*2*/ Boolean b2 = new Boolean("true"); //@Deprecated   Java 9 /*3*/ Boolean b3 = true; /*4*/ Boolean b4 = Boolean.valueOf(true); /*5*/ Boolean b5 = Boolean.valueOf("true"); /*6*/ Boolean b6 = Boolean.parseBoolean("true");</span></span></code> </pre> <br><p>  What is the difference between them?  Only the first and second methods return a new object (for the constructor).  The third method in the assembly is reduced to the fourth, which, like the last two, returns <code>Boolean.FALSE/Boolean.TRUE</code> from the presence. </p><br><p>  So, the reason for the appearance of many identical (by content) objects is to wrap a simple <code>boolean</code> in a wrapper, but not by calling <code>Boolean.valueOf</code> , but by <code>Boolean.valueOf</code> constructor.  The first suspicion fell on the library developers.  Well, let's try to find possible punctures.  Search for the source of the dependencies connected (thanks to the developers of "Ideas"), did not reveal anything suspicious, so I had to get up the debugger in the constructor, and where the curve would output. </p><br><p>  The very first hit confirmed the hunch: it smacked of reflection, in particular its use for processing annotations.  Consider the code: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Transactional</span></span>(readOnly = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyService</span></span></span><span class="hljs-class"> </span></span>{ }</code> </pre> <br><p>  During execution, reflection is used to read the <code>@Transactional</code> properties (in this case, <code>readOnly</code> ).  This happens as follows (Spring Core 5.0.4.RELEASE): </p><br><p><img src="https://habrastorage.org/webt/ml/2e/no/ml2enob20ftbk_51nhed2yhmlrq.png"></p><br><p>  Moving up the chain, we come to <code>sun.reflect.DelegatingMethodAccessorImpl</code> , the sources of which we can still read, but then begins the mysterious <code>GeneratedMethodAccessor13</code> .  And although, according to the debugger, this class is also in the <code>sun.reflect</code> package, its code is not available for us from the Idea, and the name itself suggests that the class was created on the fly.  And it is his <code>invoke()</code> method that ultimately calls the <code>Boolean(boolean value)</code> constructor <code>Boolean(boolean value)</code> . </p><br><p>  The case is complicated: now you need to somehow get the code for this method.  I could not solve this problem in a hurry, so I had to go a different way: if you cannot get the code itself, then you can try to reliably uncover the way it was created.  To do this, we put a simple experiment with calling a reflection method that returns a <code>boolean</code> : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.lang.reflect.Method; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Main</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> invocationCount = <span class="hljs-number"><span class="hljs-number">20</span></span>; Object[] booleans = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Object[invocationCount]; Method method = Main.class.getMethod(<span class="hljs-string"><span class="hljs-string">"f"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; invocationCount; i++) { booleans[i] = invoke(method); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Object </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">invoke</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Method method)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> method.invoke(<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } }</code> </pre> <br><p>  By the way, we didn‚Äôt remove the <code>jlBoolean</code> from the <code>jlBoolean</code> constructor, right?  That's only during the first 16 passes through the loop at this point the debugger does not stop!  Once again: each <code>method.invoke(null)</code> execution returns a <strong>new object</strong> (that is, <code>booleans[i-1] != booleans[i]</code> ), and the constructor of this object itself is not called. </p><br><p>  If during one of the first 16 passes we stop inside <code>DelegatingMethodAccessorImpl.invoke()</code> and move on, we will find that now there is a class that was absent before, namely <code>sun.reflect.NativeMethodAccessorImpl</code> : </p><br><p><img src="https://habrastorage.org/webt/0m/ew/i6/0mewi658lrjjjzfav8-nyd-nyfy.png"></p><br><p>  Here he is: </p><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NativeMethodAccessorImpl</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MethodAccessorImpl</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Method method; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> DelegatingMethodAccessorImpl parent; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> numInvocations; NativeMethodAccessorImpl(Method method) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.method = method; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Object </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">invoke</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object obj, Object[] args)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IllegalArgumentException, InvocationTargetException </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// We can't inflate methods belonging to vm-anonymous classes because // that kind of class can't be referred to by name, hence can't be // found from the generated bytecode. if (++numInvocations &gt; ReflectionFactory.inflationThreshold() &amp;&amp; !ReflectUtil.isVMAnonymousClass(method.getDeclaringClass())) { MethodAccessorImpl acc = (MethodAccessorImpl) new MethodAccessorGenerator(). generateMethod(method.getDeclaringClass(), method.getName(), method.getParameterTypes(), method.getReturnType(), method.getExceptionTypes(), method.getModifiers()); parent.setDelegate(acc); } return invoke0(method, obj, args); } void setParent(DelegatingMethodAccessorImpl parent) { this.parent = parent; } private static native Object invoke0(Method m, Object obj, Object[] args);</span></span></code> </pre> <br><p>  This is the answer to the question why we did not see the constructor call: instead, the platform-dependent method <code>invoke0()</code> creates an object somewhere in the depths of the VM.  The same code explains why the constructor appears on the 17th pass in the call chain, and <code>NativeMethodAccessorImpl</code> disappears: after the number of calls to the <code>f()</code> method exceeds the value returned by <code>ReflectionFactory.inflationThreshold()</code> (for JDK 8/9/10/11 this 15), on the fly, <code>MethodAccessorGenerator</code> creates an intermediary for it, which in the form of a <code>MethodAccessorImpl</code> object <code>MethodAccessorImpl</code> passed to a level higher than <code>DelegatingMethodAccessorImpl-</code> . </p><br><p>  Starting from the 17th pass, we observe the picture we are used to (the newly created implementation of <code>MethodAccessorImpl</code> ): </p><br><p><img src="https://habrastorage.org/webt/ql/wa/v4/qlwav414lrenjl8svb9c2qlfq4a.png"></p><br><p>  Thus, two places are found that return new objects: the native method <code>NativeMethodAccessorImpl.invoke0()</code> and code created on the fly using <code>new MethodAccessorGenerator().generateMethod()</code> .  Let's go on the path of least resistance and for now stay on the side of Java.  Since out of the box (in the case of JDK 8 with which the application is assembled) only the compiled class (from rt.jar) is available to us, and decompiling gives the unintelligible false origin with <code>var123</code> instead of variable names and without any explanation, you will have to look at repositories </p><br><p>  Familiarization with the <a href="">source code</a> <code>MethodAccessorGenerator</code> puts everything in its place: a bytecode is created here (yes, it is the bytecode in its original form, namely, in the form of an array of bytes).  The key method for us is called <code>emitInvoke()</code> , in which we find the one <a href="">we need</a> : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!isConstructor) { <span class="hljs-comment"><span class="hljs-comment">// Box return value if necessary if (isPrimitive(returnType)) { cb.opc_invokespecial(ctorIndexForPrimitiveType(returnType), typeSizeInStackSlots(returnType), 0); } else if (returnType == Void.TYPE) { cb.opc_aconst_null(); } }</span></span></code> </pre> <br><p>  Line 663: what is called, overlooked when reading.  Instead of calling <code>valueOf()</code> to wrap simple return values, we entered a constructor call.  Obviously, this is fixable: it‚Äôs all about business that the <code>invokespecial</code> call <code>invokespecial</code> to be replaced by <code>invokestatic</code> , and instead of the constructor, the factory method is passed. </p><br><p>  Alas, familiarization with source codes <del>  cherry </del>  "Nines" showed that (very suddenly) I am not the only one so clever, and I cannot win the laurels in this matter, <a href="http://hg.openjdk.java.net/jdk9/dev/jdk/rev/fec081f17140">since everything is already fixed before us</a> : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!isConstructor) { <span class="hljs-comment"><span class="hljs-comment">// Box return value if necessary if (isPrimitive(returnType)) { cb.opc_invokestatic(boxingMethodForPrimitiveType(returnType), typeSizeInStackSlots(returnType), 0); } else if (returnType == Void.TYPE) { cb.opc_aconst_null(); } }</span></span></code> </pre> <br><p>  This is more obvious (JDK 9 on the left): </p><br><p><img src="https://habrastorage.org/webt/0q/e2/7j/0qe27jq_nhhx4szfz5fi2qzpr6m.png"></p><br><p>  The problem was discovered long ago, and the corresponding <a href="https://bugs.openjdk.java.net/browse/JDK-5043030">problem has existed since 2004 (!)</a> . </p><br><p>  There is a discussion on the topic: </p><br><p>  <a href="http://mail.openjdk.java.net/pipermail/core-libs-dev/2014-May/027041.html">Start</a> </p><br><p>  <a href="http://mail.openjdk.java.net/pipermail/core-libs-dev/2014-June/027076.html">Continuation</a> </p><br><p>  Let's check now if it‚Äôs better.  Switching to the "nine" and repeating our experience we will see this: </p><br><p><img src="https://habrastorage.org/webt/od/nd/uv/odnduvnlai-hyalx4ynospjdsc4.png"></p><br><p>  After 16 hits, code was created using <code>Boolean.valueOf()</code> and returning <code>Boolean.TRUE/Boolean.FALSE</code> .  True, there is still a problem with the <code>NativeMethodAccessorImpl.invoke0()</code> method, which stubbornly returns new objects (even in 10-ke).  There is nothing to do, you need to go to the source code of the VM and see if we can do something about it. </p><br><p>  I did not find any direct references to <code>invoke0</code> , but in discussions on the topic the <a href="">reflection.cpp</a> file has surfaced and it looks like our constructor is being invoked by the <a href="">invoke ()</a> method.  In this method, the most important for us is the last <a href="">line</a> : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Reflection::box((jvalue*)result.get_value_addr(), rtype, THREAD);</code> </pre> <br><p>  <code>Reflection::box</code> <a href="">code</a> : </p><br><pre> <code class="cpp hljs">oop Reflection::box(jvalue* value, BasicType type, TRAPS) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (type == T_VOID) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (type == T_OBJECT || type == T_ARRAY) { <span class="hljs-comment"><span class="hljs-comment">// regular objects are not boxed return (oop) value-&gt;l; } oop result = java_lang_boxing_object::create(type, value, CHECK_NULL); if (result == NULL) { THROW_(vmSymbols::java_lang_IllegalArgumentException(), result); } return result; }</span></span></code> </pre> <br><p>  The main thing is highlighted with empty lines.  Now the <a href="">code is java_lang_boxing_object :: create</a> </p><br><pre> <code class="cpp hljs">oop java_lang_boxing_object::create(BasicType type, jvalue* value, TRAPS) { oop box = initialize_and_allocate(type, CHECK_0); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (box == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (type) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> T_BOOLEAN: box-&gt;bool_field_put(value_offset, value-&gt;z); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-comment"><span class="hljs-comment">//.... case-case-case return box; } oop java_lang_boxing_object::initialize_and_allocate(BasicType type, TRAPS) { Klass* k = SystemDictionary::box_klass(type); if (k == NULL) return NULL; instanceKlassHandle h (THREAD, k); if (!h-&gt;is_initialized()) h-&gt;initialize(CHECK_0); return h-&gt;allocate_instance(THREAD); }</span></span></code> </pre> <br><p>  As we see, the VM first creates a new empty object, and only then flushes the value into it and returns it to the outside.  This explains the appearance of a new object without calling the constructor.  Perhaps, for <code>T_BOOLEAN</code> , it would be possible to cache two values ‚Äã‚Äãat the VM level, but it is not clear whether the game is worth the candle. </p><br><p>  <strong>In the dry residue</strong> </p><br><p>  How much will we win after moving to the "nine"?  Calculate: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@BenchmarkMode</span></span>(Mode.AverageTime) <span class="hljs-meta"><span class="hljs-meta">@OutputTimeUnit</span></span>(TimeUnit.NANOSECONDS) <span class="hljs-meta"><span class="hljs-meta">@Fork</span></span>(jvmArgsAppend = {<span class="hljs-string"><span class="hljs-string">"-XX:+UseParallelGC"</span></span>, <span class="hljs-string"><span class="hljs-string">"-Xms1g"</span></span>, <span class="hljs-string"><span class="hljs-string">"-Xmx1g"</span></span>}) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ReflectiveCallBenchmark</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Benchmark</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Object </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">invoke</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Data data)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> data.method.invoke(data); } <span class="hljs-meta"><span class="hljs-meta">@State</span></span>(Scope.Thread) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Data</span></span></span><span class="hljs-class"> </span></span>{ Method method; <span class="hljs-meta"><span class="hljs-meta">@Setup</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ method = getClass().getMethod(<span class="hljs-string"><span class="hljs-string">"f"</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; } } }</code> </pre> <br><table><thead><tr><th></th><th></th><th></th><th>  JDK 8 </th><th>  JDK 9 </th><th>  JDK 10 </th><th>  JDK 11 </th><th></th></tr></thead><tbody><tr><td>  Benchmark </td><td>  Mode </td><td>  Cnt </td><td>  Score </td><td>  Score </td><td>  Score </td><td>  Score </td><td>  Unit </td></tr><tr><td>  invoke </td><td>  avgt </td><td>  thirty </td><td>  <strong>9.9</strong> </td><td>  <strong>7.0</strong> </td><td>  <strong>7,6</strong> </td><td>  <strong>7.7</strong> </td><td>  ns / op </td></tr><tr><td>  invoke: ¬∑ gc.alloc.rate.norm </td><td>  gcprof </td><td>  thirty </td><td>  <strong>32</strong> </td><td>  <strong>sixteen</strong> </td><td>  <strong>sixteen</strong> </td><td>  <strong>sixteen</strong> </td><td>  B / op </td></tr></tbody></table><br><p>  All the costs of a reflexive challenge are measured here.  If you need to measure the difference between wrapping a <code>boolean</code> using a constructor and <code>valueOf</code> , then you can use a simpler measurement: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@BenchmarkMode</span></span>(Mode.AverageTime) <span class="hljs-meta"><span class="hljs-meta">@OutputTimeUnit</span></span>(TimeUnit.NANOSECONDS) <span class="hljs-meta"><span class="hljs-meta">@Fork</span></span>(jvmArgsAppend = {<span class="hljs-string"><span class="hljs-string">"-XX:+UseParallelGC"</span></span>, <span class="hljs-string"><span class="hljs-string">"-Xms1g"</span></span>, <span class="hljs-string"><span class="hljs-string">"-Xmx1g"</span></span>}) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BooleanInstantiationBenchmark</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Benchmark</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Boolean </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">constructor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Data data)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Boolean(data.value); } <span class="hljs-meta"><span class="hljs-meta">@Benchmark</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Boolean </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">valueOf</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Data data)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Boolean.valueOf(data.value); } <span class="hljs-meta"><span class="hljs-meta">@State</span></span>(Scope.Thread) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Data</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Param</span></span>({<span class="hljs-string"><span class="hljs-string">"true"</span></span>, <span class="hljs-string"><span class="hljs-string">"false"</span></span>}) <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> value; } }</code> </pre> <br><table><thead><tr><th></th><th></th><th></th><th>  JDK 8 </th><th>  JDK 9 </th><th>  JDK 10 </th><th>  JDK 11 </th><th></th></tr></thead><tbody><tr><td>  Benchmark </td><td>  Mode </td><td>  Cnt </td><td>  Score </td><td>  Score </td><td>  Score </td><td>  Score </td><td>  Unit </td></tr><tr><td>  valueOf </td><td>  avgt </td><td>  thirty </td><td>  <strong>3.7</strong> </td><td>  <strong>3.4</strong> </td><td>  <strong>3.6</strong> </td><td>  <strong>3.5</strong> </td><td>  ns / op </td></tr><tr><td>  constructor </td><td>  avgt </td><td>  thirty </td><td>  <strong>7.4</strong> </td><td>  <strong>5.0</strong> </td><td>  <strong>5.5</strong> </td><td>  <strong>5.9</strong> </td><td>  ns / op </td></tr><tr><td>  valueOf: ¬∑ gc.alloc.rate.norm </td><td>  gcprof </td><td>  thirty </td><td>  <strong>0</strong> </td><td>  <strong>0</strong> </td><td>  <strong>0</strong> </td><td>  <strong>0</strong> </td><td>  B / op </td></tr><tr><td>  constructor: ¬∑ gc.alloc.rate.norm </td><td>  gcprof </td><td>  thirty </td><td>  <strong>sixteen</strong> </td><td>  <strong>sixteen</strong> </td><td>  <strong>sixteen</strong> </td><td>  <strong>sixteen</strong> </td><td>  B / op </td></tr></tbody></table><br><p>  Total: -16 bytes and -2..3 ns for one reflexive method call that returns a <code>boolean</code> .  Not bad, as for a simple change, especially considering the frequency of use of reflection in bloody Interprize, as well as the fact that the improvement also applies to other primitives.  Notice that the performance of the code created using <code>new MethodAccessorGenerator().generateMethod()</code> , and not the creation of an object inside the VM, is measured. </p><br><p>  As a conclusion: the improvement described is very insignificant in itself, and its effect is almost imperceptible.  Although it is such trifles that are put together give an increase in the productivity of new editions of Java. </p><br><p>  PS The value returned by the <code>ReflectionFactory.inflationThreshold()</code> method can be overridden using the <code>-Dsun.reflect.inflationThreshold</code> property passed by the argument when the VM is started.  Thus, if you have already moved to the "nine", then using this flag you can reduce the threshold for creating a bytecode for a reflexive call.  This may slow down the launch of the application, but it will be less "littering".  The documentation <a href="">explains</a> why this mechanism was invented. </p><br><p>  PPS Considered classes ( <code>MethodAccessorGenerator</code> , <code>NativeMethodAccessorImpl</code> , <code>DelegatingMethodAccessorImpl</code> , <code>MethodAccessorImpl</code> ) starting with the "nine" are moved to the <code>jdk.internal.reflect</code> package. </p><br><p>  PP P S. Note that in the framework of the described improvement, a <a href="http://hg.openjdk.java.net/jdk9/dev/jdk/rev/fec081f17140">significant number of classes</a> have undergone changes, not just the <code>MethodAccessorGenerator</code> . </p><br><p>  PPPPS The <code>jlBoolean</code> device <a href="https://bugs.openjdk.java.net/browse/JDK-8199800">can be slightly simplified</a> and win a couple of ns on it;) </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/351988/">https://habr.com/ru/post/351988/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../351978/index.html">Unity posted the original C # code on Github</a></li>
<li><a href="../351980/index.html">FastReport.Mono. Part 2: Web Report in Docker Container</a></li>
<li><a href="../351982/index.html">Matthias Noback on Ideal Architecture - Layers, Ports, and Adapters (Part 2 - Layers)</a></li>
<li><a href="../351984/index.html">PHP Digest 127 (March 1 - 25, 2018)</a></li>
<li><a href="../351986/index.html">The digest of fresh materials from the world of the frontend for the last week ‚Ññ307 (March 19 - 25, 2018)</a></li>
<li><a href="../351990/index.html">Windows Server 2019: Linux and Kubernetes support</a></li>
<li><a href="../351992/index.html">Visualization on the distribution map of votes in Moscow in the presidential elections of 2018</a></li>
<li><a href="../351994/index.html">NGINX and gRPC are real friends now</a></li>
<li><a href="../351996/index.html">Guava, Graal and Partial Escape Analysis</a></li>
<li><a href="../351998/index.html">The release of Krita 4.0, a free graphic editor for artists, took place.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>