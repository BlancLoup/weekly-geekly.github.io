<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Breaking down resource compression in Might and Magic III</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I don‚Äôt remember very well how I ended up in the DOSBox debugger, and why I was picking at the 16-bit assembler, restoring the function of unpacking t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Breaking down resource compression in Might and Magic III</h1><div class="post__text post__text-html js-mediator-article">  I don‚Äôt remember very well how I ended up in the DOSBox debugger, and why I was picking at the 16-bit assembler, restoring the function of unpacking the MM3.CC resource files ‚Äî but it was great.  I got the game on one of the recent sales of the humble bundle, and then on the net I came across the <a href="http://www.jeffludwig.com/mm3/index.php">Jeff Ludwig page</a> , which described problems with modifying the game related to compression in MM3.CC.  In particular, the following was written there: <br><blockquote>  It turned out that this algorithm is quite difficult to crack, and so far no one has learned how to unpack this data. </blockquote><br>  The call has been accepted.  His article describes how he tried to fight the algorithm.  I will sign it, as I did myself, and in the end I will give a link to an open source utility that can not only unpack, but also package the MM3.CC file. <br><br><h4>  Dos packer </h4><br>  Looking at MM3.EXE, I discovered that it is a compressed DOS executable file, with some uncompressed overlay, at the beginning of which stands FBOV.  I didn‚Äôt know anything about DOS compressor, but I‚Äôve seen from Jeff Ludwig that he is using a thing called ‚ÄúUniversal Program Cracker‚Äù v1.11.  I found version 1.10 (released on June 25, 1997) and unpacked the exe.  And I even managed to correctly process the overlay data.  Still, I wanted to know the name of the packer.  I was prompted to use the <a href="http://ntinfo.biz/">Detect It Easy</a> program, and indeed - it issued: <br><br><pre><code class="bash hljs">EXECUTRIX-COMPRESSOR(-)[by Knowledge Dynamics Corp] Borland TLINK(2.0)[-]</code> </pre> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      For history buffs, I can recommend the old thread of discussions concerning this software - from 1991 and 1995: <br><br>  <a href="https://groups.google.com/forum/">https://groups.google.com/forum/#!topic/comp.os.msdos.programmer/QsjHLY6Kb4s</a> <br>  <a href="https://groups.google.com/forum/">https://groups.google.com/forum/#!topic/comp.compression/IAj2-VHbtl4</a> <br><a name="habracut"></a><br><h4>  IDA DOS loader </h4><br>  Unpacking the exe is fine, but correctly disassembling it is even better.  Unfortunately, IDA stumbled on it.  He correctly defined the overlay, but could not load it.  After reviewing the code, I realized that analyzing it without an overlay would result in a headache, since the code clearly missed areas (despite the fact that the unpacking procedure is stored in the exe file).  While searching for FBOV in Google, I came across the source code of the IDA DOS loader, which confirmed that IDA should be able to download this overlay without any problems.  I recompiled the debug version of IDA DOS loader and traced its work through Visual Studio to understand why it does not load the overlay.  For this, I had to describe several internal parameters of the FBOV structure.  The title is described as follows: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> FB_MAGIC 0x4246 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> OV_MAGIC 0x564F struct fbov_t { ushort fb; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// = FB_MAGIC ushort ov; // = OV_MAGIC uint32 ovrsize; uint32 exeinfo; int32 segnum; };</span></span></span></span></code> </pre><br><br>  exeinfo is the offset (absolute, from the beginning of the MZ header header) array of structures describing each segment stored in the overlay.  segnum - the number of segments.  They are described by the following structure: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">seginfo_t</span></span></span><span class="hljs-class"> {</span></span> ushort seg; ushort maxoff; ushort flags; ushort minoff; };</code> </pre><br><br>  This is all in theory, and in IDA DOS loader, all this is implemented in the LoadCppOverlays () function.  But with this exe theory ceases to work - though, mistaken only a few bytes.  During the debug, I realized that exeinfo indicates the position immediately after the mentioned array of segments.  I added one line in LoadCppOverlays (): <br><br><pre> <code class="cpp hljs"> fbov.exeinfo -= fbov.segnum*<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">seginfo_t</span></span>);</code> </pre><br><br>  And it all worked.  I did not find any documentation for FBOV, so I don‚Äôt know for sure if there are several implementations of these overlays.  I am sure that the IDA DOS loader was implemented to work with the correct version, because surely the person who wrote it checked it with live examples.  Maybe it was a special feature of MM3 developers, who knows. <br><br><h4>  We are looking for unpacker </h4><br>  For the search, I used the DOSBox debugger and a set of breakpoints on int 21h (standard interrupt for working with the DOS API);  I was especially interested in the 3Dh (open file), 3Fh (file reading) and 42h (file search) functions.  And I quickly found what I was looking for. <br><br><h4>  Algorithm analysis </h4><br>  Now almost all the picking of packers / unpackers is done through Hex-Rays Decompiler, which does not present any particular difficulties.  However, it does not work with assembler 16-bit x86, and it is unlikely when it will work.  It‚Äôs as if I‚Äôve come back to 2005, when I wrote my first static unpacker.  It was IDA 4.9 time, then there was not even an interactive flowchart mode that appeared in March 2006. I mention this because for me this technology was breakthrough and dramatically accelerated the reverse engineering of algorithms.  I offer you a graphical representation of the unpacker: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/724/e2c/6c9/724e2c6c9cc77e7910da3b9beb83474d.png" alt="image"><br><br>  The purple blocks are the initialization of the algorithm, the brown ones are the main unpacking cycle, the white ones are working with the memory and the structure of the CC file.  Removing an algorithm from an assembler usually takes several steps. <br><br>  1. Data collection.  The complexity depends on the complexity of the algorithm.  It is necessary to collect information on input and output buffers, temporary buffers, variables (local and global) and constants that can be used in calculations.  To simplify the work, you need to assign variables to the CPU registers whose names are similar to the register name (_ax, _bx, _cx, etc.).  The type of the variable must match the size of the register - in our case it is uint16_t.  In some cases, it is better to represent registers as unions (union) in order to simplify access to 8-bit parts of registers.  Working with local and global variables is quite complicated, especially at first, since it is not always clear whether this is a normal type of variable that occupies 1,2,4 bytes, or is it an array.  If there are a lot of accesses to memory addresses located close to each other, we can assume that this is an array, and later we can divide them into separate variables, if they are accessed, not as an array.  This is especially useful when working with local variables, so all access to esp / ebp needs to be processed through arrays (for simplicity, let's call it _stack).  In this phase it is very important to initialize all known data. <br><br>  2. Search cycles - this is for me the most interesting.  An interactive graphical representation in IDA is one of the best tools for this.  It is convenient to start with the simplest internal cycles, and go upstairs.  Each cycle can be painted in different colors and grouped.  Cycle grouping simplifies graphical representation, and hiding internal loops helps to find the next level cycles, and so on. <br><br>  3. Code rewriting is the most tedious part.  Rewrite each opcode or opcode group into expressions in a higher level language, block by block.  If all the cycles were correctly found, it is not very difficult to do - but, like any tedious work, this part is error prone.  The remaining logic is conditional expressions that are easy to translate into high-level language.  It is convenient to mark the processed blocks with a different color so as not to get lost in them. <br><br>  4. Validation.  In most cases, the first time you will earn nothing.  Errors made in the first three stages are common and difficult to find.  Fixing them usually involves running two debuggers at the same time ‚Äî for the original code and for your version. <br><br>  5. Decorating code.  After everything has worked, it's good to go over the code and deal with all the variables, arrays and constants that have not been uniquely identified before.  It is also good to give variables normal names and get rid of optional constructions that mimic assembler.  Ideally, then there should be no variables named after the x86 registers or arrays that simulate a stack.  Everything should look like a normal high level code. <br><br>  In the case of Might and Magic III, I went through all the stages, and in the end I got a working unpacker.  To avoid the mistakes of clause 4, I worked with the debugger of the original code, and checked each rewritten simple block to generate an identical assembler code.  Walking through all the compressed MM3CC streams, I found that one of the branches of the algorithm was not involved, so for the time being I left it empty.  The red blocks on the graph show the part that is not executed on the game files. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9b6/cc2/dbe/9b6cc2dbede66eeba6e2b004c83785c0.png" alt="image"><br><br>  Then I started to google the name of the algorithm.  I searched for the hexadecimal constants found in the code and the word ‚Äúdecompress‚Äù: <br><br>  "0x13A" decompress <br>  "0x4E6" decompress <br>  ‚Äú0x274‚Äù decompress <br>  ‚Äú0x139‚Äù decompress <br>  "0xFC4" decompress &lt;- success <br><br>  I found the source code unpacker of some <a href="">old format from Amiga</a> .  In addition to this constant, there were also table constants presented in MM3.  It turned out that MM3 uses <a href="">the LZHUF algorithm</a> .  Having learned this, I even more combed the code I received, and copied the missing parts of the algorithm (red blocks) from <a href="">this source</a> .  The MM3 version is identical to the original LZHUF implementation with a few exceptions ‚Äî instead of using the value 0x20 to initialize the dictionary, it uses the value obtained from the argument.  The 8-bit value of all compressed streams in the MM3 .CC file is different.  I guessed that this was in each case the most common byte in the data. <br><br><h4>  MM3.CC Packer / Unpacker </h4><br>  I decided to finish the titanic work with a normal utility that someone else can use.  The CC file format is described in the <a href="http://xeen.wikia.com/wiki/CC_File_Format">Xeen Wiki</a> , but this description only works for CC files from Might and Magic IV and V. And for MM3.CC, the file structure is similar, but file name hashing and compression are different.  The file header and table of contents are exactly the same as described in the Xeen Wiki: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FileEntry</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FileHeader</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> NumberOfFileEntries FileEntry FileEntries[NumberOfFileEntries]; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FileEntry</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> hash; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> offsetLo; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> offsetHi; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> compressedSize; <span class="hljs-comment"><span class="hljs-comment">// includes 4 bytes header uint8_t padding; };</span></span></code> </pre><br><br>  The FileEntries array is encrypted using the algorithm below (the same as in the Xeen Wiki): <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">encryptHeader</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">* buf, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> key = <span class="hljs-number"><span class="hljs-number">0xAC</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; size; i++) { buf[i] = _rotr8(buf[i] - key, <span class="hljs-number"><span class="hljs-number">2</span></span>); key += <span class="hljs-number"><span class="hljs-number">0x67</span></span>; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">decryptHeader</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">* buf, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> key = <span class="hljs-number"><span class="hljs-number">0xAC</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; size; i++) { buf[i] = _rotl8(buf[i], <span class="hljs-number"><span class="hljs-number">2</span></span>) + key; key += <span class="hljs-number"><span class="hljs-number">0x67</span></span>; } }</code> </pre><br><br>  Files in the CC container are identified by a 16-bit hash (FileEntry.hash): <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> hashFileName(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* fileName) { <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> hash = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-number"><span class="hljs-number">0</span></span> != *fileName) { <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> c = ((*fileName &amp; <span class="hljs-number"><span class="hljs-number">0x7F</span></span>) &lt; <span class="hljs-number"><span class="hljs-number">0x60</span></span>) ? *fileName : *fileName - <span class="hljs-number"><span class="hljs-number">0x20</span></span>; hash = _rotl16(hash, <span class="hljs-number"><span class="hljs-number">9</span></span>); <span class="hljs-comment"><span class="hljs-comment">// xchg bl, bh | rol bx, 1 hash += c; fileName++; } return hash; }</span></span></code> </pre><br><br>  The first two files are special.  These are uncompressed texts, and their size is directly recorded in the exe file, so it is better not to change them.  All the others are compressed data blocks with a small descriptor at the beginning of each block: <br><br><pre> <code class="cpp hljs">{ <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> decompressionInitializer; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> decompressedSize; }</code> </pre><br><br>  The decompressionInitializer could be uint8_t, since it always stores an 8-bit value in the upper and lower 8 bits.  I do not know why it is stored that way.  decompressedSize is stored in the big-endian value, which is also strange.  Another oddity is that after re-compression with the help of my utility, the MM3.CC file has decreased by 33 Kb.  I also prepared a list of file names compiled from MM3.EXE so that the correct file names were obtained when unpacking (the list is incomplete - I missed 15 of the 556 file names).  That's almost all - I provide a link to the github repository, where the MM3CC file packer / unpacker is located <br><br>  <a href="https://github.com/rwfpl/rewolf-mm3-dumper">github.com/rwfpl/rewolf-mm3-dumper</a> <br><br>  Compression is taken from standard LZHUF with minor changes, unpacking is the result of three-day reverse engineering.  Squeezer and uncleaner do not check buffers, therefore it is not recommended to use them for serious things.  Using them is easy: <br><br><pre> <code class="bash hljs">x:\mm3&gt;mm3_cc_dumper.exe Might and Magic III CC file packer/unpacker v1.0 Copyrigh (c) 2015 ReWolf http://blog.rewolf.pl Usage: Unpack: mm3_cc_dumper.exe dump input_file.cc Pack: mm3_cc_dumper.exe pack input_directory output_file.cc</code> </pre></div><p>Source: <a href="https://habr.com/ru/post/264947/">https://habr.com/ru/post/264947/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../264933/index.html">UX-strategy in practice. Part 3 - Platform Thinking</a></li>
<li><a href="../264935/index.html">Last 2 days of sales of Early Bird MBLTdev conference tickets</a></li>
<li><a href="../264937/index.html">Improving communication between the client and the UX: how to avoid a damaged phone</a></li>
<li><a href="../264941/index.html">Objectives of the entrance exam at ShAD 2014</a></li>
<li><a href="../264943/index.html">Introducing Hub 1.0 - a connector for command products JetBrains</a></li>
<li><a href="../264949/index.html">SMS from Bash or teach Zabbix new tricks</a></li>
<li><a href="../264953/index.html">New WiFi equipment from Ruckus Wireless. New: access points, controllers and functionality</a></li>
<li><a href="../264955/index.html">Joker 2015: News 1-18 August 2015 - new speakers and reports</a></li>
<li><a href="../264961/index.html">Part 2. Creating classes, mappings and filling database</a></li>
<li><a href="../264963/index.html">Object language restrictions (and a little about the meta model)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>