<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How to write your own C ++ game engine</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Translation of an article by Jeff Preshing (Jeff Preshing) How to Write Your Own C ++ Game Engine . 
 How to write your own C ++ game engine 


 Recen...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How to write your own C ++ game engine</h1><div class="post__text post__text-html js-mediator-article"><p>  <em>Translation of an article by Jeff Preshing (Jeff Preshing) <a href="http://preshing.com/20171218/how-to-write-your-own-cpp-game-engine/">How to Write Your Own C ++ Game Engine</a> .</em> </p><br><h2>  How to write your own C ++ game engine </h2><br><p>  Recently, I have been busy writing a C ++ game engine.  I use it to create a small mobile game <strong>Hop Out</strong> .  Here is the video recorded from my iPhone 6. (You can turn on the sound!) </p><br><div class="oembed"><div><div style="left: 0; width: 100%; height: 0; position: relative; padding-bottom: 56.25%;"><video controls="" style="top: 0; left: 0; width: 100%; height: 100%; position: absolute;">  Your browser does not support HTML5 video. <source src="http://preshing.com/images/hopoutclip.mp4" type="video/mp4"></video></div></div></div><br><p>  Hop Out is the game that I want to play myself: a retro arcade game with 3D cartoon graphics.  The goal of the game is to repaint each of the platforms, as in Q * Bert. </p><br><p>  Hop Out is still in development, but the engine that powers it is starting to take on a mature shape, so I decided to share here some tips on engine development. </p><br><p>  Why would anyone want to write a game engine?  There are many possible reasons: </p><a name="habracut"></a><br><ul><li>  You are a craftsman.  You like to build systems from scratch and see how they come to life. </li><li>  You want to learn more about game development.  I‚Äôve been in the gaming industry for 14 years and still trying to figure it out.  I was not even sure that I could write the engine from scratch, because it is so different from the daily work duties of a programmer in a large studio.  I wanted to check. </li><li>  You like the feeling of control.  To organize the code exactly the way you want, and always knowing where everything is - it brings pleasure. </li><li>  You are inspired by classic game engines such as AGI (1984), id Tech 1 (1993), Build (1995), and industry giants like Unity and Unreal. </li><li>  You believe that we, the gaming industry, have to dump the cover of mystery from the engine development process.  We have not really mastered the art of game development - where there!  The more carefully we consider this process, the higher our chances of improving it. </li></ul><br><p>  The gaming platforms in 2017 ‚Äî mobile, consoles and PCs ‚Äî are very powerful and in many ways resemble each other.  Development of the game engine has ceased to be a struggle with a weak and rare iron, as it was in the past.  In my opinion, now it‚Äôs rather a struggle with the <strong>complexity of your own work</strong> .  You can easily create a monster!  That's why all the tips in this article revolve around how to keep your code manageable.  I combined them into three groups: </p><br><ol><li>  Use an iterative approach </li><li>  Think twice before generalizing too much </li><li>  Realize that serialization is a vast topic. </li></ol><br><p>  These tips apply to any game engine.  I'm not going to tell you how to write a shader, what an octree is or how to add physics.  I believe you already know that you should know this - and in many ways these topics depend on the type of game you want to do.  Instead, I deliberately chose topics that are not covered extensively - topics that I find most interesting when I try to dispel the veil of secrecy over anything. </p><br><hr><br><h2>  Use an iterative approach </h2><br><p>  My first advice is to keep anything (whatever!) To work without stopping, then repeat. </p><br><p> If possible, start with a sample application that initializes the device and draws something on the screen.  In this case, I downloaded the <a href="https://www.libsdl.org/">SDL</a> , opened <code>Xcode-iOS/Test/TestiPhoneOS.xcodeproj</code> , then launched the example <code>testgles2</code> on my iPhone. </p><br><p><img src="http://preshing.com/images/gameengine-step1.jpg"></p><br><p>  Voila!  I have a great spinning cube using OpenGL ES 2.0. </p><br><p>  My next step was to download a 3D model of Mario made by someone.  I quickly wrote a draft OBJ file loader ‚Äî this format is not so complicated ‚Äî and I corrected the example so that it draws Mario instead of a cube.  I also integrated <a href="https://www.libsdl.org/projects/SDL_image/">SDL_Image</a> to load textures. </p><br><p><img src="http://preshing.com/images/gameengine-step2.png"></p><br><p>  Then I implemented two stick controls to move Mario.  (At first I considered the idea of ‚Äã‚Äãcreating a dual-stick shooter. However, not with Mario). </p><br><p><img src="http://preshing.com/images/gameengine-step3.png"></p><br><p>  The next thing I wanted to do was get acquainted with skeletal animation, so I opened <a href="https://www.blender.org/">Blender</a> , created a tentacle model, and tied a skeleton of two bones to it, which oscillated here and there. </p><br><p><img src="http://preshing.com/images/gameengine-step4.png"></p><br><p>  By that time, I abandoned the OBJ format and wrote a Python script to export my own JSON files from Blender.  These JSON files described the skinned mesh, the skeleton, and the animation data.  I downloaded these files into the game using <a href="https://github.com/nlohmann/json">the C ++ JSON library</a> . </p><br><p><img src="http://preshing.com/images/gameengine-step5.png"></p><br><p>  As soon as everything worked, I returned to Blender and created a more developed character (This was the first three-dimensional person made and engraved by me. I was very proud of him.) </p><br><p><img src="http://preshing.com/images/gameengine-step6.jpg"></p><br><p>  Over the next few months, I took these steps: </p><br><ul><li>  He began to allocate functions of working with vectors and matrices into his own library of three-dimensional mathematics. </li><li>  Replaced <code>.xcodeproj</code> with CMake project </li><li>  I made the engine run on both Windows and iOS, because I like working in Visual Studio. </li><li>  Began to move the code to separate libraries "engine" and "game".  Over time, I divided them into even smaller libraries. </li><li>  I wrote a separate application to convert my JSON files to binary data that the game can load directly. </li><li>  At some point, removed all the SDL libraries from the iOS build.  (The build for Windows still uses SDL.) </li></ul><br><p>  The key point is this: <strong>I didn‚Äôt plan the engine architecture before I started programming</strong> .  It was a conscious choice.  Instead, I just wrote as simple as possible code that implements the next part of the functionality, then I looked at it to see which architecture arose naturally.  By "engine architecture" I mean the set of modules that make up the game engine, the dependencies between these modules and the <a href="https://ru.wikipedia.org/wiki/API">API</a> for interacting with each module. </p><br><p><img src="https://i.imgur.com/ccsOs8s.png"></p><br><p>  This approach is <a href="https://ru.wikipedia.org/wiki/%25D0%2598%25D1%2582%25D0%25B5%25D1%2580%25D0%25B0%25D1%2582%25D0%25B8%25D0%25B2%25D0%25BD%25D0%25B0%25D1%258F_%25D1%2580%25D0%25B0%25D0%25B7%25D1%2580%25D0%25B0%25D0%25B1%25D0%25BE%25D1%2582%25D0%25BA%25D0%25B0">iterative</a> because it focuses on small practical results.  It works well when writing a game engine, because at every step you have a working program.  If something goes wrong when you extract the code to a new module, you can always compare the changes with the code that worked before.  Of course, I assume that you are using some kind of <a href="https://www.perforce.com/blog/list-of-equivalent-commands-in-git-mercurial-and-svn">version control system</a> . </p><br><p>  It may seem that with this approach a lot of time is wasted, because you always write bad code, which you then need to rewrite completely.  But most of the changes are moving the code from one <code>.cpp</code> file to another, extracting function definitions to <code>.h</code> files or other equally simple actions.  Determining <em>where</em> that should lie is a difficult task, and it is easier to solve it when the code already exists. </p><br><p>  I bet that more time is spent with the opposite approach: try to think in advance about the architecture that will do everything you need.  Two of my favorite articles about the dangers of excessive engineering - <abbr title="Vicious circle of generalization"><a href="http://altdevblog.com/2011/04/01/vicious-circle-of-generalization/">The Vicious Circle of Generalization by</a></abbr> Tomash Dabrowski and Joel Spolsky's <abbr title="Don't let architectural astronauts intimidate you"><a href="https://www.joelonsoftware.com/2001/04/21/dont-let-architecture-astronauts-scare-you/">Don't Let Architecture Astronauts Scare You</a></abbr> . </p><br><p>  I'm not saying that you should not solve problems on paper before you run into them in code.  I also do not claim that you should not decide in advance what functionality you need.  For example, I knew from the very beginning that I wanted the engine to load all the resources in the background thread.  I just did not try to design or implement this functionality until my engine started loading at least some resources. </p><br><p>  The iterative approach gave me a much more elegant architecture than I could have imagined looking at a blank sheet of paper.  The iOS build of my engine today consists 100% of the original code, including its own math library, container templates, reflection / serialization system, rendering framework, physics, and audio mixer.  I had reasons to write each of these modules myself, but for you this may not be necessary.  Instead, there are many excellent open source libraries and licenses that may be suitable for your engine.  <a href="https://glm.g-truc.net/">GLM</a> , <a href="https://pybullet.org/wordpress/">Bullet Physics</a> and <a href="https://github.com/nothings/stb">STB headers</a> are just some of the interesting examples. </p><br><hr><br><h2>  Think twice before generalizing too much </h2><br><p>  As programmers, we strive to avoid duplication of code, and we like it when the code follows a uniform style.  Nevertheless, I think it is useful not to let these instincts control all decisions. </p><br><h3 id="vremya-ot-vremeni-narushayte-princip-dry">  Break DRY principle from time to time. </h3><br><p>  I will give an example: my engine contains several template classes of smart pointers that are close in spirit to <a href="http://ru.cppreference.com/w/cpp/memory/shared_ptr"><code>std::shared_ptr</code></a> .  Each of them helps to avoid memory leaks, speaking a wrapper around a raw pointer. </p><br><ul><li>  <code>Owned&lt;&gt;</code> for dynamically allocated objects that have a single owner. </li><li>  <code>Reference&lt;&gt;</code> uses reference counting to allow an object to have multiple owners. </li><li>  <code>audio::AppOwned&lt;&gt;</code> used by code outside the audio mixer.  This allows gaming systems to own objects that the audio mixer uses, such as the voice that is currently being played. </li><li>  <code>audio::AudioHandle&lt;&gt;</code> uses a reference counting system internal to the audio mixer. </li></ul><br><p>  It may seem that some of these classes duplicate the functionality of others, violating the <a href="https://ru.wikipedia.org/wiki/Don%25E2%2580%2599t_repeat_yourself">principle of DRY</a> .  In fact, at the beginning of development, I tried to reuse the existing <code>Reference&lt;&gt;</code> class as much as possible.  However, I found out that the lifetime of an audio object is subject to special rules: if an object has finished playing a fragment and the game does not own a pointer to this object, you can immediately place it in the queue for deletion.  If the game captured a pointer, then the audio object should not be deleted.  And if the game captured a pointer, but the owner of the pointer is destroyed before the replay is over, it must be canceled.  Instead of complicating <code>Reference&lt;&gt;</code> , I decided that it would be more practical to introduce separate classes of templates. </p><br><p>  95% of the time reusing existing code is the right way.  But if it starts to shackle you, or you find that you complicate something that was once simple, ask yourself: should not this part of the code base really be split in two. </p><br><h3 id="ispolzovat-raznye-soglasheniya-o-vyzove----eto-normalno">  Using different calling conventions is fine </h3><br><p>  One of the things I don‚Äôt like in Java is that it forces you to define every function within a class.  In my opinion, it is meaningless.  This may give your code a more uniform look, but also encourages over-complication and does not support the iterative approach I described earlier. </p><br><p>  In my C ++ engine, some functions belong to classes, and some do not.  For example, each opponent in the game is a class, and most of the opponent's behavior is implemented in this class, as one would expect.  On the other hand, <a href="https://stackoverflow.com/questions/7136449/shape-casting-a-capsule-against-convex-polyhedra">sphere casts</a> in my engine are executed by calling <code>sphereCast()</code> , functions in <code>physics</code> .  <code>sphereCast()</code> does not belong to any class - it is just part of the <code>physics</code> module.  I have a build system that manages dependencies between modules, which keeps the code sufficient (for me) well organized.  Wrapping this function in an arbitrary class in no way improves the organization of the code. </p><br><p>  And then there is <a href="https://en.wikipedia.org/wiki/Dynamic_dispatch">dynamic dispatch</a> , which is a form of <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D0%25BE%25D0%25BB%25D0%25B8%25D0%25BC%25D0%25BE%25D1%2580%25D1%2584%25D0%25B8%25D0%25B7%25D0%25BC_(%25D0%25B8%25D0%25BD%25D1%2584%25D0%25BE%25D1%2580%25D0%25BC%25D0%25B0%25D1%2582%25D0%25B8%25D0%25BA%25D0%25B0)">polymorphism</a> .  Often we need to call the function of an object, not knowing the exact type of this object.  The first impulse of a C ++ programmer is to define an abstract base class with virtual functions, then reload these functions in a derived class.  It works, but this is only one of the techniques.  There are other dynamic dispatching methods that do not add as much additional code, or have other advantages: </p><br><ul><li>  C ++ 11 introduced <a href="http://ru.cppreference.com/w/cpp/utility/functional/function"><code>std::function</code></a> , and this is a convenient way to store callback functions.  You can also write your own version of <code>std::function</code> , which does not cause so much pain when you enter it in the debugger. </li><li>  Many callback functions can be implemented using a pair of pointers: a function pointer and an opaque argument.  Only explicit casting inside the callback function is required.  This is often found in pure C libraries. </li><li>  Sometimes the base type is known at compile time, and you can bind a function call without any runtime overhead.  <a href="https://github.com/preshing/turf">Turf</a> , the library I use in my game engine, relies heavily on this method.  Take a look at <a href=""><code>turf::Mutex</code></a> for an example.  This is just a <code>typedef</code> over platform-specific classes. </li><li>  Sometimes the most direct way is to create and maintain a table of raw function pointers on your own.  I used this approach in my audio mixer and serialization system.  The Python interpreter also makes full use of this technique, as will be shown below. </li><li>  You can even store function pointers in a hash table, using function names as keys.  I use this technique to dispatch input events, such as multitouch events.  This is part of the strategy for recording game input and playing it in the replay system. </li></ul><br><p>  Dynamic scheduling is an extensive topic.  I only superficially talked about it to show how many ways there are to implement it.  The more extensible low-level code you write - which is not uncommon for the game engine - the more often you find yourself studying alternatives.  If you're not used to programming in this form, the Python interpreter written in C is a great example to learn.  It implements a powerful object model: each <code>PyObject</code> points to a <code>PyTypeObject</code> , and each <code>PyTypeObjet</code> contains a table of function pointers for dynamic dispatching.  The <a href="https://docs.python.org/3/extending/newtypes.html">Defining New Types</a> document is a good starting point if you want to get into the details right away. </p><br><hr><br><h2>  Realize serialization is a broad topic. </h2><br><p>  <a href="https://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25B5%25D1%2580%25D0%25B8%25D0%25B0%25D0%25BB%25D0%25B8%25D0%25B7%25D0%25B0%25D1%2586%25D0%25B8%25D1%258F">Serialization</a> is the conversion of runtime objects to a sequence of bytes and vice versa.  In other words, saving and loading data. </p><br><p>  For many, if not most, engines, game content is created in various editable ones, such as <code>.png</code> , <code>.json</code> , <code>.blend</code> or proprietary formats, then it is eventually converted into platform-specific game formats that the engine can quickly load.  The last application in this process is often called "cooker".  Cooker can be integrated into another tool or even distributed among several machines.  Usually, a cooker and a number of tools are developed and maintained in tandem with the game engine itself. </p><br><p><img src="https://i.imgur.com/tlU1xKO.png"></p><br><p>  When preparing such a pipeline, the choice of file formats at each of the stages remains with you.  You can define several proprietary formats, and they can evolve as you add functionality to the engine.  While they are evolving, you may need to maintain the compatibility of some programs with previously saved files.  No matter in what format, in the end you have to serialize them in C ++. </p><br><p>  In C ++, there are countless ways to organize serialization.  One of the fairly obvious ones is to add the <code>save</code> and <code>load</code> functions to the classes that you want to serialize.  You can achieve backward compatibility by storing the version number in the file header, then passing that number to each <code>load</code> function.  This works, although the code can become cumbersome. </p><br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">load</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(InStream&amp; in, u32 fileVersion)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   - in &gt;&gt; m_position; in &gt;&gt; m_direction; //           2. if (fileVersion &gt;= 2) { in &gt;&gt; m_velocity; } }</span></span></code> </pre> <br><p>  You can write more flexible, less error-prone serialization code by taking advantage of <a href="https://ru.wikipedia.org/wiki/%25D0%25A0%25D0%25B5%25D1%2584%25D0%25BB%25D0%25B5%25D0%25BA%25D1%2581%25D0%25B8%25D1%258F_(%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B3%25D1%2580%25D0%25B0%25D0%25BC%25D0%25BC%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5)">reflection</a> ‚Äî namely, creating runtime data describing the location of your C ++ types.  To get a quick idea of ‚Äã‚Äãhow reflection can help with serialization, take a look at how <a href="https://www.blender.org/get-involved/developers/">Blender</a> does it, an open source project. </p><br><p><img src="https://i.imgur.com/VLkDmk7.png"></p><br><p>  When you build Blender from source, many steps are taken.  First, the <code>makesdna</code> utility compiles and runs.  This utility parses a set of C header files in the Blender source tree, and then displays a brief summary of all the defined types in its own format, known as <a href="https://wiki.blender.org/index.php/Dev:Source/Architecture/SDNA_Notes">SDNA</a> .  These SDNA data serve as <strong>reflection data</strong> .  SDNA is then bundled with Blender itself, and saved with each <code>.blend</code> file that Blender writes.  From this point on, every time Blender loads a <code>.blend</code> file, it compares the SDNA <code>.blend</code> files from the SDNA linked to the current version at runtime and uses common serialization code to handle all the differences.  This strategy gives Blender an impressive range of backward and forward compatibility.  You <a href="https://www.blendernation.com/2008/12/01/blender-dna-rna-and-backward-compatibility/">can still download version 1.0 files</a> in the latest version of Blender, and new <code>.blend</code> files can be downloaded in older versions. </p><br><p>  Like Blender, many game engines ‚Äî and related tools ‚Äî create and use their own reflection data.  There are many ways to do this: you can parse your own C / C ++ source code to extract type information, as Blender does.  You can create a separate data description language and write a tool for generating type descriptions and C ++ reflection data from this language.  You can use preprocessor macros and C ++ templates to generate reflection data at runtime.  And as soon as you have these reflections at your fingertips, countless ways are opened to write a common serializer on top of all this. </p><br><p>  Sure, I miss a lot of detail.  In this article, I just wanted to show that there are many ways to serialize data, some of which are very complex.  Programmers simply do not discuss serialization as much as other engine systems, even though most other systems depend on it.  For example, out of 96 programmer reports of <a href="https://www.gdcvault.com/browse/gdc-17/%3Fcategories%3DPg">GDC 2017</a> , I counted 31 reports on graphics, 11 on online, 10 on tools, 3 on physics, 2 on audio ‚Äî and only one <a href="https://www.gdcvault.com/play/1024444/The-Data-Building-Pipeline-of">on serialization itself</a> . </p><br><p>  At a minimum, try to imagine how complex your requirements will be.  If you make a little game like Flappy Bird, with a few assets, you probably won't have to think much about serialization.  You can probably download textures directly from a PNG and that will be enough.  If you need a compact binary format with backward compatibility, but you do not want to develop your own - take a look at third-party libraries, such as <a href="https://uscilab.github.io/cereal/">Cereal</a> or <a href="https://theboostcpplibraries.com/boost.serialization">Boost.Serialization</a> .  I don‚Äôt think that <a href="https://developers.google.com/protocol-buffers/">Google Protocol Buffers are</a> ideal for serializing game resources, but they are still worth exploring. </p><br><p>  Writing a game engine - even a small one - is a big enterprise.  I could say a lot more, but honestly, the most useful advice I can come up with for an article of such length: work iteratively, resist slightly the code compilation, and remember that serialization is an extensive topic, so you will need to choose the right strategy .  My experience shows that each of these points can become a stumbling block if it is ignored. </p><br><p>  I like to compare observations on this topic, so I'm very interested to hear from other developers.  If you wrote the engine, did your experience lead to the same conclusions?  And if you don‚Äôt write or are still going, your thoughts are interesting to me too.  What do you think is a good learning resource?  What aspects still seem mysterious to you?  Feel free to leave comments below or contact me <a href="https://twitter.com/preshing">via Twitter</a> . </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/347052/">https://habr.com/ru/post/347052/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../347042/index.html">Kubeflow: a new project for working with machine learning in Kubernetes</a></li>
<li><a href="../347044/index.html">Step to quantum supremacy: Intel's 49-qubit quantum computer</a></li>
<li><a href="../347046/index.html">In the administration of Trump offered to nationalize 5G-network</a></li>
<li><a href="../347048/index.html">UK Internet Service Providers Stretch Optical Fiber to 3 Million Homes</a></li>
<li><a href="../347050/index.html">Battle of network neutrality: judicial wars and public protests</a></li>
<li><a href="../347056/index.html">Issue # 7: IT training - current issues and challenges from leading companies</a></li>
<li><a href="../347058/index.html">Facilitator with a diploma</a></li>
<li><a href="../347060/index.html">STO: dreams come true? And other reports for tmlidov with HighLoad ++</a></li>
<li><a href="../347062/index.html">Who is Data Scientist - through the eyes of the employer. Interview with Avito and Spice IT</a></li>
<li><a href="../347064/index.html">Creating a REST API on Falcon</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>