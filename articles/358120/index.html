<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Information exchange between working threads without pain? CSP channels to help us</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Developing a multithreaded code is a difficult task. Really difficult. Fortunately, high-level abstractions, such as task-based parallelism, map-reduc...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Information exchange between working threads without pain? CSP channels to help us</h1><div class="post__text post__text-html js-mediator-article">  Developing a multithreaded code is a difficult task.  Really difficult.  Fortunately, high-level abstractions, such as task-based parallelism, map-reduce / fork-join, CSP, actors, etc., have long been invented to simplify the lives of developers. <br><br>  But when you get to profile forums where C ++ nicknames communicate, you get the feeling that many are simply unaware of the presence of something simpler and more convenient than std :: thread coupled with std :: mutex + std :: condition_variable .  Regularly there are questions from the category: ‚ÄúI need to run several workflows, in one this is done, in the second this, and in the third this.  I run them like this, and exchange information between threads like this.  Am I doing right? " <br><br>  Obviously, such questions are asked by novices.  But, first, the number of inexperienced youth in software development has always been great, and with the growth of the attractiveness of the IT industry, this number only increases.  It‚Äôs sad that newbies know about std :: thread and std :: mutex, but don‚Äôt know about ready-made tools that could simplify their lives (like Intel TBB, HPX, QP / C ++, Boost.Fiber, FastFlow, CAF, SObjectizer, etc.). 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      And, secondly, among the answers to such questions are quite rare tips "take this ready-made tool, your task with its help is solved in just a few lines."  More often, people discuss the low-level details of self-made implementations of thread-safe message queues. <br><br>  All this suggests that it makes sense to show with simple examples how a particular framework can help in solving even small and seemingly simple tasks related to multithreading.  Since we are developing <a href="https://github.com/eao197/so-5-5">SObjectizer</a> as a tool to simplify the development of multi-threaded applications in C ++, today we will try to show how <a href="https://en.wikipedia.org/wiki/Communicating_sequential_processes">CSP</a> channels implemented in SObjectizer-e can save a developer from a part of the headache when writing multi-threaded code. <br><a name="habracut"></a><br><h1>  Simple demo </h1><br>  In this article we will look at a simple demo.  A small test application on the main thread of which there is a ‚Äúdialogue‚Äù with the user.  When the user enters the word "exit", the application is terminated. <br><br>  There are two additional workflows in the application.  One simulates a periodic "poll" of a certain sensor.  On the second workflow, the information ‚Äútaken‚Äù from the sensor is ‚Äúwritten‚Äù to the file. <br><br>  Naturally, no real work with the sensor and data files is performed; instead, the program organizes delays that block the working thread for some time.  This simulates synchronous work with external devices and files. <br><br>  Let such a rough imitation of the reader does not bother.  The purpose of the article is to show the interaction between the workflows via CSP channels (which are called <a href="https://www.slideshare.net/YauheniAkhotnikau/dive-into-sobjectizer-55-ninth-part-message-chains">mchains</a> in SObjectizer), and not to fill the worker threads with actual content. <br><br><h2>  The principle of the example "on the fingers" </h2><br>  So, in our example, in addition to the main thread there are two additional working threads. <br><br>  The first working thread, which we will call meter_reader_thread, is for ‚Äúpolling‚Äù the sensor.  This thread needs two mchains.  The first mchain will be used to send commands to the thread meter_reader_thread itself.  In particular, a message of type acquisition_turn will be placed on this channel by timer, upon receiving which meter_reader_thread will conduct a ‚Äúsurvey‚Äù. <br><br>  The second mchain is needed by meter_reader_thread in order to transmit the information ‚Äútaken‚Äù from the sensor of the second working thread.  The second working thread, which we will call file_writer_thread, is responsible for ‚Äúwriting‚Äù information to the file.  The second working thread reads from the mchain command to write information and "executes" them.  As long as there are no commands in mchain, the file_writer_thread thread is sleeping awaiting a new command. <br><br>  It turns out such a simple scheme: <br><br><img src="https://habrastorage.org/webt/rv/rr/lu/rvrrlucikthmpiw0fszjyoqsu1y.png"><br><br>  Work of both threads is completed as soon as mchains are closed in the main worker thread. <br><br><h2>  Parsing simple example text </h2><br>  <a href="">The full source code of a</a> simple example can be viewed in the <a href="https://bitbucket.org/sobjectizerteam/so5_lor_two_thread_demo_ru">repository</a> created for illustration.  We will go from simple to complex.  We start the analysis with functions that perform the work of the file_writer_thread and meter_reader_thread threads, and then we will look at the implementation of the main () function, in which we will have to take into account a number of tricks related to multithreading. <br><br><h3>  Function file_writer_thread () </h3><br>  The file_writer_thread () function is the simplest in this example.  Here is its full text: <br><br><pre><code class="hljs ruby">/<span class="hljs-regexp"><span class="hljs-regexp">/ ,    . void file_writer_thread( /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/        . so_5::mchain_t file_write_ch) { /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/       ,    . /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/        receive. receive(from(file_write_ch), /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/         /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   write_data. [&amp;](so_5::mhood_t&lt;write_data&gt; cmd) { /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    . std::cout &lt;&lt; cmd-&gt;file_name_ &lt;&lt; ": write started" &lt;&lt; std::endl; std::this_thread::sleep_for(350ms); std::cout &lt;&lt; cmd-&gt;file_name_ &lt;&lt; ": write finished" &lt;&lt; std::endl; }); }</span></span></code> </pre> <br>  All that file_writer_thread () does is hang inside the receive () call.  The receive () function waits for a message to arrive on the channel and, when a message arrives on the channel, looks for a handler for this message among those handlers that are sent to receive (). <br><br>  In this case, only one handler is passed - for a message of type write_data.  When a message of this type enters the channel, this handler is called.  Inside this handler, in essence, all the ‚Äúbusiness logic‚Äù is collected, i.e.  Imitation of writing read data to a file. <br><br>  The receive () function in SObjectizer has two versions.  The first version, which we did not use in this example, waits for and retrieves only one message from the channel.  The second version, which is shown above, extracts all messages from the channel and returns control only when the channel is closed.  Those.  in this case, the output from file_writer_thread () will occur only when the receive () call completes.  And this happens when someone closes the file_write_ch channel. <br><br><h3>  Function meter_reader_thread () </h3><br>  The meter_reader_thread function is somewhat more complicated: <br><br><pre> <code class="hljs ruby">/<span class="hljs-regexp"><span class="hljs-regexp">/     . void meter_reader_thread( /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ ,    . so_5::mchain_t timer_ch, /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ ,        . so_5::mchain_t file_write_ch) { /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/      . struct acquisition_turn : public so_5::signal_t {}; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   .      . int ordinal = 0; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  . auto timer = so_5::send_periodic&lt;acquisition_turn&gt;(timer_ch, 0ms, 750ms); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/       ,    . /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/        receive. receive(from(timer_ch), /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/         /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   acquire_turn. [&amp;](so_5::mhood_t&lt;acquisition_turn&gt;) { /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   . std::cout &lt;&lt; "meter read started" &lt;&lt; std::endl; std::this_thread::sleep_for(50ms); std::cout &lt;&lt; "meter read finished" &lt;&lt; std::endl; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/      . so_5::send&lt;write_data&gt;(file_write_ch, "data_" + std::to_string(ordinal) + ".dat"); ++ordinal; }); }</span></span></code> </pre> <br>  Here we, first, determine the type of signal acquisition_turn, which will come to us from time to time so that we can perform a simulation of the ‚Äúsurvey‚Äù of the sensor. <br><br>  Secondly, we launch this most periodic acquisition_turn signal by calling send_periodic ().  Thanks to this, SObjectizer will send acquisition_turn to timer_ch every 750ms. <br><br>  Well, after that, the familiar call to us will receive () from which we will exit only when the channel timer_ch is closed.  Inside receive () we have implemented our signal acquisition_turn handler.  In this handler, we simulate a ‚Äúpoll‚Äù of the sensor, and then give the command to write the ‚Äúcollected‚Äù data of the file_writer_thread thread by sending the write_data message to the file_write_ch channel. <br><br>  So it turns out that meter_reader_thread sleeps all the time inside receive (), wakes up periodically when receiving acquisition_turn, then sends the write_data message to file_write_ch (that is, to the file_writer_thread thread) and goes back to sleep before the next acquisition_turn.  Or until the timer_ch is closed. <br><br><h3>  Main () function </h3><br>  Before looking at the main () code, you need to describe a few small subtleties, without a discussion of which some of this code may not be clear. <br><br>  The main problem that has to be solved when working with threads and CSP channels is the correct and timely completion of working threads.  Those.  if we create an instance of std :: thread and start a working thread with it, then we will have to call std :: thread :: join () to wait for the completion of the working thread (detached threads are not used here).  The easiest way is to manually call std :: thread :: join () at the end of the main () function.  Sort of: <br><br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ ... <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::thread file_writer{file_writer_thread}; ... file_writer.join(); }</code> </pre> <br>  But the bad thing is that such a naive approach does not protect us from exceptions or other forms of premature exit from the skoup (for example, the usual return). <br><br>  Here we could be helped by some kind of auxiliary class that would call std :: thread :: join () in its destructor.  For example, we could do something like: <br><br><pre> <code class="hljs ruby"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">auto_joiner</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std::thread</span></span></span><span class="hljs-class"> &amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">t_</span></span></span><span class="hljs-class">;</span></span> ... /<span class="hljs-regexp"><span class="hljs-regexp">/   /</span></span>. <span class="hljs-symbol"><span class="hljs-symbol">public:</span></span> auto_joiner(std::thread &amp; t) : t<span class="hljs-number"><span class="hljs-number">_</span></span>{t} {} ~auto_joiner() { t<span class="hljs-number"><span class="hljs-number">_</span></span>.join(); } }; int main() { ... std::thread file_writer{file_writer_thread}; auto_joiner file_writer_joiner{file_writer}; ... }</code> </pre> <br>  When using a SObjectizer, there is no need to write such an auto_joiner yourself, since SObjectizer already has a similar tool.  We will see its use in the main () code.  It differs from the one shown above in that it can call join () not for one object of std :: thread, but for several. <br><br>  But besides calling std :: thread :: join (), in order to correctly stop the working thread in our example, we need to take into account one more thing: in order for the thread inside which receive () is called to complete its work, you must close mchain.  If this is not done, the return from receive () will not occur and we will fall asleep forever on the call to std :: thread :: join (). <br><br>  This means that we should take care of automatically closing the mchains when exiting main ().  And here we will use the same approach as with the call to std :: thread :: join (): let's use the auxiliary object, which in its destructor calls close () for mchain.  Those.  we will do something like: <br><br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ ... <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> ch = so_5::create_mchain(...); auto_closer ch_closer{ch}; ... }</code> </pre> <br>  Again, we don‚Äôt need to do our implementation of this auxiliary class auto_closer, because  SObjectizer is already ready. <br><br>  We have already figured out how to relinquish ourselves on call join () for worker threads and automatic closing mchains.  But there is one more very important point: in what order these operations should be performed.  Because, if we write just such a simple and clear sequence: <br><br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ ... <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> ch = so_5::create_mchain(...); auto_closer ch_closer{ch}; ... <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::thread work_thread{[ch]{ receive(from(ch), ...); }}; auto_joiner work_thread_joiner{work_thread}; ... }</code> </pre> <br>  then we get the classic deadlock and hangup in the auto_joiner destructor. <br><br>  The problem is that the auto_joiner destructor is called before the auto_closer destructor.  Those.  we will try to join for the working thread, which hangs on receive () from the not yet closed mchain. <br><br>  Therefore, in order for mchains to automatically close before join () is called for a working thread, you need to change the order in which the entities are created in the program: <br><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ... <span class="hljs-comment"><span class="hljs-comment">//    .       . std::thread work_thread; auto_joiner work_thread_joiner{work_thread}; ... //       . auto ch = so_5::create_mchain(...); auto_closer ch_closer{ch}; ... //       . work_thread = std::thread{[ch]{ receive(from(ch), ...); }}; ... }</span></span></code> </pre> <br>  And now, after explaining the main nuances, you can look at the code for the main () function itself: <br><br><pre> <code class="hljs ruby">int main() { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  SObjectizer. so_5::wrapped_env_t sobj; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> -     ... std::thread meter_reader, file_writer; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> ...      joiner. /<span class="hljs-regexp"><span class="hljs-regexp">/     join()      /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ main.    ,      main : /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ -    - /</span></span>. auto joiner = so_5::auto_join(meter_reader, file_writer); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  ,     . auto timer_ch = so_5::create_mchain(sobj); auto writer_ch = so_5::create_mchain(sobj); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>         main. /<span class="hljs-regexp"><span class="hljs-regexp">/    ,       /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ receive()  join()    . auto closer = so_5::auto_close_drop_content(timer_ch, writer_ch); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/      . meter_reader = std::thread(meter_reader_thread, timer_ch, writer_ch); file_writer = std::thread(file_writer_thread, writer_ch); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/        exit  /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/      . std::cout &lt;&lt; "Type 'exit' to quit:" &lt;&lt; std::endl; std::string cmd; while(std::getline(std::cin, cmd)) { if("exit" == cmd) break; else std::cout &lt;&lt; "Type 'exit' to quit" &lt;&lt; std::endl; } /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   main.      /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ (  closer),      /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ (  joiner). return 0; }</span></span></code> </pre> <br>  I hope that basically this code is clear.  And explanations may be required unless for two small moments. <br><br>  First, it is the creation of an instance of so_5 :: wrapped_env_t at the beginning of main.  Behind this instance will be hidden <a href="https://habr.com/post/354508/">SObjectizer Environment</a> .  And we need the SObjectizer Environment both for creating mchains and for servicing timers (the send_periodic () call in meter_reader_thread hides in itself an appeal to the SObjectizer ov timer). <br><br>  The second is the auto_close_drop_content call.  On the one hand, it‚Äôs understandable: this function returns an auto_closer object, which automatically closes the mchains in its destructor.  But, on the other hand, what does drop_content mean in the name of this function? <br><br>  The fact is that in SObjectizer you can close mchain in two modes.  In the first mode, mchain is closed with discarding all messages in the mchain that have not yet been processed by the receive () functions.  For example, at the time of calling close (), there are 100500 messages in mchain.  All these messages will be destroyed and they will not get to the recipients.  This mode is called drop_content and the auto_close_drop_content function just creates auto_closer, which will close mchain in drop_content mode. <br><br>  The second mode of closing mchain, on the contrary, saves all messages in mchain.  This allows the receive () function to finish processing the contents of mchain.  But here it will be impossible to add new messages to mchain, because  mchain is already closed (for writing).  This mode is called, respectively, retain_content. <br><br>  Both the mchain, drop_content and retain_content close modes are good in different situations.  In this example, we need drop_content, which is why auto_close_drop_content is used. <br><br><h2>  The result of the first example </h2><br>  If we run our first example, we will see the expected picture: <br><br><img src="https://habrastorage.org/webt/ng/po/7e/ngpo7e7biene8gqh0-sns0gha_i.jpeg"><br><br>  We here see consistent "polls" and "record" of the results of these "polls". <br><br><h1>  The complication of a simple example: control the load on file_writer_thread </h1><br><blockquote>  The full source code of the second example can be found <a href="">here</a> . </blockquote><br>  The first version of our example turned out to be very idealized: we believe that the recording of the data ‚Äútaken‚Äù from the sensor will always be completed by the next ‚Äúsurvey‚Äù.  But in real life, most likely, the time of operations with external devices can ‚Äúfloat‚Äù in rather wide limits.  This means that it would make sense for us to take care of the situation when the ‚Äúwriting‚Äù to the file takes longer and messages will accumulate in the mchain with the write_data messages. <br><br>  In order to simulate a similar situation, slightly modify the already shown above functions meter_reader_thread () and file_writer_thread ().  In meter_reader_thread (), just increase the acquisition_turn signal acquisition rate: <br><br><pre> <code class="hljs xml">auto timer = so_5::send_periodic<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">acquisition_turn</span></span></span><span class="hljs-tag">&gt;</span></span>(timer_ch, 0ms, 300ms);</code> </pre> <br>  But in file_writer_thread () we make it so that the time of the ‚Äúwrite‚Äù operation is chosen randomly from the range [295ms, 1s].  Those.  sometimes the operation of ‚Äúrecording‚Äù will fall within the intervals between ‚Äúpolls‚Äù, but in most cases it will not.  Sometimes it will not fit very much.  So, this is how we modify file_writer_thread (): <br><br><pre> <code class="hljs markdown">// ,    . void file<span class="hljs-emphasis"><span class="hljs-emphasis">_writer_</span></span>thread( //        . so<span class="hljs-emphasis"><span class="hljs-emphasis">_5::mchain_</span></span>t file<span class="hljs-emphasis"><span class="hljs-emphasis">_write_</span></span>ch) { //      . std::mt19937 rd<span class="hljs-emphasis"><span class="hljs-emphasis">_gen{std::random_</span></span>device{}()}; //         //  [<span class="hljs-string"><span class="hljs-string">295ms, 1s</span></span>]. std::uniform<span class="hljs-emphasis"><span class="hljs-emphasis">_int_</span></span>distribution<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">int</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> rd<span class="hljs-emphasis"><span class="hljs-emphasis">_dist{295, 1000}; //       ,    . //        receive. receive(from(file_</span></span>write<span class="hljs-emphasis"><span class="hljs-emphasis">_ch), //         //   write_</span></span>data. [<span class="hljs-string"><span class="hljs-string">&amp;</span></span>](<span class="hljs-link"><span class="hljs-link">so_5::mhood_t&lt;write_data&gt; cmd</span></span>) { //     "". const auto pause = rd<span class="hljs-emphasis"><span class="hljs-emphasis">_dist(rd_</span></span>gen); //    . std::cout <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;&lt; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">cmd-</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span>file<span class="hljs-emphasis"><span class="hljs-emphasis">_name_</span></span> <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;&lt; "</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">:</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">write</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">started</span></span></span></span><span class="xml"><span class="hljs-tag"> (</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">pause:</span></span></span></span><span class="xml"><span class="hljs-tag">" &lt;&lt; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">pause</span></span></span></span><span class="xml"><span class="hljs-tag"> &lt;&lt; "</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">ms</span></span></span></span><span class="xml"><span class="hljs-tag">)" &lt;&lt; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">std::endl</span></span></span></span><span class="xml"><span class="hljs-tag">; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">std::this_thread::sleep_for</span></span></span></span><span class="xml"><span class="hljs-tag">(</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">std::chrono::milliseconds</span></span></span></span><span class="xml"><span class="hljs-tag">{</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">pause</span></span></span></span><span class="xml"><span class="hljs-tag">}); </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">std::cout</span></span></span></span><span class="xml"><span class="hljs-tag"> &lt;&lt; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">cmd-</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span>file<span class="hljs-emphasis"><span class="hljs-emphasis">_name_</span></span> <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;&lt; "</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">:</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">write</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">finished</span></span></span></span><span class="xml"><span class="hljs-tag">" &lt;&lt; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">std::endl</span></span></span></span><span class="xml"><span class="hljs-tag">; }); }</span></span></span></span></code> </pre> <br>  It turns out that raw write_data messages can now accumulate in file_write_ch.  There is a problem of congestion that is widely known in narrow circles: this is when a data provider generates new data with a higher rate than the data consumer is able to handle.  The problem is unpleasant, you need to fight it. <br><br>  For example, it is possible to implement the back pressure mechanism.  Those.  when the data provider begins to overload the consumer, the consumer in one way or another lets the supplier know about it.  In the case of CSP shny channels, a completely natural way to implement ‚Äúback pressure‚Äù would be to block the data provider for writing to the channel until the consumer is free enough to accept the next piece of data from the supplier. <br><br><blockquote>  By the way, in this respect, the CSP Model in some data processing scenarios is much more convenient than the Actor Model.  Indeed, in the Model of Actors, the data exchange between the supplier and the consumer is carried out only through asynchronous messages.  Those.  the supplier, sending the next message to the consumer, does not know how much the consumer is loaded, whether the next message will lead to overload and, if it does, how long it takes to wait before sending the next message.  Whereas in the CSP Model of the supplier, you can ‚Äúput down‚Äù to write to the channel and ‚Äúwake up‚Äù the supplier after the consumer has dealt with his load. </blockquote>  So, we would like the supplier, i.e.  In our case, meter_reader_thread, fell asleep if file_writer_thread does not have time to parse and process the messages previously sent to file_write_ch.  Can SObjectizer mchains provide us with this? <br><br>  Yes. <br><br>  To do this, you need to set additional properties for mchain while creating mchain.  In the first version of our example, we created mchain in the simplest way, like this: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">auto</span></span> writer_ch = so_5::create_mchain(sobj);</code> </pre> <br>  In this case, a ‚Äúdimensionless‚Äù channel is created, as many messages can be pushed into such a channel as the size of free RAM allows. <br><br>  Since we want "back pressure", the "dimensionless" channel does not suit us.  So we need to limit the number of messages that can wait in the channel of its processing. <br><br>  We also want the information provider to fall asleep while trying to write to the completed channel.  There are no problems with this, but in SObjectizer you need to set an upper bound for such an expectation.  For example, fall asleep while trying to write to the channel, but sleep no more than five seconds (or five hours, it depends on the task). <br><br>  SObjectizer requires the developer to limit the maximum waiting time for recording into the filled channel, because without such a limit it is easy to catch deadlock.  Say, the T1 thread is trying to write a message to the overflow channel C1 for the T2 thread, which at this moment is trying to write a message to the overflowed channel C2 for the T3 thread.  And at this moment the thread T3 is trying to write a message to the crowded channel C0 for the thread T1.  In the case of a limit on the maximum waiting time, such a deadlock will eventually be broken automatically. <br><br>  So, we set the size of the channel and the maximum wait time, but the question remains: ‚ÄúWhat should I do with the recording operation in a crowded channel if the channel is not free even after waiting?‚Äù <br><br>  In SObjectizer, you can choose what to do if the channel is not free even after waiting.  For example, you can throw away the oldest message that is in the channel.  Or you can ignore the new message that we tried to insert into the channel.  Or you can make the send () function throw an exception in this case. <br><br>  In our example, we use the following reaction: discarding the oldest message.  In this case, it is quite logical, since  we already have ‚Äúnew data‚Äù from the sensor, their recording is more relevant than storing old data.  Therefore, in the updated example, we will create a channel for write_data messages as follows: <br><br><pre> <code class="hljs ruby">/<span class="hljs-regexp"><span class="hljs-regexp">/        ,   /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/      mchain      /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ ,       . auto writer_ch = so_5::create_mchain(sobj, /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/      300ms. 300ms, /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   mchain-    2- . 2, /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   mchain  . so_5::mchain_props::memory_usage_t::preallocated, /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    mchain-     , /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/       mchain-. so_5::mchain_props::overflow_reaction_t::remove_oldest);</span></span></code> </pre> <br>  Additional explanation can be given unless the argument so_5 :: mchain_props :: memory_usage_t :: preallocated.  This argument determines how memory will be allocated for queuing messages within the channel itself.  Since  the channel we have is fixed and small, then it makes sense to allocate space for the message queue immediately.  What we are doing in this case. <br><br><h2>  Thread Channel Limit meter_reader_thread </h2><br>  In the second example, we limited the channel size for write_data messages.  But we also have a channel for acquisition_turn signals.  Maybe it makes sense to limit it as well? <br><br>  Indeed, there is meaning.  It is generally enough for us to have a single message capacity for acquisition_turn.  If the acquisition_turn signal is already in the channel, then there is no point in adding a new one. <br><br>  Therefore, we modify the code snippet in which we create this channel: <br><br><pre> <code class="hljs ruby">/<span class="hljs-regexp"><span class="hljs-regexp">/        , /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/        mchain    /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   . auto timer_ch = so_5::create_mchain(sobj, /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/      . 1, /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   mchain  . so_5::mchain_props::memory_usage_t::preallocated, /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   ,     . so_5::mchain_props::overflow_reaction_t::drop_newest);</span></span></code> </pre> <br>  Here we see two important differences: <br><br><ul><li>  Firstly, there is no waiting for an attempt to add a message to the completed channel.  This expectation is meaningless.  In addition, because  The acquisition_turn is placed on the channel with a SObjectizer timer.  And this timer, in principle, cannot ‚Äúfall asleep‚Äù on an attempt to add a message to the full channel (otherwise the timer will not be able to do its job normally); </li><li>  secondly, in order to react to overflow, we prescribe ignoring the most recent message.  Those.  if the timer tries to add a new instance of the acquisition_turn signal to the full channel, then this new instance will be ignored, as if it was not at all. </li></ul><br><h2>  The result of the second example </h2><br>  When we run the second example, we can already see the following picture: <br><br><img src="https://habrastorage.org/webt/e4/mi/kh/e4mikhbuelho1jvdvouxiimv2dq.jpeg"><br><br>  You can see that some of the numbers from the debug print thread file_writer_thread disappeared.  For example, after the data_24.dat record, the data_26.dat record follows.  And there is no data_25.dat record.  This is because the write_data message for data_25.dat was thrown from the channel when it was full. <br><br>  In addition, we can see that when the file_writer_thread thread for a long time "leaves" the record, during this time the meter_reader_thread thread manages to conduct several "polls". <br><br><h1>  Let's complicate the example again: add control meter_reader_thread </h1><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The full source code of the third example can be found </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">here</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You can not deny yourself the temptation to complicate the example again: this time add the ability to manage the thread meter_reader_thread. </font><font style="vertical-align: inherit;">Indeed, why not make it possible to increase or decrease the period of "polling" the sensor? </font><font style="vertical-align: inherit;">Let's do it and do it. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let the main thread now, in the process of dialogue with the user, understand not only the 'exit' command (terminate the application), but also the 'inc' command (lengthen the polling period by 1.5 times) and 'dec' (shorten the polling period by 1.5 times). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The main issue that we have to solve in this case is the question of the delivery of the inc and dec commands from the main thread of the application to the meter_reader_thread thread. </font><font style="vertical-align: inherit;">But in fact - this is not a question. </font><font style="vertical-align: inherit;">We will simply generate two new signals:</font></font><br><br><pre> <code class="hljs ruby">/<span class="hljs-regexp"><span class="hljs-regexp">/ ,         /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   . struct dec_read_period : public so_5::signal_t {}; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ ,         /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   . struct inc_read_period : public so_5::signal_t {};</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The main thread will send these signals to the appropriate channel when the user enters this or that command: </font></font><br><br><pre> <code class="hljs pgsql">//        <span class="hljs-keyword"><span class="hljs-keyword">exit</span></span>  //      . <span class="hljs-type"><span class="hljs-type">bool</span></span> stop_execution = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!stop_execution) { std::cout &lt;&lt; "Type 'exit' to quit, 'inc' or 'dec':" &lt;&lt; std::endl; std::string cmd; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(std::getline(std::cin, cmd)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>("exit" == cmd) stop_execution = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>("inc" == cmd) so_5::send&lt;inc_read_period&gt;(control_ch); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>("dec" == cmd) so_5::send&lt;dec_read_period&gt;(control_ch); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> stop_execution = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But which channel exactly will we send these signals to? </font><font style="vertical-align: inherit;">This question is much more interesting. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In principle, we could use the same channel for periodic acquisition_turn, and for inc_ / dec_read_period. </font><font style="vertical-align: inherit;">But in order to show that SObjectizer is still able to work with mchain, we will use two different channels for meter_reader_thread:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the first channel, conditionally called control_ch, will be used for inc_ / dec_read_period commands. </font><font style="vertical-align: inherit;">This will be the easiest mchain without any restrictions;</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the second channel, conditionally called timer_ch, will be used for acquisition_turn signals. </font><font style="vertical-align: inherit;">This will already be a channel with a fixed size and a policy of ignoring new messages in case of overflow.</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> For ease of implementation of the third example, both of these channels will be created and closed in the main () function, and in the meter_reader_thread () function they will be passed as parameters: </font></font><br><br><pre> <code class="hljs ruby">/<span class="hljs-regexp"><span class="hljs-regexp">/  ,     . /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    meter_reader_thread.  - . auto control_ch = so_5::create_mchain(sobj); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ ,      acquisition_turn. auto timer_ch = so_5::create_mchain(control_ch-&gt;environment(), /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/      . 1, /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   mchain  . so_5::mchain_props::memory_usage_t::preallocated, /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   ,     . so_5::mchain_props::overflow_reaction_t::drop_newest); ... /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/         main. /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    ,       /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ receive()  join()    . auto closer = so_5::auto_close_drop_content(control_ch, timer_ch, writer_ch); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/      . meter_reader = std::thread(meter_reader_thread, control_ch, timer_ch, writer_ch); ...</span></span></code> </pre> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Modified version of meter_reader_thread () function </font></font></h2><br> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The meter_reader_thread () function</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> will grow significantly in size, since now it should perform more actions. And although I myself do not really like the functions, the text of which does not fit on one screen, in this case I had to write such a voluminous function, so as not to smear fragments of business logic on auxiliary functions. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Compared with the first and second examples, in the third example there were two fundamentally important changes in meter_reader_thread.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">First, now the ‚Äúpolling‚Äù period of the sensor may change. Because of this, it is not profitable for us to run acquisition_turn as a periodic message. You have to restart it each time when the period changes. Therefore, now we will go another way: when processing the next acquisition_turn, we will note the time spent on the next ‚Äúpoll‚Äù and sending write_data. After that, either we will immediately send ourselves the acquisition_turn without delay, if we spent too much time on the ‚Äúsurvey‚Äù. Or we will send a deferred acquisition_turn, while the delay in delivery will be the delta between the current polling period and the actual elapsed time. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We will have the following acqusition_turn processing fragment:</font></font><br><br><pre> <code class="hljs pgsql">//         //   acquire_turn. [&amp;](so_5::mhood_t&lt;acquisition_turn&gt;) { //   ,      //  .   . const auto started_at = std::chrono::steady_clock::now(); //   . std::cout &lt;&lt; "meter read started" &lt;&lt; std::endl; std::this_thread::sleep_for(<span class="hljs-number"><span class="hljs-number">50</span></span>ms); std::cout &lt;&lt; "meter read finished" &lt;&lt; std::endl; //      . so_5::send&lt;write_data&gt;(file_write_ch, "data_" + std::to_string(ordinal) + ".dat"); ++ordinal; //         // . const auto duration = std::chrono::steady_clock::now() - started_at; //    ,    //   . <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(duration &gt;= current_period) { std::cout &lt;&lt; "period=" &lt;&lt; current_period.count() &lt;&lt; "ms, no sleep" &lt;&lt; std::endl; so_5::send&lt;acquisition_turn&gt;(timer_ch); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { //        "". const auto sleep_time = to_ms(current_period - duration); std::cout &lt;&lt; "period=" &lt;&lt; current_period.count() &lt;&lt; "ms, sleep=" &lt;&lt; sleep_time.count() &lt;&lt; "ms" &lt;&lt; std::endl; so_5::send_delayed&lt;acquisition_turn&gt;(timer_ch, current_period - duration); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Secondly, we now have to wait for the message not from one channel, but from two at once. To which channel the message came first, from this we must take the message and process the message taken. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To do this, we will use the so_5 :: select () function, which is similar to the previously shown so_5 :: receive (). But, unlike receive (), the select () function can wait for incoming messages from several channels. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As a result, in meter_reader_thread we make the following call to select () (schematically, omitting the details of the implementations of the handlers):</font></font><br><br><pre> <code class="hljs markdown">//       ,    . so<span class="hljs-emphasis"><span class="hljs-emphasis">_5::select(so_</span></span>5::from<span class="hljs-emphasis"><span class="hljs-emphasis">_all(), //     . case_</span></span>(timer<span class="hljs-emphasis"><span class="hljs-emphasis">_ch, //         //   acquire_</span></span>turn. [<span class="hljs-string"><span class="hljs-string">&amp;</span></span>](<span class="hljs-link"><span class="hljs-link">so_5::mhood_t&lt;acquisition_turn&gt;</span></span>) { ... //  . }), //     . case<span class="hljs-emphasis"><span class="hljs-emphasis">_(control_</span></span>ch, //    . [<span class="hljs-string"><span class="hljs-string">&amp;</span></span>](<span class="hljs-link"><span class="hljs-link">so_5::mhood_t&lt;inc_read_period&gt;</span></span>) { ... //  . }, //    . [<span class="hljs-string"><span class="hljs-string">&amp;</span></span>](<span class="hljs-link"><span class="hljs-link">so_5::mhood_t&lt;dec_read_period&gt;</span></span>) { ... //  . }) );</code> </pre> <br>  Those.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">we say select () should wait for messages from all of the channels listed below until all channels are closed. </font><font style="vertical-align: inherit;">Then, in the case_ sections, there is an enumeration of channels (one channel per section) and a list of handlers for messages from each channel. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So, from the timer_ch channel, we process only the acquisition_time signal, and from the control_ch channel - the inc_read_period and dec_read_period signals. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It turns out that in the third example, the meter_read_thread () function returns control only after the control returns select (). </font><font style="vertical-align: inherit;">And select () ends when both timer_ch and control_ch are closed. </font><font style="vertical-align: inherit;">What happens in main () - e at the completion of the application.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The result of the third example </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> When running the third example and issuing several inc commands, we can see the following picture: </font></font><br><br><img src="https://habrastorage.org/webt/g5/00/bs/g500bszckmntdjlcf4ppcwyzzqe.jpeg"><br><br><h1>  Conclusion </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We are developing SObjectizer as a tool to simplify the development of multi-threaded applications, and not as an implementation of any one approach to the problem of concurrent computing. Therefore, in SObjectizer you can find traces of the Actor Models, and Publish / Subscribe, and CSP. Earlier we talked more about the part of SObjectizer, which belongs to the Actors and Pub / Sub models. Today we tried to briefly introduce the reader to CSP channels. This is the second attempt, the </font></font><a href="https://habr.com/post/336854/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">first was last year</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If there is something incomprehensible in our story, we will be happy to answer questions in the comments. If someone wants us to illustrate something from the narrated picture / scheme, then tell me what it is - we will try to make the appropriate illustration and add it to the text.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It is possible that the example shown to someone will seem uninteresting and divorced from life. </font><font style="vertical-align: inherit;">Still, our goal was his clarity. </font><font style="vertical-align: inherit;">But, if someone from the readers can offer another, more vital example in order to illustrate his decision with the help of CSP-shny channels, then we will try to make the solution of the example offered by the readers and describe this decision in subsequent articles. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Well, at the end of the article we suggest everyone to try </font></font><a href="https://github.com/eao197/so-5-5"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SObjectizer</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in and share their impressions. </font><font style="vertical-align: inherit;">Feedback is very important for us and your wishes / comments allow us to develop SObjectizer and make it more powerful and more convenient.</font></font></div><p>Source: <a href="https://habr.com/ru/post/358120/">https://habr.com/ru/post/358120/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../358110/index.html">Chinese hackers are behind numerous hacks of international companies</a></li>
<li><a href="../358112/index.html">The transition to domestic software, installation "megasiens" and attracting leading foreign scientists: a plan for breakthrough development of the Russian Federation</a></li>
<li><a href="../358114/index.html">We invite you to Android-meetup SuperJob</a></li>
<li><a href="../358116/index.html">Monitoring network traffic on servers in the cloud</a></li>
<li><a href="../358118/index.html">AI, practical course. Foreword</a></li>
<li><a href="../358122/index.html">8088 MPH: we will break all your emulators</a></li>
<li><a href="../358124/index.html">How to make a configuration file of routes in React Router 4 (subtitles)</a></li>
<li><a href="../358126/index.html">Briefly about Shadowsocks, or OpenVPN is not needed (in every home)</a></li>
<li><a href="../358128/index.html">Detection of criminal groups stealing from stores - Data Mining</a></li>
<li><a href="../358130/index.html">RKN unlocks 3.5 million Google IPs</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>