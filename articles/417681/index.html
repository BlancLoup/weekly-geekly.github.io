<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Dive into Ethereum development. Part 5: Oraclize</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Access to large files and various external dynamic data is often a very important part of a decentralized application. At the same time, Ethereum does...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Dive into Ethereum development. Part 5: Oraclize</h1><div class="post__text post__text-html js-mediator-article">  Access to large files and various external dynamic data is often a very important part of a decentralized application.  At the same time, Ethereum does not provide for the mechanism of circulation to the outside itself - smart contracts can read and write only within the framework of the blockchain itself.  In this article we will consider Oraclize, which just gives the opportunity to interact with the outside world by querying virtually any Internet resources.  A related topic is IPFS, briefly mentioning it. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/sp/_k/1m/sp_k1m_ob9-qh3_yiiyhmtecypu.jpeg"></div><br><a name="habracut"></a><br><h2>  IPFS </h2><br>  <a href="https://ipfs.io/">IPFS</a> is a distributed file system with content addressing.  This means that the content of any file added there is considered a unique hash.  The same hash is then used to search and retrieve this content from the network. <br>  The main information is already described in <a href="https://habr.com/post/314768/">this article</a> and in several others, so there is no point in repeating. <br><br><h3>  Why use IPFS in conjunction with Ethereum? </h3><br>  Any volumetric content stored on the blockchain is too expensive and harmful to the network.  Therefore, the best option is to save any link to the file that is located in the off-line repository, not necessarily IPFS.  But IPFS has several advantages: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  A file reference is a hash that is unique for a specific file content, so if we put this hash on the blockchain, then we can be sure that the file received from it is the one that was originally added, the file cannot be changed. </li><li>  Distributed system insures against the inaccessibility of a specific server (due to blocking or other reasons) </li><li>  The link to the file and the hash confirmation are combined into one line, which means you can write less to the blockchain and save gas </li></ul><br>  Among the shortcomings we can mention that since there is no central server, then for the availability of the files it is necessary that at least one of these files be ‚Äúdistributed‚Äù.  But if you have a specific file, then it is easy to connect to the distributors ‚Äî launch the ipfs daemon and add the file via <code>ipfs add</code> . <br><br>  The technology is very well suited to the ideology of decentralization; therefore, considering Oraclize now, we will more than once encounter the use of IPFS in different oracle mechanisms. <br><br><h2>  Oraclize </h2><br>  To perform almost any useful work, a smart contract needs to receive new data.  However, there is no built-in ability to execute a request from the blockchain to the outside world.  You can of course add everything that is required by transactions manually, but it is impossible to verify where this data came from and their accuracy.  Plus, you may need to organize additional infrastructure for the rapid updating of dynamic data, such as exchange rates.  And updates with a fixed interval will lead to gas overspending. <br><br>  Therefore, the service provided by <a href="http://www.oraclize.it/">Oraclize</a> comes in handy: in a smart contract you can send a request to almost any API or resource on the Internet, be sure that the data came from the specified resource unchanged, and use the result in the same smart contract. <br><br>  Oraclize is not only an Ethereum service, similar functionality is provided to other blockchains, but we will only describe a bundle with Ethereum. <br><br><h3>  Beginning of work </h3><br>  All you need to get started is to add yourself to the project one of the oraclizeAPI files from the <a href="https://github.com/oraclize/ethereum-api">repository</a> .  You only need to choose the appropriate compiler for your version (solc): oraclizeAPI_0.5.sol for versions starting at 0.4.18, oraclizeAPI_0.4.sol for versions from 0.4.1, oraclizeAPI_pre0.4.sol for everything older, support This version has already been discontinued.  If you use truffle, do not forget to rename the file to usingOraclize - it requires that the name of the file and the contract match. <br><br>  By including the appropriate file in your project, inherit the contract from <code>usingOraclize</code> .  And you can start using Oracle, which boils down to two main things: sending a request using the <code>oraclize_query</code> helper, and then processing the result in the <code>__callback</code> function.  The simplest smart contract (to get the current price of the broadcast in dollars) may look like this: <br><br><pre> <code class="javascript hljs">pragma solidity <span class="hljs-number"><span class="hljs-number">0.4</span></span><span class="hljs-number"><span class="hljs-number">.23</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"./usingOraclize.sol"</span></span>; contract ExampleContract is usingOraclize { string public ETHUSD; event updatedPrice(string price); event newOraclizeQuery(string description); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ExampleContract</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">payable</span></span></span><span class="hljs-function"> </span></span>{ updatePrice(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__callback</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">bytes32 myid, string result</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">require</span></span> (msg.sender == oraclize_cbAddress()); ETHUSD = result; updatedPrice(result); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">updatePrice</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">payable</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (oraclize_getPrice(<span class="hljs-string"><span class="hljs-string">"URL"</span></span>) &gt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.balance) { newOraclizeQuery(<span class="hljs-string"><span class="hljs-string">"Oraclize query was NOT sent, please add some ETH to cover for the query fee"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { newOraclizeQuery(<span class="hljs-string"><span class="hljs-string">"Oraclize query was sent, standing by for the answer.."</span></span>); oraclize_query(<span class="hljs-string"><span class="hljs-string">"URL"</span></span>, <span class="hljs-string"><span class="hljs-string">"json(https://api.coinmarketcap.com/v1/ticker/ethereum/?convert=USD).0.price_usd"</span></span>); } } }</code> </pre> <br>  The function that sends the request is <code>updatePrice</code> .  You can see that first there is a check that <code>oraclize_getPrice(‚ÄúURL‚Äù)</code> greater than the current balance of the contract.  This is done because the call to <code>oraclize_query</code> has to be paid, the price is calculated as the sum of the fixed commission and the payment for the gas to call the callback.  <code>‚ÄúURL‚Äù</code> is the designation of one of the types of data sources, in this case it is a simple https request, then we will consider other options.  Answers on request can be pre-parsed as json (as in the example) and in several other ways (we will look further).  In <code>__callback</code> , a string with the answer is returned.  At the very beginning, it is checked that the call passed from the trusted address oraclize <br><br>  All options for using oraclize are based on the same scheme, only data sources and the ability to add authentication to <code>__callback</code> .  Therefore, in future examples, we will cite only significant differences. <br><br><h3>  Price of use </h3><br>  As already mentioned, additional air is paid for oraclize requests, and it is removed from the balance of the contract, and not the calling address.  The only exception is the first request from each new contract, it is provided free of charge.  It is also interesting that in test networks the same mechanics is preserved, but the payment goes on the air of the corresponding network, that is, in testnets, the requests are actually free. <br><br>  It has already been mentioned that the request price is made up of two quantities: a fixed commission and a callback call charge.  The fixed commission is determined in dollars, and the amount of air is calculated from the current rate.  The Commission depends on the source of the data and additional supporting mechanisms, which we will dwell on.  The current price table looks like this: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/d9/w2/xv/d9w2xvqkoi2laplioqc377xydxm.png"></div><br>  As you can see, the price per URL request is a few cents.  Is it a lot or a little?  To do this, let's look at how much the second part costs - gas for a call to a callback. <br>  This works according to the following scheme: the amount of air needed to pay for a fixed amount of gas at a fixed price is transferred in advance from the contract together with the request.  This amount should be enough to fulfill the callback, and the price should be adequate to the market, otherwise the transaction will not work or will hang for a very long time.  At the same time, it is clear that it is not always possible to know the amount of gas in advance, and therefore the fee must be in stock (the stock is not returned).  The default values ‚Äã‚Äãare 200 thousand gas limit at 20 gwei.  This is enough for an average callback with several entries and some kind of logic.  Although the price of 20 gwei may seem too high at the moment (at the time of writing, the average is 4 gwei), but at the moments of the influx of transactions, the market price may suddenly jump and be even higher, therefore, in general, these values ‚Äã‚Äãare close to the actual ones.  So, with such values ‚Äã‚Äãand the price of air in the region of $ 500, payment for gas will approach $ 2, so we can say that the fixed commission takes an insignificant part. <br><br>  If you know what you are doing, then there is an option to change the limit and price of gas, thus significantly saving on requests. <br><br>  The gas price can be set by a separate function - <code>oraclize_setCustomGasPrice(&lt;  wei&gt;)</code> .  After the call, the price is saved and used in all subsequent requests. <br>  The limit can be set in the <code>oraclize_query</code> request <code>oraclize_query</code> , specifying it with the last argument, for example: <br><br><pre> <code class="javascript hljs">oraclize_query(<span class="hljs-string"><span class="hljs-string">"URL"</span></span>, <span class="hljs-string"><span class="hljs-string">"&lt;&gt;"</span></span>, <span class="hljs-number"><span class="hljs-number">50000</span></span>);</code> </pre> <br>  If you have complicated logic in <code>__callback</code> and gas is spent more than 200k, then you will definitely need to set a limit that covers the worst case of gas consumption.  Otherwise, if the limit is exceeded, <code>__callback</code> simply roll back. <br><br>  By the way, recently, oraclize has information that requests can be paid outside the blockchain, which will allow you not to spend the entire limit or return the balance (and the payment is not from the contract).  We have not had to use it yet, but oraclize offers to contact them at info@oraclize.it, if this option is interesting.  So keep in mind. <br><br><h3>  How does it work </h3><br>  Why, inheriting from the usual smart contract, we get functionality that was not originally supported by the blockchain mechanisms?  Actually service OrakLayz consists not only of contracts with functions-helpers.  The main job of getting data is external service.  Smart contracts form applications for access to external data and put them in the blockchain.  External service - monitors new blocks of the blockchain, and if it detects an application - executes it.  Schematically, this can be represented as: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/th/b0/ka/thb0kan1hwm75ijixmdrqtiwvum.png"></div><br><h3>  Data sources </h3><br>  In addition to the considered <code>URL</code> , oraclize provides 4 more options (which you saw in the section on prices): <code>WolframAlpha</code> , <code>IPFS</code> , <code>random</code> and <code>computation</code> .  Consider each one of them. <br><br><h4>  1. URL </h4><br>  The example already considered uses this data source.  This is the source for HTTP requests to various APIs.  In the example was the following: <br><br><pre> <code class="javascript hljs">oraclize_query(<span class="hljs-string"><span class="hljs-string">"URL"</span></span>, <span class="hljs-string"><span class="hljs-string">"json(https://api.coinmarketcap.com/v1/ticker/ethereum/?convert=USD).0.price_usd"</span></span>);</code> </pre> <br>  This is the receipt of the price of the broadcast, and since api provides the json string with the data set, the request is wrapped in a json parser and returns only the field we need.  In this case, this is GET, but the source URL also supports POST requests.  The type of request is automatically determined by the optional argument.  If there is a valid json there as in this example: <br><br><pre> <code class="javascript hljs">oraclize_query(<span class="hljs-string"><span class="hljs-string">"URL"</span></span>, <span class="hljs-string"><span class="hljs-string">"json(https://shapeshift.io/sendamount).success.deposit"</span></span>, <span class="hljs-string"><span class="hljs-string">'{"pair":"eth_btc","amount":"1","withdrawal":"1AAcCo21EUc1jbocjssSQDzLna9Vem2UN5"}'</span></span>)</code> </pre> <br>  then the request is processed as POST (the api used is described <a href="https://info.shapeshift.io/">here</a> , if interested) <br><br><h4>  2. WolframAlpha </h4><br>  This data source allows you to access the <a href="http://www.wolframalpha.com/">WolframAlpha</a> service, which can provide answers to various requests for facts or calculations, for example <br><br><pre> <code class="javascript hljs">oraclize_query(‚ÄúWolframAlpha‚Äù, ‚Äúpresident <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> Russia‚Äù)</code> </pre> <br>  will return <code>Vladimir Putin</code> , and the request <br><br><pre> <code class="javascript hljs">oraclize_query(‚ÄúWolframAlpha‚Äù, ‚Äúsolve x^<span class="hljs-number"><span class="hljs-number">2</span></span><span class="hljs-number"><span class="hljs-number">-4</span></span>‚Äù)</code> </pre> <br>  returns <code>x = 2</code> . <br>  As you can see, the result was incomplete, because the symbol ¬± was lost.  Therefore, before using this source, you need to check that the value of a specific request can be used in a smart contract.  In addition, authentication is not supported for answers, therefore oraclize themselves recommend using this source only for testing. <br><br><h4>  3. IPFS </h4><br>  As you can guess, allows you to get the contents of the file in IPFS on the multihash.  The timeout for receiving content is 20 seconds. <br><br><pre> <code class="javascript hljs">oraclize_query(‚ÄúIPFS‚Äù, ‚ÄúQmTL5xNq9PPmwvM1RhxuhiYqoTJcmnaztMz6PQpGxmALkP‚Äù)</code> </pre> <br>  will return <code>Hello, Habr!</code>  (if the file with such contents is still available) <br><br><h4>  4. random </h4><br>  Random number generation works in the same way as other sources, but if you use <code>oraclize_query</code> , you need time-consuming preparation of arguments.  To avoid this, you can use the helper function <code>oraclize_newRandomDSQuery(delay, nbytes, customGasLimit)</code> , specifying only the execution delay (in seconds), the number of bytes generated and the throttle limit for the <code>__callback</code> call. <br>  Using <code>random</code> has a couple of features to keep in mind: <br><br><ul><li>  To confirm that the number is actually random, a special type of verification, Ledger, is used, which can be performed on the blockchain (unlike all the others, but more on that later).  This means that in the constructor of a smart contract you need to set this method of verification by function: <br><br><pre> <code class="javascript hljs">oraclize_setProof(proofType_Ledger);</code> </pre> <br>  And at the beginning of the callback there should be the check itself: <br><br><pre> <code class="javascript hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__callback</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">bytes32 _queryId, string _result, bytes _proof</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">require</span></span> (oraclize_randomDS_proofVerify__returnCode(_queryId, _result, _proof) == <span class="hljs-number"><span class="hljs-number">0</span></span>) ); <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">...</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span></code> </pre><br>  This check requires a real network and will not work on ganache, so for local testing you can temporarily remove this line.  By the way, the third argument in <code>__callback</code> here is the additional parameter <code>_proof</code> .  It is required whenever one of the confirmation types is used. </li><li>  If you use a random number for critical moments, for example, to determine the winner in the lottery, fix the user input before sending newRandomDSQuery.  Otherwise, this situation may occur: oraclize calls _callback and the transaction is visible to everyone in the pending list.  Along with this, the random number itself is visible.  If users can continue, roughly speaking, to make bets, then they will be able to indicate the price of gas more, and push through their bet before the _callback is executed, knowing in advance that it will be advantageous. </li></ul><br><br><h4>  5. computation </h4><br>  It is the most flexible of the sources.  It allows you to write your own scripts and use them as a data source.  Calculations take place on AWS.  For execution, you need to describe the Dockerfile and put it together with arbitrary additional files in a zip-archive, and upload the archive to IPFS.  Execution must meet the following conditions: <br><br><ul><li>  Write the answer that you need to return, the last line in stdout </li><li>  The answer must be no more than 2500 characters. </li><li>  Initialization and execution should not go longer than 5 minutes in total </li></ul><br>  For an example of how this is done, consider how to perform the simplest join of the passed strings and return the result. <br><br>  Dockerfile: <br><br><pre> <code class="bash hljs">FROM ubuntu:16.04 MAINTAINER <span class="hljs-string"><span class="hljs-string">"info@rubyruby.ru"</span></span> CMD <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$ARG0</span></span></span><span class="hljs-string"> </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$ARG1</span></span></span><span class="hljs-string"> </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$ARG2</span></span></span><span class="hljs-string"> </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$ARG3</span></span></span><span class="hljs-string">"</span></span></code> </pre><br>  Environment Variables <code>ARG0</code> , <code>ARG1</code> , etc.  - These are the parameters passed along with the request. <br>  Add pre-file to the archive, start the ipfs server and add this archive there <br><br><pre> <code class="bash hljs">$ zip concatenation.zip Dockerfile $ ipfs daemon &amp; $ ipfs add concatenation.zip QmWbnw4BBFDsh7yTXhZaTGQnPVCNY9ZDuPBoSwB9A4JNJD</code> </pre> <br>  The resulting hash is used to send the request via <code>oraclize_query</code> in the smart contract: <br><br><pre> <code class="javascript hljs">oraclize_query(<span class="hljs-string"><span class="hljs-string">"computation"</span></span>, [<span class="hljs-string"><span class="hljs-string">"QmVAS9TNKGqV49WTEWv55aMCTNyfd4qcGFFfgyz7BYHLdD"</span></span>, <span class="hljs-string"><span class="hljs-string">"s1"</span></span>, <span class="hljs-string"><span class="hljs-string">"s2"</span></span>, <span class="hljs-string"><span class="hljs-string">"s3"</span></span>, <span class="hljs-string"><span class="hljs-string">"s4"</span></span>]);</code> </pre> <br>  The argument is an array, in which the first element is the multi-cache archive, and all the rest are parameters that fall into the environment variables. <br><br>  If you wait for the query, then in <code>__callback</code> will come the result <code>s1 s2 s3 s4</code> . <br><br><h3>  Helper parsers and subqueries </h3><br>  From the response returned by any source, you can pre-select only the required information using a number of helpers, such as: <br><br><h4>  1. JSON parser </h4><br>  You saw this method in the very first example, where from the result that coinmarketcap returns, only the price was returned: <br><br><pre> <code class="bash hljs">json(https://api.coinmarketcap.com/v1/ticker/ethereum/?convert=USD).0.price_usd</code> </pre> <br>  The use case is pretty obvious, going back to the example: <br><br><pre> <code class="hljs json">[ { <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"ethereum"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Ethereum"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"symbol"</span></span>: <span class="hljs-string"><span class="hljs-string">"ETH"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"rank"</span></span>: <span class="hljs-string"><span class="hljs-string">"2"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"price_usd"</span></span>: <span class="hljs-string"><span class="hljs-string">"462.857"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"price_btc"</span></span>: <span class="hljs-string"><span class="hljs-string">"0.0621573"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"24h_volume_usd"</span></span>: <span class="hljs-string"><span class="hljs-string">"1993200000.0"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"market_cap_usd"</span></span>: <span class="hljs-string"><span class="hljs-string">"46656433775.0"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"available_supply"</span></span>: <span class="hljs-string"><span class="hljs-string">"100800968.0"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"total_supply"</span></span>: <span class="hljs-string"><span class="hljs-string">"100800968.0"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"max_supply"</span></span>: <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-attr"><span class="hljs-attr">"percent_change_1h"</span></span>: <span class="hljs-string"><span class="hljs-string">"-0.5"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"percent_change_24h"</span></span>: <span class="hljs-string"><span class="hljs-string">"-3.02"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"percent_change_7d"</span></span>: <span class="hljs-string"><span class="hljs-string">"5.93"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"last_updated"</span></span>: <span class="hljs-string"><span class="hljs-string">"1532064934"</span></span> } ]</code> </pre> <br>  Since this is an array, we take the element <code>0</code> , and from it the <code>price_usd</code> field <br><br><h4>  2. XML </h4><br>  Use similar to JSON, for example: <br><br><pre> <code class="bash hljs">xml(https://informer.kovalut.ru/webmaster/getxml.php?kod=7701).Exchange_Rates.Central_Bank_RF.USD.New.Exch_Rate</code> </pre> <br><h4>  3. HTML </h4><br>  You can parse XHTML with XPath.  For example, get a market cap with etherscan: <br><br><pre> <code class="bash hljs">html(https://etherscan.io/).xpath(string(//*[contains(@href, <span class="hljs-string"><span class="hljs-string">'/stat/supply'</span></span>)]/font))</code> </pre> <br>  We <code>MARKET CAP OF $46.148 BillionB</code> <br><br><h4>  4. Binary helper </h4><br>  Allows you to cut pieces from raw data using the slice (offset, length) function.  That is, for example, we have a file with the contents of ‚Äúabc‚Äù: <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"abc"</span></span> &gt; example.bin</code> </pre> <br>  Put it on IPFS: <br><br><pre> <code class="bash hljs">$ ipfs add example.bin added Qme4u9HfFqYUhH4i34ZFBKi1ZsW7z4MYHtLxScQGndhgKE</code> </pre> <br>  And now let's cut out 1 character from the middle: <br><br><pre> <code class="javascript hljs">binary(Qme4u9HfFqYUhH4i34ZFBKi1ZsW7z4MYHtLxScQGndhgKE).slice(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre> <br>  In the answer we get <code>b</code> <br><br>  As you may have noticed, in the case of the binary helper, IPFS was used, not the URL source.  In fact, parsers can be applied to any sources, let's say it is not necessary to apply JSON to what the URL returns, you can add such content to the file: <br><br><pre> <code class="hljs json">{ <span class="hljs-attr"><span class="hljs-attr">"one"</span></span>:<span class="hljs-string"><span class="hljs-string">"1"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"two"</span></span>:<span class="hljs-string"><span class="hljs-string">"2"</span></span> }</code> </pre> <br>  Add it to IPFS: <br><br><pre> <code class="bash hljs">$ ipfs add test.json added QmZinLwAq5fy4imz8ZNgupWeNFTneUqHjPiTPX9tuR7Vxp</code> </pre> <br>  And then disassemble like this: <br><br><pre> <code class="bash hljs">json(QmZinLwAq5fy4imz8ZNgupWeNFTneUqHjPiTPX9tuR7Vxp).one</code> </pre> <br>  We get <code>1</code> <br><br>  And a particularly interesting use case is to combine any data sources and any parsers in one query.  This is possible using a separate <code>nested</code> data source.  We use the newly created file in a more complex query (the addition of values ‚Äã‚Äãin two fields): <br><br><pre> <code class="hljs pgsql">[WolframAlpha] <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> ${[IPFS] <span class="hljs-type"><span class="hljs-type">json</span></span>(QmZinLwAq5fy4imz8ZNgupWeNFTneUqHjPiTPX9tuR7Vxp).one} <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> ${[IPFS] <span class="hljs-type"><span class="hljs-type">json</span></span>(QmZinLwAq5fy4imz8ZNgupWeNFTneUqHjPiTPX9tuR7Vxp).two}</code> </pre> <br>  We get <code>3</code> <br>  The query is formed as follows: specify the <code>nested</code> data source, then for each query add the source name in front of it in square brackets, and further enclose all subqueries in <code>${..}</code> . <br><br><h3>  Testing </h3><br>  Oraclize provides a <a href="http://app.oraclize.it/home/test_query">useful</a> query validation <a href="http://app.oraclize.it/home/test_query">service</a> without the need for smart contracts.  Just go, choose a data source, a verification method and see what will return in __ callback if you send the corresponding requests <br><br>  For local verification in conjunction with a smart contract, you can use a <a href="http://dapps.oraclize.it/browser-solidity/">special version of the Remix IDE</a> that supports oraclize requests. <br><br>  And to check locally with ganache, you will need an <a href="https://github.com/oraclize/ethereum-bridge">ethereum bridge</a> , which will deploy smart oraclize contracts into your testnet.  To test, first add the following line to your contract constructor: <br><br><pre> <code class="javascript hljs">OAR = OraclizeAddrResolverI(<span class="hljs-number"><span class="hljs-number">0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475</span></span>);</code> </pre> <br>  run <br><br><pre> <code class="bash hljs">ganache-cli</code> </pre> <br>  Then <br><br><pre> <code class="bash hljs">node bridge --dev</code> </pre> <br>  Wait for the contracts to go through and be tested.  In the output of the <code>node bridge</code> it will be possible to see the sent requests and the received responses. <br><br>  Another help not only for testing, but also for real use - the ability to monitor requests <a href="http://app.oraclize.it/service/monitor">here</a> .  If you request a public network, you can use the hash of the transaction in which the request is executed.  If you use authentication, then keep in mind that they are guaranteed to be sent only to mainnet, for other networks it can arrive 0. If the request was on the local network, then you can use the id of the request, which is returned by <code>oraclize_query</code> .  By the way, this id is always recommended to be saved, for example in a similar mapping: <br><br><pre> <code class="javascript hljs">mapping(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">bytes32</span></span></span><span class="hljs-function">=&gt;</span></span>bool) validIds;</code> </pre> <br>  During the request, mark the id sent as <code>true</code> : <br><br><pre> <code class="javascript hljs">bytes32 queryId = oraclize_query(<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">...</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">); validIds[queryId] = true;</span></span></code> </pre><br>  And then in <code>__callback</code> to check that the request with such id was not processed yet: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__callback</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">bytes32 myid, string result</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(validIds[myid] != bytes32(<span class="hljs-number"><span class="hljs-number">0</span></span>)); <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(msg.sender == oraclize_cbAddress()); validIds[myid] = bytes32(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">...</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span></code> </pre> <br>  This is necessary because the <code>__callback</code> per request can be called more than once due to the peculiarities of the operation of the Oraclize mechanisms. <br><br><h3>  Authentication </h3><br>  In the table with sources you could see that different sources can support different types of confirmations, and different commissions may be charged.  This is a very important part of oraclize, but a detailed description of these mechanisms is a separate topic. <br><br>  The most commonly used mechanism, at least by us, is <a href="https://tlsnotary.org/">TLSNotary</a> with storage in IPFS.  Storage in IPFS is more efficient because the <code>__callback</code> does not return the proof itself (maybe around 4-5 kilobytes), but a much smaller multi-cache.  To set this type, add a line in the constructor: <br><br><pre> <code class="javascript hljs">oraclize_setProof(proofType_TLSNotary | proofStorage_IPFS);</code> </pre> <br>  We can only say that this type, roughly speaking, protects us from the unreliability of data obtained from Oraclize.  But Oraclize uses Amazon servers, which act as an auditor, so they only have to trust. <br><br>  Read more <a href="https://docs.oraclize.it/">here</a> . <br><br><h2>  Conclusion </h2><br>  Oraclize provides tools that significantly increase the number of use cases for smart contracts, as well as IPFS, which can be seen in several variations of Oracle requests.  The main problem is that we again use external data that is subject to the threats from which the blockchain was supposed to protect: centralization, blocking capabilities, code changes, result substitution.  But while this is all inevitable, and the option of obtaining data is very useful and viable, you just need to be aware of why the use of the blockchain was introduced into the project and whether the appeal reduces external unreliable sources to zero advantage. <br><br>  If you are interested in some topics on the development of Ethereum not yet disclosed in these articles - write in the comments, perhaps we will reveal in the following. <br><br>  Ethereum development: <br>  <a href="https://habrahabr.ru/post/336132/">Part 1: introduction</a> <br>  <a href="https://habrahabr.ru/post/336770/">Part 2: Web3.js and gas</a> <br>  <a href="https://habrahabr.ru/post/339080/">Part 3: user application</a> <br>  <a href="https://habr.com/post/348656/">Part 4: warmth and debug in truffle, ganache, infura</a> </div><p>Source: <a href="https://habr.com/ru/post/417681/">https://habr.com/ru/post/417681/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../417671/index.html">New ABAP programming language features on SAP webinars</a></li>
<li><a href="../417673/index.html">Solar Dozor leads the investigation: 5 non-standard cases that DLP disclosed</a></li>
<li><a href="../417675/index.html">Localization of games and applications in Unity. Quick and convenient</a></li>
<li><a href="../417677/index.html">Migrating a project from yii1 to yii2 through a one-time job</a></li>
<li><a href="../417679/index.html">Heavy legacy of the past. Windows command line issues</a></li>
<li><a href="../417683/index.html">Outdated Code - Third Party Code</a></li>
<li><a href="../417685/index.html">Friday webinars from Skillbox: we continue to study for free</a></li>
<li><a href="../417687/index.html">Life asymmetry</a></li>
<li><a href="../417689/index.html">Mobio Talks with CEO Appnext about the CPI market and trends in the mobile applications industry</a></li>
<li><a href="../417691/index.html">Our bookshelf C # programmer. What about you?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>