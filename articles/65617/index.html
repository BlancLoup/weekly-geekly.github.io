<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Data structures: binary trees. Part 1</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Intro 

 With this article I begin a cycle of articles about well-known and not-so data structures as well as their application in practice. 

 In my ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Data structures: binary trees. Part 1</h1><div class="post__text post__text-html js-mediator-article"><h2>  Intro </h2><br><br>  With this article I begin a cycle of articles about well-known and not-so data structures as well as their application in practice. <br><br>  In my articles I will give examples of code in two languages ‚Äã‚Äãat once: in Java and in Haskell.  Thanks to this, it will be possible to compare the imperative and functional styles of programming and see the pros and cons of both. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      I decided to start with binary search trees, as this is a fairly basic, but at the same time interesting thing, which also has a large number of modifications and variations, as well as practical applications. <br><a name="habracut"></a><br><h2>  Why do you need it? </h2><br><br>  Binary search trees are usually used to implement sets and associative arrays (for example, set and map in c ++ or TreeSet and TreeMap in java).  More complex applications include ropes (I will talk about them in one of the following articles), various algorithms of computational geometry, mainly in algorithms based on the ‚Äúscanning straight line‚Äù. <br><br>  In this article, trees will be considered on the example of the implementation of an associative array.  An associative array is a generalized array in which indices (usually called keys) can be arbitrary. <br><br><h2>  Well, let's get started </h2><br><br>  A binary tree consists of vertices and links between them.  More specifically, the tree has a distinguished vertex-root and each vertex can have left and right sons.  In words it sounds somewhat difficult, but if you look at the picture, everything becomes clear: <br><br><img src="https://habrastorage.org/files/2fc/38e/215/2fc38e215c8b4a09b41239f0c322c2f7.png" alt="Binary Tree Example"><br><br>  In this tree, root will be A. It can be seen that D has no left son, D has right, and B, and G, H, F, and I have both.  Peaks without sons are called leaves. <br><br>  Each vertex X can be associated with its own tree, consisting of the vertex, its sons, the sons of its sons, etc.  Such a tree is called a subtree with a root X. Left and right subtrees of X are called subtrees with roots in the left and right sons of X, respectively. Note that such subtrees may be empty if X does not have a corresponding son. <br><br>  The data in the tree is stored at its vertices.  In programs, tree tops are usually represented by a structure storing data and two references to the left and right son.  Missing vertices are null or special Leaf constructor: <br><br><pre><code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Ord</span></span></span><span class="hljs-class"> key =&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">BSTree</span></span></span><span class="hljs-class"> key value = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Leaf</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Branch</span></span></span><span class="hljs-class"> key value (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">BSTree</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">key</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">value</span></span></span><span class="hljs-class">) (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">BSTree</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">key</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">value</span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">deriving</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Show</span></span></span><span class="hljs-class">)</span></span></code> </pre> <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Node</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T1</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T2</span></span></span><span class="hljs-class">&gt; </span></span>{ T1 key; T2 value; Node&lt;T1, T2&gt; left, right; Node(T1 key, T2 value) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.key = key; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.value = value; } }</code> </pre><br><br>  As you can see from the examples, we require from the keys that they can be compared with each other ( <code>Ord a</code> in haskell and <code>T1 implements Comparable&lt;T1&gt;</code> in java).  All this is not casual - in order for the tree to be useful data must be stored in it according to some rules. <br><br>  What are these rules?  Everything is simple: if the key x is stored in the vertex X, then in the left (right) subtree only keys smaller (correspondingly larger) than x should be stored.  Illustrate: <br><br><img src="https://habrastorage.org/files/315/68a/8e2/31568a8e26a24e8ea22e7e1b26a84d81.png" alt="Sample BST with data"><br><br>  What gives us such ordering?  That we can easily find the required key x in the tree!  Just compare x with the value at the root.  If they are equal, then we have found the required.  If x is less (more), then it can only be in the left (respectively right) subtree.  Let for example we look for the number 17 in a tree: <br><br><img src="https://habrastorage.org/files/440/b88/01f/440b8801fa0948f78cb03e1f29d3e61d.png" alt="Search tree number 17"><br><br>  The function that receives the value by key: <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">get</span></span> :: <span class="hljs-type"><span class="hljs-type">Ord</span></span> key =&gt; <span class="hljs-type"><span class="hljs-type">BSTree</span></span> key value -&gt; key -&gt; <span class="hljs-type"><span class="hljs-type">Maybe</span></span> value get <span class="hljs-type"><span class="hljs-type">Leaf</span></span> _ = <span class="hljs-type"><span class="hljs-type">Nothing</span></span> get (<span class="hljs-type"><span class="hljs-type">Branch</span></span> key value left right) k | k &lt; key = get left k | k &gt; key = get right k | k == key = <span class="hljs-type"><span class="hljs-type">Just</span></span> value</code> </pre><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> T2 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T1 k)</span></span></span><span class="hljs-function"> </span></span>{ Node&lt;T1, T2&gt; x = root; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (x != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cmp = k.compareTo(x.key); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cmp == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x.value; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cmp &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { x = x.left; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { x = x.right; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; }</code> </pre><br><br><h2>  Add to tree </h2><br><br>  Now let's try the operation of adding a new key / value pair (a, b).  To do this, we will descend the tree as in the get function until we find a vertex with the same key, or we reach the missing son.  If we find a vertex with the same key, then simply change the corresponding value.  In the opposite case, it is easy to understand that it is in this place that a new vertex should be inserted in order not to disturb the order.  Consider inserting key 42 into the tree in the past figure: <br><br><img src="https://habrastorage.org/files/ab6/145/ff2/ab6145ff2f954ef38b2aca94f86221d3.png" alt="Adding a vertex to a tree"><br><br>  Code: <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">add</span></span> :: <span class="hljs-type"><span class="hljs-type">Ord</span></span> key =&gt; <span class="hljs-type"><span class="hljs-type">BSTree</span></span> key value -&gt; key -&gt; value -&gt; <span class="hljs-type"><span class="hljs-type">BSTree</span></span> key value add <span class="hljs-type"><span class="hljs-type">Leaf</span></span> kv = <span class="hljs-type"><span class="hljs-type">Branch</span></span> kv <span class="hljs-type"><span class="hljs-type">Leaf</span></span> <span class="hljs-type"><span class="hljs-type">Leaf</span></span> add (<span class="hljs-type"><span class="hljs-type">Branch</span></span> key value left right) kv | k &lt; key = <span class="hljs-type"><span class="hljs-type">Branch</span></span> key value (add left kv) right | k &gt; key = <span class="hljs-type"><span class="hljs-type">Branch</span></span> key value left (add right kv) | k == key = <span class="hljs-type"><span class="hljs-type">Branch</span></span> key value left right</code> </pre><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T1 k, T2 v)</span></span></span><span class="hljs-function"> </span></span>{ Node&lt;T1, T2&gt; x = root, y = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (x != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cmp = k.compareTo(x.key); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cmp == <span class="hljs-number"><span class="hljs-number">0</span></span>) { x.value = v; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { y = x; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cmp &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { x = x.left; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { x = x.right; } } } Node&lt;T1, T2&gt; newNode = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Node&lt;T1, T2&gt;(k, v); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (y == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { root = newNode; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (k.compareTo(y.key) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { y.left = newNode; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { y.right = newNode; } } }</code> </pre><br><br><h1>  Lyrical digression about the pros and cons of the functional approach </h1><br><br>  If you carefully consider the examples in both languages, you can see some differences in the behavior of functional and imperative implementations: if java we simply modify the data and references in the existing vertices, the version of haskell creates new vertices along the entire path traversed by recursion.  This is due to the fact that destructive assignments cannot be made in purely functional languages.  Clearly, this degrades performance and increases memory consumption.  On the other hand, such an approach also has positive aspects: the absence of side effects greatly facilitates the understanding of how the program functions.  In more detail about it it is possible to read in almost any textbook or introductory article about functional programming. <br><br>  In this article, I want to draw attention to another consequence of the functional approach: even after adding a new element to the tree, the old version will remain available!  Due to this effect, ropes work, including in the implementation in imperative languages, allowing you to implement strings with asymptotically faster operations than with the traditional approach.  I will tell you about ropes in one of the following articles. <br><br><h2>  Back to our sheep </h2><br><br>  Now we are getting close to the most difficult operation in this article - removing the key x from the tree.  To begin with, we, as before, will find our top in the tree.  Now there are two cases.  Case 1 (delete the number 5): <br><br><img src="https://habrastorage.org/files/3a8/527/e26/3a8527e267ce43ec84b4167178a81949.png" alt="Vertex deletion: case 1. before"><br><br>  It can be seen that the deleted vertex has no right son.  Then we can remove it and insert the left subtree instead of it, without disturbing the order: <br><br><img src="https://habrastorage.org/files/2ec/ef6/c24/2ecef6c24ab745a598bd483e4dbe05e8.png" alt="Vertex deletion: case 1. after"><br><br>  If the right-hand son is, case 2 is present (we delete the top 5 again, but from a slightly different tree): <br><br><img src="https://habrastorage.org/files/964/d2a/6f7/964d2a6f709a4a5ea5060f57e44d0f85.png" alt="Vertex deletion: case 2. before"><br><br>  It will not be so easy here - the left son may already have a right son.  We proceed differently: we find the minimum in the right subtree.  It is clear that you can find it if you start in the right son and go all the way to the left.  Since the found minimum does not have a left son, you can cut it out by analogy with case 1 and insert it in place of the removed vertex.  Due to the fact that it was minimal in the right subtree, the order property will not be broken: <br><br><img src="https://habrastorage.org/files/169/4cc/32e/1694cc32e7d54ed4aa545929a24d3a38.png" alt="Vertex deletion: case 2. after"><br><br>  Implementing removal: <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">remove</span></span> :: <span class="hljs-type"><span class="hljs-type">Ord</span></span> key =&gt; <span class="hljs-type"><span class="hljs-type">BSTree</span></span> key value -&gt; key -&gt; <span class="hljs-type"><span class="hljs-type">BSTree</span></span> key value remove <span class="hljs-type"><span class="hljs-type">Leaf</span></span> _ = <span class="hljs-type"><span class="hljs-type">Leaf</span></span> remove (<span class="hljs-type"><span class="hljs-type">Branch</span></span> key value left right) k | k &lt; key = <span class="hljs-type"><span class="hljs-type">Branch</span></span> key value (remove left k) right | k &gt; key = <span class="hljs-type"><span class="hljs-type">Branch</span></span> key value left (remove right k) | k == key = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> isLeaf right <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> left <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-type"><span class="hljs-type">Branch</span></span> leftmostA leftmostB left right' <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> isLeaf <span class="hljs-type"><span class="hljs-type">Leaf</span></span> = <span class="hljs-type"><span class="hljs-type">True</span></span> isLeaf _ = <span class="hljs-type"><span class="hljs-type">False</span></span> ((leftmostA, leftmostB), right') = deleteLeftmost right deleteLeftmost (<span class="hljs-type"><span class="hljs-type">Branch</span></span> key value <span class="hljs-type"><span class="hljs-type">Leaf</span></span> right) = ((key, value), right) deleteLeftmost (<span class="hljs-type"><span class="hljs-type">Branch</span></span> key value left right) = (pair, <span class="hljs-type"><span class="hljs-type">Branch</span></span> key value left' right) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> (pair, left') = deleteLeftmost left</code> </pre><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">remove</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T1 k)</span></span></span><span class="hljs-function"> </span></span>{ Node&lt;T1, T2&gt; x = root, y = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (x != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cmp = k.compareTo(x.key); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cmp == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { y = x; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cmp &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { x = x.left; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { x = x.right; } } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x.right == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (y == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { root = x.left; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x == y.left) { y.left = x.left; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { y.right = x.left; } } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { Node&lt;T1, T2&gt; leftMost = x.right; y = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (leftMost.left != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { y = leftMost; leftMost = leftMost.left; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (y != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { y.left = leftMost.right; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { x.right = leftMost.right; } x.key = leftMost.key; x.value = leftMost.value; } }</code> </pre><br><br>  For dessert, a couple of features that I used to test: <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">fromList</span></span> :: <span class="hljs-type"><span class="hljs-type">Ord</span></span> key =&gt; [(key, value)] -&gt; <span class="hljs-type"><span class="hljs-type">BSTree</span></span> key value fromList = foldr (\(key, value) tree -&gt; add tree key value) <span class="hljs-type"><span class="hljs-type">Leaf</span></span> toList :: <span class="hljs-type"><span class="hljs-type">Ord</span></span> key =&gt; <span class="hljs-type"><span class="hljs-type">BSTree</span></span> key value -&gt; [(key, value)] toList tree = toList' tree [] <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> toList' <span class="hljs-type"><span class="hljs-type">Leaf</span></span> list = list toList' (<span class="hljs-type"><span class="hljs-type">Branch</span></span> key value left right) list = toList' left ((key, value):(toList' left list))</code> </pre><br><br><h2>  Why is all this useful? </h2><br><br>  The reader may wonder why such difficulties are needed if you can simply store a list of pairs [(key, value)].  The answer is simple - tree operations work faster.  When implemented in a list, all functions require O (n) actions, where n is the size of the structure.  (Writing O (f (n)) roughly means ‚Äúproportional to f (n)‚Äù, a more correct description and details can be read <a href="http://ru.wikipedia.org/wiki/%25D0%2590%25D1%2581%25D0%25B8%25D0%25BC%25D0%25BF%25D1%2582%25D0%25BE%25D1%2582%25D0%25B8%25D0%25BA%25D0%25B0">here</a> ).  Tree operations work in O (h), where h is the maximum depth of the tree (depth is the distance from the root to the top).  In the optimal case, when the depth of all leaves is the same, there will be n = 2 ^ h vertices in the tree.  Therefore, the complexity of operations in trees close to optimum will be O (log (n)).  Unfortunately, in the worst case, the tree may degenerate and the complexity of the operations will be as in the list, for example in such a tree (you can, if you insert the numbers 1..n in order): <br><br><img src="https://habrastorage.org/files/5b4/657/b80/5b4657b80fbc4794a582bdb25a4873b9.png" alt="Degenerate tree"><br><br>  Fortunately, there are ways to implement a tree so that the optimal depth of the tree is maintained for any sequence of operations.  Such trees are called balanced.  These include red-black trees, AVL trees, splay trees, etc. <br><br><h2>  The announcement of the next series </h2><br><br>  In the next article I will make a small overview of various balanced trees, their pros and cons.  In the following articles I will talk about some (possibly several) in more detail and with the implementation.  After that I will talk about the implementation of ropes and other possible extensions and applications of balanced trees. <br><br>  Stay in touch! <br><br><h2>  useful links </h2><br><br>  Sources of examples entirely: <br><br>  <a href="http://winger.pastebin.com/f78fca1a5">on haskell</a> <br><br>  <a href="http://winger.pastebin.com/f50a4a9d7">on java</a> <br><br>  <a href="http://ru.wikipedia.org/wiki/%25D0%2591%25D0%25B8%25D0%25BD%25D0%25B0%25D1%2580%25D0%25BD%25D0%25BE%25D0%25B5_%25D0%25B4%25D0%25B5%25D1%2580%25D0%25B5%25D0%25B2%25D0%25BE_%25D0%25BF%25D0%25BE%25D0%25B8%25D1%2581%25D0%25BA%25D0%25B0">Wikipedia article</a> <br><br>  <a href="http://rain.ifmo.ru/cat/view.php/vis/trees/binary-search-2002">Interactive BST Operations Visualizer</a> <br><br>  I also strongly advise reading the book by Kormen T., Leiserson Ch., Rivest R .: ‚ÄúAlgorithms: construction and analysis‚Äù, which is an excellent textbook on algorithms and data structures <br><br><h2>  UPD: pictures restored, thanks <a href="https://habrahabr.ru/users/xfrid/" class="user_link">Xfrid</a> ! </h2></div><p>Source: <a href="https://habr.com/ru/post/65617/">https://habr.com/ru/post/65617/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../65606/index.html">Linux Foundation Credit Cards</a></li>
<li><a href="../65612/index.html">Sorting large amounts of data, implementation in Java</a></li>
<li><a href="../65613/index.html">AirPeople.ru - Do you fly by air?</a></li>
<li><a href="../65614/index.html">Corner lamer (increase the efficiency of the mobile old man Sony Ericsson w810i)</a></li>
<li><a href="../65616/index.html">Mood lamp!</a></li>
<li><a href="../65618/index.html">The Senate will deal with ultrafast trading</a></li>
<li><a href="../65619/index.html">Lack of memory on image processing hosting</a></li>
<li><a href="../65620/index.html">Record Keeping Service</a></li>
<li><a href="../65621/index.html">Down with censorship in advertising slogans</a></li>
<li><a href="../65622/index.html">Microsoft DreamSpark student for Ukrainian undergraduate and graduate students</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>