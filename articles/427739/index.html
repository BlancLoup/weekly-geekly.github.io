<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>DDD, Hexagonal, Onion, Clean, CQRS ... how I put it all together</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This article is part of the Software Architecture Chronicle , a series of articles on software architecture. In them I write about what I learned abou...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>DDD, Hexagonal, Onion, Clean, CQRS ... how I put it all together</h1><div class="post__text post__text-html js-mediator-article"> <a href=""><img src="https://habrastorage.org/webt/mm/07/bx/mm07bx1u2dxlgab0prkzllunvf8.png"></a> <br><br>  This article is part of the <a href="https://herbertograca.com/2017/07/03/the-software-architecture-chronicles/">Software Architecture Chronicle</a> , a series of articles on software architecture.  In them I write about what I learned about software architecture, what I think about it and how I use knowledge.  The content of this article may make more sense if you read the previous articles in the series. <br><br>  After graduating from university, I started working as a high school teacher, but a few years ago I quit and went to software developers for a full-time job. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Since then, I have always felt that I need to recover ‚Äúlost‚Äù time and learn as much as possible, as quickly as possible.  Therefore, I began to take a little interest in experiments, read a lot and write, paying special attention to software design and architecture.  That is why I write these articles to help me learn. <br><a name="habracut"></a><br>  In the last articles I talked about many concepts and principles that I learned, and a little about how I talk about them.  But I imagine them as fragments of one big puzzle. <br><br>  This article is about how I put together all these fragments.  It seems I should give them a name, so I‚Äôll call them <b>explicit architecture</b> .  In addition, all these concepts are <i>‚Äútested in battle‚Äù</i> and are used in production on highly reliable platforms.  One of them is the SaaS e-commerce platform with thousands of online stores worldwide, the other is a marketplace operating in two countries with a bus of messages that processes more than 20 million messages per month. <br><br><ul><li>  <a href="https://habr.com/ru/post/427739/">Fundamental system blocks</a> </li><li>  <a href="https://habr.com/ru/post/427739/">Instruments</a> </li><li>  <a href="https://habr.com/ru/post/427739/">Connecting tools and delivery mechanisms to the application core</a> <br><ul><li>  <a href="https://habr.com/ru/post/427739/">Ports</a> </li><li>  <a href="https://habr.com/ru/post/427739/">Basic or Control Adapters</a> </li><li>  <a href="https://habr.com/ru/post/427739/">Secondary or managed adapters</a> </li><li>  <a href="https://habr.com/ru/post/427739/">Inversion of control</a> </li></ul></li><li>  <a href="https://habr.com/ru/post/427739/">Application core organization</a> <br><ul><li>  <a href="https://habr.com/ru/post/427739/">Application level</a> </li><li>  <a href="https://habr.com/ru/post/427739/">Domain Level</a> <br><ul><li>  <a href="https://habr.com/ru/post/427739/">Domain Services</a> </li><li>  <a href="https://habr.com/ru/post/427739/">Domain Model</a> </li></ul></li></ul></li><li>  <a href="https://habr.com/ru/post/427739/">Components</a> <br><ul><li>  <a href="https://habr.com/ru/post/427739/">Separation of components</a> <br><ul><li>  <a href="https://habr.com/ru/post/427739/">Triggering logic in other components</a> </li><li>  <a href="https://habr.com/ru/post/427739/">Retrieving data from other components</a> <br><ul><li>  <a href="https://habr.com/ru/post/427739/">Shared Data Warehouse for Components</a> </li><li>  <a href="https://habr.com/ru/post/427739/">Separate data storage for a component</a> </li></ul></li></ul></li></ul></li><li>  <a href="https://habr.com/ru/post/427739/">Control flow</a> </li></ul><br><a name="1"></a><h1>  Fundamental system blocks </h1><br>  To begin with, we recall the architecture of <a href="https://herbertograca.com/2017/08/24/ebi-architecture/">EBI</a> and <a href="https://herbertograca.com/2017/09/14/ports-adapters-architecture/">Ports &amp; Adapters</a> .  Both of them clearly separate the internal and external application code, as well as adapters for connecting the internal and external code. <br><br>  In addition, the <a href="https://herbertograca.com/2017/09/14/ports-adapters-architecture/">Ports &amp; Adapters</a> architecture explicitly defines three fundamental blocks of code in the system: <br><br><ul><li>  That allows you to run the <b>user interface</b> , regardless of its type. </li><li>  System <b>business logic</b> or <b>application core</b> .  It is used by UI for making real transactions. </li><li>  The <b>infrastructure</b> code that connects the core of our application with tools such as a database, search engine, or third-party APIs. </li></ul><br> <a href=""><img src="https://habrastorage.org/webt/7q/gt/h5/7qgth5e95mntgholpnrryv4zbm4.png"></a> <br><br>  The core of the application is the most important thing to think about.  This code allows you to perform real actions in the system, that is, this is our application.  Several user interfaces can work with it (progressive web application, mobile application, CLI, API, etc.), everything is performed on one core. <br><br>  As you can imagine, a typical execution flow comes from the code in the UI through the application core to the infrastructure code, back to the application core, and finally the answer is delivered to the UI. <br><br> <a href=""><img src="https://habrastorage.org/webt/vn/7q/5u/vn7q5usrs1m2ftgkfmzagymrlfw.png"></a> <br><br><a name="2"></a><h1>  Instruments </h1><br>  Far from the most important kernel code, there are more tools that the application uses.  For example, the database engine, search engine, web server and CLI console (although the latter two are also delivery mechanisms). <br><br> <a href=""><img src="https://habrastorage.org/webt/_o/aj/rn/_oajrnom8cuphtclxgw-m-sgars.png"></a> <br><br>  It seems strange to include the CLI console in the same thematic section as the DBMS, because they have a different purpose.  But in fact, both are tools used by the application.  The key difference is that the CLI console and the web server <b>tell the application to do something</b> , the database engine, on the contrary, <b>receives commands from the application</b> .  This is a very important distinction, because it greatly influences the way we write code to connect these tools to the application core. <br><br><a name="3"></a><h1>  Connecting tools and delivery mechanisms to the application core </h1><br>  The blocks of code that connect the tools to the application kernel are called adapters ( <a href="https://herbertograca.com/2017/09/14/ports-adapters-architecture/">Ports &amp; Adapters architecture</a> ).  They allow business logic to interact with a specific tool, and vice versa. <br><br>  Adapters that tell an application to do something are called <b>primary or control adapters</b> , while adapters that the application says to do are called <b>secondary or managed adapters</b> . <br><br><a name="4"></a><h2>  Ports </h2><br>  However, these <i>adapters</i> are not created randomly, but in order to correspond to a specific entry point into the application kernel, a <i><b>port</b></i> .  A port is <b>nothing more than a specification</b> of how a tool can use the core of an application or vice versa.  In most languages ‚Äã‚Äãand in the simplest form, this port will be an interface, but in fact it can be composed of several interfaces and DTO. <br><br>  It is important to note that the <b>ports (interfaces) are inside the business logic</b> , and the adapters are outside.  In order for this pattern to work properly, it is extremely important to create ports in accordance with the needs of the application core, and not just simulate the tools API. <br><br><a name="5"></a><h2>  Basic or Control Adapters </h2><br>  Primary or control adapters <b>wrap around the port</b> and use it to tell the application engine what to do.  <b>They convert all data from the delivery mechanism to method calls in the application core.</b> <br><br> <a href=""><img src="https://habrastorage.org/webt/p3/6x/rc/p36xrcnsvtfgxpmnpb2f48vtguw.png"></a> <br><br>  In other words, our control adapters are controllers or console commands; they are embedded in their constructor with some object whose class implements the interface (port) that the controller or console command requires. <br><br>  In a more specific example, the port may be a service interface or a repository interface that is required by the controller.  The specific implementation of the service, repository, or request is then implemented and used in the controller. <br><br>  In addition, the port can be a command bus or a query bus interface.  In this case, a specific implementation of a command or request bus is entered into the controller, which then creates a command or request and sends it to the appropriate bus. <br><br><a name="6"></a><h2>  Secondary or managed adapters </h2><br>  Unlike control adapters, which are wrapped around a port, <b>managed adapters</b> implement the port, interface, and then are entered into the application kernel where the port is required (with an indication of the type). <br><br> <a href=""><img src="https://habrastorage.org/webt/rw/hz/bo/rwhzboewldt79asfbycnq9pwii0.png"></a> <br><br>  For example, we have a native application that needs to save data.  We create a persistence-interface with a method of <i>saving an</i> array of data and a method of <i>deleting a</i> row in a table by its ID.  From now on, wherever the application has to save or delete data, we will require in the constructor an object that implements the persistence interface that we defined. <br><br>  Now we create an adapter that is specific to MySQL, which will implement this interface.  It will have methods to save the array and delete the row in the table, and we will enter it wherever a persistence interface is required. <br><br>  If at some point we decide to change the database provider, for example, to PostgreSQL or MongoDB, we just need to create a new adapter that implements the PostgreSQL-specific persistence interface and implement the new adapter instead of the old one. <br><br><a name="7"></a><h2>  Inversion of control </h2><br>  A characteristic feature of this template is that the adapters depend on the specific tool and the specific port (by implementing the interface).  But our business logic depends only on the port (interface), which is designed to meet the needs of business logic and does not depend on the specific adapter or tool. <br><br> <a href=""><img src="https://habrastorage.org/webt/lz/8c/8m/lz8c8mla7fg4vuq9piocz1rb4ko.png"></a> <br><br>  This means that dependencies are directed to the center, that is, there is an <b>inversion of the principle of control at the architectural level</b> . <br><br>  Although again, <b>it is extremely important that the ports are created according to the needs of the application core, and not just imitated the tools API</b> . <br><br><a name="8"></a><h1>  Application core organization </h1><br>  <a href="https://herbertograca.com/2017/09/21/onion-architecture/">The Onion architecture</a> picks up DDD layers and incorporates them into the <a href="https://herbertograca.com/2017/09/14/ports-adapters-architecture/">ports and adapters architecture</a> .  These levels are designed to bring some order into the business logic, the inner part of the ‚Äúhexagon‚Äù of ports and adapters.  As before, the direction of dependencies is towards the center. <br><br><a name="9"></a><h2>  Application Level (Application Level) </h2><br>  Use cases are processes that can be run in the kernel with one or more user interfaces.  For example, in a CMS there can be one UI for regular users, another independent UI for CMS administrators, another CLI and a web API.  These UIs (applications) can initiate unique or common use cases. <br><br>  Use cases are defined at the application level - the first level of DDD and Onion architecture. <br><br> <a href=""><img src="https://habrastorage.org/webt/en/x2/97/enx297n0fviyyevojd6u3y_mx3q.png"></a> <br><br>  This layer contains application services (and their interfaces) as first-class objects, and also contains port and adapter interfaces (ports), which include ORM interfaces, search engine interfaces, messaging interfaces, etc. In the case where we use command bus and / or query bus, on this level are the corresponding command and query handlers. <br><br>  Application services and / or command handlers contain the logic for deploying a use case, a business process.  As a rule, their role is as follows: <br><br><ol><li>  use the repository to search for one or more entities; </li><li>  ask these entities to perform some domain logic; </li><li>  and use the repository to re-save entities, effectively saving changes to the data. </li></ol><br>  Command handlers can be used in two ways: <br><br><ol><li>  They may contain logic to execute a use case; </li><li>  They can be used as simple parts of a connection in our architecture that receive a command and simply call logic that exists in the application service. </li></ol><br>  Which approach to use depends on the context, for example: <br><br><ul><li>  We already have application services and are now adding a command bus? </li><li>  Does the command bus allow you to specify a class / method as a handler, or do you need to extend or implement existing classes or interfaces? </li></ul><br>  This level also contains the initiation <b>of application events</b> , which are some result of a use case.  These events trigger logic, which is a side effect of a use case, such as sending emails, notifying third-party APIs, sending push notifications, or even launching another use case belonging to another component of the application. <br><br><a name="10"></a><h2>  Domain Level </h2><br>  Further inside there is a domain level.  Objects at this level contain data and logic for managing this data, which are specific for the domain itself and do not depend on the business processes that run this logic.  They are independent and completely unaware of the application layer. <br><br> <a href=""><img src="https://habrastorage.org/webt/sm/tl/z2/smtlz2wmhuiysntbvasfqotc7zs.png"></a> <br><br><a name="11"></a><h3>  Domain Services </h3><br>  As I mentioned above, the application service role: <br><br><ol><li>  use the repository to search for one or more entities; </li><li>  ask these entities to perform some domain logic; </li><li>  and use the repository to re-save entities, effectively saving changes to the data. </li></ol><br>  But sometimes we encounter some domain logic, which includes various entities of the same or different types, and this domain logic does not belong to the entities themselves, that is, the logic is not their direct responsibility. <br><br>  Therefore, our first reaction may be to place this logic outside the entities in the application service.  However, this means that in other cases the domain logic will not be reused: the domain logic must remain outside the application level! <br><br>  The solution is to create a domain service, the role of which is to obtain a set of entities and execute some business logic on them.  The domain service belongs to the domain level and therefore does not know anything about classes at the application level, such as application services or repositories.  On the other hand, it can use other domain services and, of course, domain model objects. <br><br><a name="12"></a><h3>  Domain Model </h3><br>  In the center is the domain model.  It does not depend on anything outside of this circle and contains business objects representing something in the domain.  Examples of such objects are, first of all, entities, as well as value objects (value objects), enumerations (enums) and any objects used in the domain model. <br><br>  Domain events also live in the domain model.  When a particular data set is changed, these events are triggered, which contain new values ‚Äã‚Äãof the changed properties.  These events are ideal, for example, for use in an event sourcing module. <br><br><a name="13"></a><h1>  Components </h1><br>  So far, we have isolated the code by layers, but this is too detailed isolation of the code.  It is equally important to look at the picture with a more general view.  We are talking about the separation of code by subdomains and <i><b><a href="http://ddd.fed.wiki.org/view/welcome-visitors/view/domain-driven-design/view/bounded-context">related contexts</a></b></i> in accordance with the ideas of Robert Martin, expressed in the <i><b><a href="https://8thlight.com/blog/uncle-bob/2011/09/30/Screaming-Architecture.html">screaming architecture</a></b></i> [that is, the architecture should ‚Äúshout‚Äù about the application itself, and not about what frameworks it uses - approx.  trans.].  Here they talk about the organization of packages by function or by component, not by layers, and Simon Brown explained this quite well in the article <a href="http://www.codingthearchitecture.com/2015/03/08/package_by_component_and_architecturally_aligned_testing.html">‚ÄúComponent packages and testing in accordance with the architecture‚Äù</a> in his blog: <br><br> <a href=""><img src="https://habrastorage.org/webt/mf/n5/un/mfn5unjrsm8lmkufaoj55mfyqk0.png"></a> <br><br>  I am a supporter of organizing packages by components and I want to shamelessly change Simon Brown's diagram as follows: <br><br> <a href=""><img src="https://habrastorage.org/webt/xn/ng/nd/xnngndzw3fq5rcvzvitudp-kpns.png"></a> <br><br>  These sections of the code are pass-through for all layers described earlier, and these are <i><b><a href="https://herbertograca.com/2017/07/05/software-architecture-premises/">components of</a></b></i> our application.  Examples of components are billing, user, verification, or account, but they are always associated with a domain.  Restricted contexts, such as authorization and / or authentication, should be considered as external tools for which we create an adapter and hide behind some port. <br><br> <a href=""><img src="https://habrastorage.org/webt/9v/kd/ou/9vkdouyaegscibkngn0ui0ltbko.png"></a> <br><br><a name="14"></a><h2>  Separation of components </h2><br>  Just as in fine-grained code units (classes, interfaces, traits, mixins, etc.), large units (components) benefit from weak coupling and tight connectivity. <br><br>  To separate classes, we use dependency injection, introducing dependencies into the class, rather than creating them inside the class, as well as dependency inversion, making the class dependent on abstractions (interfaces and / or abstract classes) instead of concrete classes.  This means that the dependent class knows nothing about the specific class that it will use, it does not have a reference to the full name of the classes on which it depends. <br><br>  Similarly, in a fully decoupled component, each component knows nothing about any other component.  In other words, it has no reference to any fine-grained block of code from another component, even the interface!  This means that dependency injection and dependency inversion are not enough to separate the components, we need some kind of architectural design.  Events, common core, eventual consistency, and even a discovery service may be needed! <br><br> <a href=""><img src="https://habrastorage.org/webt/wp/gk/2w/wpgk2wxy5fgyjtrwuzctapvv19y.png"></a> <br><br><a name="15"></a><h3>  Triggering logic in other components </h3><br>  When one of our components (component B) has to do something whenever something else happens in another component (component A), we cannot simply make a direct call from component A to the class / method of component B, because then A will be associated with B. <br><br>  However, we can use the event dispatcher to send an application event that will be delivered to any component that listens on it, including B, and the event listener on B will trigger the desired action.  This means that component A will depend on the event dispatcher, but will be separated from component B. <br><br>  However, if the event itself ‚Äúlives‚Äù in A, this means that B is aware of the existence of A and is associated with it.  To remove this dependency, we can create a library with a set of application core functionality that will be shared among all components ‚Äî a <a href="http://ddd.fed.wiki.org/view/welcome-visitors/view/domain-driven-design/view/shared-kernel">common core</a> .  This means that both components will depend on a common core, but will be separated from each other.  The common kernel contains functionality, such as application and domain events, but it can also contain specification objects and everything that makes sense to share.  However, it should be the minimum size, because any changes in the common core will affect all components of the application.  In addition, if we have a polyglot system, say, an ecosystem of microservices in different languages, then the common core should not depend on the language so that all components can understand it.  For example, instead of a common kernel with an event class, it would contain an event description (that is, a name, properties, perhaps even methods, although they would be more useful in a specification object) in a universal language like JSON, so that all components / microservices could interpret it and perhaps even automatically generate your own specific implementations. <br><br>  This approach works in both monolithic and distributed applications, such as microservice ecosystems.  But if events can only be delivered asynchronously, then this approach is not enough for contexts where the launch logic in other components should work immediately!  Here, component A will need to make a direct HTTP call to component B. In this case, to disconnect the components, we need a discovery service.  Component A will ask her where to send the request to initiate the desired action.  Alternatively, make a request to the discovery service, which will transfer it to the appropriate service and ultimately return the response to the requestor.  This approach links components to the discovery service, but does not link them to each other. <br><br><a name="16"></a><h3>  Retrieving data from other components </h3><br>  As I see it, a component is not allowed to change data that it does not ‚Äúown‚Äù, but it can request and use any data. <br><br><a name="17"></a><h4>  Shared Data Warehouse for Components </h4><br>  If a component must use data belonging to another component (for example, the billing component must use the client's name that belongs to the accounts component), then it contains the request object to the data storage.  That is, the billing component can be aware of any data set, but must use ‚Äúother people's‚Äù data read-only. <br><br><a name="18"></a><h4>  Separate data storage for a component </h4><br>  In this case, the same template is used, but the data storage level becomes more difficult.  The presence of components with their own data storage means that each data warehouse contains: <br><br><ul><li>  The data set that the component owns and can change, making it the only source of truth; </li><li>  A data set that is a copy of the data of other components that it cannot change by itself, but they are necessary for the functionality of the component.  This data must be updated whenever it changes in the owner component. </li></ul><br>  Each component will create a local copy of the data it needs from other components, which will be used as needed.  When data changes in the component to which it belongs, this owner component triggers a domain event that carries data changes.  Components containing a copy of this data will listen to this domain event and update their local copy accordingly. <br><br><a name="19"></a><h1>  Control flow </h1><br>  As I said above, the control flow goes from the user to the application core, to the infrastructure tools, then back to the application core - and back to the user.  But how exactly do classes work together?  Who depends on whom?  How do we make them? <br><br>  As Uncle Bob in his article on Clean Architecture, I will try to explain the flow of control of UMLish schemes ... <br><br><h2>  No command / query bus </h2><br>  If we do not use the command bus, the controllers will depend either on the application service or on the Query object. <br><br>  <sup>[Addition 18.11.2017] I completely missed the DTO, which I use to return data from the request, so now I added it.</sup>  <sup>Thank you <a href="https://www.reddit.com/user/MorphineAdministered">MorphineAdministered for</a> <a href="https://www.reddit.com/r/PHP/comments/7dcz8k/ddd_hexagonal_onion_clean_cqrs_how_i_put_it_all/dpy6va4/">pointing out</a> the space.</sup> <br> <a href=""><img src="https://habrastorage.org/webt/hg/ak/_p/hgak_pjjk5jb-5klihtccnlb7dy.png"></a> <br>  In the diagram above, we use the interface for the application service, although we can say that it is not really needed, because the application service is part of our application code.  But we do not want to change the implementation, although we can conduct a full refactoring. <br><br>  The Query object contains an optimized query that simply returns some raw data that will be shown to the user.  This data is returned to the DTO, which is embedded in the ViewModel.  This ViewModel can have some kind of View logic and will be used to populate the View. <br><br>  On the other hand, the application service contains the logic of use cases, which is triggered when we want to do something in the system, and not just view some data.  The application service depends on repositories that return entities that contain the logic that needs to be initiated.  It may also depend on the domain service to coordinate the domain process in several entities, but this is a rare case. <br><br>  After analyzing the use case, the application service can notify the entire system that the use case has occurred, then it will still depend on the event dispatcher to trigger the event. <br><br>  It is interesting to note that we place interfaces both on the persistence engine and on repositories.  This may seem redundant, but they serve different purposes: <br><br><ul><li>  The persistence interface is a level of abstraction over ORM, so that we can change the ORM without changes in the application core. </li><li>  The repository interface is an abstraction over the persistence engine itself.  Suppose we want to switch from MySQL to MongoDB.  In this case, the persistence interface can remain the same, and if we want to continue using the same ORM, even the persistence adapter will remain the same.  However, the query language is completely different, so we can create new repositories that use the same storage mechanism, implement the same repository interfaces, but build queries using MongoDB query language instead of SQL. </li></ul><br><h2>  Bus commands / requests </h2><br>  In case our application uses a command / query bus, the diagram remains almost the same, except that the controller now depends on the bus, as well as on commands or queries.  An instance of a command or request is created here and passed to the bus, which will find the appropriate handler to receive and process the command. <br><br>  In the diagram below, the command handler uses the application service.  But this is not always necessary, because in most cases the handler will contain all the logic of the use case.  We only need to extract the logic from the handler to a separate application service if you need to reuse the same logic in another handler. <br><br>  <sup>[Addition 18.11.2017] I completely missed the DTO, which I use to return data from the request, so now I added it.</sup>  <sup>Thank you <a href="https://www.reddit.com/user/MorphineAdministered">MorphineAdministered for</a> <a href="https://www.reddit.com/r/PHP/comments/7dcz8k/ddd_hexagonal_onion_clean_cqrs_how_i_put_it_all/dpy6va4/">pointing out</a> the space.</sup> <br> <a href=""><img src="https://habrastorage.org/webt/dh/vh/c1/dhvhc1qxek9af6wc2ztmfqq4m4u.png"></a> <br>  You may have noticed that there are no dependencies between the bus, the command, the request and the handlers.  In fact, they do not need to know about each other in order to ensure good separation.  The way to direct a bus to a specific handler to process a command or request is configured in a simple configuration. <br><br>  In both cases, all arrows ‚Äî dependencies that intersect the core of the application ‚Äî point inward.  As explained earlier, this is a fundamental rule of the Ports &amp; Adapters architecture, Onion architecture and Clean architecture. <br><br> <a href=""><img src="https://habrastorage.org/webt/la/3y/qs/la3yqsseqajawy91dvvrzcgzuku.png"></a> <br><br><h1>  Conclusion </h1><br>  As always, the goal is to get a disconnected code base with high connectivity, in which you can easily, quickly and safely make any changes. <br><br><blockquote>  Plans are useless, but planning is everything.  - <i>Eisenhower</i> </blockquote><br>  This infographic is a concept map.  Knowing and understanding all these concepts helps you plan a healthy architecture and a workable application. <br><br>  But: <br><br><blockquote>  The map is not a territory.  - <i>Alfred Corzybsky</i> </blockquote><br>  In other words, <b>these are just recommendations!</b>  <b>An application is a territory, a reality, a specific use case, where you need to apply our knowledge, and it determines what the real architecture will look like!</b> <br><br>  <b>We need to understand all these patterns, but also always need to think and understand what our application needs, how far we can go for the sake of disconnection and connectivity.</b>  This decision depends on many factors, starting with the functional requirements of the project, to the development time of the application, its service life, the experience of the development team and so on. <br><br>  That's how I imagine all this for myself. <br><br>  These ideas are discussed in more detail in the following article: <a href="https://herbertograca.com/2018/07/07/more-than-concentric-layers/">‚ÄúMore than just concentric layers</a> . <a href="https://herbertograca.com/2018/07/07/more-than-concentric-layers/">‚Äù</a> </div><p>Source: <a href="https://habr.com/ru/post/427739/">https://habr.com/ru/post/427739/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../427729/index.html">How to set up a firewall on the server with Zimbra?</a></li>
<li><a href="../427731/index.html">Linus Torvalds back into service after the release of the 4.19 kernel version</a></li>
<li><a href="../427733/index.html">Cyberpunk 2000: Deus Ex creation tools</a></li>
<li><a href="../427735/index.html">Analysis of the game from classmates on Joker 2018</a></li>
<li><a href="../427737/index.html">Journey to the Land of Giants: ONYX BOOX Gulliver Overview</a></li>
<li><a href="../427741/index.html">Code Generator for Laravel - input OAS, output JSON-API</a></li>
<li><a href="../427743/index.html">Funny and strange: we collected search queries that we like.</a></li>
<li><a href="../427745/index.html">Kubernetes tips & tricks: access to dev sites</a></li>
<li><a href="../427747/index.html">Who to crush an unmanned vehicle: the results of the Moral Machine experiment</a></li>
<li><a href="../427749/index.html">Apple and Samsung for the first time fined slowing down old phones</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>