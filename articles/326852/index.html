<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Cooking Physically Based Rendering + Image-based Lighting. Theory + practice. Step by step</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hey, hello. 2017 is in the yard. Even unpretentious mobile and browser applications are beginning to slowly draw physically correct lighting. The Inte...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Cooking Physically Based Rendering + Image-based Lighting. Theory + practice. Step by step</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/web/601/516/b79/601516b79c8c4fc08f6f94c7d3528196.png" align="left">  Hey, hello.  2017 is in the yard.  Even unpretentious mobile and browser applications are beginning to slowly draw physically correct lighting.  The Internet is replete with a bunch of articles and ready-made shaders.  And it seems that it should be so easy to smear PBR too ... Or not? <br><br>  In reality, honest PBR is difficult to do, because it is easy to achieve a similar result, but it is difficult to achieve the right result.  And the Internet is full of articles that do exactly the same result, instead of the correct one.  Separating flies from cutlets in this chaos becomes difficult. <br>  Therefore, the purpose of the article is not only to understand what PBR is and how it works, but also to learn how to write it.  How to debug, where to look, and what errors can typically be made. <br>  The article is intended for people who already know hlsl and are quite familiar with linear algebra, and you can write your simplest nonPBR Phong light.  In general, I will try to explain as simply as possible, but I hope that you already have some experience with shaders. <br><a name="habracut"></a><br>  The examples will be written in Delphi (and compiled under FreePascal), but the main code will still be in hlsl.  Therefore, do not be afraid if you do not know Delphi. <br><br><div class="spoiler">  <b class="spoiler_title">Where can I see and touch?</b> <div class="spoiler_text">  To build the examples, you'll need the <a href="https://github.com/MrShoor/AvalancheProject">AvalancheProject</a> code.  This is my DX11 / OpenGL framework.  You will also need the <a href="http://imaginglib.sourceforge.net/">Vampyre Imaging Library</a> .  This is a library for working with pictures, I use it to load textures.  The source code for the examples is <a href="https://github.com/MrShoor/PBRSamples">here</a> .  For those who do not want / can not collect binaries, and wants to use the already collected, then they are <a href="">here</a> . <br></div></div><br>  So we fastened the seat belts, let's go. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  1 Importance of sRGB support </h2><br>  Our monitors usually show an sRGB image.  This is 95% true for desktops, and to some extent true for laptops (and on phones there is total arbitrariness). <br>  This is due to the fact that our perception is not linear, and we notice small changes in light in dark areas better than the same absolute changes in light areas.  If it is rough, then when you increase the brightness by 4 times, we perceive it as an increase in brightness by 2 times.  I prepared you a picture: <br><br><img src="https://habrastorage.org/files/fa4/70f/727/fa470f72751241c7a0875df482f7d8c1.png"><br><br>  Before trying to understand the picture - make sure that your browser or operating system has not resized the image. <br><br>  In the middle of the square, consisting of horizontal single-pixel black and white stripes.  The amount of light from this square is exactly 2 times less than from pure white.  Now, if you move away from the screen so that the stripes merge into a square of the same color, then on the calibrated monitor the central square should merge with the right square, and the left one will be much darker.  If you now take the color of the left square with a pipette, you will find that it is 128, and the right one - 187. It turns out that when mixing 50/50 black: 0 0 0 and white 255 255 255 we get not ~ 128 128 128, but already 187 187 187. <br><br>  Therefore, for a physically correct render, it is important for us that the white multiplied by 0.5 on the screen becomes 187 187 187. For this, the graphic API (DirectX and OpenGL) has hardware support for sRGB.  When working with textures in the shader, they are transferred to the linear space, and when displayed on the screen they are transferred back to sRGB. <br><br>  I will not dwell on how to achieve this in DirectX / OpenGL.  This is easy to google.  And make sure that your sRGB is working quite simply.  The linear gradient from black to white should change something like this: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2b8/657/6bb/2b86576bbf666ee72654264e5011ca50.jpg" alt="image"><br><br>  I just needed to show the importance of working in linear space, because this <b>is one of the first mistakes</b> that is found on the Internet in articles about PBR. <br><br><h2>  2 Cook-Torrance </h2><br>  A physically correct render usually takes into account such things as: <br><br><ol><li>  Fresnel Reflection Ratios </li><li>  Law of energy conservation </li><li>  <b>Microfacet theory</b> for reflected light and reradiated </li></ol><br>  The list can be extended to microfacet theory for subsurface scattering and physically correct refraction, etc., but in the context of this article we will talk about the first three points. <br><br><h3>  2.1 Microfacet Theory </h3><br>  The surfaces of various materials in the real world are not absolutely smooth, but very rough.  These irregularities are much longer than the light wavelength, and make a significant contribution to the illumination.  It is impossible to describe a rough plane with one normal vector, and the normal usually describes a certain average value of the macro-surface: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b7f/719/038/b7f719038ed90d85fe7cc806bdc804dc.png" alt="image"><br><br>  When in fact the main contribution to the reflected light is made precisely by micro-borders: <br><br><img src="https://habrastorage.org/files/e4d/502/6da/e4d5026da47747d0b6b4c666907393d2.PNG"><br><br>  We all remember that the angle of incidence is equal to the angle of reflection, and the vector h in this figure describes precisely the normal of the micrograin, which contributes to the illumination.  It is the light from this point of the surface that we will see. <br><br>  In addition, part of the world does not physically reach the microfaces that could reflect it: <br><br><img src="https://habrastorage.org/files/a98/c83/353/a98c8335310e49acb8d2303bbf44715d.png"><br><br>  This is called self shadowing, or <b>self shadowing</b> . <br><br>  And the light that has reached the surface and reflected is not always able to fly out: <br><br><img src="https://habrastorage.org/files/3e0/d23/263/3e0d2326314e44e191f3340a6a15f44a.png"><br><br>  This is called self-overlap, or <b>masking</b> .  And the most cunning light can be reflected two or more times: <br><br><img src="https://habrastorage.org/files/064/702/d14/064702d1437d4573ae2c7f452496da1d.png"><br><br>  And this effect is <b>called retroreflection</b> .  All these micrograins are described by a roughness coefficient ( <b>roughness</b> ), which usually (but not always) lies in the range (0; 1). At 0, we have a perfectly smooth surface and no micrograins. At 1, micrograins are distributed so that they reflect light in a hemisphere . Sometimes the coefficient of roughness is replaced by the coefficient of smoothness, which is equal to 1-roughness. <br><br>  That's basically all how surfaces behave for reflected light. <br><br><h3>  2.2 Bidirectional Reflectance Distribution Function </h3><br>  So, light reaching the surface is partially reflected, and partially penetrates into the material.  Therefore, from the total flow of light, first isolate the amount of reflected light.  Moreover, we are interested not only in the amount of reflected light, but also in the amount of light that enters our eyes.  And this is described by various <b>Bidirectional Reflectance Distribution Function (BRDF)</b> . <br>  We will consider one of the most popular models - the <b>Cook-Torrance</b> model: <br><br><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/70b610bf99b3f0c30bf64e5e09a0b3ab58c5db9e" alt="image"><br><br>  In this function: <br><br>  <b>V</b> - vector from the surface into the eye of the observer <br>  <b>N</b> - macro-normal surface <br>  <b>L</b> - direction from the surface to the light source <br>  <b>D</b> is the distribution function of the reflected light taking into account the microfaces.  Describes the number of microfaces turned to us so as to reflect light into our eyes. <br>  <b>G</b> is the distribution function of self-shadowing and self-overlapping.  Unfortunately, the light re-reflected several times in this function is not taken into account, and will be lost.  We will return to this point later in the article. <br>  <b>F</b> - Fresnel reflection coefficients.  Not all light is reflected.  Part of the light is refracted and falls inside the material.  In this function, F describes the amount of reflected light. <br><br>  Even in the formula one cannot see such a parameter as the <b>H</b> vector, but it will be actively used in the D and G distribution functions.  The meaning of the <b>H</b> vector is to describe the normal microfaces that contribute to the reflected light.  Those.  a beam of light caught on a micro-facet with a normal <b>H</b> will always be reflected in our eyes.  Since the angle of incidence is equal to the angle of reflection, we can always calculate <b>H</b> as <b>normalize (V + L)</b> .  Something like that: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4e2/4c8/d20/4e24c8d20896b14b02e74a65d67b2eef.png" alt="image"><br><br>  The distribution functions <b>D</b> and <b>G</b> are an approximate solution, and there are many and different ones.  At the end of the article I will leave a reference to the list of such distributions.  We will use the <b>GGX</b> distribution functions developed by Bruce Walter. <br><br><h3>  2.3 G. Overlap geometry </h3><br>  Let's start with self-shadowing and overlapping.  This is a function of <b>G.</b>  <b>The GGX</b> distribution of this function uses the Smith method (Smith 1967, "Geometrical shadowing of a random rough surface").  The main point of this method is that the amount of lost light from the light to the surface and from the surface to the observer will be symmetrical with respect to the macro-normal surface.  Therefore, we can divide the function <b>G</b> into 2 parts, and calculate the first half of the lost light from the angle between <b>N</b> and <b>L</b> , and then using the same function, calculate the lost light from the angle between <b>V</b> and <b>N.</b>  Here is one half of such a function <b>G</b> and describes the distribution of <b>GGX</b> : <br><br><img src="https://habrastorage.org/files/ce5/ae1/533/ce5ae1533742433fb3673360066bd94c.png"><br><br>  In this function <br>  <b>Œ± <sub>g</sub></b> is the square of the surface roughness (roughness * roughness). <br>  <b>Œ∏ <sub>v</sub></b> is the angle between the macronormal of <b>N</b> and in one case the light <b>L</b> , in the other case the vector on the observer <b>V.</b> <br>  <b>Œß</b> is a function that returns zero if the checked beam comes from the opposite side of the normal, otherwise it returns one.  In the HLSL shader, we will remove this from the formula, since  We will check at the earliest stages, and do not illuminate such a pixel at all.  In the original formula, we have a tangent, but for the render it is convenient to use the cosine of the angle, since  we get it through the scalar product.  Therefore, I slightly transformed the formula and wrote it in HLSL code: <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GGX_PartialGeometry</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> cosThetaN, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> alpha)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> cosTheta_sqr = saturate(cosThetaN*cosThetaN); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> tan2 = ( <span class="hljs-number"><span class="hljs-number">1</span></span> - cosTheta_sqr ) / cosTheta_sqr; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> GP = <span class="hljs-number"><span class="hljs-number">2</span></span> / ( <span class="hljs-number"><span class="hljs-number">1</span></span> + <span class="hljs-built_in"><span class="hljs-built_in">sqrt</span></span>( <span class="hljs-number"><span class="hljs-number">1</span></span> + alpha * alpha * tan2 ) ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> GP; }</code> </pre> <br>  And we consider the total <b>G</b> from the light vector and the observer vector as: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> roug_sqr = roughness*roughness; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> G = GGX_PartialGeometry(dot(N,V), roug_sqr) * GGX_PartialGeometry(dot(N,L), roug_sqr);</code> </pre><br>  If we render the balls and output this <b>G</b> , we get something like this: <br><br><img src="https://habrastorage.org/files/38d/4b1/b73/38d4b1b733234d0e8b7caf2d940e848e.png"><br><br>  The light source is on the left.  The roughness of the balls from left to right is from 0.05 to 1.0. <br><br>  <b>Check</b> : No pixel should be greater than one.  Put this condition here: <br><br><pre> <code class="cpp hljs">Out.Color = G; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Out.Color.r &gt; <span class="hljs-number"><span class="hljs-number">1.000001</span></span>) Out.Color.gb = <span class="hljs-number"><span class="hljs-number">0.0</span></span>;</code> </pre><br>  If at least one output pixel is greater than one, then it will turn red.  If everything is done correctly, all pixels will remain white. <br><br><h3>  2.4 D. Distribution of reflective microfaces </h3><br>  So we have the following parameters: <b>macronormal</b> , <b>roughness</b> , and <b>H</b> vector.  From these parameters, it is possible to establish which% of the microfaces on a given pixel have a normal coinciding with <b>H.</b>  In <b>GGX</b> , this function is responsible for this: <br><br><img src="https://habrastorage.org/files/807/eb1/fae/807eb1fae3cf48289b84514c5ee0e215.png"><br><br>  <b>Œß</b> is the same function as in the case of <b>G.</b>  We throw it away for the same reasons. <br>  <b>Œ± <sub>g</sub></b> - the square of the surface roughness <br>  <b>Œ∏ <sub>m</sub></b> is the angle between the macronormal of <b>N</b> and our <b>H</b> vector. <br><br>  I made some small transformations again, and replaced the tangent by the cosine of the angle.  As a result, we have the following HLSL function: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GGX_Distribution</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> cosThetaNH, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> alpha)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> alpha2 = alpha * alpha; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> NH_sqr = saturate(cosThetaNH * cosThetaNH); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> den = NH_sqr * alpha2 + (<span class="hljs-number"><span class="hljs-number">1.0</span></span> - NH_sqr); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> alpha2 / ( PI * den * den ); }</code> </pre> <br>  And call it like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> D = GGX_Distribution(dot(N,H), roughness*roughness);</code> </pre> <br>  If we display the value <b>D</b> on the screen, we get something like this: <br><br><img src="https://habrastorage.org/files/fed/4bb/b73/fed4bbb734704948bc0605690f460aac.png"><br><br>  The roughness still varies from 0.05 on the left, to 1.0 on the right. <br><br>  <b>Check</b> : Pay attention to the fact that with a roughness of 1.0 all the light should be distributed evenly throughout the hemisphere.  This means that the last ball must be monotonous.  Its color should be 153,153,153 (+ -1 due to rounding), which, when <a href="http://davengrace.com/cgi-bin/cspace.pl">transferred from sRGB to linear space,</a> will yield 0.318546778125092.  By multiplying this number by PI, we should get approximately one, which corresponds to the reflection on the hemisphere.  Why PI?  Because the <a href="http://www.wolframalpha.com/input/%3Fi%3Dintegrate%2Bcos%2Bx%2B*%2Bsin%2Bx%2Bdx%2Bdy%2Bfrom%2Bx%2B%253D%2B0%2Bto%2Bpi%2B%252F%2B2%2By%2B%253D%2B0%2Bto%2Bpi%2B*%2B2">integral cos (x) sin (x) over the hemisphere</a> gives PI. <br><br><h3>  2.5 F. Fresnel Reflection Ratios </h3><br>  A beam of light hitting the border of two different environments is reflected and refracted. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e7e/170/a83/e7e170a83b8e6445f2f942ba77203ea4.png" alt="image"><br><br>  Fresnel formulas fairly accurately describe the laws by which this happens, but if you <a href="https://ru.wikipedia.org/wiki/%25D0%25A4%25D0%25BE%25D1%2580%25D0%25BC%25D1%2583%25D0%25BB%25D1%258B_%25D0%25A4%25D1%2580%25D0%25B5%25D0%25BD%25D0%25B5%25D0%25BB%25D1%258F">go to the wiki</a> and look at these multi-story formulas, you will see that they are heavy.  Fortunately, there is a good approximation, which is used in most cases in PBR renders, it is <a href="https://en.wikipedia.org/wiki/Schlick%2527s_approximation">Schlick approximation</a> : <br><br><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/1702f2162cbd758ca4fb9afc5740da5bbc1dd6b7" alt="image"><br><br>  Where <b>R0 is</b> calculated as the ratio of the refractive indices: <br>  and <b>cos Œ∏</b> in the formula is the cosine of the angle between the incident light and the normal.  It can be seen that for <b>cosŒ∏ = 1, the</b> formula degenerates into <b>R0</b> , and this means that the physical meaning of <b>R0</b> is the amount of reflected light if the beam falls perpendicular to the surface.  Let's arrange this immediately in the hlsl code: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">float3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FresnelSchlick</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float3 F0, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> cosTheta)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> F0 + (<span class="hljs-number"><span class="hljs-number">1.0</span></span> - F0) * <span class="hljs-built_in"><span class="hljs-built_in">pow</span></span>(<span class="hljs-number"><span class="hljs-number">1.0</span></span> - saturate(cosTheta), <span class="hljs-number"><span class="hljs-number">5.0</span></span>); }</code> </pre> <br>  Note that <b>F0</b> is of type <b>float3</b> .  This is due to the fact that the reflection coefficients may be different for different channels.  Different materials reflect different amounts of light depending on the wavelength: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/79d/b87/798/79db877980588213007c7fba429d8c9d.png" alt="image"><br><br>  And since in our eyes RGB cones, then float3 will be enough for people. <br><br><h3>  2.6 We put together </h3><br>  Well.  Let's now assemble our function that returns the reflected color entirely: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">float3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CookTorrance_GGX</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float3 n, float3 l, float3 v, Material_pbr m)</span></span></span><span class="hljs-function"> </span></span>{ n = normalize(n); v = normalize(v); l = normalize(l); float3 h = normalize(v+l); <span class="hljs-comment"><span class="hljs-comment">//precompute dots float NL = dot(n, l); if (NL &lt;= 0.0) return 0.0; float NV = dot(n, v); if (NV &lt;= 0.0) return 0.0; float NH = dot(n, h); float HV = dot(h, v); //precompute roughness square float roug_sqr = m.roughness*m.roughness; //calc coefficients float G = GGX_PartialGeometry(NV, roug_sqr) * GGX_PartialGeometry(NL, roug_sqr); float D = GGX_Distribution(NH, roug_sqr); float3 F = FresnelSchlick(m.f0, HV); //mix float3 specK = G*D*F*0.25/NV; return max(0.0, specK); }</span></span></code> </pre> <br>  At the very beginning, we filter the light that does not hit the surface: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (NL &lt;= <span class="hljs-number"><span class="hljs-number">0.0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0.0</span></span>;</code> </pre>  as well as areas that we do not see: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (NV &lt;= <span class="hljs-number"><span class="hljs-number">0.0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0.0</span></span>;</code> </pre>  prepare different scalar products, and feed them with our functions <b>GGX_PartialGeometry ()</b> , <b>GGX_Distribution ()</b> , <b>FresnelSchlick ()</b> .  Next, multiply everything according to the formula already mentioned: <br><br><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/70b610bf99b3f0c30bf64e5e09a0b3ab58c5db9e" alt="image"><br><br>  Please note that I did not divide into NL: <br><br><pre> <code class="cpp hljs">float3 specK = G*D*F*<span class="hljs-number"><span class="hljs-number">0.25</span></span>/NV;</code> </pre> <br>  because then we still multiply by <b>NL</b> , and <b>NL is</b> reduced.  At the exit, I got this picture: <br><br><img src="https://habrastorage.org/files/309/7bb/aba/3097bbaba4b84d18b90e93b5bd1853e1.png"><br><br>  From left to right, the roughness increases from 0.05 to 1.0 <br>  From top to bottom, the different Fresnel <b>F0</b> coefficients are: <br>  1. (0.04, 0.04, 0.04) <br>  2. (0.24, 0.24, 0.24) <br>  3. (1.0, 0.86, 0.56) <br><br><h3>  2.7 Lambertian diffused light model </h3><br>  So the <b>FresnelSchlick</b> function will return us the amount of reflected light.  The rest of the light will be <b>1.0-FresnelSchlick ()</b> . <br><br><div class="spoiler">  <b class="spoiler_title">Here I want to make a retreat.</b> <div class="spoiler_text">  Many consider this unit minus Fresnel differently.  For example, in UE4, FresnelSchlick is counted from dot (V, H).  Somewhere take two coefficients (from dot (L, N) and dot (V, N)).  As for me - it is more logical to take from dot (L, N).  Now I can say that I do not know exactly how correct, and how will be closer to reality.  When I study this question, I will fill this gap in the article, but for now we will do it as in UE4, that is, dot (V, H). </div></div><br>  This light will pass through the surface and will randomly wander inside it until it is absorbed / reemitted / leaves the surface at another point.  Since we are not yet affecting the subsurface scattering, then roughly assume that this light will be absorbed or reemitted in a hemisphere: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/685/485/823/6854858239a6ec3e1ad875c8acd4ac55.png" alt="image"><br><br>  In the first approximation, it will suit us.  This dispersion is described by the <b>Lambert</b> lighting model.  This is described by the simplest formula <b>LightColor * dot (N, L) / PI</b> .  That is, everyone is familiar with <b>dot (N, L)</b> , which describes the density of the light flux reaching the surface, and the division by <b>PI</b> with which we have already met in the form of an <a href="http://www.wolframalpha.com/input/%3Fi%3Dintegrate%2Bcos%2Bx%2B*%2Bsin%2Bx%2Bdx%2Bdy%2Bfrom%2Bx%2B%253D%2B0%2Bto%2Bpi%2B%252F%2B2%2By%2B%253D%2B0%2Bto%2Bpi%2B*%2B2">integral hemisphere</a> .  The amount of light absorbed / reradiated describes the <b>float3</b> parameter, which is called <b>albedo</b> .  It's all very similar with the <b>F0</b> parameter.  The subject re-radiates only certain wavelengths. <br><br>  Since there is nothing more to say about the Lambert lighting model, then we add it to our <b>CookTorrance_GGX</b> (although it might have been more correct to put it into a separate function, but I am too lazy to pull out the F parameter): <br><br><pre> <code class="cpp hljs"> float3 specK = G*D*F*<span class="hljs-number"><span class="hljs-number">0.25</span></span>/(NV+<span class="hljs-number"><span class="hljs-number">0.001</span></span>); float3 diffK = saturate(<span class="hljs-number"><span class="hljs-number">1.0</span></span>-F); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> max(<span class="hljs-number"><span class="hljs-number">0.0</span></span>, m.albedo*diffK*NL/PI + specK);</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">But in general, the function has become such</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">float3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CookTorrance_GGX</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float3 n, float3 l, float3 v, Material_pbr m)</span></span></span><span class="hljs-function"> </span></span>{ n = normalize(n); v = normalize(v); l = normalize(l); float3 h = normalize(v+l); <span class="hljs-comment"><span class="hljs-comment">//precompute dots float NL = dot(n, l); if (NL &lt;= 0.0) return 0.0; float NV = dot(n, v); if (NV &lt;= 0.0) return 0.0; float NH = dot(n, h); float HV = dot(h, v); //precompute roughness square float roug_sqr = m.roughness*m.roughness; //calc coefficients float G = GGX_PartialGeometry(NV, roug_sqr) * GGX_PartialGeometry(NL, roug_sqr); float D = GGX_Distribution(NH, roug_sqr); float3 F = FresnelSchlick(m.f0, HV); //mix float3 specK = G*D*F*0.25/(NV+0.001); float3 diffK = saturate(1.0-F); return max(0.0, m.albedo*diffK*NL/PI + specK); }</span></span></code> </pre> <br></div></div><br>  Here is what I did after adding the diffuse component: <br><br><img src="https://habrastorage.org/files/3f0/513/ef5/3f0513ef51f94cce9ceba491ed465280.png"><br><br>  Albedo of three materials (in linear space) from top to bottom: <br><br>  1. (0.47, 0.78, 0.73) <br>  2. (0.86, 0.176, 0) <br>  3. (0.01, 0.01, 0.01) <br><br>  Well, here I put the second light source on the right, and increased the intensity of the sources 3 times: <br><br><img src="https://habrastorage.org/files/1e8/77c/d24/1e877cd24cb540c6b903f6687b991301.png"><br><br>  The current example can be downloaded <a href="https://github.com/MrShoor/PBRSamples/tree/master/PBR">here</a> in the repository.  I also remind you that the collected versions of the examples <a href="">here</a> . <br><br><h2>  3.0 Image based lighting </h2><br><img src="https://habrastorage.org/web/066/af5/df4/066af5df49bf4d7eb58d66af777b41af.jpg"><br><br>  We have now examined how a point source of light contributes to the illumination of each pixel of an image.  Of course, we neglected the fact that the source should decay from the square of the distance, as well as the fact that the source cannot be a point source, and we could take all this into account, but let's look at another approach to lighting.  The fact is that all the objects around reflect / reradiate light, and thereby illuminate the environment.  You come to the mirror and see yourself.  The reflected light in the mirror was re-emitted / reflected by your body not so long ago, and that is why you see yourself in it.  If we want to receive beautiful reflections in smooth objects, then we will need to count for each pixel the light from the hemisphere surrounding this pixel.  In games use in this case such fake.  Prepare a large texture with the environment (in fact, a 360 ¬∞ photo or a cubic map).  Each pixel of such a photo is a small emitter.  Next, with the help of ‚Äúsome magic‚Äù, pixels are selected from such textures, and the pixel is drawn with the code that we wrote above for point sources.  That is why the technique is called Image based lighting (ie, the texture of the environment is used as a source of light). <br><br><h3>  3.1 Monte-Carlo </h3><br>  Let's start with the simple.  Use the Monte Carlo method to calculate our coverage.  For those who are afraid and do not understand the terrible words "Monte Carlo method" I will try to explain on the fingers.  All points in the map affect the lighting of each point.  We can eliminate half of them.  These are those that are on the opposite side of the surface, as they will give zero contribution to the lighting.  We still have a hemisphere.  Now we can let random evenly distributed rays over this hemisphere, and stack the lighting in a heap, and then divide by the number of fired rays and multiply by 2œÄ.  At 2œÄ, this is the area of ‚Äã‚Äãa hemisphere with a radius of 1. Mathematicians will say that we have integrated lighting over the hemisphere by the Monte Carlo method. <br><br>  How will this work in practice?  We will pile up the texture using an additive blending using a floating point render.  In the alpha channel of this texture we will record the number of our rays, and in rgb the actual lighting.  This will allow us to split color.rgb into color.a and get the final image. <br><br>  However, additive blending means that objects overlapped by other objects will begin to shine through others, as they will be drawn.  To avoid this problem, we will use the <b>depth prepass</b> technique.  The essence of the technique is that we first draw objects <b>only into the depth buffer</b> , and then <b>switch the depth test to equal</b> and draw the objects now <b>into the color buffer</b> . <br><br>  So, then I generate a bunch of rays evenly distributed over the sphere: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RandomRay</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> TVec3; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> theta, cosphi, sinphi: Single; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> theta := <span class="hljs-number"><span class="hljs-number">2</span></span> * Pi * Random; cosphi := <span class="hljs-number"><span class="hljs-number">1</span></span> - <span class="hljs-number"><span class="hljs-number">2</span></span> * Random; sinphi := sqrt(<span class="hljs-number"><span class="hljs-number">1</span></span> - min(<span class="hljs-number"><span class="hljs-number">1.0</span></span>, sqr(cosphi))); Result.x := sinphi * cos(theta); Result.y := sinphi * sin(theta); Result.z := cosphi; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; SetLength(Result, ACount); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> ACount - <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> Result[i] := Vec(RandomRay(), <span class="hljs-number"><span class="hljs-number">1.0</span></span>);</code> </pre> <br>  and send this stuff as a constant to this shader: <br><br><pre> <code class="cpp hljs">float3 m_albedo; float3 m_f0; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> m_roughness; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> LightInt = <span class="hljs-number"><span class="hljs-number">1.0</span></span>; <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SamplesCount 1024 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MaxSamplesCount 1024 float4 uLightDirections[MaxSamplesCount]; TextureCube uEnviroment; SamplerState uEnviromentSampler; PS_Output PS(VS_Output In) { PS_Output Out; Material_pbr m; m.albedo = m_albedo; m.f0 = m_f0; m.roughness = m_roughness; float3 MacroNormal = normalize(In.vNorm); float3 ViewDir = normalize(-In.vCoord); Out.Color.rgb = 0.0; [fastopt] for (uint i=0; i&lt;SamplesCount; i++){ </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//      float3 LightDir = dot(uLightDirections[i].xyz, In.vNorm) &lt; 0 ? -uLightDirections[i].xyz : uLightDirections[i].xyz; //        180,      float3 LightColor = uEnviroment.SampleLevel(uEnviromentSampler, mul(LightDir, (float3x3)V_InverseMatrix), 0.0).rgb*LightInt; //       ( ) Out.Color.rgb += CookTorrance_GGX(MacroNormal, LightDir, ViewDir, m)*LightColor; //          } Out.Color.rgb *= 2*PI; //       Out.Color.a = SamplesCount; //      return Out; }</span></span></span></span></code> </pre> <br>  We start, and we see how our picture for the same balls gradually converges.  I used two cubic cards for rendering.  Here for this: <br><br><img src="https://habrastorage.org/web/bd0/3ac/912/bd03ac9127c64e719496b11ac43e6485.png"><br><br>  I took the cubic card that came with RenderMonkey.  It is called Snow.dds.  This is an <b>LDR</b> texture, and it is dull.  Bulbs seem more dirty than beautifully lit. <br><br>  And for this: <br><br><img src="https://habrastorage.org/web/d97/088/a47/d97088a476d34a83adc7e525c559867d.png"><br><br>  I took the <b>HDR Probe</b> from here: <a href="http://www.pauldebevec.com/Probes/">www.pauldebevec.com/Probes</a> called Grace Cathedral, San Francisco.  She has a dynamic range of 200,000: 1.  See, what's the difference?  Therefore, when you will do this kind of lighting, take the <b>HDR</b> texture immediately. <br>  By the way, let's see what the law of conservation of energy holds.  For this, I forcedly set the albedo in the shader to 1.0: <br><br>  m.albedo = 1.0; <br>  Light set in 1.0: <br>  LightColor = 1.0; <br><br>  Ideally, each pixel of the ball should now be equal to one.  Therefore, everything that goes beyond the unit will be marked in red.  I got this: <br><br><img src="https://habrastorage.org/web/477/8ad/5bf/4778ad5bf14d4aa1b5a21aaa9b541a24.png"><br><br>  In fact, the red that is now - this error.  It begins to converge, but at some point float accuracy is not enough, and convergence disappears.  Please note that the right lower ball "turned blue".  This is due to the fact that the Lambert model does not take into account the surface roughness, and the Cook-Torrens model does not take them into account with a polonster.  In fact, we lost the yellow color that goes to <b>F0</b> .  Let's try to set <b>F0 to</b> all balls set to 1.0 and see: <br><br><img src="https://habrastorage.org/web/277/388/fc4/277388fc4e684a8b9e150b8c68848dbc.png"><br><br>  The right balls became significantly darker due to the large roughness.  In fact, this is a retroreflection that we lost.  Cook-Torrens just loses this energy.  The Oren-Nayar model can partially restore this energy.  But we will postpone it for now.  We'll have to accept the fact that for very rough models we lose up to 70% of retroreflection energy. <br>  The source code is <a href="https://github.com/MrShoor/PBRSamples/tree/master/PBR_env">here</a> .  I already mentioned the collected binaries earlier, they <a href="">are here</a> . <br><br><h3>  3.2 Importance sampling </h3><br>  Of course, the gamer will not wait for the light in your picture to converge.  Something needs to be done to avoid counting thousands and thousands of rays for each pixel.  And the trick here is this.  For Montecarlo, we considered a uniform distribution over the hemisphere.  This is how we sampled: <br><br><img src="http://www.gamedev.ru/files/images/brdf_mc.jpg" alt="image"><br><br>  but the real contribution comes from the part circled in pink.  If we could choose the rays, mainly from the red zone, we would have received an acceptable picture much earlier.  So we want this: <br><br><img src="http://www.gamedev.ru/files/images/brdf_mc_is.jpg" alt="image"><br><br>  Fortunately for this there is a mathematical method called Importance Sampling (or sampling by significance).  Significance in our expression introduces the parameter <b>D.</b>  According to it, we can build a <b>CDF</b> (distribution function) from some <b>PDF</b> function (probability density function).  For <b>PDF,</b> we take the micronormal distribution to our normal, the sum over the hemisphere will give one, which means we can write this integral: <br><br><img src="https://habrastorage.org/web/c56/441/a5b/c56441a5b39f411da7972abfebe91581.png"><br><br>  Here is the integrand - <b>PDF</b> <br>  Taking the integral over the spherical angles, we get the following <b>CDF</b> : <br><br><img src="https://habrastorage.org/web/3db/e83/79c/3dbe8379c07c4bd0a5c342e5e755b9da.PNG"><br><br>  For those who want to step by step go through this stage - you can look <a href="http://blog.tobias-franke.eu/2014/03/30/notes_on_importance_sampling.html">here</a> . <br><br>  For those who do not want / can not go deep say.  We have a <b>CDF</b> , into which we substitute a uniformly distributed <b><i>Œæ</i></b> , we get a distribution at the output that reflects our <b>PDF</b> .  What does this mean for us? <br><br>  1. That this will change our <b>Cook-Torrens</b> function.  It will need to be divided into a <b>PDF</b> function. <br><br>  2. The <b>PDF</b> function reflects the micronormal distribution relative to the macronormal.  Previously, for Monte Carlo, we took a random vector, and took it as a vector to the light source.  Now, using <b>CDF,</b> we choose a random vector <b>H.</b>  Next, we reflect the vector of sight relative to this random <b>H</b> and obtain the vector of light. <br><br>  3. Our <b>PDF</b> should be transferred to the view space (since it reflects the distribution along the vector <b>N</b> ).  To translate, we need to divide our <b>PDF</b> into <b>4 * dot (H, V). It‚Äôs</b> interesting for anyone to go deeper - go <a href="https://www.cs.cornell.edu/~srm/publications/EGSR07-btdf.pdf">here</a> and there are explanations in paragraph 4.1 and further with pictures in circles. <br><br>  It seems that nothing is clear, right?  Let's try to digest all this in code. <br><br>  To begin with, we will write a function that generates the vector <b>H</b> from our <b>CDF</b> .  In HLSL it will be like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">float3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GGX_Sample</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float2 E, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> alpha)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> Phi = <span class="hljs-number"><span class="hljs-number">2.0</span></span>*PI*Ex; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> cosThetha = saturate(<span class="hljs-built_in"><span class="hljs-built_in">sqrt</span></span>( (<span class="hljs-number"><span class="hljs-number">1.0</span></span> - Ey) / (<span class="hljs-number"><span class="hljs-number">1.0</span></span> + alpha*alpha * Ey - Ey) )); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> sinThetha = <span class="hljs-built_in"><span class="hljs-built_in">sqrt</span></span>( <span class="hljs-number"><span class="hljs-number">1.0</span></span> - cosThetha*cosThetha); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> float3(sinThetha*<span class="hljs-built_in"><span class="hljs-built_in">cos</span></span>(Phi), sinThetha*<span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(Phi), cosThetha); }</code> </pre> <br>  Here in <b>E</b> we give a uniform distribution [0; 1) for both spherical angles, in <b>alpha</b> we have a square from the <b>roughness of the</b> material. <br><br>  At the output we get the <b>H</b> vector on the hemisphere.  But this hemisphere needs to be oriented on the surface.  To do this, we write another function that will return us the orientation matrix on the surface: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">float3x3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetSampleTransform</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float3 Normal)</span></span></span><span class="hljs-function"> </span></span>{ float3x3 w; float3 up = <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(Normal.y) &lt; <span class="hljs-number"><span class="hljs-number">0.999</span></span> ? float3(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>) : float3(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>); w[<span class="hljs-number"><span class="hljs-number">0</span></span>] = normalize ( cross( up, Normal ) ); w[<span class="hljs-number"><span class="hljs-number">1</span></span>] = cross( Normal, w[<span class="hljs-number"><span class="hljs-number">0</span></span>] ); w[<span class="hljs-number"><span class="hljs-number">2</span></span>] = Normal; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> w; }</code> </pre> <br>  On this matrix we will multiply all our generated vectors <b>H</b> , translating their tangent space into the space of the form.  The principle is very similar to the TBN basis. <br><br>  It now remains to divide our Cook-Torrens: <b>G * D * F * 0.25 / (NV)</b> into <b>PDF</b> .  Our <b>PDF = D * NH / (4 * HV)</b> .  Therefore, our modified Cook-Torrens is obtained: <br><br>  <b>G * F * HV / (NV * NH)</b> <br><br>  In HLSL, it now looks like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">float3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CookTorrance_GGX_sample</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float3 n, float3 l, float3 v, Material_pbr m, out float3 FK)</span></span></span><span class="hljs-function"> </span></span>{ pdf = <span class="hljs-number"><span class="hljs-number">0.0</span></span>; FK = <span class="hljs-number"><span class="hljs-number">0.0</span></span>; n = normalize(n); v = normalize(v); l = normalize(l); float3 h = normalize(v+l); <span class="hljs-comment"><span class="hljs-comment">//precompute dots float NL = dot(n, l); if (NL &lt;= 0.0) return 0.0; float NV = dot(n, v); if (NV &lt;= 0.0) return 0.0; float NH = dot(n, h); float HV = dot(h, v); //precompute roughness square float roug_sqr = m.roughness*m.roughness; //calc coefficients float G = GGX_PartialGeometry(NV, roug_sqr) * GGX_PartialGeometry(NL, roug_sqr); float3 F = FresnelSchlick(m.f0, HV); FK = F; float3 specK = G*F*HV/(NV*NH); return max(0.0, specK); }</span></span></code> </pre> <br>  Please note that I have thrown out the diffuse part from the Lambert illumination from this function, and return the <b>FK</b> parameter to the outside.  The fact is that we cannot count the diffuse component through <b>Importance Sampling</b> , since  our <b>PDF</b> is for facets that reflect light into our eyes.  And the Lambert distribution does not depend on it.  What to do?  Hmm ... but let's leave the diffuse part black for the time being, and focus on speculation. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">PS_Output </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PS</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(VS_Output In)</span></span></span><span class="hljs-function"> </span></span>{ PS_Output Out; Material_pbr m; m.albedo = m_albedo; m.f0 = m_f0; m.roughness = m_roughness; float3 MacroNormal = normalize(In.vNorm); float3 ViewDir = normalize(-In.vCoord); float3x3 HTransform = GetSampleTransform(MacroNormal); Out.Color.rgb = <span class="hljs-number"><span class="hljs-number">0.0</span></span>; float3 specColor = <span class="hljs-number"><span class="hljs-number">0.0</span></span>; float3 FK_summ = <span class="hljs-number"><span class="hljs-number">0.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (uint i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;(uint)uSamplesCount; i++){ float3 H = GGX_Sample(uHammersleyPts[i].xy, m.roughness*m.roughness); <span class="hljs-comment"><span class="hljs-comment">// H  H = mul(H, HTransform); //       float3 LightDir = reflect(-ViewDir, H); //       float3 specK; float3 FK; specK = CookTorrance_GGX_sample(MacroNormal, LightDir, ViewDir, m, FK); //   FK_summ += FK; float3 LightColor = uRadiance.SampleLevel(uRadianceSampler, mul(LightDir.xyz, (float3x3)V_InverseMatrix), 0).rgb*LightInt;//        specColor += specK * LightColor; //   } specColor /= uSamplesCount; FK_summ /= uSamplesCount; Out.Color.rgb = specColor; Out.Color.a = 1.0; return Out; }</span></span></code> </pre> <br>  We assign 1024 samples (without accumulation as in Monte Carlo) and look at the result: <br><br><img src="https://habrastorage.org/web/ff5/439/b2f/ff5439b2f2e04c2eb240292ce58342ec.png"><br><br>  Although there are a lot of samples, but it turned out noisy.  Especially on the big roughness. <br><br><h3>  3.3 Selecting LODs </h3><br>  This is because we take samples from a highly detailed map, from zero <b>LOD</b> .  And it would be good for the rays having a large deviation to take a smaller LOD.  The situation is well illustrated by this picture: <br><br><img src="https://developer.nvidia.com/sites/all/modules/custom/gpugems/books/GPUGems3/elementLinks/20fig06.jpg" alt="image"><br><br>  From <a href="https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch20.html">this</a> article from NVidia.  The blue areas show the average value, which would be nice to take from the <b>LOD</b> textures.  It can be seen that for more significant we take <b>LOD</b> less, and for less significant we take more, i.e.  we take the value averaged over the region.  It would be ideal if we covered the whole hemisphere with Lods.  Fortunately, NVidia has already given us a ready-made (and simple formula): <br><br><img src="https://developer.nvidia.com/sites/all/modules/custom/gpugems/books/GPUGems3/elementLinks/20equ13.jpg" alt="image"><br><br>  This formula consists of the difference: <br><br><img src="https://habrastorage.org/web/558/1e2/4a9/5581e24a9e5b4f75abd067a7a11b5650.png"><br><br>  The left part of us depends on the size of the texture and the number of samples.  This means that for all samples, we can count it once.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">On the right side we have a function </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , which is nothing more than our </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pdf</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , and a function </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , which they call </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">distortion</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , but in fact there is a dependence on the angle of the sample to the observer. </font><font style="vertical-align: inherit;">For </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> they have this formula:</font></font><br><br><img src="https://developer.nvidia.com/sites/all/modules/custom/gpugems/books/GPUGems3/elementLinks/20equ14.jpg" alt="image"><br><br><div class="spoiler">  <b class="spoiler_title">Spoiler header</b> <div class="spoiler_text"> (,     Dual-Paraboloid .     ,   ,   b      ,      .        <b>b=1.2</b>   ) </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Well, NVidia is also recommended to make </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bias</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> for Lods, add one. </font><font style="vertical-align: inherit;">Let's see how it looks in the hlsl code. </font><font style="vertical-align: inherit;">Here is our left side of the equation:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ComputeLOD_AParam</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> w, h; uRadiance.GetDimensions(w, h); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0.5</span></span>*log2(w*h/uSamplesCount); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Here we consider the right side, and immediately subtract it from the left: </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ComputeLOD</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> AParam, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pdf, float3 l)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> du = <span class="hljs-number"><span class="hljs-number">2.0</span></span>*<span class="hljs-number"><span class="hljs-number">1.2</span></span>*(<span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(lz)+<span class="hljs-number"><span class="hljs-number">1.0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> max(<span class="hljs-number"><span class="hljs-number">0.0</span></span>, AParam<span class="hljs-number"><span class="hljs-number">-0.5</span></span>*log2(pdf*du*du)+<span class="hljs-number"><span class="hljs-number">1.0</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now we see that we </font><font style="vertical-align: inherit;">need to pass </font><b><font style="vertical-align: inherit;">pdf</font></b><font style="vertical-align: inherit;"> and </font><b><font style="vertical-align: inherit;">l</font></b><font style="vertical-align: inherit;"> values </font><font style="vertical-align: inherit;">to </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ComputeLOD</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><b><font style="vertical-align: inherit;">l</font></b><font style="vertical-align: inherit;"> is the vector of the light sample, and </font><b><font style="vertical-align: inherit;">pdf</font></b><font style="vertical-align: inherit;"> , if we look above then this is ours: </font><b><font style="vertical-align: inherit;">pdf = D * dot (N, H) / (4 * dot (H, V))</font></b><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Therefore, let's </font><font style="vertical-align: inherit;">add the returning </font><b><font style="vertical-align: inherit;">pdf</font></b><font style="vertical-align: inherit;"> parameter </font><font style="vertical-align: inherit;">to our </font><b><font style="vertical-align: inherit;">CookTorrance_GGX_sample</font></b><font style="vertical-align: inherit;"> function </font><font style="vertical-align: inherit;">:</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">float3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CookTorrance_GGX_sample</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float3 n, float3 l, float3 v, Material_pbr m, out float3 FK, out </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pdf)</span></span></span><span class="hljs-function"> </span></span>{ pdf = <span class="hljs-number"><span class="hljs-number">0.0</span></span>; FK = <span class="hljs-number"><span class="hljs-number">0.0</span></span>; n = normalize(n); v = normalize(v); l = normalize(l); float3 h = normalize(v+l); <span class="hljs-comment"><span class="hljs-comment">//precompute dots float NL = dot(n, l); if (NL &lt;= 0.0) return 0.0; float NV = dot(n, v); if (NV &lt;= 0.0) return 0.0; float NH = dot(n, h); float HV = dot(h, v); //precompute roughness square float roug_sqr = m.roughness*m.roughness; //calc coefficients float G = GGX_PartialGeometry(NV, roug_sqr) * GGX_PartialGeometry(NL, roug_sqr); float3 F = FresnelSchlick(m.f0, HV); FK = F; float D = GGX_Distribution(NH, roug_sqr); //      D pdf = D*NH/(4.0*HV); //   pdf float3 specK = G*F*HV/(NV*NH); return max(0.0, specK); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And the cycle itself by samples now calculates </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LOD</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> LOD_Aparam = ComputeLOD_AParam(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (uint i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;(uint)uSamplesCount; i++){ float3 H = GGX_Sample(uHammersleyPts[i].xy, m.roughness*m.roughness); H = mul(H, HTransform); float3 LightDir = reflect(-ViewDir, H); float3 specK; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> pdf; float3 FK; specK = CookTorrance_GGX_sample(MacroNormal, LightDir, ViewDir, m, FK, pdf); FK_summ += FK; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> LOD = ComputeLOD(LOD_Aparam, pdf, LightDir); float3 LightColor = uRadiance.SampleLevel(uRadianceSampler, mul(LightDir.xyz, (float3x3)V_InverseMatrix), LOD).rgb*LightInt; specColor += specK * LightColor; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's look at what we did for 1024 samples with LODs: </font></font><br><br><img src="https://habrastorage.org/web/158/278/e0c/158278e0cf90404083c782eaea33d189.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Looks perfect. </font><font style="vertical-align: inherit;">Lower to 16, and ... </font></font><br><br><img src="https://habrastorage.org/web/dc0/216/a4a/dc0216a4aaec4698844908a59dd61cdc.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Yes, of course not quite perfect. </font><font style="vertical-align: inherit;">It can be seen that the quality suffered on the balls with great roughness, but nevertheless, I consider this quality in principle acceptable. </font><font style="vertical-align: inherit;">Additionally, it would be possible to improve the quality if we would </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">build</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> texture </font><b><font style="vertical-align: inherit;">mip files</font></b><font style="vertical-align: inherit;"> based on our distribution. </font><font style="vertical-align: inherit;">You can read about this in the Epic presentation </font></font><a href="https://de45xmedrsdbp.cloudfront.net/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">here</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (see the Pre-Filtered Environment Map paragraph). </font><font style="vertical-align: inherit;">In the meantime, in this article, I propose to focus on the classic pyramidal mipah.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 3.4 Hammersley point set </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you look at our random rays, the drawback is clear. They are random. And we have already learned to read from lods and want to capture as much of our area as possible with our rays. To do this, we need to ‚Äúspray‚Äù our rays, but taking into account the importance of sampling.</font></font> Since <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Since CDF</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> takes a uniform distribution, it is enough for us to evenly space points on the interval [0; 1) ... but our distribution should be two-dimensional. Therefore, it is necessary not only to evenly position the points on the gap, but also to make sure that the distance in Cartesian coordinates between the points is as large as possible. </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hammersley point set is</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> well suited for this role </font><font style="vertical-align: inherit;">. A little more about this set of points can be read </font></font><a href="http://holger.dammertz.org/stuff/notes_HammersleyOnHemisphere.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">here</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I will only show a picture of the distribution: </font></font><br><br><img src="https://habrastorage.org/web/4cf/2a6/e14/4cf2a6e145564f24a00a2068508364d8.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I will also give a function that generates a single point:</font></font><br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HammersleyPoint</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> I, N: Integer)</span></span></span><span class="hljs-function">:</span></span> TVec2; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">radicalInverse_VdC</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(bits: Cardinal)</span></span></span><span class="hljs-function">:</span></span> Single; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> bits := (bits <span class="hljs-keyword"><span class="hljs-keyword">shl</span></span> <span class="hljs-number"><span class="hljs-number">16</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> (bits <span class="hljs-keyword"><span class="hljs-keyword">shr</span></span> <span class="hljs-number"><span class="hljs-number">16</span></span>); bits := ((bits <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> $<span class="hljs-number"><span class="hljs-number">55555555</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">shl</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> ((bits <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> $AAAAAAAA) <span class="hljs-keyword"><span class="hljs-keyword">shr</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>); bits := ((bits <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> $<span class="hljs-number"><span class="hljs-number">33333333</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">shl</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> ((bits <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> $CCCCCCCC) <span class="hljs-keyword"><span class="hljs-keyword">shr</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>); bits := ((bits <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> $<span class="hljs-number"><span class="hljs-number">0</span></span>F0F0F0F) <span class="hljs-keyword"><span class="hljs-keyword">shl</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> ((bits <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> $F0F0F0F0) <span class="hljs-keyword"><span class="hljs-keyword">shr</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span>); bits := ((bits <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> $<span class="hljs-number"><span class="hljs-number">00</span></span>FF00FF) <span class="hljs-keyword"><span class="hljs-keyword">shl</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> ((bits <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> $FF00FF00) <span class="hljs-keyword"><span class="hljs-keyword">shr</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span>); Result := bits * <span class="hljs-number"><span class="hljs-number">2.3283064365386963</span></span>e-<span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Result.x := I/N; Result.y := radicalInverse_VdC(I); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What will our balls look like with this set of points? </font><font style="vertical-align: inherit;">In fact, I faked, and all the above pictures for </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Importance Sampling were</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> generated with a set of these points. </font><font style="vertical-align: inherit;">On random sets of pictures look a little worse (believe a word?)</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 3.5 Irradiance map </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Remember how we were left without a diffuse color? We cannot sample a diffuse color using </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">importance sampling</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , because our </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">importance sampling</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> selects the most valuable rays for a speculator. For diffusion, the most valuable are directly opposite, on the macronormal surface. Fortunately, the diffuse component for Lambert is completely independent of the observer. Therefore, we can pre-calculate the lighting in a cubic map. And one more bonus - changing the angle so slightly affects the lighting that the pre-calculated map can be of very low resolution, for example 16 * 16 pixels per side. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This time we are lucky. We will not write code that builds the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Irradiance map</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , but use the program</font></font><a href="https://seblagarde.wordpress.com/2012/06/10/amd-cubemapgen-for-physically-based-rendering/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CubeMapGen</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Just open our cubemap (Load Cubemap (.dds)), set the Irradiance cubemap checkbox, select Output Cube Size 16: </font></font><br><br><img src="https://habrastorage.org/web/275/aa3/626/275aa362699e424c8a148e45f6a0c1cd.PNG"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and save the resulting cube map (for HDR textures, do not forget to set the desired output format for the texture). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Well, since we dealt with the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Irradiance map</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , then after sampling we just add one sample from this map. </font><font style="vertical-align: inherit;">Our HLSL code now looks like this:</font></font><br><br><pre> <code class="cpp hljs"> Out.Color.rgb = <span class="hljs-number"><span class="hljs-number">0.0</span></span>; float3 specColor = <span class="hljs-number"><span class="hljs-number">0.0</span></span>; float3 FK_summ = <span class="hljs-number"><span class="hljs-number">0.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (uint i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;(uint)uSamplesCount; i++){ float3 H = GGX_Sample(uHammersleyPts[i].xy, m.roughness*m.roughness); H = mul(H, HTransform); float3 LightDir = reflect(-ViewDir, H); float3 specK; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> pdf; float3 FK; specK = CookTorrance_GGX_sample(MacroNormal, LightDir, ViewDir, m, FK, pdf); FK_summ += FK; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> LOD = ComputeLOD(LOD_Aparam, pdf, LightDir); float3 LightColor = uRadiance.SampleLevel(uRadianceSampler, mul(LightDir.xyz, (float3x3)V_InverseMatrix), LOD).rgb*LightInt; specColor += specK * LightColor; } specColor /= uSamplesCount; FK_summ /= uSamplesCount; float3 LightColor = uIrradiance.Sample(uIrradianceSampler, mul(MacroNormal, (float3x3)V_InverseMatrix)).rgb; Out.Color.rgb = m.albedo*saturate(<span class="hljs-number"><span class="hljs-number">1.0</span></span>-FK_summ)*LightColor + specColor;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> And at the output we have the following picture for 16 samples: </font></font><br><br><img src="https://habrastorage.org/web/9eb/ffc/fd2/9ebffcfd26914e4aa89100945a02c03b.png"><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And such for 1024</font></font></b> <div class="spoiler_text"><img src="https://habrastorage.org/web/57b/0b2/8aa/57b0b28aacb141aabed3a9690291e6f4.png"><br></div></div><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Please note that we no longer multiply the diffuse light by </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dot (N, L)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , which is logical. After all, we predicted this illumination and baked it in a cubmap, and in our case </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> are generally the same vector. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's look, what do we have there with energy conservation? As usual, we set the light from the cubic cards to one, set the material albedo to one, and highlight with a red area&gt; 1. We get about this for 1024 samples: </font></font><br><br><img src="https://habrastorage.org/web/ab8/25b/472/ab825b4727d24dd6b1b8c980e859879c.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And this is for 16:</font></font><br><br><img src="https://habrastorage.org/web/4e9/b8c/a93/4e9b8ca935b844c1a0f37bab2c4234d7.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As we see, there are obvious ‚Äúoutliers‚Äù of excess energy, but they are small. </font><font style="vertical-align: inherit;">This is due to the fact that we do not accurately calculate the amount of light from the diffuse energy. </font><font style="vertical-align: inherit;">After all, we consider Fresnel coefficients only for certain specula samples, and use them for all seeds that are pre-calculated in the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">irradiance map</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Alas, I do not know what to do with it, the Internet could not tell me anything. </font><font style="vertical-align: inherit;">Therefore, I propose for now to come to terms with this, all the same, the emissions of excess energy are not significant.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 4 A little more about the materials. </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">While we were fiddling with the balls, you must have noticed that we have two float3 color options. This is </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">albedo</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">f0</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Both of them have some physical meaning, but in games, as a rule, materials are divided into metals and non-metals. The fact is that non-metals always reflect the light in the grayscale ranges, but at the same time they re-radiate the curved light. Metals, on the contrary, reflect colored light, but at the same time absorb the rest. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">That is, for metals we have: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">albedo = {0, 0, 0} </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">f0 = {R, G, B} </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">for dielectrics we have: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">albedo = {R, G, B} </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">f0 = {X, X, X}</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and ... we see that we can enter a certain coefficient [0,1], which we will show as far as our metal surface, and take the material simply through linear interpolation. This is actually many artists do. I downloaded </font></font><a href="https://sketchfab.com/models/0affb3436519401db2bad31cfced95c1"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">this</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 3d model. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here, for example, the texture of the sword. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Texture of color: </font></font><br><br><img src="https://habrastorage.org/web/1df/ec4/1e1/1dfec41e11ea491e83ad32a656b0943e.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Texture of roughness: </font></font><br><br><img src="https://habrastorage.org/web/1a0/c60/61d/1a0c6061ddb34035aa8ddc57f45193eb.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And finally, the texture of metallicity (the one about which I told above): </font></font><br><br><img src="https://habrastorage.org/web/52a/ca8/a2a/52aca8a2a1144c4bb12f0174a7ab0370.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You can read a bit more about materials on the Internet. For example </font></font><a href="https://habrahabr.ru/company/mailru/blog/248873/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">here</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Different engines and studios can pack the parameters in different ways, but as a rule, everything revolves around: color, roughness, metallicity. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And finally, how it looks on the whole model:</font></font><br><br><img src="https://habrastorage.org/web/496/93f/99c/49693f99c3a44178a8659e3745111feb.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">on the left is the same cathedral, which we tested on balls. </font><font style="vertical-align: inherit;">On the right, our Artorias got into nature (the environment map from here </font></font><a href="http://www.pauldebevec.com/Probes/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">www.pauldebevec.com/Probes</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is called Campus). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For rendering these image data, I used additional Reinhard tone mapping, but this topic is for a separate article. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The source code with the Artorias model is a demo in my framework, and is located </font></font><a href="https://github.com/MrShoor/AvalancheProject/tree/master/Demos/Src/avm_Import"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">here</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">I also compiled a version for you, and laid it out </font></font><a href="https://1drv.ms/u/s!AiM3XDRgDCMggT9ubyUpN4RkmIo8"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">here</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 5 Conclusion </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The article came out much more than I expected. </font><font style="vertical-align: inherit;">I wanted to tell more about: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1. Anisotropic lighting model </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2. subsurface scattering </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3. Advanced diffuse lighting model, such as Oren-Nayar </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4. Grab spherical harmonics </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5. Grab tonmapping </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But believe it or not, I ran out of gas while writing this article ... And then everyone point is a fat layer. </font><font style="vertical-align: inherit;">Therefore, there is, that is. </font><font style="vertical-align: inherit;">Maybe someday I will tell about all this. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I hope that my article will lift the curtain of secrets hidden behind these letters PBR. </font><font style="vertical-align: inherit;">And thank you for your attention.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Useful materials on PBR and so on</font></font></b> <div class="spoiler_text"> [1] <a href="http://blog.tobias-franke.eu/2014/03/30/notes_on_importance_sampling.html">blog.tobias-franke.eu/2014/03/30/notes_on_importance_sampling.html</a> <br>   PDF  CDF,     . <br><br> [2] <a href="https://hal.inria.fr/hal-00942452v1/document">hal.inria.fr/hal-00942452v1/document</a> <br>     PBR (+  ) <br><br> [3] <a href="https://disney-animation.s3.amazonaws.com/library/s2012_pbs_disney_brdf_notes_v2.pdf">disney-animation.s3.amazonaws.com/library/s2012_pbs_disney_brdf_notes_v2.pdf</a> <br>    Disney,      .  ,         <br> [4] <a href="http://blog.selfshadow.com/publications/s2015-shading-course/">blog.selfshadow.com/publications/s2015-shading-course/#course_content</a> <br>       Disney <br><br> [5] <a href="https://www.cs.cornell.edu/~srm/publications/EGSR07-btdf.pdf">www.cs.cornell.edu/~srm/publications/EGSR07-btdf.pdf</a> <br>   GGX,  Bruce Walter-     <br><br> [6] <a href="https://de45xmedrsdbp.cloudfront.net/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf">de45xmedrsdbp.cloudfront.net/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf</a> <br>  PBR  Unreal Engine 4 <br><br> [7] <a href="http://holger.dammertz.org/stuff/notes_HammersleyOnHemisphere.html">holger.dammertz.org/stuff/notes_HammersleyOnHemisphere.html</a> <br>    Hammersley Point Set <br><br> [8] <a href="http://www.jordanstevenstechart.com/physically-based-rendering">www.jordanstevenstechart.com/physically-based-rendering</a> <br>   .  . <br><br> [9] <a href="http://graphicrants.blogspot.nl/2013/08/specular-brdf-reference.html">graphicrants.blogspot.nl/2013/08/specular-brdf-reference.html</a> <br>    <br><br> [10] <a href="https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch20.html">developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch20.html</a> <br>     NVidia  Importance Sampling   LOD-. <br><br> [11] <a href="http://cgg.mff.cuni.cz/~jaroslav/papers/2008-egsr-fis/2008-egsr-fis-final-embedded.pdf">cgg.mff.cuni.cz/~jaroslav/papers/2008-egsr-fis/2008-egsr-fis-final-embedded.pdf</a> <br>      Importance Sampling <br><br> [12] <a href="http://gdcvault.com/play/1024478/PBR-Diffuse-Lighting-for-GGX">gdcvault.com/play/1024478/PBR-Diffuse-Lighting-for-GGX</a> <br>      PBR. <br><br> [13] <a href="http://www.codinglabs.net/article_physically_based_rendering.aspx">www.codinglabs.net/article_physically_based_rendering.aspx</a> <br> [14] <a href="http://www.codinglabs.net/article_physically_based_rendering_cook_torrance.aspx">www.codinglabs.net/article_physically_based_rendering_cook_torrance.aspx</a> <br>        (  -   ) <br><br> [15] <a href="http://www.rorydriscoll.com/2009/01/25/energy-conservation-in-games/">www.rorydriscoll.com/2009/01/25/energy-conservation-in-games</a> <br>    <br><br> [16] <a href="https://www.gamedev.net/topic/625981-lambert-and-the-division-by-pi/">www.gamedev.net/topic/625981-lambert-and-the-division-by-pi</a> <br> <a href="http://www.wolframalpha.com/input/%3Fi%3Dintegrate%2Bcos%2Bx%2B">www.wolframalpha.com/input/?i=integrate+cos+x+</a> *+sin+x+dx+dy+from+x+%3D+0+to+pi+%2F+2+y+%3D+0+to+pi+*+2 <br>     <br><br> [17]https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf <br><br> [18] <a href="http://www.pauldebevec.com/Probes/">www.pauldebevec.com/Probes</a> <br>  HDR 360 .        . <br><br> [19] <a href="https://seblagarde.wordpress.com/2012/06/10/amd-cubemapgen-for-physically-based-rendering/">seblagarde.wordpress.com/2012/06/10/amd-cubemapgen-for-physically-based-rendering</a> <br> <a href="https://code.google.com/archive/p/cubemapgen/downloads">code.google.com/archive/p/cubemapgen/downloads</a> <br> .    radiance  irradiance  . <br><br> [20] <a href="https://eheitzresearch.wordpress.com/415-2/">eheitzresearch.wordpress.com/415-2</a> <br>    .  . </div></div></div><p>Source: <a href="https://habr.com/ru/post/326852/">https://habr.com/ru/post/326852/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../326832/index.html">How to approach the analysis of the site in terms of a hacker and identify vulnerabilities?</a></li>
<li><a href="../326834/index.html">Amateur CNC?</a></li>
<li><a href="../326840/index.html">Mustached shooter with a polygonal belly. Part two</a></li>
<li><a href="../326846/index.html">A simple error in coding does not mean a non-fearful error.</a></li>
<li><a href="../326848/index.html">Android application performance</a></li>
<li><a href="../326854/index.html">TypeScript to Slack</a></li>
<li><a href="../326856/index.html">How to make your C ++ code cross-platform?</a></li>
<li><a href="../326860/index.html">Machine Learning Boot Camp IV. Fourth. Secret. Your</a></li>
<li><a href="../326862/index.html">Banks and money through science fiction</a></li>
<li><a href="../326866/index.html">Breaking can not be pardoned, or what awaits hackers on PHDays VII</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>