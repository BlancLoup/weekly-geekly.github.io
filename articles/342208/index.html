<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How to create a blockchain project on Exonum: a quick guide</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Exonum is an open source framework for building blockchain-based applications. It is focused on working with closed blockchains and is applicable in a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How to create a blockchain project on Exonum: a quick guide</h1><div class="post__text post__text-html js-mediator-article">  Exonum is an open source framework for building blockchain-based applications.  It is focused on working with closed blockchains and is applicable in any area: FinTech, GovTech and LegalTech. <br><br>  Today we will conduct a small review of the solution, as well as in the framework of the educational format, let's look at how to build a simple blockchain-based project on Exonum.  You <a href="https://github.com/exonum/cryptocurrency-advanced">'ll find</a> all the code below <a href="https://github.com/exonum/cryptocurrency-advanced">in the repository</a> on GitHub. <br><br> <a href="https://habrahabr.ru/company/bitfury/blog/342208/"><img src="https://habrastorage.org/webt/i6/ou/km/i6oukmq7a8fborubepuivlpriv0.png"></a> <a name="habracut"></a><br>  <font color="#A9A9A9"><i>/ <a href="https://www.youtube.com/watch%3Fv%3DlHnuwhiPkSE">Exonum.</a></i></font>  <font color="#A9A9A9"><i><a href="https://www.youtube.com/watch%3Fv%3DlHnuwhiPkSE">Your next step to blockchain</a> / Exonum</i></font> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  Exonum in a nutshell </h2><br>  The Exonum framework was created specifically for the <a href="https://exonum.com/doc/get-started/what-is-exonum/">development of</a> private blockchains.  This is a system in which only a predefined group of nodes can create new blocks in the blockchain.  It is based on the desire of Bitfury specialists to create a tool that would allow relatively simple to launch a system similar in properties to public blockchains (reliability, immutability of data, auditability, etc.), but it would be more convenient to maintain and maintain. <br><br>  Unlike Ethereum, which is a virtual decentralized machine and runs simultaneously on many nodes around the world, the blockchain built on Exonum works exclusively on the computing power of the validator nodes that are interested in the operation of this system and will ensure its reliable operation. <br><br>  The Exonum private blockchain deployed on pre-determined nodes at least excludes the possibility of its sudden hard fork, clogging of the transaction pool and other problems typical of open blockchains, and the node operators monitor its efficient operation: they update the rules for processing transactions, etc. <br><br>  In addition, the implementation of smart contracts for Ethereum is highly dependent on fluctuations in the rate of cryptocurrency - the ether, which makes it unpredictable for use, for example, in government agencies that cannot pay for the execution of transactions in currencies that are in an unregulated "gray zone".  In Exonum, such dependencies are absent in principle. <br><br>  Finally, the Exonum-blockchain works significantly faster than public blockchains (Bitcoin, Ethereum, etc.), namely, it processes several thousand transactions per second against several dozen processed by the latter.  The choice of strategy is due to the general tendency to create a large number of independent blockchains that would interact with each other through sidechain technologies, linking to public blockchains (anchorage), etc. <br><br>  The main components of Exonum are: the Byzantine consensus, light clients, binding to bitcoin and services. <br><br>  The system uses a <a href="https://exonum.com/doc/architecture/consensus/">special</a> Byzantine consensus algorithm to synchronize data among nodes.  It guarantees data integrity and correct execution of transactions even in the event of a failure of up to 1/3 of the nodes due to a malfunction or intentional malicious activity, while not requiring mining of blocks. <br><br>  Speaking about the advantages of Exonum over existing analogues, we can note the developed data model (storage), which is an index containing dependencies on each other (in fact, tables) - they allow you to implement an effective data structure aimed at solving particular problems.  Clients of such a blockchain can receive cryptographic evidence of the correctness of the downloaded data (Merkle trees), which are checked locally on the client‚Äôs machine and cannot be tampered with even by the Exonum node operator. <br><br>  Light clients are network nodes that store only a small portion of the blockchain of interest.  They allow you to interact with the blockchain using mobile applications or web browsers.  Clients ‚Äúcommunicate‚Äù with one or more services on a full-featured node <a href="https://exonum.com/doc/get-started/what-is-exonum/">through an API</a> .  The work of such thin clients is specific for each individual service and is implemented as difficult as the specific service requires. <br><br>  The essence of the work of Exonum thin clients and the construction of evidence is that the end-user who has linked to the Bitcoin blockchain may not trust the private blockchain operator.  But he can be sure that the data that he displays is obtained in accordance with the rules laid down in this particular private blockchain. <br><br>  The security of light clients in Exonum, comparable to that provided by the permissionless-blockchain, is provided by the bitcoin binding already mentioned above, the so-called anchorage.  The service periodically sends block hashes to the public bitcoin blockchain in the form of transaction testimonials.  In this case, even if the Exonum blockchain stops working, the data can still be verified.  Moreover, to attack such a network, attackers have to overcome the defense mechanisms of both blockchains, which requires enormous computing power. <br><br>  Finally, services are the <a href="https://exonum.com/doc/architecture/services/">foundation of the</a> Exonum framework.  They resemble smart contracts on other platforms and contain the business logic of blockchain applications.  But, in contrast to smart contracts, services in Exonum are not ‚Äúlocked‚Äù in the virtual machine and not containerized. <br><br>  This makes them more efficient and flexible.  However, this approach requires more caution when programming (service isolation is marked on <a href="https://exonum.com/doc/roadmap/">the</a> Exonum roadmap).  Services define <a href="https://exonum.com/doc/architecture/transactions/">transaction</a> processing rules as well as open access to these <a href="https://exonum.com/doc/architecture/clients/">external clients</a> . <br><br>  After reviewing the main components, we can proceed to the analysis of the example. <br><br><h2>  Creating services in Exonum </h2><br>  On November 2, the release of Exonum 0.3 was released, and further guidance was written taking into account changes and improvements to the system (you can read about them in the <a href="">repository</a> on GitHub).  We will create a block node with a single node that implements cryptocurrency.  The network will accept two types of transactions: ‚Äúcreate a wallet‚Äù and ‚Äútransfer funds from one wallet to another‚Äù. <br><br>  Exonum is written in Rust, so you need to install a compiler.  For this you can use our <a href="https://exonum.com/doc/get-started/install/">guide</a> . <br><br><h5>  Node creation </h5><br>  First, create a new <i>crate</i> : <br><br><pre><code class="rust hljs">cargo new --bin cryptocurrency</code> </pre> <br>  And add the necessary dependencies to the created <i>cargo.toml</i> : <br><br><pre> <code class="rust hljs">[package] name = <span class="hljs-string"><span class="hljs-string">"cryptocurrency"</span></span> version = <span class="hljs-string"><span class="hljs-string">"0.3.0"</span></span> authors = [<span class="hljs-string"><span class="hljs-string">"Your Name &lt;your@email.com&gt;"</span></span>] [dependencies] iron = <span class="hljs-string"><span class="hljs-string">"0.5.1"</span></span> bodyparser = <span class="hljs-string"><span class="hljs-string">"0.7.0"</span></span> router = <span class="hljs-string"><span class="hljs-string">"0.5.1"</span></span> serde = <span class="hljs-string"><span class="hljs-string">"1.0"</span></span> serde_json = <span class="hljs-string"><span class="hljs-string">"1.0"</span></span> serde_derive = <span class="hljs-string"><span class="hljs-string">"1.0"</span></span> exonum = <span class="hljs-string"><span class="hljs-string">"0.3.0"</span></span></code> </pre><br>  We import crate with the necessary types.  To do this, <i>edit the src / main.rs file</i> : <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">crate</span></span> serde; <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">crate</span></span> serde_json; <span class="hljs-meta"><span class="hljs-meta">#[macro_use]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">crate</span></span> serde_derive; <span class="hljs-meta"><span class="hljs-meta">#[macro_use]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">crate</span></span> exonum; <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">crate</span></span> router; <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">crate</span></span> bodyparser; <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">crate</span></span> iron; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> exonum::blockchain::{Blockchain, Service, GenesisConfig, ValidatorKeys, Transaction, ApiContext}; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> exonum::node::{Node, NodeConfig, NodeApiConfig, TransactionSend, ApiSender }; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> exonum::messages::{RawTransaction, FromRaw, Message}; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> exonum::storage::{Fork, MemoryDB, MapIndex}; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> exonum::crypto::{PublicKey, Hash, HexValue}; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> exonum::encoding::{<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, Field}; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> exonum::api::{Api, ApiError}; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> iron::prelude::*; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> iron::Handler; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> router::Router;</code> </pre><br>  Define constants: <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// Service identifier const SERVICE_ID: u16 = 1; // Identifier for wallet creation transaction type const TX_CREATE_WALLET_ID: u16 = 1; // Identifier for coins transfer transaction type const TX_TRANSFER_ID: u16 = 2; // Starting balance of a newly created wallet const INIT_BALANCE: u64 = 100;</span></span></code> </pre><br>  And the <i>main</i> function: <br><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { exonum::helpers::init_logger().unwrap(); }</code> </pre><br>  All this allows you to configure the logger, which will display information about the activity of Exonum nodes in the console. <br><br>  To form the blockchain itself, you need to create an instance of the database (in our case, MemoryDB, however, you can use RocksDB) and declare a list of <a href="https://exonum.com/doc/architecture/services/">services</a> .  We place this code after logger initialization: <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> db = MemoryDB::new(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> services: <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;Service&gt;&gt; = <span class="hljs-built_in"><span class="hljs-built_in">vec!</span></span>[ ]; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> blockchain = Blockchain::new(<span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>::new(db), services);</code> </pre><br>  In fact, the blockchain is ready, but it will not work to interact with it - we don‚Äôt have a node and an API to access it.  The node will need to be <a href="https://exonum.com/doc/architecture/configuration/">configured</a> .  In the configuration, the list of public keys of <a href="https://exonum.com/doc/glossary/">validators is</a> specified (in our case it will be one).  In essence, each node requires two pairs of public and private keys: one for interacting with other nodes in the process of reaching consensus, and the second for services.  For our example, we create temporary public keys with the <i>exonum :: crypto :: gen_keypair () command</i> and write them into the configuration file. <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> validator_keys = ValidatorKeys { consensus_key: consensus_public_key, service_key: service_public_key, }; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> genesis = GenesisConfig::new(<span class="hljs-built_in"><span class="hljs-built_in">vec!</span></span>[validator_keys].into_iter());</code> </pre><br>  Next, we configure the REST API for working with external web requests ‚Äî to do this, open port 8000. Also, open port 2000 so that the full Exonum network nodes can communicate with each other. <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> api_address = <span class="hljs-string"><span class="hljs-string">"0.0.0.0:8000"</span></span>.parse().unwrap(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> api_cfg = NodeApiConfig { public_api_address: <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(api_address), ..<span class="hljs-built_in"><span class="hljs-built_in">Default</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">default</span></span>() }; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> peer_address = <span class="hljs-string"><span class="hljs-string">"0.0.0.0:2000"</span></span>.parse().unwrap(); <span class="hljs-comment"><span class="hljs-comment">// Complete node configuration let node_cfg = NodeConfig { listen_address: peer_address, peers: vec![], service_public_key, service_secret_key, consensus_public_key, consensus_secret_key, genesis, external_address: None, network: Default::default(), whitelist: Default::default(), api: api_cfg, mempool: Default::default(), services_configs: Default::default(), }; let node = Node::new(blockchain, node_cfg); node.run().unwrap();</span></span></code> </pre><br><h5>  We declare data </h5><br>  At this stage, we need to determine what data we want to store in the blockchain.  In our case, this is information about the wallet and balance, the public key for checking requests from the wallet owner and the name of the owner.  The structure will look like this: <br><br><pre> <code class="rust hljs">encoding_struct! { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Wallet</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> SIZE = <span class="hljs-number"><span class="hljs-number">48</span></span>; field pub_key: &amp;PublicKey [<span class="hljs-number"><span class="hljs-number">00</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">32</span></span>] field name: &amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span> [<span class="hljs-number"><span class="hljs-number">32</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">40</span></span>] field balance: <span class="hljs-built_in"><span class="hljs-built_in">u64</span></span> [<span class="hljs-number"><span class="hljs-number">40</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">48</span></span>] } }</code> </pre><br>  Macro <i>encoding_struct!</i>  helps to declare the structure being ordered and to define the boundaries of the value fields.  We need to change the balance of the wallet, because we add methods to the <i>Wallet</i> : <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Wallet { <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">increase</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, amount: <span class="hljs-built_in"><span class="hljs-built_in">u64</span></span>) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">Self</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> balance = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.balance() + amount; Self::new(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.pub_key(), <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.name(), balance) } <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">decrease</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, amount: <span class="hljs-built_in"><span class="hljs-built_in">u64</span></span>) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">Self</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> balance = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.balance() - amount; Self::new(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.pub_key(), <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.name(), balance) } }</code> </pre><br>  You also need to create a key-value storage in MemoryDB.  To do this, we use fork to be able, as a last resort, to roll back all changes. <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CurrencySchema</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt; { view: &amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> Fork, }</code> </pre><br>  However, fork gives access to any information in the database.  To isolate the wallets, add a unique prefix and use the <a href="https://exonum.com/doc/architecture/storage/"><i>MapIndex</i></a> abstraction <a href="https://exonum.com/doc/architecture/storage/"><i>map</i></a> . <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">impl</span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt; CurrencySchema&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wallets</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; MapIndex&lt;&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> Fork, PublicKey, Wallet&gt; { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> prefix = blockchain::gen_prefix(SERVICE_ID, <span class="hljs-number"><span class="hljs-number">0</span></span>, &amp;()); MapIndex::new(<span class="hljs-string"><span class="hljs-string">"cryptocurrency.wallets"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.view) } <span class="hljs-comment"><span class="hljs-comment">// Utility method to quickly get a separate wallet from the storage pub fn wallet(&amp;mut self, pub_key: &amp;PublicKey) -&gt; Option&lt;Wallet&gt; { self.wallets().get(pub_key) } }</span></span></code> </pre><br><h5>  Determine the transaction </h5><br>  As already noted, for the work of our educational example we will need the following types of <a href="https://exonum.com/doc/architecture/transactions/">transactions</a> : create a wallet and add funds to it, as well as transfer them to another wallet. <br><br>  The transaction for creating a wallet must contain its public key and user name. <br><br><pre> <code class="rust hljs">message! { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TxCreateWallet</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> TYPE = SERVICE_ID; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ID = TX_CREATE_WALLET_ID; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> SIZE = <span class="hljs-number"><span class="hljs-number">40</span></span>; field pub_key: &amp;PublicKey [<span class="hljs-number"><span class="hljs-number">00</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">32</span></span>] field name: &amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span> [<span class="hljs-number"><span class="hljs-number">32</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">40</span></span>] } }</code> </pre><br>  Before creating a wallet, we will check its uniqueness.  We also credit 100 coins to it. <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Transaction <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> TxCreateWallet { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">verify</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">bool</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.verify_signature(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.pub_key()) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">execute</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, view: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> Fork) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> schema = CurrencySchema { view }; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> schema.wallet(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.pub_key()).is_none() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> wallet = Wallet::new(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.pub_key(), <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.name(), INIT_BALANCE); <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"Create the wallet: {:?}"</span></span>, wallet); schema.wallets().put(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.pub_key(), wallet) } } }</code> </pre><br>  The money transfer transaction looks like this: <br><br><pre> <code class="rust hljs">message! { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TxTransfer</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> TYPE = SERVICE_ID; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ID = TX_TRANSFER_ID; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> SIZE = <span class="hljs-number"><span class="hljs-number">80</span></span>; field from: &amp;PublicKey [<span class="hljs-number"><span class="hljs-number">00</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">32</span></span>] field to: &amp;PublicKey [<span class="hljs-number"><span class="hljs-number">32</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">64</span></span>] field amount: <span class="hljs-built_in"><span class="hljs-built_in">u64</span></span> [<span class="hljs-number"><span class="hljs-number">64</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">72</span></span>] field seed: <span class="hljs-built_in"><span class="hljs-built_in">u64</span></span> [<span class="hljs-number"><span class="hljs-number">72</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">80</span></span>] } }</code> </pre><br>  It contains two public keys (for both wallets) and the number of coins that are transferred.  The <i>seed</i> field has been added so that the transaction <a href="https://exonum.com/doc/architecture/transactions/">cannot be</a> repeated.  You also need to check that the sender does not send the funds to himself: <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Transaction <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> TxTransfer { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">verify</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">bool</span></span> { (*<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.from() != *<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.to()) &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.verify_signature(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.from()) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">execute</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, view: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> Fork) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> schema = CurrencySchema { view }; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> sender = schema.wallet(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.from()); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> receiver = schema.wallet(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.to()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> (<span class="hljs-literal"><span class="hljs-literal">Some</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> sender), <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> receiver)) = (sender, receiver) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> amount = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.amount(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> sender.balance() &gt;= amount { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> sender.decrease(amount); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> receiver.increase(amount); <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"Transfer between wallets: {:?} =&gt; {:?}"</span></span>, sender, receiver); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> wallets = schema.wallets(); wallets.put(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.from(), sender); wallets.put(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.to(), receiver); } } } }</code> </pre><br>  In order for the transactions to be correctly displayed in the blockchain block browser, we also need to override the <i>`info ()`</i> method.  The implementation will be the same for both types of transactions and will look like this: <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Transaction <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> TxCreateWallet { <span class="hljs-comment"><span class="hljs-comment">// `verify()` and `execute()` code... fn info(&amp;self) -&gt; serde_json::Value { serde_json::to_value(&amp;self) .expect("Cannot serialize transaction to JSON") } }</span></span></code> </pre><br><h5>  Implement a transaction API </h5><br>  To do this, create a structure with a channel and an instance of the blockchain, which will be necessary to implement read requests: <br><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[derive(Clone)]</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CryptocurrencyApi</span></span></span></span> { channel: ApiSender, blockchain: Blockchain, }</code> </pre><br>  To simplify the processing of processes, add a <i>TransactionRequest enum</i> , which combines both types of transactions: ‚Äúcreate a wallet‚Äù and ‚Äútransfer funds‚Äù. <br><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[serde(untagged)]</span></span> <span class="hljs-meta"><span class="hljs-meta">#[derive(Clone, Serialize, Deserialize)]</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TransactionRequest</span></span></span></span> { CreateWallet(TxCreateWallet), Transfer(TxTransfer), } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Into</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;Transaction&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> TransactionRequest { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">into</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;Transaction&gt; { <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span> { TransactionRequest::CreateWallet(trans) =&gt; <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>::new(trans), TransactionRequest::Transfer(trans) =&gt; <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>::new(trans), } } } <span class="hljs-meta"><span class="hljs-meta">#[derive(Serialize, Deserialize)]</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TransactionResponse</span></span></span></span> { tx_hash: Hash, }</code> </pre><br>  It remains to "make friends" with our handler with the HTTP handler of the web server.  To do this, we implement the <i>wire</i> method.  In the example below, we add a handler that converts JSON input to Transaction. <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Api <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> CryptocurrencyApi { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wire</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, router: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> Router) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> self_ = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.clone(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> tx_handler = <span class="hljs-keyword"><span class="hljs-keyword">move</span></span> |req: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> Request| -&gt; IronResult&lt;Response&gt; { <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> req.get::&lt;bodyparser::Struct&lt;TransactionRequest&gt;&gt;() { <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>(<span class="hljs-literal"><span class="hljs-literal">Some</span></span>(tx)) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> tx: <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;Transaction&gt; = tx.into(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> tx_hash = tx.hash(); self_.channel.send(tx).map_err(ApiError::from)?; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> json = TransactionResponse { tx_hash }; self_.ok_response(&amp;serde_json::to_value(&amp;json).unwrap()) } <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>(<span class="hljs-literal"><span class="hljs-literal">None</span></span>) =&gt; <span class="hljs-literal"><span class="hljs-literal">Err</span></span>(ApiError::IncorrectRequest( <span class="hljs-string"><span class="hljs-string">"Empty request body"</span></span>.into()))?, <span class="hljs-literal"><span class="hljs-literal">Err</span></span>(e) =&gt; <span class="hljs-literal"><span class="hljs-literal">Err</span></span>(ApiError::IncorrectRequest(<span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>::new(e)))?, } }; <span class="hljs-comment"><span class="hljs-comment">// (Read request processing skipped) // Bind the transaction handler to a specific route. router.post("/v1/wallets/transaction", transaction, "transaction"); // (Read request binding skipped) } }</span></span></code> </pre><br><h5>  Implement the read requests API </h5><br>  In order to be able to verify that transactions are actually executed, we implement two types of read requests: return information about all the system wallets and return information only about a specific purse that corresponds to the public key. <br><br>  To do this, we define a couple of methods in <i>CryptocurrencyApi</i> that will access the blockchain field to read information from the blockchain's repository. <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> CryptocurrencyApi { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_wallet</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, pub_key: &amp;PublicKey) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;Wallet&gt; { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> view = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.blockchain.fork(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> schema = CurrencySchema { view: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> view }; schema.wallet(pub_key) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_wallets</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;Wallet&gt;&gt; { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> view = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.blockchain.fork(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> schema = CurrencySchema { view: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> view }; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> idx = schema.wallets(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> wallets: <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;Wallet&gt; = idx.values().collect(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> wallets.is_empty() { <span class="hljs-literal"><span class="hljs-literal">None</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(wallets) } } }</code> </pre><br>  It is worth paying attention to the fact that in this case we use the fork method, despite the fact that it gives access to write and read data (so as not to overload the example).  In reality, it is advisable to use the read-only access format (referring to snapshots). <br><br>  Further, as well as for transactions, we add processing of requests using <i>get_wallets ()</i> and <i>get_wallet ()</i> <i>methods</i> in <i>CryptocurrencyApi :: wire ()</i> . <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Api <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> CryptocurrencyApi { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wire</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, router: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> Router) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> self_ = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.clone(); <span class="hljs-comment"><span class="hljs-comment">// (Transaction processing skipped) // Gets status of all wallets in the database. let self_ = self.clone(); let wallets_info = move |_: &amp;mut Request| -&gt; IronResult&lt;Response&gt; { if let Some(wallets) = self_.get_wallets() { self_.ok_response(&amp;serde_json::to_value(wallets).unwrap()) } else { self_.not_found_response( &amp;serde_json::to_value("Wallets database is empty") .unwrap(), ) } }; // Gets status of the wallet corresponding to the public key. let self_ = self.clone(); let wallet_info = move |req: &amp;mut Request| -&gt; IronResult&lt;Response&gt; { // Get the hex public key as the last URL component; // return an error if the public key cannot be parsed. let path = req.url.path(); let wallet_key = path.last().unwrap(); let public_key = PublicKey::from_hex(wallet_key) .map_err(ApiError::FromHex)?; if let Some(wallet) = self_.get_wallet(&amp;public_key) { self_.ok_response(&amp;serde_json::to_value(wallet).unwrap()) } else { self_.not_found_response( &amp;serde_json::to_value("Wallet not found").unwrap(), ) } }; // (Transaction binding skipped) // Bind read request endpoints. router.get("/v1/wallets", wallets_info, "wallets_info"); router.get("/v1/wallet/:pub_key", wallet_info, "wallet_info"); }</span></span></code> </pre><br><h5>  We define the service </h5><br>  To turn the <i>CurrencyService</i> structure into a blockchain service, we need to assign the Service property to it.  It has two methods: <i>service_name</i> , which returns the name of our service, and <i>service_id</i> , which returns its unique ID. <br>  The <i>tx_from_raw</i> method will be used to deserialize transactions, and the <i>public_api_handler</i> method will be used to create a <i>REST Handler</i> for processing web requests to the site.  It will apply the logic already defined in <i>CryptocurrencyApi</i> . <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Service <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> CurrencyService { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">service_name</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; &amp;<span class="hljs-symbol"><span class="hljs-symbol">'static</span></span> <span class="hljs-built_in"><span class="hljs-built_in">str</span></span> { <span class="hljs-string"><span class="hljs-string">"cryptocurrency"</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">service_id</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">u16</span></span> { SERVICE_ID } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tx_from_raw</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, raw: RawTransaction) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Result</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;Transaction&gt;, encoding::Error&gt; { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> trans: <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;Transaction&gt; = <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> raw.message_type() { TX_TRANSFER_ID =&gt; <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>::new(TxTransfer::from_raw(raw)?), TX_CREATE_WALLET_ID =&gt; <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>::new(TxCreateWallet::from_raw(raw)?), _ =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">Err</span></span>(encoding::Error::IncorrectMessageType { message_type: raw.message_type() }); }, }; <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>(trans) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">public_api_handler</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, ctx: &amp;ApiContext) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;Handler&gt;&gt; { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> router = Router::new(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> api = CryptocurrencyApi { channel: ctx.node_channel().clone(), blockchain: ctx.blockchain().clone(), }; api.wire(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> router); <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>::new(router)) } }</code> </pre><br>  We implemented all parts of our mini-blockchain.  Now it remains to add <i>CryptocyrrencyService</i> to the list of services of the blockchain and run the demo: <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> services: <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;Service&gt;&gt; = <span class="hljs-built_in"><span class="hljs-built_in">vec!</span></span>[ <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>::new(CurrencyService), ]; cargo run</code> </pre><br><h5>  Service Testing </h5><br>  Exonum allows you to test the work of services.  For this package is used Sandbox - it simulates the network.  We can send a request to the node and get an answer, and then observe the changes taking place in the blockchain.  The sandbox instance is created by the <i>sandbox_with_services</i> method, which allows you to specify services for testing.  For example, like this: <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> s = sandbox_with_services(<span class="hljs-built_in"><span class="hljs-built_in">vec!</span></span>[<span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>::new(CurrencyService::new()), <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>::new(ConfigUpdateService::new())]);</code> </pre><br>  In general, Sandbox can simulate the process of receiving a message by a node, check which node sent it, and what was in it.  Also, the ‚Äúsandbox‚Äù can work over time, for example, to simulate the expiration of a time period. <br><br><h5>  Sending transactions </h5><br>  Now let's try sending multiple transactions in our blockchain demo.  First, create a wallet.  This is how the <i>create-wallet-1.json</i> file will look like: <br><br><pre> <code class="rust hljs">{ <span class="hljs-string"><span class="hljs-string">"body"</span></span>: { <span class="hljs-string"><span class="hljs-string">"pub_key"</span></span>: <span class="hljs-string"><span class="hljs-string">"03e657ae71e51be60a45b4bd20bcf79ff52f0c037ae6da0540a0e0066132b472"</span></span>, <span class="hljs-string"><span class="hljs-string">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Johnny Doe"</span></span> }, <span class="hljs-string"><span class="hljs-string">"network_id"</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"protocol_version"</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"service_id"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">"message_id"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">"signature"</span></span>: <span class="hljs-string"><span class="hljs-string">"ad5efdb52e48309df9aa582e67372bb3ae67828c5eaa1a7a5e387597174055d315eaa7879912d0509acf17f06a23b7f13f242017b354f682d85930fa28240402"</span></span> }</code> </pre><br>  Use the <i>curl</i> command to send a transaction over HTTP: <br><br><pre> <code class="rust hljs">curl -H <span class="hljs-string"><span class="hljs-string">"Content-Type: application/json"</span></span> -X POST -d @create-wallet-<span class="hljs-number"><span class="hljs-number">1</span></span>.json \ http:<span class="hljs-comment"><span class="hljs-comment">//127.0.0.1:8000/api/services/cryptocurrency/v1/wallets/transaction</span></span></code> </pre><br>  After that, in the console we will see that the wallet was created: <br><br><pre> <code class="rust hljs">Create the wallet: Wallet { pub_key: PublicKey(<span class="hljs-number"><span class="hljs-number">3E657</span></span>AE), name: <span class="hljs-string"><span class="hljs-string">"Johnny Doe"</span></span>, balance: <span class="hljs-number"><span class="hljs-number">100</span></span> }</code> </pre><br>  The second wallet is formed similarly.  After its creation we can transfer funds.  The <i>transfer-funds.json file</i> looks like this: <br><br><pre> <code class="rust hljs">{ <span class="hljs-string"><span class="hljs-string">"body"</span></span>: { <span class="hljs-string"><span class="hljs-string">"from"</span></span>: <span class="hljs-string"><span class="hljs-string">"03e657ae71e51be60a45b4bd20bcf79ff52f0c037ae6da0540a0e0066132b472"</span></span>, <span class="hljs-string"><span class="hljs-string">"to"</span></span>: <span class="hljs-string"><span class="hljs-string">"d1e877472a4585d515b13f52ae7bfded1ccea511816d7772cb17e1ab20830819"</span></span>, <span class="hljs-string"><span class="hljs-string">"amount"</span></span>: <span class="hljs-string"><span class="hljs-string">"10"</span></span>, <span class="hljs-string"><span class="hljs-string">"seed"</span></span>: <span class="hljs-string"><span class="hljs-string">"12623766328194547469"</span></span> }, <span class="hljs-string"><span class="hljs-string">"network_id"</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"protocol_version"</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"service_id"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">"message_id"</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">"signature"</span></span>: <span class="hljs-string"><span class="hljs-string">"2c5e9eee1b526299770b3677ffd0d727f693ee181540e1914f5a84801dfd410967fce4c22eda621701c2b9c676ed62bc48df9c973462a8514ffb32bec202f103"</span></span> }</code> </pre><br>  This transaction transfers 10 coins from the first wallet to the second.  Send a command to the node using <i>curl</i> : <br><br><pre> <code class="rust hljs">curl -H <span class="hljs-string"><span class="hljs-string">"Content-Type: application/json"</span></span> -X POST -d @transfer-funds.json \ http:<span class="hljs-comment"><span class="hljs-comment">//127.0.0.1:8000/api/services/cryptocurrency/v1/wallets/transaction</span></span></code> </pre><br>  The node will show that the amount was successfully transferred: <br><br><pre> <code class="rust hljs">Transfer between wallets: Wallet { pub_key: PublicKey(<span class="hljs-number"><span class="hljs-number">3E657</span></span>AE), name: <span class="hljs-string"><span class="hljs-string">"Johnny Doe"</span></span>, balance: <span class="hljs-number"><span class="hljs-number">90</span></span> } =&gt; Wallet { pub_key: PublicKey(D1E87747), name: <span class="hljs-string"><span class="hljs-string">"Janie Roe"</span></span>, balance: <span class="hljs-number"><span class="hljs-number">110</span></span> }</code> </pre><br><br>  Now, let's check that the endpoint for processing read requests actually works.  We can request the status of both wallets in the system as follows: <br><br><pre> <code class="rust hljs">curl http:<span class="hljs-comment"><span class="hljs-comment">//127.0.0.1:8000/api/services/cryptocurrency/v1/wallets</span></span></code> </pre><br>  This request will display information about the wallets in the following form: <br><br><pre> <code class="rust hljs">[ { <span class="hljs-string"><span class="hljs-string">"balance"</span></span>: <span class="hljs-string"><span class="hljs-string">"90"</span></span>, <span class="hljs-string"><span class="hljs-string">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Johnny Doe"</span></span>, <span class="hljs-string"><span class="hljs-string">"pub_key"</span></span>: <span class="hljs-string"><span class="hljs-string">"03e657ae71e51be60a45b4bd20bcf79ff52f0c037ae6da0540a0e0066132b472"</span></span> }, { <span class="hljs-string"><span class="hljs-string">"balance"</span></span>: <span class="hljs-string"><span class="hljs-string">"110"</span></span>, <span class="hljs-string"><span class="hljs-string">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Janie Roe"</span></span>, <span class="hljs-string"><span class="hljs-string">"pub_key"</span></span>: <span class="hljs-string"><span class="hljs-string">"d1e877472a4585d515b13f52ae7bfded1ccea511816d7772cb17e1ab20830819"</span></span> } ]</code> </pre><br>  The second endpoint also works.  We can verify this by sending the following request: <br><br><pre> <code class="rust hljs">curl <span class="hljs-string"><span class="hljs-string">"http://127.0.0.1:8000/api/services/cryptocurrency/v1/wallet/\ 03e657ae71e51be60a45b4bd20bcf79ff52f0c037ae6da0540a0e0066132b472"</span></span></code> </pre><br>  We get the answer: <br><br><pre> <code class="rust hljs">{ <span class="hljs-string"><span class="hljs-string">"balance"</span></span>: <span class="hljs-string"><span class="hljs-string">"90"</span></span>, <span class="hljs-string"><span class="hljs-string">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Johnny Doe"</span></span>, <span class="hljs-string"><span class="hljs-string">"pub_key"</span></span>: <span class="hljs-string"><span class="hljs-string">"03e657ae71e51be60a45b4bd20bcf79ff52f0c037ae6da0540a0e0066132b472"</span></span> }</code> </pre><br>  Thus, within the framework of our educational material, we figured out how a simple blockchain works with one validator.  In the following posts we will talk more about linking to blockchains, managing nodes and consensus in Exonum. </div><p>Source: <a href="https://habr.com/ru/post/342208/">https://habr.com/ru/post/342208/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../342196/index.html">How we set up the CI / CD process for our SOA projects</a></li>
<li><a href="../342198/index.html">The digest of interesting materials for the mobile developer # 229 (November 6 - November 12)</a></li>
<li><a href="../342200/index.html">Ethereum renewable smart contracts</a></li>
<li><a href="../342202/index.html">Compressing the incompressible - how to reduce the distribution of a mobile application</a></li>
<li><a href="../342206/index.html">Skyrim, rendered in text</a></li>
<li><a href="../342210/index.html">Product Design Digest October 2017</a></li>
<li><a href="../342212/index.html">Director of common sense: how to stop everything in control and start working in a team</a></li>
<li><a href="../342214/index.html">JSON error handling with Spring Boot</a></li>
<li><a href="../342216/index.html">How to break a bicycle over crutches when testing your distribution</a></li>
<li><a href="../342218/index.html">Learning Go by porting a small Python web backend</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>