<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Procedural vegetation on OpenGL and GLSL</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In this post, I would like to talk about using hardware tessellation and a geometry shader to generate a large amount of geometry based on minimal inp...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Procedural vegetation on OpenGL and GLSL</h1><div class="post__text post__text-html js-mediator-article">  In this post, I would like to talk about using hardware tessellation and a geometry shader to generate a large amount of geometry based on minimal input.  I hope the post will be useful to those who have an initial understanding of shader programming, but have not yet realized the power of the programmable graphics pipeline.  This is not a guide to shaders for beginners, so many of the points of their work swept under the carpet or provided with a link to the relevant documentation. <br><br><img src="https://habrastorage.org/files/734/f41/6a4/734f416a4a964c3b861682350ee76a48.jpg"><br><br>  The story will be conducted on the example of a small demo that generates the scene as in the picture above.  We will go through an exciting journey from preparing data on the CPU to recording the color values ‚Äã‚Äãat the output of the fragment shader. <br><a name="habracut"></a><br><h3>  Goals and means </h3><br>  When writing a demo, I set myself the following goals: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  Minimize the amount of data stored in video memory.  Consequently: </li><li>  Maximum utilization of the graphics processor using all available pipeline stages. </li><li>  Make some scene settings customizable. </li><li>  Focus on geometry and shader writing, spending a minimum of effort on other components.  Therefore, the most familiar to me toolkit was used: C ++ 11 (gcc), Qt5 + qmake, GLSL. </li><li>  If possible, simplify the assembly and launch of the resulting demo on various platforms. </li></ul><br>  Based on this list, we had to sacrifice the elaboration of some points: <br><br><ul><li>  The main loop is made primitive.  Therefore, the speed of animation and camera movement depends on the frame rate, and hence on the position of the camera in space. </li><li>  Its coordinates, orientation, projection and functions for changing all this are mixed into a single class of the camera.  In this form, its writing did not take much time and allowed to make a sufficiently optimal probros camera parameters in the shader. </li><li>  The shader class is made in the form of a fairly thin wrapper over the corresponding Qt5 class.  Common to different stages of the code pieces are glued together and given to the compiler optimizer, which will throw out unused code and global variables. </li><li>  The program uses a single shader, so the data transfer to it is made without the "modern" <a href="https://www.opengl.org/wiki/Uniform_Buffer_Object">UBO</a> .  In this case, they would not add performance, complicating the code. </li><li>  The frame count per second is based on <a href="https://www.opengl.org/wiki/Query_Object">OpenGL requests</a> .  Therefore, it shows not "real" FPS, but a slightly overvalued idealized indicator, which does not take into account the overhead, introduced by Qt. </li><li>  Cool lighting was not the goal of writing this demo, so a simple implementation of Phong lighting with a single source, sharpened in the shader, is used. </li><li>  The implementation of the noise in the shaders was taken from a third-party author. </li></ul><br>  In order to provide the reader with an opportunity to review the entire code of the demo during the narration, I will immediately provide a <a href="https://github.com/sergeyext/procgrass">link</a> to the repository. <br><br><h3>  Overview of Geometry Generation </h3><br>  We will draw a set of <a href="https://www.opengl.org/wiki/Primitive">patches</a> , each of which contains a single vertex.  Each vertex, in turn, contains a single four-component attribute.  Using this minimum portion of data as a seed, we will ‚Äúgrow‚Äù on each such patch (that is, one point) a whole bush of stirring stems.  In addition, all bushes can be exposed to wind with user-defined parameters.  Most of the bush generation work is performed in a <a href="https://www.opengl.org/wiki/Tessellation_Evaluation_Shader">Tesselation evaluation shader</a> and in a <a href="https://www.opengl.org/wiki/Geometry_Shader">geometric shader</a> .  So, in the tessellation shader a skeleton of a bush is generated with all the deformations introduced by stirring and wind, and in a geometric shader a polygonal ‚Äúflesh‚Äù is stretched onto this skeleton, the thickness of which depends on the height of the bone on the skeleton.  The fragment shader, as usual, calculates the lighting and applies the procedurally generated <a href="https://en.wikipedia.org/wiki/Worley_noise">texture</a> based on the Voronoi diagram. <br><br>  So, let's begin! <br><br><h3>  CPU </h3><br>  The data path to coloring monitor pixels begins with their preparation on the CPU.  As mentioned above, each ‚Äúmodel‚Äù of the scene initially consists of one vertex.  Let's make this vertex four-dimensional, where the first three components are the position of the vertex in space, and the fourth component is the number of stems in the bush.  Thus, the bushes will be able to differ from each other in the number of stems.  We start the generation of coordinates from the nodes of a square lattice of finite size, and we perturb each coordinate by a random value from a given interval: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> numNodes = <span class="hljs-number"><span class="hljs-number">14</span></span>; <span class="hljs-comment"><span class="hljs-comment">//      . const GLfloat gridStep = 3.0f; //  . //     : const GLfloat xDispAmp = 5.0f; const GLfloat zDispAmp = 5.0f; const GLfloat yDispAmp = 0.3f; //    . numClusters = numNodes * numNodes; //  . GLfloat *vertices = new GLfloat[numClusters * 4]; //    . std::random_device rd; std::mt19937 mt(rd()); std::uniform_real_distribution&lt;GLfloat&gt; xDisp(-xDispAmp, xDispAmp); std::uniform_real_distribution&lt;GLfloat&gt; yDisp(-yDispAmp, yDispAmp); std::uniform_real_distribution&lt;GLfloat&gt; zDisp(-zDispAmp, zDispAmp); std::uniform_int_distribution&lt;GLint&gt; numStems(12, 64); //  . for(int i = 0; i &lt; numNodes; ++i) { for(int j = 0; j &lt; numNodes; ++j) { const int idx = (i * numNodes + j) * 4; vertices[idx] = (i - numNodes / 2) * gridStep + xDisp(mt); vertices[idx + 1] = yDisp(mt); vertices[idx + 2] = (j - numNodes / 2) * gridStep + zDisp(mt); vertices[idx + 3] = numStems(mt); } }</span></span></code> </pre> <br>  The generated data will be sent to the video memory: <br><br><pre> <code class="cpp hljs">GLuint vao; <span class="hljs-comment"><span class="hljs-comment">// https://www.opengl.org/wiki/Vertex_Specification#Vertex_Array_Object GLuint posVbo; // https://www.opengl.org/wiki/Vertex_Specification#Vertex_Buffer_Object glGenVertexArrays(1, &amp;vao); glBindVertexArray(vao); glGenBuffers(1, &amp;posVbo); glEnableVertexAttribArray(ATTRIBINDEX_VERTEX); glBindBuffer(GL_ARRAY_BUFFER, posVbo); glVertexAttribPointer(ATTRIBINDEX_VERTEX, 4, GL_FLOAT, GL_FALSE, 0, 0); glBufferData(GL_ARRAY_BUFFER, sizeof(GLfloat) * numClusters * 4, vertices, GL_STATIC_DRAW); glFinish(); delete[] vertices;</span></span></code> </pre><br>  Now the method of drawing the entire lawn from the generated grass looks very succinctly: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> ProceduralGrass::draw() { glBindVertexArray(vao); glPatchParameteri(GL_PATCH_VERTICES, <span class="hljs-number"><span class="hljs-number">1</span></span>); glDrawArrays(GL_PATCHES, <span class="hljs-number"><span class="hljs-number">0</span></span>, numClusters); glBindVertexArray(<span class="hljs-number"><span class="hljs-number">0</span></span>); }</code> </pre><br>  In addition to geometry, in the shaders we need uniformly distributed random numbers.  The most optimal way to get numbers on the CPU in the interval [0;  1], and on the GPU in each particular location to bring them to the desired interval.  In the video memory, we deliver them in the form of a one-dimensional texture, in which the selection of the nearest value is set as filtering.  I recall that in the two-dimensional case, such filtering leads to a similar result: <br><br><img src="https://habrastorage.org/files/1df/396/8e9/1df3968e966543da884fb593d7c206b5.png" alt="foobar"><br>  <i><a href="http://romain.vergne.free.fr/teaching/IS/SI05-textures.html">A source</a></i> <br><br>  Code generation and texture settings: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> GLuint randTexSize = <span class="hljs-number"><span class="hljs-number">256</span></span>; GLfloat randTexData[randTexSize]; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::random_device rd; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-function">mt19937 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">gen</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(rd())</span></span></span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::uniform_real_distribution&lt;<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>&gt; dis(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::generate(randTexData, randTexData + randTexSize, [&amp;](){<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dis(gen);}); <span class="hljs-comment"><span class="hljs-comment">// Create and tune random texture. glGenTextures(1, &amp;randTexture); glActiveTexture(GL_TEXTURE0); glBindTexture(GL_TEXTURE_1D, randTexture); glTexParameteri(GL_TEXTURE_1D, GL_TEXTURE_MIN_FILTER, GL_NEAREST); glTexParameteri(GL_TEXTURE_1D, GL_TEXTURE_MAG_FILTER, GL_NEAREST); glTexParameteri(GL_TEXTURE_1D, GL_TEXTURE_WRAP_S, GL_REPEAT); glTexParameteri(GL_TEXTURE_1D, GL_TEXTURE_BASE_LEVEL, 0); glTexParameteri(GL_TEXTURE_1D, GL_TEXTURE_MAX_LEVEL, 0); glTexImage1D(GL_TEXTURE_1D, 0, GL_R16F, randTexSize, 0, GL_RED, GL_FLOAT, randTexData); glUniform1i(glGetUniformLocation(grassShader.programId(), "urandom01"), 0);</span></span></code> </pre><br><h3>  Vertex shader </h3><br>  As a rule, when using tessellation, the vertex shader turns out to be very lazy, since the pipeline starts with it, but there is no geometry as such.  In our case, the vertex shader is trivial.  In it, we simply send a point from the entrance immediately to the exit: <br><br><pre> <code class="hljs cs">layout(location=<span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> vec4 position; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span></span><span class="hljs-function">)</span></span> { gl_Position = position; }</code> </pre><br><h3>  Tessellation </h3><br>  Hardware tessellation is a powerful technique for increasing the detail of polygonal models using GPUs.  Do not confuse with triangle-splitting polygon algorithms performed on the central processor.  Hardware tessellation consists of three stages of the graphics pipeline, two of which can be programmed (highlighted in yellow): <br><br><img src="https://habrastorage.org/files/55c/05a/f92/55c05af92a3f47de800e0371048b3fd2.jpg"><br><br>  Details on shaders and their inputs / outputs are described below.  Here it is worth saying that a patch consisting of an arbitrary number of vertices, which is fixed for each glDraw * call and limited to at least 32, is sent to the tessellation input. as you wish.  This gives a truly fantastic capabilities compared to the old vertex shaders. <br><br>  The model of programmed tessellation operation differs significantly from other shaders, and can cause confusion when you first get to know it, even if you have experience with vertex and geometric shaders. <br><br><h4>  Tessellation control shader </h4><br>  In general, the tessellation control shader has access to all vertices of the input patch that have passed through the vertex shader separately.  At its input comes the number of vertices in the patch gl_PatchVerticesIn, the sequence number of the patch gl_PrimitiveID and the sequence number of the output vertex gl_InvocationID, about which later.  The patch sequence number gl_PrimitiveID is considered to be part of a single glDraw * call.  The vertex data itself is accessible via an array of gl_in structures, declared as follows: <br><br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">in</span></span> gl_PerVertex { vec4 gl_Position; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> gl_PointSize; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> gl_ClipDistance[]; } gl_in[gl_MaxPatchVertices];</code> </pre><br>  This array is indexed from zero to gl_PatchVerticesIn - 1. The field of greatest interest in this declaration is the gl_Position field, in which the data from the vertex shader output is written.  The number of vertices of the output patch is set in the code of the shader itself by the global declaration: <br><br><pre> <code class="hljs objectivec">layout (vertices = <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">out</span></span>; <span class="hljs-comment"><span class="hljs-comment">//      </span></span></code> </pre><br>  and it does not have to match the number of vertices in the input patch.  The number of shader calls is equal to the number of output vertices.  In each call, the shader has access to all the input nodes of the patch, but it has the right to write only on the gl_InvocationID index of the output array gl_out, which is declared as <br><br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">out</span></span> gl_PerVertex { vec4 gl_Position; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> gl_PointSize; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> gl_ClipDistance[]; } gl_out[];</code> </pre><br>  We now turn to a more interesting fact.  The shader can write only on the gl_InvocationID index, but it can read the <i>output</i> array on any index!  We remember that the work of shaders is very parallelized, and the order of their call is not determined.  This imposes restrictions on data sharing by shaders, but makes SIMD concurrency possible and gives the compiler a blank check to use the most severe optimizations.  To prevent these rules from being violated, barrier synchronization is available in the shader of the tessellation control.  The call to the built-in function barrier () blocks execution until all the shaders of the patch call this function.  Serious restrictions are imposed on the call of this function: it cannot be called from any function except main, it cannot be called in any flow control construct (for, while, switch), and it cannot be called after return. <br><br>  And finally, the most interesting thing at this stage of the pipeline: the output of the vertices is not the main thing.  Polygons will not be collected from coordinates recorded in gl_out.  The main product of the tessellation control shader is writing to the following output arrays: <br><br><pre> <code class="hljs objectivec">patch <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> gl_TessLevelOuter[<span class="hljs-number"><span class="hljs-number">4</span></span>]; patch <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> gl_TessLevelInner[<span class="hljs-number"><span class="hljs-number">2</span></span>];</code> </pre><br>  These arrays control the number of vertices in the so-called <a href="https://www.opengl.org/wiki/Tessellation_Evaluation_Shader">abstract patches</a> , which is why this stage is called tessellation control.  An abstract patch is a set of points of a two-dimensional geometric shape that is generated at the stage of tessellation primitive generation.  Abstract patches are of three types: triangles, squares and isolines.  At the same time, for each type of abstract patch, the shader should fill only the gl_TessLevelOuter and gl_TessLevelInner indices it needs, and the remaining indices of these arrays are ignored.  The generated patch contains not only the vertices of the geometric figure, but also the coordinates of points on the borders and inside the figure.  For example, a square for some values ‚Äã‚Äãof gl_TessLevelOuter and gl_TessLevelInner will be formed from triangles of this type: <br><br><img src="https://habrastorage.org/files/f7f/90c/d8b/f7f90cd8b53244b99b7590ae44b6e9d6.png"><br><br>  The lower left corner of the square always has the coordinate [0;  0], upper right - [1;  1], and all other points will have corresponding coordinates with values ‚Äã‚Äãfrom 0 to 1. <br><br>  Isolines are essentially square too, divided into rectangles, not triangles.  The coordinates of points on isolines will also belong to the interval from 0 to 1. <br><br>  But the coordinates inside the triangle are arranged in a fundamentally different way: in a two-dimensional triangle, three-component <a href="https://ru.wikipedia.org/wiki/%25D0%2591%25D0%25B0%25D1%2580%25D0%25B8%25D1%2586%25D0%25B5%25D0%25BD%25D1%2582%25D1%2580%25D0%25B8%25D1%2587%25D0%25B5%25D1%2581%25D0%25BA%25D0%25B8%25D0%25B5_%25D0%25BA%25D0%25BE%25D0%25BE%25D1%2580%25D0%25B4%25D0%25B8%25D0%25BD%25D0%25B0%25D1%2582%25D1%258B">barycentric coordinates are used</a> .  Moreover, their values ‚Äã‚Äãalso lie in the interval from 0 to 1, and the triangle is equilateral. <br><br>  The specific kind of partitioning (which, in fact, is called tessellation in the original sense) of an abstract patch strongly depends on gl_TessLevelOuter and gl_TessLevelInner.  We will not dwell on it in detail here, nor will we analyze how Inner differs from Outer.  All this is detailed in the <a href="https://www.opengl.org/wiki/Tessellation">relevant section of</a> the OpenGL tutorial. <br><br>  Now back to our plants.  At this stage of the graphics pipeline, we still can not perform any meaningful transformations on the only single point, so the output of this shader will be served with the input vertex unchanged: <br><br><pre> <code class="hljs">gl_out[gl_InvocationID].gl_Position = gl_in[gl_InvocationID].gl_Position;</code> </pre><br>  To generate the geometry, we will use a rectangular grid, that is, an abstract patch of the ‚Äúisoline‚Äù type.  The contour generation is controlled only by two variables: gl_TessLevelOuter [0] is the number of points along the <i>y</i> coordinate, and gl_TessLevelOuter [1] is the number of points along <i>x</i> .  In our program, a cycle of <i>y</i> will run through the stalks of a bush, and for each stem a cycle of <i>x</i> will run along the stem.  Therefore, the number of stems (the fourth coordinate of the input point) we write to the corresponding output: <br><br><pre> <code class="hljs">gl_TessLevelOuter[0] = gl_in[gl_InvocationID].gl_Position.w;</code> </pre><br>  The number of points along the stem determines the number of segments from which the stem is composed, that is, its detail.  In order not to waste resources, let's make the level of detail dependent on the distance between the camera and the bush: <br><br><pre> <code class="hljs ruby">uniform vec3 eyePosition; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>         . int lod() { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     : float dist = distance(gl_in[gl_InvocationID].gl_Position.xyz, eyePosition); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>        : <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(dist &lt; <span class="hljs-number"><span class="hljs-number">10.0</span></span>f) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">48</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(dist &lt; <span class="hljs-number"><span class="hljs-number">20.0</span></span>f) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">24</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(dist &lt; <span class="hljs-number"><span class="hljs-number">80.0</span></span>f) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">12</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(dist &lt; <span class="hljs-number"><span class="hljs-number">800.0</span></span>f) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span>; }</code> </pre><br>  On the CPU side, before each glDraw * call, homogeneous variables are populated: <br><br><pre> <code class="cpp hljs">grassShader.setUniformValue(<span class="hljs-string"><span class="hljs-string">"eyePosition"</span></span>, camera.getPosition()); grassShader.setUniformValue(<span class="hljs-string"><span class="hljs-string">"lookDirection"</span></span>, camera.getLookDirection());</code> </pre><br>  The first one is the coordinates of the camera in space, and the second is the direction of gaze.  Knowing the position of the camera, the direction of the sight and the coordinate of the bush, we can find out if this bush is behind the camera: <br><br><img src="https://habrastorage.org/files/986/dc8/d30/986dc8d302784ea69927e7cae5812828.jpg"><br><br>  If the bush is in front, then the angle between the direction from the camera forward and from the camera to the bush will be sharp, otherwise - blunt.  Accordingly, in the first case the scalar product of the vectors shown in the figure will be greater than zero, and in the second case - less.  We calculate the scalar product and use the step function with a step at zero to get a variable that is zero if the bush is behind and one if it is in front: <br><br><pre> <code class="hljs lisp">float halfspaceCull = step(<span class="hljs-name"><span class="hljs-name">dot</span></span>(<span class="hljs-name"><span class="hljs-name">eyePosition</span></span> - gl_in[gl_InvocationID].gl_Position.xyz, lookDirection), <span class="hljs-number"><span class="hljs-number">0</span></span>)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre><br>  Finally, we can write the number of points for the stems of the future bush: <br><br><pre> <code class="hljs">gl_TessLevelOuter[1] = lod() * halfspaceCull;</code> </pre><br><h4>  Shader tessellation </h4><br>  A note about terminology: in English, this shader is called the <a href="https://www.opengl.org/wiki/Tessellation_Evaluation_Shader">Tesselation evaluation shader</a> .  On the Russian Internet, you can find literal translations like "tessellation evaluation shader" or "tessellation calculation shader".  They look awkward and, in my opinion, do not reflect the essence of this shader.  Therefore, here the tesselation evaluation shader will be called simply a tessellation shader, unlike the previous stage, where the tessellation control shader was. <br><br>  Tessellation is enabled only if a tessellation shader is added to the shader program.  At the same time, the tessellation control shader is not mandatory: its absence is equivalent to submitting the input patch to the output without changes.  The values ‚Äã‚Äãof the gl_TessLevel * arrays can be set by the CPU by calling glPatchParameterfv with the parameter GL_PATCH_DEFAULT_OUTER_LEVEL or GL_PATCH_DEFAULT_INNER_LEVEL.  In this case, all abstract patches in the tessellation shader will be the same.  Adding only tessellation shader to the program is meaningless and leads to a shader layout error.  The kind of abstract patch, unlike its parameters, is defined in the tessellation shader code: <br><br><pre> <code class="hljs mel"><span class="hljs-keyword"><span class="hljs-keyword">layout</span></span>(isolines, equal_spacing) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span>; <span class="hljs-comment"><span class="hljs-comment">//     .</span></span></code> </pre><br>  The tessellation shader is called for each point of the abstract patch.  For example, if we ordered isolines with 64x64 dots, then the shader will be called 4096 times.  All vertices from the output of the tessellation control shader arrive at its input: <br><br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">in</span></span> gl_PerVertex { vec4 gl_Position; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> gl_PointSize; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> gl_ClipDistance[]; } gl_in[gl_MaxPatchVertices];</code> </pre><br>  gl_PatchVerticesIn, gl_PrimitiveID, gl_TessLevelOuter and gl_TessLevelInner are already familiar to us.  The last two variables are of the same type as in the tessellation control shader, but are available only for reading.  Finally, the most interesting input variable is <br><br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">in</span></span> vec3 gl_TessCoord;</code> </pre><br>  It contains the coordinates of the current (for this call) point of the abstract patch.  It is declared as vec3, however gl_TessCoord.z ‚Äã‚Äãonly makes sense for triangles.  Reading this coordinate for squares or isolines is not defined. <br><br>  You can submit several variables to the shader output.  The main one is vec4 gl_Position, in which you need to record the coordinates of the vertices from which the primitives will be collected for the next stage of the pipeline.  In our case, this is a sequence of segments, since  shader tessellation makes only the skeleton for the future of the bush. <br><br>  So, we have many (up to 4096) vertices of the abstract patch, organized into lines that are divided into equal segments.  If we draw this shape as lines without changes: <br><br><pre> <code class="hljs lisp">gl_Position = vec4(<span class="hljs-name"><span class="hljs-name">gl_TessCoord</span></span>.xy, <span class="hljs-number"><span class="hljs-number">0.0</span></span>f, <span class="hljs-number"><span class="hljs-number">1.0</span></span>f)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre><br>  then we will see something similar to the pictures in the <a href="https://www.opengl.org/wiki/Tessellation">documentation</a> : <br><br><img src="https://habrastorage.org/files/ca6/280/0cf/ca62800cf26c45b18cefe91dac54b30d.png"><br>  <i>Here and below in the screenshots a little side view.</i> <br><br>  How to make stalks from these lines?  To begin, put them vertically: <br><br><pre> <code class="hljs lisp">gl_Position = vec4(<span class="hljs-name"><span class="hljs-name">gl_TessCoord</span></span>.yx, <span class="hljs-number"><span class="hljs-number">0.0</span></span>f, <span class="hljs-number"><span class="hljs-number">1.0</span></span>f)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre><br><img src="https://habrastorage.org/files/290/b3f/bae/290b3fbaec0f4e6ea217e6f0a402b459.png"><br><br>  and learn how to arrange them in a circle, turning around a vertical axis: <br><br><pre> <code class="hljs go">vec3 position = vec3(<span class="hljs-number"><span class="hljs-number">2.0f</span></span>, gl_TessCoord.x, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>); float alpha = gl_TessCoord.y * <span class="hljs-number"><span class="hljs-number">2.0f</span></span> * M_PI; float cosAlpha = cos(alpha); float sinAlpha = sin(alpha); mat3 circDistribution = mat3( cosAlpha, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, -sinAlpha, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, sinAlpha, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, cosAlpha); position = circDistribution * position; gl_Position = vec4(position, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>);</code> </pre><br><img src="https://habrastorage.org/files/f4b/2a7/6a8/f4b2a76a80274ab0a4f9602117441f10.png"><br><br>  However, such lines are more like a fence than a bush.  To make our bush more natural, let's twist the line as a cubic Bezier curve: <br><br><img src="https://habrastorage.org/files/547/ee0/1de/547ee01de6bd44e28a08a1dbcb5c295d.png" alt="Picture from Wikipedia, an article about Bezier curves."><br><br>  And here the coordinate of gl_TessCoord.x is very useful, about which we agreed to think that it runs along each stem from zero to one.  The type of curve completely depends on the reference points P <sub>0</sub> ... P <sub>3</sub> .  The bottom of the stem we will always be located on the ground, and its top must look towards the sky, so we take P <sub>0</sub> = (0; 0).  And to select at least an approximate position of the remaining free points, the site <a href="http://cubic-bezier.com/">cubic-bezier.com is perfect</a> , whose sole purpose is to build a curve of the desired type.  Now, if gl_TessCoord.x is substituted into the Bezier curve formula, then we get a polyline, the vertices of which lie on the curve, and the segments approximate the curve: <br><br><pre> <code class="hljs markdown">float t = gl_TessCoord.x; //  . float t1 = t - 1.0f; //    ,      . //  : position.xy = -p0 <span class="hljs-bullet"><span class="hljs-bullet">* (t1 *</span></span> t1 <span class="hljs-bullet"><span class="hljs-bullet">* t1) + p3 *</span></span> (t <span class="hljs-bullet"><span class="hljs-bullet">* t *</span></span> t) + p1 <span class="hljs-bullet"><span class="hljs-bullet">* t *</span></span> (t1 <span class="hljs-bullet"><span class="hljs-bullet">* t1) *</span></span> 3.0f - p2 <span class="hljs-bullet"><span class="hljs-bullet">* (t *</span></span> t) <span class="hljs-bullet"><span class="hljs-bullet">* t1 *</span></span> 3.0f; //     ,        : position.x += 2.0f; //     .      ,  : position.z = 0.0f;</code> </pre><br><img src="https://habrastorage.org/files/0b4/a57/51e/0b4a5751e6ea45438d4f9f67dde9fba6.png"><br><br>  In the future, we will need to build up polygons around a curved stem, for which each vertex of the broken stem needs to know the plane perpendicular to the stem.  From the course of differential geometry it is known that the principal normal vector to the parametric curve can be obtained as a combination of the vector products of the derivatives of the curve with respect to the parameter: <br><br>  [B ', [B', B '']] (1) <br><br>  To uniquely define the plane, we need another vector.  In our case, the entire curve is located in the vertical plane XY, which means the main normal to is located in it.  Therefore, binormal to the curve comes to us for nothing - this is just a constant vector (0; 0; 1).  Now we remember that from the cozy XY plane the stem turns around the origin, and therefore the normal plane also needs to be rotated.  To do this, it is enough to multiply both of its generators of the vector by the same rotation matrix as the points of the stem.  Putting it all together: <br><br><pre> <code class="hljs markdown">//  : out vec3 normal; out vec3 binormal; // : normal = normalize( circDistribution <span class="hljs-bullet"><span class="hljs-bullet">* //  ,    . vec3( //     ,    (1): p0.y *</span></span> (t1 <span class="hljs-bullet"><span class="hljs-bullet">* t1) *</span></span> -3.0f + p1.y <span class="hljs-bullet"><span class="hljs-bullet">* (t1 *</span></span> t1) <span class="hljs-bullet"><span class="hljs-bullet">* 3.0f - p2.y *</span></span> (t <span class="hljs-bullet"><span class="hljs-bullet">* t) *</span></span> 3.0f + p3.y <span class="hljs-bullet"><span class="hljs-bullet">* (t *</span></span> t) <span class="hljs-bullet"><span class="hljs-bullet">* 3.0f - p2.y *</span></span> t <span class="hljs-bullet"><span class="hljs-bullet">* t1 *</span></span> 6.0f + p1.y <span class="hljs-bullet"><span class="hljs-bullet">* t *</span></span> t1 <span class="hljs-bullet"><span class="hljs-bullet">* 6.0f, p0.x *</span></span> (t1 <span class="hljs-bullet"><span class="hljs-bullet">* t1) *</span></span> 3.0f - p1.x <span class="hljs-bullet"><span class="hljs-bullet">* (t1 *</span></span> t1) <span class="hljs-bullet"><span class="hljs-bullet">* 3.0f + p2.x *</span></span> (t <span class="hljs-bullet"><span class="hljs-bullet">* t) *</span></span> 3.0f - p3.x <span class="hljs-bullet"><span class="hljs-bullet">* (t *</span></span> t) <span class="hljs-bullet"><span class="hljs-bullet">* 3.0f + p2.x *</span></span> t <span class="hljs-bullet"><span class="hljs-bullet">* t1 *</span></span> 6.0f - p1.x <span class="hljs-bullet"><span class="hljs-bullet">* t *</span></span> t1 <span class="hljs-bullet"><span class="hljs-bullet">* 6.0f, 0.0f )); // : binormal = (circDistribution *</span></span> vec3(0.0f, 0.0f, 1.0f));</code> </pre><br>  And for clarity, reduce the detail of the stems.  Normals are drawn in red and binormals in blue: <br><br><img src="https://habrastorage.org/files/422/6d1/470/4226d1470c7e42b9b01299d9720e022c.png"><br><br>  Now briefly about the animation.  First, the stalks move by themselves.  This is done through a circular rotation of the support points of the curve around the other, original points.  In this case, the position of the initial points and the initial phase of rotation depend on a random variable (remember the random one-dimensional texture?), Which, in turn, depends on gl_TessCoord.y and gl_PrimitiveID.  Thus, each stem in each bush moves in its own way, which creates the illusion of chaos.  And since the movement is done through the movement of the control points, the normals and binormals remain completely correct.  In fact, we got a skeletal animation, in which the bones are generated on the fly, and do not occupy the memory. <br><br>  In addition to the bushes' own movement, they are still affected by the ‚Äúwind‚Äù.  Wind is the offset of the stem vertices in a user-defined direction by an amount that depends on two user parameters and Perlin noise.  At the same time the wind should not shift the roots of the stems, so the offset value is multiplied by the flexibility function: <br><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">flexibility</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">in</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x * x; }</code> </pre><br>  taken from the coordinate along the stem t1.  User wind parameters are called "speed" and "turbulence" purely arbitrary, because changing them in the available user range is similar to changing these air flow parameters.  However, this ‚Äúwind‚Äù has nothing to do with real physics.  The speed slider in the interface is intentionally limited to a small value, because the wind is applied to the skeleton after the normals have been calculated without adjusting them.  Because of this, the normals cease to be so, and with a strong distortion of the skeleton (high "speed" of the wind), self-intersections of polygons appear. <br><br>  Why Perlin noise, if there is a ‚Äúnoisy‚Äù texture?  The fact is that the texture values ‚Äã‚Äãare not a continuous function of the coordinate, unlike the Perlin noise.  Therefore, if in each frame we make an offset depending on the noisy texture, we will get a chaotic twitch with a frame rate instead of a smooth wind.  High-quality implementation of Perlin‚Äôs noise was taken from <a href="https://github.com/stegu/webgl-noise/tree/master/src">Stefan Gustavson</a> . <br><br>  What else is needed to build landfills?  First, the stem thickness should decrease from the root to the top.  Therefore, we enter the corresponding output variable and transfer to it a thickness depending on the coordinate along the stem: <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> stemThickness; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">thickness</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">in</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-number"><span class="hljs-number">1.0f</span></span> - x) / <span class="hljs-number"><span class="hljs-number">0.9f</span></span>; } <span class="hljs-comment"><span class="hljs-comment">//... stemThickness = thickness(gl_TessCoord.x);</span></span></code> </pre><br>  The very coordinate along the stem and the number of the stem in the bush will also be passed down the pipeline: <br><br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> along; flat <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> stemIdx; <span class="hljs-comment"><span class="hljs-comment">// ... along = gl_TessCoord.x; stemIdx = gl_TessCoord.y;</span></span></code> </pre><br>  We need them when applying textures. <br><br><h3>  Geometric Shader </h3><br>  Finally, we come to the completion of the geometric part of our path.  At the input of the geometric shader, we get the primitives entirely.  If at the entrance of the tessellation stage there were arbitrary patches that could contain a decent amount of data, here the primitives are points, lines, or triangles.    ,        ( , )   glDraw*, , ,     .       ,      ,    : <br><br><pre> <code class="hljs lisp">layout(<span class="hljs-name"><span class="hljs-name">lines</span></span>) in<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre><br>        <br><br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">in</span></span> gl_PerVertex { vec4 gl_Position; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> gl_PointSize; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> gl_ClipDistance[]; } gl_in[];</code> </pre><br>          .             : <br><br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">in</span></span> vec3 normal[]; <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> vec3 binormal[]; <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> stemThickness[]; <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> along[]; flat <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> stemIdx[];</code> </pre><br>       ,     .    : <br><br><pre> <code class="hljs lisp">layout(<span class="hljs-name"><span class="hljs-name">triangle_strip</span></span>) out<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre><br>           .       .     ,    gl_Position.         EmitVertex(),       .         EndPrimitive(); <br><br>    :  ,         ,                .     , ..          . <br><br> ,      5-    (flat)      : <br><br><img src="https://habrastorage.org/files/d05/40d/0f7/d0540d0f79fa4325a366f0450243f5e1.png"><br><br>   ,   : <br><br><pre> <code class="hljs ruby"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(int i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; numSectors + <span class="hljs-number"><span class="hljs-number">1</span></span>; ++i) { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    float around = i / float(numSectors); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   ,   [<span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-number"><span class="hljs-number">1</span></span>] float alpha = (around) * <span class="hljs-number"><span class="hljs-number">2.0</span></span>f * M_PI; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  ()     <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(int j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; <span class="hljs-number"><span class="hljs-number">2</span></span>; ++j) { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     /<span class="hljs-regexp"><span class="hljs-regexp">/ -      : vec3 r = cos(alpha) * normal[j] + sin(alpha) * binormal[j]; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/      : vec3 vertexPosition = r * stemRadius * stemThickness[j] + gl_in[j].gl_Position.xyz; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/        . /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/     . /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/      , .. gl_Position  /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    ,       . fragPosition = vertexPosition; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   . fragNormal = r; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/         . fragAlong = along[j]; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/       .   /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ fragAlong  fragAround      ,  /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/     . fragAround = around; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/       ,     /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   .     /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   . stemIdxFrag = stemIdx[j]; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ ,        . /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    "" ,     /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/        . gl_Position = viewProjectionMatrix * vec4 (vertexPosition, gl_in[j].gl_Position.w); EmitVertex(); } } EndPrimitive();</span></span></code> </pre><br><h3>   </h3><br>     ,     .     <a href="https://en.wikipedia.org/wiki/Phong_reflection_model"> </a>           , <a href=""></a>      .  ¬´¬ª      ,      ( )      : <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">out</span></span> vec4 outColor; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> sfn = <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>(frameNumber) / totalFrames; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cap</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">in</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -abs(fma(x, <span class="hljs-number"><span class="hljs-number">2.0f</span></span>, <span class="hljs-number"><span class="hljs-number">-1.0f</span></span>)) + <span class="hljs-number"><span class="hljs-number">1.0f</span></span>; } <span class="hljs-comment"><span class="hljs-comment">//... float cell = cellular2x2(vec2(fma(sfn, 100, rand(stemIdxFrag) + fragAlong * 3.0f), cap(fragAround)) * 10.0f).x * 0.3f; outColor = ambient + diffuse + specular + vec4(0.0f, cell, 0.0f, 0.0f)</span></span></code> </pre><br>  ,   ¬´¬ª  ,     . <br><br>        ,      . <br><br><h3>  What for? </h3><br> ,          ? : ,     .        ,     -  : <br><br><ul><li>    ,      .    ,    -     . </li><li>        .           - ,        . </li><li>        .                  . </li></ul><br><h3>  useful links </h3><br>       .       ,        : <br><br><ul><li> <a href="http://www.dgp.toronto.edu/people/stam/reality/Research/pdf/GDC03.pdf"> -   </a> .               -,    <a href="https://www.opengl.org/wiki/Compute_Shader"> </a> .  ¬´¬ª      . </li><li> <a href="https://www.opengl.org/sdk/docs/reference_card/opengl43-quick-reference-card.pdf">  -  OpenGL</a> .    ,            . </li><li> <a href="https://www.opengl.org/wiki/Rendering_Pipeline_Overview">  </a> . </li></ul><br><br>   ! <br><br> <b>UPD1</b> <br><div class="spoiler"> <b class="spoiler_title"> </b> <div class="spoiler_text"><iframe width="560" height="315" src="https://www.youtube.com/embed/CkdOXQ2Eyyc" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br></div></div><br><br> <b>UPD2</b> <br> <a href="https://drive.google.com/open%3Fid%3D0B-X82AnZcQ-kbklVTkF0bWlXeVU"></a>    Windows. </div><p>Source: <a href="https://habr.com/ru/post/314532/">https://habr.com/ru/post/314532/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../314518/index.html">Working with the VKontakte C # API</a></li>
<li><a href="../314520/index.html">Measurement of resistance and inductance of a DC motor</a></li>
<li><a href="../314522/index.html">Auto-collection of data about database files and logical disks of the operating system in MS SQL Server</a></li>
<li><a href="../314524/index.html">.NET Tools. Interview with Sergey Shkredov (JetBrains), Pavel Avsenin and Alexander Zakharov (DevExpress)</a></li>
<li><a href="../314528/index.html">The power of ITIL and the problem with the guru</a></li>
<li><a href="../314534/index.html">Bug Inside: a tiny chance to make a huge mistake on the Pentium</a></li>
<li><a href="../314536/index.html">Mars Rover, Introduction</a></li>
<li><a href="../314538/index.html">The digest of interesting materials for the mobile developer # 178 (October 31-November 6)</a></li>
<li><a href="../314540/index.html">Installing node.js on Raspberry Pi</a></li>
<li><a href="../314542/index.html">54th terabit highway in Asia commissioned</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>