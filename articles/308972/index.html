<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>The logic of consciousness. Part 3. Holographic memory in a cellular automaton</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Earlier, we described a cellular automaton in which waves with a cunning inner pattern can appear. We have shown that such waves are able to spread in...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>The logic of consciousness. Part 3. Holographic memory in a cellular automaton</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/e86/20b/3cb/e8620b3cb1364699bf0a34145b4fee17.jpg" width="500" align="left">  Earlier, we described a cellular automaton in which waves with a cunning inner pattern can appear.  We have shown that such waves are able to spread information across the surface of an automaton.  It turned out that any place in the automaton can be both a receiver and a source of waves.  To receive a wave in any place, it is enough to see what pattern it turns out at the moment of the wave passing.  If this pattern is remembered and subsequently reproduced in the same place, a wave will propagate from this pattern, repeating the pattern of the original wave in its path. <br><br>  All this is very reminiscent of the radio.  Anywhere on earth you can take a message and remember.  Then from anywhere you can start it on the air again.  At the same time, broadcasting does not mean a specific recipient, but the availability of a signal for everyone. <br><br>  The automaton we describe has memory.  More precisely, all its elements have memory.  Item memory is specific.  The only thing that sees the element of the machine is a pattern made up of the activity of its neighbors.  The only way an element can react to a particular pattern is either to become active itself or, on the contrary, to turn off.  An element's memory is a set of patterns it has memorized, with an indication of how to react to them: turn it on or off. <br><a name="habracut"></a><br><h3>  Interference patterns in the cellular automaton </h3><br>  The presence of the elements of the automaton's own memory allows the use of the cellular automaton itself as a universal storage device that implements an associative array.  An associative array is a repository of key-value pairs.  In order to be able to manipulate with the saved data, an associative array must support operations: add a pair, find a pair (by key or by data), and delete a pair.  Let us show how this can be implemented in our cellular automaton. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      For large analogies with the cerebral cortex, we move from a flat cellular automaton to a volumetric one.  Arrange the elements in the nodes of a regular spatial lattice.  Replace the flat tracking space on the volume, forming a cylinder.  We assume that the thickness of the automaton is substantially less than the size of its surface.  Let us single out for observation a cylindrical volume whose dimensions are comparable with the tracking area of ‚Äã‚Äãthe elements of the automaton (figure below).  We will call a volume of this size elementary, meaning that it is the minimum volume that allows a wave to be launched without fail if a fragment of the pattern of this wave is reproduced inside this volume. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/26a/852/37d/26a85237db814ffeab57c2d1f5ec702f.png" width="500"></div><br>  <i>Spatial cellular automaton and a dedicated cylindrical fragment</i> <br><br>  Suppose that we sequentially launched two information waves in the automaton.  Let the first wave bears the value we want to save, and the second wave is the unique key that we want to make an identifier of the stored information.  Each of the waves will spread its pattern throughout the entire space of the automaton, that is, in each of its places two patterns will successively pass, formed by the first and second wave, respectively.  In the observed fragment, the first wave will leave a mark, for example, such as shown in the figure below. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/fcc/ecd/26b/fccecd26b78b4bd0846ba49dce231e11.png" width="200"></div><br>  <i>The trace of the information wave carrying the value that you need to remember</i> <br><br>  Let the elements remember their recent state.  That is, after the passage of the wave, the activity of the elements disappears, but the fact that they were active is stored by the elements before the general reset signal.  In other words, the trace left by the wave is saved until a general reset. <br><br>  The second wave will leave its mark in the same volume (figure below).  We denote the elements of each wave by our color, while some elements can receive two colors at once. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/101/41e/d4f/10141ed4f1b045bda23527937aad40f9.png" width="200"></div><br>  <i>Traces from two waves.</i>  <i>Yellow - elements encoding value.</i>  <i>Black - key coding elements</i> <br><br>  Now, let's memorize.  To do this, on all the elements of yellow color, remember the pattern formed by the elements of black.  In turn, on all black elements we will remember the pattern formed by the yellow elements.  The first captures the information pattern with the required key.  The second, on the contrary, fixes the key pattern, while the ‚Äúkey‚Äù is the information pattern itself.  As a result of such a kind of ‚Äúinterference‚Äù in the specified volume, the key-value pair will remain. <br><br>  The process of reverse playback is very simple.  Run the key in the machine.  That is, we will start the same black wave.  In the volume we are following, the yellow elements are activated.  For them, the black element pattern will be a signal stored in their memory and causing their activity.  As a result, we will restore the yellow pattern, which is the value for the corresponding key.  This yellow pattern will trigger a wave that will spread the information extracted from the memory over the space of the machine.  Actually, the described is the implementation of the recording of information and its search by key. <br><br>  If all keys are unique, then reproduction of information by key will cause a single response information wave corresponding to the value of the pair for this key.  If the value codes are also unique, then a reverse key search by value will be possible. <br><br>  To save one information key-value pair, it is enough to perform memorization in one elementary volume.  If in any way when memorizing to indicate to the automaton the place where we want to store the memory, then we can get a spatially distributed storage system.  However, nothing prevents you from performing ‚Äúredundant‚Äù distributed memorization.  That is, to remember one and the same information not in one place, but in the whole space of the cellular automaton.  Both that and another - very important properties which will be necessary for us further. <br><br>  Each elemental volume can store many memories.  The size of its memory is proportional to how many patterns a separate element of an automaton can store.  If one memorized pattern is, for example, two percent of the activity of all elements, then the total number of possible memories for an elementary volume will be approximately 20-30 times more than the memory of one element. <br><br>  The peculiar interference of two information waves and distributed memorization make the described mechanism extremely similar to <a href="https://ru.wikipedia.org/wiki/%25D0%2593%25D0%25BE%25D0%25BB%25D0%25BE%25D0%25B3%25D1%2580%25D0%25B0%25D1%2584%25D0%25B8%25D1%258F">optical holography</a> .  Principles of holography discovered and described by Denes Gabor.  If we have a light source with a stable frequency, then dividing it by means of a translucent mirror into two, we will get two coherent light fluxes.  One stream can be directed to the object, and the second to the photographic plate. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/e1f/0f6/be3/e1f0f6be345f4de3bce76227354215ca.png" width="500"></div><br>  <i>Create a hologram</i> <br><br>  As a result, when the light reflected from the object reaches the photographic plate, it will create an interference pattern with the stream illuminating the plate.  The interference pattern, imprinted on the photographic plate, will save information not only about the amplitude, but also about the phase characteristics of the light field reflected by the object.  Now, if we illuminate the previously exposed plate, the original luminous flux will be restored, and we will see the memorized object in all its three-dimensional volume. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/cbc/b87/25f/cbcb8725fd944efaba5f4b5ad6cba6d5.png" width="400"></div><br>  <i>Hologram reproduction</i> <br><br>  The hologram has several amazing properties.  First, the luminous flux saves volume, that is, looking at a phantom object from different angles, you can see it from different sides.  Secondly, each area of ‚Äã‚Äãthe hologram contains information about the entire light field.  So, if we cut the hologram in half, then at first we will see only half of the image.  But when we look at the hologram from the side, then beyond the edge of the remaining hologram we will be able to see the second ‚Äúcut off‚Äù part.  The smaller the fragment of the hologram, the lower its resolution, but even through a small area you can, like through a keyhole, view the entire image. <br><br>  Accordingly, the described memory in its essence may well be called holographic, but with the proviso that it is not based on the classical wave interference, but on the pattern interference that is somewhat different in its algorithm.  Although, if we dig deeper, in the view of <a href="https://ru.wikipedia.org/wiki/%25D0%25A6%25D0%25B8%25D1%2584%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D1%258F_%25D1%2584%25D0%25B8%25D0%25B7%25D0%25B8%25D0%25BA%25D0%25B0">digital physics</a> , which considers space as a cellular automaton, these interferences can be identical in nature. <br><br><h3>  Description of the state of the machine through a bitmap </h3><br>  Any elementary volume of the machine can be mapped bitmap.  In the initial state, all its elements are zero.  The passage of a wave turns part of the elements into units.  In the cellular automaton, after passing through the wave front, the elements return to the inactive state.  In the mapped bitmap, we introduce some other rules.  We will leave the array bits in a single state, accumulating activity after passing the next wave.  We will perform a general reset of the state of the array, when we consider it necessary. <br><br>  Each wave encodes only one concept.  Adding traces of waves allows you to make a description, consisting of several concepts at the same time.  Resetting the state of the bitmap resets the description.  The successive passage of the waves creates a description.  The finished description appears when all the necessary waves propagate. <br><br>  The structure described corresponds <a href="https://ru.wikipedia.org/wiki/%25D0%25A4%25D0%25B8%25D0%25BB%25D1%258C%25D1%2582%25D1%2580_%25D0%2591%25D0%25BB%25D1%2583%25D0%25BC%25D0%25B0">to the Bloom filter</a> .  Suppose that we have a set C consisting of concepts with which we operate.  To each element c <sub>i of the</sub> set C, we associate a binary code b <sub>i of</sub> length m, containing k ones.  Select the position of units randomly.  We compose the set I from several concepts of the set C. <br><br>  Bloom's filter contains a bitmap B of m bits.  In the initial state, it is reset.  Adding an element to Bloom's filter is a reference to the unit of those filter elements that correspond to the binary code of the element being added.  Mapping the set I to the Bloom filter is equivalent to the logical addition of the binary codes of the elements constituting I, and transferring the resulting code to the binary array of the filter. <br><br>  The Bloom filter allows you to check the membership of any element of the set C, the set I. To check, you must take the binary code of the element and make sure that all units of the code correspond to the units in the Bloom filter.  If at least one of the positions of the filter does not match, then the element is guaranteed not to belong to the set I. If the check is passed, then the element is contained in I with a high probability, which depends on the filter parameters. I The example of the check is shown in the figure below. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/53f/f13/218/53ff132188834596bf6adb1dce7e6224.png" width="500"></div><br>  <i>Bloom filter.</i>  <i>The element w does not belong to the given set {x, y, z}</i> <br><br>  One concept in a cellular automaton in an elementary volume is encoded by a pattern consisting of a small number of elements with respect to the total number of elements in this volume.  Accordingly, the binary code of the concept can be spoken of as a long binary bit code. <br><br>  After the formation of the bit array corresponding to the long description, the density of units will increase, which will correspond to the long binary medium-low coding. <br><br>  For our automaton, we assume that the total digit capacity, equal to the number of elements in the elementary volume, is quite high, the total number of concepts used is reasonably limited and that the possible number of concepts in one description is not particularly large.  Then it is possible to take a bitmap obtained after transmitting a description consisting of several concepts and restore the original concepts themselves.  To do this, you need to try on the bitmap, like the Bloom filter, codes for all possible concepts and see which ones will give a positive result.  In the assumptions made, it can be achieved that the probability of false positives is low when checking. <br><br>  This means that total binary codes can be used as analogues of the original description.  That is, in each place of the automaton the total binary code received after the distribution of a complex description will contain the entirety of the original description. <br><br><h3>  Creating a hash of complex descriptions in the cellular automaton </h3><br>  To save a complex description in its cellular automata in its entirety, it suffices to carry out the memorization procedure described earlier.  Create an identifier of memories and implement the description and identifier interference.  When memorizing the elements that encode the pattern of the identifier of the memory, you will have to remember a picture of the description containing quite a few units.  When computer simulating a cellular automaton, this is not a problem, but, as will be shown later, memorizing with a large number of signals is difficult for a biological system.  Accordingly, the question arises: is it possible to reduce the number of active elements that make up the description (or identifier), reducing their number to the amount of low coding? <br><br>  As a result, we come to the problem of <a href="https://ru.wikipedia.org/wiki/%25D0%25A5%25D0%25B5%25D1%2588%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5">hashing</a> .  Hashing is a conversion, according to a certain algorithm, of an input array of data of arbitrary length into an output bit string of fixed length.  Such transformations are also called hash functions or ‚Äúconvolution functions,‚Äù and their results are called a hash code or ‚Äúmessage digest.‚Äù <br><br>  To bring our cellular automaton to the conditions of the hashing task, we introduce a new bit hash array of relatively small length for an elementary volume. <br><br>  The hash conversion we need should reduce the length of the long binary code to the size of the hash.  A good hash function should minimize the number of possible collisions.  That is, it is desirable that the likelihood that two different descriptions can get the same hash was minimal. <br><br>  We will not now dwell on which hash function is better to use in our case.  This question is quite interesting, but difficult.  Simply, we give, as an example, one of the simplest options. <br><br>  You can divide the elements of the original bitmap into groups and calculate any one-bit logical function of the elements of the group (figure below).  Then generate a hash code of the received bits. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/065/fa9/6f3/065fa96f391c43d7bf128f6480c257d1.png" width="300"></div><br>  <i>Example of calculating one bit of hash for a group of elements</i> <br><br>  We introduce into the cellular automaton additional elements that will correspond to the elements of the hash array.  We will not affect the regular grid of the source cells.  Let's create for our own elements our own lattice located in the same geometric space.  Let the old elements of the automaton see the picture of the activity of the surrounding hash elements and let them memorize it. <br><br>  In addition, we modify the original elements in such a way that they can accumulate information about their activity during those several waves while the message is being transmitted. <br><br>  Let us try to memorize a complex description consisting of several concepts.  For this purpose, we will successively spread the waves, corresponding to the concepts from the description, over the space of the automaton.  We accumulate information about the activity.  That is, we will form a total picture of the trace of waves in the entire volume of the automaton.  Then, we calculate the activity of the hash elements. <br><br>  The figure below shows the result of the addition of several wave patterns and the result of their hash transform.  Green elements form a hash code pattern.  These elements exist separately from the original basic elements, but are with them in the same space.  That is, they are available for observation. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/02f/91c/0dc/02f91c0dcbf14fa3a5f7ad098aee571e.png" width="200"></div><br>  <i>Addition of several patterns</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/699/80f/c8b/69980fc8b64a48b193b9c77c6dafd6b8.png" width="200"></div><br>  <i>Hash transform result</i> <br><br>  Now spread the key and keep the memory.  Only now the elements involved in the key pattern will not memorize the informational picture of the activity of the main elements, but the pattern of the resulting hash. <br><br>  After the recording is completed, we can reset the activity of the machine and re-submit the original description.  The pattern of activity of the main elements will be repeated, the hash calculated from it will be repeated.  The appearance of a familiar hash code will cause the appearance of the pattern corresponding to the key of the previously made memory. <br><br>  If the description corresponds to a single event, the automaton can extract and distribute the identifier of this event.  If there are several memories in memory with the same descriptions, then a summary picture composed of the identifiers of these descriptions will appear.  This situation requires more complex processing. <br><br>  Let's summarize: <br><br><ul><li>  Two information waves can ‚Äúinterfere‚Äù with each other.  One wave marks the elements that need to remember something, and the other wave draws a pattern of what exactly they need to remember; </li><li>  Too dense pattern when memorizing, you can replace it with a hash; </li><li>  You can memorize locally in a small area of ‚Äã‚Äãthe machine.  Then you can store something in each place; </li><li>  You can remember globally.  Then in each place of the machine will be stored its own copy of the same information. </li></ul><br>  It is not by chance that I focus on the possibilities of local and global memorization.  Next, I will show that these two mechanisms are key to understanding the operation of the brain. <br><br>  Alexey Redozubov <br><br>  <a href="https://habrahabr.ru/post/308268/">The logic of consciousness.</a>  <a href="https://habrahabr.ru/post/308268/">Introduction</a> <br>  <a href="https://habrahabr.ru/post/308370/">The logic of consciousness.</a>  <a href="https://habrahabr.ru/post/308370/">Part 1. Waves in the cellular automaton</a> <br>  <a href="https://habrahabr.ru/post/308878/">The logic of consciousness.</a>  <a href="https://habrahabr.ru/post/308878/">Part 2. Dendritic waves</a> <br>  <a href="https://habrahabr.ru/post/308972/">The logic of consciousness.</a>  <a href="https://habrahabr.ru/post/308972/">Part 3. Holographic memory in a cellular automaton</a> <br>  <a href="https://habrahabr.ru/post/309366/">The logic of consciousness.</a>  <a href="https://habrahabr.ru/post/309366/">Part 4. The secret of brain memory</a> <br>  <a href="https://habrahabr.ru/post/309626/">The logic of consciousness.</a>  <a href="https://habrahabr.ru/post/309626/">Part 5. The semantic approach to the analysis of information</a> <br>  <a href="https://habrahabr.ru/post/310214/">The logic of consciousness.</a>  <a href="https://habrahabr.ru/post/310214/">Part 6. The cerebral cortex as a space for calculating meanings.</a> <br>  <a href="https://habrahabr.ru/post/310960/">The logic of consciousness.</a>  <a href="https://habrahabr.ru/post/310960/">Part 7. Self-organization of the context space</a> <br>  <a href="https://habrahabr.ru/post/312060/">The logic of consciousness.</a>  <a href="https://habrahabr.ru/post/312060/">Explanation "on the fingers"</a> <br>  <a href="https://habrahabr.ru/post/312740/">The logic of consciousness.</a>  <a href="https://habrahabr.ru/post/312740/">Part 8. Spatial maps of the cerebral cortex</a> <br>  <a href="https://habrahabr.ru/post/317712/">The logic of consciousness.</a>  <a href="https://habrahabr.ru/post/317712/">Part 9. Artificial neural networks and minicolumns of the real cortex.</a> <br>  <a href="https://habrahabr.ru/post/320866/">The logic of consciousness.</a>  <a href="https://habrahabr.ru/post/320866/">Part 10. The task of generalization</a> <br>  <a href="https://habrahabr.ru/post/321256/">The logic of consciousness.</a>  <a href="https://habrahabr.ru/post/321256/">Part 11. Natural coding of visual and sound information</a> <br>  <a href="https://habrahabr.ru/post/326334/">The logic of consciousness.</a>  <a href="https://habrahabr.ru/post/326334/">Part 12. The search for patterns.</a>  <a href="https://habrahabr.ru/post/326334/">Combinatorial space</a> </div><p>Source: <a href="https://habr.com/ru/post/308972/">https://habr.com/ru/post/308972/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../308958/index.html">In the new list of the most profitable IT companies in Russia, 50% of the seats are occupied by foreign firms.</a></li>
<li><a href="../308960/index.html">Optimization by example. Imitation annealing against the ant algorithm. Part 1</a></li>
<li><a href="../308962/index.html">Using TCL in FPGA Development</a></li>
<li><a href="../308966/index.html">New release of Kali Linux 2016.2</a></li>
<li><a href="../308968/index.html">AMD introduces new security mechanisms for its AMD-V hypervisor</a></li>
<li><a href="../308974/index.html">Tabs or spaces? Analysis of 400 thousand GitHub repositories, billion files, 14 TB code</a></li>
<li><a href="../308976/index.html">A gift for September 1 to all fans of digital circuitry and computer architecture</a></li>
<li><a href="../308978/index.html">Sort a huge file with an array with a known data dictionary</a></li>
<li><a href="../308980/index.html">Input lag during rendering and how to win</a></li>
<li><a href="../308982/index.html">Sorry, we are launching a new product.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>