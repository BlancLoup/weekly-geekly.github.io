<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Pattern matching in C # 7</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In C # 7, the long-awaited feature called pattern matching finally appeared. If you are familiar with functional languages, such as F #, then this fun...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Pattern matching in C # 7</h1><div class="post__text post__text-html js-mediator-article">  In C # 7, the long-awaited feature called pattern matching finally appeared.  If you are familiar with functional languages, such as F #, then this function as it exists at the moment may disappoint you a little.  But even today, it can simplify the code in a variety of cases.  More under the cut! <br><br><img src="https://habrastorage.org/webt/tw/bk/ck/twbkckursaas-xb76976szvpmm0.jpeg"><a name="habracut"></a><br><br>  Each new feature can be dangerous for a developer creating an application for which performance is critical.  New levels of abstractions are good, but to use them effectively, you need to understand how they actually work.  This article discusses the pattern matching function and how it works. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The pattern in C # can be used in the is expression, as well as in the case block of the switch statement. <br>  There are three types of samples: <br><br><ul><li>  sample constants; </li><li>  sample type; </li><li>  sample variable. </li></ul><br><h2>  Pattern matching in is expressions </h2><br><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsExpressions</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> o</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Alternative way checking for null if (o is null) Console.WriteLine("o is null"); // Const pattern can refer to a constant value const double value = double.NaN; if (o is value) Console.WriteLine("o is value"); // Const pattern can use a string literal if (o is "o") Console.WriteLine("o is \"o\""); // Type pattern if (o is int n) Console.WriteLine(n); // Type pattern and compound expressions if (o is string s &amp;&amp; s.Trim() != string.Empty) Console.WriteLine("o is not blank"); }</span></span></code> </pre> <br>  Using the is expression, you can check whether the value is constant, and using the type check, you can additionally determine the sample variable. <br><br>  When using pattern matching in is expressions, you should pay attention to several interesting points: <br><br><ul><li>  The variable entered by the if statement is sent to the outer scope. </li><li>  The variable entered by the if statement is explicitly assigned only when the sample falls. </li><li>  The current implementation of pattern matching of a constant in is expressions is not very efficient. </li></ul><br>  First, consider the first two cases: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ScopeAndDefiniteAssigning</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> o</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (o <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> s &amp;&amp; s.Length != <span class="hljs-number"><span class="hljs-number">0</span></span>) { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"o is not empty string"</span></span>); } <span class="hljs-comment"><span class="hljs-comment">// Can't use 's' any more. 's' is already declared in the current scope. if (o is int n || (o is string s2 &amp;&amp; int.TryParse(s2, out n))) { Console.WriteLine(n); } }</span></span></code> </pre> <br>  The first if statement introduces the variable s, visible inside the entire method.  This is reasonable, but it will complicate the logic if other if expressions in the same block try to reuse the same name.  In this case, be sure to use a different name to avoid conflicts. <br><br>  The variable entered in the is expression is explicitly assigned only when the predicate is true.  This means that the variable n in the second if expression is not assigned in the right-hand operand, but since it is already declared, we can use it as the out variable in the int.TryParse method. <br><br>  The third point mentioned above is the most important.  Consider the following example: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BoxTwice</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-number"><span class="hljs-number">42</span></span>) Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"n is 42"</span></span>); }</code> </pre> <br>  In most cases, the expression is converted to object.Equals (constant, variable) [although the characteristics state that for simple types you should use the == operator]: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BoxTwice</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>.Equals(<span class="hljs-number"><span class="hljs-number">42</span></span>, n)) { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"n is 42"</span></span>); } }</code> </pre> <br>  This code triggers two packaging-transformation processes that can significantly affect performance if used on the critical path of the application.  Previously, the expression o is null caused packing if the variable o had a type that is null-capable (see <a href="https://github.com/dotnet/roslyn/issues/13247">Suboptimal code for e is null</a> (‚ÄúNon-optimal code for e is null‚Äù)), but it is hoped that this will be corrected (here is the corresponding <a href="https://github.com/dotnet/roslyn/issues/20642">request on github</a> ). <br><br>  If the variable n is of type object, then the expression o is 42 will invoke one packing-transform process (for literal 42), although a similar code based on the switch statement would not lead to this. <br><br><h2>  Variable pattern in is expression </h2><br>  A sample variable is a special kind of sample type with one big difference: the sample will match any value, even null. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsVar</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> o</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (o <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x) Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"x: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{x}</span></span></span><span class="hljs-string">"</span></span>); }</code> </pre> <br>  The expression o is object will be true if o is not null, but the expression o is var x will always be true.  Therefore, the compiler in release mode * completely eliminates if statements and simply leaves the call to the Console method.  Unfortunately, the compiler does not warn about the inaccessibility of the code in the following case: if (! (O is var x)) Console.WriteLine ("Unreachable").  There is hope that this too will be fixed. <br><br>  <i>* It is not clear why behavior differs only in release mode.</i>  <i>It seems that the root of all the problems is the same: the initial implementation of the function is not optimal.</i>  <i>However, judging by <a href="">this commentary by</a> Neil Gafter, everything will change soon: ‚ÄúThe code for pattern matching will be rewritten from scratch (to also support recursive patterns).</i>  <i>I think that most of the improvements that you are talking about will be implemented in the new code and are available for free.</i>  <i>However, this will take some time. ‚Äù</i> <br><br>  The absence of a null check makes this situation special and potentially dangerous.  However, if you know the exact principles of this sample, then it may be useful.  It can be used to insert a temporary variable into the expression: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">VarPattern</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IEnumerable&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; s</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s.FirstOrDefault(o =&gt; o != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> v &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.TryParse(v, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> n)) { Console.WriteLine(n); } }</code> </pre> <br><h2>  Is expression and operator Elvis </h2><br>  There is another case that may be useful.  A sample type corresponds to a value only when it is not null.  We can use this ‚Äúfiltering‚Äù logic with a null propagation operator to make the code more readable: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WithNullPropagation</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IEnumerable&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; s</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s?.FirstOrDefault(str =&gt; str.Length &gt; <span class="hljs-number"><span class="hljs-number">10</span></span>)?.Length <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> length) { Console.WriteLine(length); } <span class="hljs-comment"><span class="hljs-comment">// Similar to if (s?.FirstOrDefault(str =&gt; str.Length &gt; 10)?.Length is var length2 &amp;&amp; length2 != null) { Console.WriteLine(length2); } // And similar to var length3 = s?.FirstOrDefault(str =&gt; str.Length &gt; 10)?.Length; if (length3 != null) { Console.WriteLine(length3); } }</span></span></code> </pre> <br>  Note that the same pattern can be used for both value types and reference types. <br><br><h2>  Pattern matching in case blocks </h2><br>  In C # 7, the functionality of the switch operator has been extended, so that samples can now be used in case clauses: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Count&lt;T&gt;(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> IEnumerable&lt;T&gt; e) { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (e) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ICollection&lt;T&gt; c: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> c.Count; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> IReadOnlyCollection&lt;T&gt; c: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> c.Count; <span class="hljs-comment"><span class="hljs-comment">// Matches concurrent collections case IProducerConsumerCollection&lt;T&gt; pc: return pc.Count; // Matches if e is not null case IEnumerable&lt;T&gt; _: return e.Count(); // Default case is handled when e is null default: return 0; } }</span></span></code> </pre> <br>  This example shows the first set of changes to the switch statement. <br><br><ol><li>  The switch statement can use any type of variable. </li><li>  The case clause can specify a pattern. </li><li>  The order of sentences is important.  The compiler will give an error if the previous sentence matches the base type, and the subsequent one is derived. </li><li>  Non-standard sentences are implicitly checked for null **.  In the example above, the last case clause is valid, since it matches only when the argument is not null. </li></ol><br>  <i>** In the last case clause, another function added to C # 7 is an empty variable pattern.</i>  <i>The special name _ tells the compiler that the variable is not needed.</i>  <i>The type pattern in the case clause requires a pseudonym.</i>  <i>But if you don't need it, you can use _.</i> <br><br>  The following fragment shows another feature of pattern matching based on the switch operator ‚Äî the ability to use predicates: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FizzBuzz</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> o</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (o) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> s when s.Contains(<span class="hljs-string"><span class="hljs-string">"Fizz"</span></span>) || s.Contains(<span class="hljs-string"><span class="hljs-string">"Buzz"</span></span>): Console.WriteLine(s); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n when n % <span class="hljs-number"><span class="hljs-number">5</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; n % <span class="hljs-number"><span class="hljs-number">3</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span>: Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"FizzBuzz"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n when n % <span class="hljs-number"><span class="hljs-number">5</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span>: Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"Fizz"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n when n % <span class="hljs-number"><span class="hljs-number">3</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span>: Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"Buzz"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n: Console.WriteLine(n); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } }</code> </pre> <br>  This is a strange version of the <a href="http://wiki.c2.com/%3FFizzBuzzTest">FizzBuzz</a> task, in which the object is processed, and not just a number. <br><br>  A switch statement can include multiple case clauses with the same type.  In this case, the compiler combines all type checks to avoid unnecessary computation: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FizzBuzz</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> o</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// All cases can match only if the value is not null if (o != null) { if (o is string s &amp;&amp; (s.Contains("Fizz") || s.Contains("Buzz"))) { Console.WriteLine(s); return; } bool isInt = o is int; int num = isInt ? ((int)o) : 0; if (isInt) { // The type check and unboxing happens only once per group if (num % 5 == 0 &amp;&amp; num % 3 == 0) { Console.WriteLine("FizzBuzz"); return; } if (num % 5 == 0) { Console.WriteLine("Fizz"); return; } if (num % 3 == 0) { Console.WriteLine("Buzz"); return; } Console.WriteLine(num); } } }</span></span></code> </pre> <br>  But you need to remember two things: <br><br>  1. The compiler combines only sequential type checking, and if you mix case clauses with different types, less quality code will be generated: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (o) { <span class="hljs-comment"><span class="hljs-comment">// The generated code is less optimal: // If o is int, then more than one type check and unboxing operation // may happen. case int n when n == 1: return 1; case string s when s == "": return 2; case int n when n == 2: return 3; default: return -1; }</span></span></code> </pre> <br>  The compiler converts it like this: <br><br>  if (o is int n &amp;&amp; n == 1) return 1; <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (o <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> s &amp;&amp; s == <span class="hljs-string"><span class="hljs-string">""</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (o <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n2 &amp;&amp; n2 == <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>;</code> </pre> <br>  2. The compiler does its best to avoid typical ordering problems. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (o) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Error: The switch case has already been handled by a previous case. case int n when n == 1: return 2; }</span></span></code> </pre> <br>  However, the compiler cannot determine that one predicate is stronger than another, and effectively replaces the following case clauses: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (o) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n when n &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Will never match, but the compiler won't warn you about it case int n when n &gt; 1: return 2; }</span></span></code> </pre> <br><h2>  Model Briefing </h2><br><ul><li>  The following patterns appeared in C # 7: a constant pattern, a pattern type, a sample variable, and a sample empty variable. </li><li>  Patterns can be used in is expressions and in case blocks. </li><li>  The implementation of the sample constant in the is expression for value types is far from ideal in terms of performance. </li><li>  Variable patterns are always the same, you have to be careful with them. </li><li>  The switch statement can be used for a set of type checks with additional predicates in when clauses. </li></ul><br><h2>  Unity event in Moscow - Unity Moscow Meetup 2018.1 </h2><br>  October 11, Thursday, Unity Moscow Meetup 2018.1 will be held at VSHBI.  This is the first meeting of Unity developers in Moscow this season.  The theme of the first mitap will be AR / VR.  You are waiting for interesting reports, communication with industry professionals, as well as a special demo zone from MSI. <br><br>  <a href="http://unimosmeet.ru/event2018_1">Details</a> </div><p>Source: <a href="https://habr.com/ru/post/423229/">https://habr.com/ru/post/423229/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../423215/index.html">Where is my money, dude: what is silent Steam</a></li>
<li><a href="../423217/index.html">Back to the future: practical proof of the Tomonaga-Luttinger theory after almost 56 years</a></li>
<li><a href="../423219/index.html">On the improvement of nuclear fuel</a></li>
<li><a href="../423221/index.html">Interview with Liz Parrish, CEO BioViva</a></li>
<li><a href="../423225/index.html">Jeff Bezos Foundation "Day One"</a></li>
<li><a href="../423231/index.html">Anomaly Frango, the climax</a></li>
<li><a href="../423233/index.html">Artificial Intelligence in the real world</a></li>
<li><a href="../423235/index.html">From Dribbble to Android Motion</a></li>
<li><a href="../423237/index.html">Simple but smart robotic arm</a></li>
<li><a href="../423239/index.html">Creating packages for Kubernetes with Helm: chart structure and templating</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>