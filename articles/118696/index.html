<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Developing Modules for Limbo C (Part 2)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Part 1 
 Content 


- Heap What is in my memory ... Something about garbage collection Types of objects in heap We create our complex structures in he...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Developing Modules for Limbo C (Part 2)</h1><div class="post__text post__text-html js-mediator-article">  <a href="http://habrahabr.ru/post/118665/">Part 1</a> <br><h4>  Content </h4><br><ul><li>  <a href="https://habr.com/ru/post/118696/">Heap</a> <br><ul><li>  <a href="https://habr.com/ru/post/118696/">What is in my memory ...</a> </li><li>  <a href="https://habr.com/ru/post/118696/">Something about garbage collection</a> </li><li>  <a href="https://habr.com/ru/post/118696/">Types of objects in heap</a> </li><li>  <a href="https://habr.com/ru/post/118696/">We create our complex structures in heap</a> </li></ul></li><li>  <a href="https://habr.com/ru/post/118696/">Array</a> <br><ul><li>  <a href="https://habr.com/ru/post/118696/">adt and ref adt</a> </li></ul></li><li>  <a href="https://habr.com/ru/post/118696/">GC</a> <br><ul><li>  <a href="https://habr.com/ru/post/118696/">Disable object in heap from GC</a> </li></ul></li></ul><br><a name="heap"></a><h4>  Heap </h4><br>  In order for C to correctly create and destroy complex structures with which the code will work on Limbo, it is necessary to imagine how they are stored in memory, i.e.  how the heap is organized in Inferno.  All the functions listed below for working with heap are described in <code>libinterp/heap.c</code> , and the structures in <code>include/interp.h</code> . <br><a name="habracut"></a><br><a name="heap-mem"></a><h5>  What is in my memory ... </h5><br>  In order to simply allocate <code>n</code> bytes in heap, and then free them, you need to do the following: <br><pre> <code class="cpp hljs">Heap *h; uchar *data; h = nheap(<span class="hljs-number"><span class="hljs-number">256</span></span>); data = H2D(uchar*, h); ... <span class="hljs-comment"><span class="hljs-comment">//   data  256  destroy(data);</span></span></code> </pre><br>  Physically, the memory will be allocated 256 + the size of the heap header bytes, and at the beginning will be the header, and then the user data.  The header is described in the <code>Heap</code> structure, plus there are two macros for converting a pointer to a heap header into a pointer to data (moreover, for convenience, immediately with a type <code>H2D()</code> ) <code>H2D()</code> and vice versa <code>D2H()</code> .  The <code>destroy()</code> function uses <code>D2H()</code> to get a heap header instead of a pointer to the beginning of user data of unknown length and find out how many bytes need to be freed. <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Heap</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> color; <span class="hljs-comment"><span class="hljs-comment">/* Allocation color */</span></span> ulong ref; Type* t; ulong hprof; <span class="hljs-comment"><span class="hljs-comment">/* heap profiling */</span></span> }; <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> H2D(t, x) ((t)(((uchar*)(x))+sizeof(Heap))) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> D2H(x) ((Heap*)(((uchar*)(x))-sizeof(Heap)))</span></span></code> </pre><br><a name="heap-junk"></a><h5>  Something about garbage collection </h5><br>  What is in the header heap?  I won't tell you anything about <code>hprof</code> , I didn't understand heap profiling, but the rest of the fields are extremely important. <br><br>  First, a few words about the garbage collector in Inferno.  Two strategies are used simultaneously: a simple reference counter of which is sufficient for most structures, plus a variation on the theme of <a href="http://en.wikipedia.org/wiki/Garbage_collection_(computer_science)">tri-color marking</a> to select structures with cyclical references.  Accordingly, <code>ref</code> is the reference counter, and <code>color</code> used for tri-color marking.  When <code>nheap()</code> or another similar function allocates a new object to the heap, the <code>ref</code> value is set to 1 in its heap header. When <code>destroy()</code> is called, it decreases the <code>ref</code> value by 1, and only if <code>ref</code> became equal to 0, it frees up the object occupied memory. <br><br>  Accordingly, as long as you store the value returned by <code>nheap()</code> (or any other similar function) in one variable, you have exactly one reference to this object, and its <code>ref</code> is 1. As soon as you copy this reference to another variable, you need to increase the reference count <b>plus</b> notify the tri-color algorithm.  It is done this way ( <code>Setmark()</code> is also a macro, but in order to deal with it you need to understand the work of the tri-color algorithm, which is not required from you right now): <br><pre> <code class="cpp hljs">Heap *h; uchar *data, *data2; data = H2D(uchar*, nheap(<span class="hljs-number"><span class="hljs-number">256</span></span>)); data2 = data; h = D2H(data2); h-&gt;ref++; Setmark(h); <span class="hljs-comment"><span class="hljs-comment">//   h-&gt;color destroy(data); //       destroy(data2); //     </span></span></code> </pre><br>  Of course, if you selected an object in heap, and then returned it to the user by writing to <code>*f-&gt;ret</code> , then nothing else needs to be done with <code>ref</code> and <code>color</code> - the link will be removed from the local variables of your function when the function ends, and only one will be left again the reference to this object is for the user, in the variable where he saved the value returned by your function, i.e.  There was a move, not a copy of the link. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      There is one implicit nuance associated with moving links.  In the previous example with the return value, a new, just created link is moved, and nothing extra is required there.  But if you moved a link from one already existing variable / structure to another, also an existing one, then you need to notify the tri-color algorithm by calling <code>Setmark()</code> (this is also related to the peculiarities of this algorithm and will be described below): <br><pre> <code class="cpp hljs">dst-&gt;data = src-&gt;data; src-&gt;data = H; Setmark(D2H(dst-&gt;data));</code> </pre><br><a name="heap-obj"></a><h5>  Types of objects in heap </h5><br>  The example with <code>nheap()</code> described above is almost never used in real code, since  Limbo does not have this data type: n bytes.  Therefore, neither get from Limbo nor return to Limbo the object selected through <code>nheap()</code> will fail.  And to allocate memory for the internal needs of your C-module, as a rule, there are usually enough <code>malloc()</code> with <code>free()</code> . <br><br>  All objects in the heap that Limbo can operate on must be of some type described by the <code>Type</code> structure.  This allows you to solve the problem of automatic detection of all links within any object - what needs to be done when: <br><ul><li>  memory allocation for this object (to set all the pointers inside it to <code>H</code> aka <code>nil</code> ); </li><li>  executing <code>destroy()</code> (so that when deleting an object from memory with it, delete or reduce the <code>ref</code> of all objects it referred to); </li><li>  the work of the garbage collector (to take into account when crawling all the objects in the memory, the objects to which are located inside other complex objects). </li></ul><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Type</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ref; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> (*<span class="hljs-built_in"><span class="hljs-built_in">free</span></span>)(Heap*, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> (*mark)(Type*, <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>*); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> size; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> np; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* destroy; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* initialize; uchar <span class="hljs-built_in"><span class="hljs-built_in">map</span></span>[STRUCTALIGN]; };</code> </pre><br>  For standard types (any adt / tuple / structure that contains either non-reference fields or fields with links to regular heap objects that can be freed via <code>destroy()</code> - like <code>String*</code> and <code>Array*</code> ), the <code>np</code> and <code>map</code> fields are used.  The <code>map</code> field contains a bit mask, one bit each (starting from the high bit of the first byte) for every 4 bytes of adt / tuple / structure, where the set bit means that the corresponding 4 bytes are a pointer to a heap object.  (The <code>np</code> field contains the length of the <code>map</code> field in bytes.) <br><br>  Some data types use memory in an unusual way.  Typical examples are <code>String</code> and <code>Array</code> - the first contains inside the <code>char*</code> field, which must be freed via <code>free()</code> ;  the second can be a slice and contain within itself a link to the "parent" array.  The <code>Type</code> structure allows you to specify your own non-standard handler functions for these types, which will be called when allocating / initializing memory from <code>destroy()</code> and from the garbage collector: <code>free</code> , <code>mark</code> , <code>destroy</code> and <code>initialize</code> . <br><br>  The <code>size</code> field contains the size of a structure of this type (since we still have to specify its type when allocating memory for this structure, preserving the size of the structure inside the type allows us to limit ourselves to specifying only the type, without adding the size of the structure to it each time). <br><br>  The <code>ref</code> field is used to store the current number of objects in this type of heap.  The fact is that the list of types is not limited to standard <code>string</code> , <code>array of</code> , etc.  - any tuple described on the fly is a separate type for which you need your description by the <code>Type</code> structure.  It turns out that some types are created by Limbo on the fly, stored in the same heap, and must be removed from memory as soon as all objects of this type are deleted.  Therefore, when creating a new object of a certain type, you need to increase the <code>ref</code> this type, and when you delete this object, <code>destroy()</code> will automatically reduce the <code>ref</code> also for the type of this object (and remove it from memory if <code>ref</code> equals 0). <br><br>  <code>Type</code> values ‚Äã‚Äãfor standard types are declared statically, with <code>ref</code> set to 1 (so their <code>ref</code> will never be less than 1 and they will never be removed from memory), and are described at the beginning of <code>libinterp/head.c</code> : <br><pre> <code class="cpp hljs">Type Tbyte = { <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span> }; Type Tword = { <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(WORD) }; Type Tptr = { <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, markheap, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(WORD*), <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, { <span class="hljs-number"><span class="hljs-number">0x80</span></span> } }; Type Tarray = { <span class="hljs-number"><span class="hljs-number">1</span></span>, freearray, markarray, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(Array) }; Type Tstring = { <span class="hljs-number"><span class="hljs-number">1</span></span>, freestring, noptrs, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(String) }; ...</code> </pre><br><a name="heap-complex"></a><h5>  We create our complex structures in heap </h5><br>  Types for your own adt / tuples / structures in some cases will help determine <code>libinterp/runt.h</code> (by calculating the size of your structure for <code>Type.size</code> and the bit mask of pointer fields for <code>Type.map</code> and <code>Type.np</code> ), in others you will have to define them independently (for example, to create and return a tuple from the C function).  They are usually created during initialization of your module (returning to the example with the module Example) using the <code>dtype()</code> function.  And memory is allocated and initialized for them through <code>heap(&amp;Tsometype)</code> , and not <code>nheap(n_bytes)</code> . <br><ul><li> <code>module/example.m</code> <br> <pre> <code class="bash hljs">Example: module { ... MyData: adt{ i: int; s: string; new: fn(i: int): ref MyData; }; };</code> </pre></li><li>  <code>libinterp/runt.h</code> (automatically generated from <code>module/example.m</code> ) <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Example_MyData</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Example_MyData</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Example_MyData</span></span></span><span class="hljs-class"> {</span></span> WORD i; String* s; }; <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> Example_MyData_size 8 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> Example_MyData_map {0x40,} void MyData_new(void*); typedef struct F_MyData_new F_MyData_new; struct F_MyData_new { WORD regs[NREG-1]; Example_MyData** ret; uchar temps[12]; WORD i; };</span></span></code> </pre></li></ul><br>  Example_MyData_map 0x40 means 010000 ... bit mask, i.e.  the first 4 bytes of our structure is not a pointer (WORD) but the second is a pointer (String *). <br><ul><li> <code>libinterp/example.c</code> <br> <pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Type* TMyData; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> uchar MyData_map[] = Example_MyData_map; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">examplemodinit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ ... TMyData = dtype(freeheap, Example_MyData_size, MyData_map, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(MyData_map)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyData_new</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *fp)</span></span></span><span class="hljs-function"> </span></span>{ F_MyData_new *f; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; Example_MyData* mydata; f = fp; i = f-&gt;i; mydata = H2D(Example_MyData*, heap(TMyData)); mydata-&gt;i = i; destroy(*f-&gt;ret); *f-&gt;ret = mydata; }</code> </pre></li><li> <code>testexample.b</code> <br> <pre> <code class="bash hljs">... example: Example; MyData: import example; ... init(nil: ref Draw-&gt;Context, nil: list of string) { ... mydata := MyData.new(5); sys-&gt;<span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"i = %d, s = %q\n"</span></span>, mydata.i, mydata.s); } ; testexample ... i = 5, s = <span class="hljs-string"><span class="hljs-string">''</span></span> ;</code> </pre></li></ul><br><a name="array"></a><h4>  Array </h4><br>  Consider working with arrays.  In memory, the array is located as follows: heap header, array header, array elements.  Accordingly, to allocate memory for an array, you must know the size and number of its elements.  To initialize these elements (all of a sudden there are links that need to be set in <code>H</code> ) and later to correctly remove from memory, you need to know the type of these elements (then there is no need to specify the size, it is already specified inside the type). <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Array</span></span></span><span class="hljs-class"> {</span></span> WORD len; Type* t; Array* root; uchar* data; };</code> </pre><br>  Here <code>len</code> is the size of the array, <code>t</code> is the type of its elements, <code>root</code> pointer to the parent array (if this array is its slice), and <code>data</code> pointer to the first element of the array (this is the next byte after the <code>Array</code> structure if the array is independent or the address of the first element of our slice is among the elements parent array). <br><br>  If we do not create a slice of another array, then we need to allocate more memory than the <code>Array</code> structure itself (and, accordingly, as indicated in <code>Tarray.size</code> ).  Therefore, we will not be able to allocate memory for the array through the <code>heap()</code> function used previously.  Fortunately, for this there is a convenient <code>heaparray()</code> function.  An example of selecting <code>array[16] of byte</code> : <br><pre> <code class="cpp hljs">Array *arr; arr = H2D(Array*, heaparray(&amp;Tbyte, <span class="hljs-number"><span class="hljs-number">16</span></span>));</code> </pre><br>  Here is an example of a function that returns an array slice: <a href="">http://code.google.com/p/inferno-cjson/source/browse/libinterp/cjson.c#59</a> . <br><br><a name="refadt"></a><h5>  adt and ref adt </h5><br>  There is an implicit difference between Limbo and C in how adt and ref adt are handled.  If at the Limbo level, working with them looks (almost) the same: <br><pre> <code class="bash hljs">a := array[10] of MyData; b := array[10] of ref MyData; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(i := 0; i &lt; len b; i++) b[i] = ref MyData; a[0].i = b[0].i;</code> </pre><br>  then at the C level these are completely different arrays: <br><pre> <code class="cpp hljs">Array *a, *b; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; Example_MyData* adata; Example_MyData** bdata; a = H2D(Array*, heaparray(TMyData, <span class="hljs-number"><span class="hljs-number">10</span></span>)); adata = (Example_MyData*)a-&gt;data; b = H2D(Array*, heaparray(&amp;Tptr, <span class="hljs-number"><span class="hljs-number">10</span></span>)); bdata = (Example_MyData**)b-&gt;data; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; b-&gt;len; i++) bdata[i] = H2D(Example_MyData*, heap(TMyData)); adata[<span class="hljs-number"><span class="hljs-number">0</span></span>].i = bdata[<span class="hljs-number"><span class="hljs-number">0</span></span>]-&gt;i;</code> </pre><br><a name="gc"></a><h4>  GC </h4><br>  A general description of the tri-color algorithm can be found in <a href="http://en.wikipedia.org/wiki/Garbage_collection_(computer_science)">Wikipedia</a> .  Inferno, these three ‚Äúcolors‚Äù are called <code>mutator</code> , <code>marker</code> and <code>sweeper</code> . <br><br>  New objects set <code>h-&gt;color=mutator</code> . <br><br>  After each full gc cycle, the values ‚Äã‚Äãof <code>mutator</code> , <code>marker</code> and <code>sweeper</code> variables change in a circle, thus changing the values ‚Äã‚Äãof <code>h-&gt;color</code> all objects in heap: <br><pre> <code class="bash hljs">mutator -&gt; marker marker -&gt; sweeper sweeper -&gt; mutator //    ..  sweeper  </code> </pre><br>  If during operation gc <code>h-&gt;color==sweeper</code> , then <code>h</code> is removed from memory. <br><br>  So, what is <code>Setmark()</code> and why it is needed. <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> Setmark(h) </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta">((h)-&gt;color!=mutator) { (h)-&gt;color = propagator; nprop=1; }</span></span></code> </pre><br>  Further, since the garbage collector can work for a very long time, and everything else is stopped at this moment, in Inferno the garbage collector works in small pieces - bypassing some of the objects it pauses, letting other code work, and then continues from the place where it stopped last time .  But for this algorithm, it is required to check all objects in memory in one pass, atomically, otherwise it is impossible to unambiguously identify unused objects.  Therefore, a mechanism is implemented in the Inferno garbage collector that allows you to determine if its potentially interesting objects changed <b>between</b> GC launches. <br><br>  This mechanism is the call to <code>Setmark()</code> .  The <code>nprop</code> flag <code>nprop</code> it, if necessary, indicates to the GC that after the current crawl cycle of objects in the heap cannot be deleted, unused objects must be repeated from the beginning. <br><br>  The value <code>h-&gt;color==propagator</code> means that the next time gc is run, it is necessary to view this object.  In the process of viewing the object, <code>h-&gt;color</code> set in <code>mutator</code> .  (The same <code>propagator</code> value is set to ‚Äúroot‚Äù objects at the beginning of a new GC cycle, but in this context it is not important.) <br><br><a name="gc-detach"></a><h5>  Disable object in heap from GC </h5><br>  Since the GC removes from memory all objects that are not referenced by ‚Äúroot‚Äù objects (which probably contain Dis working threads, loaded modules, etc.) without paying attention to the value of their <code>ref</code> , the question arises: how to store a link to the heap object outside Dis threads, for example in the global variables of your C-module, so that it does not kill the GC?  To do this, you must inform the GC that it should not monitor this heap object using <code>poolimmutable()</code> (to connect an object back to the GC there is a <code>poolmutable()</code> , all these functions are in <code>emu/port/alloc.c</code> ): <br><ul><li> <code>libinterp/example.c</code> <br> <pre> <code class="cpp hljs">... <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Array* EmptyArray; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">examplemodinit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ ... EmptyArray = H2D(Array*, heaparray(&amp;Tbyte, <span class="hljs-number"><span class="hljs-number">0</span></span>)); poolimmutable(D2H(EmptyArray)); }</code> </pre></li></ul></div><p>Source: <a href="https://habr.com/ru/post/118696/">https://habr.com/ru/post/118696/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../118689/index.html">Tethering applications are blocked in the Android Market by the largest US carriers</a></li>
<li><a href="../118690/index.html">Atom gates</a></li>
<li><a href="../118691/index.html">And you put quotes in the attributes of tags in the HTML layout (HTML4, HTML5)</a></li>
<li><a href="../118692/index.html">Bin Laden's Death and Twitter Record</a></li>
<li><a href="../118695/index.html">Nintendo lowers Wii price to $ 149</a></li>
<li><a href="../118697/index.html">Yahoo never recovered missing mail</a></li>
<li><a href="../118699/index.html">Sony turns off the service Sony Online Entertainment</a></li>
<li><a href="../118700/index.html">Have you ever broken the GPL?</a></li>
<li><a href="../118701/index.html">Amazon plans to launch its tablet in summer 2011</a></li>
<li><a href="../118702/index.html">Vertical Scaling in Java Cloud</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>