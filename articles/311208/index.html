<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Microservices: please do not need</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Illustration @alvaro_sanchez 


 For a while, everyone went crazy over microservices. It was impossible to open your favorite news aggregator and not ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Microservices: please do not need</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/files/717/e67/4f7/717e674f7a714fe4a0e00eee50a55e9a.jpg"><br>  <em>Illustration <a href="https://twitter.com/alvaro_sanchez">@alvaro_sanchez</a></em> </p><br><p>  For a while, everyone went crazy over microservices.  It was impossible to open your favorite news aggregator and not see that some unknown company until now talks about saving its engineering department with the help of microservices.  You may even have worked for the company yourself, which captured the excitement of tiny, magical small services that would solve all the problems of a large, neglected, full law code base. </p><br><p>  Naturally, in reality everything turned out quite the opposite.  When you look back at what happened, the vision is closer to 100% than when you look with hope into the future. </p><br><p>  I want to talk about some important misconceptions and the pitfalls of the movement for microservices from the point of view of a person who worked for a company that was convinced of the idea of ‚Äã‚Äãthe healing properties of microservices.  I do not want the conclusion of this article for you to be "microservices == bad", but ideally I would like you to think about the problems when you decide whether microservice architecture is right for you. <a name="habracut"></a></p><br><h2 id="chto-takoe-mikroservis-voobsche">  What is "microservice" in general? </h2><br><p>  There is no perfect definition, but people who are promoting this area have been able to describe a good set of requirements for the system, according to which it could be attributed to the ‚Äúmicroservice‚Äù architecture. </p><br><p>  You can say it is not a monolith.  In practice, this means that microservice works with only a small, as limited as possible task area.  It performs a minimum of functions to achieve a specific goal in your stack.  Here‚Äôs a more specific example: let's say the bank has a ‚ÄúLogin Service‚Äù, and you certainly don‚Äôt want this service to have access to the financial transactions of your customers.  You will take this area to some ‚ÄúTransaction Service‚Äù (bear in mind - it‚Äôs very difficult to give names). </p><br><p>  In addition, people often assume that microservices must communicate with other services remotely.  Since they are separate processes, and often run far from others, usually such processes communicate with each other over the network using REST or some other RPC protocol. </p><br><p>  So far everything seems simple enough - you just need to wrap small pieces of the system in some REST API, and let everyone communicate with each other over the network.  In my experience, there are 5 "truths" that people believe in, and which are not always true: </p><br><ol><li>  The code will be cleaner </li><li>  It is easier to write modules that solve one problem. </li><li>  It works faster than monolith </li><li>  Engineers easier if you do not need to work with a single code base </li><li>  This is the easiest way to provide automatic scaling, and here is Docker somewhere involved. </li></ol><br><h2 id="zabluzhdenie-1-bolee-chistyy-kod">  Misconception # 1: Cleaner Code </h2><br><p>  <em>‚ÄúYou don‚Äôt need to add a network constraint to justify writing better code.‚Äù</em> </p><br><p>  The truth of life is that neither microservices nor any other approach when modeling the technical stack is a requirement for writing cleaner and more supported code.  Of course, once the moving parts are smaller, the ability to write lazy and ill-considered code is reduced.  But it‚Äôs like saying that thefts can be defeated by removing goods from shop windows.  You did not solve the problem, you just removed a lot of features. </p><br><p>  A popular approach is to build architecture in such a way that logical "services" own parts of the domain.  This is similar to the concept of microservices, because the dependencies that control the system will be explicit.  And business logic will not fit into different angles.  In addition, this approach does not entail an excessive use of the network and possible problems associated with this. </p><br><p>  Another advantage of this approach is that it resembles Service Oriented Architecture, built on the basis of microservices: if you decide to go to microservices, then most of the work has already been done, and you probably already have a good understanding of the subject areas for proper separation of its parts.  True SOA begins with a code, and continues over time at the level of the physical topology of the stack. </p><br><h2 id="zabluzhdenie-2-eto-legche">  Misconception # 2: It's lighter </h2><br><p>  <em>"Distributed transactions are never easier."</em> </p><br><p>  It may seem different from the outside, but most of the subject areas (especially in new companies that need to create prototypes, make pivots and generally redefine the area itself many times) cannot be divided into neat, clear boxes.  Often, an arbitrary part of the system needs to get data about another part in order to work correctly.  Everything becomes even more complicated when she delegates the operation of writing data to another part, outside of her subject area.  When you have gone beyond your zone of influence, and you need to use other parts to store or change data, then you are in a country of <em>distributed transactions</em> . </p><br><p>  When several remote services are involved in a single request, the complexity greatly increases.  Is it possible to refer to them in parallel or need to be addressed sequentially?  Are you aware of all possible errors in advance (at the application level <em>and</em> at the network level) that can occur at <em>any</em> time, at any part of the chain, and what will these errors mean for the request itself?  Often, each of the distributed transactions requires its own approach to error handling.  And to understand all the mistakes and understand how to solve them is a very, very big job. </p><br><h2 id="zabluzhdenie-3-eto-bystree">  Misconception # 3: It's Faster </h2><br><p>  <em>"You can greatly improve the performance of the monolith if you add a little discipline"</em> </p><br><p>  This error is difficult to refute, because in reality we can often speed up a separate system if we reduce the number of tasks or the number of dependencies that are loaded, and so on. </p><br><p>  But overall, this is not systemic evidence.  I have no doubt that if you switched to microservices, the code isolated in these services could be accelerated, but you should not forget about the delays caused by network requests.  A network is never as fast as internal communication, it is sometimes ‚Äúfast enough‚Äù. </p><br><p>  In addition, many stories about increasing productivity are in fact related to the benefits of a new language or a whole technological stack, and not just microservice architecture.  If you rewrite the old Ruby on Rails, Django, or NodeJS application in a new language like Scala and Go (two popular choices for the microservice architecture), then the performance will improve, if only because of improvements in the performance of new technologies in general.  But these languages ‚Äã‚Äãdon't really matter if you call their processes "micro."  They work faster because of simple factors like compilation. </p><br><p>  Also, in most applications in startups, the net performance of the processor and memory is almost never a problem.  Usually the problem is in I / O, and additional network calls only increase I / O. </p><br><h2 id="zabluzhdenie-4-luchshe-dlya-inzhenerov">  Misconception # 4: Better for Engineers </h2><br><p>  <em>When many engineers work in isolated code bases, then the syndrome "is not my problem."</em> </p><br><p>  It may seem that when small teams work on small pieces of the puzzle, everything will be easier.  But in the end, this configuration can lead to problems. </p><br><p>  The biggest problem is the need to run an ever-growing number of services for any, even the smallest change.  That is, you need to invest time and effort to build and maintain a system where every engineer can run everything locally.  Such things as Docker can simplify this moment, but someone will still have to maintain the configuration throughout the life of the project. </p><br><p>  In addition, it complicates the writing of tests.  To write a normal set of integration tests, you need to understand all the services associated with a particular operation, take into account all possible errors, and so on.  It will take more time to understand the system than to develop the system.  And although I will never tell an engineer that to understand a system is a waste of time, I still want to warn him against adding premature complexity. </p><br><p>  And finally, this configuration creates social problems.  Bugs can live simultaneously in several services and require changes at the level of several teams.  They need to synchronize and coordinate their efforts.  In addition, people can lose their sense of responsibility and try to push as many problems as possible to another team.  When engineers work together on the same code base, the understanding of the system grows simultaneously with the understanding of each other.  They are more likely to work on solving problems together, rather than being the kings and queens of small isolated principalities. </p><br><h2 id="zabluzhdenie-5-luchshe-masshtabiruetsya">  Misconception # 5: Scale Better </h2><br><p>  <em>"Microservice can be scaled in breadth as well as a monolith"</em> </p><br><p>  Packing services into separate units and scaling them with, say, Docker is a good approach for horizontal scaling, without a doubt. </p><br><p>  However, this can be done not only with microservices.  The approach works in the case of monolithic applications.  You can make logical monolith clusters that handle portions of traffic.  For example, incoming API requests, front-end control panels and background tasks can be in the same code base, but it is not necessary on each machine to process all three types of requests. </p><br><p>  The advantage here is the same as in the case of microservices: individual clusters can be configured depending on the load, and they can also be scaled individually in response to traffic spikes.  Microservice architecture from the very beginning pushes to such an approach, but nothing prevents you from applying the same method for scaling a monolithic stack. </p><br><h2 id="kogda-ispolzovat-mikroservisy">  When to use microservices </h2><br><p>  <em>‚ÄúWhen you, as an engineering organization, are ready,‚Äù</em> </p><br><p>  I want to end this article with a discussion of when the right time will come to microservices (or, if you have already begun, how to understand if this was the right moment). </p><br><p>  The most important thing on the way to a good, working microservice architecture is a simple understanding of your subject area.  If you do not understand it, or are still trying to understand, then microservices will bring more problems than solutions.  But if you already have a deep understanding, then you know the limits and dependencies, and the microservice approach can be the right step. </p><br><p>  Another important point is your work environment, especially how it will look in the context of distributed transactions.  If you are familiar with the paths of each category of queries in the system, and you understand where, how and why these paths may break, then you will be able to build a distributed model for processing queries. </p><br><p>  In addition to understanding the environment, there is a topic of <em>monitoring the</em> environment.  It goes beyond the discussion of microservice vs. monolith, but monitoring should be at the heart of engineering efforts.  You will likely need a lot of information about different parts of the system to understand why one of the parts behaves badly or even generates errors.  If you have a well-established system of monitoring components of the system, then you will be able to understand the behavior of the system during horizontal scaling. </p><br><p>  And finally, if you actually demonstrate the benefits of your engineering organization and the business as a whole, then moving to microservices will help grow, scale, and make money.  Of course, building interesting systems and trying new things is great, but in the end any company has the most important indicator.  If you have to postpone the release of a new feature, which will bring money to the company, because of a post on some blog about "monoliths is bad," then you will have to justify this decision.  Sometimes it's worth it.  Sometimes not.  Knowing when to insist and take time will help your reputation in the long run. </p><br><h2 id="vyvody">  findings </h2><br><p>  I hope, now you have a set of conditions and questions that need to be resolved if someone offers a microservice approach.  As I said at the beginning, my goal was not to prove that "microservices are bad."  But jumping onto microservices without thinking about all the possibilities for details and questions is asking for problems in the future. </p><br><p>  If I ask for my advice, I would look in the direction of "internal" services based on clean, well-defined modules in the code.  They can already be brought to these services in the future, if the need arises.  This approach is not the only possible one, and certainly not a panacea for bad code.  But it will help you move forward faster than if you dig into microservices before the right one. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/311208/">https://habr.com/ru/post/311208/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../311198/index.html">learnopengl. Lesson 1.2 - Creating a window</a></li>
<li><a href="../311200/index.html">Format preserving encryption or how to correctly encrypt credit card numbers</a></li>
<li><a href="../311202/index.html">The best vacancies at My Circle for the week, September 12-18</a></li>
<li><a href="../311204/index.html">Mobile user behavior scenarios have pushed Google AdWords to introduce end-to-end remarketing</a></li>
<li><a href="../311206/index.html">Launching a payment aggregator or e-wallet: features of Russian legislation and success secrets</a></li>
<li><a href="../311210/index.html">Complex Data Visualization Algorithm</a></li>
<li><a href="../311212/index.html">Installation and optimal configuration of Nginx + LAMP (CentOS 7)</a></li>
<li><a href="../311214/index.html">When exceptions are needed</a></li>
<li><a href="../311218/index.html">How do we test the server code without mobile clients?</a></li>
<li><a href="../311220/index.html">Programming & Music: we understand and write VSTi synthesizer on C # WPF. Part 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>