<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Really transparent WCF usage</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Motivation 
 For the desktop world, wcf remains the most common way to organize client-server interaction in .net for both local and global networks. ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Really transparent WCF usage</h1><div class="post__text post__text-html js-mediator-article"><h4>  Motivation </h4><br>  For the desktop world, wcf remains the most common way to organize client-server interaction in .net for both local and global networks.  It is flexible to configure, easy to use and transparent. <br><br>  At least it should be.  In practice, adding a new service is a routine.  You need to remember to register the configuration on the server, do the same on the client, you need to write or generate a proxy class.  Maintain configs uncomfortable.  If the service has changed, then you need to make changes to the proxy class.  And do not forget about registration in the IoC container.  And adding new hosts for new services.  And I want a simple asynchrony.  Separately, everything is simple, but even for the article I added this list three times already, and I am not sure that I did not miss something. <br><br>  Time to automate.  The simplest scenario from creating a solution to calling a wcf service looks like this: <br><ol><li>  Install-Package <a href="https://www.nuget.org/packages/Rikrop.Core.Wcf.Unity/">Rikrop.Core.Wcf.Unity</a> </li><li>  We write ServiceContract and their implementation </li><li>  On the server and the client, we add one registration line to the IoC (no need to edit the configs) </li><li>  We lift hosts from two lines <br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> assembly = Assembly.GetExecutingAssembly(); _serviceHostManager.StartServices(assembly);</code> </pre> </li><li>  On the client, resolve the IServiceExecutor &lt;TService&gt;.  This wrapper serves to call the service methods and hides the work with the channel. </li><li>  Can use <pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> articles = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> _myServiceExecutor.Execute(service =&gt; service.GetArticles());</code> </pre></li></ol><br><a name="habracut"></a><br><h4>  Quick start </h4><br>  Create a client-server application.  Clients send the server the index of the number from the Fibonacci sequence, the server returns the number from the sequence with the specified index.  <i>Logging and error handling is removed from the code in the article, but in the code on <a href="https://github.com/Vadimyan/Rikrop.WcfExample">github</a> I give a more complete example to illustrate the holistic approach.</i> <br>  Project structure close to reality: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/files/d36/990/efb/d36990efb8754fff968fed27238ae44c.PNG"><br><br>  Server.Contracts contains the interfaces of wcf-services, Server - their implementation, as well as the implementation of the hoster - a class that will raise the wcf-services.  BL - server logic.  ConsoleServiceHost hosts services in the domain of the console application.  Client.Presentaion contains the corresponding client layer.  In our example, there is only a command to call the service and process the result.  Client is a console application that uses the previous build to handle user input. <br><br>  Actually, nuget packages need to be installed as follows: <br><ul><li>  Rikrop.Core.Wcf.Unity contains helpers for registering the infrastructure necessary for wcf operation in the IoC container.  This is a set of ready-made solutions and extensions for quick setup of all aspects of interaction.  The package should be added to projects where there will be server and client registrations in the IoC container.  We have this RikropWcfExample.Server and RikropWcfExample.Client. </li><li>  Rikrop.Core.Wcf contains the main classes for working with wcf, channel management, sessions, authorization, hosting wcf-services.  We‚Äôll add it to RikropWcfExample.Server, there will be a hoster, and RikropWcfExample.Client.Presentation *, where the wcf-service call will come from. </li></ul><br>  In RikropWcfExample.Server.Contracts add the description of the <a href="">wcf-service</a> : <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.ServiceModel; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Threading.Tasks; <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">RikropWcfExample.Server.Contracts</span></span> { [ServiceContract] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">ICalculatorService</span></span> { [OperationContract] <span class="hljs-function"><span class="hljs-function">Task&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">ulong</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetFibonacciNumber</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n</span></span></span><span class="hljs-function">)</span></span>; } }</code> </pre><br>  The implementation in <a href="">CalculatorService.cs</a> will transmit the request and return the result from the business logic layer: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> RikropWcfExample.Server.BL; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> RikropWcfExample.Server.Contracts; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Threading.Tasks; <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">RikropWcfExample.Server</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">CalculatorService</span></span> : <span class="hljs-title"><span class="hljs-title">ICalculatorService</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> FibonacciCalculator _fibonacciCalculator; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CalculatorService</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">FibonacciCalculator.ICtor fibonacciCalculatorCtor</span></span></span><span class="hljs-function">)</span></span> { _fibonacciCalculator = fibonacciCalculatorCtor.Create(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">ulong</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetFibonacciNumber</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> _fibonacciCalculator.Calculate(n); } } }</code> </pre><br>  While you can see one feature - wcf-service uses async / await to describe asynchrony.  For the rest, there are no specific constructions. <br><br>  We now turn to registration.  The simplest syntax for the server indicates the type of binding (NetTcp) a list of behaviors that should be added to the services: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> IUnityContainer </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RegisterWcfHosting</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> IUnityContainer container, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> serviceIp, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> servicePort</span></span></span><span class="hljs-function">)</span></span> { container .RegisterServerWcf( o =&gt; o.RegisterServiceConnection(reg =&gt; reg.NetTcp(serviceIp, servicePort)) .RegisterServiceHostFactory(reg =&gt; reg.WithBehaviors().AddDependencyInjectionBehavior()) ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> container; }</code> </pre><br>  The client specifies the type of service wrapper for services (ServiceExecutor), the type of wrapper over the binding (Standart assumes NetTcp) and, in fact, the server address: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> IUnityContainer </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RegisterWcf</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> IUnityContainer container, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> serviceIp, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> servicePort</span></span></span><span class="hljs-function">)</span></span> { container .RegisterClientWcf(o =&gt; o.RegisterServiceExecutor(reg =&gt; reg.Standard() .WithExceptionConverters() .AddFaultToBusinessConverter()) .RegisterChannelWrapperFactory(reg =&gt; reg.Standard()) .RegisterServiceConnection(reg =&gt; reg.NetTcp(serviceIp, servicePort))); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> container; }</code> </pre><br>  Everything.  You do not need to register each service by interface, you do not need to create a proxy, you do not need to register wcf in the configuration - these registrations will allow you to immediately start working with services as if they are local calls. <br>  But first you need to kill them on the server.  The <a href="">Rikrop.Core.Wcf</a> library already includes the <a href="">ServiceHostManager</a> class, which does all the work on its own.  Register each service is not necessary: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Rikrop.Core.Wcf; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Reflection; <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">RikropWcfExample.Server</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">WcfHoster</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> ServiceHostManager _serviceHostManager; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WcfHoster</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ServiceHostManager serviceHostManager</span></span></span><span class="hljs-function">)</span></span> { _serviceHostManager = serviceHostManager; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Start</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> assembly = Assembly.GetExecutingAssembly(); _serviceHostManager.StartServices(assembly); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Stop</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { _serviceHostManager.StopServices(); } } }</code> </pre><br>  Start the <a href="">server</a> : <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> serverContainer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> UnityContainer()) { serverContainer.RegisterServerDependencies(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> service = serverContainer.Resolve&lt;WcfHoster&gt;(); service.Start(); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">" .    Enter."</span></span>); Console.ReadLine(); service.Stop(); } }</code> </pre><br>  Run the <a href="">client</a> : <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> container = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> UnityContainer()) { container.RegisterClientDependencies(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> calculateFibonacciCommandCtor = container.Resolve&lt;CalculateFibonacciCommand.ICtor&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> number; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.TryParse(GetUserInput(), <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> number)) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> command = calculateFibonacciCommandCtor.Create(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result = command.Execute(number); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"Fibonacci[{0}] = {1}"</span></span>, number, result); } } }</code> </pre><br>  Works: <br><br><img src="https://habrastorage.org/files/7dc/297/52b/7dc29752b09c4ed5abc345fdbb9271bb.PNG"><br><br><h4>  Comparison with the classic approach and extensibility </h4><br>  It may seem that the proposed solution requires quite a lot of infrastructure code and does not have any advantages over the usual use of wcf.  The easiest way to show the difference is the example of typical situations that arise when working on projects. <br><br><h5>  Adding a new method to an existing wcf-service or changing the signature of an existing method </h5><br><table><tbody><tr><th width="2000">  Rikrop.Core.Wcf (.Unity) </th><th width="2000">  Without using libraries </th></tr><tr><td><ul><li>  In ServiceContract add method definition. </li><li>  In the class of the wcf-service add implementation. </li></ul><br>  Now you can call a new method on the client. </td><td><ul><li>  In ServiceContract add method definition. </li><li>  In the class of the wcf-service add implementation. </li><li>  Generate a proxy class on the client or add a manual implementation of calling a new service on the client (sometimes both options if you do not want to directly use the proxy class. </li></ul><br>  Now you can call a new service on the client. </td></tr></tbody></table><br><h5>  Adding a new wcf service to an existing host </h5><br><table><tbody><tr><th width="2000">  Rikrop.Core.Wcf (.Unity) </th><th width="2000">  Without using libraries </th></tr><tr><td><ul><li>  Create a ServiceContract new service. </li><li>  Implement a service contract. </li></ul><br>  Now you can call a new service on the client. </td><td><ul><li>  Create a ServiceContract new service. </li><li>  Implement a service contract. </li><li>  Generate a proxy class on the client or add a manual implementation of calling a new service on the client (sometimes both options if you do not want to directly use the proxy class. </li><li>  Add wcf code to the host that initializes the ServiceHost for the new service. </li><li>  Register in the client IoC container the proxy class of the new service. </li><li>  Add service configuration on server and non-client. </li></ul><br>  Now you can call a new service on the client. </td></tr></tbody></table><br><h5>  Change settings of all wcf-services (for example, the type of binding) </h5><table><tbody><tr><th width="2000">  Rikrop.Core.Wcf (.Unity) </th><th width="2000">  Without using libraries </th></tr><tr><td><ul><li>  In server registration, change the line with the binding type *. </li><li>  In client registration, change the string with the type of binding type *. </li></ul><br>  * see public Result <a href="">Custom</a> &lt;TServiceConnection&gt; (LifetimeManager lifetimeManager = null, params InjectionMember [] injectionMembers) where TServiceConnection: IServiceConnection </td><td><ul><li>  In the server's app.config, change all entries in the &lt;bindings&gt; * block. </li><li>  In the client‚Äôs app.config, change all entries in the &lt;bindings&gt; block *. </li></ul><br>  * The amount of work is proportional to the number of wcf-services.  If there are 100, then we can only hope that the quick replacement of the file will work. </td></tr></tbody></table><br><h5>  Change settings of several wcf-services (for example, the type of binding) </h5><br><table><tbody><tr><th width="2000">  Rikrop.Core.Wcf (.Unity) </th><th width="2000">  Without using libraries </th></tr><tr><td><ul><li>  On the server, add registration for the new address and type of binding. </li><li>  In the client registration add a new registration for a different address and type of binding. </li></ul><br></td><td><ul><li>  In the server's app.config, change the entries in the &lt;bindings&gt; block for the desired wcf-services. </li><li>  In the client‚Äôs app.config, change the entries in the &lt;bindings&gt; block for the desired wcf services. </li></ul><br></td></tr></tbody></table><br>  It is worth saying a few words about the last two points.  With the proper organization of app.config, making changes to it is pretty easy.  This can be done without rebuilding the application.  In a real development, the structured wcf configuration comes across quite rarely, which is the reason for the iterative development.  A non-programmer also has to change the configuration infrequently if the initial settings meet the requirements.  At the same time, it is easy to make a typo that the compiler will not find. <br><br><h4>  Extensibility  Behavior for authorization and work with sessions </h4><br>  Expansion of functionality and behavior change occurs by adding Behavior during registration.  The most frequent use is the behavior responsible for transmitting session information in the wcf message header. <br>  To demonstrate the functionality, a separate <a href="https://github.com/Vadimyan/Rikrop.WcfExample/tree/AuthorizationExample">branch</a> was created with the expanded code of the previous example.  In the standard behavior setting, the developer is asked to select the authorization method - this is the OperationContract, which will be available to users without a session in the message header.  Calling the remaining methods will be possible only with a filled header. <br><br>  Registration on the server will look like this: <br><br><pre> <code class="cs hljs">container .RegisterType&lt;ISessionResolver&lt;Session&gt;, SessionResolver&lt;Session&gt;&gt;() .RegisterServerWcf( o =&gt; o.RegisterServiceConnection(reg =&gt; reg.NetTcp(serviceIp, servicePort)) .RegisterServiceHostFactory(reg =&gt; reg.WithBehaviors() .AddErrorHandlersBehavior(eReg =&gt; eReg.AddBusinessErrorHandler().AddLoggingErrorHandler(NLogger.CreateEventLogTarget())) .AddDependencyInjectionBehavior() .AddServiceAuthorizationBehavior(sReg =&gt; sReg.WithStandardAuthorizationManager() .WithStandardSessionHeaderInfo(<span class="hljs-string"><span class="hljs-string">"ExampleNamespace"</span></span>, <span class="hljs-string"><span class="hljs-string">"SessionId"</span></span>) .WithOperationContextSessionIdInitializer() .WithSessionAuthStrategy&lt;Session&gt;() .WithLoginMethod&lt;ILoginService&gt;(s =&gt; s.Login()) .WithOperationContextSessionIdResolver() .WithInMemorySessionRepository() .WithStandardSessionCopier()) ) );</code> </pre><br>  You can change the authorization method by adding your <a href="http://msdn.microsoft.com/ru-ru/library/system.servicemodel.serviceauthorizationmanager(v%3Dvs.110).aspx">System.ServiceModel.ServiceAuthorizationManager</a> implementation, change the session identifier initialization method, authorization verification method, session retrieval method from the request execution context, and how the sessions are stored and copied on the server.  In a generic case, the registration of AuthorizationBehavior might look like this: <br><br><pre> <code class="cs hljs">.AddServiceAuthorizationBehavior(sReg =&gt; sReg.WithCustomAuthorizationManager&lt;ServiceAuthorizationManagerImpl&gt;() .WithCustomSessionHeaderInfo&lt;ISessionHeaderInfoImpl&gt;() .WithCustomSessionIdInitializer&lt;ISessionIdInitializerImpl&gt;() .WithCustomAuthStrategy&lt;IAuthStrategyImpl&gt;() .WithLoginMethod&lt;ILoginService&gt;(s =&gt; s.Login()) .WithCustomSessionIdResolver&lt;ISessionIdResolverImpl&gt;() .WithCustomSessionRepository&lt;ISessionRepositoryImpl&lt;MySessionImpl&gt;&gt;() .WithCustomSessionCopier&lt;ISessionCopierImpl&lt;MySessionImpl&gt;&gt;())</code> </pre><br>  Client registration also changes: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> IUnityContainer </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RegisterWcf</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> IUnityContainer container, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> serviceIp, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> servicePort</span></span></span><span class="hljs-function">)</span></span> { container .RegisterType&lt;ClientSession&gt;(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ContainerControlledLifetimeManager()) .RegisterClientWcf(o =&gt; o .RegisterServiceExecutor(reg =&gt; reg.Standard() .WithExceptionConverters() .AddFaultToBusinessConverter()) .RegisterChannelWrapperFactory(reg =&gt; reg.Standard()) .RegisterServiceConnection(reg =&gt; reg .NetTcp(serviceIp, servicePort) .WithBehaviors() .AddSessionBehavior(sReg =&gt; sReg .WithStandardSessionHeaderInfo(<span class="hljs-string"><span class="hljs-string">"ExampleNamespace"</span></span>, <span class="hljs-string"><span class="hljs-string">"SessionId"</span></span>) .WithCustomSessionIdResolver&lt;ClientSession&gt;(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ContainerControlledLifetimeManager()) .WithStandardMessageInspectorFactory&lt;ILoginService&gt;(service =&gt; service.Login())))); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> container; }</code> </pre><br>  Result: <br><br><img src="https://habrastorage.org/files/f78/329/ebd/f78329ebdbb646fd9edff227ef74462d.PNG"><br><br><h5>  Work algorithm </h5><br><ol><li>  The client is authorized through the selected method in the <a href="">wcf-contract</a> .  If authentication is successful, the server creates a session, saves it in the repository and gives data about it to the client: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newSession = Session.Create(userId); _sessionRepository.Add(newSession); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SessionDto { SessionId = newSession.SessionId, Username = <span class="hljs-string"><span class="hljs-string">"ExampleUserName"</span></span> };</code> </pre></li><li>  <a href="">The client</a> receives the session data and saves it: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> clientSession = container.Resolve&lt;ClientSession&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sessionDto = Task.Run(<span class="hljs-keyword"><span class="hljs-keyword">async</span></span> () =&gt; <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> loginServiceExecutor.Execute(s =&gt; s.Login())).Result; clientSession.Session = sessionDto;</code> </pre></li><li>  The server has the ability to obtain information about the calling client: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">ulong</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetFibonacciNumber</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> session = _sessionResolver.GetSession(); _logger.LogInfo( <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.Format(<span class="hljs-string"><span class="hljs-string">"User with SessionId={0} and UserId={1} called CalculatorService.GetFibonacciNumber"</span></span>, session.SessionId, session.UserId)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> _fibonacciCalculator.Calculate(n); }</code> </pre></li><li>  The client has the opportunity <a href="">to receive data</a> received from the server during authorization: <br><br><pre> <code class="cs hljs">_logger.LogInfo(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.Format(<span class="hljs-string"><span class="hljs-string">"SessionId {0} with name {1} begin calculate Fibomacci"</span></span>, _clientSession.SessionId, _clientSession.Session.Username));</code> </pre></li></ol><br><h4>  What's inside </h4><br>  Most of the infrastructure provides the library System.ServiceModel.dll.  However, there are several solutions that need to be considered in more detail. <br><br>  The basis of the interaction between the client and the server is the implementation of the <a href="">IServiceExecutor</a> interface, located in the Rikrop.Core.Wcf library. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">IServiceExecutor</span></span>&lt;<span class="hljs-title"><span class="hljs-title">out</span></span> <span class="hljs-title"><span class="hljs-title">TService</span></span>&gt; { <span class="hljs-function"><span class="hljs-function">Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Execute</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Func&lt;TService, Task&gt; action</span></span></span><span class="hljs-function">)</span></span>; Task&lt;TResult&gt; Execute&lt;TResult&gt;(Func&lt;TService, Task&lt;TResult&gt;&gt; func); }</code> </pre><br>  In the <a href="">simplest case</a> , the channel is opened and the method is called in the context of this channel: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> Task&lt;TResult&gt; Execute&lt;TResult&gt;(Func&lt;TService, Task&lt;TResult&gt;&gt; func) { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> wrapper = _channelWrapperFactory.CreateWrapper()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> func(wrapper.Channel); } }</code> </pre><br>  More complex implementations can <a href="">convert errors</a> or additionally notify about the end of processing by changing the property.  These ideas are most widely used in WPF-implementations of the IServiceExecutor, where using ServiceExecutorFactory, you can create wrappers over a wcf-service, allowing you to use DataBinding to notify the UI of a lengthy operation, or display a popup with arbitrary information while waiting for a response from the server. <br>  For an easy implementation, the main role is played by the Fluent interface during registration and the standard library infrastructure implementations, which makes it even easy to figure out even the most complex structures from the first time using the studio jump: <br><br><img src="https://habrastorage.org/files/00c/7f7/688/00c7f7688a9a4ac091c329ba3d2c2acb.png"><br><br>  The article also indirectly mentions other libraries: <br><ul><li>  Implementation of <a href="">auto plants</a> : <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> IUnityContainer </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RegisterFactories</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> IUnityContainer container</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>[] { Assembly.GetExecutingAssembly(), <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> (FibonacciCalculator).Assembly } .SelectMany(assembly =&gt; assembly.DefinedTypes.Where(type =&gt; type.Name == <span class="hljs-string"><span class="hljs-string">"ICtor"</span></span>)) .Where(type =&gt; !container.IsRegistered(type)) .ForEach(container.RegisterFactory); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> container; }</code> </pre></li><li>  Wrappers over <a href="">loggers</a> : <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> IUnityContainer </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RegisterLogger</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> IUnityContainer container</span></span></span><span class="hljs-function">)</span></span> { container.RegisterType&lt;ILogger&gt;(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ContainerControlledLifetimeManager(), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InjectionFactory(f =&gt; NLogger.CreateConsoleTarget())); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> container; }</code> </pre></li></ul><br><h4>  Results </h4><br>  Once you have set up the infrastructure on a project, you can forget about the network nature of the interaction through the IServiceExexutor for a long time.  It is best to use a systematic approach and use the same framework for building desktop applications using the mvvm pattern, <a href="http://habrahabr.ru/post/243353/">interacting with the database</a> , logging and other typical tasks.  But even with the reluctance to use an unfamiliar and not always familiar framework, you can find an application to the ideas underlying it.  Component extensibility, strict typing during configuration, interaction transparency on all layers, minimization of the infrastructure code and time spent on maintaining the infrastructure are important things to keep in mind when writing a calculator and a multi-user Enterprise system.  You can download the library code and connect it to the solution by the project instead of using the library.  This will allow you to study the work under the debugger and make changes if necessary. <br><br><h4>  Bonus </h4><br>  There is nothing better than practice.  I learned that we had the experience of translating a fairly large project (~ 300.000 lines of code) somewhere between development and support for using Rikrop.Core.Wcf.  This is a rather interesting experience of tormenting with async / await in .net 4.0, customizing work with sessions, extracting settings from a config and translating them into a c # form.  If anyone is interested, you can describe a specific example of switching to this library without dragging out the entire framework. <br><br>  There is also a solution for wpf with informing the user via ui blocking or pop-up windows implemented via ServiceExecutorFactory.  This is a private example and it applies much more to wpf than wcf.  But it can give more information about the benefits of the library and the motivation to use. </div><p>Source: <a href="https://habr.com/ru/post/246961/">https://habr.com/ru/post/246961/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../246951/index.html">Playing with genetic algorithms</a></li>
<li><a href="../246953/index.html">Why does OpenVPN slow down?</a></li>
<li><a href="../246955/index.html">FLProg and penguins</a></li>
<li><a href="../246957/index.html">The digest of interesting materials from the world of web development and IT for the last week ‚Ññ140 (December 22 - 28, 2014)</a></li>
<li><a href="../246959/index.html">Understanding Flux, reactive architecture from facebook</a></li>
<li><a href="../246963/index.html">About the diagonal of the square</a></li>
<li><a href="../246965/index.html">Functional programming in Swift. Start</a></li>
<li><a href="../246967/index.html">Happy New Year!</a></li>
<li><a href="../246969/index.html">When technology outpaces needs: how did they think about IT development in 1985</a></li>
<li><a href="../246971/index.html">Dirty tricks with macros C ++</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>