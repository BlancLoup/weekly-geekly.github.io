<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>SpecFlow and alternative testing approach</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Testing with SpecFlow firmly entered my life, the list of necessary technologies for a "good project". Moreover, despite the fact that SpecFlow is foc...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>SpecFlow and alternative testing approach</h1><div class="post__text post__text-html js-mediator-article"><img align="right" src="https://habrastorage.org/getpro/habr/post_images/e5a/a53/74d/e5aa5374dabf352fe3e9ba84bde4eef6.png">  Testing with SpecFlow firmly entered my life, the list of necessary technologies for a "good project".  Moreover, despite the fact that SpecFlow is focused on behavior tests, I came to the conclusion that integration and even unit tests can take advantage of this approach.  Of course, people from BA and QA will no longer be involved in writing such tests, but only the developers themselves.  Of course, for small tests this introduces a considerable overhead.  But how much more pleasant to read the human description of the test, rather than the bare code. <br><a name="habracut"></a><br><br>  As an example, I will give the test, revised from the usual type of tests in MSTest to the test in SpecFlow <br><div class="spoiler">  <b class="spoiler_title">initial test</b> <div class="spoiler_text"><pre><code class="hljs pgsql">[TestMethod] <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">void</span></span> CreatePluralName_SucceedsOnSamples() { // setup var target = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> NameCreator(); var pluralSamples = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Dictionary</span></span>&lt;string, string&gt; { { "ballista", "ballistae" }, { "class", "classes"}, { "box", "boxes" }, { "byte", "bytes" }, { "bolt", "bolts" }, { "fish", "fishes" }, { "guy", "guys" }, { "ply", "plies" } }; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (var sample <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> pluralSamples) { // act var result = target.CreatePluralName(sample.Key); // verify <span class="hljs-keyword"><span class="hljs-keyword">Assert</span></span>.AreEqual(sample.<span class="hljs-keyword"><span class="hljs-keyword">Value</span></span>, result); } }</code> </pre> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">test in specflow</b> <div class="spoiler_text"><pre> <code class="hljs smalltalk"><span class="hljs-type"><span class="hljs-type">Feature</span></span>: <span class="hljs-type"><span class="hljs-type">PluralNameCreation</span></span> <span class="hljs-type"><span class="hljs-type">In</span></span> order to assign names to <span class="hljs-type"><span class="hljs-type">Collection</span></span> type of <span class="hljs-type"><span class="hljs-type">Navigation</span></span> <span class="hljs-type"><span class="hljs-type">Properties</span></span> <span class="hljs-type"><span class="hljs-type">I</span></span> want to convert a singular name to a plural name @<span class="hljs-type"><span class="hljs-type">PluralName</span></span> <span class="hljs-type"><span class="hljs-type">Scenario</span></span> <span class="hljs-type"><span class="hljs-type">Outline</span></span>: <span class="hljs-type"><span class="hljs-type">Create</span></span> a plural name <span class="hljs-type"><span class="hljs-type">Given</span></span> <span class="hljs-type"><span class="hljs-type">I</span></span> have a <span class="hljs-string"><span class="hljs-string">'Name'</span></span> defined as <span class="hljs-string"><span class="hljs-string">'&lt;name&gt;'</span></span> <span class="hljs-type"><span class="hljs-type">When</span></span> <span class="hljs-type"><span class="hljs-type">I</span></span> convert <span class="hljs-string"><span class="hljs-string">'Name'</span></span> to plural <span class="hljs-string"><span class="hljs-string">'Result'</span></span> <span class="hljs-type"><span class="hljs-type">Then</span></span> <span class="hljs-string"><span class="hljs-string">'Result'</span></span> should be equal to <span class="hljs-string"><span class="hljs-string">'&lt;result&gt;'</span></span> <span class="hljs-type"><span class="hljs-type">Examples</span></span>: | name | result | | ballista | ballistae | | class | classes | | box | boxes | | byte | bytes | | bolt | bolts | | fish | fishes | | guy | guys | | ply | plies |</code> </pre><br></div></div><br><br><h2>  Classic approach </h2><br>  The example above does not apply to the alternative approach, which I want to talk about in this article, it refers to the classical one.  In this very classical approach, the ‚Äúinput‚Äù data for the test is specially created in the test itself.  This phrase can already serve as a hint, what is the "alternative". <br>  Another, slightly more complicated example of the classic creation of data for a test, with which you can then compare the alternative: <br><pre> <code class="hljs pgsql">Given that I have a insurance created <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> year <span class="hljs-number"><span class="hljs-number">2006</span></span> <span class="hljs-keyword"><span class="hljs-keyword">And</span></span> insurance has an assignment <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> <span class="hljs-string"><span class="hljs-string">'Dependent'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">over</span></span> <span class="hljs-number"><span class="hljs-number">70</span></span> people covered</code> </pre><br>  These lines, which I will call steps, will correspond to the following lines with code: <br><pre> <code class="hljs pgsql">insurance = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Insurance { Created = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> DateTime(<span class="hljs-number"><span class="hljs-number">2006</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>), Assignments = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> List&lt;Assignment&gt;() }; insurance.Assignments.<span class="hljs-keyword"><span class="hljs-keyword">Add</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Assignment { <span class="hljs-keyword"><span class="hljs-keyword">Type</span></span> = assignmentType, HeadCount = headCount + <span class="hljs-number"><span class="hljs-number">1</span></span> });</code> </pre><br>  Also in the definitions of test steps there is a code that allows you to transfer these objects between steps, but for brevity this code has been omitted. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  Alternative </h2><br>  At once I want to mention that this approach was found and applied not by me, but by my colleague.  On the habr and on the githab, it is registered as a <a href="http://habrahabr.ru/users/gerichhome/" class="user_link">gerichhome</a> .  I took it to describe and publish.  Well, maybe according to the Habra tradition, a comment will appear that is more useful than the article, it turns out that it was not for nothing that he wrote and wasted time. <br>  In some cases, as in the case of our project, a considerable amount of data is needed to display the portal page.  And to test some specific features only a small portion is needed.  And, so that the rest of the page does not fall due to lack of data, you will have to write a considerable amount of code.  And, even worse, you will most likely have to write some SpecFlow steps.  Thus it turns out that you want, you do not want, but you have to test the whole page, as it were, and not the part that is necessary at the moment. <br>  And in order to circumvent this, the data can not be created, but searched among the available ones.  The data can be either in the test database or in the mock files collected and serialized on a slice of some API.  Of course, this approach is more suitable for the case when we already have a lot of functionality, at least the part that will allow to manipulate this data.  So that, if there is no necessary data set for the test, you could first go through the test scenario with your hands, make a data cast, and then automate it.  It is convenient to use this approach when there is a desire and / or need to cover the existing code with tests, then refactor / rewrite / expand and not be afraid that the functionality will break. <br><br>  As before, the test requires an Insurance object, created in 2006 and having an Assignment with the type of Dependent and the number of people covered by more than seventy.  Any of the insurance stored in the database contains many other entities, in our project the model occupied more than 20 tables.  As part of the demonstration, I did not use the full model, my simplified model includes only three entities. <br>  In order to find the necessary insurance, you need to somehow determine the source in the form of IEnumerable &lt;Insurance&gt; and change the definition of the steps to the following: <br><pre> <code class="hljs javascript">insurances = insurances.Where(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function"> =&gt;</span></span> x.Created.Year == year); insurances = insurances.Where(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function"> =&gt;</span></span> x.Assignments.Any(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">y</span></span></span><span class="hljs-function"> =&gt;</span></span> y.Type == assignmentType &amp;&amp; y.HeadCount &gt; headCount));</code> </pre><br>  Next, in the next steps, you need to open the portal, giving it the ID of the first insurance found in the HTTP request line, and actually test the necessary functionality.  The specifics of these actions, of course, far beyond the bounds of this topic, <br><br><h2>  Search algorithm </h2><br>  So, the insurance is found, we opened the portal, checked that the name of the insurance is displayed on the UI in the required section, now we need to check that the other section displays the required number of tenants.  And then the question arises, how in this step to find out what kind of Assignment allowed our insurance to pass on this condition?  Which of, for example, five take to compare its HeadCount with the number on the UI? <br>  For this, we would have to repeat this condition in the ‚ÄúThen‚Äù step, and duplicating the code is obviously bad.  In addition, the conditions will have to be duplicated in the steps of SpecFlow, which is completely unacceptable. <br>  Lyrical digression - we already had something similar on one of the projects, there was an sql query (for simplicity, let it be coming from configs), which searches for people returning the SSN list.  According to the scenario, these people should have had a child over 18 years old.  And business people discussed for a long time, almost cursing, could not understand why we could not decompose this query in order for a particular person to find those children who came under the condition.  Could not understand why we need a second request.  And since there is a vision of a brighter future, in which BA will write the text of the test, it is much more difficult to explain why duplication in steps is more difficult than eliminating this duplication, and this is the first task that is solved by the search algorithm. <br>  In addition, with the usual search in the previous paragraph, the second step cannot be divided into two steps by SpecFlow.  This is the second problem solved by the algorithm.  It will be discussed later about this algorithm and its implementation. <br>  The algorithm is schematically represented in the following picture: <br><img src="https://habrastorage.org/files/519/831/413/51983141377749448fdc520b4071d0cd.png"><br>  Search works quite simply.  The initial collection of root entities, in this case insurance, is represented as IEnumerable &lt;IResolutionContext &lt;Insurance &gt;&gt;.  Only those insurances that meet their own conditions and have a collection of subsidiary entities that satisfy the conditions get into it.  In order to designate these child entities, it is necessary to register a so-called.  provider with lambda type Func &lt;T1, IEnumerable &lt;T2 &gt;&gt;. <br>  Child collections may also have conditions, the simplest of which is Exists.  With this condition, the collection will be considered valid if it contains at least one element that satisfies its own conditions. <br>  Own conditions, they are filters, are lambdas of the type Func &lt;T1, bool&gt; in the simple case. <br>  The picture shows the case where two insurance found suitable for all conditions, the first one has a number of objects Assignment, of which fit under conditions 4, and also a number of objects Tax, of which two approached.  Also for the second insurance there were 3 suitable Assignment and 4 Tax. <br>  And, although this seems fairly obvious, it should be noted that, apart from insurance that did not fit its own conditions, those insurances that did not find suitable objects for Assignment or did not find suitable Tax objects did not appear on the list. <br>  Red arrows indicate the tree of interactions of specific elements.  A specific Assignment element, there is only one link up, it ‚Äúknows‚Äù only about the specific Insurance element that gave rise to it, and ‚Äúdoes not know‚Äù either about the Assignments collection in which it is located, nor, especially about the Insurances collection, for an element collections of parent elements may exist. <br><br>  From here on, there are descriptions and examples of the use of the implementation, which I developed and published in NuGet (link at the end).  The colleague also created his own implementation of the search algorithm, which differs mainly in that it pulls the registration network into a chain, that is, a tree with a single branch.  Its implementation has some of its features, which I do not have, and my own shortcomings.  Also, its implementation has some unnecessary dependencies, which slightly hinder the decision making in a separate module.  In addition, for political reasons, roofing felts for personal reasons, he is not particularly keen to publish his decisions, which would make it somewhat difficult to use him in other projects.  I had free time and desire to embody some interesting algorithm.  With this I approached the writing of this article. <br><br><h2>  Registration of entities and filters </h2><br>  To achieve maximum granularity, the steps are broken down as follows. <br><pre> <code class="hljs delphi">Given insurance A <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> taken from insurancesSource <span class="hljs-string"><span class="hljs-string">#1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">And</span></span> insurance A <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> created <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> year <span class="hljs-number"><span class="hljs-number">2007</span></span> <span class="hljs-string"><span class="hljs-string">#2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">And</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> insurance A exists an assignment A <span class="hljs-string"><span class="hljs-string">#3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">And</span></span> assignment A has <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> <span class="hljs-string"><span class="hljs-string">'Dependent'</span></span> <span class="hljs-string"><span class="hljs-string">#4</span></span> <span class="hljs-keyword"><span class="hljs-keyword">And</span></span> assignment A has over <span class="hljs-number"><span class="hljs-number">70</span></span> people covered <span class="hljs-string"><span class="hljs-string">#5</span></span></code> </pre><br>  Such granularity may of course look somewhat redundant, but it does allow for achieving a very high level of reuse.  When writing tests for the search algorithm, having 5-6 written tests, all the following tests for a good three-quarters consisted of reused steps. <br><br>  To register such sources and filters, use the following syntax: <br><pre> <code class="hljs vhdl"> <span class="hljs-keyword"><span class="hljs-keyword">context</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">Register</span></span>() .Items(key, () =&gt; InsurancesSource.Insurances); #<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">context</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">Register</span></span>() .<span class="hljs-keyword"><span class="hljs-keyword">For</span></span>&lt;Insurance&gt;(key) .IsTrue(insurance =&gt; insurance.Created.Year == year); #<span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">context</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">Register</span></span>() .<span class="hljs-keyword"><span class="hljs-keyword">For</span></span>&lt;Insurance&gt;(insuranceKey) .Exists(assignmentKey, insurance =&gt; insurance.Assignments); #<span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">context</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">Register</span></span>() .<span class="hljs-keyword"><span class="hljs-keyword">For</span></span>&lt;Assignment&gt;(key) .IsTrue(assignment =&gt; assignment.<span class="hljs-keyword"><span class="hljs-keyword">Type</span></span> == <span class="hljs-keyword"><span class="hljs-keyword">type</span></span>); #<span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-keyword"><span class="hljs-keyword">context</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">Register</span></span>() .<span class="hljs-keyword"><span class="hljs-keyword">For</span></span>&lt;Assignment&gt;(key) .IsTrue(assignment =&gt; assignment.HeadCount &gt;= headCount); #<span class="hljs-number"><span class="hljs-number">5</span></span></code> </pre><br>  The context used here is (TestingContext context) injected into the classes containing the definitions.  All the lines in the SpecFlow test are marked with numbers only to indicate the correspondence with the definitions, the order of arrangement of these lines can be any.  This can be useful when using the ‚ÄúBackground‚Äù feature.  Such freedom of registration is achieved due to the fact that the tree of providers is built not during the actual registration, but at the first receipt of the result. <br><br><h2>  Retrieving Search Results </h2><br><pre> <code class="hljs vhdl">var insurance = <span class="hljs-keyword"><span class="hljs-keyword">context</span></span>.Value&lt;Insurance&gt;(insuranceKey); var insurances = <span class="hljs-keyword"><span class="hljs-keyword">context</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">All</span></span>&lt;Insurance&gt;(insuranceKey); var assignments = <span class="hljs-keyword"><span class="hljs-keyword">context</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">All</span></span>&lt;Assignment&gt;(assignmentKey);</code> </pre><br>  The first line returns the first policy that fits under all conditions, i.e.  was established in 2007, and has at least one Dependent type Assignment in which there are 70 people. <br>  The second line returns all policies that meet these conditions. <br>  The third line returns all matching Assignment objects from matching policies.  That is, the result does not contain suitable Covers from unsuitable policies. <br>  The ‚ÄúAll‚Äù method returns IEnumerable &lt;IResolutionContext &lt;Insurance &gt;&gt;, not IEnumerable &lt;Insurance&gt;.  To obtain the latter, select the Value field using Select.  The IResolutionContext interface allows you to get a list of matching child entities for the current parent.  Example: <br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> insurances = context.<span class="hljs-type"><span class="hljs-type">All</span></span>&lt;<span class="hljs-type"><span class="hljs-type">Insurance</span></span>&gt;(insuranceKey); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> firstPolicyCoverages = insurances.<span class="hljs-type"><span class="hljs-type">First</span></span>().<span class="hljs-type"><span class="hljs-type">Get</span></span>&lt;<span class="hljs-type"><span class="hljs-type">Assignment</span></span>&gt;(assignmentKey);</code> </pre><br>  It is important to mention here that, for any two pairs T1-key1 and T2-key2, the following condition is true - If from the context T1-key1, let's say it will be a variable <br><pre> <code class="hljs xml"> IResolutionContext<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">T1</span></span></span><span class="hljs-tag">&gt;</span></span> c1</code> </pre>  get a collection of contexts T2-key2 <pre> <code class="hljs django"><span class="xml"><span class="xml">IEnumerable</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">IResolutionContext</span></span></span></span><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">T2</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">&gt; cs2 = c1.Get</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">T2</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">(key2)</span></span></code> </pre>  then you can call back to T1-key1 from any of the elements of this collection and the resulting collection will contain the original element. <pre> <code class="hljs pgsql">cs2.<span class="hljs-keyword"><span class="hljs-keyword">All</span></span>(x =&gt; x.<span class="hljs-keyword"><span class="hljs-keyword">Get</span></span>&lt;T1&gt;(key1).Contains(c1)) == <span class="hljs-keyword"><span class="hljs-keyword">true</span></span></code> </pre> <br>  In addition, between c1 and cs2 elements, all the conditions indicated in the combined filters will be fulfilled. <br><br><h2>  Combined filters </h2><br>  In some cases, it is necessary to compare the fields of two entities.  An example of such a filter: <br><pre> <code class="hljs pgsql"> <span class="hljs-keyword"><span class="hljs-keyword">And</span></span> assignment A covers less people than maximum dependents specified <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> insurance A</code> </pre><br>  The condition, of course, is unrealistic, like some others.  I hope it does not confuse anyone, an example is an example. <br>  The definition of such a step: <br><pre> <code class="hljs javascript">context .For&lt;Assignment&gt;<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">assignmentKey</span></span></span><span class="hljs-function">) .</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">For</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Insurance</span></span></span><span class="hljs-function">&gt;(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">insuranceKey</span></span></span><span class="hljs-function">) .</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IsTrue</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(assignment, insurance</span></span></span><span class="hljs-function">) =&gt;</span></span> assignment.HeadCount &lt; insurance.MaximumDependents);</code> </pre><br>  The filter is assigned to the entity farthest from the root of the tree, in this case it is an Assignment, and in the process of execution it searches for insurance, passing along the red arrow (in the first figure) upwards. <br>  If two entities of the same type with different keys are involved in the filter, then an inequality filter is automatically applied between them. <br>  that is, in the case of .For &lt;Assignment&gt; ("a") .For &lt;Assignment&gt; ("b"), the same entity will never fall into the lambda (a1, a2) =&gt; in both arguments. <br><br>  I limited myself to the fact that two entities can be used in the filter, since most likely the condition using 3 entities can be broken into pieces.  There is no technical limit, I can add a ‚Äútriple‚Äù filter at will. <br><br><h2>  Collection filters </h2><br>  Several filters on the collection have already been laid, and one of them - Exists, has already been used previously.  There are also filters DoesNotExist and Each. <br>  They literally mean the following - the parent entity, in this case insurance, is considered to be suitable for the condition, if there is at least one child entity - the Assignment is suitable for the condition.  This is for Exists.  For DoesNotExist - if there is not one Assignment suitable for the conditions, and Each - if all the Assignment of this insurance are suitable for the conditions. <br>  In addition, you can set your own filters for collections.  For example: <br><pre> <code class="hljs javascript">context.ForAll&lt;Assignment&gt;(key) .IsTrue(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">assignments</span></span></span><span class="hljs-function"> =&gt;</span></span> assignments.Sum(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function"> =&gt;</span></span> x.HeadCount) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><br>  The filter for the collections, of course, includes only suitable Assignment, that is, those that first went through their own filters. <br><br>  The second example involves comparing two collections. <br>  SpecFlow text for example: <br><pre> <code class="hljs pgsql"> <span class="hljs-keyword"><span class="hljs-keyword">And</span></span> average payment per person <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> assignments B, specified <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> taxes B <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">over</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span>$</code> </pre><br>  and the corresponding definition: <br><pre> <code class="hljs javascript">context .ForAll&lt;Assignment&gt;<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">assignmentKey</span></span></span><span class="hljs-function">) .</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ForAll</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Tax</span></span></span><span class="hljs-function">&gt;(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">taxKey</span></span></span><span class="hljs-function">) .</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IsTrue</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(assignments, taxes</span></span></span><span class="hljs-function">) =&gt;</span></span> taxes.Sum(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function"> =&gt;</span></span> x.Amount) / assignments.Sum(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function"> =&gt;</span></span> x.HeadCount) &gt; average);</code> </pre><br><br><h2>  Another method of testing </h2><br>  The trick is to first prepare a fully populated object, check that the page (meaning that we are testing the web application) works out the happy-path script successfully, and then using the same object in each subsequent test, one breaks something and check that the page issues a warning to the user.  For example, a user entering under happy-path must have a password, mail, address, access rights, etc.  And for bad tests, the same user is taken and the password is broken for him, mail for the next test, and so on. <br>  The same technique can be used when searching for data: <br><pre> <code class="hljs pgsql">Background: Given insurance B <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> taken <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> insurancesSource <span class="hljs-keyword"><span class="hljs-keyword">And</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> insurance B <span class="hljs-keyword"><span class="hljs-keyword">exists</span></span> an assignment B <span class="hljs-keyword"><span class="hljs-keyword">And</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> insurance B <span class="hljs-keyword"><span class="hljs-keyword">exists</span></span> a tax B Scenario: <span class="hljs-keyword"><span class="hljs-keyword">No</span></span> assignment <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> needed count <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Given there <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">no</span></span> suitable assignment B Scenario: <span class="hljs-keyword"><span class="hljs-keyword">No</span></span> tax <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> needed amount <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Given there <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">no</span></span> suitable tax B</code> </pre><br>  The text I gave is not complete, only significant lines.  In the example in the Background section, all the registrations required for the happy-path are specified, and in specific ‚Äúbad‚Äù scenarios one of the filters is inverted.  In the happy-path test, an insurance will be found in which there is a suitable Assignment and a suitable Tax.  For the first "bad" test, insurance will be found in which there is no suitable Assignment, for the second, respectively, insurance, in which there is no suitable Tax.  This inversion can be included as follows: <br><pre> <code class="hljs xml">context.InvertCollectionValidity<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Assignment</span></span></span><span class="hljs-tag">&gt;</span></span>(key);</code> </pre><br>  In addition, you can assign a key to any filter, then invert this filter using this key. <br><br><h2>  Logging failed search </h2><br>  In the case when many filters are specified, it is not immediately possible to understand why the search returns nothing.  Of course, it is quite easy to fight this with the dichotomy method, that is, to comment out half of the filters and see what changes, then half from half, etc.  However, for convenience, and to reduce time costs, it was decided to give the opportunity to print to the log that filter that invalidated the last available entity.  This means that if the first of the three filters eliminated half of the entities, the second eliminated the second half, and the case did not even reach the third filter, then the second specified filter will be printed in this case.  To do this, subscribe to the OnSearchFailure event. <br><br>  That's all.  The project is available on github. <a href="https://github.com/repinvv/TestingContext">Github.com/repinvv/TestingContext</a> <br>  You can get the finished build from NuGet <a href="https://www.nuget.org/packages/TestingContext/">www.nuget.org/packages/TestingContext</a> </div><p>Source: <a href="https://habr.com/ru/post/268561/">https://habr.com/ru/post/268561/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../268545/index.html">We shared the Internet: a lot of us, but it is not</a></li>
<li><a href="../268547/index.html">Manage different types of disks on a virtual server</a></li>
<li><a href="../268551/index.html">UX in messengers: 2005 - 2015. Part I. Background. Years 2005-2007</a></li>
<li><a href="../268555/index.html">The leak of real full names of users through Kinopoisk.ru</a></li>
<li><a href="../268559/index.html">Is your programming language unfounded? (or why predictability is important)</a></li>
<li><a href="../268567/index.html">New emotions on Facebook. A brief analysis of the functionality and its logic</a></li>
<li><a href="../268569/index.html">Patch mysqldump at home</a></li>
<li><a href="../268573/index.html">Remote code execution in InterSystems Cach√© (RCE)</a></li>
<li><a href="../268575/index.html">Photoshop history</a></li>
<li><a href="../268577/index.html">Robonoch -2015</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>