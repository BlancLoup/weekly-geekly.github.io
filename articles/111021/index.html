<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Pro optimization techniques</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="An instructive story about optimization techniques clearly. 

 Terms of Reference 
 We will announce a small competition on architecture-oriented soft...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Pro optimization techniques</h1><div class="post__text post__text-html js-mediator-article">  An instructive story about optimization techniques clearly. <br><br><h5>  Terms of Reference </h5><br>  We will announce a small competition on architecture-oriented software optimization as part of the topic. <br>  In short, the code consists of a bundle of functions that produce, at first glance, vague manipulations with the original data and a driver gadget that runs a non-optimized version n times, then optimized, compares the counted digits, and, if they coincide, returns a runtime relationship.  Like this: <br><br>  Executing original code ... done <br>  Executing optimized code ... done <br>  Checking results ... PASSED <br>  Number of runs: 3 <br>  Original code average time: 11.954537 sec. <br>  Optimized code average time: 1.052994 sec. <br>  Speedup: 11.35 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      It is allowed to use any optimization techniques, a GCC compiler with any options, and, say, a server with two quad-core Intel Xeon E5420 2.5 GHz processors. <br>  Here, by the way, the code: <br><a name="habracut"></a><br><blockquote><code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black"><font color="#008000">/*</font> <br> <font color="#008000">* contestopt.c:</font> <br> <font color="#008000">*/</font> <br> <br> #include <font color="#A31515">"contest.h"</font> <br> <br> <font color="#0000ff">void</font> function3( <font color="#0000ff">double</font> a[][NUM], <font color="#0000ff">double</font> b[][NUM], <font color="#0000ff">double</font> c[][NUM]); <br> <font color="#0000ff">void</font> function2( <font color="#0000ff">double</font> a[][NUM]); <br> <font color="#0000ff">double</font> function4(unsigned <font color="#0000ff">int</font> second); <br> <br> <font color="#0000ff">double</font> ***p; <br> <font color="#0000ff">double</font> ****x; <br> <font color="#0000ff">double</font> ****y; <br> <font color="#0000ff">double</font> ****z; <br> <font color="#0000ff">double</font> ***wrk1; <br> <font color="#0000ff">double</font> ***wrk2; <br> <font color="#0000ff">double</font> ***bnd; <br> <font color="#0000ff">static</font> <font color="#0000ff">double</font> a[NUM][NUM], b[NUM][NUM]; <br> <br> <font color="#0000ff">void</font> function1( <font color="#0000ff">double</font> result[][NUM], <font color="#0000ff">double</font> gos[2], unsigned <font color="#0000ff">int</font> second) <br> { <br> function2(a); <br> function2(b); <br> <br> function3(a, b, result); <br> gos[0] = function4(second); <br> } <br> <br> <font color="#0000ff">void</font> function3( <font color="#0000ff">double</font> a[][NUM], <font color="#0000ff">double</font> b[][NUM], <font color="#0000ff">double</font> result[][NUM]) <br> { <br> <font color="#0000ff">int</font> i, j, k; <br> <br> <font color="#0000ff">for</font> (i = 0; i &lt; NUM; i++) { <br> <font color="#0000ff">for</font> (j = 0; j &lt; NUM; j++) { <br> <font color="#0000ff">for</font> (k = 0; k &lt; NUM; k++) { <br> result[i][j] = result[i][j] + a[i][k] * b[k][j]; <br> } <br> } <br> } <br> } <br> <br> <font color="#0000ff">void</font> function2( <font color="#0000ff">double</font> a[][NUM]) <br> { <br> <font color="#0000ff">int</font> i, j; <br> <font color="#0000ff">double</font> first = 0.0; <br> <font color="#0000ff">double</font> second = 1.0; <br> a[0][0] = first; <br> a[0][1] = second; <br> <font color="#0000ff">for</font> (i = 0; i &lt; NUM; i++) { <br> <font color="#0000ff">for</font> (j = 0; j &lt; NUM; j++) { <br> <font color="#0000ff">if</font> (!(i == 0 &amp;&amp; (j == 0 || j == 1))) { <br> a[i][j] = first + second; <br> first = second; <br> second = a[i][j]; <br> } <br> <font color="#0000ff">if</font> (j % 20 == 0 &amp;&amp; j != 0) { <br> first = first * (j + 1) / (NUM); <br> second = second * (j + 1) / (NUM); <br> } <br> } <br> first = ((i + 1) * NUM) / first; <br> second = ((i + 1) * NUM) / second; <br> } <br> } <br> <br> <font color="#0000ff">void</font> function5( <font color="#0000ff">double</font> ***A, <font color="#0000ff">double</font> val) <br> { <br> <font color="#0000ff">int</font> i, j, k; <br> <font color="#0000ff">for</font> (i = 0; i &lt; XX; i++) <br> <font color="#0000ff">for</font> (j = 0; j &lt; YY; j++) <br> <font color="#0000ff">for</font> (k = 0; k &lt; ZZ; k++) <br> A[i][j][k] = val; <br> } <br> <br> <font color="#0000ff">void</font> function6(unsigned <font color="#0000ff">int</font> second) <br> { <br> <font color="#0000ff">int</font> mimax = XX; <br> <font color="#0000ff">int</font> mjmax = YY; <br> <font color="#0000ff">int</font> mkmax = ZZ; <br> <br> <font color="#0000ff">int</font> imax = mimax - 1; <br> <font color="#0000ff">int</font> jmax = mjmax - 1; <br> <font color="#0000ff">int</font> kmax = mkmax - 1; <br> <br> <font color="#0000ff">int</font> i, j, k, l; <br> <font color="#0000ff">double</font> val; <br> srand((unsigned <font color="#0000ff">int</font> ) second); <br> p = ( <font color="#0000ff">double</font> ***) malloc( <font color="#0000ff">sizeof</font> ( <font color="#0000ff">double</font> **) * XX); <br> wrk1 = ( <font color="#0000ff">double</font> ***) malloc( <font color="#0000ff">sizeof</font> ( <font color="#0000ff">double</font> **) * XX); <br> wrk2 = ( <font color="#0000ff">double</font> ***) malloc( <font color="#0000ff">sizeof</font> ( <font color="#0000ff">double</font> **) * XX); <br> bnd = ( <font color="#0000ff">double</font> ***) malloc( <font color="#0000ff">sizeof</font> ( <font color="#0000ff">double</font> **) * XX); <br> <br> x = ( <font color="#0000ff">double</font> ****) malloc( <font color="#0000ff">sizeof</font> ( <font color="#0000ff">double</font> ***) * XX); <br> y = ( <font color="#0000ff">double</font> ****) malloc( <font color="#0000ff">sizeof</font> ( <font color="#0000ff">double</font> ***) * XX); <br> z = ( <font color="#0000ff">double</font> ****) malloc( <font color="#0000ff">sizeof</font> ( <font color="#0000ff">double</font> ***) * XX); <br> <br> <font color="#0000ff">for</font> (i = 0; i &lt; XX; i++) { <br> p[i] = ( <font color="#0000ff">double</font> **) malloc( <font color="#0000ff">sizeof</font> ( <font color="#0000ff">double</font> *) * YY); <br> wrk1[i] = ( <font color="#0000ff">double</font> **) malloc( <font color="#0000ff">sizeof</font> ( <font color="#0000ff">double</font> *) * YY); <br> wrk2[i] = ( <font color="#0000ff">double</font> **) malloc( <font color="#0000ff">sizeof</font> ( <font color="#0000ff">double</font> *) * YY); <br> bnd[i] = ( <font color="#0000ff">double</font> **) malloc( <font color="#0000ff">sizeof</font> ( <font color="#0000ff">double</font> *) * YY); <br> <br> x[i] = ( <font color="#0000ff">double</font> ***) malloc( <font color="#0000ff">sizeof</font> ( <font color="#0000ff">double</font> **) * YY); <br> y[i] = ( <font color="#0000ff">double</font> ***) malloc( <font color="#0000ff">sizeof</font> ( <font color="#0000ff">double</font> **) * YY); <br> z[i] = ( <font color="#0000ff">double</font> ***) malloc( <font color="#0000ff">sizeof</font> ( <font color="#0000ff">double</font> **) * YY); <br> <br> <font color="#0000ff">for</font> (j = 0; j &lt; YY; j++) { <br> p[i][j] = ( <font color="#0000ff">double</font> *) malloc( <font color="#0000ff">sizeof</font> ( <font color="#0000ff">double</font> ) * ZZ); <br> wrk1[i][j] = ( <font color="#0000ff">double</font> *) malloc( <font color="#0000ff">sizeof</font> ( <font color="#0000ff">double</font> ) * ZZ); <br> wrk2[i][j] = ( <font color="#0000ff">double</font> *) malloc( <font color="#0000ff">sizeof</font> ( <font color="#0000ff">double</font> ) * ZZ); <br> bnd[i][j] = ( <font color="#0000ff">double</font> *) malloc( <font color="#0000ff">sizeof</font> ( <font color="#0000ff">double</font> ) * ZZ); <br> <br> x[i][j] = ( <font color="#0000ff">double</font> **) malloc( <font color="#0000ff">sizeof</font> ( <font color="#0000ff">double</font> *) * ZZ); <br> y[i][j] = ( <font color="#0000ff">double</font> **) malloc( <font color="#0000ff">sizeof</font> ( <font color="#0000ff">double</font> *) * ZZ); <br> z[i][j] = ( <font color="#0000ff">double</font> **) malloc( <font color="#0000ff">sizeof</font> ( <font color="#0000ff">double</font> *) * ZZ); <br> <br> <font color="#0000ff">for</font> (k = 0; k &lt; ZZ; k++) { <br> x[i][j][k] = ( <font color="#0000ff">double</font> *) malloc( <font color="#0000ff">sizeof</font> ( <font color="#0000ff">double</font> ) * 4); <br> y[i][j][k] = ( <font color="#0000ff">double</font> *) malloc( <font color="#0000ff">sizeof</font> ( <font color="#0000ff">double</font> ) * 3); <br> z[i][j][k] = ( <font color="#0000ff">double</font> *) malloc( <font color="#0000ff">sizeof</font> ( <font color="#0000ff">double</font> ) * 3); <br> <br> } <br> <br> } <br> } <br> <br> val = ( <font color="#0000ff">double</font> ) rand() / (10.0 * RAND_MAX); <br> <font color="#0000ff">for</font> (i = 0; i &lt; XX; i++) <br> <font color="#0000ff">for</font> (j = 0; j &lt; YY; j++) <br> <font color="#0000ff">for</font> (k = 0; k &lt; ZZ; k++) { <br> <font color="#0000ff">for</font> (l = 0; l &lt; 3; l++) { <br> x[i][j][k][l] = 1.0; <br> y[i][j][k][l] = val; <br> z[i][j][k][l] = 1.0; <br> } <br> <br> x[i][j][k][3] = 1.0; <br> } <br> function5(bnd, 1.0); <br> function5(wrk1, 0.0); <br> function5(wrk2, 0.0); <br> <font color="#0000ff">for</font> (i = 0; i &lt; imax; i++) <br> <font color="#0000ff">for</font> (j = 0; j &lt; jmax; j++) <br> <font color="#0000ff">for</font> (k = 0; k &lt; kmax; k++) <br> p[i][j][k] = ( <font color="#0000ff">double</font> ) (k * k) / ( <font color="#0000ff">double</font> ) (kmax * kmax); <br> } <br> <br> <font color="#0000ff">void</font> function7() <br> { <br> <font color="#0000ff">int</font> i, j, k; <br> <font color="#0000ff">for</font> (i = 0; i &lt; XX; i++) { <br> <font color="#0000ff">for</font> (j = 0; j &lt; YY; j++) { <br> free(p[i][j]); <br> free(wrk1[i][j]); <br> free(wrk2[i][j]); <br> free(bnd[i][j]); <br> <br> <font color="#0000ff">for</font> (k = 0; k &lt; ZZ; k++) { <br> free(x[i][j][k]); <br> free(y[i][j][k]); <br> free(z[i][j][k]); <br> } <br> free(x[i][j]); <br> free(y[i][j]); <br> free(z[i][j]); <br> } <br> free(p[i]); <br> free(wrk1[i]); <br> free(wrk2[i]); <br> free(bnd[i]); <br> <br> free(x[i]); <br> free(y[i]); <br> free(z[i]); <br> <br> } <br> free(x); <br> free(y); <br> free(z); <br> <br> free(p); <br> free(wrk1); <br> free(wrk2); <br> free(bnd); <br> } <br> <br> <font color="#0000ff">double</font> function4(unsigned <font color="#0000ff">int</font> second) <br> { <br> <font color="#0000ff">int</font> nn = NN; <br> <font color="#0000ff">double</font> gosa, s0, ss; <br> <font color="#0000ff">int</font> mimax = XX; <br> <font color="#0000ff">int</font> mjmax = YY; <br> <font color="#0000ff">int</font> mkmax = ZZ; <br> <font color="#0000ff">int</font> imax = mimax - 1; <br> <font color="#0000ff">int</font> jmax = mjmax - 1; <br> <font color="#0000ff">int</font> kmax = mkmax - 1; <br> <font color="#0000ff">int</font> iCount, jCount, kCount, loop, i, j, k; <br> <br> function6(second); <br> <font color="#0000ff">for</font> (loop = 0; loop &lt; nn; loop++) { <br> gosa = 0.0; <br> <font color="#0000ff">for</font> (k = 1; k &lt; kmax - 1; k++) <br> <font color="#0000ff">for</font> (j = 1; j &lt; jmax - 1; j++) <br> <font color="#0000ff">for</font> (i = 1; i &lt; imax - 1; i++) { <br> s0 = x[i][j][k][0] * p[i + 1][j][k] <br> + x[i][j][k][1] * p[i][j][k] <br> + x[i][j][k][2] * p[i][j][k] <br> + y[i][j][k][0] * (p[i + 1][j + 1][k] - p[i + 1][j - 1][k] <br> - p[i - 1][j + 1][k] + p[i - 1][j - 1][k]) <br> + y[i][j][k][1] * (p[i][j + 1][k + 1] - p[i][j - 1][k + 1] <br> - p[i][j + 1][k - 1] + p[i][j - 1][k - 1]) <br> + y[i][j][k][2] * (p[i + 1][j][k + 1] - p[i - 1][j][k + 1] <br> - p[i + 1][j][k - 1] + p[i - 1][j][k - 1]) <br> + z[i][j][k][0] * p[i - 1][j][k] <br> + z[i][j][k][1] * p[i][j - 1][k] <br> + z[i][j][k][2] * p[i][j][k - 1] + wrk1[i][j][k]; <br> ss = (s0 * x[i][j][k][3] - p[i][j][k]) * bnd[i][j][k]; <br> gosa = gosa + ss; <br> wrk2[i][j][k] = p[i][j][k] + 0.1 * ss; <br> } <br> <font color="#0000ff">for</font> (iCount = 1; iCount &lt; imax - 1; iCount++) <br> <font color="#0000ff">for</font> (jCount = 1; jCount &lt; jmax - 1; jCount++) <br> <font color="#0000ff">for</font> (kCount = 1; kCount &lt; kmax - 1; kCount++) <br> p[iCount][jCount][kCount] = wrk2[iCount][jCount][kCount]; <br> } <br> function7(); <br> <font color="#0000ff">return</font> gosa; <br> } <br> <br> <font color="#0000ff">double</font> exponent( <font color="#0000ff">int</font> i, <font color="#0000ff">double</font> x) <br> { <br> <font color="#0000ff">double</font> z = 1.0; <br> <font color="#0000ff">int</font> j; <br> <font color="#0000ff">for</font> (j = 0; j &lt; i; j++) { <br> z = z * x; <br> } <br> <font color="#0000ff">return</font> z; <br> } <br> <br> <font color="#0000ff">double</font> function8( <font color="#0000ff">float</font> *a, <font color="#0000ff">float</font> p) <br> { <br> <font color="#0000ff">int</font> i, j; <br> <font color="#0000ff">double</font> h, x; <br> <font color="#0000ff">double</font> s = p; <br> h = 1.0 / VAL; <br> <font color="#0000ff">for</font> (i = 1; i &lt;= VAL; i++) { <br> x = h * (i - 0.5); <br> <font color="#0000ff">for</font> (j = 0; j &lt; ORDER; j++) { <br> s = (a[j] * exponent(j, x)) + s; <br> } <br> } <br> <font color="#0000ff">return</font> s * h; <br> }</font> <br> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br>  Tested on values: <br>  #define NUM 600 <br>  #define XX 65 <br>  #define YY 33 <br>  #define ZZ 33 <br>  #define NN 50 <br>  #define VAL 10,000,000 <br>  #define ORDER 30 <br>  #define TOLERANCE 1e-8 <br><br>  Approximate driver view: <br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black"><font color="#008000">/*</font> <br> <font color="#008000">* driver.c: Contest driver.</font> <br> <font color="#008000">*/</font> <br> <br> #include &lt;sys/time.h&gt; <br> #include &lt;stdio.h&gt; <br> #include &lt;stdlib.h&gt; <br> #include &lt;inttypes.h&gt; <br> #include &lt;time.h&gt; <br> <br> #include <font color="#A31515">"contest.h"</font> <br> #include <font color="#A31515">"hpctimer.h"</font> <br> <br> <font color="#0000ff">double</font> _RES[NUM][NUM] = { 0.0 }; <br> <font color="#0000ff">double</font> _GOS[2] = { 0.0, 0.0 }; <br> <font color="#0000ff">double</font> RES[NUM][NUM] = { 0.0 }; <br> <font color="#0000ff">double</font> GOS[2] = { 0.0, 0.0 }; <br> <font color="#0000ff">float</font> A[ORDER] = { 0.0 }; <br> <br> <font color="#0000ff">double</font> function8( <font color="#0000ff">float</font> *a, <font color="#0000ff">float</font> p); <br> <font color="#0000ff">void</font> function1( <font color="#0000ff">double</font> result[][NUM], <font color="#0000ff">double</font> gos[2], unsigned <font color="#0000ff">int</font> second); <br> <br> <font color="#0000ff">int</font> is_results_eq( <font color="#0000ff">double</font> _res[][NUM], <font color="#0000ff">double</font> _gos[2], <font color="#0000ff">float</font> _p, <br> <font color="#0000ff">double</font> res[][NUM], <font color="#0000ff">double</font> gos[2], <font color="#0000ff">float</font> p) <br> { <br> <font color="#0000ff">int</font> i, j; <br> <br> <font color="#0000ff">if</font> (fabsf(_p - p) &gt; 1E-1) { <br> printf( <font color="#A31515">"_p p\n"</font> ); <br> printf( <font color="#A31515">"%f\n"</font> , _p); <br> printf( <font color="#A31515">"%f\n"</font> , p); <br> <font color="#0000ff">return</font> 0; <br> } <br> <br> <font color="#0000ff">if</font> (fabs(_gos[0] - gos[0]) &gt; 1E-1) { <br> printf( <font color="#A31515">"_gos gos\n"</font> ); <br> printf( <font color="#A31515">"%f\n"</font> , _gos[0]); <br> printf( <font color="#A31515">"%f\n"</font> , gos[0]); <br> <font color="#0000ff">return</font> 0; <br> } <br> <br> <font color="#0000ff">for</font> (i = 0; i &lt; NUM; i++) <br> <font color="#0000ff">for</font> (j = 0; j &lt; NUM; j++) { <br> <font color="#0000ff">if</font> (fabs(_RES[i][j] - RES[i][j]) &gt; TOLERANCE) { <br> printf( <font color="#A31515">"[%d, %d] =\n%f\n%f\n"</font> , i, j, _RES[i][j], RES[i][j]); <br> <font color="#0000ff">return</font> 0; <br> } <br> } <br> <font color="#0000ff">return</font> 1; <br> } <br> <br> <font color="#0000ff">int</font> main( <font color="#0000ff">int</font> argc, <font color="#0000ff">char</font> **argv) <br> { <br> unsigned <font color="#0000ff">int</font> second; <br> unsigned <font color="#0000ff">int</font> i, j; <br> <font color="#0000ff">float</font> p = 9.0; <br> <font color="#0000ff">double</font> _res, res; <br> <font color="#0000ff">int</font> nruns = 3; <br> hpctimer_time_t t0, t1; <br> <font color="#0000ff">double</font> torig = 0.0, topt = 0.0; <br> <br> srand(time(NULL)); <br> second = 1219304613 + (1000 - (2000.0 * ( <font color="#0000ff">double</font> ) rand() / ( <font color="#0000ff">double</font> ) (RAND_MAX + 1.0))); <br> <font color="#0000ff">for</font> (i = 0; i &lt; ORDER; i++) { <br> A[i] = ( <font color="#0000ff">float</font> )i; <br> } <br> <br> <font color="#0000ff">for</font> (i = 0; i &lt; NUM; i++) { <br> <font color="#0000ff">for</font> (j = 0; j &lt; NUM; j++) { <br> _RES[i][j] = 0.0; <br> RES[i][j] = 0.0; <br> } <br> } <br> <br> <font color="#008000">/* Original code */</font> <br> printf( <font color="#A31515">"Executing original code ... "</font> ); <br> fflush(stdout); <br> t0 = hpctimer_gettime(); <br> <font color="#0000ff">for</font> (i = 0; i &lt; nruns; i++) { <br> _function1(_RES, _GOS, second); <br> _res = _function8(A, p); <br> } <br> t1 = hpctimer_gettime(); <br> torig = hpctimer_getdiff(t0, t1) / nruns; <br> printf( <font color="#A31515">"done\n"</font> ); <br> fflush(stdout); <br> <br> <font color="#008000">/* Optimized code */</font> <br> printf( <font color="#A31515">"Executing optimized code ... "</font> ); <br> fflush(stdout); <br> t0 = hpctimer_gettime(); <br> <font color="#0000ff">for</font> (i = 0; i &lt; nruns; i++) { <br> function1(RES, GOS, second); <br> res = function8(A, p); <br> } <br> t1 = hpctimer_gettime(); <br> topt = hpctimer_getdiff(t0, t1) / nruns; <br> printf( <font color="#A31515">"done\n"</font> ); <br> fflush(stdout); <br> <br> printf( <font color="#A31515">"Checking results ... "</font> ); <br> fflush(stdout); <br> <br> <font color="#0000ff">if</font> (!is_results_eq(_RES, _GOS, _res, RES, GOS, res)) { <br> printf( <font color="#A31515">"RESULTS ARE DIFFERENT!\n"</font> ); <br> } <font color="#0000ff">else</font> { <br> printf( <font color="#A31515">"PASSED\n"</font> ); <br> printf( <font color="#A31515">"Number of runs: %d\n"</font> , nruns); <br> printf( <font color="#A31515">"Original code average time: %.6f sec.\n"</font> , torig); <br> printf( <font color="#A31515">"Optimized code average time: %.6f sec.\n"</font> , topt); <br> printf( <font color="#A31515">"Speedup: %.2f\n"</font> , torig / topt); <br> } <br> <font color="#0000ff">return</font> 0; <br> }</font> <br> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br><h5>  Acceleration Rule One </h5><br>  It would be possible to say about optimization at the source code level: ‚ÄúIt doesn‚Äôt matter what the code does ‚Äî it‚Äôs important how it does it.‚Äù  But the First Optimization Rule that I derived is somewhat contrary to this statement: <br><br>  <b>First Rule</b> <br>  <i>Smoking materiel and algorithms</i> <br><br>  For when you first look at the code, it becomes clear that it performs some simple actions through the anus. <br>  So, even a quick glance is enough to cut out exponent function with disgust, which significantly sets the number of useful gestures (by running some profiler, you can find that it eats 80% of the total counting time).  The raising to the degree that she does in function8 is easily implemented dynamically. <br>  In function8 itself, the calculation of the integral is subconsciously viewed, but we will discuss the scope for its optimization later. <br>  The difference scheme used in function4 is not much optimized by rewriting the code, but, after carrying out the accumulation of gosa in a separate cycle, you can still speed it up. <br>  The multiplication of matrices in function3 is accelerated in many different ways, but at the first stage it is sufficient to note that the multiplied matrices are absolutely identical, and to reduce the memory consumed in this function by two times.  Or even google an elegant algorithm for squaring a matrix.  I'm not talking about Strassen, Coppersmith Vinograd and other perverts. <br><br><h5>  Acceleration, Rule Two </h5><br>  I do not know if the author of the code deliberately crammed so much redundancy into it, but the main part of the resulting acceleration is due to the Second Rule: <br><br>  <b>Second Rule</b> <br>  <i>Destroy data structures that do not carry meaning</i> <br><br>  The rule, by the way, is excellent, and it works not only for optimization, but also for readability, and for better compilability.  Lyrically quoting one remarkable woman, "there is no point in using recursion where it does not make sense to use it." <br>  In this sense, function4 is loaded downright indecently.  Noticing with horror, four-dimensional arrays x, y and z are initialized, destroy them immediately.  Wrk1 and bnd can follow.  I'm not talking about such trifles as mimax, iCount, ss and other excesses.  As a result, the code becomes much shorter and more aesthetic. <br>  function6 and function7 are completely eliminated, the remnants of useful actions will not load function4 either logically or over time, therefore they are transferred to it without serious consequences.  function5 suddenly self-destruct.  In function3, as already mentioned, you can use the same source matrix, and call function2 once. <br>  Already much easier to breathe, and the resulting speedup begins to inspire exploits. <br><br><h5>  Acceleration Rule Three </h5><br>  <b>Third Rule</b> <br>  <i>Minimize conversion prediction errors</i> <br><br>  Now I will explain everything.  This is a branch optimization technique.  The compiled loop or branch statement looks like this (very simplistic): <br> <code>1 mov eax, ebx <br> 2 jne $a <br> 3 mov ecx, ebx <br> 4 jmp b <br> 5 a: ... <br> 6 b: ...</code> <br>  Imagine what is happening at this time in the pipeline.  Instructions are processed in several stages (Fetch - Decode - Execute - Write-back), and after loading instruction 2 the <i>conversion prediction module</i> should work, because we do not yet know the result of this operation and cannot choose the next one. <br>  What happens when the transition prediction module "makes a mistake"?  That's right - the pipeline is unloading.  And this overhead.  We can reduce the number of errors in the prediction of transitions by reducing the number of calls to it. <br>  How? <br><ul><li>  place the most likely branches at the beginning of the branches </li><li>  make higher (on the level of nesting in cycles) invariant branching </li><li>  use loop unrolling </li></ul>  I will explain the last: if instead <br><blockquote> <code><font color="black"><font color="#0000ff">for</font> (i = 0; i &lt; n; i++) { <br> sum += p[i]; <br> }</font></code> </blockquote> <br>  to write <br><blockquote> <code><font color="black"><font color="#0000ff">for</font> (i = 0; i &lt; n; i+=4) { <br> sum += p[i]; <br> sum += p[i + 1]; <br> sum += p[i + 2]; <br> sum += p[i + 3]; <br> }</font></code> </blockquote> <br>  we reduce the number of predictions of transitions by four times. <br><br>  This technique has a pack of pitfalls, for example, the multiplicity of the number of iterations of the pieces to be unfolded, the optimal length of the unfolding, and others.  But in each individual case, you can find a balance and grab off the extra percentages of acceleration in this relatively simple way. <br>  An example of loop unfolding can be seen in the optimized version of function3. <br>  It would also be nice to add the imposition of invariant branching from cycles, which are very blistering eyes in function2, but it‚Äôs not so easy to get them out of there.  Who implements better than me - that young man. <br><br>  To read: R. Gerber, A. Bill <a href="http://www.piter.com/book.phtml%3F978538800131">"Software Optimization: A Collection of Recipes</a> . <a href="http://www.piter.com/book.phtml%3F978538800131">"</a>  2010, Intel <br><br><h5>  Acceleration Rule Four </h5><br>  <b>Fourth Rule</b> <br>  <i>Effectively work with memory</i> <br><br>  In particular, with the cache.  There is such a <i>property of locality of references</i> - the property of programs repeatedly / often refer to the same objects;  and there is temporal localization and spatial localization.  Caching is pre-empted, and on this basis it makes sense to use sequential addresses to avoid cache misses. <br>  In the same matrix multiplication, the row is located in memory sequentially, and the column is scattered, and the known acceleration effect transposes the second matrix. <br>  If we are already talking, let me give another example: if a structure (struct) does not fully fit into the cache, and contains an array within itself, it is better to use an array of structures instead of an array in the structure. <br>  And yet, to write a portable program, do not bind to the size of the cache. <br>  And many other subtleties.  Read - Chris Kaspersky <a href="http://www.ozon.ru/context/detail/id/1418882/">"Technique optimization programs.</a>  <a href="http://www.ozon.ru/context/detail/id/1418882/">Efficient use of memory</a> .  2003, BHV-Petersburg <br><br><h5>  Acceleration, Rule Fifth </h5><br>  What processor architecture do we have there? <br><br>  <b>Fifth Rule</b> <br>  <i>Vectorize calculations where possible</i> <br><br>  It's time to use SSE, good, you can vectorize almost any code that works with arrays. <br>  A small educational program. <br>  SSE (x86) architecture: <br><ol><li>  MMX - processing integer vectors (64-bit registers) </li><li>  SSE - work with real and integer vectors (128 bits) </li></ol>  Instructions can work with scalars as well as packed vectors.  For example: <br><pre> <code class="hljs ruby">mulss xmm1, xmm<span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-params"><span class="hljs-params">| mulps xmm1, xmm0 XMM0 4.0 3.0 2.0 1.0 |</span></span> <span class="hljs-number"><span class="hljs-number">4.0</span></span> <span class="hljs-number"><span class="hljs-number">3.0</span></span> <span class="hljs-number"><span class="hljs-number">2.0</span></span> <span class="hljs-number"><span class="hljs-number">1.0</span></span> * <span class="hljs-params"><span class="hljs-params">| * * * * XMM1 5.0 5.0 5.0 5.0 |</span></span> <span class="hljs-number"><span class="hljs-number">5.0</span></span> <span class="hljs-number"><span class="hljs-number">5.0</span></span> <span class="hljs-number"><span class="hljs-number">5.0</span></span> <span class="hljs-number"><span class="hljs-number">5.0</span></span> = <span class="hljs-params"><span class="hljs-params">| = = = = XMM1 4.0 3.0 2.0 5.0 |</span></span> <span class="hljs-number"><span class="hljs-number">20.0</span></span> <span class="hljs-number"><span class="hljs-number">15.0</span></span> <span class="hljs-number"><span class="hljs-number">10.0</span></span> <span class="hljs-number"><span class="hljs-number">5.0</span></span></code> </pre><br>  SSE instructions can copy, arithmetic, compare, bitwise operations, and even any tricky transformations. <br><br>  How to use them?  There are assembly vector instructions, there are special C ++ classes, there is, after all, automatic vectorization ‚Äî the most portable.  I wanted to use intrinsiki. <br>  <i>Intrinsics</i> is a set of functions and data types supported by the compiler to provide high-level access to SSE instructions. <br>  Connect xmmintrin.h, write vectorized code, compile with -msse3 flag.  The compiler distributes XMM # registers, schedules commands and addressing modes.  Convenient, intuitively simple. <br>  For example, add four float numbers to one instruction: <br><blockquote> <code><font color="black">#include &lt;xmmintrin.h&gt; <br> <font color="#0000ff">void</font> add( <font color="#0000ff">float</font> *a, <font color="#0000ff">float</font> *b, <font color="#0000ff">float</font> *c) <br> { <br> __mm128 t0, t1; <br> t0 = _mm_load_ps(a); <br> t1 = _mm_load_ps(b); <br> t0 = _mm_add_ps(t0, t1); <br> _mm_store_ps(c, t0); <br> }</font></code> </blockquote> <br>  In this particular case, matrix multiplication is rewritten to intrinsiki (at the same time it becomes a block).  function8 is in principle also vectorized, but here is a special case, so for now I‚Äôm looking for your patience. <br>  At this stage, the code begins to dream, and each operator cut from the thick cycle gives a noticeable performance jump. <br><br><h5>  Acceleration Rule Six </h5><br>  Look at the boundary conditions.  Replace data structures with simpler ones, where possible.  To reduce calculations to problems for which solution there are fast algorithms. <br><br>  <b>Sixth Rule</b> <br>  <i>Use mosk</i> <br><br>  In the driver, the results of matrix multiplication are compared to the accuracy of TOLERANCE, and the remaining two numbers are compared to the tenth.  By the method of scientific typing, it turns out that in function8, two thirds of the interval is enough to achieve the required accuracy, and the first three million (all) iterations can be discarded.  Moreover, it is enough to take into account every six to seven thousandth iteration. <br>  Get <br><blockquote> <code><font color="black"><font color="#0000ff">double</font> function8( <font color="#0000ff">float</font> *a, <font color="#0000ff">float</font> p) <br> { <br> <font color="#0000ff">int</font> i, j, val, step; <br> <font color="#0000ff">double</font> h, x, z; <br> <font color="#0000ff">double</font> s = p; <br> <br> h = 1.0 / VAL; <br> val = 0.33 * VAL; <br> step = val / 500; <br> <font color="#0000ff">for</font> (i = val; i &lt;= VAL; i += step) { <br> x = h * i; <br> z = 1.0; <br> <font color="#0000ff">for</font> (j = 1; j &lt; ORDER; j++) { <br> z *= x; <br> s += j * z; <br> } <br> } <br> <font color="#0000ff">return</font> s * h * step; <br> }</font></code> </blockquote> <br>  and rejoice.  Like?  I do not.  For you can generally get rid of the operation of exponentiation. <br><blockquote> <code><font color="black"><font color="#0000ff">double</font> function8( <font color="#0000ff">float</font> *a, <font color="#0000ff">float</font> p) <br> { <br> unsigned <font color="#0000ff">int</font> j; <br> <font color="#0000ff">double</font> s = p / VAL; <br> <font color="#0000ff">for</font> (j = 0; j &lt; ORDER; j++) { <br> s += (a[j] / (j + 1)); <br> } <br> <font color="#0000ff">return</font> s; <br> }</font></code> </blockquote> <br>  It turns out the complexity of O (ORDER) - compared to the original O (VAL) * O (ORDER ^ 2).  The same result can be achieved by using Bernoulli numbers (which are not so trivial, but you can still notice by writing out the algorithm manually). <br>  You can pay attention to the features of filling the squared matrix and see the zeros in the even rows. <br>  You can replace three-dimensional arrays on one-dimensional, addressing them like: <br>  m1 = (YY - 1) * (ZZ - 1);  m2 = (ZZ - 1);  p [i * m1 + j * m2 + k].  This small trick allows you to use memset to populate multi-dimensional matrices. <br>  You can and even need to use __inline for small functions. <br><br>  And further.  Since in this case, an eight-core machine is available, it is impossible not to use OpenMP.  Parallelization of function3, function4 and function8 does not even require much imagination.  A little less obvious is the possibility of using parallel sections in function1 (for function3 and function4 are independent of data). <br><br>  For sweet - version of the optimized program.  He does not pretend to the ideal, but he gives an acceleration honestly several hundred times. <br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black"><font color="#008000">/*</font> <br> <font color="#008000">* contestopt.c:</font> <br> <font color="#008000">*/</font> <br> <br> #include &lt;sys/time.h&gt; <br> #include &lt;omp.h&gt; <br> #include <font color="#A31515">"contest.h"</font> <br> <br> <font color="#0000ff">void</font> function3( <font color="#0000ff">double</font> a[][NUM], <font color="#0000ff">double</font> c[][NUM]); <br> <font color="#0000ff">void</font> function2( <font color="#0000ff">double</font> a[][NUM]); <br> <font color="#0000ff">double</font> function4(unsigned <font color="#0000ff">int</font> second); <br> <br> <font color="#0000ff">static</font> <font color="#0000ff">double</font> p[XX][YY][ZZ] __attribute__ ((aligned(64))); <br> <font color="#0000ff">static</font> <font color="#0000ff">double</font> wrk2[XX][YY][ZZ] __attribute__ ((aligned(64))); <br> <font color="#0000ff">static</font> <font color="#0000ff">double</font> a[NUM][NUM] __attribute__ ((aligned(64))); <br> <br> <font color="#0000ff">void</font> function1( <font color="#0000ff">double</font> result[][NUM], <font color="#0000ff">double</font> gos[2], unsigned <font color="#0000ff">int</font> second) <br> { <br> <font color="#0000ff">#pragma</font> omp parallel sections <br> { <br> <font color="#0000ff">#pragma</font> omp section <br> function3(a,result); <br> <br> <font color="#0000ff">#pragma</font> omp section <br> gos[0] = function4(second); <br> } <br> } <br> <br> <font color="#0000ff">void</font> function3( <font color="#0000ff">double</font> a[][NUM], <font color="#0000ff">double</font> result[][NUM]) <br> { <br> <font color="#0000ff">int</font> i, i2, j, j2, k, k2; <br> <font color="#0000ff">double</font> *restrict rres; <br> <font color="#0000ff">double</font> *restrict rmul1; <br> <font color="#0000ff">double</font> *restrict rmul2; <br> unsigned <font color="#0000ff">int</font> BS = 8; <br> <font color="#0000ff">int</font> remainder = NUM % 8; <br> <font color="#0000ff">int</font> limit = NUM - remainder; <br> <br> function2(a); <br> <font color="#0000ff">if</font> (!(NUM &amp; 1)) { <br> <font color="#0000ff">#pragma</font> omp <font color="#0000ff">for</font> <font color="#0000ff">private</font> (k, j, i, i2, j2, k2, rres, rmul1, rmul2) <br> <font color="#0000ff">for</font> (i = 0; i &lt; limit; i += BS) <br> <font color="#0000ff">for</font> (j = 0; j &lt; limit; j += BS) <br> <font color="#0000ff">for</font> (k = 0; k &lt; limit; k += BS) <br> <font color="#0000ff">for</font> (i2 = 0, rres = &amp;result[i][j], rmul1 = &amp;a[i][k]; i2 &lt; BS; <br> ++i2, rres += NUM, rmul1 += NUM) { <br> _mm_prefetch (&amp;rmul1[8], _MM_HINT_NTA); <br> <font color="#0000ff">if</font> (!(NUM &amp; 1)) <br> <font color="#0000ff">for</font> (k2 = 0, rmul2 = &amp;a[k][j]; k2 &lt; BS; ++k2, rmul2 += NUM) { <br> __m128d m1d = _mm_load_sd (&amp;rmul1[k2]); <br> m1d = _mm_unpacklo_pd (m1d, m1d); <br> j2 = 0; <br> __m128d m2 = _mm_load_pd (&amp;rmul2[j2]); <br> __m128d r2 = _mm_load_pd (&amp;rres[j2]); <br> _mm_store_pd (&amp;rres[j2], <br> _mm_add_pd (_mm_mul_pd (m2, m1d), r2)); <br> j2 +=2; <br> m2 = _mm_load_pd (&amp;rmul2[j2]); <br> r2 = _mm_load_pd (&amp;rres[j2]); <br> _mm_store_pd (&amp;rres[j2], <br> _mm_add_pd (_mm_mul_pd (m2, m1d), r2)); <br> j2 +=2; <br> m2 = _mm_load_pd (&amp;rmul2[j2]); <br> r2 = _mm_load_pd (&amp;rres[j2]); <br> _mm_store_pd (&amp;rres[j2], <br> _mm_add_pd (_mm_mul_pd (m2, m1d), r2)); <br> j2 +=2; <br> m2 = _mm_load_pd (&amp;rmul2[j2]); <br> r2 = _mm_load_pd (&amp;rres[j2]); <br> _mm_store_pd (&amp;rres[j2], <br> _mm_add_pd (_mm_mul_pd (m2, m1d), r2)); <br> } <br> } <br> } <font color="#0000ff">else</font> { <br> <font color="#0000ff">#pragma</font> omp <font color="#0000ff">for</font> <font color="#0000ff">private</font> (k, j, i, i2, j2, k2, rres, rmul1, rmul2) <br> <font color="#0000ff">for</font> (i = 0; i &lt; limit; i += BS) <br> <font color="#0000ff">for</font> (j = 0; j &lt; limit; j += BS) <br> <font color="#0000ff">for</font> (k = 0; k &lt; limit; k += BS) <br> <font color="#0000ff">for</font> (i2 = 0, rres = &amp;result[i][j], rmul1 = &amp;a[i][k]; i2 &lt; BS; <br> ++i2, rres += NUM, rmul1 += NUM) { <br> _mm_prefetch (&amp;rmul1[8], _MM_HINT_NTA); <br> <font color="#0000ff">for</font> (k2 = 0, rmul2 = &amp;a[k][j]; k2 &lt; BS; ++k2, rmul2 += NUM) { <br> <font color="#0000ff">for</font> (j2 = 0; j2 &lt; BS; j2++ ) { <br> rres[j2] += rmul1[k2] * rmul2[j2]; <br> } <br> } <br> } <br> } <br> <font color="#0000ff">if</font> (remainder) { <br> <font color="#0000ff">#pragma</font> omp <font color="#0000ff">for</font> <font color="#0000ff">private</font> (i,j,k) <br> <font color="#0000ff">for</font> (i = 0; i &lt; limit; ++i) <br> <font color="#0000ff">for</font> (k = NUM - remainder; k &lt; NUM; ++k) <br> <font color="#0000ff">for</font> (j = 0; j &lt; limit; ++j) <br> result[i][j] += a[i][k] * a[k][j]; <br> <font color="#0000ff">#pragma</font> omp <font color="#0000ff">for</font> <font color="#0000ff">private</font> (i,j,k) <br> <font color="#0000ff">for</font> (i = limit; i &lt; NUM; ++i) <br> <font color="#0000ff">for</font> (k = 0; k &lt; NUM; ++k) <br> <font color="#0000ff">for</font> (j = 0; j &lt; NUM; ++j) <br> result[i][j] += a[i][k] * a[k][j]; <br> <font color="#0000ff">#pragma</font> omp <font color="#0000ff">for</font> <font color="#0000ff">private</font> (i,j,k) <br> <font color="#0000ff">for</font> (i = 0; i &lt; limit; ++i) <br> <font color="#0000ff">for</font> (k = 0; k &lt; NUM; ++k) <br> <font color="#0000ff">for</font> (j = limit; j &lt; NUM; ++j) <br> result[i][j] += a[i][k] * a[k][j]; <br> } <br> } <br> <br> <font color="#0000ff">void</font> function2( <font color="#0000ff">double</font> a[][NUM]) <br> { <br> <font color="#0000ff">int</font> i, j ; <br> <font color="#0000ff">double</font> first = 0.0; <br> <font color="#0000ff">double</font> second = 1.0; <br> <br> __assume_aligned(a, 64); <br> <br> a[0][0]=first; <br> a[0][1]=second; <br> <br> <font color="#0000ff">for</font> (j = 2; j &lt; NUM; j++) { <br> a[0][j] = first + second; <br> first = second; <br> second = a[0][j]; <br> <font color="#0000ff">if</font> ( j%20 == 0 &amp;&amp; j != 0) { <br> first = first * (j + 1) / (NUM); <br> second = second * (j + 1) / (NUM); <br> } <br> } <br> first = NUM / first; <br> second = NUM / second; <br> <font color="#0000ff">for</font> (i = 1; i &lt; NUM; i++) { <br> <font color="#0000ff">for</font> (j = 0; j &lt; NUM; j++) { <br> a[i][j] = first + second; <br> first = second; <br> second = a[i][j]; <br> <font color="#0000ff">if</font> ( j%20 == 0 &amp;&amp; j != 0 ) { <br> first = first * (j + 1) / (NUM); <br> second = second * (j + 1) / (NUM); <br> } <br> } <br> first = ((i + 1) * NUM) / first; <br> second = ((i + 1) * NUM) / second; <br> } <br> } <br> <br> __inline <font color="#0000ff">void</font> function6(unsigned <font color="#0000ff">int</font> second) <br> { <br> <font color="#0000ff">int</font> imax = XX - 1; <br> <font color="#0000ff">int</font> jmax = YY - 1; <br> <font color="#0000ff">int</font> kmax = ZZ - 1; <br> <font color="#0000ff">int</font> i, j, k; <br> <br> <font color="#0000ff">double</font> kmaxDoubled = kmax * kmax; <br> <font color="#0000ff">for</font> (k = 0; k &lt; kmax; k++) <br> p[0][0][k] = (k * k) / kmaxDoubled; <br> <font color="#0000ff">for</font> (i = 0; i &lt; imax; i++) <br> <font color="#0000ff">for</font> (j = 0; j &lt; jmax; j++) <br> <font color="#0000ff">for</font> (k = 1; k &lt; kmax; k++) <br> p[i][j][k] = p[0][0][k]; <br> } <br> <br> <font color="#0000ff">double</font> function4(unsigned <font color="#0000ff">int</font> second) <br> { <br> <font color="#0000ff">int</font> nn = NN; <br> <font color="#0000ff">double</font> gosa = 0.0, val; <br> <font color="#0000ff">int</font> imax = XX - 2; <br> <font color="#0000ff">int</font> jmax = YY - 2; <br> <font color="#0000ff">int</font> kmax = ZZ - 2; <br> <font color="#0000ff">int</font> loop, i, j, k; <br> <br> function6(second); <br> srand((unsigned <font color="#0000ff">int</font> )second); <br> val = ( <font color="#0000ff">double</font> ) rand() / (10.0 * RAND_MAX); <br> <font color="#0000ff">for</font> (loop = 1; loop &lt; nn; loop++) { <br> <font color="#0000ff">for</font> (k = 1; k &lt; kmax; k++) <br> <font color="#0000ff">for</font> (j = 1; j &lt; jmax; j++) <br> <font color="#0000ff">for</font> (i = 1; i &lt; imax; i++) { <br> wrk2[i][j][k] = 0.1 * ( p[i + 1][j][k] + p[i][j][k] <br> + val * (p[i + 1][j + 1][k] - p[i + 1][j - 1][k] <br> - p[i - 1][j + 1][k] + p[i - 1][j - 1][k] <br> + p[i][j + 1][k + 1] - p[i][j - 1][k + 1] <br> - p[i][j + 1][k - 1] + p[i][j - 1][k - 1] <br> + p[i + 1][j][k + 1] - p[i - 1][j][k + 1] <br> - p[i + 1][j][k - 1] + p[i - 1][j][k - 1]) <br> + p[i - 1][j][k] + p[i][j - 1][k] + p[i][j][k - 1]); <br> } <br> <font color="#0000ff">for</font> (i = 1; i &lt; imax; i++) <br> <font color="#0000ff">for</font> (j = 1; j &lt; jmax; j++) <br> <font color="#0000ff">for</font> (k = 1; k &lt; kmax; k++) p[i][j][k] += wrk2[i][j][k]; <br> } <br> <font color="#0000ff">for</font> (k = 1; k &lt; kmax; k++) <br> <font color="#0000ff">for</font> (j = 1; j &lt; jmax; j++) <br> <font color="#0000ff">for</font> (i = 1; i &lt; imax; i++) { <br> gosa += p[i + 1][j][k] + p[i][j][k] <br> + val * (p[i + 1][j + 1][k] - p[i + 1][j - 1][k] <br> - p[i - 1][j + 1][k] + p[i - 1][j - 1][k] <br> + p[i][j + 1][k + 1] - p[i][j - 1][k + 1] <br> - p[i][j + 1][k - 1] + p[i][j - 1][k - 1] <br> + p[i + 1][j][k + 1] - p[i - 1][j][k + 1] <br> - p[i + 1][j][k - 1] + p[i - 1][j][k - 1]) <br> + p[i - 1][j][k] + p[i][j - 1][k] + p[i][j][k - 1]; <br> } <br> <font color="#0000ff">return</font> gosa; <br> } <br> <br> <font color="#0000ff">double</font> function8( <font color="#0000ff">float</font> *a, <font color="#0000ff">float</font> p) <br> { <br> unsigned <font color="#0000ff">int</font> j; <br> <font color="#0000ff">double</font> s = 0.0; <br> <br> <font color="#0000ff">#pragma</font> omp parallel <br> { <br> <font color="#0000ff">#pragma</font> omp <font color="#0000ff">for</font> <font color="#0000ff">private</font> (j) reduction (+:s) <br> <font color="#0000ff">for</font> (j = 0; j &lt; ORDER; j++) { <br> s += (a[j] /(j + 1)); <br> } <br> } <br> <font color="#0000ff">return</font> (s + p / VAL); <br> }</font> <br> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br>  Here is such a fun and very useful practical example.  Let's summarize the code optimization scheme: <br><ol><li>  Algorithmic optimization </li><li>  Architecturally independent optimization: <br><ul><li>  I / O to parallel flow </li><li>  paralleling </li><li>  efficient memory management, efficient caching </li></ul></li><li>  Architectural-oriented optimization: <br><ul><li>  vector instructions </li><li>  minimizing the number of conversion prediction errors </li><li>  library functions from processor manufacturers </li><li>  making calculations on a video card </li><li>  etc. </li></ul></li></ol>  And that was still interesting.  The given driver.c program contains a vulnerability, using which, you can get acceleration tens of thousands of times, especially without straining.  Although it will already be an exploit. <br><br>  Thanks for attention. </div><p>Source: <a href="https://habr.com/ru/post/111021/">https://habr.com/ru/post/111021/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../111016/index.html">Happy New Year!</a></li>
<li><a href="../111017/index.html">UFO flew in and congratulated everyone on the upcoming new year!</a></li>
<li><a href="../111018/index.html">Hotlinks to jQuery site will be banned from January 31, 2011</a></li>
<li><a href="../111019/index.html">Pronunciation dictionaries and user generated content</a></li>
<li><a href="../111020/index.html">Duke Nukem is close!</a></li>
<li><a href="../111030/index.html">Installing Windows 7 on Macbook Air 2010 Late main and only OS</a></li>
<li><a href="../111031/index.html">Writing an icq-bot on perl</a></li>
<li><a href="../111032/index.html">Amazing letter</a></li>
<li><a href="../111035/index.html">Happy New Year!</a></li>
<li><a href="../111036/index.html">Linux: Accelerating software and RAID6 in a home server</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>