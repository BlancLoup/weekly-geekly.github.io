<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Steam Files. Part 2 - BLOB, CDR, VDF, PAK, VPK</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="After a considerable delay, I publish the continuation of the cycle of my articles. 
 For your reference: 


- Steam Protocol 2 and Steam Files - Intr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Steam Files. Part 2 - BLOB, CDR, VDF, PAK, VPK</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/000/dca/198/000dca198a459957c5d705d59a8bc514.png" alt="Steam Logo"><br><br>  After a considerable delay, I publish the continuation of the cycle of my articles. <br>  For your reference: <br><ul><li>  <a href="http://habrahabr.ru/post/223961/">Steam Protocol 2 and Steam Files - Introduction</a> </li><li>  <a href="http://habrahabr.ru/post/224027/">Steam Files.</a>  <a href="http://habrahabr.ru/post/224027/">Part 1 - GCF / NCF</a> </li></ul><br>  In this article, I will address the remaining file formats: <br><ul><li>  <a href="https://habr.com/ru/post/268921/">BLOB</a> is an obsolete data format that serves as a container for binary data.  It contained the basic parameters (IP-addresses of servers, CRD-record and much more); </li><li>  <a href="https://habr.com/ru/post/268921/">CDR (Content Description Record)</a> is a binary file containing data about applications and their cache files.  Currently not used; </li><li>  <a href="https://habr.com/ru/post/268921/">VDF</a> is a binary / text file containing a set of data and having a structure depending on the specific application.  Designed to replace BLOB and CDR; </li><li>  <a href="https://habr.com/ru/post/268921/">PAK</a> - previously used in Half-Life 1, the great legacy of Quake 1, is no longer used; </li><li>  <a href="https://habr.com/ru/post/268921/">VPK</a> - a new format of game archives inside the games themselves, is actively used at the moment.  A detailed description of the file is available on the <a href="https://developer.valvesoftware.com/wiki/VPK_File_Format">official resource</a> .  The article describes only the first version of the format. </li></ul><br>  The article is presented for reference only, since there is relatively little relevant information here, and there are almost no examples of algorithms - everything can be viewed in <a href="https://github.com/andreili/steam_libs">the previously mentioned repository</a> . <br><a name="habracut"></a><br><a name="BLOB"></a><h4>  <b>BLOB (Binary Large OBject)</b> </h4><br>  In previous versions, the Steam client was used in a single copy - ClienRegistry.blob. <br>  It has a clear tree-like structure and is read recursively until the child elements are exhausted.  It does not have separate headers - immediately there is a root node with at least 1 descendant.  <b>The format is somewhat non-linear</b> , as I will indicate below. <br><br><h6>  <b>Node Header</b> </h6><br>  Each node has 2 headers - the header of the node itself and the header of the node data. <br>  Node header format: <br><pre><code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> TBLOBNodeHeader { <span class="hljs-built_in"><span class="hljs-built_in">UINT16</span></span> Magic; <span class="hljs-built_in"><span class="hljs-built_in">UINT32</span></span> Size; <span class="hljs-built_in"><span class="hljs-built_in">UINT32</span></span> SlackSize; };</code> </pre> <br>  <i>Magic</i> - field describing the type of node.  Possible values: <br><ul><li>  0x5001 - simple node with child nodes; </li><li>  0x4301 - compressed node, you must go through the data in it as a deflate and read the headers of the received data again (here it is, nonlinearity!); </li><li>  Other values ‚Äã‚Äã(usually 0x0000) are a named node containing descendants. </li></ul><br>  <i>Size</i> - the actual size of the data stored in the node (does not include headers); <br>  <i>SlackSize</i> is the size of the data block recorded for alignment in the file. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h5>  <b>Compressed data header</b> </h5><br>  If the node was compressed, then the header of the node is followed by the header of the compressed data: <br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> TBLOBCompressedDataHeader { <span class="hljs-built_in"><span class="hljs-built_in">UINT32</span></span> UncompressedSize; <span class="hljs-built_in"><span class="hljs-built_in">UINT32</span></span> unknown1; <span class="hljs-built_in"><span class="hljs-built_in">UINT16</span></span> unknown2; };</code> </pre> <br>  <i>UncompressedSize</i> - the size of the "raw" data for which you will need to allocate memory; <br>  <i>unknown1, unknown2</i> - the destination is unknown, always equal to 0x00000001, do not affect parsing. <br>  As stated above, for data received after calling <b>uncompress</b> from ZLib, the node header should be re-read. <br><br><h5>  <b>Parsing data</b> </h5><br>  After reading the node header and, if necessary, unpacking its contents, the most fun part begins - reading the node contents.  The algorithm was optimized as much as possible, which made it difficult to understand it after such a period of time. <br>  Parsing data depends on the TBLOBNodeHeader.Magic field ‚Äî if it is 0x5001, then we immediately read the descendant nodes. <br>  Otherwise, read the header TBLOBDataHeader <br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> TBLOBDataHeader { <span class="hljs-built_in"><span class="hljs-built_in">UINT16</span></span> NameLen; <span class="hljs-built_in"><span class="hljs-built_in">UINT32</span></span> DataLen; };</code> </pre> <br>  Following this header is the node name, followed by the data. <br>  In the data, the header of the descendant node is immediately read, and depending on the type of node, branching occurs: <br><ul><li>  If 0x5001 or 0x4301 - read the new node; </li><li>  Otherwise, save as simple data. </li></ul><br><div class="spoiler">  <b class="spoiler_title">Parsing data</b> <div class="spoiler_text">  C ++ <br><pre> <code class="hljs haskell"><span class="hljs-title"><span class="hljs-title">void</span></span> <span class="hljs-type"><span class="hljs-type">CBLOBNode</span></span>::<span class="hljs-type"><span class="hljs-type">DeserializeFromMem</span></span>(char *mem) { <span class="hljs-type"><span class="hljs-type">TBLOBNodeHeader</span></span> *<span class="hljs-type"><span class="hljs-type">NodeHeader</span></span> = (<span class="hljs-type"><span class="hljs-type">TBLOBNodeHeader</span></span>*)mem; <span class="hljs-type"><span class="hljs-type">TBLOBDataHeader</span></span> *<span class="hljs-type"><span class="hljs-type">DataHeader</span></span> = (<span class="hljs-type"><span class="hljs-type">TBLOBDataHeader</span></span>*)mem; char *<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">NULL</span></span></span><span class="hljs-class">; if (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">NodeHeader</span></span></span><span class="hljs-class">-&gt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Magic</span></span></span><span class="hljs-class"> == </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">NODE_COMPRESSED_MAGIC</span></span></span><span class="hljs-class">) { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mem</span></span></span><span class="hljs-class"> += </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sizeof</span></span></span><span class="hljs-class">(</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TBLOBNodeHeader</span></span></span><span class="hljs-class">); </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TBLOBCompressedDataHeader</span></span></span><span class="hljs-class"> *</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CompressedHeader</span></span></span><span class="hljs-class"> = (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TBLOBCompressedDataHeader</span></span></span><span class="hljs-class">*)</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mem</span></span></span><span class="hljs-class">; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mem</span></span></span><span class="hljs-class"> += </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sizeof</span></span></span><span class="hljs-class">(</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TBLOBCompressedDataHeader</span></span></span><span class="hljs-class">); </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">UINT32</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">compSize</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">NodeHeader</span></span></span><span class="hljs-class">-&gt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Size</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">uncompSize</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CompressedHeader</span></span></span><span class="hljs-class">-&gt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">UncompressedSize</span></span></span><span class="hljs-class">; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">data</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">new</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">char</span></span></span><span class="hljs-class">[</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">uncompSize</span></span></span><span class="hljs-class">]; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">if</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">uncompress</span></span></span><span class="hljs-class">((</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Bytef</span></span></span><span class="hljs-class">*)</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">data</span></span></span><span class="hljs-class">, (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">uLongf</span></span></span><span class="hljs-class">*)&amp;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">uncompSize</span></span></span><span class="hljs-class">, (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Bytef</span></span></span><span class="hljs-class">*)</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mem</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">compSize</span></span></span><span class="hljs-class">) != </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Z_OK</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">return</span></span></span><span class="hljs-class">; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mem</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">data</span></span></span><span class="hljs-class">; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">NodeHeader</span></span></span><span class="hljs-class"> = (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TBLOBNodeHeader</span></span></span><span class="hljs-class">*)</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mem</span></span></span><span class="hljs-class">; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DataHeader</span></span></span><span class="hljs-class"> = (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TBLOBDataHeader</span></span></span><span class="hljs-class">*)</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mem</span></span></span><span class="hljs-class">; } if (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">NodeHeader</span></span></span><span class="hljs-class">-&gt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Magic</span></span></span><span class="hljs-class"> == </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">NODE_MAGIC</span></span></span><span class="hljs-class">) { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fIsData</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">false</span></span></span><span class="hljs-class">; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fDataSize</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">NodeHeader</span></span></span><span class="hljs-class">-&gt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Size</span></span></span><span class="hljs-class">; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fSlackSize</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">NodeHeader</span></span></span><span class="hljs-class">-&gt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SlackSize</span></span></span><span class="hljs-class">; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fChildrensCount</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GetChildrensCount(mem)</span></span></span><span class="hljs-class">; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fChildrens</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">new</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CBLOBNode</span></span></span><span class="hljs-class">*[</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fChildrensCount</span></span></span><span class="hljs-class">]; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mem</span></span></span><span class="hljs-class"> += </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sizeof</span></span></span><span class="hljs-class">(</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TBLOBNodeHeader</span></span></span><span class="hljs-class">); </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">for</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">UINT</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">i</span></span></span><span class="hljs-class">=0 ; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">i</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fChildrensCount</span></span></span><span class="hljs-class"> ; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">i</span></span></span><span class="hljs-class">++) { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fChildrens</span></span></span><span class="hljs-class">[</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">i</span></span></span><span class="hljs-class">] = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">new</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CBLOBNode</span></span></span><span class="hljs-class">(); </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fChildrens</span></span></span><span class="hljs-class">[</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">i</span></span></span><span class="hljs-class">]-&gt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DeserializeFromMem(mem)</span></span></span><span class="hljs-class">; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">NodeHeader</span></span></span><span class="hljs-class"> = (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TBLOBNodeHeader</span></span></span><span class="hljs-class">*)</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mem</span></span></span><span class="hljs-class">; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DataHeader</span></span></span><span class="hljs-class"> = (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TBLOBDataHeader</span></span></span><span class="hljs-class">*)</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mem</span></span></span><span class="hljs-class">; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">if</span></span></span><span class="hljs-class"> ((</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">NodeHeader</span></span></span><span class="hljs-class">-&gt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Magic</span></span></span><span class="hljs-class"> == </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">NODE_MAGIC</span></span></span><span class="hljs-class">) || (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">NodeHeader</span></span></span><span class="hljs-class">-&gt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Magic</span></span></span><span class="hljs-class"> == </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">NODE_COMPRESSED_MAGIC</span></span></span><span class="hljs-class">)) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mem</span></span></span><span class="hljs-class"> += </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">NodeHeader</span></span></span><span class="hljs-class">-&gt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Size</span></span></span><span class="hljs-class"> + </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">NodeHeader</span></span></span><span class="hljs-class">-&gt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SlackSize</span></span></span><span class="hljs-class">; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">else</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mem</span></span></span><span class="hljs-class"> += </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sizeof</span></span></span><span class="hljs-class">(</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TBLOBDataHeader</span></span></span><span class="hljs-class">) + </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DataHeader</span></span></span><span class="hljs-class">-&gt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DataLen</span></span></span><span class="hljs-class"> + </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DataHeader</span></span></span><span class="hljs-class">-&gt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">NameLen</span></span></span><span class="hljs-class">; } } else { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fIsData</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">true</span></span></span><span class="hljs-class">; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fNameLen</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DataHeader</span></span></span><span class="hljs-class">-&gt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">NameLen</span></span></span><span class="hljs-class">; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fDataSize</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DataHeader</span></span></span><span class="hljs-class">-&gt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DataLen</span></span></span><span class="hljs-class">; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mem</span></span></span><span class="hljs-class"> += </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sizeof</span></span></span><span class="hljs-class">(</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TBLOBDataHeader</span></span></span><span class="hljs-class">); </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fName</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">new</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">char</span></span></span><span class="hljs-class">[</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fNameLen</span></span></span><span class="hljs-class">+1]; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">memcpy</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fName</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mem</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fNameLen</span></span></span><span class="hljs-class">); </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fName</span></span></span><span class="hljs-class">[</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fNameLen</span></span></span><span class="hljs-class">] = '\</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x00'</span></span></span><span class="hljs-class">; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mem</span></span></span><span class="hljs-class"> += </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fNameLen</span></span></span><span class="hljs-class">; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">UINT16</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">node</span></span></span><span class="hljs-class">; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">memcpy</span></span></span><span class="hljs-class">(&amp;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">node</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mem</span></span></span><span class="hljs-class">, 2); </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">if</span></span></span><span class="hljs-class"> ((</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">node</span></span></span><span class="hljs-class"> == </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">NODE_MAGIC</span></span></span><span class="hljs-class">) || (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">node</span></span></span><span class="hljs-class"> == </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">NODE_COMPRESSED_MAGIC</span></span></span><span class="hljs-class">)) { </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DeserializeFromMem(mem)</span></span></span><span class="hljs-class">; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fData</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">NULL</span></span></span><span class="hljs-class">; } else { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fData</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">new</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">char</span></span></span><span class="hljs-class">[</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fDataSize</span></span></span><span class="hljs-class">]; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">memcpy</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fData</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mem</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fDataSize</span></span></span><span class="hljs-class">); } } if (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">data</span></span></span><span class="hljs-class"> != </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">NULL</span></span></span><span class="hljs-class">) delete </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class">; }</span></span></code> </pre> <br>  Delphi <br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TBLOBNode</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DeserializeFromMem</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Mem: pByte)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> NodeHeader: pBLOBNodeHeader; DataHeader: pBLOBDataHeader; CompressedHeader: TBLOBCompressedDataHeader; compSize, uncompSize: uint32; Data: Pointer; ChildrensCount, i: integer; <span class="hljs-comment"><span class="hljs-comment">//str: TStream; begin NodeHeader:=pBLOBNodeHeader(Mem); DataHeader:=pBLOBDataHeader(Mem); Data:=nil; if (NodeHeader^.Magic=NODE_COMPRESSED_MAGIC) then begin inc(Mem, sizeof(TBLOBNodeHeader)); Move(Mem^, CompressedHeader, sizeof(TBLOBCompressedDataHeader)); inc(Mem, sizeof(TBLOBCompressedDataHeader)); compSize:=NodeHeader^.Size-sizeof(TBLOBNodeHeader)-sizeof(TBLOBCompressedDataHeader); uncompSize:=CompressedHeader.UncompressedSize; GetMem(Data, uncompSize); uncompress(Data, uncompSize, Mem, compSize); Mem:=Data; NodeHeader:=pBLOBNodeHeader(Mem); DataHeader:=pBLOBDataHeader(Mem); { Str:=TStream.CreateWriteFileStream('.\dr.unc'); str.Write(Mem^, uncompSize); str.Free; } end; if (NodeHeader^.Magic=NODE_MAGIC) then begin fIsData:=false; fDataLen:=NodeHeader^.Size; fSlackLen:=NodeHeader^.StackSize; {if fSlackLen&lt;&gt;0 then Writeln(fSlackLen);} ChildrensCount:=GetChildrensCount(Mem); SetLength(fChildrens, ChildrensCount); inc(Mem, sizeof(TBLOBNodeHeader)); for i:=0 to ChildrensCount-1 do begin fChildrens[i]:=TBLOBNode.Create(); fChildrens[i].DeserializeFromMem(Mem); NodeHeader:=pBLOBNodeHeader(Mem); DataHeader:=pBLOBDataHeader(Mem); if (NodeHeader^.Magic=NODE_MAGIC) or (NodeHeader^.Magic=NODE_COMPRESSED_MAGIC) then inc(Mem, NodeHeader^.Size+NodeHeader^.StackSize) else inc(Mem, sizeof(TBLOBDataHeader)+DataHeader^.NameLen+DataHeader^.DataLen); end; end else begin fIsData:=true; fNameLen:=DataHeader^.NameLen; fDataLen:=DataHeader^.DataLen; inc(Mem, sizeof(TBLOBDataHeader)); SetLength(fName, fNameLen); Move(Mem^, fName[1], fNameLen); inc(Mem, fNameLen); {if (fDataLen=160) and (fName=AnsiString(#0#0#0#0)) and (puint16(Mem)^&lt;&gt;NODE_MAGIC) then writeln(''); } if (puint16(Mem)^=NODE_MAGIC) or (puint16(Mem)^=NODE_COMPRESSED_MAGIC) then begin DeserializeFromMem(Mem); fData:=nil; end else begin GetMem(fData, fDataLen); Move(Mem^, fData^, fDataLen); end; end; if Data&lt;&gt;nil then FreeMem(Data, uncompSize); end;</span></span></code> </pre> <br></div></div><br><br><a name="CDR"></a><h5>  <b>CDR (Content Description Record)</b> </h5><br>  It is contained in a BLOB container and has several main descendants in the root node, the location of which is rigidly spelled out (similarly for descendants): <br><ul><li>  0 - file version (number, 16 bits); </li><li>  1 - application records; </li><li>  2 - description of application packages; </li><li>  3, 4 - the assignment is not defined, so they are simply ignored; </li><li>  5 - public application keys; </li><li>  6 - encrypted private keys. </li></ul><br><div class="spoiler">  <b class="spoiler_title">Many well, very boring and long transfers, you can not even read.</b>  <b class="spoiler_title">The purpose of the fields is still unclear.</b> <div class="spoiler_text"><h6>  <b>Application recordings</b> </h6><br>  Fields (also BLOB nodes, by index): <br><ul><li>  1 - application ID; </li><li>  2 - the name of the application; </li><li>  3 - Application catalog; </li><li>  4 - Minimum cache file size; </li><li>  5 - Maximum cache file size; </li><li>  6 - Contains a list of launch parameters; </li><li>  7 - Contains a list of application icons; </li><li>  8 - application ID.  which must be run when you first start; </li><li>  9 - flag Is Bandwidth Greedy; </li><li>  10 - List of application versions; </li><li>  11 - ID of the current version of the application; </li><li>  12 - List of application cache files; </li><li>  13 - Test version number; </li><li>  14 - Additional fields in the form of a list of name-value pairs; </li><li>  15 - test version password; </li><li>  16 - ID of the test version; </li><li>  17 - The original game folder; </li><li>  18 - SkipMFPOverwrite Flag; </li><li>  19 - UseFilesystemDvr flag. </li></ul><br>  Launch parameters: <br><ul><li>  1 - Description; </li><li>  2 - Command line parameters; </li><li>  3 - Icon number; </li><li>  4 - Flag, responsible for the lack of a shortcut on the desktop; </li><li>  5 - Flag, responsible for the lack of a shortcut in the Start menu; </li><li>  6 - Flag Long Running Unattended. </li></ul><br>  Application Versions: <br><ul><li>  1 - Description of the version; </li><li>  2 - Version number; </li><li>  3 - Flag responsible for the inaccessibility of the application of this version; </li><li>  4 - List of launch parameter IDs for this version; </li><li>  5 - Decryption key for content; </li><li>  6 - Flag indicating the presence of the decryption key; </li><li>  7 - IsRebased flag; </li><li>  8 - Flag IsLongVersionRoll. </li></ul><br>  Application cache files: <br><ul><li>  1 - cache file ID; </li><li>  2 - The name of the cache file to be mounted; </li><li>  3 - Flag responsible for the optional cache file. </li></ul><br><h6>  <b>Application Package Description</b> </h6><br>  1 - package ID; <br>  2 - Package name; <br>  3 - Package type; <br>  4 - Price in cents; <br>  5 - There is a period in minutes; <br>  6 - List of application IDs of this package; <br>  7 - ID of the application being launched (WTF?); <br>  8 - OnSubscribeRunLaunchOptionIndex flag; <br>  9 - RateLimitRecord List; <br>  10 - Discounts list; <br>  11 - Pre-order flag; <br>  12 - Flag indicating the requirement for the physical address of the buyer; <br>  13 - Domestic price in cents; <br>  14 - International price in cents; <br>  15 - Type of key required; <br>  16 - Flag indicating that this package is only for cybercafes; <br>  17 - Some game code; <br>  18 - Description of this code; <br>  19 - Package unavailable flag; <br>  20 - Flag of the requirement of the disc with the game; <br>  21 - Area Code.  on which this game is available; <br>  22 - Flag indicating that the package is available in version 3; <br>  23 - Additional fields in the form of a list of name-value pairs. <br></div></div><br><a name="VDF"></a><h5>  <b>Vdf</b> </h5><br>  The client's settings are stored in files of this format, and in the current versions there is also information about the applications.  It can be either binary or text file. <br>  Like BLOB, it has a tree structure. <br>  Consider a binary file.  There are several types of files that differ in structure and headers, but the format of the nodes is the same. <br><br>  Each node begins with a byte describing the type of the node, followed by a NULL-terminated string with the name of the node. <br>  Types of nodes: <br><ul><li>  0 - contains only subnodes; </li><li>  1 - string data; </li><li>  2 is an integer; </li><li>  3 - fractional number; </li><li>  4 - pointer (to what ??); </li><li>  5 - Unicode string; </li><li>  6 - color; </li><li>  7 is a 64-bit integer number; </li><li>  8 - marker of the end of the list of nodes. </li></ul><br>  In the case of reading a list of descendant nodes, the nodes are read until the type is equal to 8 <br><br>  Consider the basic binary files that use the binary version of the VDF format. <br><br><h6>  <b>appcache / appinfo.vdf</b> </h6><br>  First comes the headline with the following content: <br><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TVDFHeader</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> version1; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> type; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> version2; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> version3; };</code> </pre> <br>  The fields <i>version1</i> and <i>version2 were</i> previously considered as part of the signature, but over time they changed - they used to be equal to 0x24 and 0x06, now equal to 0x26 and 0x07, respectively. <br>  The <i>type</i> field is a signature and contains 0x4456 ('DV'). <br>  The <i>version3</i> field always contains 0x00000001. <br><br>  After the title comes a list with information about the application, each element of which has its own title: <br><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TVDFAppHeader</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> AppID; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> DataSize; };</code> </pre> <br>  The header is followed by a list of node parameters containing 1 byte of the end of list (0x00 if the end) and the VDF tree element. <br><br><h6>  <b>appcache / packageinfo.vdf</b> </h6><br>  The title is similar to the previous one, only the first 3 fields are different: <br><ul><li>  <i>version1</i> and <i>version2</i> previously contained 0x25 and 0x06, now - 0x27 and 0x06; </li><li>  <i>type</i> - 0x5556 ('UV'). </li></ul><br>  Following the header is a list of nodes describing application packages.  Before each element of the list is a 4-byte number, which is equal to 0xFFFFFFFF, if the end of the list is reached. <br><br>  <a href="http://pastebin.com/4ppNw1yg">Sample text VDF file</a> . <br><br><a name="PAK"></a><h4>  <b>PAK</b> </h4><br>  The legacy archive format used in the first versions of Half-Life 1. No compression, it‚Äôs just a container for files. <br>  File Header: <br><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TPAKHeader</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> Sign[<span class="hljs-number"><span class="hljs-number">4</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> DirectoryOffset; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> DirectoryLength; };</code> </pre> <br>  <i>Sign</i> - the signature contains 'PACK'. <br>  <i>DirectoryOffset</i> - offset of the beginning of the list of items. <br>  <i>DirectoryLength</i> - the size of the list of items. <br><br>  At the specified offset is an array of headers for the elements contained in the archive: <br><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TPAKDirectoryItem</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> ItemName[<span class="hljs-number"><span class="hljs-number">56</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> ItemOffset; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> ItemLength; };</code> </pre> <br>  I think there is no need to describe anything, everything is clear. <br><br><a name="VPK"></a><h4>  <b>VPK</b> </h4><br>  The format of the game file archives, presented as a set of files, one of which contains a description of the location of the files, while the others contain the files themselves.  The root file has a name of the form "&lt;archive name&gt; _dir.vpk", and the rest - "&lt;archive name&gt; _ &lt;archive number&gt; .vpk". <br>  Consider the structure of the root file, starting with the following header: <br><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TVPKHeader</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> Signature; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> PaksCount; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> DirSize; }</code> </pre> <br>  <i>Signature</i> - always contains 0x55aa1234. <br>  <i>PaksCount</i> - the number of archives with the contents of files; <br>  <i>DirSize</i> - the size of the data with the meta-information about the files. <br><br>  The header is followed by a hierarchical list with items.  Moreover, the list structure is ordered by file extensions and paths to them. <br>  That is, first there is a NULL-terminated string with a file extension, then a NULL-terminated string with a path where there are such files, followed by a NULL-terminated string file name (without extension) with information about the file.  The end of each list level is an empty line. <br><div class="spoiler">  <b class="spoiler_title">Pseudo-structure example, only string part</b> <div class="spoiler_text">  bsp <br>  hl2 / maps <br>  map1 <br>  map2 <br>  map3 <br><br>  wav <br>  sound / amb <br>  amb1 <br>  amb2 <br><br>  sound / voice <br>  voice1 <br>  voice2 <br></div></div><br>  File Information Format: <br><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TVPKDirectoryEntry</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> CRC; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> PreloadBytes; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> ArchiveIndex; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> EntryOffset <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> EntryLength <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> Dummy1; };</code> </pre> <br>  <i>CRC</i> - file checksum; <br>  <i>PreloadBytes</i> - the size of the data at the beginning of the file contained in the root file after this structure; <br>  <i>ArchiveIndex</i> - archive number with these files; <br>  <i>EntryOffset</i> - data offset inside the archive; <br>  <i>EntryLength</i> - data size. <br><h4>  Conclusion </h4><br>  This is the complete description of all the Steam file formats that I opened myself or with the help of materials from the cs.rin.ru forum (yes, that's exactly where the most ardent English-speaking no-Steam activists are still sitting).  Only having finished this article, I realized that it could be safely incorporated into the previous one - the volume would not have increased much, and a small stump would hang like this ... <br>  Well, nothing, in the next article I will describe how Steam works with all servers (root, authentication, content, etc.).  The already outdated SteamNetwork2 protocol will be considered (the 3rd version based on HTTPS is currently running). </div><p>Source: <a href="https://habr.com/ru/post/268921/">https://habr.com/ru/post/268921/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../268907/index.html">Security Week 42: SHA-1 collisions, practical hacking of routers, Android / Security / Sadness</a></li>
<li><a href="../268909/index.html">CRM is a mockingbird. We integrate amoCRM, telephony and cellular communication</a></li>
<li><a href="../268911/index.html">Interview with Audrey Tan, Part 1</a></li>
<li><a href="../268915/index.html">Accordion about architecture and localization</a></li>
<li><a href="../268917/index.html">Visualization of static and dynamic networks on R, part 6</a></li>
<li><a href="../268923/index.html">Modifying the Vanilla Music Player for Android</a></li>
<li><a href="../268925/index.html">From participating in the hackathon to winning the Imagine Cup</a></li>
<li><a href="../268929/index.html">Event-oriented Python backtesting step by step. Part 4</a></li>
<li><a href="../268931/index.html">5 internships for programmers abroad</a></li>
<li><a href="../268933/index.html">Megahakaton IoT Russia from Intel and Microsoft</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>