<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>NRF51822: we are friends of BLE and RTOS</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Modern trends in technology are on the path of increasing integration - progress allows the development process of electronic devices to become more a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>NRF51822: we are friends of BLE and RTOS</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/62/jb/af/62jbafkybd2ospeqfnfzdy4rxha.jpeg"><br><br>  Modern trends in technology are on the path of increasing integration - progress allows the development process of electronic devices to become more and more similar to the assembly of the designer.  One of the most striking examples is the huge number of so-called "systems on a chip" - SoC, a bunch of microcontrollers and peripherals for almost every taste.  Today, we will look at one of these systems, the NRF51822 chip from Nordic Semiconductor - a solution for systems designed to work with BLE technology included in the Bluetooth 4.0 standard. <br><br>  And since electronic devices are increasingly increasing the level of integration, why not programming to rise to a higher level of abstraction and make a Bluetooth application running a real-time operating system - RTOS. <br>  Our goal in this article is to make a simple embedded application for the NRF51822 running the RTOS Keil-RTX that will poll the ADC once a second and record the values ‚Äã‚Äãobtained in the BLE characteristics.  If you are interested in this topic - welcome under cat. <br><a name="habracut"></a><br><h1>  Briefly about RTOS and BLE </h1><br>  A lot has already been said about RTOS, so in order not to repeat, I advise you to read about it <a href="https://habrahabr.ru/post/208780/">here</a> and <a href="https://ru.wikipedia.org/wiki/%25D0%259E%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B0%25D1%2586%25D0%25B8%25D0%25BE%25D0%25BD%25D0%25BD%25D0%25B0%25D1%258F_%25D1%2581%25D0%25B8%25D1%2581%25D1%2582%25D0%25B5%25D0%25BC%25D0%25B0_%25D1%2580%25D0%25B5%25D0%25B0%25D0%25BB%25D1%258C%25D0%25BD%25D0%25BE%25D0%25B3%25D0%25BE_%25D0%25B2%25D1%2580%25D0%25B5%25D0%25BC%25D0%25B5%25D0%25BD%25D0%25B8">here</a> .  Of the important features of using RTOS, I would like to note only that they allow you to very easily increase the functionality of the program without adding confusion to the code.  This is possible due to the fact that certain parts of the program can work conditionally at the same time without interfering with each other and can be executed as isolated blocks.  And if we make an application for a ‚Äúsystem on a chip‚Äù, which is guaranteed to perform a large number of different sorts of tasks, many of which are time-consuming, then using RTOS can greatly simplify our lives. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      About what BLE is and how it works, there is a wonderful <a href="https://habrahabr.ru/post/319244/">series of articles</a> , which, among other things, helped me to understand some things.  If you have not read - be sure to read.  Within the framework of this article, we are more interested in practical nuances of working with this technology. <br><br>  Generally speaking, writing ‚Äúwe are friends of BLE and RTOS‚Äù, I allowed myself to listen a little, because in a sense these two concepts get along very well even without our participation.  The fact is that the Bluetooth stack that we use in the controller to work with the BLE standard is in itself a kind of RTOS, in which there are tasks, the controller for these tasks, timers ticking and events occur in it.  Therefore, in my personal opinion, the use of RTOS in BLE applications will be a good tone, since this will allow the application as a whole to one level of abstraction. <br><br><h1>  Required Tools </h1><br>  In order not to touch on the basic issues of launching NRF51, we will rely on the articles of Comrade <a href="https://habrahabr.ru/users/foxek/" class="user_link">Foxek</a> , therefore we will need the same tools: <br><br>  ‚Ä¢ NRF51 debug board <br>  ‚Ä¢ Smartphone running Android OS <br>  ‚Ä¢ Android nRF Connect application <br>  ‚Ä¢ MKD ARM Keil uVision <br><br><h1>  RTOS configuration </h1><br>  We start classically - we will load the ble_app_template template project using the Pack Installer (for details on this step, see <a href="https://habrahabr.ru/post/343166/">nRF51822 Quick Start</a> ) and add the necessary dependencies using the Run-Time Environment Manager after downloading them to the <a href="https://habrahabr.ru/post/343166/">Instal Instal</a> -e Pack: <br><br><img src="https://habrastorage.org/webt/8i/gw/pe/8igwpecp1okdh9oi63qnniobsgq.png"><br><br>  So we added RTOS to our project.  Now, in order for it to interact with the hardware, it is necessary to make some tuning.  CMSIS-RTOS is well adapted to work with Cortex-M core processors and, as a rule, uses the SysTick system timer for time slicing in the OS.  However, the NRF51 controller has a Cortex-M0 core on its board and does not have a SysTick timer, so the manufacturer <a href="https://infocenter.nordicsemi.com/index.jsp%3Ftopic%3D%252Fcom.nordic.infocenter.sdk51.v9.0.0%252Frtx.html">recommends</a> using the RTC1 real-time clock for clocking the RTOS.  On the one hand, such a solution is a plus, since RTC1 does not turn off in the controller's sleep mode, which means we can build an application with very low consumption under RTOS control.  On the other hand, the RTC blocks are clocked with a frequency of only 32768 Hz, which means that the size of the system time quantum will not work out to be sufficiently small. <br><br>  <b>UPD.</b>  In the Run-Time Environment Manager, in the nRF_Libraries tab for the app_timer module, select the Rtx option.  Otherwise, there will be a conflict with the multiple definition of the RTC1 interrupt handler. <br><br>  In order to make our OS understand which timer it works with, we need to add several functions: timer initialization and a couple of event handlers and timer interrupts.  To do this, open the RTX_Conf_CM.c file from the CMSIS tab, <br><br><img src="https://habrastorage.org/webt/rm/p2/qw/rmp2qw2sqxv6ppu-8xevdxuzxt4.png"><br><br>  Add the header file nrf.h to it, find the Global Functions section and replace the contents of the functions in it with the following: <br><br><div class="spoiler">  <b class="spoiler_title">Source</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/*---------------------------------------------------------------------------- * Global Functions *---------------------------------------------------------------------------*/</span></span> <span class="hljs-comment"><span class="hljs-comment">/*--------------------------- os_idle_demon ---------------------------------*/</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TIMER_MASK 0xFFFFFF volatile unsigned int rtos_suspend; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/// \brief The idle demon is running when no other thread is ready to run void os_idle_demon (void) { unsigned int expected_time; unsigned int prev_time; NVIC_SetPriority(PendSV_IRQn, NVIC_GetPriority(RTC1_IRQn)); for (;; ) { rtos_suspend = 1; expected_time = os_suspend(); expected_time &amp;= TIMER_MASK; if (expected_time &gt; 2) { prev_time = NRF_RTC1-&gt;COUNTER; expected_time += prev_time; NRF_RTC1-&gt;CC[0] = (expected_time &gt; TIMER_MASK) ? expected_time - TIMER_MASK : expected_time; NRF_RTC1-&gt;INTENCLR = RTC_INTENSET_TICK_Msk; NVIC_EnableIRQ(RTC1_IRQn); __disable_irq(); if (rtos_suspend) { NRF_RTC1-&gt;INTENSET = RTC_INTENSET_COMPARE0_Msk; __WFI(); NRF_RTC1-&gt;EVENTS_COMPARE[0] = 0; NRF_RTC1-&gt;INTENCLR = RTC_INTENSET_COMPARE0_Msk; } __enable_irq(); NRF_RTC1-&gt;INTENSET = RTC_INTENSET_TICK_Msk; expected_time = NRF_RTC1-&gt;COUNTER; expected_time = (expected_time &gt;= prev_time) ? expected_time - prev_time : TIMER_MASK - prev_time + expected_time; } os_resume(expected_time); } } #if (OS_SYSTICK == 0) // Functions for alternative timer as RTX kernel timer /*--------------------------- os_tick_init ----------------------------------*/ /// \brief Initializes an alternative hardware timer as RTX kernel timer /// \return IRQ number of the alternative hardware timer int os_tick_init (void) { NRF_CLOCK-&gt;LFCLKSRC = (CLOCK_LFCLKSRC_SRC_Xtal &lt;&lt; CLOCK_LFCLKSRC_SRC_Pos); NRF_CLOCK-&gt;EVENTS_LFCLKSTARTED = 0; NRF_CLOCK-&gt;TASKS_LFCLKSTART = 1; while (NRF_CLOCK-&gt;EVENTS_LFCLKSTARTED == 0) { // Do nothing. } NRF_RTC1-&gt;PRESCALER = 32;//OS_TRV; NRF_RTC1-&gt;INTENSET = RTC_INTENSET_TICK_Msk; NRF_RTC1-&gt;TASKS_START = 1; return (RTC1_IRQn); /* Return IRQ number of timer (0..239) */ } /*--------------------------- os_tick_val -----------------------------------*/ /// \brief Get alternative hardware timer's current value (0 .. OS_TRV) /// \return Current value of the alternative hardware timer uint32_t os_tick_val (void) { return NRF_RTC1-&gt;COUNTER; } /*--------------------------- os_tick_ovf -----------------------------------*/ /// \brief Get alternative hardware timer's overflow flag /// \return Overflow flag\n /// - 1 : overflow /// - 0 : no overflow uint32_t os_tick_ovf (void) { return NRF_RTC1-&gt;EVENTS_OVRFLW; } /*--------------------------- os_tick_irqack --------------------------------*/ /// \brief Acknowledge alternative hardware timer interrupt void os_tick_irqack (void) { if ((NRF_RTC1-&gt;EVENTS_TICK != 0) &amp;&amp; ((NRF_RTC1-&gt;INTENSET &amp; RTC_INTENSET_TICK_Msk) != 0)) { NRF_RTC1-&gt;EVENTS_TICK = 0; } } #if defined (__CC_ARM) /* ARM Compiler */ __asm __declspec(noreturn) void RTC1_IRQHandler(void) { EXTERN OS_Tick_Handler BL OS_Tick_Handler } #else #error "Unknown compiler! Don't know how to create SVC function." #endif #endif // (OS_SYSTICK == 0)</span></span></span></span></code> </pre> <br><br></div></div><br>  The os_idle_demon () function is responsible just for the work of the system when using power saving modes - if our application is not busy with any task, then the system itself puts the controller to sleep. <br><br>  Next, we say to our system that we will not use SysTick, because for this we already have all the functions, well, at the same time, let's say with what frequency the clocking works and how we want to quantize the system time.  To do this, open the configuration utility in the same RTX_Conf_CM.c file and set the appropriate system parameters for us: <br><br><img src="https://habrastorage.org/webt/hk/cv/hc/hkcvhcbp0kgrrwaeonpw85schpc.png"><br><br>  The interval between system counts of 10ms was not chosen by chance: if at a clock frequency of 32768 Hz we use the prescaler 327, then the timer frequency will turn out to be 99.9 Hz, which at least with some acceptable accuracy will ensure the system timings.  If it is necessary to use smaller values ‚Äã‚Äãfor this interval, then you can pick up such values ‚Äã‚Äãthat will give acceptable accuracy (for example, divisor 31 and interval length 977 Œºs), but these will be non-circular numbers, which introduces some confusion in the code.  Also, let's create streams with a non-standard stack size, allocate memory for these streams and tick the watermark for the stack - this will make debugging more intuitive. <br><br>  At this stage, you can try to collect and download the program to the controller.  The operating system will start and start executing the main function as its only thread.  However, the meaning of RTOS is that different tasks are spinning in different streams, so now we will create our own stream for our BLE stack: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//      ble_stack_thread osPoolDef(ble_evt_pool, 8, ble_evt_t); //   osPoolId ble_evt_pool; //    osMessageQDef(ble_stack_msg_box, 8, ble_evt_t); //    osMessageQId ble_stack_msg_box; //     osThreadId ble_stack_thread_id; //      void ble_stack_thread(void const * arg); //     osThreadDef (ble_stack_thread, osPriorityAboveNormal, 1, 400);</span></span></code> </pre> <br>  Here we defined the memory pool to be used by the stack, the mailbox through which the stack will receive messages from the system, as well as the thread itself, declared its number and the function in which it will be executed.  Now it remains to determine what the thread itself will do, as well as to declare the function of its creation in the system and the stack event handler: <br><br><div class="spoiler">  <b class="spoiler_title">Source</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//     BLE void ble_stack_thread(void const * arg) { uint32_t err_code; osEvent evt; ble_evt_t * p_ble_evt; UNUSED_PARAMETER(arg); while (1) { evt = osMessageGet(ble_stack_msg_box, osWaitForever); // wait for message if (evt.status == osEventMessage) { p_ble_evt = evt.value.p; switch (p_ble_evt-&gt;header.evt_id) { case BLE_GAP_EVT_CONNECTED: err_code = bsp_indication_set(BSP_INDICATE_CONNECTED); APP_ERROR_CHECK(err_code); m_conn_handle = p_ble_evt-&gt;evt.gap_evt.conn_handle; break; case BLE_GAP_EVT_DISCONNECTED: m_conn_handle = BLE_CONN_HANDLE_INVALID; break; default: // No implementation needed. break; } (void)osPoolFree(ble_evt_pool, p_ble_evt); } } } //      BLE void ble_create_thread (void) { ble_evt_pool = osPoolCreate(osPool(ble_evt_pool)); ble_stack_msg_box = osMessageCreate(osMessageQ(ble_stack_msg_box), NULL); ble_stack_thread_id = osThreadCreate(osThread(ble_stack_thread), NULL); }</span></span></code> </pre> <br></div></div><br>  As you can see, the standard function of the on_ble_evt event handler is replaced with a simple message transfer to the stream, within which the logic that the handler used to perform has already been organized. <br><br>  To register a stream in the system, we will create a function that creates a memory pool and a mailbox, and then creates a stream and registers it with an identifier, which we declared a little earlier.  It remains only to add this all to main and run: <br><br><div class="spoiler">  <b class="spoiler_title">Source</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> err_code; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> erase_bonds; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> osStatus status; <span class="hljs-comment"><span class="hljs-comment">//   status = osKernelInitialize(); //  timers_init(); ble_stack_init(); device_manager_init(erase_bonds); gap_params_init(); advertising_init(); services_init(); conn_params_init(); //     err_code = ble_advertising_start(BLE_ADV_MODE_FAST); APP_ERROR_CHECK(err_code); ble_create_thread(); //   status = osKernelStart(); }</span></span></code> </pre><br></div></div><br>  Pay attention to the functions osKernelInitialize () and osKernelStart () - since main is already a stream, by the time it enters it RTOS is already running.  However, it is better to create streams and configure all peripherals on a stopped OS, so the first function is to pause and the second run back to work. <br><br>  In addition, I deleted everything that concerns bsp_ble from the project, since this library is trying to interfere with the work of the stack bypassing RTOS, but we don‚Äôt want to do that at all.  I also removed the main loop from main itself, since main is a thread and after all initializations we don‚Äôt have to keep its memory reserved.  Therefore, the main is completed, and the system continues to work, such miracles. <br><br>  Now you can build the program, download it to the controller and connect to our device using the nRF Connect program: <br><br><img src="https://habrastorage.org/webt/k0/3k/fx/k03kfxfr1x2agc3dlxo1jj28icu.png"><br><br>  As we see, we still do not have a single service, so it's time to fix it.  As you remember, we were going to read data from the ADC and write it into the service characteristic.  In order not to repeat and build my own bike, I will take the template for creating services and features <a href="https://habrahabr.ru/post/343166/">from here</a> . <br><br><div class="spoiler">  <b class="spoiler_title">Source</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//    void services_init(void) { ble_uuid_t ble_uuid; /*  128 -  UUID */ ble_uuid128_t base_uuid = ADC_BASE_UUID; uint8_t uuid_type; ble_uuid.type = BLE_UUID_TYPE_VENDOR_BEGIN; ble_uuid.uuid = ADC_SERVICE_UUID; sd_ble_uuid_vs_add(&amp;base_uuid, &amp;ble_uuid.type); sd_ble_gatts_service_add(BLE_GATTS_SRVC_TYPE_PRIMARY, &amp;ble_uuid, &amp;adc_handles); } /*    * UUID -   * handles -    (  ) * n_bytes -    * iswrite, isnotf, isread -   , ,  */ uint32_t char_add(uint16_t UUID, ble_gatts_char_handles_t * handles, uint8_t n_bytes, bool iswrite, bool isnotf, bool isread) { ble_gatts_char_md_t char_md; ble_gatts_attr_md_t cccd_md; ble_gatts_attr_t attr_char_value; ble_uuid_t char_uuid; ble_gatts_attr_md_t attr_md; memset(&amp;cccd_md, 0, sizeof(cccd_md)); BLE_GAP_CONN_SEC_MODE_SET_OPEN(&amp;cccd_md.read_perm); BLE_GAP_CONN_SEC_MODE_SET_OPEN(&amp;cccd_md.write_perm); cccd_md.vloc = BLE_GATTS_VLOC_STACK; memset(&amp;char_md, 0, sizeof(char_md)); char_md.char_props.notify = isnotf; //   ; char_md.char_props.write = iswrite; //   ; char_md.char_props.read = isread; //   ; char_md.p_char_user_desc = NULL; char_md.p_char_pf = NULL; char_md.p_user_desc_md = NULL; char_md.p_cccd_md = &amp;cccd_md; char_md.p_sccd_md = NULL; /*  UUID - 128 -  */ char_uuid.type = BLE_UUID_TYPE_VENDOR_BEGIN; char_uuid.uuid = UUID; memset(&amp;attr_md, 0, sizeof(attr_md)); BLE_GAP_CONN_SEC_MODE_SET_OPEN(&amp;attr_md.read_perm); BLE_GAP_CONN_SEC_MODE_SET_OPEN(&amp;attr_md.write_perm); attr_md.vloc = BLE_GATTS_VLOC_STACK; attr_md.rd_auth = 0; attr_md.wr_auth = 0; attr_md.vlen = 0; attr_char_value.p_uuid = &amp;char_uuid; attr_char_value.p_attr_md = &amp;attr_md; attr_char_value.init_len = n_bytes; attr_char_value.init_offs = 0; attr_char_value.max_len = n_bytes; //  ; attr_char_value.p_value = NULL; //   ; /*     */ sd_ble_gatts_characteristic_add(adc_handles, &amp;char_md, &amp;attr_char_value, handles); return 0; }</span></span></code> </pre><br></div></div><br>  Here, ADC_BASE_UUID and ADC_SERVICE_UUID are a composite service identifier, set in this form: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/*  UUID (  UUID    ) */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> ADC_BASE_UUID {0x66, 0x9A, 0x0C, 0x20, 0x00, 0x08, 0x1A, 0x8F, 0xE7, 0x11, 0x61, 0xBE, 0x00, 0x00, 0x00, 0x00} </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*  UUID (  UUID    ) */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> ADC_SERVICE_UUID 0x1533 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> ADC_CHAR_UUID 0x1534</span></span></code> </pre><br>  Great, now we have a service with one characteristic, which contains 1 byte of data.  It remains only to fill this byte with useful information, so we turn to the <a href="https://habrahabr.ru/post/345396/">article</a> and initialize the ADC, which will perform the conversion once a second and add a function that will update the content of the characteristic: <br><br><div class="spoiler">  <b class="spoiler_title">Source</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//    void ADC_init (void) { //  2       8  NRF_ADC-&gt;CONFIG = 0x00; NRF_ADC-&gt;CONFIG |= (ADC_CONFIG_RES_8bit &lt;&lt; ADC_CONFIG_RES_Pos)| (ADC_CONFIG_INPSEL_AnalogInputOneThirdPrescaling &lt;&lt; ADC_CONFIG_INPSEL_Pos)| (ADC_CONFIG_PSEL_AnalogInput2 &lt;&lt; ADC_CONFIG_PSEL_Pos); NRF_ADC-&gt;INTENSET |= ADC_INTENSET_END_Enabled &lt;&lt; ADC_INTENSET_END_Pos; NRF_ADC-&gt;ENABLE |= ADC_ENABLE_ENABLE_Enabled &lt;&lt; ADC_ENABLE_ENABLE_Pos; //     NVIC_SetPriority(ADC_IRQn, 1); NVIC_EnableIRQ(ADC_IRQn); //      NRF_TIMER1-&gt;POWER = 1; NRF_TIMER1-&gt;MODE = TIMER_MODE_MODE_Timer &lt;&lt; TIMER_MODE_MODE_Pos; NRF_TIMER1-&gt;PRESCALER = 10; // 16 MHz / 2^10 = 15625 Hz NRF_TIMER1-&gt;CC[0] = 15625; // 15625 Hz / 15625 = 1 Hz NRF_TIMER1-&gt;INTENSET = (TIMER_INTENSET_COMPARE1_Enabled &lt;&lt; TIMER_INTENSET_COMPARE1_Pos); NRF_TIMER1-&gt;SHORTS |= (TIMER_SHORTS_COMPARE0_CLEAR_Enabled &lt;&lt; TIMER_SHORTS_COMPARE0_CLEAR_Pos); //   PPI       NRF_PPI-&gt;CH[0].EEP = (uint32_t) &amp;NRF_TIMER1-&gt;EVENTS_COMPARE[0]; NRF_PPI-&gt;CH[0].TEP = (uint32_t) &amp;NRF_ADC-&gt;TASKS_START; NRF_PPI-&gt;CHEN |= PPI_CHEN_CH0_Enabled; NRF_PPI-&gt;CHENSET |= PPI_CHENSET_CH0_Enabled; NRF_PPI-&gt;TASKS_CHG[0].EN = 1; NRF_TIMER1-&gt;TASKS_START = 1; } //    void ADC_IRQHandler(void) { rtos_suspend = 0; NRF_ADC-&gt;EVENTS_END = 0; if (NRF_ADC-&gt;CONFIG &gt;&gt; ADC_CONFIG_PSEL_Pos == ADC_CONFIG_PSEL_AnalogInput2) { NRF_TIMER1-&gt;EVENTS_COMPARE[0] = 0; adc_val = NRF_ADC-&gt;RESULT; osSignalSet(char_update_thread_id, 1&lt;&lt;CharUpdateSignal); } }</span></span></code> </pre><br></div></div><br>  Note that in the interrupt handler there is such a construction as <br>  rtos_suspend = 0; <br>  The rtos_suspend variable itself is defined in the RTOS configuration file and exported to our main file.  Since the operating system does not manage interrupts, this variable is needed so that the program understands that the system is not inactive at the moment, but is in the interrupt handler, which means that the power saving functions should not be activated now.  It is strongly recommended that each interrupt handler reset this variable, since otherwise the system‚Äôs behavior remains unpredictable. <br><br>  Since the interrupt handler cannot perform actions on the stack (in our case, update the characteristics), we can create a thread that will do this.  There are tools such as signals to interact with streams from interrupts.  In essence, signals are just bits in a flag variable that can be set and reset ‚Äî very much like interrupts.  Create a stream to record the characteristics and a signal-alert for it and add it to main: <br><br><div class="spoiler">  <b class="spoiler_title">thread</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//       void char_update_thread (void const* arg); //      osThreadId char_update_thread_id; //      osThreadDef(char_update_thread, osPriorityNormal, 1, 0); //    int32_t CharUpdateSignal = 0x01; //     void char_update_thread (void const* arg) { while(1) { osSignalWait(1&lt;&lt;CharUpdateSignal,osWaitForever); ble_char_update(&amp;adc_val,1,adc_char_handles.value_handle); } }</span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">main</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> err_code; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> erase_bonds; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> osStatus status; <span class="hljs-comment"><span class="hljs-comment">//   status = osKernelInitialize(); //  timers_init(); ble_stack_init(); device_manager_init(erase_bonds); gap_params_init(); advertising_init(); services_init(); char_add(ADC_CHAR_UUID,&amp;adc_char_handles, 1, false, false, true); conn_params_init(); //     err_code = ble_advertising_start(BLE_ADV_MODE_FAST); APP_ERROR_CHECK(err_code); //   ADC_init(); //   ble_create_thread(); char_update_thread_id = osThreadCreate(osThread(char_update_thread),NULL); //   status = osKernelStart(); }</span></span></code> </pre><br></div></div><br>  Great, now everything is ready!  You can download the program to the controller and check what we have: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/-h/go/z9/-hgoz9cexc491qq5zmobosd0niw.png"></div><br>  As you can see, we have a service with one characteristic that stores a single-byte value.  We can read it and make sure that the values ‚Äã‚Äãchange according to the change in voltage at the ADC input.  It was also possible to make this a notifying characteristic, then if the data in the characteristic on the device were changed, they would be automatically updated on the smartphone. <br><br><h1>  Conclusion </h1><br>  In conclusion, I would like to say that at first glance it seems as if RTOS introduces an unnecessary complication into the project, but this is not quite so.  The fact is that the application we created can now be easily scaled until there is no more memory for all the tasks.  For each new module, be it some kind of mathematical operations or work with peripherals, it will be enough to create your own thread and the only thing the programmer will need to think about is how to distribute priorities between tasks and, in difficult cases, when different threads turn to one and to build the same resources with semaphores and latches. <br><br><h2>  Links </h2><br>  <a href="">Project RTOS BLE</a> <br>  <a href="http://www.keil.com/pack/doc/CMSIS/RTOS/html/rtxImplementation.html">Keil-RTX web page</a> <br>  <a href="https://habrahabr.ru/post/343166/">NRF51822 in brief: Quick start</a> <br>  <a href="https://habrahabr.ru/post/345396/">NRF51822 in brief: Power saving and some peripherals</a> <br>  <a href="http://www.nordicsemi.com/eng/Products/Bluetooth-low-energy/nRF51822">NRF51822 product page</a> </div><p>Source: <a href="https://habr.com/ru/post/350416/">https://habr.com/ru/post/350416/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../350406/index.html">Own data in the system crash dump of Windows</a></li>
<li><a href="../350408/index.html">Digitalization and reality. Should I change something?</a></li>
<li><a href="../350410/index.html">How to make the best sites in Russia</a></li>
<li><a href="../350412/index.html">Duke Nukem Forever, which was not</a></li>
<li><a href="../350414/index.html">Technologies of unmanned vehicles. Yandex lecture</a></li>
<li><a href="../350418/index.html">Bitcoin and Ethereum: what happens on nodes that are not mining, and what will happen next?</a></li>
<li><a href="../350420/index.html">Digest of interesting materials for the mobile developer # 243 (February 26 - March 4)</a></li>
<li><a href="../350422/index.html">It's time for managers to wake up</a></li>
<li><a href="../350424/index.html">25 billion requests per hour: ServiceNow database</a></li>
<li><a href="../350426/index.html">Game development for NES in C. Chapters 17-21. My own game</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>