<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Create a GTK video player using Haskell</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="When we last settled on Movie Monad , we created a desktop video player using all web technologies (HTML, CSS, JavaScript and Electron). The trick was...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Create a GTK video player using Haskell</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/web/4b4/91e/586/4b491e586dbe49acbe0c413008af8dd6.jpg"></p><br><p>  When we last settled on <a href="https://lettier.github.io/posts/2016-08-15-making-movie-monad.html">Movie Monad</a> , we created a desktop video player using all web technologies (HTML, CSS, JavaScript and Electron).  The trick was that all the source code for the project was written in Haskell. </p><br><p>  One of the limitations of our web approach was that the size of the video file could not be too large, otherwise the application would fall.  To avoid this, we implemented a file size check and warned the user that the limit was exceeded. </p><br><p>  We could continue to develop our approach with the web by setting the backend to stream the video file to the HTML5 server, by running the server and the Electron application in parallel.  Instead, we abandon web technologies and turn to GTK +, Gstreamer and the X11 window management system. </p><a name="habracut"></a><br><p><img src="https://habrastorage.org/web/4fe/162/c64/4fe162c64ffb4837b3cdab2538d9a58a.jpg" alt="image"></p><br><p>  If you use another window management system, for example, Wayland, Quartz or WinAPI, then this approach can be adapted to work with your GDK backend.  Adaptation is to embed a <a href="https://gstreamer.freedesktop.org/data/doc/gstreamer/head/gst-plugins-base-plugins/html/gst-plugins-base-plugins-playbin.html">GStreamer playbin</a> video output into a Movie Monad window. </p><br><p>  GDK is an important aspect of GTK + portability.  Since Glib already provides low-level cross-platform functionality, in order to make GTK + work on other platforms you only need to port the GDK to the basic graphical level of the operating system.  That is, it is GDK ports on the Windows API and Quartz that allow GTK + applications to run on Windows and macOS ( <a href="https://en.wikipedia.org/wiki/GDK">source</a> ). </p><br><h2 id="dlya-kogo-eta-statya">  Who is this article for? </h2><br><ul><li>  For Haskell programmers who want to implement a GTK + user interface. </li><li>  For programmers interested in functional programming. </li><li>  For the creators of the GUI. </li><li>  For those who are looking for alternatives to GitHub Electron. </li><li>  For fans of video players. </li></ul><br><h2 id="chto-my-rassmotrim">  What we look at </h2><br><ul><li>  Stack. </li><li>  Bindings haskell-gi </li><li>  Directory of various data and files with them. </li><li>  Glade. </li><li>  GTK +. </li><li>  GStreamer. </li><li>  How to create a movie monad. </li></ul><br><h2 id="nastroyka-proekta">  Project Setup </h2><br><p>  First we need to set up a machine for developing Haskell programs, as well as set up files and dependencies for the project directory. </p><br><h3 id="platforma-haskell">  Haskell Platform </h3><br><p>  If your machine is not yet ready to develop Haskell programs, you can get everything you need by downloading and installing <a href="https://www.haskell.org/platform/">the Haskell platform</a> . </p><br><h3 id="stack">  Stack </h3><br><p>  If you do not already have a <a href="https://docs.haskellstack.org/en/stable/README/">Stack</a> , then be sure to install it before you start developing.  But if you have already used the Haskell platform, then you already have the Stack. </p><br><h3 id="exiftool">  ExifTool </h3><br><p> Before playing the video in Movie Monad, we need to collect some information about the file selected by the user.  To do this, use <a href="https://www.sno.phy.queensu.ca/~phil/exiftool/install.html">ExifTool</a> .  If you are working on Linux, then there is a great chance that you already have this tool ( <code>which exiftool</code> ).  ExifTool is available for Windows, Mac and Linux. </p><br><h3 id="fayly-proekta">  Project files </h3><br><p>  There are three ways to get project files. </p><br><pre> <code class="hljs ruby">wget <span class="hljs-symbol"><span class="hljs-symbol">https:</span></span>/<span class="hljs-regexp"><span class="hljs-regexp">/github.com/lettier</span></span><span class="hljs-regexp"><span class="hljs-regexp">/movie-monad/archive</span></span><span class="hljs-regexp"><span class="hljs-regexp">/master.zip unzip master.zip mv movie-monad-master movie-monad cd movie-monad/</span></span></code> </pre> <br><p>  You can download the <a href="">ZIP</a> archive and extract them. </p><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">git</span></span> clone git<span class="hljs-variable"><span class="hljs-variable">@github</span></span>.com:lettier/movie-monad.git cd movie-monad/</code> </pre> <br><p>  You can make a Git-clone using SSH. </p><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">git</span></span> clone https://github.com/lettier/movie-monad.git cd movie-monad/</code> </pre> <br><p>  You can clone git over https. </p><br><h3 id="haskell-gi">  haskell-gi </h3><br><p>  <a href="https://github.com/haskell-gi/haskell-gi">haskell-gi is</a> able to generate Haskell bindings to libraries using <a href="https://wiki.gnome.org/Projects/GObjectIntrospection">middleware self-diagnostics (introspection middleware) GObject</a> .  At the time of this writing, all the necessary bindings are available on <a href="https://hackage.haskell.org/packages/search%3Fterms%3Dgi">Hackage</a> . </p><br><h3 id="zavisimosti">  Dependencies </h3><br><p>  Now install the dependencies of the project. </p><br><pre> <code class="hljs sql">cd movie-monad/ stack <span class="hljs-keyword"><span class="hljs-keyword">install</span></span> <span class="hljs-comment"><span class="hljs-comment">--dependencies-only</span></span></code> </pre> <br><h2 id="kod">  Code </h2><br><p>  Now we set up the introduction of Movie Monad.  You can delete the source files and recreate them, or follow the instructions. </p><br><h3 id="paths_movie_monadhs">  Paths_movie_monad.hs </h3><br><p>  <code>Paths_movie_monad.hs</code> used to search for the <a href="https://glade.gnome.org/">Glade</a> XML GUI file during runtime.  Since we are developing, we will use a dummy module ( <code>movie-monad/src/dev/Paths_movie_monad.hs</code> ) to search for the file <code>movie-monad/src/data/gui.glade</code> .  After the project is built / installed, the real <code>Paths_movie_monad</code> module will be generated automatically.  It will provide us with the <code>getDataFileName</code> function.  It assigns to its output a prefix in the form of an absolute path where <code>data-dir (movie-monad/src/) data-files</code> copied or installed. </p><br><pre> <code class="hljs haskell"><span class="hljs-meta"><span class="hljs-meta">{-# LANGUAGE OverloadedStrings #-}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">module</span></span> Paths_movie_monad <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> dataDir :: <span class="hljs-type"><span class="hljs-type">String</span></span> dataDir = <span class="hljs-string"><span class="hljs-string">"./src/"</span></span> getDataFileName :: <span class="hljs-type"><span class="hljs-type">FilePath</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">IO</span></span> <span class="hljs-type"><span class="hljs-type">FilePath</span></span> getDataFileName a = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> putStrLn <span class="hljs-string"><span class="hljs-string">"You are using a fake Paths_movie_monad."</span></span> return (dataDir ++ <span class="hljs-string"><span class="hljs-string">"/"</span></span> ++ a)</code> </pre> <br><p>  Dummy module <code>Paths_movie_monad</code> . </p><br><pre> <code class="hljs pgsql">{-# <span class="hljs-keyword"><span class="hljs-keyword">LANGUAGE</span></span> CPP #-} {-# OPTIONS_GHC -fno-warn-missing-<span class="hljs-keyword"><span class="hljs-keyword">import</span></span>-lists #-} {-# OPTIONS_GHC -fno-warn-implicit-prelude #-} module Paths_movie_monad ( <span class="hljs-keyword"><span class="hljs-keyword">version</span></span>, getBinDir, getLibDir, getDynLibDir, getDataDir, getLibexecDir, getDataFileName, getSysconfDir ) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> qualified Control.<span class="hljs-keyword"><span class="hljs-keyword">Exception</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Exception</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Data.Version (Version(..)) <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-keyword"><span class="hljs-keyword">System</span></span>.Environment (getEnv) <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Prelude #<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> defined(VERSION_base) #<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> MIN_VERSION_base(<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>) catchIO :: IO a -&gt; (<span class="hljs-keyword"><span class="hljs-keyword">Exception</span></span>.IOException -&gt; IO a) -&gt; IO a #<span class="hljs-keyword"><span class="hljs-keyword">else</span></span> catchIO :: IO a -&gt; (<span class="hljs-keyword"><span class="hljs-keyword">Exception</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">Exception</span></span> -&gt; IO a) -&gt; IO a #endif #<span class="hljs-keyword"><span class="hljs-keyword">else</span></span> catchIO :: IO a -&gt; (<span class="hljs-keyword"><span class="hljs-keyword">Exception</span></span>.IOException -&gt; IO a) -&gt; IO a #endif catchIO = <span class="hljs-keyword"><span class="hljs-keyword">Exception</span></span>.catch <span class="hljs-keyword"><span class="hljs-keyword">version</span></span> :: <span class="hljs-keyword"><span class="hljs-keyword">Version</span></span> version = <span class="hljs-keyword"><span class="hljs-keyword">Version</span></span> [<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>] [] bindir, libdir, dynlibdir, datadir, libexecdir, sysconfdir :: FilePath bindir = "/home/&lt;snip&gt;/.stack-work/install/x86_64-linux-nopie/lts-9.1/8.0.2/bin" libdir = "/home/&lt;snip&gt;/.stack-work/install/x86_64-linux-nopie/lts-9.1/8.0.2/lib/x86_64-linux-ghc-8.0.2/movie-monad-0.0.0.0" dynlibdir = "/home/&lt;snip&gt;/.stack-work/install/x86_64-linux-nopie/lts-9.1/8.0.2/lib/x86_64-linux-ghc-8.0.2" datadir = "/home/&lt;snip&gt;/.stack-work/install/x86_64-linux-nopie/lts-9.1/8.0.2/share/x86_64-linux-ghc-8.0.2/movie-monad-0.0.0.0" libexecdir = "/home/&lt;snip&gt;/.stack-work/install/x86_64-linux-nopie/lts-9.1/8.0.2/libexec" sysconfdir = "/home/&lt;snip&gt;/.stack-work/install/x86_64-linux-nopie/lts-9.1/8.0.2/etc" getBinDir, getLibDir, getDynLibDir, getDataDir, getLibexecDir, getSysconfDir :: IO FilePath getBinDir = catchIO (getEnv "movie_monad_bindir") (\_ -&gt; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bindir) getLibDir = catchIO (getEnv "movie_monad_libdir") (\_ -&gt; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> libdir) getDynLibDir = catchIO (getEnv "movie_monad_dynlibdir") (\_ -&gt; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dynlibdir) getDataDir = catchIO (getEnv "movie_monad_datadir") (\_ -&gt; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> datadir) getLibexecDir = catchIO (getEnv "movie_monad_libexecdir") (\_ -&gt; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> libexecdir) getSysconfDir = catchIO (getEnv "movie_monad_sysconfdir") (\_ -&gt; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sysconfdir) getDataFileName :: FilePath -&gt; IO FilePath getDataFileName <span class="hljs-type"><span class="hljs-type">name</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> dir &lt;- getDataDir <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (dir ++ "/" ++ <span class="hljs-type"><span class="hljs-type">name</span></span>)</code> </pre> <br><p>  Automatically generated module <code>Paths_movie_monad</code> . </p><br><h3 id="mainhs">  Main.hs </h3><br><p>  <code>Main.hs</code> is the entry point for Movie Monad.  In this file, we set up our window with different widgets, connect GStreamer, and when the user logs off, we demolish the window. </p><br><p>  <strong><em>Pragmas</em></strong> </p><br><p>  We need to tell the compiler (GHC) that we need overloaded string and lexically scoped type variables. </p><br><p>  <code>OverloadedStrings</code> allows us to use string literals ( <code>"Literal"</code> ) where <code>String/[Char]</code> or Text are required.  <code>ScopedTypeVariables</code> allows us to use the type signature in the parameter parameter of the lambda function, which is passed to the interception when calling ExifTool. </p><br><pre> <code class="hljs pgsql">{-# <span class="hljs-keyword"><span class="hljs-keyword">LANGUAGE</span></span> OverloadedStrings #-} {-# <span class="hljs-keyword"><span class="hljs-keyword">LANGUAGE</span></span> ScopedTypeVariables #-}</code> </pre> <br><p>  <strong><em>Imports</em></strong> </p><br><pre> <code class="hljs pgsql">module Main <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Prelude <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Foreign</span></span>.C.<span class="hljs-keyword"><span class="hljs-keyword">Types</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-keyword"><span class="hljs-keyword">System</span></span>.Process <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-keyword"><span class="hljs-keyword">System</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">Exit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Control.Monad <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Control.<span class="hljs-keyword"><span class="hljs-keyword">Exception</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-type"><span class="hljs-type">Text</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">Read</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Data.IORef <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Data.Maybe <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Data.Int <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Data.Text <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Data.GI.Base <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Data.GI.Base.Signals <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Data.GI.Base.Properties <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> GI.GLib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> GI.GObject <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> qualified GI.Gtk <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> GI.Gst <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> GI.GstVideo <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> GI.Gdk <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> GI.GdkX11 <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Paths_movie_monad</code> </pre> <br><p>  Since we are working with C bindings, we will need to work with types that already exist in this language.  A considerable part of the imports are the bindings generated by haskell-gi. </p><br><p>  <strong><em>IsVideoOverlay</em></strong> </p><br><p>  GStreamer video <code>gi-gstvideo</code> ( <code>gi-gstvideo</code> ) contain a class of type (interface) <code>IsVideoOverlay</code> .  GStreamer bindings ( <code>gi-gst</code> ) contain an element type.  To use the <code>playbin</code> element with the <code>playbin</code> function, we need to declare a <code>GI.Gst.Element</code> - an instance of type (type instance) <code>IsVideoOverlay</code> .  And on the C side, <code>playbin</code> implements the <code>VideoOverlay</code> interface. </p><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">newtype</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GstElement</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GstElement</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GI</span></span></span><span class="hljs-class">.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Gst</span></span></span><span class="hljs-class">.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Element</span></span></span><span class="hljs-class"> instance </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GI</span></span></span><span class="hljs-class">.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GstVideo</span></span></span><span class="hljs-class">.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">IsVideoOverlay</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GstElement</span></span></span></span></code> </pre> <br><p>  Notice that we wrap a <code>GI.Gst.Element</code> into a new type (newtype) to avoid the appearance of a lost (orphaned) instance, since we are declaring an instance outside the haskell-gi bindings. </p><br><p>  <strong><em>main</em></strong> </p><br><p>  <code>Main</code> is our biggest feature.  In it, we initialize all GUI widgets and define callback procedures based on certain events. </p><br><pre> <code class="hljs objectivec">main :: IO () main = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span></code> </pre> <br><p>  <strong><em>GI initialization</em></strong> </p><br><pre> <code class="hljs kotlin"> _ &lt;- GI.Gst.<span class="hljs-keyword"><span class="hljs-keyword">init</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Nothing</span></span> _ &lt;- GI.Gtk.<span class="hljs-keyword"><span class="hljs-keyword">init</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Nothing</span></span></code> </pre> <br><p>  Here we initialized GStreamer and GTK +. </p><br><p>  <strong><em>Build GUI widgets</em></strong> </p><br><pre> <code class="hljs haskell"> gladeFile &lt;- getDataFileName <span class="hljs-string"><span class="hljs-string">"data/gui.glade"</span></span> builder &lt;- <span class="hljs-type"><span class="hljs-type">GI</span></span>.<span class="hljs-type"><span class="hljs-type">Gtk</span></span>.builderNewFromFile (pack gladeFile) window &lt;- builderGetObject <span class="hljs-type"><span class="hljs-type">GI</span></span>.<span class="hljs-type"><span class="hljs-type">Gtk</span></span>.<span class="hljs-type"><span class="hljs-type">Window</span></span> builder <span class="hljs-string"><span class="hljs-string">"window"</span></span> fileChooserButton &lt;- builderGetObject <span class="hljs-type"><span class="hljs-type">GI</span></span>.<span class="hljs-type"><span class="hljs-type">Gtk</span></span>.<span class="hljs-type"><span class="hljs-type">FileChooserButton</span></span> builder <span class="hljs-string"><span class="hljs-string">"file-chooser-button"</span></span> drawingArea &lt;- builderGetObject <span class="hljs-type"><span class="hljs-type">GI</span></span>.<span class="hljs-type"><span class="hljs-type">Gtk</span></span>.<span class="hljs-type"><span class="hljs-type">Widget</span></span> builder <span class="hljs-string"><span class="hljs-string">"drawing-area"</span></span> seekScale &lt;- builderGetObject <span class="hljs-type"><span class="hljs-type">GI</span></span>.<span class="hljs-type"><span class="hljs-type">Gtk</span></span>.<span class="hljs-type"><span class="hljs-type">Scale</span></span> builder <span class="hljs-string"><span class="hljs-string">"seek-scale"</span></span> onOffSwitch &lt;- builderGetObject <span class="hljs-type"><span class="hljs-type">GI</span></span>.<span class="hljs-type"><span class="hljs-type">Gtk</span></span>.<span class="hljs-type"><span class="hljs-type">Switch</span></span> builder <span class="hljs-string"><span class="hljs-string">"on-off-switch"</span></span> volumeButton &lt;- builderGetObject <span class="hljs-type"><span class="hljs-type">GI</span></span>.<span class="hljs-type"><span class="hljs-type">Gtk</span></span>.<span class="hljs-type"><span class="hljs-type">VolumeButton</span></span> builder <span class="hljs-string"><span class="hljs-string">"volume-button"</span></span> desiredVideoWidthComboBox &lt;- builderGetObject <span class="hljs-type"><span class="hljs-type">GI</span></span>.<span class="hljs-type"><span class="hljs-type">Gtk</span></span>.<span class="hljs-type"><span class="hljs-type">ComboBoxText</span></span> builder <span class="hljs-string"><span class="hljs-string">"desired-video-width-combo-box"</span></span> fullscreenButton &lt;- builderGetObject <span class="hljs-type"><span class="hljs-type">GI</span></span>.<span class="hljs-type"><span class="hljs-type">Gtk</span></span>.<span class="hljs-type"><span class="hljs-type">Button</span></span> builder <span class="hljs-string"><span class="hljs-string">"fullscreen-button"</span></span> errorMessageDialog &lt;- builderGetObject <span class="hljs-type"><span class="hljs-type">GI</span></span>.<span class="hljs-type"><span class="hljs-type">Gtk</span></span>.<span class="hljs-type"><span class="hljs-type">MessageDialog</span></span> builder <span class="hljs-string"><span class="hljs-string">"error-message-dialog"</span></span> aboutButton &lt;- builderGetObject <span class="hljs-type"><span class="hljs-type">GI</span></span>.<span class="hljs-type"><span class="hljs-type">Gtk</span></span>.<span class="hljs-type"><span class="hljs-type">Button</span></span> builder <span class="hljs-string"><span class="hljs-string">"about-button"</span></span> aboutDialog &lt;- builderGetObject <span class="hljs-type"><span class="hljs-type">GI</span></span>.<span class="hljs-type"><span class="hljs-type">Gtk</span></span>.<span class="hljs-type"><span class="hljs-type">AboutDialog</span></span> builder <span class="hljs-string"><span class="hljs-string">"about-dialog"</span></span></code> </pre> <br><p>  As already mentioned, we get the absolute path to the <a href="https://github.com/lettier/movie-monad/blob/master/src/data/gui.glade">XML</a> <code>data/gui.glade</code> , which describes all our GUI widgets.  Next we create a constructor from this file and get our widgets.  If we didn‚Äôt use Glade, we‚Äôd have to create them manually, which is quite tedious. </p><br><p>  <strong><em>Playbin</em></strong> </p><br><pre> <code class="hljs mel"> playbin &lt;- fromJust &lt;$&gt; GI.Gst.elementFactoryMake <span class="hljs-string"><span class="hljs-string">"playbin"</span></span> (Just <span class="hljs-string"><span class="hljs-string">"MultimediaPlayer"</span></span>)</code> </pre> <br><p>  Here we create a <code>playbin</code> GStreamer pipeline.  It is designed to address a variety of needs and saves us time creating our own pipeline.  Let's call this element <code>MultimediaPlayer</code> . </p><br><p>  <strong><em>Embed GStreamer output</em></strong> </p><br><p>  In order for GTK + and GStreamer to work together, we need to tell GStreamer exactly where to output the video.  If this is not done, then GStreamer will create its own window, since we use <code>playbin</code> . </p><br><pre> <code class="hljs vala"> _ &lt;- GI.<span class="hljs-built_in"><span class="hljs-built_in">Gtk</span></span>.onWidgetRealize drawingArea $ onDrawingAreaRealize drawingArea playbin fullscreenButton -- ... onDrawingAreaRealize :: GI.<span class="hljs-built_in"><span class="hljs-built_in">Gtk</span></span>.Widget -&gt; GI.Gst.Element -&gt; GI.<span class="hljs-built_in"><span class="hljs-built_in">Gtk</span></span>.Button -&gt; GI.<span class="hljs-built_in"><span class="hljs-built_in">Gtk</span></span>.WidgetRealizeCallback onDrawingAreaRealize drawingArea playbin fullscreenButton = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> gdkWindow &lt;- fromJust &lt;$&gt; GI.<span class="hljs-built_in"><span class="hljs-built_in">Gtk</span></span>.widgetGetWindow drawingArea x11Window &lt;- GI.<span class="hljs-built_in"><span class="hljs-built_in">Gtk</span></span>.unsafeCastTo GI.GdkX11.X11Window gdkWindow xid &lt;- GI.GdkX11.x11WindowGetXid x11Window let xid<span class="hljs-string"><span class="hljs-string">' = fromIntegral xid :: CUIntPtr GI.GstVideo.videoOverlaySetWindowHandle (GstElement playbin) xid'</span></span> GI.<span class="hljs-built_in"><span class="hljs-built_in">Gtk</span></span>.widgetHide fullscreenButton</code> </pre> <br><p>  Here you see the callback setup as soon as the <code>drawingArea</code> widget is <code>drawingArea</code> .  It is in this widget that GStreamer should show videos.  We get the parent GDK window for the render area widget.  Then we get the window handler, or <code>XID</code> of the X11 system of our GTK + window.  The <code>CUIntPtr</code> string converts the ID from <code>CULong</code> to <code>CUIntPtr</code> required for <code>videoOverlaySetWindowHandle</code> .  When we get the correct type, we notify GStreamer that with the help of the <code>xid'</code> handler it can draw the output of the <code>playbin</code> in our window. </p><br><p>  Because of the bug in Glade, we programmatically hide the full-screen widget, because if you uncheck the visible box in Glade, the widget will not be hidden anyway. </p><br><p>  Please note that you need to adapt Movie Monad to work with the window system, if you are using not some other X system. </p><br><p>  <strong><em>File selection</em></strong> </p><br><pre> <code class="hljs vala"> _ &lt;- GI.<span class="hljs-built_in"><span class="hljs-built_in">Gtk</span></span>.onFileChooserButtonFileSet fileChooserButton $ onFileChooserButtonFileSet playbin fileChooserButton volumeButton isWindowFullScreenRef desiredVideoWidthComboBox onOffSwitch fullscreenButton drawingArea window errorMessageDialog -- ... onFileChooserButtonFileSet :: GI.Gst.Element -&gt; GI.<span class="hljs-built_in"><span class="hljs-built_in">Gtk</span></span>.FileChooserButton -&gt; GI.<span class="hljs-built_in"><span class="hljs-built_in">Gtk</span></span>.VolumeButton -&gt; IORef Bool -&gt; GI.<span class="hljs-built_in"><span class="hljs-built_in">Gtk</span></span>.ComboBoxText -&gt; GI.<span class="hljs-built_in"><span class="hljs-built_in">Gtk</span></span>.Switch -&gt; GI.<span class="hljs-built_in"><span class="hljs-built_in">Gtk</span></span>.Button -&gt; GI.<span class="hljs-built_in"><span class="hljs-built_in">Gtk</span></span>.Widget -&gt; GI.<span class="hljs-built_in"><span class="hljs-built_in">Gtk</span></span>.Window -&gt; GI.<span class="hljs-built_in"><span class="hljs-built_in">Gtk</span></span>.MessageDialog -&gt; GI.<span class="hljs-built_in"><span class="hljs-built_in">Gtk</span></span>.FileChooserButtonFileSetCallback onFileChooserButtonFileSet playbin fileChooserButton volumeButton isWindowFullScreenRef desiredVideoWidthComboBox onOffSwitch fullscreenButton drawingArea window errorMessageDialog = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> _ &lt;- GI.Gst.elementSetState playbin GI.Gst.StateNull filename &lt;- fromJust &lt;$&gt; GI.<span class="hljs-built_in"><span class="hljs-built_in">Gtk</span></span>.fileChooserGetFilename fileChooserButton setPlaybinUriAndVolume playbin filename volumeButton isWindowFullScreen &lt;- readIORef isWindowFullScreenRef desiredVideoWidth &lt;- getDesiredVideoWidth desiredVideoWidthComboBox maybeWindowSize &lt;- getWindowSize desiredVideoWidth filename <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> maybeWindowSize of Nothing -&gt; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> _ &lt;- GI.Gst.elementSetState playbin GI.Gst.StatePaused GI.<span class="hljs-built_in"><span class="hljs-built_in">Gtk</span></span>.windowUnfullscreen window GI.<span class="hljs-built_in"><span class="hljs-built_in">Gtk</span></span>.switchSetActive onOffSwitch False GI.<span class="hljs-built_in"><span class="hljs-built_in">Gtk</span></span>.widgetHide fullscreenButton GI.<span class="hljs-built_in"><span class="hljs-built_in">Gtk</span></span>.widgetShow desiredVideoWidthComboBox resetWindowSize desiredVideoWidth fileChooserButton drawingArea window _ &lt;- GI.<span class="hljs-built_in"><span class="hljs-built_in">Gtk</span></span>.onDialogResponse errorMessageDialog (\ _ -&gt; GI.<span class="hljs-built_in"><span class="hljs-built_in">Gtk</span></span>.widgetHide errorMessageDialog) <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> $ GI.<span class="hljs-built_in"><span class="hljs-built_in">Gtk</span></span>.dialogRun errorMessageDialog Just (width, height) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> _ &lt;- GI.Gst.elementSetState playbin GI.Gst.StatePlaying GI.<span class="hljs-built_in"><span class="hljs-built_in">Gtk</span></span>.switchSetActive onOffSwitch True GI.<span class="hljs-built_in"><span class="hljs-built_in">Gtk</span></span>.widgetShow fullscreenButton unless isWindowFullScreen $ setWindowSize width height fileChooserButton drawingArea window</code> </pre> <br><p>  To start a video playback session, the user must be able to select a video file.  After the file is selected, you need to perform a series of mandatory actions so that everything works well. </p><br><ul><li>  We get the file name from the file selection widget. </li><li>  We <code>playbin</code> which file it should play. </li><li>  Make the volume level in the widget the same as in <code>playbin</code> . </li><li>  Based on the desired image width and video size, we determine the appropriate width and height of the window. </li><li>  If the window sizes are successfully received: <br><ul><li>  Start playing the file. </li><li>  We transfer the pause / play button to the ‚Äúon‚Äù state. </li><li>  Show fullscreen widget. </li><li>  If the video is not in full screen mode: </li><li>  Change the window size to match the relative video size. </li></ul></li><li>  If unable to get window dimensions: <br><ul><li>  Put the <code>playbin</code> on pause. </li><li>  Turn the switch to the "off" position. </li><li>  If it is possible, we deduce a window from the full-screen mode. </li><li>  Reset the window size. </li><li>  Display a small dialog error message. </li></ul></li></ul><br><p>  <strong><em>Pause and play</em></strong> </p><br><pre> <code class="hljs cs"> _ &lt;- GI.Gtk.<span class="hljs-function"><span class="hljs-function">onSwitchStateSet </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onOffSwitch</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">onSwitchStateSet playbin</span></span></span><span class="hljs-function">) -- ... onSwitchStateSet :: GI.Gst.Element -&gt; Bool -&gt; IO Bool onSwitchStateSet playbin switchOn</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> switchOn then <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> $ GI.Gst.elementSetState playbin GI.Gst.StatePlaying <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> $ GI.Gst.elementSetState playbin GI.Gst.StatePaused <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> switchOn</code> </pre> <br><p>  It's simple.  If the switch is in the ‚Äúon‚Äù position, then we set the <code>playbin</code> element to the <code>playbin</code> element.  Otherwise, we give it a pause state. </p><br><p>  <strong><em>Volume setting</em></strong> </p><br><pre> <code class="hljs nginx"> <span class="hljs-attribute"><span class="hljs-attribute">_</span></span> &lt;- GI.Gtk.<span class="hljs-literal"><span class="hljs-literal">on</span></span>ScaleButtonValueChanged volumeButton (<span class="hljs-literal"><span class="hljs-literal">on</span></span>ScaleButtonValueChanged playbin) -- ... <span class="hljs-literal"><span class="hljs-literal">on</span></span>ScaleButtonValueChanged :: GI.Gst.Element -&gt; Double -&gt; IO () <span class="hljs-literal"><span class="hljs-literal">on</span></span>ScaleButtonValueChanged playbin volume = void $ Data.GI.Base.Properties.setObjectPropertyDouble playbin <span class="hljs-string"><span class="hljs-string">"volume"</span></span> volume</code> </pre> <br><p>  When the volume in the widget changes, we pass its value to GStreamer so that it can adjust the volume to play. </p><br><p>  <strong><em>Moving around the video</em></strong> </p><br><pre> <code class="hljs kotlin"> seekScaleHandlerId &lt;- GI.Gtk.onRangeValueChanged seekScale (onRangeValueChanged playbin seekScale) -- ... onRangeValueChanged :: GI.Gst.Element -&gt; GI.Gtk.Scale -&gt; IO () onRangeValueChanged playbin seekScale = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> (couldQueryDuration, duration) &lt;- GI.Gst.elementQueryDuration playbin GI.Gst.FormatTime <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> couldQueryDuration $ <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> percentage<span class="hljs-string"><span class="hljs-string">' &lt;- GI.Gtk.rangeGetValue seekScale let percentage = percentage'</span></span> / <span class="hljs-number"><span class="hljs-number">100.0</span></span> let position = fromIntegral (round ((fromIntegral duration :: <span class="hljs-built_in"><span class="hljs-built_in">Double</span></span>) * percentage) :: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>) :: Int64 void $ GI.Gst.elementSeekSimple playbin GI.Gst.FormatTime [ GI.Gst.SeekFlagsFlush ] position</code> </pre> <br><p>  In Movie Monad, there is a playback scale in which you can move the slider forward / backward, thereby navigating through video frames. </p><br><p>  The scale from 0 to 100% represents the total duration of the video file.  If you move the slider, for example, to 50, then we move to the timestamp, which is in the middle between the beginning and the end.  It would be possible to adjust the scale from zero to the duration of the video, but the described method is more versatile. </p><br><p>  Please note that for this callback we use a signal ID ( <code>seekScaleHandlerId</code> ), since we will need it later. </p><br><p>  <strong><em>Update Playback Scale</em></strong> </p><br><pre> <code class="hljs vala"> _ &lt;- GI.<span class="hljs-built_in"><span class="hljs-built_in">GLib</span></span>.timeoutAddSeconds GI.<span class="hljs-built_in"><span class="hljs-built_in">GLib</span></span>.PRIORITY_DEFAULT <span class="hljs-number"><span class="hljs-number">1</span></span> (updateSeekScale playbin seekScale seekScaleHandlerId) -- ... updateSeekScale :: GI.Gst.Element -&gt; GI.<span class="hljs-built_in"><span class="hljs-built_in">Gtk</span></span>.Scale -&gt; Data.GI.Base.Signals.SignalHandlerId -&gt; IO Bool updateSeekScale playbin seekScale seekScaleHandlerId = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> (couldQueryDuration, duration) &lt;- GI.Gst.elementQueryDuration playbin GI.Gst.FormatTime (couldQueryPosition, position) &lt;- GI.Gst.elementQueryPosition playbin GI.Gst.FormatTime let percentage = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> couldQueryDuration &amp;&amp; couldQueryPosition &amp;&amp; duration &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> then <span class="hljs-number"><span class="hljs-number">100.0</span></span> * (fromIntegral position / fromIntegral duration :: Double) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-number"><span class="hljs-number">0.0</span></span> GI.GObject.signalHandlerBlock seekScale seekScaleHandlerId GI.<span class="hljs-built_in"><span class="hljs-built_in">Gtk</span></span>.rangeSetValue seekScale percentage GI.GObject.signalHandlerUnblock seekScale seekScaleHandlerId <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> True</code> </pre> <br><p>  To synchronize the scale and the video playback process itself, you need to transfer messages between GTK + and GStreamer.  Every second we will request the current playback position and update the scale in accordance with it.  So we show the user how much of the file is already shown, and the slider will always correspond to the real position of the playback. </p><br><p>  In order not to initiate a previously configured callback, we disable the <code>onRangeValueChanged</code> signal <code>onRangeValueChanged</code> when updating the playback scale.  The onRangeValueChanged <code>onRangeValueChanged</code> should only be executed if the <strong>user</strong> changes the position of the slider. </p><br><p>  <strong><em>Video resizing</em></strong> </p><br><pre> <code class="hljs rust"> _ &lt;- GI.Gtk.onComboBoxChanged desiredVideoWidthComboBox $ onComboBoxChanged fileChooserButton desiredVideoWidthComboBox drawingArea window -- ... onComboBoxChanged :: GI.Gtk.FileChooserButton -&gt; GI.Gtk.ComboBoxText -&gt; GI.Gtk.Widget -&gt; GI.Gtk.Window -&gt; IO () onComboBoxChanged fileChooserButton desiredVideoWidthComboBox drawingArea window = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> filename' &lt;- GI.Gtk.fileChooserGetFilename fileChooserButton <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> filename = fromMaybe <span class="hljs-string"><span class="hljs-string">""</span></span> filename' desiredVideoWidth &lt;- getDesiredVideoWidth desiredVideoWidthComboBox maybeWindowSize &lt;- getWindowSize desiredVideoWidth filename case maybeWindowSize of Nothing -&gt; resetWindowSize desiredVideoWidth fileChooserButton drawingArea window Just (width, height) -&gt; setWindowSize width height fileChooserButton drawingArea window</code> </pre> <br><p>  This widget allows the user to select the desired video width.  The height will be selected automatically based on the aspect ratio of the video file. </p><br><p>  <strong><em>Full screen mode</em></strong> </p><br><pre> <code class="hljs vala"> _ &lt;- GI.<span class="hljs-built_in"><span class="hljs-built_in">Gtk</span></span>.onWidgetButtonReleaseEvent fullscreenButton (onFullscreenButtonRelease isWindowFullScreenRef desiredVideoWidthComboBox fileChooserButton window) -- ... onFullscreenButtonRelease :: IORef Bool -&gt; GI.<span class="hljs-built_in"><span class="hljs-built_in">Gtk</span></span>.ComboBoxText -&gt; GI.<span class="hljs-built_in"><span class="hljs-built_in">Gtk</span></span>.FileChooserButton -&gt; GI.<span class="hljs-built_in"><span class="hljs-built_in">Gtk</span></span>.Window -&gt; GI.Gdk.EventButton -&gt; IO Bool onFullscreenButtonRelease isWindowFullScreenRef desiredVideoWidthComboBox fileChooserButton window _ = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> isWindowFullScreen &lt;- readIORef isWindowFullScreenRef <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> isWindowFullScreen then <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> GI.<span class="hljs-built_in"><span class="hljs-built_in">Gtk</span></span>.widgetShow desiredVideoWidthComboBox GI.<span class="hljs-built_in"><span class="hljs-built_in">Gtk</span></span>.widgetShow fileChooserButton <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> $ GI.<span class="hljs-built_in"><span class="hljs-built_in">Gtk</span></span>.windowUnfullscreen window <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> GI.<span class="hljs-built_in"><span class="hljs-built_in">Gtk</span></span>.widgetHide desiredVideoWidthComboBox GI.<span class="hljs-built_in"><span class="hljs-built_in">Gtk</span></span>.widgetHide fileChooserButton <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> $ GI.<span class="hljs-built_in"><span class="hljs-built_in">Gtk</span></span>.windowFullscreen window <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> True</code> </pre> <br><p>  When the user releases the widget's button in full-screen mode, we switch the state of the full-screen mode of the window, hide the file selection panel and the video width selection widget.  When you exit the full-screen mode, we restore the panel and widget. </p><br><p>  Please note that we don‚Äôt show a fullscreen widget if we don‚Äôt have a video. </p><br><pre> <code class="hljs rust"> _ &lt;- GI.Gtk.onWidgetWindowStateEvent window (onWidgetWindowStateEvent isWindowFullScreenRef) -- ... onWidgetWindowStateEvent :: IORef Bool -&gt; GI.Gdk.EventWindowState -&gt; IO Bool onWidgetWindowStateEvent isWindowFullScreenRef eventWindowState = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> windowStates &lt;- GI.Gdk.getEventWindowStateNewWindowState eventWindowState <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> isWindowFullScreen = Prelude.foldl (\ acc x -&gt; acc || GI.Gdk.WindowStateFullscreen == x) False windowStates writeIORef isWindowFullScreenRef isWindowFullScreen <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> True</code> </pre> <br><p>  To control the full-screen state of the window, we need to set up a callback so that it starts up every time the window state changes.  Different callbacks depend on the full screen state information.  As an aid, we use <code>IORef</code> , from which each function will read and to which it will write a callback.  This <code>IORef</code> is a modifiable (and common) link.  Ideally, we need to request a window exactly when it is in full-screen mode, but there is no API for it.  Therefore, we will use a variable link. </p><br><p>  Due to the use of a single writer and heap of signal callbacks in the main execution thread, we avoid possible traps of the general changeable state.  If we were concerned about thread safety, we could use <code>MVar</code> , <code>TVar</code> or <code>atomicModifyIORef</code> . </p><br><p>  <strong><em>About the program</em></strong> </p><br><pre> <code class="hljs vala"> _ &lt;- GI.<span class="hljs-built_in"><span class="hljs-built_in">Gtk</span></span>.onWidgetButtonReleaseEvent aboutButton (onAboutButtonRelease aboutDialog) -- ... onAboutButtonRelease :: GI.<span class="hljs-built_in"><span class="hljs-built_in">Gtk</span></span>.AboutDialog -&gt; GI.Gdk.EventButton -&gt; IO Bool onAboutButtonRelease aboutDialog _ = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> _ &lt;- GI.<span class="hljs-built_in"><span class="hljs-built_in">Gtk</span></span>.onDialogResponse aboutDialog (\ _ -&gt; GI.<span class="hljs-built_in"><span class="hljs-built_in">Gtk</span></span>.widgetHide aboutDialog) _ &lt;- GI.<span class="hljs-built_in"><span class="hljs-built_in">Gtk</span></span>.dialogRun aboutDialog <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> True</code> </pre> <br><p>  The last widget in question is the About dialog box.  Here we associate the dialog box with the ‚ÄúAbout‚Äù button displayed in the main window. </p><br><p>  <strong><em>Closing the window</em></strong> </p><br><pre> <code class="hljs nginx"> <span class="hljs-attribute"><span class="hljs-attribute">_</span></span> &lt;- GI.Gtk.<span class="hljs-literal"><span class="hljs-literal">on</span></span>WidgetDestroy window (<span class="hljs-literal"><span class="hljs-literal">on</span></span>WindowDestroy playbin) -- ... <span class="hljs-literal"><span class="hljs-literal">on</span></span>WindowDestroy :: GI.Gst.Element -&gt; IO () <span class="hljs-literal"><span class="hljs-literal">on</span></span>WindowDestroy playbin = do _ &lt;- GI.Gst.elementSetState playbin GI.Gst.StateNull _ &lt;- GI.Gst.objectUnref playbin GI.Gtk.mainQuit</code> </pre> <br><p>  When the user closes the window, we destroy the <code>playbin</code> pipeline and exit the main GTK loop. </p><br><p>  <strong><em>Launch</em></strong> </p><br><pre> <code class="hljs css"> <span class="hljs-selector-tag"><span class="hljs-selector-tag">GI</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Gtk</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.widgetShowAll</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">window</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">GI</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Gtk</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.main</span></span></code> </pre> <br><p>  Finally, we show or draw the main window and start the main GTK + loop.  It is blocked until the <code>mainQuit</code> . </p><br><p>  <strong><em>Complete Main.hs file</em></strong> </p><br><p>  Below is the file <code>movie-monad/src/Main.hs</code>  Different helper functions related to <code>main</code> are not shown. </p><br><pre> <code class="hljs rust">{- Movie Monad (C) <span class="hljs-number"><span class="hljs-number">2017</span></span> David lettier lettier.com -} {-# LANGUAGE OverloadedStrings #-} {-# LANGUAGE ScopedTypeVariables #-} module Main <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> import Prelude import Foreign.C.Types import System.Process import System.Exit import Control.Monad import Control.Exception import Text.Read import Data.IORef import Data.Maybe import Data.Int import Data.Text import Data.GI.Base import Data.GI.Base.Signals import Data.GI.Base.Properties import GI.GLib import GI.GObject import qualified GI.Gtk import GI.Gst import GI.GstVideo import GI.Gdk import GI.GdkX11 import Paths_movie_monad -- Declare Element a <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">instance</span></span></span></span> of IsVideoOverlay via a newtype wrapper -- Our GStreamer element is playbin -- Playbin implements the GStreamer VideoOverlay interface newtype GstElement = GstElement GI.Gst.Element instance GI.GstVideo.IsVideoOverlay GstElement main :: IO () main = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> _ &lt;- GI.Gst.init Nothing _ &lt;- GI.Gtk.init Nothing gladeFile &lt;- getDataFileName <span class="hljs-string"><span class="hljs-string">"data/gui.glade"</span></span> builder &lt;- GI.Gtk.builderNewFromFile (pack gladeFile) window &lt;- builderGetObject GI.Gtk.Window builder <span class="hljs-string"><span class="hljs-string">"window"</span></span> fileChooserButton &lt;- builderGetObject GI.Gtk.FileChooserButton builder <span class="hljs-string"><span class="hljs-string">"file-chooser-button"</span></span> drawingArea &lt;- builderGetObject GI.Gtk.Widget builder <span class="hljs-string"><span class="hljs-string">"drawing-area"</span></span> seekScale &lt;- builderGetObject GI.Gtk.Scale builder <span class="hljs-string"><span class="hljs-string">"seek-scale"</span></span> onOffSwitch &lt;- builderGetObject GI.Gtk.Switch builder <span class="hljs-string"><span class="hljs-string">"on-off-switch"</span></span> volumeButton &lt;- builderGetObject GI.Gtk.VolumeButton builder <span class="hljs-string"><span class="hljs-string">"volume-button"</span></span> desiredVideoWidthComboBox &lt;- builderGetObject GI.Gtk.ComboBoxText builder <span class="hljs-string"><span class="hljs-string">"desired-video-width-combo-box"</span></span> fullscreenButton &lt;- builderGetObject GI.Gtk.Button builder <span class="hljs-string"><span class="hljs-string">"fullscreen-button"</span></span> errorMessageDialog &lt;- builderGetObject GI.Gtk.MessageDialog builder <span class="hljs-string"><span class="hljs-string">"error-message-dialog"</span></span> aboutButton &lt;- builderGetObject GI.Gtk.Button builder <span class="hljs-string"><span class="hljs-string">"about-button"</span></span> aboutDialog &lt;- builderGetObject GI.Gtk.AboutDialog builder <span class="hljs-string"><span class="hljs-string">"about-dialog"</span></span> playbin &lt;- fromJust &lt;$&gt; GI.Gst.elementFactoryMake <span class="hljs-string"><span class="hljs-string">"playbin"</span></span> (Just <span class="hljs-string"><span class="hljs-string">"MultimediaPlayer"</span></span>) isWindowFullScreenRef &lt;- newIORef False _ &lt;- GI.Gtk.onWidgetRealize drawingArea $ onDrawingAreaRealize drawingArea playbin fullscreenButton _ &lt;- GI.Gtk.onFileChooserButtonFileSet fileChooserButton $ onFileChooserButtonFileSet playbin fileChooserButton volumeButton isWindowFullScreenRef desiredVideoWidthComboBox onOffSwitch fullscreenButton drawingArea window errorMessageDialog _ &lt;- GI.Gtk.onSwitchStateSet onOffSwitch (onSwitchStateSet playbin) _ &lt;- GI.Gtk.onScaleButtonValueChanged volumeButton (onScaleButtonValueChanged playbin) seekScaleHandlerId &lt;- GI.Gtk.onRangeValueChanged seekScale (onRangeValueChanged playbin seekScale) _ &lt;- GI.GLib.timeoutAddSeconds GI.GLib.PRIORITY_DEFAULT <span class="hljs-number"><span class="hljs-number">1</span></span> (updateSeekScale playbin seekScale seekScaleHandlerId) _ &lt;- GI.Gtk.onComboBoxChanged desiredVideoWidthComboBox $ onComboBoxChanged fileChooserButton desiredVideoWidthComboBox drawingArea window _ &lt;- GI.Gtk.onWidgetButtonReleaseEvent fullscreenButton (onFullscreenButtonRelease isWindowFullScreenRef desiredVideoWidthComboBox fileChooserButton window) _ &lt;- GI.Gtk.onWidgetWindowStateEvent window (onWidgetWindowStateEvent isWindowFullScreenRef) _ &lt;- GI.Gtk.onWidgetButtonReleaseEvent aboutButton (onAboutButtonRelease aboutDialog) _ &lt;- GI.Gtk.onWidgetDestroy window (onWindowDestroy playbin) GI.Gtk.widgetShowAll window GI.Gtk.main builderGetObject :: (GI.GObject.GObject b, GI.Gtk.IsBuilder a) =&gt; (Data.GI.Base.ManagedPtr b -&gt; b) -&gt; a -&gt; Prelude.<span class="hljs-built_in"><span class="hljs-built_in">String</span></span> -&gt; IO b builderGetObject objectTypeClass builder objectId = fromJust &lt;$&gt; GI.Gtk.builderGetObject builder (pack objectId) &gt;&gt;= GI.Gtk.unsafeCastTo objectTypeClass onDrawingAreaRealize :: GI.Gtk.Widget -&gt; GI.Gst.Element -&gt; GI.Gtk.Button -&gt; GI.Gtk.WidgetRealizeCallback onDrawingAreaRealize drawingArea playbin fullscreenButton = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> gdkWindow &lt;- fromJust &lt;$&gt; GI.Gtk.widgetGetWindow drawingArea x11Window &lt;- GI.Gtk.unsafeCastTo GI.GdkX11.X11Window gdkWindow xid &lt;- GI.GdkX11.x11WindowGetXid x11Window <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> xid' = fromIntegral xid :: CUIntPtr GI.GstVideo.videoOverlaySetWindowHandle (GstElement playbin) xid' GI.Gtk.widgetHide fullscreenButton onFileChooserButtonFileSet :: GI.Gst.Element -&gt; GI.Gtk.FileChooserButton -&gt; GI.Gtk.VolumeButton -&gt; IORef Bool -&gt; GI.Gtk.ComboBoxText -&gt; GI.Gtk.Switch -&gt; GI.Gtk.Button -&gt; GI.Gtk.Widget -&gt; GI.Gtk.Window -&gt; GI.Gtk.MessageDialog -&gt; GI.Gtk.FileChooserButtonFileSetCallback onFileChooserButtonFileSet playbin fileChooserButton volumeButton isWindowFullScreenRef desiredVideoWidthComboBox onOffSwitch fullscreenButton drawingArea window errorMessageDialog = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> _ &lt;- GI.Gst.elementSetState playbin GI.Gst.StateNull filename &lt;- fromJust &lt;$&gt; GI.Gtk.fileChooserGetFilename fileChooserButton setPlaybinUriAndVolume playbin filename volumeButton isWindowFullScreen &lt;- readIORef isWindowFullScreenRef desiredVideoWidth &lt;- getDesiredVideoWidth desiredVideoWidthComboBox maybeWindowSize &lt;- getWindowSize desiredVideoWidth filename case maybeWindowSize of Nothing -&gt; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> _ &lt;- GI.Gst.elementSetState playbin GI.Gst.StatePaused GI.Gtk.windowUnfullscreen window GI.Gtk.switchSetActive onOffSwitch False GI.Gtk.widgetHide fullscreenButton GI.Gtk.widgetShow desiredVideoWidthComboBox resetWindowSize desiredVideoWidth fileChooserButton drawingArea window _ &lt;- GI.Gtk.onDialogResponse errorMessageDialog (\ _ -&gt; GI.Gtk.widgetHide errorMessageDialog) void $ GI.Gtk.dialogRun errorMessageDialog Just (width, height) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> _ &lt;- GI.Gst.elementSetState playbin GI.Gst.StatePlaying GI.Gtk.switchSetActive onOffSwitch True GI.Gtk.widgetShow fullscreenButton unless isWindowFullScreen $ setWindowSize width height fileChooserButton drawingArea window onSwitchStateSet :: GI.Gst.Element -&gt; Bool -&gt; IO Bool onSwitchStateSet playbin switchOn = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> switchOn then void $ GI.Gst.elementSetState playbin GI.Gst.StatePlaying <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> void $ GI.Gst.elementSetState playbin GI.Gst.StatePaused <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> switchOn onScaleButtonValueChanged :: GI.Gst.Element -&gt; Double -&gt; IO () onScaleButtonValueChanged playbin volume = void $ Data.GI.Base.Properties.setObjectPropertyDouble playbin <span class="hljs-string"><span class="hljs-string">"volume"</span></span> volume onRangeValueChanged :: GI.Gst.Element -&gt; GI.Gtk.Scale -&gt; IO () onRangeValueChanged playbin seekScale = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> (couldQueryDuration, duration) &lt;- GI.Gst.elementQueryDuration playbin GI.Gst.FormatTime when couldQueryDuration $ <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> percentage' &lt;- GI.Gtk.rangeGetValue seekScale <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> percentage = percentage' / <span class="hljs-number"><span class="hljs-number">100.0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> position = fromIntegral (round ((fromIntegral duration :: Double) * percentage) :: Int) :: Int64 void $ GI.Gst.elementSeekSimple playbin GI.Gst.FormatTime [ GI.Gst.SeekFlagsFlush ] position updateSeekScale :: GI.Gst.Element -&gt; GI.Gtk.Scale -&gt; Data.GI.Base.Signals.SignalHandlerId -&gt; IO Bool updateSeekScale playbin seekScale seekScaleHandlerId = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> (couldQueryDuration, duration) &lt;- GI.Gst.elementQueryDuration playbin GI.Gst.FormatTime (couldQueryPosition, position) &lt;- GI.Gst.elementQueryPosition playbin GI.Gst.FormatTime <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> percentage = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> couldQueryDuration &amp;&amp; couldQueryPosition &amp;&amp; duration &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> then <span class="hljs-number"><span class="hljs-number">100.0</span></span> * (fromIntegral position / fromIntegral duration :: Double) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-number"><span class="hljs-number">0.0</span></span> GI.GObject.signalHandlerBlock seekScale seekScaleHandlerId GI.Gtk.rangeSetValue seekScale percentage GI.GObject.signalHandlerUnblock seekScale seekScaleHandlerId <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> True onComboBoxChanged :: GI.Gtk.FileChooserButton -&gt; GI.Gtk.ComboBoxText -&gt; GI.Gtk.Widget -&gt; GI.Gtk.Window -&gt; IO () onComboBoxChanged fileChooserButton desiredVideoWidthComboBox drawingArea window = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> filename' &lt;- GI.Gtk.fileChooserGetFilename fileChooserButton <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> filename = fromMaybe <span class="hljs-string"><span class="hljs-string">""</span></span> filename' desiredVideoWidth &lt;- getDesiredVideoWidth desiredVideoWidthComboBox maybeWindowSize &lt;- getWindowSize desiredVideoWidth filename case maybeWindowSize of Nothing -&gt; resetWindowSize desiredVideoWidth fileChooserButton drawingArea window Just (width, height) -&gt; setWindowSize width height fileChooserButton drawingArea window onFullscreenButtonRelease :: IORef Bool -&gt; GI.Gtk.ComboBoxText -&gt; GI.Gtk.FileChooserButton -&gt; GI.Gtk.Window -&gt; GI.Gdk.EventButton -&gt; IO Bool onFullscreenButtonRelease isWindowFullScreenRef desiredVideoWidthComboBox fileChooserButton window _ = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> isWindowFullScreen &lt;- readIORef isWindowFullScreenRef <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> isWindowFullScreen then <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> GI.Gtk.widgetShow desiredVideoWidthComboBox GI.Gtk.widgetShow fileChooserButton void $ GI.Gtk.windowUnfullscreen window <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> GI.Gtk.widgetHide desiredVideoWidthComboBox GI.Gtk.widgetHide fileChooserButton void $ GI.Gtk.windowFullscreen window <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> True onWidgetWindowStateEvent :: IORef Bool -&gt; GI.Gdk.EventWindowState -&gt; IO Bool onWidgetWindowStateEvent isWindowFullScreenRef eventWindowState = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> windowStates &lt;- GI.Gdk.getEventWindowStateNewWindowState eventWindowState <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> isWindowFullScreen = Prelude.foldl (\ acc x -&gt; acc || GI.Gdk.WindowStateFullscreen == x) False windowStates writeIORef isWindowFullScreenRef isWindowFullScreen <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> True onAboutButtonRelease :: GI.Gtk.AboutDialog -&gt; GI.Gdk.EventButton -&gt; IO Bool onAboutButtonRelease aboutDialog _ = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> _ &lt;- GI.Gtk.onDialogResponse aboutDialog (\ _ -&gt; GI.Gtk.widgetHide aboutDialog) _ &lt;- GI.Gtk.dialogRun aboutDialog <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> True onWindowDestroy :: GI.Gst.Element -&gt; IO () onWindowDestroy playbin = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> _ &lt;- GI.Gst.elementSetState playbin GI.Gst.StateNull _ &lt;- GI.Gst.objectUnref playbin GI.Gtk.mainQuit setPlaybinUriAndVolume :: GI.Gst.Element -&gt; Prelude.<span class="hljs-built_in"><span class="hljs-built_in">String</span></span> -&gt; GI.Gtk.VolumeButton -&gt; IO () setPlaybinUriAndVolume playbin filename volumeButton = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> uri = <span class="hljs-string"><span class="hljs-string">"file://"</span></span> ++ filename volume &lt;- GI.Gtk.scaleButtonGetValue volumeButton Data.GI.Base.Properties.setObjectPropertyDouble playbin <span class="hljs-string"><span class="hljs-string">"volume"</span></span> volume Data.GI.Base.Properties.setObjectPropertyString playbin <span class="hljs-string"><span class="hljs-string">"uri"</span></span> (Just $ pack uri) getVideoInfo :: Prelude.<span class="hljs-built_in"><span class="hljs-built_in">String</span></span> -&gt; Prelude.<span class="hljs-built_in"><span class="hljs-built_in">String</span></span> -&gt; IO (Maybe Prelude.<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>) getVideoInfo flag filename = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> (code, out, _) &lt;- catch ( readProcessWithExitCode <span class="hljs-string"><span class="hljs-string">"exiftool"</span></span> [flag, <span class="hljs-string"><span class="hljs-string">"-s"</span></span>, <span class="hljs-string"><span class="hljs-string">"-S"</span></span>, filename] <span class="hljs-string"><span class="hljs-string">""</span></span> ) (\ (_ :: Control.Exception.IOException) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (ExitFailure <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> code == System.Exit.ExitSuccess then <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (Just out) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Nothing isVideo :: Prelude.<span class="hljs-built_in"><span class="hljs-built_in">String</span></span> -&gt; IO Bool isVideo filename = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> maybeOut &lt;- getVideoInfo <span class="hljs-string"><span class="hljs-string">"-MIMEType"</span></span> filename case maybeOut of Nothing -&gt; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> False Just out -&gt; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-string"><span class="hljs-string">"video"</span></span> `isInfixOf` pack out) getWindowSize :: Int -&gt; Prelude.<span class="hljs-built_in"><span class="hljs-built_in">String</span></span> -&gt; IO (Maybe (Int32, Int32)) getWindowSize desiredVideoWidth filename = isVideo filename &gt;&gt;= getWidthHeightString &gt;&gt;= splitWidthHeightString &gt;&gt;= widthHeightToDouble &gt;&gt;= ratio &gt;&gt;= windowSize <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> getWidthHeightString :: Bool -&gt; IO (Maybe Prelude.<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>) getWidthHeightString False = <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Nothing getWidthHeightString True = getVideoInfo <span class="hljs-string"><span class="hljs-string">"-ImageSize"</span></span> filename splitWidthHeightString :: Maybe Prelude.<span class="hljs-built_in"><span class="hljs-built_in">String</span></span> -&gt; IO (Maybe [Text]) splitWidthHeightString Nothing = <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Nothing splitWidthHeightString (Just string) = <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (Just (Data.Text.splitOn <span class="hljs-string"><span class="hljs-string">"x"</span></span> (pack string))) widthHeightToDouble :: Maybe [Text] -&gt; IO (Maybe Double, Maybe Double) widthHeightToDouble (Just (x:y:_)) = <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (readMaybe (unpack x) :: Maybe Double, readMaybe (unpack y) :: Maybe Double) widthHeightToDouble _ = <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (Nothing, Nothing) ratio :: (Maybe Double, Maybe Double) -&gt; IO (Maybe Double) ratio (Just width, Just height) = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> width &lt;= <span class="hljs-number"><span class="hljs-number">0.0</span></span> then <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Nothing <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (Just (height / width)) ratio _ = <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Nothing windowSize :: Maybe Double -&gt; IO (Maybe (Int32, Int32)) windowSize Nothing = <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Nothing windowSize (Just ratio') = <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (Just (fromIntegral desiredVideoWidth :: Int32, round ((fromIntegral desiredVideoWidth :: Double) * ratio') :: Int32)) getDesiredVideoWidth :: GI.Gtk.ComboBoxText -&gt; IO Int getDesiredVideoWidth = fmap (\ x -&gt; read (Data.Text.unpack x) :: Int) . GI.Gtk.comboBoxTextGetActiveText setWindowSize :: Int32 -&gt; Int32 -&gt; GI.Gtk.FileChooserButton -&gt; GI.Gtk.Widget -&gt; GI.Gtk.Window -&gt; IO () setWindowSize width height fileChooserButton drawingArea window = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> GI.Gtk.setWidgetWidthRequest fileChooserButton width GI.Gtk.setWidgetWidthRequest drawingArea width GI.Gtk.setWidgetHeightRequest drawingArea height GI.Gtk.setWidgetWidthRequest window width GI.Gtk.setWidgetHeightRequest window height GI.Gtk.windowResize window width (<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> height &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span> then <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> height) resetWindowSize :: (Integral a) =&gt; a -&gt; GI.Gtk.FileChooserButton -&gt; GI.Gtk.Widget -&gt; GI.Gtk.Window -&gt; IO () resetWindowSize width' fileChooserButton drawingArea window = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> width = fromIntegral width' :: Int32 GI.Gtk.widgetQueueDraw drawingArea setWindowSize width <span class="hljs-number"><span class="hljs-number">0</span></span> fileChooserButton drawingArea window</code> </pre> <br><h2 id="sobiraem-movie-monad">  Movie Monad </h2><br><p>          ,   Movie Monad    . </p><br><pre> <code class="hljs dos"><span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> movie-monad/ stack clean stack install stack exec -- movie-monad # Or just `movie-monad` <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> `stack <span class="hljs-built_in"><span class="hljs-built_in">path</span></span> | grep local-bin-<span class="hljs-built_in"><span class="hljs-built_in">path</span></span>` is <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> your `<span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> $<span class="hljs-built_in"><span class="hljs-built_in">PATH</span></span>`</code> </pre> <br><p>    ,  Movie Monad  . </p><br><h2 id="zaklyuchenie">  Conclusion </h2><br><p>   <a href="https://github.com/lettier/movie-monad">Movie Monad</a> ,         GTK+  GStreamer.       ,   Electron-. Movie Monad           . </p><br><p>    GTK+    .        ,   GTK+  ~50 ,   Electron ‚Äî ~300  (500%- ). </p><br><p> ,   GTK+       .     ,   Electron    - .     haskell-gi       . </p><br><p>     ,    GTK+  Haskell,     <a href="https://github.com/lettier/gifcurry">Gifcurry</a> .             . </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/338176/">https://habr.com/ru/post/338176/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../338166/index.html">Use PowerShell for IT security. Part III: Budget Classification</a></li>
<li><a href="../338168/index.html">Do-it-yourself Windows server file backup</a></li>
<li><a href="../338170/index.html">Timing attack on Node.js - when time works against you</a></li>
<li><a href="../338172/index.html">Work with smart contracts through Ethereum RPC API</a></li>
<li><a href="../338174/index.html">Infographics: all 42 spacecraft buried on other planets in the solar system</a></li>
<li><a href="../338178/index.html">Sotsinzhiniring in military propaganda</a></li>
<li><a href="../338180/index.html">Materials from VLDB, conferences about the future of databases</a></li>
<li><a href="../338186/index.html">Data geometry 1. Simplexes and graphs</a></li>
<li><a href="../338188/index.html">Control of dangerous cash operations: integration of video surveillance with 1C</a></li>
<li><a href="../338190/index.html">Generating a family tree based on Wikipedia data</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>