<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Why do we need all these functors and monads?</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Very often in articles about Haskell pretty often there are functors and especially monads. 
 So often that sometimes the comments ‚Äúhow much is possib...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Why do we need all these functors and monads?</h1><div class="post__text post__text-html js-mediator-article">  Very often in articles about Haskell pretty often there are functors and especially monads. <br>  So often that sometimes the comments ‚Äúhow much is possible about some new monads‚Äù and ‚Äúwrite about something useful‚Äù are not less frequent. <br>  In my opinion, this indicates that people sometimes do not understand why we need all these functors and monads. <br><br>  This article is an attempt to show that the power of functional languages, and especially Haskell, is also the power of functors and monads. <br><img src="https://habrastorage.org/getpro/habr/post_images/665/815/3a8/6658153a81883ae24da9bc4fdfe5714e.png"><br><a name="habracut"></a><br><h4>  Clean data </h4><br>  I will try to show this with an example of a rather artificial and probably useless, however, the emphasis will be placed on the importance of using a common code and reuse. <br><br>  The term ‚Äúclean‚Äù is overloaded in programming. <br>  For example, the phrase ‚ÄúRuby is a purely objective language‚Äù we understand as ‚ÄúRuby is a language, where everything is objects‚Äù. <br>  But the phrase "Haskell is a pure functional language" should be understood as "Haskell is a functional language without side effects." <br>  In this article we will use the term ‚Äúpure‚Äù in another context. <br>  ‚ÄúNet data‚Äù is the data I want to get. <br>  Mostly primitive types are numbers, strings, sometimes more complex ones, for example, a picture or several values. <br>  Accordingly, ‚Äúdirty data‚Äù is data that contains, in addition to what I want, additional information. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Here's a program: <br><pre><code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">module</span></span> Main <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> foo = undefined <span class="hljs-comment"><span class="hljs-comment">--   main :: IO () main = do putStrLn "Input a: " a &lt;- getLine --  1    putStrLn "Input b: " b &lt;- getLine --  2    print (foo ab) --   </span></span></code> </pre> <br>  The program is simple to disgrace - we ask the user to enter 2 lines, and then output the result of the calculation. <br>  We see that our foo function is not yet defined (it always causes the program to crash), although Haskel can already compile our code. <br><br>  Now we will rewrite our function in more detail using only ‚Äúpure‚Äù data: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">pure1arg</span></span> :: <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> pure1arg = (+ <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-comment"><span class="hljs-comment">--   ,   1  pure2args :: Int -&gt; Int -&gt; Int pure2args = (+) --  ,   2  unsafe2args :: Int -&gt; Int -&gt; Int unsafe2args = div --   ,   2  foo :: String -&gt; String -&gt; Int foo ab = unsafe2args extraUnsafeE unsafeC --     ,     where unsafeA :: Int unsafeA = read a --           unsafeB :: Int unsafeB = read b --  unsafeA    unsafeC :: Int unsafeC = pure1arg unsafeB --    1     reallyUnsafeD :: Int reallyUnsafeD = pure2args unsafeA unsafeC --    2     extraUnsafeE :: Int extraUnsafeE = unsafe2args unsafeA reallyUnsafeD --    2 .  2   .</span></span></code> </pre><br>  As you can see, it is also clear here, the function <code>foo</code> is essentially [no matter what] a mixture of integer division and sums. <br>  Most functional programming languages ‚Äã‚Äãmake it easy to create functions based on pure data. <br><br>  It would seem that everything is great - a simple and elegant program.  But netushki! <br>  The result of the function is much more complicated than we would like. <br>  As we understand, it is impossible to divide by <code>0</code> , and the user can enter not the numbers, but the left strings, and when converting strings to numbers can throw out an error.  Our code is not safe. <br>  The imperative approach to solving such problems is divided into 2 groups: either use branching, or use exceptions.  Often, both approaches are combined. <br>  These approaches are so effective that they are mainly used in functional languages. <br>  Let's face it - there are exceptions in Haskell, but they are underdeveloped, need to be reformed, are not caught in the best way.  And most importantly - in most cases they are simply not needed. <br>  But it is no less - possible. <br>  Therefore, we will try to rewrite our code using branches and exceptions. <br><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">module</span></span> Main <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Control.Exception (<span class="hljs-type"><span class="hljs-type">IOException</span></span>, <span class="hljs-title"><span class="hljs-title">catch</span></span>) printError :: IOException -&gt; IO () printError = print pure2args :: Int -&gt; Int -&gt; Int pure2args = (+) pure1arg :: Int -&gt; Int pure1arg = (+ 1) unsafe2args :: Int -&gt; Int -&gt; Int unsafe2args ab = if b == 0 then error "Error 'unsafe2args' : wrong 2nd argument = 0" <span class="hljs-comment"><span class="hljs-comment">--unsafe source of IOException else div ab foo :: String -&gt; String -&gt; Int foo ab = unsafe2args extraUnsafeE unsafeC where unsafeA :: Int unsafeA = read a --unsafe source of IOException unsafeB :: Int unsafeB = read b --unsafe source of IOException unsafeC :: Int unsafeC = pure1arg unsafeB reallyUnsafeD :: Int reallyUnsafeD = pure2args unsafeA unsafeC extraUnsafeE :: Int extraUnsafeE = unsafe2args unsafeA reallyUnsafeD main :: IO () main = do putStrLn "Input a: " a &lt;- getLine putStrLn "Input b: " b &lt;- getLine catch (print (foo ab)) printError --      IOException</span></span></code> </pre><br><h4>  Dirty data </h4><br>  In Haskell (and in many functional languages) there is a worthy answer to such problems. <br>  The main strength lies in Algebraic Data Types. <br><br>  If we consider the above example, it is clear that our functions may fall. <br>  The solution is to use plain data types. <br>  In ML languages ‚Äã‚Äãand Scala, this type is called <code>Option</code> , in Haskell, it is called <code>Maybe a</code> . <br><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Prelude <span class="hljs-keyword"><span class="hljs-keyword">hiding</span></span> (<span class="hljs-type"><span class="hljs-type">Maybe</span></span>) <span class="hljs-comment"><span class="hljs-comment">--       .       data Maybe a = Nothing | Just a deriving Show</span></span></code> </pre><br>  We do not pay attention to the <code>deriving</code> part, we simply say that we ask the compiler to be able to translate our data type into a string. <br>  Namely, <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">show</span></span> <span class="hljs-type"><span class="hljs-type">Nothing</span></span> == <span class="hljs-string"><span class="hljs-string">"Nothing"</span></span> show (<span class="hljs-type"><span class="hljs-type">Just</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>) == <span class="hljs-string"><span class="hljs-string">"Just 3"</span></span></code> </pre><br>  The data type is <code>Nothing</code> if we have no data, and <code>Just a</code> if it has one. <br>  As you can see, the data type is ‚Äúdirty‚Äù because it contains extra information. <br>  Let's rewrite our functions more correctly, more safely and without exceptions. <br><br>  First of all, let's replace the functions that caused the drop on safe analogues: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">maybeResult2args</span></span> :: <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Maybe</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> maybeResult2args ab = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> b == <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-type"><span class="hljs-type">Nothing</span></span> <span class="hljs-comment"><span class="hljs-comment">--safe else Just (div ab) ... maybeA :: Maybe Int maybeA = readMaybe a --safe maybeB :: Maybe Int maybeB = readMaybe b --safe</span></span></code> </pre><br>  Now, these functions instead of falling give the result <code>Nothing</code> , if everything is in order, then <code>Just </code> . <br><br>  But the rest of the code depends on these functions.  We will have to change almost all the functions, including those that have been tested many times. <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">pure2args</span></span> :: <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> pure2args = (+) safePure2args :: <span class="hljs-type"><span class="hljs-type">Maybe</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Maybe</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Maybe</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> safePure2args ab = <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> a <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-type"><span class="hljs-type">Nothing</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Nothing</span></span> <span class="hljs-type"><span class="hljs-type">Just</span></span> a' -&gt; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> b <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-type"><span class="hljs-type">Nothing</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Nothing</span></span> <span class="hljs-type"><span class="hljs-type">Just</span></span> b' -&gt; <span class="hljs-type"><span class="hljs-type">Just</span></span> (pure2args a' b') pure1arg :: <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> pure1arg = (+ <span class="hljs-number"><span class="hljs-number">1</span></span>) safePure1arg :: <span class="hljs-type"><span class="hljs-type">Maybe</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Maybe</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> safePure1arg a = <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> a <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-type"><span class="hljs-type">Nothing</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Nothing</span></span> <span class="hljs-type"><span class="hljs-type">Just</span></span> a' -&gt; <span class="hljs-type"><span class="hljs-type">Just</span></span> (pure1arg a') maybeResult2args :: <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Maybe</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> maybeResult2args ab = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> b == <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-type"><span class="hljs-type">Nothing</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-type"><span class="hljs-type">Just</span></span> (div ab) foo :: <span class="hljs-type"><span class="hljs-type">String</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">String</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Maybe</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> foo ab = <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> maybeE <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-type"><span class="hljs-type">Nothing</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Nothing</span></span> <span class="hljs-type"><span class="hljs-type">Just</span></span> e -&gt; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> maybeC <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-type"><span class="hljs-type">Nothing</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Nothing</span></span> <span class="hljs-type"><span class="hljs-type">Just</span></span> c -&gt; maybeResult2args ec <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> maybeA :: <span class="hljs-type"><span class="hljs-type">Maybe</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> maybeA = readMaybe a maybeB :: <span class="hljs-type"><span class="hljs-type">Maybe</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> maybeB = readMaybe b maybeC :: <span class="hljs-type"><span class="hljs-type">Maybe</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> maybeC = safePure1arg maybeB maybeD :: <span class="hljs-type"><span class="hljs-type">Maybe</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> maybeD = safePure2args maybeA maybeC maybeE = <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> maybeA <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-type"><span class="hljs-type">Nothing</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Nothing</span></span> <span class="hljs-type"><span class="hljs-type">Just</span></span> a1 -&gt; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> maybeD <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-type"><span class="hljs-type">Nothing</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Nothing</span></span> <span class="hljs-type"><span class="hljs-type">Just</span></span> d -&gt; maybeResult2args a1 d printMaybe :: <span class="hljs-type"><span class="hljs-type">Show</span></span> a =&gt; <span class="hljs-type"><span class="hljs-type">Maybe</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">IO</span></span> () printMaybe <span class="hljs-type"><span class="hljs-type">Nothing</span></span> = print <span class="hljs-string"><span class="hljs-string">"Something Wrong"</span></span> printMaybe (<span class="hljs-type"><span class="hljs-type">Just</span></span> a) = print a main :: <span class="hljs-type"><span class="hljs-type">IO</span></span> () main = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> putStrLn <span class="hljs-string"><span class="hljs-string">"Input a: "</span></span> a &lt;- getLine putStrLn <span class="hljs-string"><span class="hljs-string">"Input b: "</span></span> b &lt;- getLine printMaybe (foo ab)</code> </pre><br>  As you can see a simple program has turned into a rather monstro-shaped code. <br>  A lot of wrapper functions, a lot of redundant code, a lot has been changed. <br>  But this is where many functional programming languages ‚Äã‚Äãstop. <br>  Now you can understand why in those languages, despite the possibility of creating a lot of ADT, ADT is not so often used in the code. <br><br>  You can live with ATD, but without a similar orgy?  It turns out you can. <br><br><h4>  Functors </h4><br>  Functors come to our aid in the beginning. <br><br>  Functors are those data types for which the <code>fmap</code> function exists. <br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Functor</span></span></span><span class="hljs-class"> f </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> fmap :: (a -&gt; b) -&gt; fa -&gt; fb</code> </pre><br>  as well as his infix synonym: <br><pre> <code class="haskell hljs">(&lt;$&gt;) :: <span class="hljs-type"><span class="hljs-type">Functor</span></span> f =&gt; (a -&gt; b) -&gt; fa -&gt; fb (&lt;$&gt;) = fmap</code> </pre><br>  such that for all values ‚Äã‚Äãof the data type the following conditions are always met: <br><br>  Identity condition: <br> <code>fmap id == id</code> <br>  Composition condition: <br> <code>fmap (f . g) == fmap f . fmap g</code> <br> <br>  Where <code>id</code> is an identity function <br><pre> <code class="haskell hljs"> id :: a -&gt; a id x = x</code> </pre><br>  And <code>(.)</code> - functional composition <br><pre> <code class="haskell hljs"> (.) :: (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c f . g = \x -&gt; f (gx)</code> </pre><br>  The functor is a type class where we have created a special function <code>fmap</code> .  Let's look at its arguments - it takes one ‚Äúpure‚Äù function <code>a -&gt; b</code> , we take the ‚Äúdirty‚Äù functor value <code>fa</code> and get the output functor value <code>fb</code> . <br><br>  The data type <code>Maybe</code> is a functor.  Create an instance (instance) for the type <code>Maybe</code> , so that the laws of the functors are not violated: <br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">instance</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Functor</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Maybe</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> fmap _ <span class="hljs-type"><span class="hljs-type">Nothing</span></span> = <span class="hljs-type"><span class="hljs-type">Nothing</span></span> fmap f (<span class="hljs-type"><span class="hljs-type">Just</span></span> a) = <span class="hljs-type"><span class="hljs-type">Just</span></span> (fa)</code> </pre><br>  How do we use a pure function with the <code>Maybe</code> functor?  Very simple: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">safePure1arg</span></span> :: <span class="hljs-type"><span class="hljs-type">Maybe</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Maybe</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> safePure1arg = fmap pure1arg</code> </pre><br>  We see the most important thing here - we did not rewrite our <code>pure1arg</code> function, which means we don‚Äôt have to test it again for bugs and everything remained universal and clean, but we easily created its safe version, which accepts not numbers for input, but simple ones numbers <br><br>  However, if we want to use a functor, trying to rewrite <code>safePure2args</code> , we‚Äôll be a fiasco. <br>  Functors work only with functions with a single functor-dirty argument. <br>  What to do for functions with several parameters? <br><br><h4>  Applicative Functors </h4><br>  Here applicative functors come to the rescue: <br><br>  Applicative functors are such functors for which 2 functions are defined: <code>pure</code> and <code>(&lt;*&gt;)</code> <br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Functor</span></span></span><span class="hljs-class"> f =&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Applicative</span></span></span><span class="hljs-class"> f </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> pure :: a -&gt; fa (&lt;*&gt;) :: f (a -&gt; b) -&gt; fa -&gt; fb</code> </pre><br>  Such that for them for any values ‚Äã‚Äãof one data type the following rules are always executed: <br><br>  Identity condition: <br> <code>pure id &lt;*&gt; v == v</code> <br>  Composition condition: <br> <code>pure (.) &lt;*&gt; u &lt;*&gt; v &lt;*&gt; w == u &lt;*&gt; (v &lt;*&gt; w)</code> <br>  The homomorphism condition: <br> <code>pure f &lt;*&gt; pure x == pure (fx)</code> <br>  Exchange condition: <br> <code>u &lt;*&gt; pure y == pure ($ y) &lt;*&gt; u</code> <br> <br>  The main distinction of the funtor from the applicative funtor is that the funder pulls a pure function through the functor value, while the applicator allows us to drag the functor function <code>f (a -&gt; b)</code> through the functor value. <br><br>  Maybe is an applicative functor and is defined as follows: <br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">instance</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Applicative</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Maybe</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> pure = <span class="hljs-type"><span class="hljs-type">Just</span></span> <span class="hljs-type"><span class="hljs-type">Nothing</span></span> &lt;*&gt; _ = <span class="hljs-type"><span class="hljs-type">Nothing</span></span> _ &lt;*&gt; <span class="hljs-type"><span class="hljs-type">Nothing</span></span> = <span class="hljs-type"><span class="hljs-type">Nothing</span></span> (<span class="hljs-type"><span class="hljs-type">Just</span></span> f) &lt;*&gt; (<span class="hljs-type"><span class="hljs-type">Just</span></span> a) = <span class="hljs-type"><span class="hljs-type">Just</span></span> (fa)</code> </pre><br>  It's time to rewrite <code>safePure2args</code> . <br>  Basically, the function is rewritten, combining the functor <code>fmap</code> for the first argument, and the applicative stringing of the remaining arguments: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">safePure2args</span></span> :: <span class="hljs-type"><span class="hljs-type">Maybe</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Maybe</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Maybe</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> safePure2args ab = pure2args &lt;$&gt; a &lt;*&gt; b</code> </pre><br>  But you can rewrite the function using exclusively applicative functions (monad style) - first, we make the pure function purely applicative, and applicatively string the arguments: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">safePure2args</span></span> :: <span class="hljs-type"><span class="hljs-type">Maybe</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Maybe</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Maybe</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> safePure2args ab = (pure pure2args) &lt;*&gt; a &lt;*&gt; b</code> </pre><br>  Wonderful! <br>  Can it be possible at the same time to rewrite the function <code>maybeE</code> with the help of applicative functors?  Alas. <br><br><h4>  Monads </h4><br>  Let's take a look at the signature of the <code>maybeResult2args</code> function: <br> <code>maybeResult2args :: Int -&gt; Int -&gt; Maybe Int</code> <br>  The function takes as input the "clean" arguments, and gives the output a "dirty" result. <br>  So, for the most part in real programming, it is these functions that are most often encountered - they take ‚Äúclean‚Äù arguments as input, and ‚Äúdirty‚Äù result as output. <br>  And when we have several such functions, monads help to combine them together. <br><br>  Monads are data types for which there are <code>return</code> and <code>(&gt;&gt;=)</code> functions <br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Monad</span></span></span><span class="hljs-class"> m </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> return :: a -&gt; ma (&gt;&gt;=) :: ma -&gt; (a -&gt; mb) -&gt; mb</code> </pre><br>  such that the rules for any values ‚Äã‚Äãof type are executed: <br><br>  Left identity: <br> <code>return a &gt;&gt;= k == ka</code> <br>  Right Identity: <br> <code>m &gt;&gt;= return == m</code> <br>  Associativity: <br> <code>m &gt;&gt;= (\x -&gt; kx &gt;&gt;= h) == (m &gt;&gt;= k) &gt;&gt;= h</code> <br> <br>  For convenience, there is an additional function with the reverse order of the arguments: <br><pre> <code class="haskell hljs">(=&lt;&lt;) :: <span class="hljs-type"><span class="hljs-type">Monad</span></span> m =&gt; (a -&gt; mb) -&gt; ma -&gt; mb (=&lt;&lt;) = flip (&gt;&gt;=)</code> </pre><br>  Where <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">flip</span></span> :: (a -&gt; b -&gt; c) -&gt; b -&gt; a -&gt; c flip fab = fba</code> </pre><br>  We understand that the <code>Maybe</code> type is a monad, which means we can define its instance (instance): <br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">instance</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Monad</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Maybe</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> return = <span class="hljs-type"><span class="hljs-type">Just</span></span> (<span class="hljs-type"><span class="hljs-type">Just</span></span> x) &gt;&gt;= k = kx <span class="hljs-type"><span class="hljs-type">Nothing</span></span> &gt;&gt;= _ = <span class="hljs-type"><span class="hljs-type">Nothing</span></span></code> </pre><br>  By the way, if we look closely at the internal content and signatures, we see that: <br> <code>pure == return</code> <br> <code>fmap f xs == xs &gt;&gt;= return . f</code> <br> <br>  It's time to rewrite the function <code>maybeE</code> <br><pre> <code class="haskell hljs"> maybeE = maybeA &gt;&gt;= (\a1 -&gt; maybeD &gt;&gt;= (maybeResult2args a1))</code> </pre><br>  Yeah, it turned out not much more beautiful.  This is due to the fact that monads are beautifully written for one variable.  Fortunately, there are many additional features. <br>  You can write <code>bind2</code> function <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">bind2</span></span> :: <span class="hljs-type"><span class="hljs-type">Monad</span></span> m =&gt; (a -&gt; b -&gt; mc) -&gt; ma -&gt; mb -&gt; mc bind2 mf mx my = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> x &lt;- mx y &lt;- my mf xy</code> </pre><br><pre> <code class="haskell hljs"> maybeE = bind2 maybeResult2args maybeA maybeD</code> </pre><br>  Or use the <code>liftM2</code> and <code>join</code> functions <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">liftM2</span></span> :: <span class="hljs-type"><span class="hljs-type">Monad</span></span> m =&gt; (a1 -&gt; a2 -&gt; r) -&gt; m a1 -&gt; m a2 -&gt; mr join :: <span class="hljs-type"><span class="hljs-type">Monad</span></span> m =&gt; m (ma) -&gt; ma maybeE = join $ liftM2 maybeResult2args maybeA maybeD</code> </pre><br>  In extreme cases, you can use syntax sugar for monads using <code>do</code> notation: <br><pre> <code class="haskell hljs"> maybeE = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> a1 &lt;- maybeA d &lt;- maybeD maybeResult2args a1 d</code> </pre><br><h4>  Differences in the use of funtors and monads </h4><br>  If we reduce the basic functions to one type, we will see: <br><pre> <code class="haskell hljs">(&lt;$&gt;) :: <span class="hljs-type"><span class="hljs-type">Functor</span></span> f =&gt; (a -&gt; b) -&gt; fa -&gt; fb (&lt;*&gt;) :: <span class="hljs-type"><span class="hljs-type">Applicative</span></span> f =&gt; f (a -&gt; b) -&gt; fa -&gt; fb (=&lt;&lt;) :: <span class="hljs-type"><span class="hljs-type">Monad</span></span> f =&gt; (a -&gt; fb) -&gt; fa -&gt; fb</code> </pre><br>  All are used to pass ‚Äúdirty‚Äù values ‚Äã‚Äãto functions, while functions expect ‚Äúclean‚Äù values ‚Äã‚Äãat the input. <br>  Funtori use the "clean" function. <br>  Applicative functors are a ‚Äúpure‚Äù function inside ‚Äúpollution‚Äù. <br>  Monads use functions that have a ‚Äúdirty‚Äù meaning at the exit. <br><br><h4>  Program without routine </h4><br>  Well, finally, you can completely and accurately rewrite the entire program: <br><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">module</span></span> Main <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Control.Monad <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Control.Applicative <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Text.Read (<span class="hljs-title"><span class="hljs-title">readMaybe</span></span>) bind2 :: Monad m =&gt; (<span class="hljs-title"><span class="hljs-title">a</span></span> -&gt; <span class="hljs-title"><span class="hljs-title">b</span></span> -&gt; <span class="hljs-title"><span class="hljs-title">mc</span></span>) -&gt; ma -&gt; mb -&gt; mc bind2 mf mx my = do x &lt;- mx y &lt;- my mf xy pure2args :: Int -&gt; Int -&gt; Int pure2args = (+) pure1arg :: Int -&gt; Int pure1arg = (+ 1) maybeResult2args :: Int -&gt; Int -&gt; Maybe Int maybeResult2args ab = if b == 0 then Nothing <span class="hljs-comment"><span class="hljs-comment">--safe else Just (div ab) foo :: String -&gt; String -&gt; Maybe Int foo ab = bind2 maybeResult2args maybeE maybeC where maybeA :: Maybe Int maybeA = readMaybe a --safe maybeB :: Maybe Int maybeB = readMaybe b --safe maybeC :: Maybe Int maybeC = fmap pure1arg maybeB maybeD :: Maybe Int maybeD = pure2args &lt;$&gt; maybeA &lt;*&gt; maybeC maybeE :: Maybe Int maybeE = bind2 maybeResult2args maybeA maybeD printMaybe :: Show a =&gt; Maybe a -&gt; IO () printMaybe Nothing = print "Something Wrong" printMaybe (Just a) = print a main :: IO () main = do putStrLn "Input a: " a &lt;- getLine putStrLn "Input b: " b &lt;- getLine printMaybe (foo ab)</span></span></code> </pre><br>  The code became simple and clear again! <br>  At the same time, we did not sacrifice a safety span! <br>  At the same time, we almost did not change the code! <br>  At the same time, the pure functions remained pure! <br>  At the same time avoided the routine! <br><br><h4>  Conclusion </h4><br>  Is it possible to live in a functional world without functors and monads?  Can. <br>  But, if we want to use the full force of Algebraic Data Types with all our might, we will have to use functors and monads for convenient functional composition of various functions. <br>  For this is an excellent remedy for the routine and the path to short, understandable and frequently re-used code! <br><br>  <b>PS</b> It should be understood that for different types of data, the analogy with the "clean" and "dirty" data types is not quite appropriate. <br>  For example, for lists <br> <code>fmap = map</code> <br>  And the monad: <br><pre> <code class="haskell hljs"> a = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> c &lt;- cs d &lt;- ds return (zet cd)</code> </pre><br>  really is <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">a</span></span> = [zet cd | c &lt;- cs, d &lt;- ds]</code> </pre><br>  What is not always obvious at first sight. </div><p>Source: <a href="https://habr.com/ru/post/212955/">https://habr.com/ru/post/212955/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../212939/index.html">Why is the mouse cursor tilted at 45 ¬∞?</a></li>
<li><a href="../212941/index.html">Octodon: going deeper underground</a></li>
<li><a href="../212943/index.html">Jacques Arsac. 1929-2014</a></li>
<li><a href="../212947/index.html">Briefly about the perfect 7-port USB 3.0 hub ORICO</a></li>
<li><a href="../212953/index.html">Simple monitoring of DFS Replication in Zabbix</a></li>
<li><a href="../212957/index.html">Whatsapp came out on the warpath</a></li>
<li><a href="../212959/index.html">How we: hover on iOS won ...</a></li>
<li><a href="../212963/index.html">Our IT market in pictures by segment</a></li>
<li><a href="../212965/index.html">Free codecs won the Wikipedia vote</a></li>
<li><a href="../212969/index.html">About the features of the introduction of open source software in small business</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>