<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How can PVS-Studio help in finding vulnerabilities?</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Vulnerability in terms of computer security is a flaw in the system that allows you to deliberately violate its integrity or cause incorrect operation...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How can PVS-Studio help in finding vulnerabilities?</h1><div class="post__text post__text-html js-mediator-article"><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b5f/f9c/33f/b5ff9c33feffb16b940fe748d07d1062.png"></div><p></p><br>  Vulnerability in terms of computer security is a flaw in the system that allows you to deliberately violate its integrity or cause incorrect operation.  As practice shows, even a seemingly insignificant bug can be a serious vulnerability.  Vulnerabilities can be avoided using various methods of software validation and verification, including static analysis.  How PVS-Studio copes with the vulnerability search task is discussed. <br><a name="habracut"></a><br><br><h2>  PVS-Studio is a tool that prevents not only errors, but also vulnerabilities </h2><br>  How we came to this conclusion, I will tell a little lower.  Here I wanted to talk about what PVS-Studio is. <br><br><p><img src="https://habrastorage.org/getpro/habr/post_images/d2b/0d1/4ba/d2b0d14baf58803b6eda44ce674ad120.png" alt="Picture 4"></p>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      PVS-Studio is a static code analyzer that looks for errors (and vulnerabilities, as you will see later) in programs written in C, C ++, C #.  It works under Windows and Linux, it can be built into the Visual Studio IDE as a plugin.  Currently, the analyzer implements over 450 diagnostic rules, each of which is accompanied by <a href="https://www.viva64.com/ru/w/">documentation</a> . <br><br>  At the time of writing this article, using PVS-Studio, more than <a href="https://www.viva64.com/ru/inspections/">280 open source projects were</a> tested, in which over <a href="https://www.viva64.com/ru/examples/">11,000 errors</a> were found.  I wonder how many of these errors are vulnerabilities ... <br><br>  Download and try PVS-Studio on the <a href="https://www.viva64.com/ru/pvs-studio/">official website</a> . <br><br>  By the way, we offer licenses for PVS-Studio to security experts.  If you are a public security expert and are searching for vulnerabilities, email us for a license.  You can read more about this offer in the article " <a href="https://www.viva64.com/ru/b/0510/">We provide the PVS-Studio analyzer to security experts</a> ". <br><br><h2>  Terminology </h2><br>  If you are good at terminology, you know how CVE differs from CWE, and what they have in common, you can skip this section.  I advise the rest to read, so that it is easier to understand further. <br><br>  CWE (Common Weakness Enumeration) - a common list of security defects.  Designed for software developers and security professionals.  It is an official registry or dictionary of common security defects that can manifest themselves in architecture, design, code or software implementation, and can be used by attackers to gain unauthorized access to the system.  This list was developed as a universal formal language for describing software security defects, as well as a standard for measuring the effectiveness of tools that detect such defects, and for recognizing, eliminating, and preventing these defects. <br><br>  CVE (Common Vulnerabilities and Exposures) - program errors that can be directly used by hackers. <br><br>  MITER began work on the classification of software vulnerabilities in 1999, when a list of common vulnerabilities and software exposure vulnerabilities (CVE) was based.  In 2005, as part of the further development of the CVE system, a team of authors began work on a preliminary classification of vulnerabilities, attacks, failures and other types of security problems in order to define common software security defects.  However, despite the self-sufficiency of the created classification within the CVE, it turned out to be too coarse for defining and classifying the code security assessment methods used by analyzers.  To solve this problem, the CWE list was created. <br><br><h2>  PVS-Studio: other positioning </h2><br><h3>  Prehistory </h3><br>  We have always positioned PVS-Studio as a tool for finding errors in the program code.  The articles on the verification of projects used the appropriate terminology: bug, error, typo, etc.  It is clear that different errors have different criticality: this code, most likely, is simply redundant and confuses the programmer, but because of this error, the entire system falls at 5 am every 3 days.  It was clear, this concept did not receive further development for a long time - mistakes, they are mistakes. <br><br>  However, over time, it turned out that some of the errors detected by PVS-Studio can be treated in a more serious way.  For example, improper use of the <i>printf</i> function can lead to much more negative consequences than outputting the wrong message in <i>stdout</i> .  When it became clear that with the help of many diagnostic rules, it was possible to detect not just errors, but potential vulnerabilities (CWE), it was decided to approach the issue in more detail and see how the PVS-Studio and CWE diagnostic rules relate. <br><br><h3>  Relationship of PVS-Studio and CWE alerts </h3><br>  Based on the results of work on identifying the relationship between the warnings of PVS-Studio and CWE, the following table was compiled: <br><table><tbody><tr><th width="100">  CWE </th><th>  PVS-Studio </th><th>  CWE Description </th></tr><tr><td>  CWE-14 </td><td>  V597 </td><td>  Compiler Removal of Code to Clear Buffers </td></tr><tr><td>  CWE-36 </td><td>  V631, V3039 </td><td>  Absolute Path Traversal </td></tr><tr><td>  CWE-121 </td><td>  V755 </td><td>  Stack-based Buffer Overflow </td></tr><tr><td>  CWE-122 </td><td>  V755 </td><td>  Heap-based Buffer Overflow </td></tr><tr><td>  CWE-123 </td><td>  V575 </td><td>  Write-what-where Condition </td></tr><tr><td>  CWE-129 </td><td>  V557, V781, V3106 </td><td>  Improper Validation of Array Index </td></tr><tr><td>  CWE-190 </td><td>  V636 </td><td>  Integer overflow or wraparound </td></tr><tr><td>  CWE-193 </td><td>  V645 </td><td>  Off-by-one error </td></tr><tr><td>  CWE-252 </td><td>  V522, V575 </td><td>  Unchecked Return Value </td></tr><tr><td>  CWE-253 </td><td>  V544, V545, V676, V716, V721, V724 </td><td>  Incorrect Check of Function Return Value </td></tr><tr><td>  CWE-390 </td><td>  V565 </td><td>  Detection of Error Condition Without Action </td></tr><tr><td>  CWE-476 </td><td>  V522, V595, V664, V757, V769, V3019, V3042, V3080, V3095, V3105, V3125 </td><td>  NULL Pointer Dereference </td></tr><tr><td>  CWE-481 </td><td>  V559, V3055 </td><td>  Assigning instead of comparing </td></tr><tr><td>  CWE-482 </td><td>  V607 </td><td>  Comparing instead of assigning </td></tr><tr><td>  CWE-587 </td><td>  V566 </td><td>  Assignment of a Fixed Address to a Pointer </td></tr><tr><td>  CWE-369 </td><td>  V609, V3064 </td><td>  Divide by zero </td></tr><tr><td>  CWE-416 </td><td>  V723, V774 </td><td>  Use after free </td></tr><tr><td>  CWE-467 </td><td>  V511, V512, V568 </td><td>  Use of sizeof () on a Pointer Type </td></tr><tr><td>  CWE-805 </td><td>  V512, V594, V3106 </td><td>  Buffer Access with Incorrect Length Value </td></tr><tr><td>  CWE-806 </td><td>  V512 </td><td>  Buffer Access Size Buffer </td></tr><tr><td>  CWE-483 </td><td>  V640, V3043 </td><td>  Incorrect Block Delimitation </td></tr><tr><td>  CWE-134 </td><td>  V576, V618, V3025 </td><td>  Use of Externally-Controlled Format String </td></tr><tr><td>  CWE-135 </td><td>  V518, V635 </td><td>  Incorrect Calculation of Multi-Byte String Length </td></tr><tr><td>  CWE-462 </td><td>  V766, V3058 </td><td>  Duplicate Key in Associative List (Alist) </td></tr><tr><td>  CWE-401 </td><td>  V701, V773 </td><td>  Release Memory Memory Removing Last Reference ('Memory Leak') </td></tr><tr><td>  CWE-468 </td><td>  V613, V620, V643 </td><td>  Incorrect Pointer Scaling </td></tr><tr><td>  CWE-588 </td><td>  V641 </td><td>  Attempt to Access Child of Non-structure Pointer </td></tr><tr><td>  CWE-843 </td><td>  V641 </td><td>  Access of Resource Using Incompatible Type ('Type Confusion') </td></tr><tr><td>  CWE-131 </td><td>  V512, V514, V531, V568, V620, V627, V635, V641, V645, V651, V687, V706, V727 </td><td>  Incorrect Calculation of Buffer Size </td></tr><tr><td>  CWE-195 </td><td>  V569 </td><td>  Signed to Unsigned Conversion Error </td></tr><tr><td>  CWE-197 </td><td>  V642 </td><td>  Numeric Truncation Error </td></tr><tr><td>  CWE-762 </td><td>  V611, V780 </td><td>  Mismatched Memory Management Routines </td></tr><tr><td>  CWE-478 </td><td>  V577, V719, V622, V3002 </td><td>  Missing Default Case in Switch Statement </td></tr><tr><td>  CWE-415 </td><td>  V586 </td><td>  Double free </td></tr><tr><td>  CWE-188 </td><td>  V557, V3106 </td><td>  Reliance on Data / Memory Layout </td></tr><tr><td>  CWE-562 </td><td>  V558 </td><td>  Return of Stack Variable Address </td></tr><tr><td>  CWE-690 </td><td>  V522, V3080 </td><td>  Unchecked Return Value to NULL Pointer Dereference </td></tr><tr><td>  CWE-457 </td><td>  V573, V614, V730, V670, V3070, V3128 </td><td>  Use of Uninitialized Variable </td></tr><tr><td>  CWE-404 </td><td>  V611, V773 </td><td>  Improper Resource Shutdown or Release </td></tr><tr><td>  CWE-563 </td><td>  V519, V603, V751, V763, V3061, V3065, V3077, V3117 </td><td>  Assignment to Variable without Use ('Unused Variable') </td></tr><tr><td>  CWE-561 </td><td>  V551, V695, V734, V776, V779, V3021 </td><td>  Dead code </td></tr><tr><td>  CWE-570 </td><td>  V501, V547, V517, V560, V625, V654, V3022, V3063 </td><td>  Expression is Always False </td></tr><tr><td>  CWE-571 </td><td>  V501, V547, V560, V617, V654, V694, V768, V3022, V3063 </td><td>  Expression is Always True </td></tr><tr><td>  CWE-670 </td><td>  V696 </td><td>  Always-Incorrect Control Flow Implementation </td></tr><tr><td>  CWE-674 </td><td>  V3110 </td><td>  Uncontrolled Recursion </td></tr><tr><td>  CWE-681 </td><td>  V601 </td><td>  Incorrect Conversion between Numeric Types </td></tr><tr><td>  CWE-688 </td><td>  V549 </td><td>  Function Call With Incorrect Variable Or Reference As Argument </td></tr><tr><td>  CWE-697 </td><td>  V556, V668 </td><td>  Insufficient Comparison </td></tr></tbody></table><p>  Table N1 - Draft version of the correspondence table of CWE and PVS-Studio diagnostics </p><br>  This is not the final version of the table, but it does provide some insight into how PVS-Studio and CWE warnings relate to each other.  Now it became clear that PVS-Studio successfully finds (and always finds) in the program code not just bugs, but potential vulnerabilities, that is, CWE.  Several articles have been written on this topic, their list is given at the end of the current article. <br><br><h2>  CVE bases </h2><br><p><img src="https://habrastorage.org/getpro/habr/post_images/b4c/56f/456/b4c56f4561eb3eb5c5b13aa62965239a.png" alt="Picture 2"></p><br><br>  Potential Vulnerability (CWE) is not yet a Vulnerability (CVE).  The real vulnerabilities found in both open source and proprietary projects are collected at <a href="http://cve.mitre.org/">http://cve.mitre.org</a> .  There you can see a description of a specific vulnerability, find additional links (for example, to a discussion, a bulletin of vulnerability fixes, links to commits covering vulnerabilities, etc.).  If desired, this database can be unloaded entirely in the format of interest.  At the time of this writing, the database in text format was a .txt file with a size of about 100 MB and a volume of more than 2.7 million lines.  Very impressive, agree. <br><br><p><img src="https://habrastorage.org/getpro/habr/post_images/e2c/651/b44/e2c651b445dae9720ac8e3deb2423e9f.png" alt="Picture 6"></p><br><br>  In the course of the work, I found another interesting resource that can be useful to those interested - <a href="http://www.cvedetails.com/">http://www.cvedetails.com/</a> .  It is convenient in that it gives opportunities such as: <br><br><ul><li>  CVE lookup by CWE ID; </li><li>  search CVE in a specific product; </li><li>  viewing statistics on the appearance / fixes of vulnerabilities; </li><li>  viewing various data tables related in one way or another to CVE (for example, the rating of firms in whose software products the most vulnerabilities were found); </li><li>  etc. </li></ul><br><h2>  Some CVEs that could be found with PVS-Studio </h2><br>  I am writing this article in order to demonstrate that the PVS-Studio analyzer can protect an application from vulnerabilities (at least from some of them). <br><br>  We never investigated whether a particular defect discovered by PVS-Studio could be exploited as a vulnerability.  It is difficult, and we are not facing such a task.  Therefore, I will act differently: I will take several vulnerabilities that have already been discovered and described, and demonstrate that they could have been avoided if the code were regularly checked using PVS-Studio. <br><br>  <b>Note</b>  The vulnerabilities described in the article were not found in synthetic examples, but in real source files taken from old project revisions. <br><br><h3>  illumos-gate </h3><br><p><img src="https://habrastorage.org/getpro/habr/post_images/03b/409/a97/03b409a9741fc1d15e05499abe0072db.png" alt="Picture 7"></p><br><br>  The first vulnerability, which will be discussed, was discovered in the source code of the illumos-gate project.  illumos-gate is an open source project (available in the <a href="https://github.com/illumos/illumos-gate">repository on GitHub</a> ) that forms the core of the operating system, rooted in Unix and BSD. <br><br>  The vulnerability has the code name <a href="http://cve.mitre.org/cgi-bin/cvename.cgi%3Fname%3DCVE-2014-9491">CVE-2014-9491</a> . <br><br>  <b>CVE-2014-9491 Description</b> : It‚Äôs not a <i>challenge</i> , which makes it possible to send a message through the unspecified vectors. <br><br>  The problem code was in the <i>devzvol_readdir</i> function and looked like this: <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">devzvol_readdir</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *ptr; .... ptr = <span class="hljs-built_in"><span class="hljs-built_in">strchr</span></span>(ptr + <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'/'</span></span>) + <span class="hljs-number"><span class="hljs-number">1</span></span>; rw_exit(&amp;sdvp-&gt;sdev_contents); sdev_iter_datasets(dvp, ZFS_IOC_DATASET_LIST_NEXT, ptr); .... }</code> </pre> <br>  The <i>strchr</i> function returns a pointer to the first occurrence of the character passed as the second argument.  However, the function may return a null pointer if the character was not found in the source string.  But this fact has been forgotten or not taken into account.  As a result, 1 is simply added to the return value, the result is written to the <i>ptr</i> variable, and then the pointer is operated ‚Äúas is‚Äù.  If the received pointer was zero, then adding a unit to it, we get an invalid pointer, checking which for <i>NULL</i> inequality will not mean its validity.  Under certain conditions, this code could lead to the emergence of a <a href="https://en.wikipedia.org/wiki/Kernel_panic">kernel panic</a> . <br><br>  PVS-Studio detects this vulnerability using the <a href="https://www.viva64.com/ru/w/V769/">V769</a> diagnostic rule, <a href="https://www.viva64.com/ru/w/V769/">stating</a> that the pointer returned by the <i>strchr</i> function can be zero, and at the same time it deteriorates (due to the addition 1): <br><br>  V769 The 'strchr (ptr + 1,' / ')' pointer in the 'strchr (ptr + 1,' / ') + 1' expression could be nullptr.  In such a case, it will not be used. <br><br><h3>  Network audio system </h3><br>  Network Audio System (NAS) is an open source client-server audio transmission system <a href="https://sourceforge.net/projects/nas/">available on SourceForge</a> .  NAS works both under Unix and under Windows. <br><br>  The vulnerability discovered in this project has the code name <a href="https://cve.mitre.org/cgi-bin/cvename.cgi%3Fname%3DCVE-2013-4258">CVE-2013-4258</a> . <br><br>  <b>CVE-2013-4258 Description</b> : Function in server / os / aulog.c in Network Audio System (NAS) 1.9.3 allows you to remotely via the system. <i>syslog</i> related format specifiers in unspecified vectors. <br><br>  The code looked like this: <br><br><pre> <code class="cpp hljs">.... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (NasConfig.DoDaemon) { <span class="hljs-comment"><span class="hljs-comment">/* daemons use syslog */</span></span> openlog(<span class="hljs-string"><span class="hljs-string">"nas"</span></span>, LOG_PID, LOG_DAEMON); syslog(LOG_DEBUG, buf); closelog(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { errfd = <span class="hljs-built_in"><span class="hljs-built_in">stderr</span></span>; ....</code> </pre> <br>  This code snippet incorrectly uses the <i>syslog</i> function.  The declaration of this function is as follows: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">syslog</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> priority, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *format, ...)</span></span></span></span>;</code> </pre> <br>  The second parameter must be a format string, and the subsequent ones must be the data required by this string.  Here, there is no format string, and the target message is directly passed as an argument (variable <i>buf</i> ).  This caused a vulnerability that could lead to the execution of arbitrary code. <br><br>  If you believe the <a href="http://www.securityfocus.com/bid/61852">entries in the SecurityFocus database</a> , the vulnerability was manifested in the Debian and Gentoo operating systems. <br><br>  What is PVS-Studio?  PVS-Studio detects this error using the <a href="https://www.viva64.com/ru/w/V618/">V618</a> diagnostic rule and issues a warning: <br><br>  V618 It is dangerous to call the specification of the syslog.  The example of the safe code: printf ("% s", str); <br><br>  The function of annotation of functions implemented in the analyzer and a large number of annotations help to detect this and similar errors - now their number exceeds 6500 for C, C ++ and 900 for C #. <br><br>  The correct call to this function, closing this vulnerability, is as follows: <br><br><pre> <code class="cpp hljs">syslog(LOG_DEBUG, <span class="hljs-string"><span class="hljs-string">"%s"</span></span>, buf);</code> </pre> <br>  It uses the format string <i>"% s"</i> , which makes the <i>syslog</i> function call safe. <br><br><h3>  Ytnef (Yerase's TNEF Stream Reader) </h3><br>  Ytnef is an open source program <a href="https://github.com/Yeraze/ytnef">available on GitHub</a> .  Designed to decode TNEF streams, such as those created in Outlook. <br><br>  Over the past part of 2017, it revealed a number of vulnerabilities described <a href="http://www.cvedetails.com/vulnerability-list/vendor_id-16117/year-2017/Ytnef-Project.html">here</a> .  Consider one of the CVE entries described in this list ‚Äî <a href="http://www.cvedetails.com/cve/CVE-2017-6298/">CVE-2017-6298</a> . <br><br>  <b>Description CVE-2017-6298</b> : An issue was discovered in ytnef before 1.9.1.  This is related to a patch described as "1 of 9. Null Pointer Deref / calloc return value not checked." <br><br>  All the corrected places where a null pointer dereference could occur had approximately the same form: <br><br><pre> <code class="cpp hljs">vl-&gt;data = <span class="hljs-built_in"><span class="hljs-built_in">calloc</span></span>(vl-&gt;size, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(WORD)); temp_word = SwapWord((BYTE*)d, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(WORD)); <span class="hljs-built_in"><span class="hljs-built_in">memcpy</span></span>(vl-&gt;data, &amp;temp_word, vl-&gt;size);</code> </pre> <br>  In all such places, vulnerabilities are related to the misuse of the <i>calloc</i> function.  This function can return a null pointer if it was not possible to allocate the requested memory block.  But the resulting pointer is not checked for <i>NULL</i> inequality, but is used on the assumption that <i>calloc</i> will always return a non-zero pointer.  This is somewhat imprudent. <br><br>  How does PVS-Studio cope with the detection of such vulnerabilities?  Quite easy: the analyzer implements many different diagnostic rules that detect operation with zero pointers. <br><br>  In particular, the vulnerabilities described above will be detected using the <a href="https://www.viva64.com/ru/w/V575/">V575</a> diagnostic rule.  The warning is as follows: <br><br>  V575 The potential null pointer has passed into 'memcpy' function.  Inspect the first argument. <br><br>  The analyzer has detected that a potentially null pointer resulting from a call to the <i>calloc</i> function is passed to the <i>memcpy</i> function without checking for <i>NULL</i> inequality. <br><br>  Thus, PVS-Studio also detected this vulnerability.  But if the analyzer were used regularly in the process of writing code, then this problem could have been prevented even before it got into the version control system ... <br><br><h3>  Mysql </h3><br><p><img src="https://habrastorage.org/getpro/habr/post_images/bca/e9e/6ad/bcae9e6ad4de5aef9e524656ae30b7cf.png" alt="Picture 8"></p><br><br>  MySQL is a free relational database management system.  Typically, MySQL is used as a server that is accessed by local or remote clients, but the distribution package includes an internal server library that allows you to include MySQL in standalone programs. <br><br>  Consider one of the vulnerabilities found in this project - <a href="http://www.cve.mitre.org/cgi-bin/cvename.cgi%3Fname%3DCVE-2012-2122">CVE-2012-2122</a> . <br><br>  <b>Description CVE-2012-2122:</b> sql / <a href="">password.c</a> in Oracle MySQL 5.1.x before 5.1.63, 5.5.x before 5.5.24, and 5.6.x before 5.6.6, and MariaDB 5.1.x before 5.1.62, 5.2.x before 5.2.12, 5.3.x before 5.3.6, and 5.5.x before 5.5.23, it allows improperly checked return value <i>.</i> <br><br>  Here is the code that contains the vulnerability: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> my_bool; <span class="hljs-function"><span class="hljs-function">my_bool </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">check_scramble</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *scramble_arg, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *message, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> uint8 *hash_stage2)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">memcmp</span></span>(hash_stage2, hash_stage2_reassured, SHA1_HASH_SIZE); }</code> </pre> <br>  The <i>memcmp</i> function <i>return type</i> is <i>int</i> , and the <i>check_scramble</i> function return type is <i>my_bool</i> , in fact, <i>char</i> .  As a result, an implicit casting of <i>int</i> to <i>char</i> occurs, in which the values ‚Äã‚Äãof the high-order bits are discarded.  This led to the fact that in about 1 case out of 256 it was possible to connect with any password, knowing the username.  Due to the fact that 300 connection attempts took less than a second, this protection is as good as its absence.  You can read more about this vulnerability through the links mentioned on the <a href="http://www.cve.mitre.org/cgi-bin/cvename.cgi%3Fname%3DCVE-2012-2122">CVE-2012-2122 page</a> . <br><br>  PVS-Studio detects this problem using the <a href="https://www.viva64.com/ru/w/V642/">V642</a> diagnostic rule.  The warning is as follows: <br><br>  V642 Saving the 'memcmp' function result inside the 'char' type variable is inappropriate.  Breaking the program's logic.  password.c <br><br>  It turns out that this vulnerability was discovered using PVS-Studio. <br><br><h3>  iOS </h3><br><p><img src="https://habrastorage.org/getpro/habr/post_images/692/0f6/14a/6920f614a8ccf36680fd50dad832e857.png" alt="Picture 9"></p><br><br>  iOS is a mobile operating system for smartphones, electronic tablets and wearable players, developed and produced by the American company Apple. <br><br>  Consider one of the vulnerabilities to which this operating system was exposed - <a href="https://cve.mitre.org/cgi-bin/cvename.cgi%3Fname%3DCVE-2014-1266">CVE-2014-1266</a> .  Fortunately, in the general access there is a code fragment from which it is clear what the problem was. <br><br>  <b>Description of Vulnerability CVE-2014-1266</b> : The <i>SSL</i> function of libsecurity_ssl / lib / sslKeyExchange.c and the TV 6.x before 6.0.2, and Apple OS X 10.9.x before 10.9.2 TLS Server Key Exchange message, which allows you to download SSL servers by (1) (or) (2) omitting the signing step. <br><br>  The code snippet that led to the vulnerability was as follows: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> OSStatus </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SSLVerifySignedServerKeyExchange</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(SSLContext *ctx, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> isRsa, SSLBuffer signedParams, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *signature, UInt16 signatureLen)</span></span></span><span class="hljs-function"> </span></span>{ OSStatus err; .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((err = SSLHashSHA1.update(&amp;hashCtx, &amp;serverRandom)) != <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> fail; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((err = SSLHashSHA1.update(&amp;hashCtx, &amp;signedParams)) != <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> fail; <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> fail; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((err = SSLHashSHA1.final(&amp;hashCtx, &amp;hashOut)) != <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> fail; .... fail: SSLFreeBuffer(&amp;signedHashes); SSLFreeBuffer(&amp;hashCtx); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err; }</code> </pre> <br>  The problem lies in the two <i>goto</i> operators, located next to each other.  Only the first of these operators refers to the <i>if</i> operator, the second does not.  Thus, regardless of the values ‚Äã‚Äãof the previous conditions, the transition to the label <i>fail</i> will be made.  Due to the execution of the second <i>goto statement</i> , the <i>err</i> value will be successful.  This led to the fact that attackers could deceive the SSL server. <br><br>  PVS-Studio detects this problem using two diagnostic rules at once - <a href="https://www.viva64.com/ru/w/V640/">V640</a> and <a href="https://www.viva64.com/ru/w/V779/">V779</a> .  The warnings are as follows: <br><br><ul><li>  V640 The code's operational logic does not correspond with its formatting.  The statement is indented.  It is possible that curly brackets are missing. </li><li>  V779 Unreachable code detected.  It is possible that an error is present </li></ul><br>  Thus, the analyzer warns at once about several things that seemed suspicious to him: <br><br><ul><li>  The logic of the program does not match the design of the code: judging by the alignment, it seems that both <i>goto</i> operators belong to the <i>if</i> operator, but this is not so.  The first <i>goto statement is</i> indeed a condition, the second is not; </li><li>  presence of unreachable code: since the second <i>goto statement</i> is executed unconditionally, the code following it will not be executed. </li></ul><br>  It turns out that here PVS-Studio has successfully coped with its work. <br><br><h2>  Effective use of static analysis </h2><br>  The goal of this article, as I mentioned earlier, is to show that PVS-Studio successfully deals with the search for vulnerabilities.  The approach chosen to achieve this goal is to demonstrate that the analyzer successfully finds some known vulnerabilities.  The material above was necessary to confirm the fact that vulnerabilities can be searched using static analysis. <br><br>  Now I would like to talk about how to do it most effectively.  Ideally, vulnerabilities should be discovered before they become such (that is, when someone finds them and understands how to exploit them), and the sooner they are found, the better.  If used correctly, static vulnerability analysis can be detected even at the coding stage.  How this can be achieved will be described below. <br><br>  <b>Note.</b>  In this section, for consistency, I use the word "mistakes."  But simple mistakes, as we have seen, can be potential, and then valid vulnerabilities.  Please do not forget about it. <br><br>  In general, the earlier the error is detected and fixed, the cheaper the cost of fixing it.  The figure below shows the data from the book Applied Software Measurement from Capers Jones. <br><br><p><img src="https://habrastorage.org/getpro/habr/post_images/e78/524/19e/e7852419e90bd8a9b36219f93a5a985d.png" alt="Picture 1"></p><br><br>  As can be seen from the graphs, approximately 85% of errors are made at the coding stage, while the cost of correction at this stage is minimal.  At the same time, as the error exists in the program code, the cost of correcting it constantly increases, and if at the coding stage, the elimination of the error will cost about $ 25, then after the release of the software product, this figure increases to tens of thousands of dollars.  About the cost of vulnerabilities discovered after the release, even not worth it. <br><br>  From here follows a simple conclusion - the earlier the error is detected and corrected, the better.  The purpose of static analysis is to detect errors in the code as early as possible.  Static analysis is not a substitute for other software validation and verification tools, but complements them. <br><br>  How to get the maximum benefit from the use of a static analyzer?  The first rule - the code should be checked regularly.  Ideally, the error should be corrected at the stage of writing the code, before it is embedded in the version control system. <br><br>  However, it may be inconvenient to run constant checks on the developer‚Äôs machine.  In addition, the operation of checking the entire code can be quite long, which does not allow to frequently recheck the code after revisions.  In PVS-Studio, for this purpose, an <a href="https://www.viva64.com/ru/m/0024/">incremental analysis mode is</a> implemented, which allows analyzing only the code that has been changed / affected since the last build.  Moreover, this function allows you to run the analysis automatically after assembly, which allows the developer not to be distracted by the independent launch of the analysis.  After completion of the analysis, if errors were found in the modified files, the programmer will be given the appropriate notification. <br><br>  Even under the condition of such use, errors may occur in the version control system.  Therefore, you need to have a "second level of protection" - the use of a static analyzer on the build server.  For example, integrate code analysis into the nightly build process.  This will allow you to regularly check the projects at night, and in the morning to get information about what errors have entered the version control system.  The important point in this case is the need to quickly correct errors found in this way - preferably the next day.  Otherwise, over time, the appearance of new errors simply no one will pay attention, and there will be no sense from such checks. <br><br>  Implementing static analysis in the development process may seem like a non-trivial task if the project is not developed from scratch.  For information on how to properly start using static analysis in this case, see the article " <a href="https://www.viva64.com/ru/b/0309/">How to quickly implement static analysis in a large project?</a> " <br><br><h2>  Conclusion </h2><br>  I hope I managed to show you that: <br><br><ul><li>  even a seemingly simple bug can be a serious vulnerability; </li><li>  PVS-Studio successfully handles not only the search for errors in the code, but also the search for CWE and CVE. </li></ul><br>  And if the cost of a simple error in the code increases significantly over time, then there is nothing to say about the cost of vulnerabilities ... At the same time, if you use static analysis, many vulnerabilities can be fixed even before they get into the version control system, not to mention so that someone finds and exploits them. <br><br>  Finally, I would advise you to try <a href="https://www.viva64.com/ru/pvs-studio-download/">PVS-Studio</a> on your project - suddenly you will be able to find something interesting that will save your project from falling into CVE databases. <br><br><h2>  Additional links </h2><br><ul><li>  <a href="https://www.viva64.com/ru/b/0510/">We provide the PVS-Studio analyzer to security experts</a> ; </li><li>  <a href="https://www.viva64.com/ru/b/0486/">PVS-Studio: search for security defects</a> . </li><li>  <a href="https://www.viva64.com/ru/b/0496/">How to find 56 potential vulnerabilities in FreeBSD code in one evening</a> . </li><li>  <a href="https://www.viva64.com/ru/b/0508/">The PVS-Studio team is ready to work on the Tizen project</a> . </li><li>  <a href="https://www.viva64.com/ru/b/0309/">How to quickly implement static analysis in a large project?</a> </li></ul><br><br><div style="text-align:center;"> <a href="http://www.viva64.com/en/b/0514/"><img src="https://habrastorage.org/files/8d2/41b/5bf/8d241b5bf34747169141ed7c1997143b.png"></a> </div><br><br>  If you want to share this article with an English-speaking audience, then please use the link to the translation: Sergey Vasiliev.  <a href="http://www.viva64.com/en/b/0514/">How Can PVS-Studio Help in the Detection of Vulnerabilities?</a> <br><br><div class="spoiler">  <b class="spoiler_title">Read the article and have a question?</b> <div class="spoiler_text">  Often our articles are asked the same questions.  We collected answers to them here: <a href="http://www.viva64.com/ru/a/0085/">Answers to questions from readers of articles about PVS-Studio, version 2015</a> .  Please review the list. </div></div></div><p>Source: <a href="https://habr.com/ru/post/331262/">https://habr.com/ru/post/331262/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../331250/index.html">Malta as a new direction for IT professionals</a></li>
<li><a href="../331254/index.html">A brief description of BPMN with an example</a></li>
<li><a href="../331256/index.html">The story of the unexpected "scorching" and restore one smartphone</a></li>
<li><a href="../331258/index.html">Atmosphere at InfoWatch</a></li>
<li><a href="../331260/index.html">CocoaHeads Russia in Tutu.ru office</a></li>
<li><a href="../331264/index.html">Analytical tools: a review of lucrative offers</a></li>
<li><a href="../331266/index.html">Hosting provider paid a million dollars to ransomware hackers</a></li>
<li><a href="../331268/index.html">How to run add-on bitcoin blockchain</a></li>
<li><a href="../331270/index.html">Speed ‚Äã‚Äãreading: does it work or not? Part 1</a></li>
<li><a href="../331272/index.html">GraphicsJS - Graphic JavaScript Library</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>